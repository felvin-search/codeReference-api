{
  "elm": {
    "bubble sort": "\"module BubbleSort exposing (output)\\n\\nimport Util exposing (sortingOutputDef)\\n\\n\\nbubbleSort : List Int -> List Int\\nbubbleSort inputList =\\n    let\\n        bubble : List Int -> List Int -> List Int -> List Int\\n        bubble source tempList result =\\n            case source of\\n                h1 :: h2 :: tail ->\\n                    if h1 < h2 then\\n                        bubble (h2 :: tail) (h1 :: tempList) result\\n\\n                    else\\n                        bubble (h1 :: tail) (h2 :: tempList) result\\n\\n                h1 :: [] ->\\n                    sort tempList (h1 :: result)\\n\\n                [] ->\\n                    result\\n\\n        sort : List Int -> List Int -> List Int\\n        sort source result =\\n            if List.isEmpty source then\\n                result\\n\\n            else\\n                bubble source [] result\\n    in\\n    sort inputList []\\n\\n\\noutput : List String -> String\\noutput args =\\n    sortingOutputDef args bubbleSort\\n\"",
    "insertion sort": "\"module InsertionSort exposing (output)\\n\\nimport List exposing (head, singleton, tail)\\nimport Util\\n\\n\\ninsertionSort : List Int -> List Int\\ninsertionSort inputList =\\n    let\\n        insert : Int -> List Int -> List Int\\n        insert newEle sorted =\\n            case sorted of\\n                [] ->\\n                    singleton newEle\\n\\n                sortedHead :: sortedTail ->\\n                    if sortedHead < newEle then\\n                        sortedHead :: insert newEle sortedTail\\n\\n                    else\\n                        newEle :: sorted\\n    in\\n    case inputList of\\n        [] ->\\n            []\\n\\n        head :: tail ->\\n            insert head <| insertionSort tail\\n\\n\\noutput : List String -> String\\noutput args =\\n    Util.sortingOutputDef args insertionSort\\n\"",
    "merge sort": "\"module MergeSort exposing (..)\\n\\nimport List exposing (drop, length, take)\\nimport Util exposing (sortingOutputDef)\\n\\n\\ninsertInto : Int -> List Int -> List Int -> List Int\\ninsertInto toInsert lesserList greaterList =\\n    case greaterList of\\n        [] ->\\n            lesserList ++ [ toInsert ]\\n\\n        gHead :: gTail ->\\n            if toInsert > gHead then\\n                insertInto toInsert (lesserList ++ [ gHead ]) gTail\\n\\n            else\\n                lesserList ++ [ toInsert ] ++ greaterList\\n\\n\\nmergeJoin : List Int -> List Int -> List Int\\nmergeJoin firstHalf secondHalf =\\n    case firstHalf of\\n        [] ->\\n            secondHalf\\n\\n        fHead :: fTail ->\\n            mergeJoin fTail (insertInto fHead [] secondHalf)\\n\\n\\nmergeSort : List Int -> List Int\\nmergeSort inputList =\\n    case inputList of\\n        [] ->\\n            []\\n\\n        head :: [] ->\\n            [ head ]\\n\\n        _ ->\\n            mergeJoin (mergeSort <| take (length inputList // 2) inputList)\\n                (mergeSort <| drop (length inputList // 2) inputList)\\n\\n\\noutput : List String -> String\\noutput args =\\n    sortingOutputDef args mergeSort\\n\"",
    "selection sort": "\"module SelectionSort exposing (output)\\n\\nimport Util\\n\\n\\ngetNextMinVal : Int -> List Int -> ( Int, List Int )\\ngetNextMinVal comparedWith lst =\\n    case lst of\\n        [] ->\\n            ( comparedWith, [] )\\n\\n        h :: tail ->\\n            if comparedWith < h then\\n                let\\n                    recRes =\\n                        getNextMinVal comparedWith tail\\n                in\\n                ( Tuple.first recRes, h :: Tuple.second recRes )\\n\\n            else\\n                let\\n                    recRes =\\n                        getNextMinVal h tail\\n                in\\n                ( Tuple.first recRes, comparedWith :: Tuple.second recRes )\\n\\n\\nselectionSort : List Int -> List Int\\nselectionSort unsorted =\\n    case unsorted of\\n        [] ->\\n            []\\n\\n        h :: [] ->\\n            [ h ]\\n\\n        h :: tail ->\\n            let\\n                firstSorted =\\n                    getNextMinVal h tail\\n            in\\n            Tuple.first firstSorted :: selectionSort (Tuple.second firstSorted)\\n\\n\\noutput : List String -> String\\noutput args =\\n    Util.sortingOutputDef args selectionSort\\n\""
  }
}
