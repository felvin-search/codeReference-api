{
  "julia": {
    "prefix sum": "\"function prefix_sum(arr::Vector{T})where T<:Number\\n    pre=[]\\n    preans=zero(T)\\n    for i in arr\\n        preans+=i\\n        push!(pre,preans)\\n    end\\n    return pre\\nend\\n\"",
    "atbash": "\"\\\"\\\"\\\"\\r\\nencode(input)\\r\\n\\r\\nProgram to implement atbash cipher for the given sentence.A full description of the algorithm can be found on [wikipedia](https://en.wikipedia.org/wiki/Atbash)\\r\\n\\r\\n# Arguments:\\r\\n- `input` : The sentence needed to rotate\\r\\n\\r\\n# Examples/Tests \\r\\n```julia\\r\\njulia> encode(\\\"test\\\")\\r\\ngvhg\\r\\n\\r\\njulia> encode(\\\"abcdefghijklmnopqrstuvwxyz\\\")\\r\\nzyxwvutsrqponmlkjihgfedcba\\r\\n\\r\\njulia> encode(\\\"hello\\\")\\r\\nsvool\\r\\n\\r\\n```\\r\\n\\r\\n# Algorithm: \\r\\n\\r\\n```julia\\r\\n\\r\\nfor r in input\\r\\n    part *= xform(r)\\r\\n    if length(part) >= 5\\r\\n      push!(parts, part)\\r\\n      part = \\\"\\\"\\r\\n    end\\r\\n  end\\r\\n  if part != \\\"\\\"\\r\\n    push!(parts, part)\\r\\n  end\\r\\n  return join(parts, \\\" \\\")\\r\\n\\r\\n```\\r\\n\\r\\n# References:\\r\\nhttps://en.wikipedia.org/wiki/Atbash\\r\\n\\r\\n```\\r\\n\\r\\n# Contributed by:- [Ihjass Thasbekha](https://github.com/Ihjass)\\r\\n\\\"\\\"\\\"\\r\\nfunction encode(input)\\r\\n  input = replace(lowercase(input), reject_re => \\\"\\\")\\r\\n  parts = []\\r\\n  part = \\\"\\\"\\r\\n  for r in input\\r\\n    part *= xform(r)\\r\\n    if length(part) >= 5\\r\\n      push!(parts, part)\\r\\n      part = \\\"\\\"\\r\\n    end\\r\\n  end\\r\\n  if !isempty(part)\\r\\n\\r\\n    push!(parts, part)\\r\\n  end\\r\\n  return join(parts, \\\" \\\")\\r\\nend\\r\\nreject_re = r\\\"[^a-z\\\\d]+\\\"\\r\\nxform(r) = (r >= 'a' && r <= 'z') ? r = 25 - (r - 'a') + 'a' : r\\r\\n \\r\\n\"",
    "length conversion": "\"\\\"\\\"\\\"\\n    function length_conversion(value, from_type, to_type)\\n\\nA function that converts a value from a measurement unit to another one\\n\\nAccepted units are: millimeter(s), centimeter(s), meter(s), kilometer(s),\\ninch(es), feet, foot, yard(s), mile(s). Abbreviations are also supported.\\n\\n# Examples/Tests (optional but recommended)\\n```julia\\nlength_conversion(10, \\\"METERS\\\", \\\"cm\\\")\\nlength_conversion(12345, \\\"yards\\\", \\\"FEET\\\")\\n```\\n\\nBecause the algorithm converts values to meters, and from meters to the final type,\\nsome imperial system units may have errors:\\nlength_conversion(1, \\\"yards\\\", \\\"FEET\\\") returns 3.000000096, intead of 3.\\n\\n# Contributed by:- [Fernanda Kawasaki](https://github.com/fernandakawasaki)\\n\\\"\\\"\\\"\\n\\n# Lookup table that returns conversion of 1 unit of type to meters\\nMETER_CONVERSION = Dict{String,Float64}(\\n    \\\"mm\\\" => 0.001,\\n    \\\"cm\\\" => 0.01,\\n    \\\"m\\\" => 1,\\n    \\\"km\\\" => 1000,\\n    \\\"in\\\" => 0.0254,\\n    \\\"ft\\\" => 0.3048,\\n    \\\"yd\\\" => 0.9144,\\n    \\\"mi\\\" => 1609.34\\n)\\n\\n# Lookup table that returns the conversion of 1 meter to type\\nTYPE_CONVERSION = Dict{String,Float64}(\\n    \\\"mm\\\" => 1000,\\n    \\\"cm\\\" => 100,\\n    \\\"m\\\" => 1,\\n    \\\"km\\\" => 0.001,\\n    \\\"in\\\" => 39.3701,\\n    \\\"ft\\\" => 3.28084,\\n    \\\"yd\\\" => 1.09361,\\n    \\\"mi\\\" => 0.000621371\\n)\\n\\nNAME_CONVERSION = Dict{String,String}(\\n    \\\"millimeter\\\" => \\\"mm\\\",\\n    \\\"millimeters\\\" => \\\"mm\\\",\\n    \\\"centimeter\\\" => \\\"cm\\\",\\n    \\\"centimeters\\\" => \\\"cm\\\",\\n    \\\"meter\\\" => \\\"m\\\",\\n    \\\"meters\\\" => \\\"m\\\",\\n    \\\"kilometer\\\" => \\\"km\\\",\\n    \\\"kilometers\\\" => \\\"km\\\",\\n    \\\"inch\\\" => \\\"in\\\",\\n    \\\"inches\\\" => \\\"in\\\",\\n    \\\"feet\\\" => \\\"ft\\\",\\n    \\\"foot\\\" => \\\"ft\\\",\\n    \\\"yard\\\" => \\\"yd\\\",\\n    \\\"yards\\\" => \\\"yd\\\",\\n    \\\"mile\\\" => \\\"mi\\\",\\n    \\\"miles\\\" => \\\"mi\\\",\\n)\\n\\nfunction normalize_type(type)\\n    l_type = lowercase(type)\\n    if !haskey(METER_CONVERSION, l_type)\\n        if !haskey(NAME_CONVERSION, l_type)\\n            throw(\\n                error(\\n                    \\\"Invalid 'type' value: $(type)\\\\n\\\",\\n                    \\\"Supported values are: $(keys(NAME_CONVERSION))\\\\n\\\",\\n                    \\\"Supported abbreviations are: $(keys(METER_CONVERSION))\\\\n\\\",\\n                ),\\n            )\\n        end\\n        return NAME_CONVERSION[l_type]\\n    end\\n    return l_type\\nend\\n\\nfunction length_conversion(value, from_type, to_type)\\n    from_type_norm = normalize_type(from_type)\\n    to_type_norm = normalize_type(to_type)\\n    value_in_meters = value * METER_CONVERSION[from_type_norm]\\n    return value_in_meters * TYPE_CONVERSION[to_type_norm]\\nend\\n\"",
    "temparature conversion": "\"\\\"\\\"\\\"\\ncelsius_to_fahrenheit(celsius, ndigits::Int = 2)\\n\\nConverts celsius to fahrenheit and round to 2 decimal places\\n\\n# Example\\n\\n```julia\\ncelsius_to_fahrenheit(273.354, 3) == 524.037  # returns true\\ncelsius_to_fahrenheit(273.354, 0) == 524.0    # returns true\\ncelsius_to_fahrenheit(-40.0) == -40.0         # returns true\\ncelsius_to_fahrenheit(-20.0) == -4.0          # returns true\\ncelsius_to_fahrenheit(0) == 32.0              # returns true\\ncelsius_to_fahrenheit(20) == 68.0             # returns true\\n```\\n\\\"\\\"\\\"\\nfunction celsius_to_fahrenheit(celsius, ndigits::Int = 2)\\n    return round((float(celsius) * 1.8) + 32.0; digits = ndigits)\\nend\\n\\n\\\"\\\"\\\"\\nfunction celsius_to_kelvin(celsius, ndigits::Int = 2)\\n\\nConverts celsius to kelvin and round to 2 decimal places\\n\\n# Example\\n\\n```julia\\ncelsius_to_kelvin(273.354, 3) == 546.504    # returns true\\ncelsius_to_kelvin(273.354, 0) == 547.0      # returns true\\ncelsius_to_kelvin(0.0) == 273.15            # returns true\\ncelsius_to_kelvin(20.0) == 293.15           # returns true\\n```\\n\\n\\\"\\\"\\\"\\nfunction celsius_to_kelvin(celsius, ndigits::Int = 2)\\n\\n    return round(float(celsius) + 273.15; digits = ndigits)\\nend\\n\\n\\n\\\"\\\"\\\"\\nfahrenheit_to_celsius(fahrenheit, ndigits::Int = 2)\\n\\nConverts fahrenheit to celsius and round to 2 decimal places\\n\\n# Example\\n\\n```julia\\nfahrenheit_to_celsius(273.354, 3) == 134.086 # returns true\\nfahrenheit_to_celsius(273.354, 0) == 134.0   # returns true\\nfahrenheit_to_celsius(0.0) == -17.78         # returns true\\nfahrenheit_to_celsius(20.0) == -6.67         # returns true\\nfahrenheit_to_celsius(40.0) == 4.44          # returns true\\nfahrenheit_to_celsius(60.0) == 15.56         # returns true\\nfahrenheit_to_celsius(80.0) == 26.67         # returns true\\n```\\n\\\"\\\"\\\"\\nfunction fahrenheit_to_celsius(fahrenheit, ndigits::Int = 2)\\n    return round((float(fahrenheit) - 32.0) * 5 / 9; digits = ndigits)\\nend\\n\\n\\n\\n\\\"\\\"\\\"\\nfahrenheit_to_kelvin(fahrenheit, ndigits::Int = 2)\\n\\nConverts fahrenheit to kelvin and round to 2 decimal places\\n\\n# Example\\n\\n```julia\\nfahrenheit_to_kelvin(273.354, 3) == 407.236 # returns true\\nfahrenheit_to_kelvin(273.354, 0) == 407.0   # returns true\\nfahrenheit_to_kelvin(0) == 255.37           # returns true\\nfahrenheit_to_kelvin(20.0) == 266.48        # returns true\\nfahrenheit_to_kelvin(40.0) == 277.59        # returns true\\nfahrenheit_to_kelvin(60.0) == 288.71        # returns true\\nfahrenheit_to_kelvin(80.0) == 299.82        # returns true\\n```\\n\\\"\\\"\\\"\\nfunction fahrenheit_to_kelvin(fahrenheit, ndigits::Int = 2)\\n    round(((float(fahrenheit) - 32.0) * 5 / 9) + 273.15; digits = ndigits)\\nend\\n\\n\\n\\\"\\\"\\\"\\nfunction kelvin_to_celsius(kelvin, ndigits::Int = 2)\\n\\nConverts kelvin to celsius and round to 2 decimal places\\n\\n# Example\\n\\n```julia\\nkelvin_to_celsius(273.354, 3) == 0.204   # returns true\\nkelvin_to_celsius(273.354, 0) == 0.0     # returns true\\nkelvin_to_celsius(273.15) == 0.0         # returns true\\nkelvin_to_celsius(300) == 26.85          # returns true\\n```\\n\\\"\\\"\\\"\\nfunction kelvin_to_celsius(kelvin, ndigits::Int = 2)\\n    return round(float(kelvin) - 273.15; digits = ndigits)\\nend\\n\\n\\n\\n\\\"\\\"\\\"\\nfunction kelvin_to_fahrenheit(kelvin, ndigits::Int = 2)\\n\\nConverts kelvin to fahrenheit and round to 2 decimal places\\n\\n# Example\\n\\n```julia\\nkelvin_to_fahrenheit(273.354, 3) == 32.367  # returns true\\nkelvin_to_fahrenheit(273.354, 0) == 32.0    # returns true\\nkelvin_to_fahrenheit(273.15) == 32.0        # returns true\\nkelvin_to_fahrenheit(300) == 80.33          # returns true\\n```\\n\\\"\\\"\\\"\\nfunction kelvin_to_fahrenheit(kelvin, ndigits::Int = 2)\\n    round(((float(kelvin) - 273.15) * 1.8) + 32.0; digits = ndigits)\\nend\\n\"",
    "weight conversion": "\"KILOGRAM_CHART = Dict{String,Float64}(\\n    \\\"kilogram\\\" => 1.0,\\n    \\\"gram\\\" => 10^3,\\n    \\\"milligram\\\" => 10^6,\\n    \\\"metric-ton\\\" => 10^-3,\\n    \\\"long-ton\\\" => 0.0009842073,\\n    \\\"short-ton\\\" => 0.0011023122,\\n    \\\"pound\\\" => 2.2046244202,\\n    \\\"ounce\\\" => 35.273990723,\\n    \\\"carrat\\\" => 5000.0,\\n    \\\"atomic-mass-unit\\\" => 6.022136652e26,\\n)\\n\\nWEIGHT_TYPE_CHART = Dict{String,Float64}(\\n    \\\"kilogram\\\" => 1.0,\\n    \\\"gram\\\" => 10^-3,\\n    \\\"milligram\\\" => 10^-6,\\n    \\\"metric-ton\\\" => 10^3,\\n    \\\"long-ton\\\" => 1016.04608,\\n    \\\"short-ton\\\" => 907.184,\\n    \\\"pound\\\" => 0.453592,\\n    \\\"ounce\\\" => 0.0283495,\\n    \\\"carrat\\\" => 0.0002,\\n    \\\"atomic-mass-unit\\\" => 1.660540199e-27,\\n)\\n\\nfunction weight_conversion(from_type, to_type, value)\\n    if !haskey(KILOGRAM_CHART, to_type) || !haskey(WEIGHT_TYPE_CHART, from_type)\\n        throw(\\n            error(\\n                \\\"Invalid 'from_type' or 'to_type' value: $(from_type), $(to_type)\\\\n\\\",\\n                \\\"Supported values are: $(WEIGHT_TYPE_CHART)\\\",\\n            ),\\n        )\\n    end\\n    return value * KILOGRAM_CHART[to_type] * WEIGHT_TYPE_CHART[from_type]\\nend\\n\"",
    "dynamic programming": "\"\\\"\\\"\\\"\\n    zero_one_pack!(capacity::N, weights::V, values::V, dp::V) where {N <: Number,V <: AbstractVector}\\nThis does 0-1 (each item can be chosen only once) knapsack :\\npack capacity = capacity\\nweight of each item = weights\\nvalue of each item = values\\ndp array is what the function works on\\nIt returns the ans (dp[capacity])\\n```\\njulia> dp=zeros(Int,30)\\njulia> zero_one_pack!(20,[1,3,11],[2,5,30],dp)\\n37\\n```\\n\\\"\\\"\\\"\\nfunction zero_one_pack!(capacity::N, weights::V, values::V, dp::V\\n) where {N <: Number,V <: AbstractVector}\\n    for i in 1:length(weights)\\n        j = capacity\\n        while j > weights[i] # reversed loop\\n            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])\\n            j -= 1\\n        end\\n        dp[weights[i]] = max(dp[weights[i]], values[i]) # dp[j]=max(dp[j],dp[0]+values[i])\\n    end\\n    return dp[capacity]\\nend\\n\\n\\\"\\\"\\\"\\nThis does complete/infinite (each item can be chosen infinite times) knapsack :\\npack capacity = capacity\\nweight of each item = weights\\nvalue of each item = values\\ndp array is what the function works on\\nIt returns the ans (dp[capacity])\\n```\\njulia> dp=zeros(Int,30)\\njulia> complete_pack!(20,[1,2,9],[1,3,20],dp)\\n43\\n```\\n\\\"\\\"\\\"\\nfunction complete_pack!(capacity::N, weights::V, values::V, dp::V\\n) where {N <: Number,V <: AbstractVector}\\n    for i in 1:length(weights)\\n        dp[weights[i]] = max(dp[weights[i]], values[i]) # dp[j]=max(dp[j],dp[0]+values[i])\\n        for j in weights[i] + 1:capacity\\n            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])\\n        end\\n    end\\n    return dp[capacity]\\nend\\n\"",
    "greedy algorithm": "\"\\\"\\\"\\\"\\nFor greedy algorithm, it will take the element based on the optimal value in the array at each loop in the function\\n\\nThis does 0-1 (each item can be chosen only once) knapsack :\\npack capacity = capacity\\nweight of each item = weights\\nvalue of each item = values\\n\\nEach loop the function will find the highest value in the array and check if the capacity is enough to store it, if enough then \\nthe value will be added into the total_max_value. \\nAfter that the highest current value will be deleted.\\n\\n```\\njulia> zero_one_pack!(20,[1,3,11],[2,5,30])\\n37\\n```\\n\\\"\\\"\\\"\\nfunction zero_one_pack!(capacity::N, weights::V, values::V\\n) where {N <: Number,V <: AbstractVector}\\n    total_max_value = 0\\n    while capacity > 0 && (length(weights)!=0 || length(values)!=0)\\n        max_value, index = findmax(values) # get the highest value and index in the vector\\n        if capacity >= weights[index]\\n            total_max_value += max_value \\n            capacity -= weights[index]\\n        end\\n        splice!(values, index)\\n        splice!(weights, index)\\n    end\\n    return total_max_value\\nend\\n\\n\\\"\\\"\\\"\\nThis does complete/infinite (each item can be chosen infinite times) knapsack :\\npack capacity = capacity\\nweight of each item = weights\\nvalue of each item = values\\n\\nEach loop the function will find the highest value in the array and check if the capacity is enough to store it, if enough then \\nthe value will be added into the total_max_value until the capacity cannot hold the weight of the highest current value. \\nAfter that the highest current value will be deleted.\\n\\n```\\njulia> complete_pack!(20,[1,2,9],[1,3,20])\\n43\\n```\\n\\\"\\\"\\\"\\nfunction complete_pack!(capacity::N, weights::V, values::V\\n) where {N <: Number,V <: AbstractVector}\\n    total_max_value = 0\\n    while capacity > 0 && (length(weights)!=0 || length(values)!=0)\\n        max_value, index = findmax(values)\\n        while capacity >= weights[index] \\n            total_max_value += max_value \\n            capacity -= weights[index]\\n        end\\n        splice!(values, index)\\n        splice!(weights, index)\\n    end\\n    return total_max_value\\nend\"",
    "abs": "\"\\n\\\"\\\"\\\"\\n    abs_val(num)\\n\\nProgram to find the absolute value of a number\\n\\n# Example\\n```julia\\nabs_val(-100) # returns 100\\nabs_val(0) # returns 0\\nabs(123.1) # returns 123.1\\n-1000 == abs_val(-1000) #returns false\\n1000 == abs_val(1000) #returns true\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction abs_val(num::N)where N<:Real\\n    return num < 0 ? -num : num\\nend\\n\\n\\n\\\"\\\"\\\"\\n    abs_max(x)\\n\\nProgram to find the max absolute value in a vector\\n\\n# Example\\n```julia\\nabs_max([1,3,4]) # returns 4\\nabs_max([-3,1,2]) # returns -3\\nabs_max([-7,-3,6]) #returns -7\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction abs_max(x::Vector{N})where N<:Real\\n    _max=x[1]\\n    for i in x\\n        if abs(i)>abs(_max) _max=i end\\n    end\\n    return _max\\nend\\n\\n\\\"\\\"\\\"\\n    abs_min(num)\\n\\nProgram to find the min absolute value in a vector\\n\\n# Example\\n```julia\\nabs_min([1,3,4]) # returns 1\\nabs_min([-3,1,2]) # returns 1\\nabs_min([-7,-3,6]) #returns -3\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction abs_min(x::Vector{N})where N<:Real\\n    _min=x[1]\\n    for i in x\\n        if abs(i)<abs(_min) _min=i end\\n    end\\n    return _min\\nend\\n\"",
    "area": "\"# Functions for area of various geometric shapes\\n# Contributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee)\\n\\n\\\"\\\"\\\"\\n    surfarea_cube(side)\\n\\nFinds surface area of a cube\\n\\n# Example\\n\\n```julia\\nsurfarea_cube(1)  # returns 6\\nsurfarea_cube(3)  # returns 54\\nsurfarea_cube(-1) # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction surfarea_cube(side)\\n    if side < 0\\n        throw(DomainError(side, \\\"surfarea_cube() only works for non-negative values\\\"))\\n    end\\n    return 6(side^2)\\nend\\n\\n\\\"\\\"\\\"\\n    surfarea_sphere(side)\\n\\nFinds surface area of a sphere\\n\\n# Example\\n\\n```julia\\nsurfarea_sphere(5)  # returns 314.1592653589793\\nsurfarea_sphere(1)  # returns 12.566370614359172\\nsurfarea_sphere(-1) # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction surfarea_sphere(radius)\\n    if radius < 0\\n        throw(DomainError(radius, \\\"surfarea_sphere() only works for non-negative values\\\"))\\n    end\\n    return 4π * (radius^2)\\nend\\n\\n\\\"\\\"\\\"\\n    area_rectangle(length, width)\\n\\nFinds area of the rectangle\\n\\n# Example\\n\\n```julia\\narea_rectangle(10,20) # returns 200\\narea_rectangle(-1,-2) # returns DomainError\\narea_rectangle(1,-2)  # returns DomainError\\narea_rectangle(-1,2)  # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction area_rectangle(length, width)\\n    if length < 0 || width < 0\\n        throw(DomainError(\\\"area_rectangle() only works for non-negative values\\\"))\\n    end\\n    return length * width\\nend\\n\\n\\\"\\\"\\\"\\n    area_square(side)\\n\\nFinds area of the area_square\\n\\n# Example\\n\\n```julia\\narea_square(10) # returns 100\\narea_square(-1) # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction area_square(side)\\n    if side < 0\\n        throw(DomainError(\\\"area_square() only works for non-negative values\\\"))\\n    end\\n    return side^2\\nend\\n\\n\\\"\\\"\\\"\\n    area_triangle(base, height)\\n\\nFinds area of the right angled triangle with base height\\n\\n# Example\\n\\n```julia\\narea_triangle(10,10) # returns 50.0\\narea_triangle(-1,-2) # returns DomainError\\narea_triangle(1,-2)  # returns DomainError\\narea_triangle(-1,2)  # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction area_triangle(base, height)\\n    if base < 0 || height < 0\\n        throw(DomainError(\\\"area_triangle() only accepts non-negative values\\\"))\\n    end\\n    return (base * height) / 2\\nend\\n\\n\\\"\\\"\\\"\\n    area_heron_triangle(side1, side2, side3)\\n\\nFinds area of a triangle using heron's formula\\n\\n# Example\\n\\n```julia\\narea_heron_triangle(5,12,13) # returns 30.0\\narea_heron_triangle(-1,-2,1) # returns DomainError\\narea_heron_triangle(1,-2,1)  # returns DomainError\\narea_heron_triangle(-1,2,1)  # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction area_heron_triangle(side1, side2, side3)\\n    if side1 < 0 || side2 < 0 || side3 < 0\\n        throw(DomainError(\\\"area_triangle_three_sides() only accepts non-negative values\\\"))\\n    elseif side1 + side2 < side3 || side1 + side3 < side2 || side2 + side3 < side1\\n        throw(DomainError(\\\"Given three sides do not form a triangle\\\"))\\n    end\\n    semi_perimeter = (side1 + side2 + side3) / 2\\n    area = sqrt(\\n        semi_perimeter\\n        * (semi_perimeter - side1)\\n        * (semi_perimeter - side2)\\n        * (semi_perimeter - side3)\\n    )\\n    return area\\nend\\n\\n\\\"\\\"\\\"\\n    area_parallelogram(base, height)\\n\\nFinds area of the parallelogram\\n\\n# Example\\n\\n```julia\\narea_parallelogram(10,20) # returns 200\\narea_parallelogram(-1,-2) # returns DomainError\\narea_parallelogram(1,-2)  # returns DomainError\\narea_parallelogram(-1,2)  # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction area_parallelogram(base, height)\\n\\n    if base < 0 || height < 0\\n        throw(DomainError(\\\"area_parallelogram() only accepts non-negative values\\\"))\\n    end\\n    return base * height\\nend\\n\\n\\\"\\\"\\\"\\narea_trapezium(base1,base2,height)\\n\\nFinds area of the traπzium\\n\\n# Example\\n\\n```julia\\narea_trapezium(10, 20, 30)  # returns 450.0\\narea_trapezium(-1, -2, -3)  # returns DomainError\\narea_trapezium(-1, 2, 3)    # returns DomainError\\narea_trapezium(1, -2, 3)    # returns DomainError\\narea_trapezium(1, 2, -3)    # returns DomainError\\narea_trapezium(-1, -2, 3)   # returns DomainError\\narea_trapezium(1, -2, -3)   # returns DomainError\\narea_trapezium(-1, 2, -3)   # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction area_trapezium(base1, base2, height)\\n    if base1 < 0 || base2 < 0 || height < 0\\n        throw(DomainError(\\\"area_trapezium() only accepts non-negative values\\\"))\\n    end\\n    return 1 / 2 * (base1 + base2) * height\\nend\\n\\n\\\"\\\"\\\"\\n    area_circle(radius)\\n\\nFinds area of the circle\\n\\n# Example\\n\\n```julia\\narea_circle(20) # returns 1256.6370614359173\\narea_circle(-1) # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction area_circle(radius)\\n    if radius < 0\\n        throw(DomainError(\\\"area_circle() only accepts non-negative values\\\"))\\n    end\\n    return π * radius^2\\nend\\n\\n\\\"\\\"\\\"\\n    area_ellipse(radius_x, radius_y)\\n\\nFinds area of the ellipse\\n\\n# Example\\n\\n```julia\\narea_ellipse(10, 10) # returns 314.1592653589793\\narea_ellipse(10, 20) # returns 628.3185307179587\\narea_ellipse(1, -2) # returns DomainError\\narea_ellipse(-1, 2) # returns DomainError\\narea_ellipse(-1, -2) # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction area_ellipse(radius_x, radius_y)\\n    if radius_x < 0 || radius_y < 0\\n        throw(DomainError(\\\"area_ellipse() only accepts non-negative values\\\"))\\n    end\\n    return π * radius_x * radius_y\\nend\\n\\n\\\"\\\"\\\"\\n    area_rhombus(diagonal_1, diagonal_2)\\n\\nFinds area of the rhombus\\n\\n# Example\\n\\n```julia\\narea_rhombus(10, 20) # returns 100.0\\narea_rhombus(-1,-2) # returns DomainError\\narea_rhombus(1,-2)  # returns DomainError\\narea_rhombus(-1,2)  # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction area_rhombus(diagonal_1, diagonal_2)\\n    if diagonal_1 < 0 || diagonal_2 < 0\\n        throw(DomainError(\\\"area_rhombus() only accepts non-negative values\\\"))\\n    end\\n    return 1 / 2 * diagonal_1 * diagonal_2\\nend\\n\\n\\\"\\\"\\\"\\n    trapazoidal_area(f, x_start, x_end, steps)\\n\\nApproximates the area under the curve using the trapezoidal rule\\nArguments:\\n - f: function for the\\n - x_start: starting value for x\\n - x_end: ending value for x\\n - steps: steps taken while integrating.\\n\\\"\\\"\\\"\\nfunction trapazoidal_area(f, x_start, x_end, steps)\\n\\tx1 = x_start\\n\\tfx1 = f(x_start)\\n\\tarea = 0.0\\n\\n\\tfor _ in 1:steps\\n\\t\\tx2 = ((x_end - x_start) / steps) + x1\\n\\t\\tfx2 = f(x2)\\n\\t\\tarea += abs(fx2 + fx1) * (x2 - x1) / 2\\n\\t\\tx1 = x2\\n\\t\\tfx1 = fx2\\n\\tend\\n\\n\\treturn area\\nend\\n\"",
    "armstrong number": "\"\\\"\\\"\\\"\\n    is_armstrong(x)\\n\\nProgram to check if a number is an [Armstrong/Narcissistic number](https://en.wikipedia.org/wiki/Narcissistic_number) in decimal system.\\n\\nArmstrong number is a number that is the sum of its own digits raised to the power of the number of digits.\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee)\\n\\nA positive integer is called an Armstrong number (of order n) if\\n\\n`abcd... = a^n + b^n + c^n + d^n +....`\\n\\\"\\\"\\\"\\nfunction is_armstrong(x)\\n    # If the number is less than 0, then it is not a armstrong number.\\n    if x < 0\\n        return false\\n    elseif x == 0\\n        return true\\n    else\\n        # Finding the total number of digits in the number\\n        length = Int(floor(log10(x) + 1))\\n        result = 0\\n        temp = x\\n        for i in 1:length\\n            val = temp % 10\\n            # Finding each digit raised to the power total digit and add it to the total sum\\n            result = result + Int(trunc(val))^length\\n            temp = temp / 10\\n        end\\n        return x == result ? true : false\\n    end\\nend\\n\"",
    "average mean": "\"\\\"\\\"\\\"\\n    mean(nums)\\n\\nFind mean of a vector of numbers\\n\\n# Example\\n\\n```julia\\nmean([3, 6, 9, 12, 15, 18, 21])      # returns 12.0\\nmean([5, 10, 15, 20, 25, 30, 35])    # returns 20.0\\nmean([1, 2, 3, 4, 5, 6, 7, 8])       # returns 4.5\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction mean(nums::Vector{T})where T<:Number\\n    return sum(nums) / length(nums)\\nend\\n\"",
    "average median": "\"\\\"\\\"\\\"\\n    median(nums)\\n\\nFinds median of a vector of numbers\\n\\n## Example\\n\\n```julia\\nmedian([2,1,3,4])                   # returns 2.5\\nmedian([2, 70, 6, 50, 20, 8, 4])    # returns 8\\nmedian([0])                         # returns 0\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction median(nums::Vector{T})where T<:Number\\n    sorted = sort(nums)\\n    len = length(sorted)\\n    mid_index = div(len,2)\\n    return len % 2 == 0 ? (sorted[mid_index + 1] + sorted[mid_index]) / 2 : sorted[mid_index + 1]\\nend\\n\"",
    "average mode": "\"\\\"\\\"\\\"\\n    mode(nums)\\n\\nFinds mode of a vector of numbers\\n\\n# Example\\n\\n```julia\\nmode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])        # returns [2]\\nmode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])        # returns [2]\\nmode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])  # returns [2, 4]\\nmode([\\\"x\\\", \\\"y\\\", \\\"y\\\", \\\"z\\\"])                              # returns [\\\"y\\\"]\\nmode([\\\"x\\\", \\\"x\\\" , \\\"y\\\", \\\"y\\\", \\\"z\\\"])                       # returns [\\\"x\\\", \\\"y\\\"]\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee)\\n\\\"\\\"\\\"\\nfunction mode(nums)\\n    dict = Dict() # nums => Number of repetitions\\n    result = [] # Array of the modes so far\\n    max = 0 # Max of repetitions so far\\n\\n    for i in nums\\n        # Add one to the dict[i] entry (create one if none)\\n        if i in keys(dict)\\n            dict[i] += 1\\n        else\\n            dict[i] = 1\\n        end\\n        # Result updated if no of repetitions of i >= max\\n        if dict[i] >= max\\n            if dict[i] > max\\n                empty!(result)\\n                max += 1\\n            end\\n            append!(result, [i])\\n        end\\n    end\\n\\n    return result\\nend\\n\"",
    "babylonian sqrt": "\"\\\"\\\"\\\"\\n    bab_sqrt(S::Real; tolerance = 1e-6, guess = nothing)\\n\\nThe Babylonian Method of calculating a square root is a simple iterative method to determine square roots. A full description of the algorithm can be found on [Wikipedia](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n\\n# Arguments:\\n- `S`: The number to calculate the square root for.\\n\\n# Positional Arguments\\n- `tolerance`: How close the square of the square root needs to be from the input value. `abs(S - xn^2) < tolerance`\\n- `guess`: The initial value to use for `xn`\\n\\n# Examples/Tests \\n```julia\\njulia> bab_sqrt(100)\\n10.000000000107445\\n\\njulia> bab_sqrt(100, guess = 15)\\n10.000000000131072\\n\\njulia> bab_sqrt(π, guess = 1)\\n1.7724538555800293\\n\\njulia> bab_sqrt(π, guess = 1, tolerance = 2)\\n2.0707963267948966\\n```\\n\\n# Algorithm: \\n\\n```julia\\nwhile tolerance <= abs(xn^2 - S)\\n    xn = (1 / 2) * (xn + S / xn)\\nend\\n```\\n\\n# References:\\n[Methods of computing square roots](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n\\n```\\n\\n# Contributed by:- [Anson Biggs](https://ansonbiggs.com) \\n\\\"\\\"\\\"\\nfunction bab_sqrt(S::Real; tolerance = 1e-6, guess = nothing)\\n\\n    # Can only calculate for positive numbers\\n    if S < 0\\n        throw(DomainError(\\\"Input must be greater than zero\\\"))\\n    end\\n\\n    xn = guess\\n    if xn === nothing\\n        xn = S / 2\\n    elseif xn < 0\\n        xn = abs(xn)\\n    end\\n\\n    while tolerance <= abs(xn^2 - S)\\n        xn = (1 / 2) * (xn + S / xn)\\n    end\\n    return xn\\n\\nend\\n\"",
    "ceil floor": "\"\\\"\\\"\\\"\\n    ceil_val(x)\\n\\nFinds the ceiling of x as an functionInteger\\n\\n# Example\\n```julia\\nceil_val(1.3)   # 2.0\\nceil_val(2.0)   # returns 2.0\\nceil_val(-1.5)  #returns -1.0\\n```\\n\\n# Reference\\n- https://en.wikipedia.org/wiki/Floor_and_ceiling_functions\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee)\\n\\\"\\\"\\\"\\nceil_val(x) = x - trunc(x) <= 0 ? trunc(x) : trunc(x) + 1\\n\\n\\\"\\\"\\\"\\n    floor_val(x)\\n\\nFinds the floor of x as an Integer\\n\\n# Example\\n```julia\\nfloor_val(1.3)  # 1\\nfloor_val(2.0)  # returns 2.0\\nfloor_val(-1.7) # returns -2.0\\n```\\n\\n# Reference\\n- https://en.wikipedia.org/wiki/Floor_and_ceiling_functions\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee)\\n\\\"\\\"\\\"\\nfloor_val(x) = x - trunc(x) >= 0 ? trunc(x) : trunc(x) - 1\\n\"",
    "collatz sequence": "\"\\\"\\\"\\\"\\n    collatz_sequence(n)\\n\\nCollatz conjecture: start with any positive integer n. The next term is\\nobtained as follows:\\n\\tIf n term is even, the next term is: n / 2 .\\n\\tIf n is odd, the next term is: 3 * n + 1.\\nThe conjecture states the sequence will always reach 1 for any starting value n.\\n\\\"\\\"\\\"\\n\\nfunction collatz_sequence(n::N)where N<:Integer\\n\\tsequence = [n]\\n\\twhile n != 1\\n\\t\\tn = n % 2 == 1 ? 3 * n + 1 : div(n, 2)\\n\\t\\tappend!(sequence, n)\\n\\tend\\n\\treturn sequence\\nend\\n\"",
    "combination": "\"\\\"\\\"\\\"\\n    combination(n, r)\\n        \\nreturns the number of ways picking r unordered outcomes from\\nn possibilities, without repetition\\n\\n# Arguments:\\n- `n`: Positive integers of items to choose from\\n- 'r': Positive integers of items to choose\\n\\nContributed By:- [Mayur Dahibhate](https://github.com/mayurdahibhate)\\n\\\"\\\"\\\"\\n\\nfunction combination(n, r)\\n\\n    function factorial(n)        \\n        fact = 1\\n        \\n        if n == 0 || n == 1\\n            return fact\\n        end\\n         \\n        for i = 1:n\\n            fact = fact * i\\n        end \\n        \\n        return fact\\n    end\\n    \\n    comb = factorial(n) / (factorial(r) * factorial(n - r))\\n\\n    return convert(Int64, comb)\\nend\\n\"",
    "euler method": "\"\\\"\\\"\\\"\\n    euler_method(f, x0, span, h=1.0e-2)\\n\\nCalculate the solution to a differential equation using forward euler method.\\n\\\"\\\"\\\"\\nfunction euler_method(f, x0, span, h=1.0e-2)\\n    s, e = span\\n    steps = floor((e - s) / h) |> Int\\n    x = Vector{Float64}(undef, steps)\\n\\tt = Vector{Float64}(undef, steps)\\n    x[1] = x0\\n\\tt[1] = 0\\n    for i in 1:(steps - 1)\\n        x[i + 1] = x[i] + h * f(x[i], t[i])\\n\\t\\tt[i + 1] = t[i] + h\\n    end\\n    return x, t\\nend\\n\"",
    "factorial": "\"\\\"\\\"\\\"\\n    factorial_iterative(n)\\n\\nFinds factorial of a number using Iterative method\\n\\n# Example\\n```julia\\nfactorial_iterative(5)      # returns 120\\nfactorial_iterative(-1)     # returns error\\n```\\n# Reference\\n- factorial of a positive integer -- https://en.wikipedia.org/wiki/Factorial\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction factorial_iterative(n::N)where N<:Integer\\n    if n < 0\\n        throw(error(\\\"factorial_iterative() only accepts non-negative integral values\\\"))\\n    end\\n    if n==0 || n==1\\n        return one(BigInt)\\n    end\\n    return n*factorial_iterative(n-1)\\nend\\n\\n\\\"\\\"\\\"\\n    factorial_recursive(n)\\n\\nFinds factorial of anumber using recursive method\\n\\n# Example\\n```julia\\nfactorial_recursive(5)      # returns 120\\n```\\n# Reference\\n- factorial of a positive integer -- https://en.wikipedia.org/wiki/Factorial\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction factorial_recursive(n::N)::BigInt where N<:Integer\\n    if n < 0\\n        throw(error(\\\"factorial_iterative() only accepts non-negative integral values\\\"))\\n    end\\n    if n == 0 || n == 1\\n        return one(BigInt)\\n        # keep same result type\\n    else\\n        factorial=one(BigInt)\\n        for i in 1:n\\n            factorial*=i\\n        end\\n        return factorial\\n    end\\nend\\n\"",
    "krishnamurthy number": "\"include(\\\"factorial.jl\\\")\\n\\n\\\"\\\"\\\"\\n    krishnamurthy(number)\\n\\nCheck if a number is a Krishnamurthy number or not\\n\\n# Details\\n\\nIt is also known as Peterson Number. \\n\\nA Krishnamurthy Number is a number whose sum of the\\nfactorial of the digits equals to the original\\nnumber itself.\\n\\nFor example: 145 = 1! + 4! + 5!\\n    So, 145 is a Krishnamurthy Number\\n\\n# Example\\n\\n```julia\\nkrishnamurthy(145) # returns true\\nkrishnamurthy(240) # returns false\\nkrishnamurthy(1)   # returns true \\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee)\\n\\\"\\\"\\\"\\nfunction krishnamurthy(number)\\n    if number != trunc(number) || number < 0\\n        throw(error(\\\"krishnamurthy() only accepts non-negative integral values\\\"))\\n    end\\n    total = 0\\n    temp = number\\n    while temp > 0\\n        temp, digit = divrem(temp, 10)\\n        total += factorial_iterative(digit)\\n    end\\n    return total == number\\nend\\n\"",
    "line length": "\"\\\"\\\"\\\"\\n    line_length(f, x_start, x_end, steps=100)\\n\\nApproximates the arc length of a line segment by treating the curve as a\\nsequence of linear lines and summing their lengths.\\n\\nArguments:\\n - f: function that returns the arc\\n - x_start: starting x value\\n - x_end: ending x_value\\n - steps: steps to take for accurace, more the steps greater the accuracy\\n\\\"\\\"\\\"\\nfunction line_length(f, x_start, x_end, steps=100)\\n\\tx1 = x_start\\n\\tfx1 = f(x1)\\n\\tlen = 0.0\\n\\n\\tfor step in 1:steps\\n\\t\\tx2 = ((x_end - x_start) / steps) + x1\\n\\t\\tfx2 = f(x2)\\n\\t\\tlen += hypot(x2 - x1, fx2 - fx1)\\n\\n\\t\\tx1 = x2\\n\\t\\tfx1 = fx2\\n\\tend\\n\\n\\treturn len\\nend\\n\"",
    "monte carlo integration": "\"\\\"\\\"\\\"\\n    monte_carlo_integration(f::Function, a::Real, b::Real, n::Int)\\n\\nMonte carlo integration is a very easy and scalable way to do multidimentional integrals.\\nHowever, only single variable integrals are considered.\\n\\n# Arguments\\n- `f`: the function to integrate. (at the momment only single variable is suported)\\n- `a`: start in the integration limits.\\n- `b`: endin the integration limits.\\n- `N`: Number of points to sample. For most simple functions, 1000 to 10,000 should be okay.\\n\\n# Examples\\n```julia\\njulia> monte_carlo_integration(x -> 3*x^2, 0, 1, 100000) # integrate a polynomial\\n1.0000037602209\\n\\njulia> monte_carlo_integration(x -> sin(x), 0, pi, 1000) # integrate the sin function\\n2.0018927826323756\\n```\\n\\n# References\\n- https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration\\n- https://kingaa.github.io/sbied/pfilter/monteCarlo.html\\n\\n# Contributors\\n- [AugustoCL](https://github.com/AugustoCL)\\n- [Ved Mahajan](https://github.com/Ved-Mahajan)\\n\\\"\\\"\\\"\\nfunction monte_carlo_integration(f::Function, a::Real, b::Real, n::Int)\\n    Δₓ = ((b - a) / n)\\n\\n    Σ = 0.0\\n    for _ ∈ 1:n\\n        # generate uniform(a, b) using uniform(0, 1)\\n        Xᵢ = a + (b-a)*rand()\\n        Σ += f(Xᵢ)\\n    end\\n\\n    return Δₓ * Σ\\nend\\n\"",
    "perfect cube": "\"\\\"\\\"\\\"\\n    perfect_cube(number)\\n\\nCheck if a number is a perfect cube or not.\\n\\n# Example\\n```jula\\nperfect_cube(27) # returns true\\nperfect_cube(4)  # returns false\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction perfect_cube(number::N)where N<:Integer\\n    val = trunc(cbrt(number))\\n    return (val * val * val) == number\\nend\\n\"",
    "perfect number": "\"\\\"\\\"\\\"\\n    perfect_number(number)\\n\\nChecks if a number is a perfect_number number or not\\n\\n# Details\\n\\nperfect_number number is a positive integer that is equal to the sum of\\nits positive divisors, excluding the number itself.\\n\\nFor example : 6 is perfect_number number\\n\\nDivisors of 6 => [1,2,3]\\n\\nSum of divisors => 1+2+3 = 6\\n\\n6 == sum(divisors) # which is true\\n\\n# Example\\n\\n```julia\\nperfect_number(27)     # returns false\\nperfect_number(28)     # returns true\\nperfect_number(496)    # returns true\\nperfect_number(8128)   # returns true\\nperfect_number(123)    # returns false\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction perfect_number(number::N)where N<:Number\\n    divisors = Vector{Int}()\\n    for i = 1:(number÷2+1)\\n        if number % i == 0\\n            push!(divisors, i)\\n        end\\n    end\\n    return sum(divisors) == number\\nend\\n\"",
    "perfect square": "\"\\\"\\\"\\\"\\nperfect_square(number)\\n\\nCheck if a number is a perfect square or not.\\n\\n# Example\\n```jula\\nperfect_square(9)   # returns True\\nperfect_square(16)  # returns True\\nperfect_square(1)   # returns True\\nperfect_square(0)   # returns True\\nperfect_square(10)  # returns False\\nperfect_square(-9)  # returns False\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction perfect_square(number::N)where N<:Integer\\n    number<0&&return false\\n    val=isqrt(number)\\n    return val*val == number\\nend\\n\"",
    "permutation": "\"\\\"\\\"\\\"\\n    permutation(n, r)\\n        \\n    returns the number of ways to choose r items from n items\\n    with order and without repetition\\n\\n# Arguments:\\n- `n`: Positive integers of items to choose from\\n- 'r': Positive integers of items to choose\\n\\nContributed By:- [Mayur Dahibhate](https://github.com/mayurdahibhate)\\n\\\"\\\"\\\"\\n\\nfunction permutation(n, r)\\n\\n    function factorial(n)        \\n        fact = 1\\n        \\n        if n == 0 || n == 1\\n            return fact\\n        end\\n         \\n        for i = 1:n\\n            fact = fact * i\\n        end \\n        \\n        return fact\\n    end\\n    \\n    perm = factorial(n) / factorial(n - r) \\n\\n    return convert(Int64, perm)\\nend\\n\"",
    "prime check": "\"\\\"\\\"\\\"\\nprime_check(number)\\n\\nChecks to see if a number is a prime or not\\n    \\nA number is prime if it has exactly two factors: 1 and itself.\\n\\n# Example\\n\\n```julia\\nprime_check(2) # returns true\\nprime_check(3) # returns true\\nprime_check(5) # returns true\\nprime_check(7) # returns true\\nprime_check(11) # returns true\\nprime_check(13) # returns true\\nprime_check(17) # returns true\\nprime_check(19) # returns true\\nprime_check(23) # returns true\\nprime_check(29) # returns true\\nprime_check(30) # returns false\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee) and [Rratic](https://github.com/Rratic)\\n\\\"\\\"\\\"\\nfunction prime_check(number::N)where N<:Integer\\n    if 1 < number < 4\\n        # 2, 3 are primes\\n        return true\\n    elseif number < 2 || number % 2 == 0\\n        # Negative ,0,1, and even numbers except 2 are not primes\\n        return false\\n    end\\n    for i in 3:2:isqrt(number) + 1\\n        if number % i == 0\\n            return false\\n        end\\n    end\\n    return true\\nend\\n\"",
    "prime factors": "\"\\\"\\\"\\\"\\nprime_factors(number)\\n\\nReturns prime factors of `number` as a vector\\n\\n# Example\\n\\n```julia\\nprime_factors(50)          # returns [2,5,5]\\nprime_factors(0)           # returns []\\nprime_factors(100)         # returns [2, 2, 5, 5]\\nprime_factors(2560)        # returns [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee)\\n\\\"\\\"\\\"\\nfunction prime_factors(number::N)where N<:Integer\\n    i = 2\\n    factors = Vector{Int}()\\n    while i*i <= number\\n        if number % i == 1\\n            i += 1\\n        else\\n            number ÷= i\\n            push!(factors, i)\\n        end\\n    end\\n    if number > 1 == 1\\n        push!(factors, number)\\n    end\\n    return factors\\nend\\n\"",
    "riemann integration": "\"\\\"\\\"\\\"\\n    riemann_integration(f::Function, a::Real, b::Real, n::Int, approx::Symbol = :midpoint)\\n\\na Riemann sum is a certain kind of approximation of an integral by a finite sum.\\nThe sum is calculated by partitioning the region into shapes (rectangles, trapezoids, parabolas, or cubics) that together form a region that is similar to the region being measured, then calculating the area for each of these shapes, and finally adding all of these small areas together.\\n\\nBecause the region filled by the small shapes is usually not exactly the same shape as the region being measured, the Riemann sum will differ from the area being measured. \\nThis error can be reduced by dividing up the region more finely, using smaller and smaller shapes. \\nAs the shapes get smaller and smaller, the sum approaches the Riemann integral.\\n\\n# Arguments\\n- `f`: the function to integrate. (at the momment only single variable is suported)\\n- `a`: Start of the integration limit.\\n- `b`: End of the integration limit.\\n- `n`: Number of points to sample. (as n increase, error decrease)\\n- `approx`: Indicate the method of approximation (midpoint, left or right)\\n\\n# Examples\\n```julia\\njulia> riemann_integration(x -> x, 1, 3, 1_000, :midpoint)  # 4.0\\njulia> riemann_integration(x -> x, 1, 3, 1_000, :left)      # 3.997997997997998\\njulia> riemann_integration(x -> x, 1, 3, 1_000, :right)     # 4.002002002002002\\njulia> riemann_integration(x -> 3*x^2, 0, 1, 100000)        # integrate a polynomial\\n0.9999999999750021\\njulia> riemann_integration(x -> sin(x), 0, pi, 1000)          # integrate the sin function\\n2.0000008241146774\\n```\\n\\n# Refereces\\n- https://www.khanacademy.org/math/ap-calculus-ab/ab-integration-new/ab-6-2/a/riemann-sums-review\\n- https://math.libretexts.org/Courses/Mount_Royal_University/MATH_2200%3A_Calculus_for_Scientists_II/2%3A_Techniques_of_Integration/2.5%3A_Numerical_Integration_-_Midpoint%2C_Trapezoid%2C_Simpson's_rule\\n- https://abel.math.harvard.edu/~knill/teaching/math1a_2011/handouts/40-numerical.pdf\\n- https://en.wikipedia.org/wiki/Riemann_integral\\n\\n\\nContributed By:- [AugustoCL](https://github.com/AugustoCL)\\n\\\"\\\"\\\"\\nfunction riemann_integration(f::Function, a::Real, b::Real, n::Int, approx::Symbol = :midpoint)\\n    # width of the rectangles\\n    Δₓ = (b - a) / n\\n\\n    # methods of approximation (:midpoint, :left, :right)\\n    if approx == :midpoint\\n        sum_range = (a + Δₓ/2):Δₓ:(b - Δₓ/2)\\n    elseif approx == :left\\n        sum_range = a:Δₓ:(b - Δₓ)\\n    elseif approx == :right\\n        sum_range = (a + Δₓ):Δₓ:b\\n    else\\n        throw(ArgumentError(\\\"The symbol :$approx is not a valid argument. Insert :midpoint, :left or :right\\\"))\\n    end\\n\\n    # sum of the height of the rectangles\\n    Σ = 0.0\\n    for i in 2:length(sum_range)\\n        a  = sum_range[i-1]\\n        b  = sum_range[i]\\n        xᵢ = a + (b-a)*rand()   # draw a uniform(a,b) for each subinterval [a,b]\\n        Σ += f(xᵢ)\\n    end\\n\\n    # approximate integral of f\\n    return Δₓ * Σ\\nend\\n\"",
    "sieve of eratosthenes": "\"\\\"\\\"\\\"\\nSieve of Eratosthenes is an algorithm for finding all the primes upto a limit `n`.\\n\\nReference:\\n-https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\\n\\\"\\\"\\\"\\nfunction eratosthenes(n)\\n    primes = fill(true,n)\\n    primes[1] = false\\n    for p = 2:n\\n        primes[p] || continue\\n        for i = 2:div(n,p)\\n            primes[p*i] = false\\n        end\\n    end\\n    findall(primes)\\nend\\n\"",
    "simpsons integration": "\"\\\"\\\"\\\"\\n    simpsons_integration(f::Function, a::Real, b::Real, n::Int)\\n\\nSimpson's rule uses a quadratic polynomial on each subinterval of a partition to approximate the function f(x) and to compute the definite integral. \\nThis is an improvement over the trapezoid rule which approximates f(x) by a straight line on each subinterval of a partition.\\nFor more details of the method, check the link in the reference.\\n\\n# Arguments\\n- `f`: The function to integrate. (ar the moment only single variable is suported)\\n- `a`: Start of the integration limit.\\n- `b`: End of the integration limit.\\n- `n`: Number of points to sample. (as n increase, error decrease)\\n\\n# Examples/Test\\n```julia\\n# aproximate pi with f(x) = 4 / (1 + x^2)\\njulia> simpsons_integration(x -> 4 / (1 + x^2), 0, 1, 100_000)\\n3.1415926535897936\\njulia> simpsons_integration(x -> 4 / (1 + x^2), 0, 1, 100_000) ≈ pi\\ntrue\\n```\\n\\n# References:\\n- https://personal.math.ubc.ca/~pwalls/math-python/integration/simpsons-rule/\\n\\n# Contributed By:- [AugustoCL](https://github.com/AugustoCL)\\n\\\"\\\"\\\"\\nfunction simpsons_integration(f::Function, a::Real, b::Real, n::Int)\\n    # width of the segments\\n    Δₓ = (b - a) / n\\n    \\n    # rules of the method (check link in references)\\n    a₁(i) = 2i - 2\\n    a₂(i) = 2i - 1\\n\\n    # sum of the heights\\n    Σ = sum(1:n/2) do i\\n            f(a + a₁(i)*Δₓ) + 4f(a + a₂(i)*Δₓ) + f(a + 2i*Δₓ)\\n        end\\n\\n    # approximate integral of f\\n    return (Δₓ / 3) * Σ\\nend\\n\"",
    "sum of arithmetic series": "\"\\\"\\\"\\\"\\n    sum_ap(first_term, diff, num_terms)\\n\\nFinds sum of a arithmetic progression series\\n\\n# Input parameters\\n\\n- first_term : first term of the series\\n- diff       : common difference between consecutive terms\\n- num_terms  : number of terms in the series till which we count sum\\n\\n# Example \\n\\n```julia\\nsum_ap(1, 1, 10)    # returns 55.0 \\nsum_ap(1, 10, 100)  # returns 49600.0\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee)\\n\\\"\\\"\\\"\\nfunction sum_ap(first_term, diff, num_terms)\\n    #formula for sum of the ap series\\n    sum = (num_terms / 2) * (2 * first_term + (num_terms - 1) * diff)\\n    return sum\\nend\\n\\n\"",
    "sum of geometric progression": "\"\\\"\\\"\\\"\\n    sum_gp(first_term, ratio, num_terms)\\n\\nFinds sum of n terms in a geometric progression\\n\\n# Input parameters\\n\\n- first_term : first term of the series\\n- raio      : common ratio between consecutive terms -> a2/a1 or a3/a2 or a4/a3\\n- num_terms  : number of terms in the series till which we count sum\\n\\n# Example\\n\\n```julia\\nsum_gp(1, 2, 10)    # 1023.0\\nsum_gp(1, 10, 5)    # 11111.0\\nsum_gp(0, 2, 10)    # 0.0\\nsum_gp(1, 0, 10)    # 1.0\\nsum_gp(1, 2, 0)     # -0.0\\nsum_gp(-1, 2, 10)   # -1023.0\\nsum_gp(1, -2, 10)   # -341.0\\n```\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee)\\n\\\"\\\"\\\"\\nfunction sum_gp(first_term, ratio, num_terms)\\n    # case where ratio is 1\\n    if ratio == 1\\n        return num_terms * first_term\\n    end\\n    # ormula for finding sum of n terms of a geometric progression\\n    return (first_term / (1 - ratio)) * (1 - ratio^num_terms)\\nend\\n\\n\\n\\n\"",
    "trapezoid integration": "\"\\\"\\\"\\\"\\n    trapezoid_integration(f::Function, a::Real, b::Real, n::Int)\\n\\nThe trapezoidal rule works by approximating the region under the graph of the function f(x) as a trapezoid and calculating its area.\\n\\n# Arguments\\n- `f`: the function to integrate. (at the momment only single variable is suported)\\n- `a`: Start of the integration limit.\\n- `b`: End of the integration limit.\\n- `n`: Number of points to sample. (as n increase, error decrease)\\n\\n# Examples/Test\\n```julia\\njulia> trapezoid_integration(x -> 4 / (1 + x^2), 0, 1, 100_000)\\n3.1415926535731526\\njulia> trapezoid_integration(x -> 4 / (1 + x^2), 0, 1, 100_000) ≈ pi\\ntrue\\n```\\n# References:\\n-https://personal.math.ubc.ca/~pwalls/math-python/integration/trapezoid-rule/\\n-https://en.wikipedia.org/wiki/Trapezoidal_rule\\n\\n# Contributed By:- [AugustoCL](https://github.com/AugustoCL)\\n\\\"\\\"\\\"\\nfunction trapezoid_integration(f::Function, a::Real, b::Real, n::Int)\\n    # width of the trapezoids\\n    Δₓ = (b - a) / n\\n\\n    # sum of the height of the trapezoids\\n    Σ = 0.5*f(a) +\\n        sum(f(i) for i in (a+Δₓ):Δₓ:(b-Δₓ)) +\\n        0.5*f(b)\\n\\n    # approximate integral of f\\n    return Δₓ * Σ\\nend\\n\\n\"",
    "verlet": "\"\\\"\\\"\\\"\\nVerlet integration is an integration method used to integrate newtons - law of motion. It is frequently used to find trajectories in molecular dynamics simulation.\\nThe function takes `four` inputs viz,\\n- `f` : the differential equation\\n- `x0` : the initial condition. This is a Vector with the first element as initial value for position(x_0) and the the second  initial condition for velocity (v_0) \\n- `tspan`: is the time span for integration. It is a tuple (initial time, final time)\\nThis functionr returns a tuple (x,t):\\n- `x` is the solution\\n- `t` is the array containing the time points\\nReference:\\n- https://www.algorithm-archive.org/contents/verlet_integration/verlet_integration.html\\nContributed by: [Ved Mahajan](https://github.com/Ved-Mahajan)\\n\\\"\\\"\\\"\\nfunction verlet_integration(f,x0,tspan,Δt= 1.0e-3)\\n        s,e = tspan\\n        N = floor((e-s)/Δt) |> Int\\n        x = Vector{Float64}(undef,N)\\n        t = collect(s:Δt:(e - Δt))\\n        x[1] = x0[1]\\n        x[2] = x0[1] + x0[2]*Δt + 0.5*f(x0[1])*(Δt)^2\\n\\n        for i in 2:(N-1)\\n                x[i+1] = 2*x[i] - x[i-1] + f(x[i])*(Δt)^2\\n        end\\n        return x,t\\nend\\n\"",
    "volume": "\"#Find Volumes of Various Shapes.\\n#Wikipedia reference: https://en.wikipedia.org/wiki/Volume\\n# contributed By:- [Qingyu Qu](https://github.com/ErikQQY)\\n\\n\\\"\\\"\\\"\\n    vol_cube()\\n\\nCompute the volume of a cube.\\n\\n# Examples\\n\\n```julia-repl\\njulia> vol_cube(1)\\n1\\njulia> vol_cube(3)\\n27\\njulia> vol_cube(-1)\\nDomainError\\n```\\n\\\"\\\"\\\"\\nfunction vol_cube(side)\\n    if side<0\\n        throw(DomainError(\\\"vol_cube() only works for non negative values.\\\"))\\n    end\\n    return side^3\\nend\\n\\n\\\"\\\"\\\"\\n    vol_cuboid(width, height, length)\\n\\nCompute the volume of a vol_cuboid\\n\\n# Examples\\n\\n```julia-repl\\njulia> vol_cuboid(1, 1, 1)\\n1\\njulia> vol_cuboid(1, 2, 3)\\n6\\n```\\n\\\"\\\"\\\"\\nfunction vol_cuboid(width, height, length)\\n    if width < 0 || height <0 || length < 0\\n        throw(DomainError(\\\"vol_cuboid() only works for non negative values.\\\"))\\n    end\\n    return width*height*length\\nend\\n\\n\\\"\\\"\\\"\\n    vol_cone(area_of_base, height)\\n\\nCompute the Volume of a Cone\\n\\n\\n# Examples\\n\\n```julia-repl\\njulia> vol_cone(10, 3)\\n10.0\\njulia> vol_cone(1, 1)\\n0.3333333333333333\\n```\\n\\\"\\\"\\\"\\nfunction vol_cone(area_of_base, height)\\n    if area_of_base < 0 || height <0\\n        throw(DomainError(\\\"vol_cone() only works for non negative values.\\\"))\\n    end\\n    return area_of_base*height/3.0\\nend\\n\\n\\\"\\\"\\\"\\n    vol_right_circ_cone(radius, height)\\n\\nCompute the Volume of a Right Circular Cone.\\n\\n# Examples\\n\\n```julia-repl\\njulia> vol_right_circ_cone(2, 3)\\n12.566370614359172\\n```\\n\\\"\\\"\\\"\\nfunction vol_right_circ_cone(radius, height)\\n    if radius < 0 || height < 0\\n        throw(DomainError(\\\"vol_right_circ_cone() only works for non negative values.\\\"))\\n    end\\n    return π*radius^2*height/3.0\\nend\\n\\n\\\"\\\"\\\"\\n    vol_prism(area_of_base, height)\\n\\nCompute the Volume of a Prism.\\n\\n# Examples\\n\\n```julia-repl\\njulia> vol_prism(10, 2)\\n20.0\\njulia> vol_prism(11, 1)\\n11.0\\n```\\n\\\"\\\"\\\"\\nfunction vol_prism(area_of_base, height)\\n    if area_of_base < 0 || height < 0\\n        throw(DomainError(\\\"vol_prism() only works for non negative values.\\\"))\\n    end\\n    return area_of_base*height\\nend\\n\\n\\\"\\\"\\\"\\n    vol_pyramid(area_of_base, height)\\n\\nCompute the volume of a Pyramid.\\n\\n# Examples\\n\\n```julia-repl\\njulia> vol_pyramid(10, 3)\\n10.0\\njulia> vol_pyramid(1.5, 3)\\n1.5\\n```\\n\\\"\\\"\\\"\\nfunction vol_pyramid(area_of_base, height)\\n    if area_of_base < 0 || height < 0\\n        throw(DomainError(\\\"vol_pyramid() only works for non negative values.\\\"))\\n    end\\n    return area_of_base*height/3.0\\nend\\n\\n\\\"\\\"\\\"\\n    vol_sphere(radius)\\n\\nCompute the volume of a sphere.\\n\\n# Examples\\n\\n```julia\\nvol_sphere(5)  # returns 523.5987755982989\\nvol_sphere(1)  # returns 4.1887902047863905\\nvol_sphere(-1) # returns DomainError\\n```\\n\\\"\\\"\\\"\\nfunction vol_sphere(radius)\\n    if radius < 0\\n        throw(DomainError(\\\"vol_sphere() only works for non negative values.\\\"))\\n    end\\n    return 4/3*pi*(radius)^3\\nend\\n\\n\\\"\\\"\\\"\\n    vol_circular_cylinder(area_of_, height)\\n\\nCompute the Volume of a Circular Cylinder.\\n\\n# Examples\\n\\n```julia-repl\\njulia> vol_circular_cylinder(1, 1)\\n3.141592653589793\\njulia> vol_circular_cylinder(4, 3)\\n150.79644737231007\\n\\\"\\\"\\\"\\nfunction vol_circular_cylinder(radius, height)\\n    if radius < 0 || height < 0\\n        throw(DomainError(\\\"vol_circular_cylinder() only works for non negative values.\\\"))\\n    end\\n    return pi*radius^2*height\\nend\"",
    "determinant": "\"\\\"\\\"\\\"\\n    determinant(mat)\\n\\nGiven a non singluar matrix, calculate its determinant using LU decomposition.\\n\\nL and U are lower triangular and upper triangular matrices respectively such that\\n\\nA = L*U\\n\\nIf we want to find the determinant, then\\n\\ndet(A) = det(LU) = det(L)*det(U)\\n\\nDeterminant of triangualar matrices is the product of their diagonal entries. Hence, makes finding the determinant easy.\\n\\\"\\\"\\\"\\nfunction determinant(mat)\\n\\tn, m = size(mat)\\n\\tif n != m\\n\\t\\tDomainError(mat, \\\"The matrix should be a square matrix.\\\")\\n\\tend\\n\\tL, U = lu_decompose(mat)\\n\\tl_prod = prod([L[i,i] for i in 1:n])\\n\\tu_prod = prod([U[i,i] for i in 1:n])\\n\\n\\treturn l_prod * u_prod\\nend\\n\"",
    "gauss jordan elim": "\"\\\"\\\"\\\"\\n    gauss_jordan(A::AbstractMatrix{T}) where T<:Number\\n\\nGaussian elimination, also known as row reduction, is an algorithm for solving systems of linear equations. \\nIt consists of a sequence of operations performed on the corresponding matrix of coefficients. \\nThis method can also be used to compute the rank of a matrix, the determinant of a square matrix, and the inverse of an invertible matrix.\\nhttps://en.wikipedia.org/wiki/Gaussian_elimination\\n\\n# Examples/Tests\\n```julia\\njulia> M1 = [1 2 3; 4 5 6];\\njulia> M2 = [1 2 3; 4 8 12];\\n\\njulia> @test gauss_jordan(M1) == [1 0 -1; 0 1 2]        # Test Passed\\njulia> @test_throws AssertionError gauss_jordan(M2)     # Test Passed - Thrown: AssertionError\\n```     \\n\\n# Contributed By:- [AugustoCL](https://github.com/AugustoCL)\\n\\\"\\\"\\\"\\nfunction gauss_jordan(A::AbstractMatrix{T}) where {T<:Number}\\n\\n    # check if matrix is singular\\n    m, n = size(A)\\n    if m == n\\n        @assert det(A) ≠ 0.0 \\\"Must insert a non-singular matrix\\\"\\n    else\\n        @assert det(A[:, 1:end-1]) ≠ 0.0 \\\"Must insert a non-singular matrix or a system matrix [A b]\\\"\\n    end\\n\\n    # execute the gauss-jordan elimination\\n    for i ∈ axes(A, 1)\\n\\n        if A[i, i] == 0.0\\n            for n ∈ (i + 1):m                           # iterate in lines below to check if could be swap\\n                if A[n, i] ≠ 0.0                        # condition to swap row\\n                    L = copy(A[i, :])                   # copy line to swap\\n                    A[i, :] = A[n, :]                   # swap occur\\n                    A[n, :] = L\\n                    break\\n                end\\n            end\\n        end\\n\\n        @. A[i, :] = A[i, :] ./ A[i, i]                  # divide pivot line by pivot element\\n\\n        for j ∈ axes(A, 1)                               # iterate each line for each pivot column, except pivot line\\n            if j ≠ i                                     # jump pivot line\\n                @. A[j, :] = A[j, :] - A[i, :]*A[j, i]   # apply gauss jordan in each line\\n            end\\n        end\\n    end\\n\\n    return A\\nend\\n\\n# using multiple dispatch to avoid InexactError with Integers\\ngauss_jordan(A::AbstractMatrix{T}) where {T<:Integer} = gauss_jordan(convert(Matrix{Float64}, A))\\n\"",
    "lu decompose": "\"\\\"\\\"\\\"\\n    lu_decompose(mat)\\nDecomposes a `n x n` non singular matrix into a lower triangular matrix (L) and an upper triangular matrix (U)\\n\\\"\\\"\\\"\\nfunction lu_decompose(mat)\\n\\tn = mat |> size |> first\\n\\tL = zeros(n, n)\\n\\tU = zeros(n, n)\\n\\n\\tfor i in 1:n\\n\\t\\tfor j in i:n\\n\\t\\t\\ts = 0\\n\\t\\t\\tfor k in 1:i\\n\\t\\t\\t\\ts += L[i,k] * U[k,j]\\n\\t\\t\\tend\\n\\t\\t\\tU[i,j] = mat[i,j] - s\\n\\t\\tend\\n\\n\\t\\tfor k in i:n\\n\\t\\t\\tif i == k\\n\\t\\t\\t\\tL[i,i] = 1\\n    \\t\\t\\telse\\n\\t\\t\\t\\ts = 0\\n\\t\\t\\t\\tfor j in 1:i\\n\\t\\t\\t\\t\\ts += L[k,j] * U[j,i]\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tL[k,i] = (mat[k,i] - s) / U[i,i]\\n\\t\\t\\tend\\n\\t\\tend\\n\\tend\\n\\n\\treturn L, U\\nend\\n\"",
    "rotation-matrix": "\"\\\"\\\"\\\"\\nA 2D Rotation matrix is a mtrix that rotates a vector in a 2D real space by an angle theta.\\nFor more info: https://en.wikipedia.org/wiki/Rotation_matrix\\n\\nThis function takes the angle `theta` in radians as input and returns a 2D Matrix which will rotate the the vector by angle `theta`.\\n\\\"\\\"\\\"\\nfunction rotation_matrix(θ)\\n\\trot_mat = Matrix{Float64}(undef,2,2)\\n\\trot_mat[1,1]  = cos(θ)\\n\\trot_mat[1,2] = -sin(θ)\\n\\trot_mat[2,1] = sin(θ)\\n\\trot_mat[2,2] = cos(θ)\\n\\n\\treturn rot_mat\\nend\\n\"",
    "count nucleotide": "\"\\\"\\\"\\\"\\n    count_nucleotides(s::AbstractString)\\nGiven: A DNA string s\\n\\nof length at most 1000 nt.\\n\\nReturn: Four integers (separated by spaces) counting the respective number of times that the symbols 'A', 'C', 'G', and 'T' occur in s\\n\\\"\\\"\\\"\\nfunction count_nucleotides(s::AbstractString)\\n\\treturn join(map(y -> count(x -> x == y, s), ['A', 'T', 'G', 'C']), \\\" \\\")\\nend\\n\"",
    "dna2rna": "\"\\\"\\\"\\\"\\n    dna2rna(s::AbstractString)\\nGiven: A DNA string t\\n\\nhaving length at most 1000 nt.\\n\\nReturn: The transcribed RNA string of t\\n\\\"\\\"\\\"\\nfunction dna2rna(s::AbstractString)\\n\\treturn replace(s, 'T' => 'U')\\nend\\n\"",
    "reverse complement": "\"\\\"\\\"\\\"\\n    reverse_complement(s::AbstractString)\\nGiven: A DNA string s of length at most 1000 bp.\\n\\nReturn: The reverse complement s^c of s.\\n\\\"\\\"\\\"\\n\\n\\nfunction reverse_complement(s::AbstractString)\\n\\trules = Dict('A' => 'T', 'T' => 'A', 'G' => 'C', 'C' => 'G')\\n\\treturn map(x -> rules[x], reverse(s))\\nend\\n\"",
    "fcfs": "\"\\\"\\\"\\\"\\n    fcfs(n, process_id, burst_time)\\n\\nImplementation of first come first served scheduling algorithm\\n\\n# Output\\nTuple of vectors (process_id, burst_time, waiting_time, turnaround_time, avg_waiting_time, avg_turnaround_time)\\n\\n# Example\\n\\n```julia\\nn = 3 # number of processes\\nprocess_id = Any[1, 2, 3] # process ids\\nburst_times = Any[3, 4, 5] # burst times\\nfcfs(n, process_id, burst_times)\\n```\\n# Reference\\n\\nhttps://en.wikipedia.org/wiki/Scheduling_(computing)#First_come,_first_served\\n\\nContributed By:- [Ashwani Rathee](https://github.com/ashwani-rathee)\\n\\\"\\\"\\\"\\nfunction fcfs(n, process_id, burst_time)\\n    waiting_time = []\\n    push!(waiting_time, 0)\\n    for i = 2:n\\n        # Calculates waiting time\\n        push!(waiting_time, burst_time[i - 1] + waiting_time[i - 1])\\n    end\\n\\n    turnaround_time = []\\n    for i = 1:n\\n        # Calculates turnaround time\\n        push!(turnaround_time, burst_time[i] + waiting_time[i])\\n    end\\n\\n    # Calculates Average waiting time\\n    avg_waiting_time = sum(waiting_time) / length(waiting_time)\\n\\n    # Calculates Average turnaround time\\n    avg_turnaround_time = sum(turnaround_time) / length(turnaround_time)\\n\\n    return process_id, burst_time, waiting_time, turnaround_time, avg_waiting_time, avg_turnaround_time\\nend\\n\"",
    "binary search": "\"# Problem from https://exercism.io/my/tracks/julia#exercise-binary-search\\n# Based on my published solution https://exercism.io/tracks/julia/exercises/binary-search/solutions/5dcd7f36433245a28484889c42a957c0\\n\\n# Problem Instructions:\\n\\n\\\"\\\"\\\"\\n    binary_search(list, query; rev=false, lt=<, by=identity)\\n\\nImplement a binary search algorithm.\\nSearching a sorted collection is a common task. A dictionary is a sorted list of word definitions. Given a word, one can find its definition. A telephone book is a sorted list of people's names, addresses, and telephone numbers. Knowing someone's name allows one to quickly find their telephone number and address.\\n\\nIf the list to be searched contains more than a few items (a dozen, say) a binary search will require far fewer comparisons than a linear search, but it imposes the requirement that the list be sorted.\\n\\nIn computer science, a binary search or half-interval search algorithm finds the position of a specified input value (the search \\\"key\\\") within an array sorted by key value.\\n\\nIn each step, the algorithm compares the search key value with the key value of the middle element of the array.\\n\\nIf the keys match, then a matching element has been found and the range of indices that equal the search key value are returned.\\n\\nOtherwise, if the search key is less than the middle element's key, then the algorithm repeats its action on the sub-array to the left of the middle element or, if the search key is greater, on the sub-array to the right.\\n\\nIf the remaining array to be searched is empty, then the key cannot be found in the array and a special \\\"not found\\\" indication is returned. Search methods in Julia typically return an empty range located at the insertion point in this case.\\n\\nA binary search halves the number of items to check with each iteration, so locating an item (or determining its absence) takes logarithmic time. A binary search is a dichotomic divide and conquer search algorithm.\\n\\nBonus task:\\nImplement keyword arguments by, lt and rev so that by specifies a transformation applied to all elements of the list, lt specifies a comparison and rev specifies if the list is ordered in reverse.\\n\\nContributed By:- [Soc Virnyl Estela](https://github.com/uncomfyhalomacro)\\n\\\"\\\"\\\"\\nfunction binary_search(list, query; rev=false, lt=<, by=identity)\\n    if issorted(list) || issorted(list; rev=true)\\n        low = !rev ? 1 : length(list)\\n        high = !rev ? length(list) : 1\\n        middle(l, h) = round(Int, (l + h)//2)\\n        query = by(query)\\n\\n        while !rev ? low <= high : high <= low\\n            mid = middle(low, high)\\n            by(list[mid]) === query && return mid:mid\\n            if lt(by(list[mid]), query)\\n                low = !rev ? mid + 1 : mid - 1\\n            else\\n                high = !rev ? mid - 1 : mid + 1\\n            end\\n        end\\n        return !rev ? (low:high) : (high:low)\\n\\n    else\\n        throw(error(\\\"List not sorted, unable to search value\\\"))\\n    end\\nend\\n\\n# See Issue https://github.com/TheAlgorithms/Julia/issues/34\\n\\\"\\\"\\\"\\n    binary_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T<:Real}\\n\\nThe implementation of this binary Search is recursive and requires O(Log n) space. With iterative Binary Search, we need only O(1) space. Useful for the implementation of `exponential_search`.\\n\\nContributed By:- [Ash](https://github.com/ashwani-rathee)\\n\\\"\\\"\\\"\\nfunction binary_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T<:Real}\\n    if (r >= l)\\n        mid = Int(ceil(l + (r - l) / 2))\\n        # println(mid)\\n        if (arr[mid] == x)\\n            return \\\"Element present at index $mid\\\"\\n        elseif (arr[mid] > x)\\n            binary_search(arr, l, mid - 1, x)\\n        else\\n            binary_search(arr, mid + 1, r, x)\\n        end\\n    else\\n        return \\\"Element not present in array\\\"\\n    end\\nend\\n\"",
    "exponential search": "\"\\\"\\\"\\\"\\n\\t exponential_search(arr::AbstractArray{T,1}, x::T) where {T <: Real}\\n\\nExponential Search in 1-D array\\nTime Complexity:  O(Log n)\\n# Exponential Search\\nIt works in O(Log n) time\\nExponential search involves two steps:\\n- Find range where element is present\\n- Do Binary Search in above found range.\\n### Time Complexity :\\nO(Log n)\\nApplications of Exponential Search:\\nExponential Binary Search is particularly useful for unbounded searches, where size of array is infinite. Please refer Unbounded Binary Search for an example.\\nIt works better than Binary Search for bounded arrays, and also when the element to be searched is closer to the first element.\\n\\nContributed By:- [Ash](https://github.com/ashwani-rathee)\\n\\\"\\\"\\\"\\nfunction exponential_search(arr::AbstractArray{T,1}, x::T) where {T<:Real}\\n    n = size(arr)[1]\\n    if (arr[1] == x)\\n        return \\\"Element present at index 1\\\"\\n    end\\n\\n    i = 1\\n    while (i < n && arr[i] <= x)\\n        i = i * 2\\n    end\\n    return binary_search(arr, Int(ceil(i / 2)), min(i, n), x)\\nend\\n\"",
    "interpolation search": "\"\\\"\\\"\\\"\\n# Interpolation Search\\nUsed for sorted array which is uniformly distributed.\\nBinary Search always goes to the middle element to check. On the other hand, interpolation search may go to different locations according to the value of the key being searched. For example, if the value of the key is closer to the last element, interpolation search is likely to start search toward the end side.\\nThe idea of formula is to return higher value of pos when element to be searched is closer to arr[hi]. And smaller value when closer to arr[lo]\\npos = lo + [ (x-arr[lo])*(hi-lo) / (arr[hi]-arr[Lo]) ]\\n- arr[] ==> Array where elements need to be searched\\n- x     ==> Element to be searched\\n- lo    ==> Starting index in arr[]\\n- hi    ==> Ending index in arr[]\\n## Derivation =>\\nLet's assume that the elements of the array are linearly distributed.\\nGeneral equation of line : y = m*x + c.\\ny is the value in the array and x is its index.\\nNow putting value of lo,hi and x in the equation\\n- arr[hi] = m*hi+c ----(1)\\n- arr[lo] = m*lo+c ----(2)\\n- x = m*pos + c     ----(3)\\nm = (arr[hi] - arr[lo] )/ (hi - lo)\\nsubtracting eqxn (2) from (3)\\n- x - arr[lo] = m * (pos - lo)\\n- lo + (x - arr[lo])/m = pos\\n- pos = lo + (x - arr[lo]) *(hi - lo)/(arr[hi] - arr[lo])\\n## Algorithm:\\nRest of the Interpolation algorithm is the same except the above partition logic.\\n- Step1: In a loop, calculate the value of “pos” using the probe position formula.\\n- Step2: If it is a match, return the index of the item, and exit.\\n- Step3: If the item is less than arr[pos], calculate the probe position of the left sub-array. Otherwise calculate the same in the right sub-array.\\n- Step4: Repeat until a match is found or the sub-array reduces to zero.\\n\\n\\\"\\\"\\\"\\n\\n\\\"\\\"\\\"\\n\\t interpolation_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T <: Real}\\n\\nInterpolation Search in 1-D array\\nTime Complexity: O(log2(log2 n))\\n\\\"\\\"\\\"\\nfunction interpolation_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T <: Real}\\n\\tn = size(arr)[1]\\n\\tif (r >= l && x >= arr[l] && x <= arr[r])\\n\\t\\tmid = Int(ceil(l + (((x - arr[l]) * (r - l)) / (arr[r] - arr[l]))))\\n\\t\\tif (arr[mid] == x)\\n\\t\\t\\treturn \\\"Element present at index $mid\\\"\\n\\t\\telseif (arr[mid] > x)\\n\\t\\t\\tinterpolation_search(arr, l, mid - 1, x)\\n\\t\\telse\\n\\t\\t\\tinterpolation_search(arr, mid + 1, r, x)\\n\\t\\tend\\n\\telse\\n\\t\\treturn \\\"Element not present in array\\\"\\n\\tend\\nend\\n\"",
    "jump search": "\"\\\"\\\"\\\"\\n# Jump Search(sorted array)\\nJump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements.\\nFor example, suppose we have an array arr[] of size n and block (to be jumped) size m. Then we search at the indexes arr[0], arr[m], arr[2m]…..arr[km] and so on. Once we find the interval (arr[km] < x < arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.\\nLet’s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610). Length of the array is 16. Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4.\\n- STEP 1: Jump from index 0 to index 4;\\n- STEP 2: Jump from index 4 to index 8;\\n- STEP 3: Jump from index 8 to index 12;\\n- STEP 4: Since the element at index 12 is greater than 55 we will jump back a step to come to index 8.\\n- STEP 5: Perform linear search from index 8 to get the element 55.\\n## What is the optimal block size to be skipped?\\nIn the worst case, we have to do n/m jumps and if the last checked value is greater than the element to be searched for, we perform m-1 comparisons more for linear search. Therefore the total number of comparisons in the worst case will be ((n/m) + m-1). The value of the function ((n/m) + m-1) will be minimum when m = √n. Therefore, the best step size is m = √n.\\n\\\"\\\"\\\"\\n\\n\\\"\\\"\\\"\\n    jump_search(arr::AbstractArray{T,1}, x::T, jump::T = Int(ceil(sqrt(n)))) where {T <: Real}\\nJump Search in 1-D array\\nTime Complexity :  O(√ n)\\nTime complexity of Jump Search is between Linear Search ( ( O(n) ) and Binary Search ( O (Log n) )\\n\\\"\\\"\\\"\\nfunction jump_search(arr::AbstractArray{T,1}, x::T, jump::T = Int(ceil(sqrt(n)))) where {T <: Real}\\n\\tn = size(arr)[1];\\n\\tstart = 1\\n\\tfinal = jump\\n\\twhile( arr[final] <= x && final < n)\\n\\t\\tstart = final\\n\\t \\tfinal = final + jump\\n\\t\\tif( final > n -1)\\n\\t\\t   final = n\\n\\t\\tend\\n\\tend\\n\\tfor i in start:final\\n\\t\\tif(arr[i] == x)\\n\\t\\t\\treturn i\\n\\t\\tend\\n\\tend\\n\\treturn -1\\nend\\n\"",
    "linear search": "\"\\\"\\\"\\\"\\n    linear_search(array, key)\\nA simple search of `array`, element per element until `key` is found.\\n\\\"\\\"\\\"\\nfunction linear_search(array, key)\\n    for i in 1:length(array)\\n        if array[i] == key\\n            return i\\n        end\\n    end\\n    return -1\\nend\\n\"",
    "bubble sort": "\"function bubble_sort!(array::Vector{T}) where {T}\\n    for i = 1:length(array)\\n        flag = false\\n        for j = 1:(length(array)-i)\\n            if array[j] > array[j+1]\\n                array[j], array[j+1] = array[j+1], array[j]\\n                flag = true\\n            end\\n        end\\n\\n        if !flag\\n            return\\n        end\\n    end\\nend\\n\"",
    "bucket sort": "\"\\\"\\\"\\\"\\n# Bucket Sort\\n\\nBucket Sort is a divide and conquer sorting algorithm.\\nIt distributes elements into buckets and sort each bucket before merging all buckets\\nBuckets are arrays that each stores a different range of elements\\nInsertion sort is used to sort the buckets because its fast in small-sized arrays\\n\\n## Bucket Calculation\\n\\nnumber of buckets = length of array\\nsize of buckets = (largest element - smallest element + 1) / length of array\\n\\n## Bucket Sort Steps\\n\\n1. Create an array of buckets\\n2. Add each elements into its respective bucket\\n3. Sort each non-empty bucket\\n4. Concatenate elements of non-empty buckets\\n\\n## Example\\n\\n1. Array of [3, 5, 2, 9] has 4 buckets\\n2. The size of buckets = (9 - 2 + 1) / 4 = 2\\n3. The range of elements can be assign to each bucket, x\\n    bucket 1: 2 <= x < 4\\n    bucket 2: 4 <= x < 6\\n    bucket 3: 6 <= x < 8\\n    bucket 4: 8 <= x <= 9\\n4. The distribution of elements in the buckets = [3, 2][5][][9]\\n5. After sorting the elements each bucket = [2, 3][5][][9]\\n6. Concatenate all elements = [2, 3, 5, 9]\\n\\n# Example\\n```julia\\nBucketSort!([3, 5, 2, 9]) # returns [2, 3, 5, 9]\\n```\\n\\nContributed By:- [Ming Liang](https://github.com/DrakonDarquesse)\\n\\\"\\\"\\\"\\n\\nfunction bucket_sort!(arr::Vector{T}, l::Int=length(arr)) where T\\n    if l==0\\n        return\\n    end\\n\\n    max = maximum(arr)\\n    min = minimum(arr)\\n    r = (max-min+1)/l\\n    buckets = Array{T, 1}[[] for a in 1:l]\\n\\n    for i in arr\\n        push!(buckets[floor(Int, (i-min)/r)+1], i)\\n    end\\n\\n    for bucket in buckets\\n        for i in 1:length(bucket)\\n            val = bucket[i]\\n            idx = i\\n            while idx > 1 && val < bucket[idx-1]\\n                bucket[idx] = bucket[idx-1]\\n                idx = idx - 1\\n            end\\n\\n            bucket[idx] = val\\n        end\\n    end\\n    copy!(arr, vcat(buckets...))\\nend\\n\"",
    "counting sort": "\"\\\"\\\"\\\"\\n# Counting Sort \\nOVERVIEW:\\nCounting Sort is a sorting algorithm that sort elements within a specific range.\\nThe sorting technique is to count the existing element and stored its occurrence time in a new list, then only print it out.\\n\\nSTEPS: \\nAssume the input as --> x=[-3, 1, -5, 0, -3]\\n  minimum = -5\\n- STEP 1: Create a list size within the range, in this case is -5 --> 1 which have range of 7 (-5, -4, -3, -2, -1, 0, 1), so list with size 7 and assign all to 0 is created\\n- STEP 2: Count the occurances of element in the list \\n          First number = -3 it is the third number in the range, so count[3]+=1\\n          Final view:\\n          index : ( 1,  2,  3,  4,  5, 6, 7)\\n          range : (-5, -4, -3, -2, -1, 0, 1)\\n          count : [ 1,  0,  2,  0,  0, 1, 1] <-- the list will store this occurences\\n- STEP 3: Make the count list accumulate the occurances \\n          The final count is (1, 1, 3, 3, 3, 4, 5)\\n- STEP 4: Assign the elements in x into correct possition by creating a new list (will call 'output' in this sample)\\n          the 1st element in 'x' is -3, it is third in range, so it will call the index of 3 in 'count', which is 3 and assign the -3 in to 3rd position in 'output', \\n          then the third element in range will deduct by 1, so the next repeated element will get the correct position, new 'count' --> [1, 1, 2, 3, 3, 4, 5]\\n\\n          the 2nd element in 'x' is  1, it is last  in range, so it will call the index of 7 in 'count', which is 5 and assign the  1 in to 5th position in 'output', \\n          new 'count' --> [1, 1, 2, 3, 3, 4, 4]\\n          ......\\n          ......\\n          *If you want the order of original array to have the same order as the output array use can change this to decremental for loop\\n- STEP 5: Assign the 'ouput' list back to 'x'\\n\\nFINAL RESULT -->  [-5, -3, -3, 0, 1]                                                                                    \\n\\\"\\\"\\\"\\nfunction counting_sort!(arr::Vector{T},l::Int=1,r::Int=length(arr))where T\\n    if l>=r\\n        return\\n    end\\n    max = maximum(arr)\\n    min = minimum(arr)\\n    range = max-min+1\\n    count = Vector{T}(undef, range)\\n    output = Vector{T}(undef, r)\\n\\n    for i in 1:range\\n      count[i]=0\\n    end\\n\\n    # Store count of the item that appear in the 'arr' (STEP 2)\\n    for i in 1:r\\n      count[arr[i]-min+1]+=1\\n    end\\n\\n    # Calculate cumulative frequency in 'count' (STEP 3)\\n    for i in 2:length(count)\\n      count[i] += count[i-1]\\n    end\\n\\n    # Build the 'output' by assigning the item into correct position (STEP 4)\\n    for i in 1:r\\n      index = arr[i] - min + 1\\n      output[count[index]] = arr[i]\\n      count[index]-=1\\n    end\\n\\n    # Copy the 'output' to 'arr', so that 'arr' contain sorted item (STEP 5)\\n    for i in 1:r\\n      arr[i]=output[i]\\n    end\\n  \\nend\"",
    "exchange sort": "\"\\\"\\\"\\\"\\n    ExchangeSort(arr)\\n\\nSort an array by exchanging elements that are not in their proper position, hence Exchange Sort\\n\\nExchange Sort Steps\\n1. Compares each element of an array\\n2. Swap those elements that are not in their proper position\\n\\nExample\\n1. An array of [1, 2, 4, 3, 5] and compare each elements\\n2. Since 4 is greater than 3\\n3. Swap both position\\n4. Returns [1, 2, 3, 4, 5]\\n\\nProgram to sort an array\\n\\n# Example\\n```julia\\nExchangeSort([5, 4, 3, 2, 1]) # returns [1, 2, 3, 4, 5]\\nExchangeSort([1, 2, 3, 4, 5]) # returns [1, 2, 3, 4, 5]\\nExchangeSort(['5', '4', '3', '2', '1']) # returns ['1', '2', '3', '4', '5']\\n```\\n\\nContributed By:- [Gervin Fung](https://github.com/GervinFung)\\n\\\"\\\"\\\"\\n\\nfunction exchange_sort!(arr::Vector{T})where T\\n    size=length(arr)\\n    for i in 1:size\\n        for j in i:size\\n            if (arr[i]>arr[j])\\n                temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n            end\\n        end\\n    end\\nend\\n\"",
    "heap sort": "\"\\\"\\\"\\\"\\n    idx_for(i::Int)  \\n\\nSimple helper function for converting 0-based indices to Julia's 1-based indices.\\n\\\"\\\"\\\"\\nfunction idx_for(i::Int) \\n  return i + 1\\nend\\n\\n\\\"\\\"\\\"\\n    heap_sort!(arr::Vector{T}, gt = >, N::Int = length(arr)) where {T}\\n\\nSort the given vector (in-place) using the Heapsort algorithm.\\n\\nHeapsort consists of two stages:\\n  1. Building a (max) heap of the array\\n  2. Repeatedly extracting the largest element and inserting it at the front of the sorted part of the array\\n\\nAfter the largest element has been extracted, the tree is updated to maintain the heap property via a \\\"sifting\\\" operation.\\n\\n  Storing a heap in an array is pretty straightforward - for every node with index n, its children are stored at indices\\n  2n + 1 and 2n + 2 (for 0-based indices). Index 0 contains the root node.\\n  Since Julia's indices are 1-based, we need to change this a little bit. We're using a trivial helper function \\n  idx_for to convert from 0-based to 1-based.\\n\\n  See https://en.wikipedia.org/wiki/Heapsort for a complete explanation of Heapsort.\\n\\n  Contributed By:- [Frank Schmitt](https://github.com/frankschmitt)\\n\\\"\\\"\\\" \\nfunction heap_sort!(arr::Vector{T}, gt = >, N::Int = length(arr)) where {T}\\n      n = N \\n      i = div(n,2) \\n      t = -1\\n  \\n      while true \\n          if (i > 0)    # First stage - Sorting the heap\\n              i -= 1    # Save its index to i \\n              t = arr[idx_for(i)]    # Save parent value to t \\n          else          # Second stage - Extracting elements in-place \\n              n -= 1    # Make the new heap smaller \\n              if (n == 0) \\n                return # When the heap is empty, we are done \\n              end\\n              t = arr[idx_for(n)]               # Save last value (it will be overwritten)\\n              arr[idx_for(n)] = arr[idx_for(0)] # Save largest value at the end of arr \\n          end\\n  \\n          parent = i # We will start pushing down t from parent \\n          child = i*2 + 1 # parent's left child \\n  \\n          # Sift operation - pushing the value of t down the heap \\n          while (child < n) \\n              if (child + 1 < n  &&  gt(arr[idx_for(child + 1)], arr[idx_for(child)])) \\n                  child += 1 # Choose the largest child\\n              end \\n              if (gt(arr[idx_for(child)], t))                   # If any child is bigger than the parent \\n                  arr[idx_for(parent)] = arr[idx_for(child)]    # Move the largest child up \\n                  parent = child                                # Move parent pointer to this child \\n                  child = parent*2+1                            #  find the next child\\n              else\\n                  break # t's place is found \\n              end\\n          end\\n          arr[idx_for(parent)] = t # We save t in the heap \\n      end\\n  end\\n\"",
    "insertion sort": "\"function insertion_sort!(arr::Vector{T})where T\\n    for i in 1:length(arr)-1\\n        temp=arr[i+1]\\n        j=i\\n        while j>0&&arr[j]>temp\\n            arr[j+1]=arr[j]\\n            j-=1\\n        end\\n        arr[j+1]=temp\\n    end\\nend\\n\"",
    "merge sort": "\"function merge_sort!(arr::Vector{T},l::Int=1,r::Int=length(arr),temp::Vector{T}=Vector{T}(undef,r-l+1))where T\\n    if l>=r\\n        return\\n    end\\n    # split\\n    mid=(l+r)>>1\\n    merge_sort!(arr,l,mid)\\n    merge_sort!(arr,mid+1,r)\\n    # merge\\n    l_pos=l # pos of the left part\\n    r_pos=mid+1 # pos of the right part\\n    for t_pos in 1:r-l+1\\n        if l_pos<=mid && (r_pos>r || arr[l_pos]<arr[r_pos])\\n            temp[t_pos]=arr[l_pos]\\n            l_pos+=1\\n        else\\n            temp[t_pos]=arr[r_pos]\\n            r_pos+=1\\n        end\\n    end\\n    for i in l:r\\n        arr[i]=temp[i-l+1]\\n    end\\nend\\n\"",
    "quick sort": "\"function quick_sort!(arr::Vector{T},l::Int=1,r::Int=length(arr))where T\\n    if l>=r\\n        return\\n    end\\n    mid=arr[(l+r)>>1]\\n    l_pos=l\\n    r_pos=r\\n    while l_pos<=r_pos\\n        while arr[l_pos]<mid l_pos+=1 end\\n        while arr[r_pos]>mid r_pos-=1 end\\n        if l_pos<=r_pos\\n            t=arr[l_pos]\\n            arr[l_pos]=arr[r_pos]\\n            arr[r_pos]=t\\n            l_pos+=1\\n            r_pos-=1\\n        end\\n    end\\n    if l<r_pos quick_sort!(arr,l,r_pos) end\\n    if l_pos<r quick_sort!(arr,l_pos,r) end\\nend\"",
    "selection sort": "\"function selection_sort!(arr::Vector{T})where T\\n    l=length(arr)\\n    for i in 1:l-1\\n        place=i\\n        for j in i+1:l\\n            if arr[j]<arr[place] place=j end\\n        end\\n        temp=arr[i]\\n        arr[i]=arr[place]\\n        arr[place]=temp\\n    end\\nend\\n\"",
    "pearson correlation": "\"\\\"\\\"\\\"\\n    pearson_correlation(x, y)\\n\\nFind the pearson correlation between two variables.\\n\\n# Example:\\n\\njulia> PearsonCorrelation([12,11,16,17,19,21],[11,51,66,72,12,15])\\n-0.2092706263573845\\n\\nContribution by: [Aru Bhardwaj](https://github.com/arubhardwaj)\\n\\n\\n\\\"\\\"\\\"\\n\\nfunction pearson_correlation(x, y)\\n    mean_x = sum(x) / length(x)\\n    mean_y = sum(y) / length(y)\\n    XY = (x .- mean_x) .* (y .- mean_y)\\n    XXs = sum((x .- mean_x) .* (x .- mean_x))\\n    YYs = sum((y .- mean_y) .* (y .- mean_y))\\n    return(sum(XY) / (sqrt(XXs .* YYs)))\\nend\\n\"",
    "variance": "\"\\\"\\\"\\\"\\n    variance(a)\\n\\nFind the variance from a set of data.\\n\\n# Arguments:\\n- `a`: holds the set of data\\n\\n# Reference\\n    - According to Ronald E. Walpole, `variance` is used to measure the variability of a set of data. -- Introduction to Statistics by Ronald E. Walpole\\n\\n# Contributors:\\n- [Aru Bhardwaj](https://github.com/arubhardwaj)\\n\\\"\\\"\\\"\\nfunction variance(a)\\n    avg = sum(a) / length(a)\\n    x = sum((a .- avg).^2)\\n    s_sq = x / (length(a) - 1)\\n    return(s_sq)\\nend\\n\"",
    "detect anagrams": "\"\\\"\\\"\\\"\\n    detect_anagrams(subject, candidates)\\nA function that checks if a list of words\\nis an [Anagram](https://en.wikipedia.org/wiki/Anagram) or not of a subject word.\\n\\nis the original word = subject\\nis list of words to be compared if they are an anagram of `subject` = candidates\\n\\n```\\njulia> subject = \\\"listen\\\"\\njulia> candidates = [\\\"inlets\\\", \\\"enlists\\\", \\\"google\\\", \\\"banana\\\"]\\njulia> detect_anagrams(subject, candidates)\\n1-element Vector{String}:\\n \\\"inlets\\\"\\n```\\n\\nContributed By:- [Soc V. E.](https://github.com/ReneganRonin)\\nBased on my exercism's Julia track problem solution on [Anagrams](https://exercism.io/my/solutions/0a1d39faa5694624b7750be3ebf6c974).\\n\\nInstructions:\\n\\nAn anagram is a rearrangement of letters to form a new word. Given a word and a list of candidates, select the sublist of anagrams of the given word.\\nGiven \\\"listen\\\" and a list of candidates like \\\"enlists\\\" \\\"google\\\" \\\"inlets\\\" \\\"banana\\\" the program should return a list containing \\\"inlets\\\".\\n\\nInspired by the [Extreme Startup game](https://github.com/rchatley/extreme_startup)\\n\\\"\\\"\\\"\\nfunction detect_anagrams(subject, candidates)\\n    condition(i) = sort(collect(lowercase(subject))) == sort(collect(lowercase(i)))\\n    collection = collect(\\n        word for word in candidates if lowercase(word) != lowercase(subject)\\n    )\\n    return filter(condition, collection)\\nend\\n\"",
    "is palindrome": "\"\\\"\\\"\\\"\\n    is_palindrome(s)\\nA set of functions to check if a given string\\nis a palindrome.\\n\\nArguments:\\n - s - a string =#\\n\\\"\\\"\\\"\\n\\nfunction is_palindrome(s) # Named function\\n    s = lowercase(s)\\n    s == reverse(s)\\nend\\n\\ns -> s == reverse(s) # Anonymous\\n\"",
    "kmp substring search": "\"\\\"\\\"\\\"\\n    GetIndexWithKMP(string::String, sub_string::String, ignore_case::Bool)::Int\\n\\nFind if a string contain a given sub string with KMP Search, as an explanation might be too lengthy\\nAs such, a detailed explanation can be found at https://towardsdatascience.com/pattern-search-with-the-knuth-morris-pratt-kmp-algorithm-8562407dba5b\\n\\n\\nQuestions and answers\\n1. Why KMP instead of naive search?\\n- Given n = length of string , m = length of string P\\n- Then, the naive search will have time complexity O(mn) to find all occurrences of pattern P in S\\n- However, knuth-morris-pratt (KMP) algorithm will have tim complexity of O(m+n) to find all occurrences of pattern P in S\\n- Hence, KMP is more efficient than the naive approach\\n\\n\\nExample\\n\\n```julia\\nGetIndexWithKMP(\\\"Hello I am Gervin\\\", \\\"Hello I am Gervin\\\", false) # returns 1\\nGetIndexWithKMP(\\\"ABABDABACDABABCABAB\\\", \\\"ABABCABAB\\\", false) # returns 11\\nGetIndexWithKMP(\\\"SeEms Like IgNOrE CaSe Work\\\", \\\"seems like ignore case work\\\", true) # returns 1\\n```\\n\\nContributed By:- [Gervin Fung](https://github.com/GervinFung)\\nNote: This function will also allow ignoring cases also\\n\\n\\\"\\\"\\\"\\n\\n\\n# by convention -1 will be returned if the string does not contain the sub-string given\\n# in this case, 0 will be returned for Julia with start index of 1\\n# reason is that -1 is for language with start index of 0\\n# Should be convenient for others as most programming language use -1 if the string does not contain the sub-string given\\nconst NO_SUBSTRING_INDEX = 0\\n# 1 is the first index, unlike others, where 0 is the first index\\n# Should be convenient for others as most programming language use 0 as first index\\nconst JULIA_FIRST_INDEX = 1\\n\\nfunction create_suffic_array(pattern_length::Int, sub_string::String)::Vector{Int}\\n\\n    # Longest Proper Prefix which is Suffix array\\n    lps::Vector{Int} = ones(Int, pattern_length)\\n\\n    index::Int = JULIA_FIRST_INDEX\\n    i::Int = 1 + JULIA_FIRST_INDEX\\n\\n    while (i < pattern_length)\\n        if sub_string[i] == sub_string[index]\\n            lps[i] = index + 1;\\n            index += 1;\\n            i += 1;\\n        else\\n            if index != 1\\n                index = lps[index - 1]\\n            else\\n                lps[i] = 1\\n                i += 1\\n            end\\n        end\\n    end\\n\\n    return lps\\nend\\n\\n# this function will be used to obtain the index which the substring was found\\nfunction get_index_with_kmp(string::String, sub_string::String, ignore_case::Bool)::Int\\n\\n    string = ignore_case ? lowercase(string) : string\\n    sub_string = ignore_case ? lowercase(sub_string) : sub_string\\n\\n    string_length::Int = length(string)\\n    substring_length::Int = length(sub_string)\\n\\n    lps::Vector{Int} = create_suffic_array(substring_length, sub_string)\\n\\n    # likewise, 1 is the first index, unlike others, where 0 is the first index\\n    i::Int = JULIA_FIRST_INDEX\\n    j::Int = JULIA_FIRST_INDEX\\n\\n    while i < string_length + 1 && j < substring_length + 1\\n        if string[i] == sub_string[j]\\n            i += 1\\n            j += 1\\n        else\\n            if j != 1\\n                j = lps[j - 1]\\n            else\\n                i += 1\\n            end\\n        end\\n    end\\n\\n    return j == substring_length + 1 ? i - j + 1 : NO_SUBSTRING_INDEX\\nend\\n\\n# optional function that returns boolean if string does contain the sub-string given\\nfunction contain_substring_with_kmp(string::String, sub_string::String, ignore_case::Bool)::Bool\\n    return get_index_with_kmp(string, sub_string, ignore_case) != NO_SUBSTRING_INDEX\\nend\\n\"",
    "pangram": "\"\\\"\\\"\\\"\\r\\nispangram(input)\\r\\n\\r\\nProgram to determine the sentence is pangram or not.The program will return true if it is pangram and false if it is not.A full description of the algorithm can be found on [exercism](https://exercism.org/tracks/julia/exercises/pangram)\\r\\n\\r\\n# Arguments:\\r\\n- `input`: The sentence to find if its pangram or not.\\r\\n\\r\\n# Examples/Tests \\r\\n```julia\\r\\njulia> ispangram(Pack my box with five dozen liquor jugs)\\r\\ntrue\\r\\n\\r\\njulia> ispangram(The quick brown fox jumps over the lazy dog)\\r\\ntrue\\r\\n\\r\\njulia> wordcount(hello world!!!)\\r\\nfalse\\r\\n\\r\\n```\\r\\n\\r\\n# Algorithm: \\r\\n\\r\\n```julia\\r\\n\\r\\nfor letter in input\\r\\n    if 'A' <= letter <= 'Z'\\r\\n        x &= ~(1<<(letter-'A'))\\r\\n    elseif 'a' <= letter <= 'z'\\r\\n        x &= ~(1<<(letter-'a'))\\r\\n    end\\r\\n    x == 0 && return true\\r\\nend\\r\\n\\r\\n```\\r\\n\\r\\n# References:\\r\\n(https://exercism.org/tracks/julia/exercises/pangram)\\r\\n\\r\\n```\\r\\n\\r\\n# Contributed by:- [Ihjass Thasbekha](https://github.com/Ihjass)\\r\\n\\\"\\\"\\\"\\r\\nfunction ispangram(input)\\r\\n    x = 2^26-1\\r\\n    for letter in input\\r\\n        if 'A' <= letter <= 'Z'\\r\\n            x &= ~(1<<(letter-'A'))\\r\\n        elseif 'a' <= letter <= 'z'\\r\\n            x &= ~(1<<(letter-'a'))\\r\\n        end\\r\\n        x == 0 && return true\\r\\n    end\\r\\n    return false\\r\\nend\\r\\n\"",
    "word count": "\"\\\"\\\"\\\"\\r\\nwordcount(sentence)\\r\\n\\r\\nProgram to find word count in the given sentence. The program will return count with the word.\\r\\nA full description of the algorithm can be found on [exercism](https://exercism.org/tracks/julia/exercises/word-count)\\r\\n\\r\\n# Arguments:\\r\\n- `sentence`: The sentence to find the word count.\\r\\n\\r\\n# Examples/Tests \\r\\n```julia\\r\\njulia> wordcount(The quick brown fox jumps over the lazy dog)\\r\\nDict{Any, Any}(\\\"jumps\\\" => 1, \\\"the\\\" => 2, \\\"brown\\\" => 1, \\\"over\\\" => 1, \\\"quick\\\" => 1, \\\"lazy\\\" => 1, \\\"dog\\\" => 1, \\\"fox\\\" => 1)\\r\\n\\r\\njulia> wordcount(the sky is blue and beautiful)\\r\\nDict{Any, Any}(\\\"and\\\" => 1, \\\"the\\\" => 1, \\\"sky\\\" => 1, \\\"blue\\\" => 1, \\\"is\\\" => 1, \\\"beautiful\\\" => 1)\\r\\n\\r\\n```\\r\\n\\r\\n# Algorithm: \\r\\n\\r\\n```julia\\r\\n\\r\\nfor word in eachmatch(reg_expression, sentence)\\r\\n    if !haskey(counts, word.match)\\r\\n        counts[word.match] = 1\\r\\n    else\\r\\n        counts[word.match] += 1\\r\\n    end\\r\\nend\\r\\n\\r\\n```\\r\\n\\r\\n# References:\\r\\n(https://exercism.org/tracks/julia/exercises/word-count)\\r\\n\\r\\n```\\r\\n\\r\\n# Contributed by:- [Ihjass Thasbekha](https://github.com/Ihjass)\\r\\n\\\"\\\"\\\"\\r\\nfunction word_count(sentence)\\r\\n    lowercase_sentence = lowercase(sentence)\\r\\n    counts = Dict()\\r\\n    regex = r\\\"(\\\\w+('\\\\w)?)\\\"\\r\\n    for w in eachmatch(regex, lowercase_sentence)\\r\\n        if !haskey(counts, w.match)\\r\\n            counts[w.match] = 1\\r\\n        else\\r\\n            counts[w.match] += 1\\r\\n        end\\r\\n    end\\r\\n    return counts\\r\\nend\\r\\n\"",
    "basic binary search tree": "\"include(\\\"basic_binary_tree.jl\\\")\\n\\\"\\\"\\\"\\narray-based binary search tree\\nleft tree values < root value < right tree values\\n\\\"\\\"\\\"\\nabstract type AbstractBinarySearchTree_arr<:AbstractBinaryTree_arr end\\nfunction Base.findfirst(value::T,tree::Tree,place::Int=tree.root)where {T,Tree<:AbstractBinarySearchTree_arr}\\n    if tree.val[place]==value\\n        return place\\n    elseif tree.val[place]>value\\n        if tree.lch[place]==0 return 0 end\\n        return findfirst(value,tree,tree.lch[place])\\n    else\\n        if tree.rch[place]==0 return 0 end\\n        return findfirst(value,tree,tree.rch[place])\\n    end\\nend\\n\"",
    "basic binary tree": "\"abstract type AbstractBinaryTree end\\n\\\"\\\"\\\"\\narray-based binary tree\\n\\\"\\\"\\\"\\nabstract type AbstractBinaryTree_arr<:AbstractBinaryTree end\\nmutable struct BinaryTree{T}<:AbstractBinaryTree_arr where T\\n    n::Int\\n    root::Int\\n    par::Vector{Int}\\n    lch::Vector{Int}\\n    rch::Vector{Int}\\n    val::Vector{T}\\nend\\nfunction BinaryTree{T}(size::Int,rootval::T)where T\\n    x=BinaryTree(1,1,zeros(T,size),zeros(T,size),zeros(T,size),Vector{T}(undef,size))\\n    x.val[1]=rootval\\n    return x\\nend\\n\\nfunction Base.insert!(tree::BinaryTree,from::Int,value,place::Bool)\\n    tree.n+=1\\n    tree.par[tree.n]=from\\n    if place\\n        tree.rch[from]=tree.n\\n    else\\n        tree.lch[from]=tree.n\\n    end\\n    tree.val[tree.n]=value\\nend\\n\\nfunction Base.insert!(tree::BinaryTree,from::Int,value)\\n    if tree.lch[from]==0\\n        insert!(tree,from,value,false)\\n    elseif tree.rch[from]==0\\n        insert!(tree,from,value,true)\\n    else\\n        return false\\n    end\\n    return true\\nend\\n\\n# for AbstractBinaryTree_arr\\nfunction isleaf(tree::Tree,from::Int)::Bool where Tree<:AbstractBinaryTree_arr\\n    return tree.lch[from]==0&&tree.rch[from]==0\\nend\\n\\nfunction ch(tree::Tree,from::Int,select::Bool)where Tree<:AbstractBinaryTree_arr\\n    if select return tree.rch[from]\\n    else return tree.lch[from]\\n    end\\nend\\n\\nfunction set_ch(tree::Tree,from::Int,select::Bool,value::T)where {Tree<:AbstractBinaryTree_arr,T}\\n    if select tree.rch[from]=value\\n    else tree.lch[from]=value\\n    end\\nend\\n\\nfunction height(tree::Tree,from::Int=tree.root)where Tree<:AbstractBinaryTree_arr\\n    count=0\\n    if tree.lch[from]!=0 count=height(tree,tree.lch[from])+1 end\\n    if tree.rch[from]!=0 count=max(height(tree,tree.rch[from])+1,count) end\\n    return count\\nend\\n\\nfunction depth(tree::Tree,from::Int)where Tree<:AbstractBinaryTree_arr\\n    count=0\\n    while from!=tree.root\\n        count+=1\\n        from=tree.par[from]\\n    end\\n    return count\\nend\\n\\nfunction left(tree::Tree,from::Int=tree.root)where Tree<:AbstractBinaryTree_arr\\n    if tree.lch[from]==0\\n        return from\\n    else\\n        return left(tree,tree.lch[from])\\n    end\\nend\\n\\nfunction right(tree::Tree,from::Int=tree.root)where Tree<:AbstractBinaryTree_arr\\n    if tree.rch[from]==0\\n        return from\\n    else\\n        return right(tree,tree.rch[from])\\n    end\\nend\\n\"",
    "splay": "\"include(\\\"basic_binary_search_tree.jl\\\")\\nmutable struct Splay{T}<:AbstractBinarySearchTree_arr where T\\n    n::Int\\n    root::Int\\n    par::Vector{Int}\\n    lch::Vector{Int}\\n    rch::Vector{Int}\\n    val::Vector{T}\\n\\n    cnt::Vector{Int}\\n    size::Vector{Int}\\nend\\n\"",
    "disjoint set": "\"\\\"\\\"\\\"\\nThis can contain a maximum of `length(par)` parenting-relations\\npar is an array of `Int`, which is the index of the parent node.\\n\\\"\\\"\\\"\\nmutable struct DisjointSet\\n    par::Vector{Int}\\n    function DisjointSet(size)\\n        x=[i for i in 1:size]\\n        return new(x)\\n    end\\nend\\n\\n\\\"\\\"\\\"\\nFind the ancestor of node `x`.\\n\\\"\\\"\\\"\\nfunction find(set::DisjointSet,x::Int)::Int\\n    if set.par[x]==x return x\\n    else return set.par[x]=find(set,set.par[x])\\n    end\\nend\\n\\nfunction Base.merge!(set::DisjointSet,x::Int,y::Int)\\n    x=find(set,x)\\n    y=find(set,y)\\n    set.par[x]=y\\nend\\n\""
  }
}
