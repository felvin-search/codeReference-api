{
  "c#": {
    "burrows wheeler transform": "\"using System;\\nusing System.Linq;\\n\\nnamespace Algorithms.DataCompression\\n{\\n    /// <summary>\\n    ///     The Burrows–Wheeler transform (BWT) rearranges a character string into runs of similar characters.\\n    ///     This is useful for compression, since it tends to be easy to compress a string that has runs of repeated\\n    ///     characters.\\n    ///     See <a href=\\\"https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform\\\">here</a> for more info.\\n    /// </summary>\\n    public class BurrowsWheelerTransform\\n    {\\n        /// <summary>\\n        ///     Encodes the input string using BWT and returns encoded string and the index of original string in the sorted\\n        ///     rotation matrix.\\n        /// </summary>\\n        /// <param name=\\\"s\\\">Input string.</param>\\n        public (string encoded, int index) Encode(string s)\\n        {\\n            if (s.Length == 0)\\n            {\\n                return (string.Empty, 0);\\n            }\\n\\n            var rotations = GetRotations(s);\\n            Array.Sort(rotations, StringComparer.Ordinal);\\n            var lastColumn = rotations\\n                .Select(x => x[^1])\\n                .ToArray();\\n            var encoded = new string(lastColumn);\\n            return (encoded, Array.IndexOf(rotations, s));\\n        }\\n\\n        /// <summary>\\n        ///     Decodes the input string and returns original string.\\n        /// </summary>\\n        /// <param name=\\\"s\\\">Encoded string.</param>\\n        /// <param name=\\\"index\\\">Index  of original string in the sorted rotation matrix.</param>\\n        public string Decode(string s, int index)\\n        {\\n            if (s.Length == 0)\\n            {\\n                return string.Empty;\\n            }\\n\\n            var rotations = new string[s.Length];\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                for (var j = 0; j < s.Length; j++)\\n                {\\n                    rotations[j] = s[j] + rotations[j];\\n                }\\n\\n                Array.Sort(rotations, StringComparer.Ordinal);\\n            }\\n\\n            return rotations[index];\\n        }\\n\\n        private string[] GetRotations(string s)\\n        {\\n            var result = new string[s.Length];\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                result[i] = s.Substring(i) + s.Substring(0, i);\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n\"",
    "huffman compressor": "\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing Algorithms.Sorters.Comparison;\\nusing Utilities.Extensions;\\n\\nnamespace Algorithms.DataCompression\\n{\\n    /// <summary>\\n    ///     Greedy lossless compression algorithm.\\n    /// </summary>\\n    public class HuffmanCompressor\\n    {\\n        // TODO: Use partial sorter\\n        private readonly IComparisonSorter<ListNode> sorter;\\n        private readonly Translator translator;\\n\\n        public HuffmanCompressor(IComparisonSorter<ListNode> sorter, Translator translator)\\n        {\\n            this.sorter = sorter;\\n            this.translator = translator;\\n        }\\n\\n        /// <summary>\\n        ///     Given an input string, returns a new compressed string\\n        ///     using huffman encoding.\\n        /// </summary>\\n        /// <param name=\\\"uncompressedText\\\">Text message to compress.</param>\\n        /// <returns>Compressed string and keys to decompress it.</returns>\\n        public (string compressedText, Dictionary<string, string> decompressionKeys) Compress(string uncompressedText)\\n        {\\n            if (string.IsNullOrEmpty(uncompressedText))\\n            {\\n                return (string.Empty, new Dictionary<string, string>());\\n            }\\n\\n            if (uncompressedText.Distinct().Count() == 1)\\n            {\\n                var dict = new Dictionary<string, string>\\n                {\\n                    { \\\"1\\\", uncompressedText[0].ToString() },\\n                };\\n                return (new string('1', uncompressedText.Length), dict);\\n            }\\n\\n            var nodes = GetListNodesFromText(uncompressedText);\\n            var tree = GenerateHuffmanTree(nodes);\\n            var (compressionKeys, decompressionKeys) = GetKeys(tree);\\n            return (translator.Translate(uncompressedText, compressionKeys), decompressionKeys);\\n        }\\n\\n        /// <summary>\\n        ///     Finds frequency for each character in the text.\\n        /// </summary>\\n        /// <returns>Symbol-frequency array.</returns>\\n        private static ListNode[] GetListNodesFromText(string text)\\n        {\\n            var occurenceCounts = new Dictionary<char, int>();\\n\\n            foreach (var ch in text)\\n            {\\n                if (!occurenceCounts.ContainsKey(ch))\\n                {\\n                    occurenceCounts.Add(ch, 0);\\n                }\\n\\n                occurenceCounts[ch]++;\\n            }\\n\\n            return occurenceCounts.Select(kvp => new ListNode(kvp.Key, 1d * kvp.Value / text.Length)).ToArray();\\n        }\\n\\n        private (Dictionary<string, string> compressionKeys, Dictionary<string, string> decompressionKeys) GetKeys(\\n            ListNode tree)\\n        {\\n            var compressionKeys = new Dictionary<string, string>();\\n            var decompressionKeys = new Dictionary<string, string>();\\n\\n            if (tree.HasData)\\n            {\\n                compressionKeys.Add(tree.Data.ToString(), string.Empty);\\n                decompressionKeys.Add(string.Empty, tree.Data.ToString());\\n                return (compressionKeys, decompressionKeys);\\n            }\\n\\n            if (tree.LeftChild is not null)\\n            {\\n                var (lsck, lsdk) = GetKeys(tree.LeftChild);\\n                compressionKeys.AddMany(lsck.Select(kvp => (kvp.Key, \\\"0\\\" + kvp.Value)));\\n                decompressionKeys.AddMany(lsdk.Select(kvp => (\\\"0\\\" + kvp.Key, kvp.Value)));\\n            }\\n\\n            if (tree.RightChild is not null)\\n            {\\n                var (rsck, rsdk) = GetKeys(tree.RightChild);\\n                compressionKeys.AddMany(rsck.Select(kvp => (kvp.Key, \\\"1\\\" + kvp.Value)));\\n                decompressionKeys.AddMany(rsdk.Select(kvp => (\\\"1\\\" + kvp.Key, kvp.Value)));\\n\\n                return (compressionKeys, decompressionKeys);\\n            }\\n\\n            return (compressionKeys, decompressionKeys);\\n        }\\n\\n        private ListNode GenerateHuffmanTree(ListNode[] nodes)\\n        {\\n            var comparer = new ListNodeComparer();\\n            while (nodes.Length > 1)\\n            {\\n                sorter.Sort(nodes, comparer);\\n\\n                var left = nodes[0];\\n                var right = nodes[1];\\n\\n                var newNodes = new ListNode[nodes.Length - 1];\\n                Array.Copy(nodes, 2, newNodes, 1, nodes.Length - 2);\\n                newNodes[0] = new ListNode(left, right);\\n                nodes = newNodes;\\n            }\\n\\n            return nodes[0];\\n        }\\n\\n        /// <summary>\\n        ///     Represents tree structure for the algorithm.\\n        /// </summary>\\n        public class ListNode\\n        {\\n            public ListNode(char data, double frequency)\\n            {\\n                HasData = true;\\n                Data = data;\\n                Frequency = frequency;\\n            }\\n\\n            public ListNode(ListNode leftChild, ListNode rightChild)\\n            {\\n                LeftChild = leftChild;\\n                RightChild = rightChild;\\n                Frequency = leftChild.Frequency + rightChild.Frequency;\\n            }\\n\\n            public char Data { get; }\\n\\n            public bool HasData { get; }\\n\\n            public double Frequency { get; }\\n\\n            public ListNode? RightChild { get; }\\n\\n            public ListNode? LeftChild { get; }\\n        }\\n\\n        public class ListNodeComparer : IComparer<ListNode>\\n        {\\n            public int Compare(ListNode? x, ListNode? y)\\n            {\\n                if (x is null || y is null)\\n                {\\n                    return 0;\\n                }\\n\\n                return x.Frequency.CompareTo(y.Frequency);\\n            }\\n        }\\n    }\\n}\\n\"",
    "shannon fano compressor": "\"using System.Collections.Generic;\\nusing System.Linq;\\nusing Algorithms.Knapsack;\\nusing Utilities.Extensions;\\n\\nnamespace Algorithms.DataCompression\\n{\\n    /// <summary>\\n    ///     Greedy lossless compression algorithm.\\n    /// </summary>\\n    public class ShannonFanoCompressor\\n    {\\n        private readonly IHeuristicKnapsackSolver<(char symbol, double frequency)> splitter;\\n        private readonly Translator translator;\\n\\n        public ShannonFanoCompressor(\\n            IHeuristicKnapsackSolver<(char symbol, double frequency)> splitter,\\n            Translator translator)\\n        {\\n            this.splitter = splitter;\\n            this.translator = translator;\\n        }\\n\\n        /// <summary>\\n        ///     Given an input string, returns a new compressed string\\n        ///     using Shannon-Fano encoding.\\n        /// </summary>\\n        /// <param name=\\\"uncompressedText\\\">Text message to compress.</param>\\n        /// <returns>Compressed string and keys to decompress it.</returns>\\n        public (string compressedText, Dictionary<string, string> decompressionKeys) Compress(string uncompressedText)\\n        {\\n            if (string.IsNullOrEmpty(uncompressedText))\\n            {\\n                return (string.Empty, new Dictionary<string, string>());\\n            }\\n\\n            if (uncompressedText.Distinct().Count() == 1)\\n            {\\n                var dict = new Dictionary<string, string>\\n                {\\n                    { \\\"1\\\", uncompressedText[0].ToString() },\\n                };\\n                return (new string('1', uncompressedText.Length), dict);\\n            }\\n\\n            var node = GetListNodeFromText(uncompressedText);\\n            var tree = GenerateShannonFanoTree(node);\\n            var (compressionKeys, decompressionKeys) = GetKeys(tree);\\n            return (translator.Translate(uncompressedText, compressionKeys), decompressionKeys);\\n        }\\n\\n        private (Dictionary<string, string> compressionKeys, Dictionary<string, string> decompressionKeys) GetKeys(\\n            ListNode tree)\\n        {\\n            var compressionKeys = new Dictionary<string, string>();\\n            var decompressionKeys = new Dictionary<string, string>();\\n\\n            if (tree.Data.Length == 1)\\n            {\\n                compressionKeys.Add(tree.Data[0].symbol.ToString(), string.Empty);\\n                decompressionKeys.Add(string.Empty, tree.Data[0].symbol.ToString());\\n                return (compressionKeys, decompressionKeys);\\n            }\\n\\n            if (tree.LeftChild is not null)\\n            {\\n                var (lsck, lsdk) = GetKeys(tree.LeftChild);\\n                compressionKeys.AddMany(lsck.Select(kvp => (kvp.Key, \\\"0\\\" + kvp.Value)));\\n                decompressionKeys.AddMany(lsdk.Select(kvp => (\\\"0\\\" + kvp.Key, kvp.Value)));\\n            }\\n\\n            if (tree.RightChild is not null)\\n            {\\n                var (rsck, rsdk) = GetKeys(tree.RightChild);\\n                compressionKeys.AddMany(rsck.Select(kvp => (kvp.Key, \\\"1\\\" + kvp.Value)));\\n                decompressionKeys.AddMany(rsdk.Select(kvp => (\\\"1\\\" + kvp.Key, kvp.Value)));\\n            }\\n\\n            return (compressionKeys, decompressionKeys);\\n        }\\n\\n        private ListNode GenerateShannonFanoTree(ListNode node)\\n        {\\n            if (node.Data.Length == 1)\\n            {\\n                return node;\\n            }\\n\\n            var left = splitter.Solve(node.Data, 0.5 * node.Data.Sum(x => x.frequency), x => x.frequency, _ => 1);\\n            var right = node.Data.Except(left).ToArray();\\n\\n            node.LeftChild = GenerateShannonFanoTree(new ListNode(left));\\n            node.RightChild = GenerateShannonFanoTree(new ListNode(right));\\n\\n            return node;\\n        }\\n\\n        /// <summary>\\n        ///     Finds frequency for each character in the text.\\n        /// </summary>\\n        /// <returns>Symbol-frequency array.</returns>\\n        private ListNode GetListNodeFromText(string text)\\n        {\\n            var occurenceCounts = new Dictionary<char, double>();\\n\\n            for (var i = 0; i < text.Length; i++)\\n            {\\n                var ch = text[i];\\n                if (!occurenceCounts.ContainsKey(ch))\\n                {\\n                    occurenceCounts.Add(ch, 0);\\n                }\\n\\n                occurenceCounts[ch]++;\\n            }\\n\\n            return new ListNode(occurenceCounts.Select(kvp => (kvp.Key, 1d * kvp.Value / text.Length)).ToArray());\\n        }\\n\\n        /// <summary>\\n        ///     Represents tree structure for the algorithm.\\n        /// </summary>\\n        public class ListNode\\n        {\\n            public ListNode((char symbol, double frequency)[] data) => Data = data;\\n\\n            public (char symbol, double frequency)[] Data { get; }\\n\\n            public ListNode? RightChild { get; set; }\\n\\n            public ListNode? LeftChild { get; set; }\\n        }\\n    }\\n}\\n\"",
    "translator": "\"using System.Collections.Generic;\\nusing System.Text;\\n\\nnamespace Algorithms.DataCompression\\n{\\n    /// <summary>\\n    ///     TODO.\\n    /// </summary>\\n    public class Translator\\n    {\\n        /// <summary>\\n        ///     TODO.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">TODO. 2.</param>\\n        /// <param name=\\\"translationKeys\\\">TODO. 3.</param>\\n        /// <returns>TODO. 4.</returns>\\n        public string Translate(string text, Dictionary<string, string> translationKeys)\\n        {\\n            var sb = new StringBuilder();\\n\\n            var start = 0;\\n            for (var i = 0; i < text.Length; i++)\\n            {\\n                var key = text.Substring(start, i - start + 1);\\n                if (translationKeys.ContainsKey(key))\\n                {\\n                    _ = sb.Append(translationKeys[key]);\\n                    start = i + 1;\\n                }\\n            }\\n\\n            return sb.ToString();\\n        }\\n    }\\n}\\n\"",
    "caesar encoder": "\"using System.Text;\\n\\nnamespace Algorithms.Encoders\\n{\\n    /// <summary>\\n    ///     Encodes using caesar cypher.\\n    /// </summary>\\n    public class CaesarEncoder : IEncoder<int>\\n    {\\n        /// <summary>\\n        ///     Encodes text using specified key,\\n        ///     time complexity: O(n),\\n        ///     space complexity: O(n),\\n        ///     where n - text length.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">Text to be encoded.</param>\\n        /// <param name=\\\"key\\\">Key that will be used to encode the text.</param>\\n        /// <returns>Encoded text.</returns>\\n        public string Encode(string text, int key) => Cipher(text, key);\\n\\n        /// <summary>\\n        ///     Decodes text that was encoded using specified key,\\n        ///     time complexity: O(n),\\n        ///     space complexity: O(n),\\n        ///     where n - text length.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">Text to be decoded.</param>\\n        /// <param name=\\\"key\\\">Key that was used to encode the text.</param>\\n        /// <returns>Decoded text.</returns>\\n        public string Decode(string text, int key) => Cipher(text, -key);\\n\\n        private static string Cipher(string text, int key)\\n        {\\n            var newText = new StringBuilder(text.Length);\\n            for (var i = 0; i < text.Length; i++)\\n            {\\n                if (!char.IsLetter(text[i]))\\n                {\\n                    _ = newText.Append(text[i]);\\n                    continue;\\n                }\\n\\n                var letterA = char.IsUpper(text[i]) ? 'A' : 'a';\\n                var letterZ = char.IsUpper(text[i]) ? 'Z' : 'z';\\n\\n                var c = text[i] + key;\\n                c -= c > letterZ ? 26 * (1 + (c - letterZ - 1) / 26) : 0;\\n                c += c < letterA ? 26 * (1 + (letterA - c - 1) / 26) : 0;\\n\\n                _ = newText.Append((char)c);\\n            }\\n\\n            return newText.ToString();\\n        }\\n    }\\n}\\n\"",
    "feistel cipher": "\"using System;\\nusing System.Collections.Generic;\\nusing System.Text;\\n\\nnamespace Algorithms.Encoders\\n{\\n    /// <summary>\\n    ///     Encodes using Feistel cipher.\\n    ///     https://en.wikipedia.org/wiki/Feistel_cipher\\n    ///     In cryptography, a Feistel cipher (also known as Luby–Rackoff block cipher)\\n    ///     is a symmetric structure used in the construction of block ciphers,\\n    ///     named after the German-born physicist and cryptographer Horst Feistel\\n    ///     who did pioneering research while working for IBM (USA)\\n    ///     A large proportion of block ciphers use the scheme, including the US DES,\\n    ///     the Soviet/Russian GOST and the more recent Blowfish and Twofish ciphers.\\n    /// </summary>\\n    public class FeistelCipher : IEncoder<uint>\\n    {\\n        // number of rounds to transform data block, each round a new \\\"round\\\" key is generated.\\n        private const int Rounds = 32;\\n\\n        /// <summary>\\n        ///     Encodes text using specified key,\\n        ///     where n - text length.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">Text to be encoded.</param>\\n        /// <param name=\\\"key\\\">Key that will be used to encode the text.</param>\\n        /// <exception cref=\\\"ArgumentException\\\">Error: key should be more than 0x00001111 for better encoding, key=0 will throw DivideByZero exception.</exception>\\n        /// <returns>Encoded text.</returns>\\n        public string Encode(string text, uint key)\\n        {\\n            List<ulong> blocksListPlain = SplitTextToBlocks(text);\\n            StringBuilder encodedText = new();\\n\\n            foreach (ulong block in blocksListPlain)\\n            {\\n                uint temp = 0;\\n\\n                // decompose a block to two subblocks 0x0123456789ABCDEF => 0x01234567 & 0x89ABCDEF\\n                uint rightSubblock = (uint)(block & 0x00000000FFFFFFFF);\\n                uint leftSubblock = (uint)(block >> 32);\\n\\n                uint roundKey;\\n\\n                // Feistel \\\"network\\\" itself\\n                for (int round = 0; round < Rounds; round++)\\n                {\\n                    roundKey = GetRoundKey(key, round);\\n                    temp = rightSubblock ^ BlockModification(leftSubblock, roundKey);\\n                    rightSubblock = leftSubblock;\\n                    leftSubblock = temp;\\n                }\\n\\n                // compile text string formating the block value to text (hex based), length of the output = 16 byte always\\n                ulong encodedBlock = leftSubblock;\\n                encodedBlock = (encodedBlock << 32) | rightSubblock;\\n                encodedText.Append(string.Format(\\\"{0:X16}\\\", encodedBlock));\\n            }\\n\\n            return encodedText.ToString();\\n        }\\n\\n        /// <summary>\\n        ///     Decodes text that was encoded using specified key.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">Text to be decoded.</param>\\n        /// <param name=\\\"key\\\">Key that was used to encode the text.</param>\\n        /// <exception cref=\\\"ArgumentException\\\">Error: key should be more than 0x00001111 for better encoding, key=0 will throw DivideByZero exception.</exception>\\n        /// <exception cref=\\\"ArgumentException\\\">Error: The length of text should be divisible by 16 as it the block lenght is 16 bytes.</exception>\\n        /// <returns>Decoded text.</returns>\\n        public string Decode(string text, uint key)\\n        {\\n            // The plain text will be padded to fill the size of block (16 bytes)\\n            if (text.Length % 16 != 0)\\n            {\\n                throw new ArgumentException($\\\"The length of {nameof(key)} should be divisible by 16\\\");\\n            }\\n\\n            List<ulong> blocksListEncoded = GetBlocksFromEncodedText(text);\\n            StringBuilder decodedTextHex = new();\\n\\n            foreach (ulong block in blocksListEncoded)\\n            {\\n                uint temp = 0;\\n\\n                // decompose a block to two subblocks 0x0123456789ABCDEF => 0x01234567 & 0x89ABCDEF\\n                uint rightSubblock = (uint)(block & 0x00000000FFFFFFFF);\\n                uint leftSubblock = (uint)(block >> 32);\\n\\n                // Feistel \\\"network\\\" - decoding, the order of rounds and operations on the blocks is reverted\\n                uint roundKey;\\n                for (int round = Rounds - 1; round >= 0; round--)\\n                {\\n                    roundKey = GetRoundKey(key, round);\\n                    temp = leftSubblock ^ BlockModification(rightSubblock, roundKey);\\n                    leftSubblock = rightSubblock;\\n                    rightSubblock = temp;\\n                }\\n\\n                // compose decoded block\\n                ulong decodedBlock = leftSubblock;\\n                decodedBlock = (decodedBlock << 32) | rightSubblock;\\n\\n                for(int i = 0; i < 8; i++)\\n                {\\n                    ulong a = (decodedBlock & 0xFF00000000000000) >> 56;\\n\\n                    // it's a trick, the code works with non zero characters, if your text has ASCII code 0x00 it will be skipped.\\n                    if (a != 0)\\n                    {\\n                        decodedTextHex.Append((char)a);\\n                    }\\n\\n                    decodedBlock = decodedBlock << 8;\\n                }\\n            }\\n\\n            return decodedTextHex.ToString();\\n        }\\n\\n        // Using the size of block = 8 bytes this function splts the text and returns set of 8 bytes (ulong) blocks\\n        // the last block is extended up to 8 bytes if the tail of the text is smaller than 8 bytes\\n        private static List<ulong> SplitTextToBlocks(string text)\\n        {\\n            List<ulong> blocksListPlain = new();\\n            byte[] textArray = Encoding.ASCII.GetBytes(text);\\n            int offset = 8;\\n            for(int i = 0; i < text.Length; i += 8)\\n            {\\n                // text not always has len%16 == 0, that's why the offset should be adjusted for the last part of the text\\n                if (i > text.Length - 8)\\n                {\\n                    offset = text.Length - i;\\n                }\\n\\n                string block = Convert.ToHexString(textArray, i, offset);\\n                blocksListPlain.Add(Convert.ToUInt64(block, 16));\\n            }\\n\\n            return blocksListPlain;\\n        }\\n\\n        // convert the encoded text to the set of ulong values (blocks for decoding)\\n        private static List<ulong> GetBlocksFromEncodedText(string text)\\n        {\\n            List<ulong> blocksListPlain = new();\\n            for(int i = 0; i < text.Length; i += 16)\\n            {\\n                ulong block = Convert.ToUInt64(text.Substring(i, 16), 16);\\n                blocksListPlain.Add(block);\\n            }\\n\\n            return blocksListPlain;\\n        }\\n\\n        // here might be any deterministic math formula\\n        private static uint BlockModification(uint block, uint key)\\n        {\\n            for (int i = 0; i < 32; i++)\\n            {\\n                // 0x55555555 for the better distribution 0 an 1 in the block\\n                block = ((block ^ 0x55555555) * block) % key;\\n                block = block ^ key;\\n            }\\n\\n            return block;\\n        }\\n\\n        // There are many ways to generate a round key, any deterministic math formula does work\\n        private static uint GetRoundKey(uint key, int round)\\n        {\\n            // \\\"round + 2\\\" - to avoid a situation when pow(key,1) ^ key  = key ^ key = 0\\n            uint a = (uint)Math.Pow((double)key, round + 2);\\n            return a ^ key;\\n        }\\n    }\\n}\\n\"",
    "hill encoder": "\"using System;\\nusing System.Linq;\\nusing Algorithms.Numeric;\\n\\nnamespace Algorithms.Encoders\\n{\\n    /// <summary>\\n    ///     Lester S. Hill's polygraphic substitution cipher,\\n    ///     without representing letters using mod26, using\\n    ///     corresponding \\\"(char)value\\\" instead.\\n    /// </summary>\\n    public class HillEncoder : IEncoder<double[,]>\\n    {\\n        private readonly GaussJordanElimination linearEquationSolver;\\n\\n        public HillEncoder() => linearEquationSolver = new GaussJordanElimination(); // TODO: add DI\\n\\n        public string Encode(string text, double[,] key)\\n        {\\n            var preparedText = FillGaps(text);\\n            var chunked = ChunkTextToArray(preparedText);\\n            var splitted = SplitToCharArray(chunked);\\n\\n            var ciphered = new double[chunked.Length][];\\n\\n            for (var i = 0; i < chunked.Length; i++)\\n            {\\n                var vector = new double[3];\\n                Array.Copy(splitted, i * 3, vector, 0, 3);\\n                var product = MatrixCipher(vector, key);\\n                ciphered[i] = product;\\n            }\\n\\n            var merged = MergeArrayList(ciphered);\\n\\n            return BuildStringFromArray(merged);\\n        }\\n\\n        public string Decode(string text, double[,] key)\\n        {\\n            var chunked = ChunkTextToArray(text);\\n            var split = SplitToCharArray(chunked);\\n\\n            var deciphered = new double[chunked.Length][];\\n\\n            for (var i = 0; i < chunked.Length; i++)\\n            {\\n                var vector = new double[3];\\n                Array.Copy(split, i * 3, vector, 0, 3);\\n                var product = MatrixDeCipher(vector, key);\\n                deciphered[i] = product;\\n            }\\n\\n            var merged = MergeArrayList(deciphered);\\n            var str = BuildStringFromArray(merged);\\n\\n            return UnFillGaps(str);\\n        }\\n\\n        /// <summary>\\n        ///     Converts elements from the array to their corresponding Unicode characters.\\n        /// </summary>\\n        /// <param name=\\\"arr\\\">array of vectors.</param>\\n        /// <returns>Message.</returns>\\n        private static string BuildStringFromArray(double[] arr) => new(arr.Select(c => (char)c).ToArray());\\n\\n        /// <summary>\\n        ///     Multiplies the key for the given scalar.\\n        /// </summary>\\n        /// <param name=\\\"vector\\\">list of splitted words as numbers.</param>\\n        /// <param name=\\\"key\\\">Cipher selected key.</param>\\n        /// <returns>Ciphered vector.</returns>\\n        private static double[] MatrixCipher(double[] vector, double[,] key)\\n        {\\n            var multiplied = new double[vector.Length];\\n\\n            for (var i = 0; i < key.GetLength(1); i++)\\n            {\\n                for (var j = 0; j < key.GetLength(0); j++)\\n                {\\n                    multiplied[i] += key[i, j] * vector[j];\\n                }\\n            }\\n\\n            return multiplied;\\n        }\\n\\n        /// <summary>\\n        ///     Given a list of vectors, returns a single array of elements.\\n        /// </summary>\\n        /// <param name=\\\"list\\\">List of ciphered arrays.</param>\\n        /// <returns>unidimensional list.</returns>\\n        private static double[] MergeArrayList(double[][] list)\\n        {\\n            var merged = new double[list.Length * 3];\\n\\n            for (var i = 0; i < list.Length; i++)\\n            {\\n                Array.Copy(list[i], 0, merged, i * 3, list[0].Length);\\n            }\\n\\n            return merged;\\n        }\\n\\n        /// <summary>\\n        ///     Splits the input text message as chunks of words.\\n        /// </summary>\\n        /// <param name=\\\"chunked\\\">chunked words list.</param>\\n        /// <returns>spliiter char array.</returns>\\n        private static char[] SplitToCharArray(string[] chunked)\\n        {\\n            var splitted = new char[chunked.Length * 3];\\n\\n            for (var i = 0; i < chunked.Length; i++)\\n            {\\n                for (var j = 0; j < 3; j++)\\n                {\\n                    splitted[i * 3 + j] = chunked[i].ToCharArray()[j];\\n                }\\n            }\\n\\n            return splitted;\\n        }\\n\\n        /// <summary>\\n        ///     Chunks the input text message.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">text message.</param>\\n        /// <returns>array of words.</returns>\\n        private static string[] ChunkTextToArray(string text)\\n        {\\n            // To split the message into chunks\\n            var div = text.Length / 3;\\n            var chunks = new string[div];\\n\\n            for (var i = 0; i < div; i++)\\n            {\\n                chunks.SetValue(text.Substring(i * 3, 3), i);\\n            }\\n\\n            return chunks;\\n        }\\n\\n        /// <summary>\\n        ///     Fills a text message with spaces at the end\\n        ///     to enable a simple split by 3-length-word.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">Text Message.</param>\\n        /// <returns>Modified text Message.</returns>\\n        private static string FillGaps(string text)\\n        {\\n            var remainder = text.Length % 3;\\n            return remainder == 0 ? text : text + new string(' ', 3 - remainder);\\n        }\\n\\n        /// <summary>\\n        ///     Removes the extra spaces included on the cipher phase.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">Text message.</param>\\n        /// <returns>Deciphered Message.</returns>\\n        private static string UnFillGaps(string text) => text.TrimEnd();\\n\\n        /// <summary>\\n        ///     Finds the inverse of the given matrix using a linear equation solver.\\n        /// </summary>\\n        /// <param name=\\\"vector\\\">Splitted words vector.</param>\\n        /// <param name=\\\"key\\\">Key used for the cipher.</param>\\n        /// <returns>TODO.</returns>\\n        private double[] MatrixDeCipher(double[] vector, double[,] key)\\n        {\\n            // To augment the original key with the given vector.\\n            var augM = new double[3, 4];\\n\\n            for (var i = 0; i < key.GetLength(0); i++)\\n            {\\n                for (var j = 0; j < key.GetLength(1); j++)\\n                {\\n                    augM[i, j] = key[i, j];\\n                }\\n            }\\n\\n            for (var k = 0; k < vector.Length; k++)\\n            {\\n                augM[k, 3] = vector[k];\\n            }\\n\\n            _ = linearEquationSolver.Solve(augM);\\n\\n            return new[] { augM[0, 3], augM[1, 3], augM[2, 3] };\\n        }\\n    }\\n}\\n\"",
    "i encoder": "\"namespace Algorithms.Encoders\\n{\\n    /// <summary>\\n    ///     Encodes and decodes text based on specified key.\\n    /// </summary>\\n    /// <typeparam name=\\\"TKey\\\">Type of the key.</typeparam>\\n    public interface IEncoder<TKey>\\n    {\\n        /// <summary>\\n        ///     Encodes text using specified key.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">Text to be encoded.</param>\\n        /// <param name=\\\"key\\\">Key that will be used to encode the text.</param>\\n        /// <returns>Encoded text.</returns>\\n        string Encode(string text, TKey key);\\n\\n        /// <summary>\\n        ///     Decodes text that was encoded using specified key.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">Text to be decoded.</param>\\n        /// <param name=\\\"key\\\">Key that was used to encode the text.</param>\\n        /// <returns>Decoded text.</returns>\\n        string Decode(string text, TKey key);\\n    }\\n}\\n\"",
    "nysiis encoder": "\"using System.Globalization;\\nusing System.Linq;\\nusing System.Text;\\n\\nnamespace Algorithms.Encoders\\n{\\n    /// <summary>\\n    ///     Class for NYSIIS encoding strings.\\n    /// </summary>\\n    public class NysiisEncoder\\n    {\\n        private static readonly char[] Vowels = { 'A', 'E', 'I', 'O', 'U' };\\n\\n        /// <summary>\\n        ///     Encodes a string using the NYSIIS Algorithm.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">The string to encode.</param>\\n        /// <returns>The NYSIIS encoded string (all uppercase).</returns>\\n        public string Encode(string text)\\n        {\\n            text = text.ToUpper(CultureInfo.CurrentCulture);\\n            text = TrimSpaces(text);\\n            text = StartReplace(text);\\n            text = EndReplace(text);\\n\\n            for (var i = 1; i < text.Length; i++)\\n            {\\n                text = ReplaceStep(text, i);\\n            }\\n\\n            text = RemoveDuplicates(text);\\n            return TrimEnd(text);\\n        }\\n\\n        private string TrimSpaces(string text) => text.Replace(\\\" \\\", string.Empty);\\n\\n        private string RemoveDuplicates(string text)\\n        {\\n            var sb = new StringBuilder();\\n            sb.Append(text[0]);\\n            foreach (var c in text)\\n            {\\n                if (sb[^1] != c)\\n                {\\n                    sb.Append(c);\\n                }\\n            }\\n\\n            return sb.ToString();\\n        }\\n\\n        private string TrimEnd(string text)\\n        {\\n            var checks = new (string from, string to)?[]\\n            {\\n                (\\\"S\\\", string.Empty),\\n                (\\\"AY\\\", \\\"Y\\\"),\\n                (\\\"A\\\", string.Empty),\\n            };\\n            var replacement = checks.FirstOrDefault(t => text.EndsWith(t!.Value.from));\\n            if (replacement is { })\\n            {\\n                var (from, to) = replacement!.Value;\\n                text = Replace(text, text.Length - from.Length, from.Length, to);\\n            }\\n\\n            return text;\\n        }\\n\\n        private string ReplaceStep(string text, int i)\\n        {\\n            (string from, string to)[] replacements =\\n            {\\n                (\\\"EV\\\", \\\"AF\\\"),\\n                (\\\"E\\\", \\\"A\\\"),\\n                (\\\"I\\\", \\\"A\\\"),\\n                (\\\"O\\\", \\\"A\\\"),\\n                (\\\"U\\\", \\\"A\\\"),\\n                (\\\"Q\\\", \\\"G\\\"),\\n                (\\\"Z\\\", \\\"S\\\"),\\n                (\\\"M\\\", \\\"N\\\"),\\n                (\\\"KN\\\", \\\"NN\\\"),\\n                (\\\"K\\\", \\\"C\\\"),\\n                (\\\"SCH\\\", \\\"SSS\\\"),\\n                (\\\"PH\\\", \\\"FF\\\"),\\n            };\\n            var replaced = TryReplace(text, i, replacements, out text);\\n            if (replaced)\\n            {\\n                return text;\\n            }\\n\\n            // H[vowel] or [vowel]H -> text[i-1]\\n            if (text[i] == 'H')\\n            {\\n                if (!Vowels.Contains(text[i - 1]))\\n                {\\n                    return ReplaceWithPrevious();\\n                }\\n\\n                if (i < text.Length - 1 && !Vowels.Contains(text[i + 1]))\\n                {\\n                    return ReplaceWithPrevious();\\n                }\\n            }\\n\\n            // [vowel]W -> [vowel]\\n            if (text[i] == 'W' && Vowels.Contains(text[i - 1]))\\n            {\\n                return ReplaceWithPrevious();\\n            }\\n\\n            return text;\\n\\n            string ReplaceWithPrevious() => Replace(text, i, 1, text[i - 1].ToString());\\n        }\\n\\n        private bool TryReplace(string text, int index, (string, string)[] opts, out string result)\\n        {\\n            for (var i = 0; i < opts.Length; i++)\\n            {\\n                var check = opts[i].Item1;\\n                var repl = opts[i].Item2;\\n                if (text.Length >= index + check.Length && text.Substring(index, check.Length) == check)\\n                {\\n                    result = Replace(text, index, check.Length, repl);\\n                    return true;\\n                }\\n            }\\n\\n            result = text;\\n            return false;\\n        }\\n\\n        private string StartReplace(string start)\\n        {\\n            var checks = new (string from, string to)?[]\\n            {\\n                (\\\"MAC\\\", \\\"MCC\\\"),\\n                (\\\"KN\\\", \\\"NN\\\"),\\n                (\\\"K\\\", \\\"C\\\"),\\n                (\\\"PH\\\", \\\"FF\\\"),\\n                (\\\"PF\\\", \\\"FF\\\"),\\n                (\\\"SCH\\\", \\\"SSS\\\"),\\n            };\\n            var replacement = checks.FirstOrDefault(t => start.StartsWith(t!.Value.from));\\n            if (replacement is { })\\n            {\\n                var (from, to) = replacement!.Value;\\n                start = Replace(start, 0, from.Length, to);\\n            }\\n\\n            return start;\\n        }\\n\\n        private string EndReplace(string end)\\n        {\\n            var checks = new (string from, string to)?[]\\n            {\\n                (\\\"EE\\\", \\\"Y\\\"),\\n                (\\\"IE\\\", \\\"Y\\\"),\\n                (\\\"DT\\\", \\\"D\\\"),\\n                (\\\"RT\\\", \\\"D\\\"),\\n                (\\\"NT\\\", \\\"D\\\"),\\n                (\\\"ND\\\", \\\"D\\\"),\\n            };\\n            var replacement = checks.FirstOrDefault(t => end.EndsWith(t!.Value.from));\\n            if (replacement is { })\\n            {\\n                var (from, to) = replacement!.Value;\\n                end = Replace(end, end.Length - from.Length, from.Length, to);\\n            }\\n\\n            return end;\\n        }\\n\\n        private string Replace(string text, int index, int length, string substitute) =>\\n            text[..index] + substitute + text[(index + length) ..];\\n    }\\n}\\n\"",
    "soundex encoder": "\"using System.Collections.Generic;\\nusing System.Linq;\\n\\nnamespace Algorithms.Encoders\\n{\\n    /// <summary>\\n    ///     Class for Soundex encoding strings.\\n    /// </summary>\\n    public class SoundexEncoder\\n    {\\n        /// <summary>\\n        ///     Encodes a string using the Soundex Algorithm.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">The string to encode.</param>\\n        /// <returns>The Soundex encoded string (one uppercase character and three digits).</returns>\\n        public string Encode(string text)\\n        {\\n            text = text.ToLowerInvariant();\\n            var chars = OmitHAndW(text);\\n            IEnumerable<int> numbers = ProduceNumberCoding(chars);\\n            numbers = CollapseDoubles(numbers);\\n            numbers = OmitVowels(numbers);\\n            numbers = CollapseLeadingDigit(numbers, text[0]);\\n            numbers = numbers.Take(3);\\n            numbers = PadTo3Numbers(numbers);\\n            var final = numbers.ToArray();\\n            return $\\\"{text.ToUpperInvariant()[0]}{final[0]}{final[1]}{final[2]}\\\";\\n        }\\n\\n        private IEnumerable<int> CollapseLeadingDigit(IEnumerable<int> numbers, char c)\\n        {\\n            using var enumerator = numbers.GetEnumerator();\\n            enumerator.MoveNext();\\n            if (enumerator.Current == MapToNumber(c))\\n            {\\n                enumerator.MoveNext();\\n            }\\n\\n            do\\n            {\\n                yield return enumerator.Current;\\n            }\\n            while (enumerator.MoveNext());\\n        }\\n\\n        private IEnumerable<int> PadTo3Numbers(IEnumerable<int> numbers)\\n        {\\n            using var enumerator = numbers.GetEnumerator();\\n            for (var i = 0; i < 3; i++)\\n            {\\n                yield return enumerator.MoveNext()\\n                    ? enumerator.Current\\n                    : 0;\\n            }\\n        }\\n\\n        private IEnumerable<int> OmitVowels(IEnumerable<int> numbers) => numbers.Where(i => i != 0);\\n\\n        private IEnumerable<char> OmitHAndW(string text) => text.Where(c => c != 'h' && c != 'w');\\n\\n        private IEnumerable<int> CollapseDoubles(IEnumerable<int> numbers)\\n        {\\n            var previous = int.MinValue;\\n            foreach (var i in numbers)\\n            {\\n                if (previous != i)\\n                {\\n                    yield return i;\\n                    previous = i;\\n                }\\n            }\\n        }\\n\\n        private IEnumerable<int> ProduceNumberCoding(IEnumerable<char> text) => text.Select(MapToNumber);\\n\\n        private int MapToNumber(char ch)\\n        {\\n            var mapping = new Dictionary<char, int>\\n            {\\n                ['a'] = 0,\\n                ['e'] = 0,\\n                ['i'] = 0,\\n                ['o'] = 0,\\n                ['u'] = 0,\\n                ['y'] = 0,\\n                ['h'] = 8,\\n                ['w'] = 8,\\n                ['b'] = 1,\\n                ['f'] = 1,\\n                ['p'] = 1,\\n                ['v'] = 1,\\n                ['c'] = 2,\\n                ['g'] = 2,\\n                ['j'] = 2,\\n                ['k'] = 2,\\n                ['q'] = 2,\\n                ['s'] = 2,\\n                ['x'] = 2,\\n                ['z'] = 2,\\n                ['d'] = 3,\\n                ['t'] = 3,\\n                ['l'] = 4,\\n                ['m'] = 5,\\n                ['n'] = 5,\\n                ['r'] = 6,\\n            };\\n\\n            return mapping[ch];\\n        }\\n    }\\n}\\n\"",
    "vigenere encoder": "\"using System;\\nusing System.Text;\\n\\nnamespace Algorithms.Encoders\\n{\\n    /// <summary>\\n    ///     Encodes using vigenere cypher.\\n    /// </summary>\\n    public class VigenereEncoder : IEncoder<string>\\n    {\\n        private readonly CaesarEncoder caesarEncoder = new();\\n\\n        /// <summary>\\n        ///     Encodes text using specified key,\\n        ///     time complexity: O(n),\\n        ///     space complexity: O(n),\\n        ///     where n - text length.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">Text to be encoded.</param>\\n        /// <param name=\\\"key\\\">Key that will be used to encode the text.</param>\\n        /// <returns>Encoded text.</returns>\\n        public string Encode(string text, string key) => Cipher(text, key, caesarEncoder.Encode);\\n\\n        /// <summary>\\n        ///     Decodes text that was encoded using specified key,\\n        ///     time complexity: O(n),\\n        ///     space complexity: O(n),\\n        ///     where n - text length.\\n        /// </summary>\\n        /// <param name=\\\"text\\\">Text to be decoded.</param>\\n        /// <param name=\\\"key\\\">Key that was used to encode the text.</param>\\n        /// <returns>Decoded text.</returns>\\n        public string Decode(string text, string key) => Cipher(text, key, caesarEncoder.Decode);\\n\\n        private string Cipher(string text, string key, Func<string, int, string> symbolCipher)\\n        {\\n            key = AppendKey(key, text.Length);\\n            var encodedTextBuilder = new StringBuilder(text.Length);\\n            for (var i = 0; i < text.Length; i++)\\n            {\\n                if (!char.IsLetter(text[i]))\\n                {\\n                    _ = encodedTextBuilder.Append(text[i]);\\n                    continue;\\n                }\\n\\n                var letterZ = char.IsUpper(key[i]) ? 'Z' : 'z';\\n                var encodedSymbol = symbolCipher(text[i].ToString(), letterZ - key[i]);\\n                _ = encodedTextBuilder.Append(encodedSymbol);\\n            }\\n\\n            return encodedTextBuilder.ToString();\\n        }\\n\\n        private string AppendKey(string key, int length)\\n        {\\n            if (string.IsNullOrEmpty(key))\\n            {\\n                throw new ArgumentOutOfRangeException($\\\"{nameof(key)} must be non-empty string\\\");\\n            }\\n\\n            var keyBuilder = new StringBuilder(key, length);\\n            while (keyBuilder.Length < length)\\n            {\\n                _ = keyBuilder.Append(key);\\n            }\\n\\n            return keyBuilder.ToString();\\n        }\\n    }\\n}\\n\"",
    "breadth first search": "\"using System;\\nusing System.Collections.Generic;\\nusing DataStructures.Graph;\\n\\nnamespace Algorithms.Graph\\n{\\n    /// <summary>\\n    /// Breadth First Search - algorithm for traversing graph.\\n    /// Algorithm starts from root node that is selected by the user.\\n    /// Algorithm explores all nodes at the present depth.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Vertex data type.</typeparam>\\n    public class BreadthFirstSearch<T> : IGraphSearch<T> where T : IComparable<T>\\n    {\\n        /// <summary>\\n        /// Traverses graph from start vertex.\\n        /// </summary>\\n        /// <param name=\\\"graph\\\">Graph instance.</param>\\n        /// <param name=\\\"startVertex\\\">Vertex that search starts from.</param>\\n        /// <param name=\\\"action\\\">Action that needs to be executed on each graph vertex.</param>\\n        public void VisitAll(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action = default)\\n        {\\n            Bfs(graph, startVertex, action, new HashSet<Vertex<T>>());\\n        }\\n\\n        /// <summary>\\n        /// Traverses graph from start vertex.\\n        /// </summary>\\n        /// <param name=\\\"graph\\\">Graph instance.</param>\\n        /// <param name=\\\"startVertex\\\">Vertex that search starts from.</param>\\n        /// <param name=\\\"action\\\">Action that needs to be executed on each graph vertex.</param>\\n        /// <param name=\\\"visited\\\">Hash set with visited vertices.</param>\\n        private void Bfs(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action, HashSet<Vertex<T>> visited)\\n        {\\n            var queue = new Queue<Vertex<T>>();\\n\\n            queue.Enqueue(startVertex);\\n\\n            while (queue.Count > 0)\\n            {\\n                var currentVertex = queue.Dequeue();\\n\\n                if (currentVertex == null || visited.Contains(currentVertex))\\n                {\\n                    continue;\\n                }\\n\\n                foreach (var vertex in graph.GetNeighbors(currentVertex))\\n                {\\n                    queue.Enqueue(vertex!);\\n                }\\n\\n                action?.Invoke(currentVertex);\\n\\n                visited.Add(currentVertex);\\n            }\\n        }\\n    }\\n}\\n\"",
    "depth first search": "\"using System;\\nusing System.Collections.Generic;\\nusing DataStructures.Graph;\\n\\nnamespace Algorithms.Graph\\n{\\n    /// <summary>\\n    /// Depth First Search - algorithm for traversing graph.\\n    /// Algorithm starts from root node that is selected by the user.\\n    /// Algorithm explores as far as possible along each branch before backtracking.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Vertex data type.</typeparam>\\n    public class DepthFirstSearch<T> : IGraphSearch<T> where T : IComparable<T>\\n    {\\n        /// <summary>\\n        /// Traverses graph from start vertex.\\n        /// </summary>\\n        /// <param name=\\\"graph\\\">Graph instance.</param>\\n        /// <param name=\\\"startVertex\\\">Vertex that search starts from.</param>\\n        /// <param name=\\\"action\\\">Action that needs to be executed on each graph vertex.</param>\\n        public void VisitAll(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action = default)\\n        {\\n            Dfs(graph, startVertex, action, new HashSet<Vertex<T>>());\\n        }\\n\\n        /// <summary>\\n        /// Traverses graph from start vertex.\\n        /// </summary>\\n        /// <param name=\\\"graph\\\">Graph instance.</param>\\n        /// <param name=\\\"startVertex\\\">Vertex that search starts from.</param>\\n        /// <param name=\\\"action\\\">Action that needs to be executed on each graph vertex.</param>\\n        /// <param name=\\\"visited\\\">Hash set with visited vertices.</param>\\n        private void Dfs(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action, HashSet<Vertex<T>> visited)\\n        {\\n            action?.Invoke(startVertex);\\n\\n            visited.Add(startVertex);\\n\\n            foreach (var vertex in graph.GetNeighbors(startVertex))\\n            {\\n                if (vertex == null || visited.Contains(vertex))\\n                {\\n                    continue;\\n                }\\n\\n                Dfs(graph, vertex!, action, visited);\\n            }\\n        }\\n    }\\n}\\n\"",
    "floyd warshall": "\"using System;\\nusing DataStructures.Graph;\\n\\nnamespace Algorithms.Graph\\n{\\n    /// <summary>\\n    /// Floyd Warshall algorithm on directed weighted graph.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">generic type of data in graph.</typeparam>\\n    public class FloydWarshall<T>\\n    {\\n        /// <summary>\\n        /// runs the algorithm.\\n        /// </summary>\\n        /// <param name=\\\"graph\\\">graph upon which to run.</param>\\n        /// <returns>\\n        /// a 2D array of shortest paths between any two vertices.\\n        /// where there is no path between two vertices - double.PositiveInfinity is placed.\\n        /// </returns>\\n        public double[,] Run(DirectedWeightedGraph<T> graph)\\n        {\\n            var distances = SetupDistances(graph);\\n            var vertexCount = distances.GetLength(0);\\n            for (var k = 0; k < vertexCount; k++)\\n            {\\n                for (var i = 0; i < vertexCount; i++)\\n                {\\n                    for (var j = 0; j < vertexCount; j++)\\n                    {\\n                        distances[i, j] = distances[i, j] > distances[i, k] + distances[k, j]\\n                        ? distances[i, k] + distances[k, j]\\n                        : distances[i, j];\\n                    }\\n                }\\n            }\\n\\n            return distances;\\n        }\\n\\n        /// <summary>\\n        /// setup adjacency matrix for use by main algorithm run.\\n        /// </summary>\\n        /// <param name=\\\"graph\\\">graph to dissect adjacency matrix from.</param>\\n        /// <returns>the adjacency matrix in the format mentioned in Run.</returns>\\n        private double[,] SetupDistances(DirectedWeightedGraph<T> graph)\\n        {\\n            var distances = new double[graph.Count, graph.Count];\\n            for (int i = 0; i < distances.GetLength(0); i++)\\n            {\\n                for (var j = 0; j < distances.GetLength(0); j++)\\n                {\\n                    var dist = graph.AdjacentDistance(graph.Vertices[i] !, graph.Vertices[j] !);\\n                    distances[i, j] = dist != 0 ? dist : double.PositiveInfinity;\\n                }\\n            }\\n\\n            for (var i = 0; i < distances.GetLength(0); i++)\\n            {\\n                distances[i, i] = 0;\\n            }\\n\\n            return distances;\\n        }\\n    }\\n}\\n\"",
    "i graph search": "\"using System;\\nusing DataStructures.Graph;\\n\\nnamespace Algorithms.Graph\\n{\\n    public interface IGraphSearch<T>\\n    {\\n        /// <summary>\\n        /// Traverses graph from start vertex.\\n        /// </summary>\\n        /// <param name=\\\"graph\\\">Graph instance.</param>\\n        /// <param name=\\\"startVertex\\\">Vertex that search starts from.</param>\\n        /// <param name=\\\"action\\\">Action that needs to be executed on each graph vertex.</param>\\n        void VisitAll(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action = null);\\n    }\\n}\\n\"",
    "branch and bound knapsack solver": "\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\nnamespace Algorithms.Knapsack\\n{\\n    /// <summary>\\n    ///     Branch and bound Knapsack solver.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Type of items in knapsack.</typeparam>\\n    public class BranchAndBoundKnapsackSolver<T>\\n    {\\n        /// <summary>\\n        ///     Returns the knapsack containing the items that maximize value while not exceeding weight capacity.\\n        ///     Construct a tree structure with total number of items + 1 levels, each node have two child nodes,\\n        ///     starting with a dummy item root, each following levels are associated with 1 items, construct the\\n        ///     tree in breadth first order to identify the optimal item set.\\n        /// </summary>\\n        /// <param name=\\\"items\\\">All items to choose from.</param>\\n        /// <param name=\\\"capacity\\\">The maximum weight capacity of the knapsack to be filled.</param>\\n        /// <param name=\\\"weightSelector\\\">\\n        ///     A function that returns the value of the specified item\\n        ///     from the <paramref name=\\\"items\\\">items</paramref> list.\\n        /// </param>\\n        /// <param name=\\\"valueSelector\\\">\\n        ///     A function that returns the weight of the specified item\\n        ///     from the <paramref name=\\\"items\\\">items</paramref> list.\\n        /// </param>\\n        /// <returns>\\n        ///     The array of items that provides the maximum value of the\\n        ///     knapsack without exceeding the specified weight <paramref name=\\\"capacity\\\">capacity</paramref>.\\n        /// </returns>\\n        public T[] Solve(T[] items, int capacity, Func<T, int> weightSelector, Func<T, double> valueSelector)\\n        {\\n            // This is required for greedy approach in upper bound calculation to work.\\n            items = items.OrderBy(i => valueSelector(i) / weightSelector(i)).ToArray();\\n\\n            // nodesQueue --> used to construct tree in breadth first order\\n            Queue<BranchAndBoundNode> nodesQueue = new();\\n\\n            // maxCumulativeValue --> maximum value while not exceeding weight capacity.\\n            var maxCumulativeValue = 0.0;\\n\\n            // starting node, associated with a temporary created dummy item\\n            BranchAndBoundNode root = new(level: -1, taken: false);\\n\\n            // lastNodeOfOptimalPat --> last item in the optimal item sets identified by this algorithm\\n            BranchAndBoundNode lastNodeOfOptimalPath = root;\\n\\n            nodesQueue.Enqueue(root);\\n\\n            while (nodesQueue.Count != 0)\\n            {\\n                // parent --> parent node which represents the previous item, may or may not be taken into the knapsack\\n                BranchAndBoundNode parent = nodesQueue.Dequeue();\\n\\n                // IF it is the last level, branching cannot be performed\\n                if (parent.Level == items.Length - 1)\\n                {\\n                    continue;\\n                }\\n\\n                // create a child node where the associated item is taken into the knapsack\\n                var left = new BranchAndBoundNode(parent.Level + 1, true, parent);\\n\\n                // create a child node where the associated item is not taken into the knapsack\\n                var right = new BranchAndBoundNode(parent.Level + 1, false, parent);\\n\\n                // Since the associated item on current level is taken for the first node,\\n                // set the cumulative weight of first node to cumulative weight of parent node + weight of the associated item,\\n                // set the cumulative value of first node to cumulative value of parent node + value of current level's item.\\n                left.CumulativeWeight = parent.CumulativeWeight + weightSelector(items[left.Level]);\\n                left.CumulativeValue = parent.CumulativeValue + valueSelector(items[left.Level]);\\n                right.CumulativeWeight = parent.CumulativeWeight;\\n                right.CumulativeValue = parent.CumulativeValue;\\n\\n                // IF cumulative weight is smaller than the weight capacity of the knapsack AND\\n                // current cumulative value is larger then the current maxCumulativeValue, update the maxCumulativeValue\\n                if (left.CumulativeWeight <= capacity && left.CumulativeValue > maxCumulativeValue)\\n                {\\n                    maxCumulativeValue = left.CumulativeValue;\\n                    lastNodeOfOptimalPath = left;\\n                }\\n\\n                left.UpperBound = ComputeUpperBound(left, items, capacity, weightSelector, valueSelector);\\n                right.UpperBound = ComputeUpperBound(right, items, capacity, weightSelector, valueSelector);\\n\\n                // IF upperBound of this node is larger than maxCumulativeValue,\\n                // the current path is still possible to reach or surpass the maximum value,\\n                // add current node to nodesQueue so that nodes below it can be further explored\\n                if (left.UpperBound > maxCumulativeValue && left.CumulativeWeight < capacity)\\n                {\\n                    nodesQueue.Enqueue(left);\\n                }\\n\\n                // Cumulative weight is the same as for parent node and < capacity\\n                if (right.UpperBound > maxCumulativeValue)\\n                {\\n                    nodesQueue.Enqueue(right);\\n                }\\n            }\\n\\n            return GetItemsFromPath(items, lastNodeOfOptimalPath);\\n        }\\n\\n        // determine items taken based on the path\\n        private static T[] GetItemsFromPath(T[] items, BranchAndBoundNode lastNodeOfPath)\\n        {\\n            List<T> takenItems = new();\\n\\n            // only bogus initial node has no parent\\n            for (var current = lastNodeOfPath; current.Parent is not null; current = current.Parent)\\n            {\\n                if(current.IsTaken)\\n                {\\n                    takenItems.Add(items[current.Level]);\\n                }\\n            }\\n\\n            return takenItems.ToArray();\\n        }\\n\\n        /// <summary>\\n        ///     Returns the upper bound value of a given node.\\n        /// </summary>\\n        /// <param name=\\\"aNode\\\">The given node.</param>\\n        /// <param name=\\\"items\\\">All items to choose from.</param>\\n        /// <param name=\\\"capacity\\\">The maximum weight capacity of the knapsack to be filled.</param>\\n        /// <param name=\\\"weightSelector\\\">\\n        ///     A function that returns the value of the specified item\\n        ///     from the <paramref name=\\\"items\\\">items</paramref> list.\\n        /// </param>\\n        /// <param name=\\\"valueSelector\\\">\\n        ///     A function that returns the weight of the specified item\\n        ///     from the <paramref name=\\\"items\\\">items</paramref> list.\\n        /// </param>\\n        /// <returns>\\n        ///     upper bound value of the given <paramref name=\\\"aNode\\\">node</paramref>.\\n        /// </returns>\\n        private static double ComputeUpperBound(BranchAndBoundNode aNode, T[] items, int capacity, Func<T, int> weightSelector, Func<T, double> valueSelector)\\n        {\\n            var upperBound = aNode.CumulativeValue;\\n            var availableWeight = capacity - aNode.CumulativeWeight;\\n            var nextLevel = aNode.Level + 1;\\n\\n            while (availableWeight > 0 && nextLevel < items.Length)\\n            {\\n                if (weightSelector(items[nextLevel]) <= availableWeight)\\n                {\\n                    upperBound += valueSelector(items[nextLevel]);\\n                    availableWeight -= weightSelector(items[nextLevel]);\\n                }\\n                else\\n                {\\n                    upperBound += valueSelector(items[nextLevel]) / weightSelector(items[nextLevel]) * availableWeight;\\n                    availableWeight = 0;\\n                }\\n\\n                nextLevel++;\\n            }\\n\\n            return upperBound;\\n        }\\n    }\\n}\\n\"",
    "branch and bound node": "\"namespace Algorithms.Knapsack\\n{\\n    public class BranchAndBoundNode\\n    {\\n        // isTaken --> true = the item where index = level is taken, vice versa\\n        public bool IsTaken { get; }\\n\\n        // cumulativeWeight --> um of weight of item associated in each nodes starting from root to this node (only item that is taken)\\n        public int CumulativeWeight { get; set; }\\n\\n        // cumulativeValue --> sum of value of item associated in each nodes starting from root to this node (only item that is taken)\\n        public double CumulativeValue { get; set; }\\n\\n        // upperBound --> largest possible value after taking/not taking the item associated to this node (fractional)\\n        public double UpperBound { get; set; }\\n\\n        // level --> level of the node in the tree structure\\n        public int Level { get; }\\n\\n        // parent node\\n        public BranchAndBoundNode? Parent { get; }\\n\\n        public BranchAndBoundNode(int level, bool taken, BranchAndBoundNode? parent = null)\\n        {\\n            Level = level;\\n            IsTaken = taken;\\n            Parent = parent;\\n        }\\n    }\\n}\\n\"",
    "dynamic programming knapsack solver": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace Algorithms.Knapsack\\n{\\n    /// <summary>\\n    ///     Dynamic Programming Knapsack solver.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Type of items in knapsack.</typeparam>\\n    public class DynamicProgrammingKnapsackSolver<T>\\n    {\\n        /// <summary>\\n        ///     Returns the knapsack containing the items that\\n        ///     maximize value while not exceeding weight capacity.\\n        /// </summary>\\n        /// <param name=\\\"items\\\">The list of items from which we select ones to be in the knapsack.</param>\\n        /// <param name=\\\"capacity\\\">\\n        ///     The maximum weight capacity of the knapsack\\n        ///     to be filled. Only integer values of this capacity are tried. If\\n        ///     a greater resolution is needed, multiply the\\n        ///     weights/capacity by a factor of 10.\\n        /// </param>\\n        /// <param name=\\\"weightSelector\\\">\\n        ///     A function that returns the value of the specified item\\n        ///     from the <paramref name=\\\"items\\\">items</paramref> list.\\n        /// </param>\\n        /// <param name=\\\"valueSelector\\\">\\n        ///     A function that returns the weight of the specified item\\n        ///     from the <paramref name=\\\"items\\\">items</paramref> list.\\n        /// </param>\\n        /// <returns>\\n        ///     The array of items that provides the maximum value of the\\n        ///     knapsack without exceeding the specified weight <paramref name=\\\"capacity\\\">capacity</paramref>.\\n        /// </returns>\\n        public T[] Solve(T[] items, int capacity, Func<T, int> weightSelector, Func<T, double> valueSelector)\\n        {\\n            var cache = Tabulate(items, weightSelector, valueSelector, capacity);\\n            return GetOptimalItems(items, weightSelector, cache, capacity);\\n        }\\n\\n        private static T[] GetOptimalItems(T[] items, Func<T, int> weightSelector, double[,] cache, int capacity)\\n        {\\n            var currentCapacity = capacity;\\n\\n            var result = new List<T>();\\n            for (var i = items.Length - 1; i >= 0; i--)\\n            {\\n                if (cache[i + 1, currentCapacity] > cache[i, currentCapacity])\\n                {\\n                    var item = items[i];\\n                    result.Add(item);\\n                    currentCapacity -= weightSelector(item);\\n                }\\n            }\\n\\n            result.Reverse(); // we added items back to front\\n            return result.ToArray();\\n        }\\n\\n        private static double[,] Tabulate(\\n            T[] items,\\n            Func<T, int> weightSelector,\\n            Func<T, double> valueSelector,\\n            int maxCapacity)\\n        {\\n            // Store the incremental results in a bottom up manner\\n            var n = items.Length;\\n            var results = new double[n + 1, maxCapacity + 1];\\n            for (var i = 0; i <= n; i++)\\n            {\\n                for (var w = 0; w <= maxCapacity; w++)\\n                {\\n                    if (i == 0 || w == 0)\\n                    {\\n                        // If we have no items to take, or\\n                        // if we have no capacity in our knapsack\\n                        // we cannot possibly have any value\\n                        results[i, w] = 0;\\n                    }\\n                    else if (weightSelector(items[i - 1]) <= w)\\n                    {\\n                        // Decide if it is better to take or not take this item\\n                        var iut = items[i - 1]; // iut = Item under test\\n                        var vut = valueSelector(iut); // vut = Value of item under test\\n                        var wut = weightSelector(iut); // wut = Weight of item under test\\n                        var valueIfTaken = vut + results[i - 1, w - wut];\\n                        var valueIfNotTaken = results[i - 1, w];\\n                        results[i, w] = Math.Max(valueIfTaken, valueIfNotTaken);\\n                    }\\n                    else\\n                    {\\n                        // There is not enough room to take this item\\n                        results[i, w] = results[i - 1, w];\\n                    }\\n                }\\n            }\\n\\n            return results;\\n        }\\n    }\\n}\\n\"",
    "i heuristic knapsack solver": "\"using System;\\n\\nnamespace Algorithms.Knapsack\\n{\\n    /// <summary>\\n    ///     Solves knapsack problem using some heuristics\\n    ///     Sum of values of taken items -> max\\n    ///     Sum of weights of taken items. &lt;= capacity.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Type of items in knapsack.</typeparam>\\n    public interface IHeuristicKnapsackSolver<T>\\n    {\\n        /// <summary>\\n        ///     Solves knapsack problem using some heuristics\\n        ///     Sum of values of taken items -> max\\n        ///     Sum of weights of taken items. &lt;= capacity.\\n        /// </summary>\\n        /// <param name=\\\"items\\\">All items to choose from.</param>\\n        /// <param name=\\\"capacity\\\">How much weight we can take.</param>\\n        /// <param name=\\\"weightSelector\\\">Maps item to its weight.</param>\\n        /// <param name=\\\"valueSelector\\\">Maps item to its value.</param>\\n        /// <returns>Items that were chosen.</returns>\\n        T[] Solve(T[] items, double capacity, Func<T, double> weightSelector, Func<T, double> valueSelector);\\n    }\\n}\\n\"",
    "i knapsack solver": "\"namespace Algorithms.Knapsack\\n{\\n    /// <summary>\\n    ///     Solves knapsack problem:\\n    ///     to maximize sum of values of taken items,\\n    ///     while sum of weights of taken items is less than capacity.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Type of items in knapsack.</typeparam>\\n    public interface IKnapsackSolver<T> : IHeuristicKnapsackSolver<T>\\n    {\\n    }\\n}\\n\"",
    "naive knapsack solver": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace Algorithms.Knapsack\\n{\\n    /// <summary>\\n    ///     Greedy heurictic solver.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Type of items in knapsack.</typeparam>\\n    public class NaiveKnapsackSolver<T> : IHeuristicKnapsackSolver<T>\\n    {\\n        /// <summary>\\n        ///     TODO.\\n        /// </summary>\\n        /// <param name=\\\"items\\\">TODO. 2.</param>\\n        /// <param name=\\\"capacity\\\">TODO. 3.</param>\\n        /// <param name=\\\"weightSelector\\\">TODO. 4.</param>\\n        /// <param name=\\\"valueSelector\\\">TODO. 5.</param>\\n        /// <returns>TODO. 6.</returns>\\n        public T[] Solve(T[] items, double capacity, Func<T, double> weightSelector, Func<T, double> valueSelector)\\n        {\\n            var weight = 0d;\\n            var left = new List<T>();\\n\\n            foreach (var item in items)\\n            {\\n                var weightDelta = weightSelector(item);\\n                if (weight + weightDelta <= capacity)\\n                {\\n                    weight += weightDelta;\\n                    left.Add(item);\\n                }\\n            }\\n\\n            return left.ToArray();\\n        }\\n    }\\n}\\n\"",
    "aliquot sum calculator": "\"using System;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    ///     In number theory, the aliquot sum s(n) of a positive integer n is the sum of all proper divisors\\n    ///     of n, that is, all divisors of n other than n itself. For example, the proper divisors of 15\\n    ///     (that is, the positive divisors of 15 that are not equal to 15) are 1, 3 and 5, so the aliquot\\n    ///     sum of 15 is 9 i.e. (1 + 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum.\\n    /// </summary>\\n    public static class AliquotSumCalculator\\n    {\\n        /// <summary>\\n        ///     Finds the aliquot sum of an integer number.\\n        /// </summary>\\n        /// <param name=\\\"number\\\">Positive number.</param>\\n        /// <returns>The Aliquot Sum.</returns>\\n        /// <exception cref=\\\"ArgumentException\\\">Error number is not on interval (0.0; int.MaxValue).</exception>\\n        public static int CalculateAliquotSum(int number)\\n        {\\n            if (number < 0)\\n            {\\n                throw new ArgumentException($\\\"{nameof(number)} cannot be negative\\\");\\n            }\\n\\n            var sum = 0;\\n            for (int i = 1, limit = number / 2; i <= limit; ++i)\\n            {\\n                if (number % i == 0)\\n                {\\n                    sum += i;\\n                }\\n            }\\n\\n            return sum;\\n        }\\n    }\\n}\\n\"",
    "binomial coefficient": "\"using System;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    ///     The binomial coefficients are the positive integers\\n    ///     that occur as coefficients in the binomial theorem.\\n    /// </summary>\\n    public static class BinomialCoefficient\\n    {\\n        /// <summary>\\n        ///     Calculates Binomial coefficients for given input.\\n        /// </summary>\\n        /// <param name=\\\"num\\\">First number.</param>\\n        /// <param name=\\\"k\\\">Second number.</param>\\n        /// <returns>Binimial Coefficients.</returns>\\n        public static long Calculate(int num, int k)\\n        {\\n            if (num < k || k < 0)\\n            {\\n                throw new ArgumentException(\\\"n ≥ k ≥ 0\\\");\\n            }\\n\\n            return Factorial.Calculate(num) / (Factorial.Calculate(k) * Factorial.Calculate(num - k));\\n        }\\n    }\\n}\\n\"",
    "euler method": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    ///     In mathematics and computational science, the Euler method (also called forward Euler method)\\n    ///     is a first-order numerical procedure for solving ordinary differential equations (ODEs)\\n    ///     with a given initial value (aka. Cauchy problem). It is the most basic explicit method for numerical integration\\n    ///     of ordinary differential equations. The method proceeds in a series of steps. At each step\\n    ///     the y-value is calculated by evaluating the differential equation at the previous step,\\n    ///     multiplying the result with the step-size and adding it to the last y-value:\\n    ///     y_n+1 = y_n + stepSize * f(x_n, y_n).\\n    ///     (description adapted from https://en.wikipedia.org/wiki/Euler_method )\\n    ///     (see also: https://www.geeksforgeeks.org/euler-method-solving-differential-equation/ ).\\n    /// </summary>\\n    public static class EulerMethod\\n    {\\n        /// <summary>\\n        ///     Loops through all the steps until xEnd is reached, adds a point for each step and then\\n        ///     returns all the points.\\n        /// </summary>\\n        /// <param name=\\\"xStart\\\">Initial conditions x-value.</param>\\n        /// <param name=\\\"xEnd\\\">Last x-value.</param>\\n        /// <param name=\\\"stepSize\\\">Step-size on the x-axis.</param>\\n        /// <param name=\\\"yStart\\\">Initial conditions y-value.</param>\\n        /// <param name=\\\"yDerivative\\\">The right hand side of the differential equation.</param>\\n        /// <returns>The solution of the Cauchy problem.</returns>\\n        public static List<double[]> EulerFull(\\n            double xStart,\\n            double xEnd,\\n            double stepSize,\\n            double yStart,\\n            Func<double, double, double> yDerivative)\\n        {\\n            if (xStart >= xEnd)\\n            {\\n                throw new ArgumentOutOfRangeException(\\n                    nameof(xEnd),\\n                    $\\\"{nameof(xEnd)} should be greater than {nameof(xStart)}\\\");\\n            }\\n\\n            if (stepSize <= 0)\\n            {\\n                throw new ArgumentOutOfRangeException(\\n                    nameof(stepSize),\\n                    $\\\"{nameof(stepSize)} should be greater than zero\\\");\\n            }\\n\\n            List<double[]> points = new();\\n            double[] firstPoint = { xStart, yStart };\\n            points.Add(firstPoint);\\n            var yCurrent = yStart;\\n            var xCurrent = xStart;\\n\\n            while (xCurrent < xEnd)\\n            {\\n                yCurrent = EulerStep(xCurrent, stepSize, yCurrent, yDerivative);\\n                xCurrent += stepSize;\\n                double[] point = { xCurrent, yCurrent };\\n                points.Add(point);\\n            }\\n\\n            return points;\\n        }\\n\\n        /// <summary>\\n        ///     Calculates the next y-value based on the current value of x, y and the stepSize.\\n        /// </summary>\\n        /// <param name=\\\"xCurrent\\\">Current x-value.</param>\\n        /// <param name=\\\"stepSize\\\">Step-size on the x-axis.</param>\\n        /// <param name=\\\"yCurrent\\\">Current y-value.</param>\\n        /// <param name=\\\"yDerivative\\\">The right hand side of the differential equation.</param>\\n        /// <returns>The next y-value.</returns>\\n        private static double EulerStep(\\n            double xCurrent,\\n            double stepSize,\\n            double yCurrent,\\n            Func<double, double, double> yDerivative)\\n        {\\n            var yNext = yCurrent + stepSize * yDerivative(xCurrent, yCurrent);\\n            return yNext;\\n        }\\n    }\\n}\\n\"",
    "factorial": "\"using System;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    ///     The factorial of a positive integer n, denoted by n!,\\n    ///     is the product of all positive integers less than or equal to n.\\n    /// </summary>\\n    public static class Factorial\\n    {\\n        /// <summary>\\n        ///     Calculates factorial of a number.\\n        /// </summary>\\n        /// <param name=\\\"num\\\">Input number.</param>\\n        /// <returns>Factorial of input number.</returns>\\n        public static long Calculate(int num)\\n        {\\n            if (num < 0)\\n            {\\n                throw new ArgumentException(\\\"Only for num >= 0\\\");\\n            }\\n\\n            return num == 0 ? 1 : num * Calculate(num - 1);\\n        }\\n    }\\n}\\n\"",
    "gauss jordan elimination": "\"using System;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    ///     TODO.\\n    /// </summary>\\n    public class GaussJordanElimination\\n    {\\n        private int RowCount { get; set; }\\n\\n        /// <summary>\\n        ///     Method to find a linear equation system using gaussian elimination.\\n        /// </summary>\\n        /// <param name=\\\"matrix\\\">The key matrix to solve via algorithm.</param>\\n        /// <returns>\\n        ///     whether the input matrix has a unique solution or not.\\n        ///     and solves on the given matrix.\\n        /// </returns>\\n        public bool Solve(double[,] matrix)\\n        {\\n            RowCount = matrix.GetUpperBound(0) + 1;\\n\\n            if (!CanMatrixBeUsed(matrix))\\n            {\\n                throw new ArgumentException(\\\"Please use a n*(n+1) matrix with Length > 0.\\\");\\n            }\\n\\n            var pivot = PivotMatrix(ref matrix);\\n            if (!pivot)\\n            {\\n                return false;\\n            }\\n\\n            Elimination(ref matrix);\\n\\n            return ElementaryReduction(ref matrix);\\n        }\\n\\n        /// <summary>\\n        ///     To make simple validation of the matrix to be used.\\n        /// </summary>\\n        /// <param name=\\\"matrix\\\">Multidimensional array matrix.</param>\\n        /// <returns>\\n        ///     True: if algorithm can be use for given matrix;\\n        ///     False: Otherwise.\\n        /// </returns>\\n        private bool CanMatrixBeUsed(double[,] matrix) => matrix?.Length == RowCount * (RowCount + 1) && RowCount > 1;\\n\\n        /// <summary>\\n        ///     To prepare given matrix by pivoting rows.\\n        /// </summary>\\n        /// <param name=\\\"matrix\\\">Input matrix.</param>\\n        /// <returns>Matrix.</returns>\\n        private bool PivotMatrix(ref double[,] matrix)\\n        {\\n            for (var col = 0; col + 1 < RowCount; col++)\\n            {\\n                if (matrix[col, col] == 0)\\n                {\\n                    // To find a non-zero coefficient\\n                    var rowToSwap = FindNonZeroCoefficient(ref matrix, col);\\n\\n                    if (matrix[rowToSwap, col] != 0)\\n                    {\\n                        var tmp = new double[RowCount + 1];\\n                        for (var i = 0; i < RowCount + 1; i++)\\n                        {\\n                            // To make the swap with the element above.\\n                            tmp[i] = matrix[rowToSwap, i];\\n                            matrix[rowToSwap, i] = matrix[col, i];\\n                            matrix[col, i] = tmp[i];\\n                        }\\n                    }\\n                    else\\n                    {\\n                        // To return that the matrix doesn't have a unique solution.\\n                        return false;\\n                    }\\n                }\\n            }\\n\\n            return true;\\n        }\\n\\n        private int FindNonZeroCoefficient(ref double[,] matrix, int col)\\n        {\\n            var rowToSwap = col + 1;\\n\\n            // To find a non-zero coefficient\\n            for (; rowToSwap < RowCount; rowToSwap++)\\n            {\\n                if (matrix[rowToSwap, col] != 0)\\n                {\\n                    return rowToSwap;\\n                }\\n            }\\n\\n            return col + 1;\\n        }\\n\\n        /// <summary>\\n        ///     Applies REF.\\n        /// </summary>\\n        /// <param name=\\\"matrix\\\">Input matrix.</param>\\n        private void Elimination(ref double[,] matrix)\\n        {\\n            for (var srcRow = 0; srcRow + 1 < RowCount; srcRow++)\\n            {\\n                for (var destRow = srcRow + 1; destRow < RowCount; destRow++)\\n                {\\n                    var df = matrix[srcRow, srcRow];\\n                    var sf = matrix[destRow, srcRow];\\n\\n                    for (var i = 0; i < RowCount + 1; i++)\\n                    {\\n                        matrix[destRow, i] = matrix[destRow, i] * df - matrix[srcRow, i] * sf;\\n                    }\\n                }\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     To continue reducing the matrix using RREF.\\n        /// </summary>\\n        /// <param name=\\\"matrix\\\">Input matrix.</param>\\n        /// <returns>True if it has a unique solution; false otherwise.</returns>\\n        private bool ElementaryReduction(ref double[,] matrix)\\n        {\\n            for (var row = RowCount - 1; row >= 0; row--)\\n            {\\n                var element = matrix[row, row];\\n                if (element == 0)\\n                {\\n                    return false;\\n                }\\n\\n                for (var i = 0; i < RowCount + 1; i++)\\n                {\\n                    matrix[row, i] /= element;\\n                }\\n\\n                for (var destRow = 0; destRow < row; destRow++)\\n                {\\n                    matrix[destRow, RowCount] -= matrix[destRow, row] * matrix[row, RowCount];\\n                    matrix[destRow, row] = 0;\\n                }\\n            }\\n\\n            return true;\\n        }\\n    }\\n}\\n\"",
    "keith number checker": "\"using System;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    ///  In number theory, a Keith number or repfigit number is a natural number n in a given number base b with k digits such that\\n    ///  when a sequence is created such that the first k terms are the k digits of n and each subsequent term is the sum of the\\n    ///  previous k terms, n is part of the sequence.\\n    /// </summary>\\n    public static class KeithNumberChecker\\n    {\\n        /// <summary>\\n        ///     Checks if a number is a Keith number or not.\\n        /// </summary>\\n        /// <param name=\\\"number\\\">Number to check.</param>\\n        /// <returns>True if it is a Keith number; False otherwise.</returns>\\n        public static bool IsKeithNumber(int number)\\n        {\\n            if (number < 0)\\n            {\\n                throw new ArgumentException($\\\"{nameof(number)} cannot be negative\\\");\\n            }\\n\\n            var tempNumber = number;\\n\\n            var stringNumber = number.ToString();\\n\\n            var digitsInNumber = stringNumber.Length;\\n\\n            /* storing the terms of the series */\\n            var termsArray = new int[number];\\n\\n            for (var i = digitsInNumber - 1; i >= 0; i--)\\n            {\\n                termsArray[i] = tempNumber % 10;\\n                tempNumber /= 10;\\n            }\\n\\n            var sum = 0;\\n            var k = digitsInNumber;\\n            while (sum < number)\\n            {\\n                sum = 0;\\n\\n                for (var j = 1; j <= digitsInNumber; j++)\\n                {\\n                    sum += termsArray[k - j];\\n                }\\n\\n                termsArray[k] = sum;\\n                k++;\\n            }\\n\\n            return sum == number;\\n        }\\n    }\\n}\\n\"",
    "miller rabin primality checker": "\"using System;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    /// https://en.wikipedia.org/wiki/Miller-Rabin_primality_test\\n    /// The Miller–Rabin primality test or Rabin–Miller primality test is a probabilistic primality test:\\n    /// an algorithm which determines whether a given number is likely to be prime,\\n    /// similar to the Fermat primality test and the Solovay–Strassen primality test.\\n    /// It is of historical significance in the search for a polynomial-time deterministic primality test.\\n    /// Its probabilistic variant remains widely used in practice, as one of the simplest and fastest tests known.\\n    /// </summary>\\n    public static class MillerRabinPrimalityChecker\\n    {\\n        /// <summary>\\n        ///     Run the probabilistic primality test.\\n        ///     </summary>\\n        /// <param name=\\\"n\\\">Number to check.</param>\\n        /// <param name=\\\"rounds\\\">Number of rounds, the parameter determines the accuracy of the test, recommended value is Log2(n).</param>\\n        /// <returns>True if is a highly likely prime number; False otherwise.</returns>\\n        /// <exception cref=\\\"ArgumentException\\\">Error: number should be morhe than 3.</exception>\\n        public static bool IsProbablyPrimeNumber(BigInteger n, BigInteger rounds)\\n        {\\n            if (n <= 3)\\n            {\\n                throw new ArgumentException($\\\"{nameof(n)} should be more than 3\\\");\\n            }\\n\\n            // Input #1: n > 3, an odd integer to be tested for primality\\n            // Input #2: k, the number of rounds of testing to perform, recommended k = Log2(n)\\n            // Output:   false = “composite”\\n            //           true  = “probably prime”\\n\\n            // write n as 2r·d + 1 with d odd(by factoring out powers of 2 from n − 1)\\n            BigInteger r = 0;\\n            BigInteger d = n - 1;\\n            while (d % 2 == 0)\\n            {\\n                r++;\\n                d /= 2;\\n            }\\n\\n            BigInteger x;\\n            Random rand = new();\\n\\n            // as there is no native random function for BigInteger we suppose a random int number is sufficient\\n            int nMaxValue = (n > int.MaxValue) ? int.MaxValue : (int)n;\\n            BigInteger a = rand.Next(2, nMaxValue - 2); // ; pick a random integer a in the range[2, n − 2]\\n\\n            while (rounds > 0)\\n            {\\n                rounds--;\\n                x = BigInteger.ModPow(a, d, n);\\n                if (x == 1 || x == (n - 1))\\n                {\\n                    continue;\\n                }\\n\\n                BigInteger tempr = r - 1;\\n                while (tempr > 0 && (x != n - 1))\\n                {\\n                    tempr--;\\n                    x = BigInteger.ModPow(x, 2, n);\\n                }\\n\\n                if (x == n - 1)\\n                {\\n                    continue;\\n                }\\n\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n    }\\n}\\n\"",
    "modular exponentiation": "\"using System;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    ///     Modular exponentiation is a type of exponentiation performed over a modulus\\n    ///     Modular exponentiation c is: c = b^e mod m where b is base, e is exponent, m is modulus\\n    ///     (Wiki: https://en.wikipedia.org/wiki/Modular_exponentiation).\\n    /// </summary>\\n    public class ModularExponentiation\\n    {\\n        /// <summary>\\n        ///     Performs Modular Exponentiation on b, e, m.\\n        /// </summary>\\n        /// <param name=\\\"b\\\">Base.</param>\\n        /// <param name=\\\"e\\\">Exponent.</param>\\n        /// <param name=\\\"m\\\">Modulus.</param>\\n        /// <returns>Modular Exponential.</returns>\\n        public int ModularPow(int b, int e, int m)\\n        {\\n            // initialize result in variable res\\n            int res = 1;\\n            if (m == 1)\\n            {\\n                // 1 divides every number\\n                return 0;\\n            }\\n\\n            if (m <= 0)\\n            {\\n                // exponential not defined in this case\\n                throw new ArgumentException(string.Format(\\\"{0} is not a positive integer\\\", m));\\n            }\\n\\n            for (int i = 0; i < e; i++)\\n            {\\n                res = (res * b) % m;\\n            }\\n\\n            return res;\\n        }\\n    }\\n}\\n\"",
    "narcissistic number checker": "\"using System;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    ///     A Narcissistic number is equal to the sum of the cubes of its digits. For example, 370 is a\\n    ///     Narcissistic number because 3*3*3 + 7*7*7 + 0*0*0 = 370.\\n    /// </summary>\\n    public static class NarcissisticNumberChecker\\n    {\\n        /// <summary>\\n        ///     Checks if a number is a Narcissistic number or not.\\n        /// </summary>\\n        /// <param name=\\\"number\\\">Number to check.</param>\\n        /// <returns>True if is a Narcissistic number; False otherwise.</returns>\\n        public static bool IsNarcissistic(int number)\\n        {\\n            var sum = 0;\\n            var temp = number;\\n            var numberOfDigits = 0;\\n            while (temp != 0)\\n            {\\n                numberOfDigits++;\\n                temp /= 10;\\n            }\\n\\n            temp = number;\\n            while (number > 0)\\n            {\\n                var remainder = number % 10;\\n                var power = (int)Math.Pow(remainder, numberOfDigits);\\n\\n                sum += power;\\n                number /= 10;\\n            }\\n\\n            return sum == temp;\\n        }\\n    }\\n}\\n\"",
    "perfect number checker": "\"using System;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    ///     In number theory, a perfect number is a positive integer that is equal to the sum of its positive\\n    ///     divisors, excluding the number itself.For instance, 6 has divisors 1, 2 and 3 (excluding\\n    ///     itself), and 1 + 2 + 3 = 6, so 6 is a perfect number.\\n    /// </summary>\\n    public static class PerfectNumberChecker\\n    {\\n        /// <summary>\\n        ///     Checks if a number is a perfect number or not.\\n        /// </summary>\\n        /// <param name=\\\"number\\\">Number to check.</param>\\n        /// <returns>True if is a perfect number; False otherwise.</returns>\\n        /// <exception cref=\\\"ArgumentException\\\">Error number is not on interval (0.0; int.MaxValue).</exception>\\n        public static bool IsPerfectNumber(int number)\\n        {\\n            if (number < 0)\\n            {\\n                throw new ArgumentException($\\\"{nameof(number)} cannot be negative\\\");\\n            }\\n\\n            var sum = 0; /* sum of its positive divisors */\\n            for (var i = 1; i < number; ++i)\\n            {\\n                if (number % i == 0)\\n                {\\n                    sum += i;\\n                }\\n            }\\n\\n            return sum == number;\\n        }\\n    }\\n}\\n\"",
    "perfect square checker": "\"using System;\\n\\nnamespace Algorithms.Numeric\\n{\\n    /// <summary>\\n    ///     A perfect square is an element of algebraic structure that is equal to the square of another element.\\n    /// </summary>\\n    public static class PerfectSquareChecker\\n    {\\n        /// <summary>\\n        ///     Checks if a number is a perfect square or not.\\n        /// </summary>\\n        /// <param name=\\\"number\\\">Number too check.</param>\\n        /// <returns>True if is a perfect square; False otherwise.</returns>\\n        public static bool IsPerfectSquare(int number)\\n        {\\n            if (number < 0)\\n            {\\n                return false;\\n            }\\n\\n            var sqrt = (int)Math.Sqrt(number);\\n            return sqrt * sqrt == number;\\n        }\\n    }\\n}\\n\"",
    "fermat prime checker": "\"using System;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Other\\n{\\n    /// <summary>\\n    ///     Fermat's prime tester https://en.wikipedia.org/wiki/Fermat_primality_test.\\n    /// </summary>\\n    public static class FermatPrimeChecker\\n    {\\n        /// <summary>\\n        ///     Checks if input number is a probable prime.\\n        /// </summary>\\n        /// <param name=\\\"numberToTest\\\">Input number.</param>\\n        /// <param name=\\\"timesToCheck\\\">Number of times to check.</param>\\n        /// <returns>True if is a prime; False otherwise.</returns>\\n        public static bool IsPrime(int numberToTest, int timesToCheck)\\n        {\\n            // You have to use BigInteger for two reasons:\\n            //   1. The pow operation between two int numbers usually overflows an int\\n            //   2. The pow and modular operation is very optimized\\n            var numberToTestBigInteger = new BigInteger(numberToTest);\\n            var exponentBigInteger = new BigInteger(numberToTest - 1);\\n\\n            // Create a random number generator using the current time as seed\\n            var r = new Random(default(DateTime).Millisecond);\\n\\n            var iterator = 1;\\n            var prime = true;\\n\\n            while (iterator < timesToCheck && prime)\\n            {\\n                var randomNumber = r.Next(1, numberToTest);\\n                var randomNumberBigInteger = new BigInteger(randomNumber);\\n                if (BigInteger.ModPow(randomNumberBigInteger, exponentBigInteger, numberToTestBigInteger) != 1)\\n                {\\n                    prime = false;\\n                }\\n\\n                iterator++;\\n            }\\n\\n            return prime;\\n        }\\n    }\\n}\\n\"",
    "flood fill": "\"using System;\\nusing System.Collections.Generic;\\nusing System.Drawing;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Other\\n{\\n    /// <summary>\\n    /// Flood fill, also called seed fill, is an algorithm that determines and\\n    /// alters the area connected to a given node in a multi-dimensional array with\\n    /// some matching attribute. It is used in the \\\"bucket\\\" fill tool of paint\\n    /// programs to fill connected, similarly-colored areas with a different color.\\n    /// (description adapted from https://en.wikipedia.org/wiki/Flood_fill)\\n    /// (see also: https://www.techiedelight.com/flood-fill-algorithm/).\\n    /// </summary>\\n    public static class FloodFill\\n    {\\n        private static readonly List<(int xOffset, int yOffset)> Neighbors = new() { (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) };\\n\\n        /// <summary>\\n        /// Implements the flood fill algorithm through a breadth-first approach using a queue.\\n        /// </summary>\\n        /// <param name=\\\"bitmap\\\">The bitmap to which the algorithm is applied.</param>\\n        /// <param name=\\\"location\\\">The start location on the bitmap.</param>\\n        /// <param name=\\\"targetColor\\\">The old color to be replaced.</param>\\n        /// <param name=\\\"replacementColor\\\">The new color to replace the old one.</param>\\n        public static void BreadthFirstSearch(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor)\\n        {\\n            if (location.x < 0 || location.x >= bitmap.Width || location.y < 0 || location.y >= bitmap.Height)\\n            {\\n                throw new ArgumentOutOfRangeException(nameof(location), $\\\"{nameof(location)} should point to a pixel within the bitmap\\\");\\n            }\\n\\n            var queue = new List<(int x, int y)>();\\n            queue.Add(location);\\n\\n            while (queue.Count > 0)\\n            {\\n                BreadthFirstFill(bitmap, location, targetColor, replacementColor, queue);\\n            }\\n        }\\n\\n        /// <summary>\\n        /// Implements the flood fill algorithm through a depth-first approach through recursion.\\n        /// </summary>\\n        /// <param name=\\\"bitmap\\\">The bitmap to which the algorithm is applied.</param>\\n        /// <param name=\\\"location\\\">The start location on the bitmap.</param>\\n        /// <param name=\\\"targetColor\\\">The old color to be replaced.</param>\\n        /// <param name=\\\"replacementColor\\\">The new color to replace the old one.</param>\\n        public static void DepthFirstSearch(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor)\\n        {\\n            if (location.x < 0 || location.x >= bitmap.Width || location.y < 0 || location.y >= bitmap.Height)\\n            {\\n                throw new ArgumentOutOfRangeException(nameof(location), $\\\"{nameof(location)} should point to a pixel within the bitmap\\\");\\n            }\\n\\n            DepthFirstFill(bitmap, location, targetColor, replacementColor);\\n        }\\n\\n        private static void BreadthFirstFill(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor, List<(int x, int y)> queue)\\n        {\\n            (int x, int y) currentLocation = queue[0];\\n            queue.RemoveAt(0);\\n\\n            if (bitmap.GetPixel(currentLocation.x, currentLocation.y) == targetColor)\\n            {\\n                bitmap.SetPixel(currentLocation.x, currentLocation.y, replacementColor);\\n\\n                for (int i = 0; i < Neighbors.Count; i++)\\n                {\\n                    int x = currentLocation.x + Neighbors[i].xOffset;\\n                    int y = currentLocation.y + Neighbors[i].yOffset;\\n                    if (x >= 0 && x < bitmap.Width && y >= 0 && y < bitmap.Height)\\n                    {\\n                        queue.Add((x, y));\\n                    }\\n                }\\n            }\\n        }\\n\\n        private static void DepthFirstFill(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor)\\n        {\\n            if (bitmap.GetPixel(location.x, location.y) == targetColor)\\n            {\\n                bitmap.SetPixel(location.x, location.y, replacementColor);\\n\\n                for (int i = 0; i < Neighbors.Count; i++)\\n                {\\n                    int x = location.x + Neighbors[i].xOffset;\\n                    int y = location.y + Neighbors[i].yOffset;\\n                    if (x >= 0 && x < bitmap.Width && y >= 0 && y < bitmap.Height)\\n                    {\\n                        DepthFirstFill(bitmap, (x, y), targetColor, replacementColor);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "geo location": "\"using System;\\n\\nnamespace Algorithms.Other\\n{\\n    public static class GeoLocation\\n    {\\n        private const double EarthRadiusKm = 6371.01d;\\n\\n        /// <summary>\\n        ///     Calculates spherical distance between 2 points given their latitude, longitude coordinates.\\n        ///     https://www.movable-type.co.uk/scripts/latlong.html.\\n        /// </summary>\\n        /// <param name=\\\"lat1\\\">Latitude of point A.</param>\\n        /// <param name=\\\"lng1\\\">Longitude of point A.</param>\\n        /// <param name=\\\"lat2\\\">Latitude of point B.</param>\\n        /// <param name=\\\"lng2\\\">Longitude of point B.</param>\\n        /// <returns>Spherical distance between A and B.</returns>\\n        public static double CalculateDistanceFromLatLng(double lat1, double lng1, double lat2, double lng2)\\n        {\\n            var pi180 = Math.PI / 180d;\\n            var lat1Radian = lat1 * pi180;\\n            var lng1Radian = lng1 * pi180;\\n            var lat2Radian = lat2 * pi180;\\n            var lng2Radian = lng2 * pi180;\\n\\n            var diffLat = lat2Radian - lat1Radian;\\n            var diffLng = lng2Radian - lng1Radian;\\n\\n            var haversine =\\n                Math.Sin(diffLat / 2) * Math.Sin(diffLat / 2)\\n                + Math.Cos(lat1Radian) * Math.Cos(lat2Radian) * Math.Sin(diffLng / 2) * Math.Sin(diffLng / 2);\\n            var distance = EarthRadiusKm * (2d * Math.Atan2(Math.Sqrt(haversine), Math.Sqrt(1 - haversine)));\\n\\n            return distance * 1000; // Convert from km -> m\\n        }\\n    }\\n}\\n\"",
    "int2 binary": "\"using System.Text;\\n\\nnamespace Algorithms.Other\\n{\\n    /// <summary>\\n    ///     Manually converts an integer of certain size to a string of the binary representation.\\n    /// </summary>\\n    public static class Int2Binary\\n    {\\n        /// <summary>\\n        ///     Returns string of the binary representation of given Int.\\n        /// </summary>\\n        /// <param name=\\\"input\\\">Number to be converted.</param>\\n        /// <returns>Binary representation of input.</returns>\\n        public static string Int2Bin(ushort input)\\n        {\\n            ushort msb = ushort.MaxValue / 2 + 1;\\n            var output = new StringBuilder();\\n            for (var i = 0; i < 16; i++)\\n            {\\n                if (input >= msb)\\n                {\\n                    output.Append(\\\"1\\\");\\n                    input -= msb;\\n                    msb /= 2;\\n                }\\n                else\\n                {\\n                    output.Append(\\\"0\\\");\\n                    msb /= 2;\\n                }\\n            }\\n\\n            return output.ToString();\\n        }\\n\\n        /// <summary>\\n        ///     Returns string of the binary representation of given Int.\\n        /// </summary>\\n        /// <param name=\\\"input\\\">Number to be converted.</param>\\n        /// <returns>Binary representation of input.</returns>\\n        public static string Int2Bin(uint input)\\n        {\\n            var msb = uint.MaxValue / 2 + 1;\\n            var output = new StringBuilder();\\n            for (var i = 0; i < 32; i++)\\n            {\\n                if (input >= msb)\\n                {\\n                    output.Append(\\\"1\\\");\\n                    input -= msb;\\n                    msb /= 2;\\n                }\\n                else\\n                {\\n                    output.Append(\\\"0\\\");\\n                    msb /= 2;\\n                }\\n            }\\n\\n            return output.ToString();\\n        }\\n\\n        /// <summary>\\n        ///     Returns string of the binary representation of given Int.\\n        /// </summary>\\n        /// <param name=\\\"input\\\">Number to be converted.</param>\\n        /// <returns>Binary representation of input.</returns>\\n        public static string Int2Bin(ulong input)\\n        {\\n            var msb = ulong.MaxValue / 2 + 1;\\n            var output = new StringBuilder();\\n            for (var i = 0; i < 64; i++)\\n            {\\n                if (input >= msb)\\n                {\\n                    output.Append(\\\"1\\\");\\n                    input -= msb;\\n                    msb /= 2;\\n                }\\n                else\\n                {\\n                    output.Append(\\\"0\\\");\\n                    msb /= 2;\\n                }\\n            }\\n\\n            return output.ToString();\\n        }\\n    }\\n}\\n\"",
    "koch snowflake": "\"using System;\\nusing System.Collections.Generic;\\nusing System.Drawing;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Other\\n{\\n    /// <summary>\\n    ///     The Koch snowflake is a fractal curve and one of the earliest fractals to\\n    ///     have been described. The Koch snowflake can be built up iteratively, in a\\n    ///     sequence of stages. The first stage is an equilateral triangle, and each\\n    ///     successive stage is formed by adding outward bends to each side of the\\n    ///     previous stage, making smaller equilateral triangles.\\n    ///     This can be achieved through the following steps for each line:\\n    ///     1. divide the line segment into three segments of equal length.\\n    ///     2. draw an equilateral triangle that has the middle segment from step 1\\n    ///     as its base and points outward.\\n    ///     3. remove the line segment that is the base of the triangle from step 2.\\n    ///     (description adapted from https://en.wikipedia.org/wiki/Koch_snowflake )\\n    ///     (for a more detailed explanation and an implementation in the\\n    ///     Processing language, see  https://natureofcode.com/book/chapter-8-fractals/\\n    ///     #84-the-koch-curve-and-the-arraylist-technique ).\\n    /// </summary>\\n    public static class KochSnowflake\\n    {\\n        /// <summary>\\n        ///     Go through the number of iterations determined by the argument \\\"steps\\\".\\n        ///     Be careful with high values (above 5) since the time to calculate increases\\n        ///     exponentially.\\n        /// </summary>\\n        /// <param name=\\\"initialVectors\\\">\\n        ///     The vectors composing the shape to which\\n        ///     the algorithm is applied.\\n        /// </param>\\n        /// <param name=\\\"steps\\\">The number of iterations.</param>\\n        /// <returns>The transformed vectors after the iteration-steps.</returns>\\n        public static List<Vector2> Iterate(List<Vector2> initialVectors, int steps = 5)\\n        {\\n            List<Vector2> vectors = initialVectors;\\n            for (var i = 0; i < steps; i++)\\n            {\\n                vectors = IterationStep(vectors);\\n            }\\n\\n            return vectors;\\n        }\\n\\n        /// <summary>\\n        ///     Method to render the Koch snowflake to a bitmap. To save the\\n        ///     bitmap the command 'GetKochSnowflake().Save(\\\"KochSnowflake.png\\\")' can be used.\\n        /// </summary>\\n        /// <param name=\\\"bitmapWidth\\\">The width of the rendered bitmap.</param>\\n        /// <param name=\\\"steps\\\">The number of iterations.</param>\\n        /// <returns>The bitmap of the rendered Koch snowflake.</returns>\\n        public static Bitmap GetKochSnowflake(\\n            int bitmapWidth = 600,\\n            int steps = 5)\\n        {\\n            if (bitmapWidth <= 0)\\n            {\\n                throw new ArgumentOutOfRangeException(\\n                    nameof(bitmapWidth),\\n                    $\\\"{nameof(bitmapWidth)} should be greater than zero\\\");\\n            }\\n\\n            var offsetX = bitmapWidth / 10f;\\n            var offsetY = bitmapWidth / 3.7f;\\n            var vector1 = new Vector2(offsetX, offsetY);\\n            var vector2 = new Vector2(bitmapWidth / 2, (float)Math.Sin(Math.PI / 3) * bitmapWidth * 0.8f + offsetY);\\n            var vector3 = new Vector2(bitmapWidth - offsetX, offsetY);\\n            List<Vector2> initialVectors = new() { vector1, vector2, vector3, vector1 };\\n            List<Vector2> vectors = Iterate(initialVectors, steps);\\n            return GetBitmap(vectors, bitmapWidth, bitmapWidth);\\n        }\\n\\n        /// <summary>\\n        ///     Loops through each pair of adjacent vectors. Each line between two adjacent\\n        ///     vectors is divided into 4 segments by adding 3 additional vectors in-between\\n        ///     the original two vectors. The vector in the middle is constructed through a\\n        ///     60 degree rotation so it is bent outwards.\\n        /// </summary>\\n        /// <param name=\\\"vectors\\\">\\n        ///     The vectors composing the shape to which\\n        ///     the algorithm is applied.\\n        /// </param>\\n        /// <returns>The transformed vectors after the iteration-step.</returns>\\n        private static List<Vector2> IterationStep(List<Vector2> vectors)\\n        {\\n            List<Vector2> newVectors = new();\\n            for (var i = 0; i < vectors.Count - 1; i++)\\n            {\\n                var startVector = vectors[i];\\n                var endVector = vectors[i + 1];\\n                newVectors.Add(startVector);\\n                var differenceVector = endVector - startVector;\\n                newVectors.Add(startVector + differenceVector / 3);\\n                newVectors.Add(startVector + differenceVector / 3 + Rotate(differenceVector / 3, 60));\\n                newVectors.Add(startVector + differenceVector * 2 / 3);\\n            }\\n\\n            newVectors.Add(vectors[^1]);\\n            return newVectors;\\n        }\\n\\n        /// <summary>\\n        ///     Standard rotation of a 2D vector with a rotation matrix\\n        ///     (see https://en.wikipedia.org/wiki/Rotation_matrix ).\\n        /// </summary>\\n        /// <param name=\\\"vector\\\">The vector to be rotated.</param>\\n        /// <param name=\\\"angleInDegrees\\\">The angle by which to rotate the vector.</param>\\n        /// <returns>The rotated vector.</returns>\\n        private static Vector2 Rotate(Vector2 vector, float angleInDegrees)\\n        {\\n            var radians = angleInDegrees * (float)Math.PI / 180;\\n            var ca = (float)Math.Cos(radians);\\n            var sa = (float)Math.Sin(radians);\\n            return new Vector2(ca * vector.X - sa * vector.Y, sa * vector.X + ca * vector.Y);\\n        }\\n\\n        /// <summary>\\n        ///     Utility-method to render the Koch snowflake to a bitmap.\\n        /// </summary>\\n        /// <param name=\\\"vectors\\\">The vectors defining the edges to be rendered.</param>\\n        /// <param name=\\\"bitmapWidth\\\">The width of the rendered bitmap.</param>\\n        /// <param name=\\\"bitmapHeight\\\">The height of the rendered bitmap.</param>\\n        /// <returns>The bitmap of the rendered edges.</returns>\\n        private static Bitmap GetBitmap(\\n            List<Vector2> vectors,\\n            int bitmapWidth,\\n            int bitmapHeight)\\n        {\\n            Bitmap bitmap = new(bitmapWidth, bitmapHeight);\\n\\n            using (Graphics graphics = Graphics.FromImage(bitmap))\\n            {\\n                // Set the background white\\n                var imageSize = new Rectangle(0, 0, bitmapWidth, bitmapHeight);\\n                graphics.FillRectangle(Brushes.White, imageSize);\\n\\n                // Draw the edges\\n                for (var i = 0; i < vectors.Count - 1; i++)\\n                {\\n                    Pen blackPen = new(Color.Black, 1);\\n\\n                    var x1 = vectors[i].X;\\n                    var y1 = vectors[i].Y;\\n                    var x2 = vectors[i + 1].X;\\n                    var y2 = vectors[i + 1].Y;\\n\\n                    graphics.DrawLine(blackPen, x1, y1, x2, y2);\\n                }\\n            }\\n\\n            return bitmap;\\n        }\\n    }\\n}\\n\"",
    "luhn": "\"using System;\\n\\nnamespace Algorithms.Other\\n{\\n    /// <summary>\\n    ///     Luhn algorithm is a simple\\n    ///     checksum formula used to validate\\n    ///     a variety of identification numbers,\\n    ///     such as credit card numbers.\\n    ///     More information on the link:\\n    ///     https://en.wikipedia.org/wiki/Luhn_algorithm.\\n    /// </summary>\\n    public static class Luhn\\n    {\\n        /// <summary>\\n        ///     Checking the validity of a sequence of numbers.\\n        /// </summary>\\n        /// <param name=\\\"number\\\">The number that will be checked for validity.</param>\\n        /// <returns>\\n        ///     True: Number is valid.\\n        ///     False: Number isn`t valid.\\n        /// </returns>\\n        public static bool Validate(string number) => GetSum(number) % 10 == 0;\\n\\n        /// <summary>\\n        ///     This algorithm only finds one number.\\n        ///     In place of the unknown digit, put \\\"x\\\".\\n        /// </summary>\\n        /// <param name=\\\"number\\\">The number in which to find the missing digit.</param>\\n        /// <returns>Missing digit.</returns>\\n        public static int GetLostNum(string number)\\n        {\\n            var lostIndex = number.Length - 1 - number.LastIndexOf(\\\"x\\\", StringComparison.CurrentCultureIgnoreCase);\\n            var lostNum = GetSum(number.Replace(\\\"x\\\", \\\"0\\\", StringComparison.CurrentCultureIgnoreCase)) * 9 % 10;\\n\\n            // Case 1: If the index of the lost digit is even.\\n            if (lostIndex % 2 == 0)\\n            {\\n                return lostNum;\\n            }\\n\\n            var tempLostNum = lostNum / 2;\\n\\n            // Case 2: if the index of the lost digit isn`t even and that number <= 4.\\n            // Case 3: if the index of the lost digit isn`t even and that number > 4.\\n            return Validate(number.Replace(\\\"x\\\", tempLostNum.ToString())) ? tempLostNum : (lostNum + 9) / 2;\\n        }\\n\\n        /// <summary>\\n        ///     Computes the sum found by the algorithm.\\n        /// </summary>\\n        /// <param name=\\\"number\\\">The number for which the sum will be found.</param>\\n        /// <returns>Sum.</returns>\\n        private static int GetSum(string number)\\n        {\\n            var sum = 0;\\n            for (var i = 0; i < number.Length; i++)\\n            {\\n                var d = number[i] - '0';\\n                d = (i + number.Length) % 2 == 0\\n                    ? 2 * d\\n                    : d;\\n                if (d > 9)\\n                {\\n                    d -= 9;\\n                }\\n\\n                sum += d;\\n            }\\n\\n            return sum;\\n        }\\n    }\\n}\\n\"",
    "mandelbrot": "\"using System;\\nusing System.Drawing;\\n\\nnamespace Algorithms.Other\\n{\\n    /// <summary>\\n    ///     The Mandelbrot set is the set of complex numbers \\\"c\\\" for which the series\\n    ///     \\\"z_(n+1) = z_n * z_n + c\\\" does not diverge, i.e. remains bounded. Thus, a\\n    ///     complex number \\\"c\\\" is a member of the Mandelbrot set if, when starting with\\n    ///     \\\"z_0 = 0\\\" and applying the iteration repeatedly, the absolute value of\\n    ///     \\\"z_n\\\" remains bounded for all \\\"n > 0\\\". Complex numbers can be written as\\n    ///     \\\"a + b*i\\\": \\\"a\\\" is the real component, usually drawn on the x-axis, and \\\"b*i\\\"\\n    ///     is the imaginary component, usually drawn on the y-axis. Most visualizations\\n    ///     of the Mandelbrot set use a color-coding to indicate after how many steps in\\n    ///     the series the numbers outside the set cross the divergence threshold.\\n    ///     Images of the Mandelbrot set exhibit an elaborate and infinitely\\n    ///     complicated boundary that reveals progressively ever-finer recursive detail\\n    ///     at increasing magnifications, making the boundary of the Mandelbrot set a\\n    ///     fractal curve.\\n    ///     (description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set)\\n    ///     (see also https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set).\\n    /// </summary>\\n    public static class Mandelbrot\\n    {\\n        /// <summary>\\n        ///     Method to generate the bitmap of the Mandelbrot set. Two types of coordinates\\n        ///     are used: bitmap-coordinates that refer to the pixels and figure-coordinates\\n        ///     that refer to the complex numbers inside and outside the Mandelbrot set. The\\n        ///     figure-coordinates in the arguments of this method determine which section\\n        ///     of the Mandelbrot set is viewed. The main area of the Mandelbrot set is\\n        ///     roughly between \\\"-1.5 &lt; x &lt; 0.5\\\" and \\\"-1 &lt; y &lt; 1\\\" in the figure-coordinates.\\n        ///     To save the bitmap the command 'GetBitmap().Save(\\\"Mandelbrot.png\\\")' can be used.\\n        /// </summary>\\n        /// <param name=\\\"bitmapWidth\\\">The width of the rendered bitmap.</param>\\n        /// <param name=\\\"bitmapHeight\\\">The height of the rendered bitmap.</param>\\n        /// <param name=\\\"figureCenterX\\\">The x-coordinate of the center of the figure.</param>\\n        /// <param name=\\\"figureCenterY\\\">The y-coordinate of the center of the figure.</param>\\n        /// <param name=\\\"figureWidth\\\">The width of the figure.</param>\\n        /// <param name=\\\"maxStep\\\">Maximum number of steps to check for divergent behavior.</param>\\n        /// <param name=\\\"useDistanceColorCoding\\\">Render in color or black and white.</param>\\n        /// <returns>The bitmap of the rendered Mandelbrot set.</returns>\\n        public static Bitmap GetBitmap(\\n            int bitmapWidth = 800,\\n            int bitmapHeight = 600,\\n            double figureCenterX = -0.6,\\n            double figureCenterY = 0,\\n            double figureWidth = 3.2,\\n            int maxStep = 50,\\n            bool useDistanceColorCoding = true)\\n        {\\n            if (bitmapWidth <= 0)\\n            {\\n                throw new ArgumentOutOfRangeException(\\n                    nameof(bitmapWidth),\\n                    $\\\"{nameof(bitmapWidth)} should be greater than zero\\\");\\n            }\\n\\n            if (bitmapHeight <= 0)\\n            {\\n                throw new ArgumentOutOfRangeException(\\n                    nameof(bitmapHeight),\\n                    $\\\"{nameof(bitmapHeight)} should be greater than zero\\\");\\n            }\\n\\n            if (maxStep <= 0)\\n            {\\n                throw new ArgumentOutOfRangeException(\\n                    nameof(maxStep),\\n                    $\\\"{nameof(maxStep)} should be greater than zero\\\");\\n            }\\n\\n            var bitmap = new Bitmap(bitmapWidth, bitmapHeight);\\n            var figureHeight = figureWidth / bitmapWidth * bitmapHeight;\\n\\n            // loop through the bitmap-coordinates\\n            for (var bitmapX = 0; bitmapX < bitmapWidth; bitmapX++)\\n            {\\n                for (var bitmapY = 0; bitmapY < bitmapHeight; bitmapY++)\\n                {\\n                    // determine the figure-coordinates based on the bitmap-coordinates\\n                    var figureX = figureCenterX + ((double)bitmapX / bitmapWidth - 0.5) * figureWidth;\\n                    var figureY = figureCenterY + ((double)bitmapY / bitmapHeight - 0.5) * figureHeight;\\n\\n                    var distance = GetDistance(figureX, figureY, maxStep);\\n\\n                    // color the corresponding pixel based on the selected coloring-function\\n                    bitmap.SetPixel(\\n                        bitmapX,\\n                        bitmapY,\\n                        useDistanceColorCoding ? ColorCodedColorMap(distance) : BlackAndWhiteColorMap(distance));\\n                }\\n            }\\n\\n            return bitmap;\\n        }\\n\\n        /// <summary>\\n        ///     Black and white color-coding that ignores the relative distance. The Mandelbrot\\n        ///     set is black, everything else is white.\\n        /// </summary>\\n        /// <param name=\\\"distance\\\">Distance until divergence threshold.</param>\\n        /// <returns>The color corresponding to the distance.</returns>\\n        private static Color BlackAndWhiteColorMap(double distance) =>\\n            distance >= 1\\n                ? Color.FromArgb(255, 0, 0, 0)\\n                : Color.FromArgb(255, 255, 255, 255);\\n\\n        /// <summary>\\n        ///     Color-coding taking the relative distance into account. The Mandelbrot set\\n        ///     is black.\\n        /// </summary>\\n        /// <param name=\\\"distance\\\">Distance until divergence threshold.</param>\\n        /// <returns>The color corresponding to the distance.</returns>\\n        private static Color ColorCodedColorMap(double distance)\\n        {\\n            if (distance >= 1)\\n            {\\n                return Color.FromArgb(255, 0, 0, 0);\\n            }\\n\\n            // simplified transformation of HSV to RGB\\n            // distance determines hue\\n            var hue = 360 * distance;\\n            double saturation = 1;\\n            double val = 255;\\n            var hi = (int)Math.Floor(hue / 60) % 6;\\n            var f = hue / 60 - Math.Floor(hue / 60);\\n\\n            var v = (int)val;\\n            var p = 0;\\n            var q = (int)(val * (1 - f * saturation));\\n            var t = (int)(val * (1 - (1 - f) * saturation));\\n\\n            switch (hi)\\n            {\\n                case 0: return Color.FromArgb(255, v, t, p);\\n                case 1: return Color.FromArgb(255, q, v, p);\\n                case 2: return Color.FromArgb(255, p, v, t);\\n                case 3: return Color.FromArgb(255, p, q, v);\\n                case 4: return Color.FromArgb(255, t, p, v);\\n                default: return Color.FromArgb(255, v, p, q);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Return the relative distance (ratio of steps taken to maxStep) after which the complex number\\n        ///     constituted by this x-y-pair diverges. Members of the Mandelbrot set do not\\n        ///     diverge so their distance is 1.\\n        /// </summary>\\n        /// <param name=\\\"figureX\\\">The x-coordinate within the figure.</param>\\n        /// <param name=\\\"figureY\\\">The y-coordinate within the figure.</param>\\n        /// <param name=\\\"maxStep\\\">Maximum number of steps to check for divergent behavior.</param>\\n        /// <returns>The relative distance as the ratio of steps taken to maxStep.</returns>\\n        private static double GetDistance(double figureX, double figureY, int maxStep)\\n        {\\n            var a = figureX;\\n            var b = figureY;\\n            var currentStep = 0;\\n            for (var step = 0; step < maxStep; step++)\\n            {\\n                currentStep = step;\\n                var aNew = a * a - b * b + figureX;\\n                b = 2 * a * b + figureY;\\n                a = aNew;\\n\\n                // divergence happens for all complex number with an absolute value\\n                // greater than 4 (= divergence threshold)\\n                if (a * a + b * b > 4)\\n                {\\n                    break;\\n                }\\n            }\\n\\n            return (double)currentStep / (maxStep - 1);\\n        }\\n    }\\n}\\n\"",
    "r g b h s v conversion": "\"using System;\\n\\nnamespace Algorithms.Other\\n{\\n    /// <summary>\\n    ///     The RGB color model is an additive color model in which red, green, and\\n    ///     blue light are added together in various ways to reproduce a broad array of\\n    ///     colors. The name of the model comes from the initials of the three additive\\n    ///     primary colors, red, green, and blue. Meanwhile, the HSV representation\\n    ///     models how colors appear under light. In it, colors are represented using\\n    ///     three components: hue, saturation and (brightness-)value. This class\\n    ///     provides methods for converting colors from one representation to the other.\\n    ///     (description adapted from https://en.wikipedia.org/wiki/RGB_color_model and\\n    ///     https://en.wikipedia.org/wiki/HSL_and_HSV).\\n    /// </summary>\\n    public static class RgbHsvConversion\\n    {\\n        /// <summary>\\n        ///     Conversion from the HSV-representation to the RGB-representation.\\n        /// </summary>\\n        /// <param name=\\\"hue\\\">Hue of the color.</param>\\n        /// <param name=\\\"saturation\\\">Saturation of the color.</param>\\n        /// <param name=\\\"value\\\">Brightness-value of the color.</param>\\n        /// <returns>The tuple of RGB-components.</returns>\\n        public static (byte red, byte green, byte blue) HsvToRgb(\\n            double hue,\\n            double saturation,\\n            double value)\\n        {\\n            if (hue < 0 || hue > 360)\\n            {\\n                throw new ArgumentOutOfRangeException(nameof(hue), $\\\"{nameof(hue)} should be between 0 and 360\\\");\\n            }\\n\\n            if (saturation < 0 || saturation > 1)\\n            {\\n                throw new ArgumentOutOfRangeException(\\n                    nameof(saturation),\\n                    $\\\"{nameof(saturation)} should be between 0 and 1\\\");\\n            }\\n\\n            if (value < 0 || value > 1)\\n            {\\n                throw new ArgumentOutOfRangeException(nameof(value), $\\\"{nameof(value)} should be between 0 and 1\\\");\\n            }\\n\\n            var chroma = value * saturation;\\n            var hueSection = hue / 60;\\n            var secondLargestComponent = chroma * (1 - Math.Abs(hueSection % 2 - 1));\\n            var matchValue = value - chroma;\\n\\n            return GetRgbBySection(hueSection, chroma, matchValue, secondLargestComponent);\\n        }\\n\\n        /// <summary>\\n        ///     Conversion from the RGB-representation to the HSV-representation.\\n        /// </summary>\\n        /// <param name=\\\"red\\\">Red-component of the color.</param>\\n        /// <param name=\\\"green\\\">Green-component of the color.</param>\\n        /// <param name=\\\"blue\\\">Blue-component of the color.</param>\\n        /// <returns>The tuple of HSV-components.</returns>\\n        public static (double hue, double saturation, double value) RgbToHsv(\\n            byte red,\\n            byte green,\\n            byte blue)\\n        {\\n            var dRed = (double)red / 255;\\n            var dGreen = (double)green / 255;\\n            var dBlue = (double)blue / 255;\\n            var value = Math.Max(Math.Max(dRed, dGreen), dBlue);\\n            var chroma = value - Math.Min(Math.Min(dRed, dGreen), dBlue);\\n            var saturation = value.Equals(0) ? 0 : chroma / value;\\n            double hue;\\n\\n            if (chroma.Equals(0))\\n            {\\n                hue = 0;\\n            }\\n            else if (value.Equals(dRed))\\n            {\\n                hue = 60 * (0 + (dGreen - dBlue) / chroma);\\n            }\\n            else if (value.Equals(dGreen))\\n            {\\n                hue = 60 * (2 + (dBlue - dRed) / chroma);\\n            }\\n            else\\n            {\\n                hue = 60 * (4 + (dRed - dGreen) / chroma);\\n            }\\n\\n            hue = (hue + 360) % 360;\\n\\n            return (hue, saturation, value);\\n        }\\n\\n        private static (byte red, byte green, byte blue) GetRgbBySection(\\n            double hueSection,\\n            double chroma,\\n            double matchValue,\\n            double secondLargestComponent)\\n        {\\n            byte red;\\n            byte green;\\n            byte blue;\\n\\n            if (hueSection >= 0 && hueSection <= 1)\\n            {\\n                red = ConvertToByte(chroma + matchValue);\\n                green = ConvertToByte(secondLargestComponent + matchValue);\\n                blue = ConvertToByte(matchValue);\\n            }\\n            else if (hueSection > 1 && hueSection <= 2)\\n            {\\n                red = ConvertToByte(secondLargestComponent + matchValue);\\n                green = ConvertToByte(chroma + matchValue);\\n                blue = ConvertToByte(matchValue);\\n            }\\n            else if (hueSection > 2 && hueSection <= 3)\\n            {\\n                red = ConvertToByte(matchValue);\\n                green = ConvertToByte(chroma + matchValue);\\n                blue = ConvertToByte(secondLargestComponent + matchValue);\\n            }\\n            else if (hueSection > 3 && hueSection <= 4)\\n            {\\n                red = ConvertToByte(matchValue);\\n                green = ConvertToByte(secondLargestComponent + matchValue);\\n                blue = ConvertToByte(chroma + matchValue);\\n            }\\n            else if (hueSection > 4 && hueSection <= 5)\\n            {\\n                red = ConvertToByte(secondLargestComponent + matchValue);\\n                green = ConvertToByte(matchValue);\\n                blue = ConvertToByte(chroma + matchValue);\\n            }\\n            else\\n            {\\n                red = ConvertToByte(chroma + matchValue);\\n                green = ConvertToByte(matchValue);\\n                blue = ConvertToByte(secondLargestComponent + matchValue);\\n            }\\n\\n            return (red, green, blue);\\n        }\\n\\n        private static byte ConvertToByte(double input) => (byte)Math.Round(255 * input);\\n    }\\n}\\n\"",
    "sieve of eratosthenes": "\"using System.Collections.Generic;\\nusing System.Linq;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Other\\n{\\n    /// <summary>\\n    ///     TODO.\\n    /// </summary>\\n    public static class SieveOfEratosthenes\\n    {\\n        /// <summary>\\n        ///     TODO.\\n        /// </summary>\\n        /// <param name=\\\"count\\\">TODO. 2.</param>\\n        /// <returns>TODO. 3.</returns>\\n        public static List<BigInteger> GetPrimeNumbers(int count)\\n        {\\n            var output = new List<BigInteger>();\\n            for (BigInteger n = 2; output.Count < count; n++)\\n            {\\n                if (output.All(x => n % x != 0))\\n                {\\n                    output.Add(n);\\n                }\\n            }\\n\\n            return output;\\n        }\\n    }\\n}\\n\"",
    "binary searcher": "\"using System;\\n\\nnamespace Algorithms.Search\\n{\\n    /// <summary>\\n    ///     TODO.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">TODO. 2.</typeparam>\\n    public class BinarySearcher<T> where T : IComparable<T>\\n    {\\n        /// <summary>\\n        ///     Finds index of item in array that equals to item searched for,\\n        ///     time complexity: O(log(n)),\\n        ///     space complexity: O(1),\\n        ///     where n - array size.\\n        /// </summary>\\n        /// <param name=\\\"sortedData\\\">Sorted array to search in.</param>\\n        /// <param name=\\\"item\\\">Item to search for.</param>\\n        /// <returns>Index of item that equals to item searched for or -1 if none found.</returns>\\n        public int FindIndex(T[] sortedData, T item)\\n        {\\n            var leftIndex = 0;\\n            var rightIndex = sortedData.Length - 1;\\n\\n            while (leftIndex <= rightIndex)\\n            {\\n                var middleIndex = leftIndex + (rightIndex - leftIndex) / 2;\\n\\n                if (item.CompareTo(sortedData[middleIndex]) > 0)\\n                {\\n                    leftIndex = middleIndex + 1;\\n                    continue;\\n                }\\n\\n                if (item.CompareTo(sortedData[middleIndex]) < 0)\\n                {\\n                    rightIndex = middleIndex - 1;\\n                    continue;\\n                }\\n\\n                return middleIndex;\\n            }\\n\\n            return -1;\\n        }\\n    }\\n}\\n\"",
    "fast searcher": "\"using System;\\nusing Utilities.Exceptions;\\n\\nnamespace Algorithms.Search\\n{\\n    /// <summary>\\n    ///     The idea: you could combine the advantages from both binary-search and interpolation search algorithm.\\n    ///     Time complexity:\\n    ///     worst case: Item couldn't be found: O(log n),\\n    ///     average case: O(log log n),\\n    ///     best case: O(1).\\n    ///     Note: This algorithm is recursive and the array has to be sorted beforehand.\\n    /// </summary>\\n    public class FastSearcher\\n    {\\n        /// <summary>\\n        ///     Finds index of first item in array that satisfies specified term\\n        ///     throws ItemNotFoundException if the item couldn't be found.\\n        /// </summary>\\n        /// <param name=\\\"array\\\">Span of sorted numbers which will be used to find the item.</param>\\n        /// <param name=\\\"item\\\">Term to check against.</param>\\n        /// <returns>Index of first item that satisfies term.</returns>\\n        /// <exception cref=\\\"ItemNotFoundException\\\"> Gets thrown when the given item couldn't be found in the array.</exception>\\n        public int FindIndex(Span<int> array, int item)\\n        {\\n            if (array.Length == 0)\\n            {\\n                throw new ItemNotFoundException();\\n            }\\n\\n            if (item < array[0] || item > array[^1])\\n            {\\n                throw new ItemNotFoundException();\\n            }\\n\\n            if (array[0] == array[^1])\\n            {\\n                return item == array[0] ? 0 : throw new ItemNotFoundException();\\n            }\\n\\n            var (left, right) = ComputeIndices(array, item);\\n            var (from, to) = SelectSegment(array, left, right, item);\\n\\n            return from + FindIndex(array.Slice(from, to - from + 1), item);\\n        }\\n\\n        private (int left, int right) ComputeIndices(Span<int> array, int item)\\n        {\\n            var indexBinary = array.Length / 2;\\n\\n            int[] section =\\n            {\\n                array.Length - 1,\\n                item - array[0],\\n                array[^1] - array[0],\\n            };\\n            var indexInterpolation = section[0] * section[1] / section[2];\\n\\n            // Left is min and right is max of the indices\\n            return indexInterpolation > indexBinary\\n                ? (indexBinary, indexInterpolation)\\n                : (indexInterpolation, indexBinary);\\n        }\\n\\n        private (int from, int to) SelectSegment(Span<int> array, int left, int right, int item)\\n        {\\n            if (item < array[left])\\n            {\\n                return (0, left - 1);\\n            }\\n\\n            if (item < array[right])\\n            {\\n                return (left, right - 1);\\n            }\\n\\n            return (right, array.Length - 1);\\n        }\\n    }\\n}\\n\"",
    "jump searcher": "\"using System;\\n\\nnamespace Algorithms.Search\\n{\\n    /// <summary>\\n    ///     Jump Search checks fewer elements by jumping ahead by fixed steps.\\n    ///     The optimal steps to jump is √n, where n refers to the number of elements in the array.\\n    ///     Time Complexity: O(√n)\\n    ///     Note: The array has to be sorted beforehand.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Type of the array element.</typeparam>\\n    public class JumpSearcher<T> where T : IComparable<T>\\n    {\\n        /// <summary>\\n        ///     Find the index of the item searched for in the array.\\n        /// </summary>\\n        /// <param name=\\\"sortedArray\\\">Sorted array to be search in. Cannot be null.</param>\\n        /// <param name=\\\"searchItem\\\">Item to be search for. Cannot be null.</param>\\n        /// <returns>If item is found, return index. If array is empty or item not found, return -1.</returns>\\n        public int FindIndex(T[] sortedArray, T searchItem)\\n        {\\n            if (sortedArray is null)\\n            {\\n                throw new ArgumentNullException(\\\"sortedArray\\\");\\n            }\\n\\n            if (searchItem is null)\\n            {\\n                throw new ArgumentNullException(\\\"searchItem\\\");\\n            }\\n\\n            int jumpStep = (int)Math.Floor(Math.Sqrt(sortedArray.Length));\\n            int currentIndex = 0;\\n            int nextIndex = jumpStep;\\n\\n            if (sortedArray.Length != 0)\\n            {\\n                while (sortedArray[nextIndex - 1].CompareTo(searchItem) < 0)\\n                {\\n                    currentIndex = nextIndex;\\n                    nextIndex += jumpStep;\\n\\n                    if (nextIndex >= sortedArray.Length)\\n                    {\\n                        nextIndex = sortedArray.Length - 1;\\n                        break;\\n                    }\\n                }\\n\\n                for (int i = currentIndex; i <= nextIndex; i++)\\n                {\\n                    if (sortedArray[i].CompareTo(searchItem) == 0)\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n\\n            return -1;\\n        }\\n    }\\n}\\n\"",
    "linear searcher": "\"using System;\\nusing Utilities.Exceptions;\\n\\nnamespace Algorithms.Search\\n{\\n    /// <summary>\\n    ///     Class that implements linear search algorithm.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Type of array element.</typeparam>\\n    public class LinearSearcher<T>\\n    {\\n        /// <summary>\\n        ///     Finds first item in array that satisfies specified term\\n        ///     Time complexity: O(n)\\n        ///     Space complexity: O(1).\\n        /// </summary>\\n        /// <param name=\\\"data\\\">Array to search in.</param>\\n        /// <param name=\\\"term\\\">Term to check against.</param>\\n        /// <returns>First item that satisfies term.</returns>\\n        public T Find(T[] data, Func<T, bool> term)\\n        {\\n            for (var i = 0; i < data.Length; i++)\\n            {\\n                if (term(data[i]))\\n                {\\n                    return data[i];\\n                }\\n            }\\n\\n            throw new ItemNotFoundException();\\n        }\\n\\n        /// <summary>\\n        ///     Finds index of first item in array that satisfies specified term\\n        ///     Time complexity: O(n)\\n        ///     Space complexity: O(1).\\n        /// </summary>\\n        /// <param name=\\\"data\\\">Array to search in.</param>\\n        /// <param name=\\\"term\\\">Term to check against.</param>\\n        /// <returns>Index of first item that satisfies term or -1 if none found.</returns>\\n        public int FindIndex(T[] data, Func<T, bool> term)\\n        {\\n            for (var i = 0; i < data.Length; i++)\\n            {\\n                if (term(data[i]))\\n                {\\n                    return i;\\n                }\\n            }\\n\\n            return -1;\\n        }\\n    }\\n}\\n\"",
    "recursive binary searcher": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace Algorithms.Search\\n{\\n    /// <summary>\\n    ///     RecursiveBinarySearcher.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Type of searcher target.</typeparam>\\n    public class RecursiveBinarySearcher<T> where T : IComparable<T>\\n    {\\n        /// <summary>\\n        ///     Finds index of item in collection that equals to item searched for,\\n        ///     time complexity: O(log(n)),\\n        ///     space complexity: O(1),\\n        ///     where n - collection size.\\n        /// </summary>\\n        /// <param name=\\\"collection\\\">Sorted collection to search in.</param>\\n        /// <param name=\\\"item\\\">Item to search for.</param>\\n        /// <exception cref=\\\"ArgumentNullException\\\">Thrown if input collection is null.</exception>\\n        /// <returns>Index of item that equals to item searched for or -1 if none found.</returns>\\n        public int FindIndex(IList<T>? collection, T item)\\n        {\\n            if (collection is null)\\n            {\\n                throw new ArgumentNullException(nameof(collection));\\n            }\\n\\n            var leftIndex = 0;\\n            var rightIndex = collection.Count - 1;\\n\\n            return FindIndex(collection, item, leftIndex, rightIndex);\\n        }\\n\\n        /// <summary>\\n        ///     Finds index of item in array that equals to item searched for,\\n        ///     time complexity: O(log(n)),\\n        ///     space complexity: O(1),\\n        ///     where n - array size.\\n        /// </summary>\\n        /// <param name=\\\"collection\\\">Sorted array to search in.</param>\\n        /// <param name=\\\"item\\\">Item to search for.</param>\\n        /// <param name=\\\"leftIndex\\\">Minimum search range.</param>\\n        /// <param name=\\\"rightIndex\\\">Maximum search range.</param>\\n        /// <returns>Index of item that equals to item searched for or -1 if none found.</returns>\\n        private int FindIndex(IList<T> collection, T item, int leftIndex, int rightIndex)\\n        {\\n            if (leftIndex > rightIndex)\\n            {\\n                return -1;\\n            }\\n\\n            var middleIndex = leftIndex + (rightIndex - leftIndex) / 2;\\n            var result = item.CompareTo(collection[middleIndex]);\\n\\n            return result switch\\n            {\\n                var r when r == 0 => middleIndex,\\n                var r when r > 0 => FindIndex(collection, item, middleIndex + 1, rightIndex),\\n                var r when r < 0 => FindIndex(collection, item, leftIndex, middleIndex - 1),\\n                _ => -1,\\n            };\\n        }\\n    }\\n}\\n\"",
    "binomial sequence": "\"using System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Sequence of binomial coefficients.\\n    ///     </para>\\n    ///     <para>\\n    ///         Wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: http://oeis.org/A007318.\\n    ///     </para>\\n    /// </summary>\\n    public class BinomialSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     Gets sequence of binomial coefficients.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                var i = 0;\\n\\n                while (true)\\n                {\\n                    var row = GenerateRow(i);\\n                    foreach (var coefficient in row)\\n                    {\\n                        yield return coefficient;\\n                    }\\n\\n                    i++;\\n                }\\n            }\\n        }\\n\\n        private static BigInteger BinomialCoefficient(long n, long k)\\n        {\\n            if (k == 0 || k == n)\\n            {\\n                return new BigInteger(1);\\n            }\\n\\n            if (n < 0)\\n            {\\n                return new BigInteger(0);\\n            }\\n\\n            return BinomialCoefficient(n - 1, k) + BinomialCoefficient(n - 1, k - 1);\\n        }\\n\\n        private static IEnumerable<BigInteger> GenerateRow(long n)\\n        {\\n            long k = 0;\\n\\n            while (k <= n)\\n            {\\n                yield return BinomialCoefficient(n, k);\\n                k++;\\n            }\\n        }\\n    }\\n}\\n\"",
    "catalan sequence": "\"using System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Catalan numbers: C[n+1] = (2*(2*n+1)*C[n])/(n+2).\\n    ///     </para>\\n    ///     <para>\\n    ///         Wikipedia: https://en.wikipedia.org/wiki/Catalan_number.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS:http://oeis.org/A000108.\\n    ///     </para>\\n    /// </summary>\\n    public class CatalanSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     Gets sequence of Catalan numbers.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                // initialize the first element (1) and define it's enumerator (0)\\n                var catalan = new BigInteger(1);\\n                var n = 0;\\n                while (true)\\n                {\\n                    yield return catalan;\\n                    catalan = (2 * (2 * n + 1) * catalan) / (n + 2);\\n                    n++;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "divisors count sequence": "\"using System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Sequence of the number of divisors of n, starting with 1.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: https://oeis.org/A000005.\\n    ///     </para>\\n    /// </summary>\\n    public class DivisorsCountSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     Gets sequence of number of divisors for n, starting at 1.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                yield return BigInteger.One;\\n                for (var n = new BigInteger(2); ; n++)\\n                {\\n                    var count = 2;\\n                    for (var k = 2; k < n; k++)\\n                    {\\n                        BigInteger.DivRem(n, k, out var remainder);\\n                        if (remainder == 0)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n\\n                    yield return count;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "euler totient sequence": "\"using System.Collections.Generic;\\nusing System.Linq;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Sequence of Euler totient function phi(n).\\n    ///     </para>\\n    ///     <para>\\n    ///         Wikipedia: https://en.wikipedia.org/wiki/Euler%27s_totient_function.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: https://oeis.org/A000010.\\n    ///     </para>\\n    /// </summary>\\n    public class EulerTotientSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     <para>\\n        ///         Gets sequence of Euler totient function phi(n).\\n        ///     </para>\\n        ///     <para>\\n        ///         'n' is copied from value of the loop of i that's being enumerated over.\\n        ///         1) Initialize result as n\\n        ///         2) Consider every number 'factor' (where 'factor' is a prime divisor of n).\\n        ///            If factor divides n, then do following\\n        ///            a) Subtract all multiples of factor from 1 to n [all multiples of factor\\n        ///               will have gcd more than 1 (at least factor) with n]\\n        ///            b) Update n by repeatedly dividing it by factor.\\n        ///         3) If the reduced n is more than 1, then remove all multiples\\n        ///            of n from result.\\n        ///     </para>\\n        ///     <para>\\n        ///         Base code was from https://www.geeksforgeeks.org/eulers-totient-function/.\\n        ///      </para>\\n        ///     <para>\\n        ///         Implementation avoiding floating point operations was used for base\\n        ///         and replacement of loop going from 1 to sqrt(n) was replaced with\\n        ///         List of prime factors.\\n        ///     </para>\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                yield return BigInteger.One;\\n\\n                for (BigInteger i = 2; ; i++)\\n                {\\n                    var n = i;\\n                    var result = n;\\n\\n                    var factors = PrimeFactors(i);\\n                    foreach (var factor in factors)\\n                    {\\n                        while (n % factor == 0)\\n                        {\\n                            n /= factor;\\n                        }\\n\\n                        result -= result / factor;\\n                    }\\n\\n                    if (n > 1)\\n                    {\\n                        result -= result / n;\\n                    }\\n\\n                    yield return result;\\n                }\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     <para>\\n        ///         Uses the prime sequence to find all prime factors of the\\n        ///         number we're looking at.\\n        ///     </para>\\n        ///     <para>\\n        ///         The prime sequence is examined until its value squared is\\n        ///         less than or equal to target, and checked to make sure it\\n        ///         evenly divides the target.  If it evenly divides, it's added\\n        ///         to the result which is returned as a List.\\n        ///     </para>\\n        /// </summary>\\n        /// <param name=\\\"target\\\">Number that is being factored.</param>\\n        /// <returns>List of prime factors of target.</returns>\\n        private static IEnumerable<BigInteger> PrimeFactors(BigInteger target)\\n        {\\n            return new PrimesSequence()\\n                  .Sequence.TakeWhile(prime => prime * prime <= target)\\n                  .Where(prime => target % prime == 0)\\n                  .ToList();\\n        }\\n    }\\n}\\n\"",
    "factorial sequence": "\"using System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Sequence of factorial numbers.\\n    ///     </para>\\n    ///     <para>\\n    ///         Wikipedia: https://en.wikipedia.org/wiki/Factorial.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: https://oeis.org/A000142.\\n    ///     </para>\\n    /// </summary>\\n    public class FactorialSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     Gets sequence of factorial numbers.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                var n = 0;\\n                var factorial = new BigInteger(1);\\n                while (true)\\n                {\\n                    yield return factorial;\\n                    n++;\\n                    factorial *= n;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "fibonacci sequence": "\"using System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Fibonacci sequence.\\n    ///     </para>\\n    ///     <para>\\n    ///         Wikipedia: https://wikipedia.org/wiki/Fibonacci_number.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: https://oeis.org/A000045.\\n    ///     </para>\\n    /// </summary>\\n    public class FibonacciSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     Gets Fibonacci sequence.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                yield return 0;\\n                yield return 1;\\n                BigInteger previous = 0;\\n                BigInteger current = 1;\\n                while (true)\\n                {\\n                    var next = previous + current;\\n                    previous = current;\\n                    current = next;\\n                    yield return next;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "golombs sequence": "\"using System.Collections.Generic;\\nusing System.Linq;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Golomb's sequence. a(n) is the number of times n occurs in the sequence, starting with a(1) = 1.\\n    ///     </para>\\n    ///     <para>\\n    ///         Wikipedia: https://en.wikipedia.org/wiki/Golomb_sequence.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: https://oeis.org/A001462.\\n    ///     </para>\\n    /// </summary>\\n    public class GolombsSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     Gets Golomb's sequence.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                yield return 1;\\n                yield return 2;\\n                yield return 2;\\n\\n                var queue = new Queue<BigInteger>();\\n                queue.Enqueue(2);\\n\\n                for (var i = 3; ; i++)\\n                {\\n                    var repetitions = queue.Dequeue();\\n                    for (var j = 0; j < repetitions; j++)\\n                    {\\n                        queue.Enqueue(i);\\n                        yield return i;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "i sequence": "\"using System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     Common interface for all integer sequences.\\n    /// </summary>\\n    public interface ISequence\\n    {\\n        /// <summary>\\n        ///     Gets sequence as enumerable.\\n        /// </summary>\\n        IEnumerable<BigInteger> Sequence { get; }\\n    }\\n}\\n\"",
    "kolakoski sequence": "\"using System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Kolakoski sequence; n-th element is the length of the n-th run in the sequence itself.\\n    ///     </para>\\n    ///     <para>\\n    ///         Wikipedia: https://en.wikipedia.org/wiki/Kolakoski_sequence.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: https://oeis.org/A000002.\\n    ///     </para>\\n    /// </summary>\\n    public class KolakoskiSequence : ISequence\\n    {\\n        /// <summary>\\n        /// Gets Kolakoski sequence.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                yield return 1;\\n                yield return 2;\\n                yield return 2;\\n\\n                var queue = new Queue<int>();\\n                queue.Enqueue(2);\\n                var nextElement = 1;\\n                while (true)\\n                {\\n                    var nextRun = queue.Dequeue();\\n                    for (var i = 0; i < nextRun; i++)\\n                    {\\n                        queue.Enqueue(nextElement);\\n                        yield return nextElement;\\n                    }\\n\\n                    nextElement = 1 + nextElement % 2;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "make change sequence": "\"using System;\\nusing System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Number of ways of making change for n cents using coins of 1, 2, 5, 10 cents.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: https://oeis.org/A000008.\\n    ///     </para>\\n    /// </summary>\\n    public class MakeChangeSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     <para>\\n        ///         Gets sequence of number of ways of making change for n cents\\n        ///         using coins of 1, 2, 5, 10 cents.\\n        ///     </para>\\n        ///     <para>\\n        ///         Uses formula from OEIS page by Michael Somos\\n        ///         along with first 17 values to prevent index issues.\\n        ///     </para>\\n        ///     <para>\\n        ///         Formula:\\n        ///         a(n) = a(n-2) +a(n-5) - a(n-7) + a(n-10) - a(n-12) - a(n-15) + a(n-17) + 1.\\n        ///     </para>\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                var seed = new List<BigInteger>\\n                           {\\n                               1, 1, 2, 2, 3, 4, 5, 6, 7, 8,\\n                               11, 12, 15, 16, 19, 22, 25,\\n                           };\\n                foreach (var value in seed)\\n                {\\n                    yield return value;\\n                }\\n\\n                for(var index = 17; ; index++)\\n                {\\n                    BigInteger newValue = seed[index - 2] + seed[index - 5] - seed[index - 7]\\n                                        + seed[index - 10] - seed[index - 12] - seed[index - 15]\\n                                        + seed[index - 17] + 1;\\n\\n                    seed.Add(newValue);\\n                    yield return newValue;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "natural sequence": "\"using System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Sequence of natural numbers.\\n    ///     </para>\\n    ///     <para>\\n    ///         Wikipedia: https://wikipedia.org/wiki/Natural_number.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: https://oeis.org/A000027.\\n    ///     </para>\\n    /// </summary>\\n    public class NaturalSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     Gets sequence of natural numbers.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                var n = new BigInteger(1);\\n                while (true)\\n                {\\n                    yield return n++;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "primes sequence": "\"using System.Collections.Generic;\\nusing System.Linq;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Sequence of prime numbers.\\n    ///     </para>\\n    ///     <para>\\n    ///         Wikipedia: https://wikipedia.org/wiki/Prime_number.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: https://oeis.org/A000040.\\n    ///     </para>\\n    /// </summary>\\n    public class PrimesSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     Gets sequence of prime numbers.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                yield return 2;\\n                var primes = new List<BigInteger>\\n                {\\n                    2,\\n                };\\n                var n = new BigInteger(3);\\n\\n                while (true)\\n                {\\n                    if (primes.All(p => n % p != 0))\\n                    {\\n                        yield return n;\\n                        primes.Add(n);\\n                    }\\n\\n                    n += 2;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "recamans sequence": "\"using System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Recaman's sequence. a(0) = 0; for n > 0, a(n) = a(n-1) - n if nonnegative and not already in the sequence, otherwise a(n) = a(n-1) + n.\\n    ///     </para>\\n    ///     <para>\\n    ///         Wikipedia: https://en.wikipedia.org/wiki/Recam%C3%A1n%27s_sequence.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: http://oeis.org/A005132.\\n    ///     </para>\\n    /// </summary>\\n    public class RecamansSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     Gets Recaman's sequence.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                yield return 0;\\n                var elements = new HashSet<BigInteger> { 0 };\\n                var previous = 0;\\n                var i = 1;\\n\\n                while (true)\\n                {\\n                    var current = previous - i;\\n                    if (current < 0 || elements.Contains(current))\\n                    {\\n                        current = previous + i;\\n                    }\\n\\n                    yield return current;\\n                    previous = current;\\n                    elements.Add(current);\\n                    i++;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "van ecks sequence": "\"using System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         Van Eck's sequence. For n >= 1, if there exists an m &lt; n such that a(m) = a(n), take the largest such m and set a(n+1) = n-m; otherwise a(n+1) = 0. Start with a(1)=0.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: http://oeis.org/A181391.\\n    ///     </para>\\n    /// </summary>\\n    public class VanEcksSequence : ISequence\\n    {\\n        /// <summary>\\n        ///     Gets Van Eck's sequence.\\n        /// </summary>\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                yield return 0;\\n                var dictionary = new Dictionary<BigInteger, BigInteger>();\\n                BigInteger previous = 0;\\n                BigInteger currentIndex = 2; // 1-based index\\n                while (true)\\n                {\\n                    BigInteger element = 0;\\n                    if (dictionary.TryGetValue(previous, out var previousIndex))\\n                    {\\n                        element = currentIndex - previousIndex;\\n                    }\\n\\n                    yield return element;\\n\\n                    dictionary[previous] = currentIndex;\\n                    previous = element;\\n                    currentIndex++;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "zero sequence": "\"using System.Collections;\\nusing System.Collections.Generic;\\nusing System.Numerics;\\n\\nnamespace Algorithms.Sequences\\n{\\n    /// <summary>\\n    ///     <para>\\n    ///         The zero sequence.\\n    ///     </para>\\n    ///     <para>\\n    ///         OEIS: https://oeis.org/A000004.\\n    ///     </para>\\n    /// </summary>\\n    public class ZeroSequence : ISequence\\n    {\\n        public IEnumerable<BigInteger> Sequence\\n        {\\n            get\\n            {\\n                while (true)\\n                {\\n                    yield return 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "boyer moore": "\"using System;\\n\\nnamespace Algorithms.Strings\\n{\\n    /// <summary>\\n    ///     The idea:   You compare the pattern with the text from right to left.\\n    ///     If the text symbol that is compared with the rightmost pattern symbol\\n    ///     does not occur in the pattern at all, then the pattern can be shifted\\n    ///     by m positions behind this text symbol.\\n    ///     Complexity:\\n    ///     Time:   Preprocessing: O(m²)\\n    ///     Comparison: O(mn)\\n    ///     Space:  O(m + a)\\n    ///     where   m - pattern length\\n    ///     n - text length\\n    ///     a - alphabet length.\\n    ///     Source:     https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/bmen.htm\\n    ///     https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm.\\n    /// </summary>\\n    public static class BoyerMoore\\n    {\\n        /// <summary>\\n        ///     Finds the index of the first occurrence of the pattern <c>p</c> in <c>t</c>.\\n        /// </summary>\\n        /// <param name=\\\"t\\\">Input text.</param>\\n        /// <param name=\\\"p\\\">Search pattern.</param>\\n        /// <returns>Index of the pattern in text or -1 if the pattern  was not found.</returns>\\n        public static int FindFirstOccurrence(string t, string p)\\n        {\\n            // Pattern length\\n            var m = p.Length;\\n\\n            // Text length\\n            var n = t.Length;\\n\\n            // For each symbol of the alphabet, the position of its rightmost occurrence in the pattern,\\n            // or -1 if the symbol does not occur in the pattern.\\n            int[] badChar = BadCharacterRule(p, m);\\n\\n            // Each entry goodSuffix[i] contains the shift distance of the pattern\\n            // if a mismatch at position i – 1 occurs, i.e. if the suffix of the pattern starting at position i has matched.\\n            int[] goodSuffix = GoodSuffixRule(p, m);\\n\\n            // Index in text\\n            var i = 0;\\n\\n            // Index in pattern\\n            int j;\\n\\n            while (i <= n - m)\\n            {\\n                // Starting at end of pattern\\n                j = m - 1;\\n\\n                // While matching\\n                while (j >= 0 && p[j] == t[i + j])\\n                {\\n                    j--;\\n                }\\n\\n                // Pattern found\\n                if (j < 0)\\n                {\\n                    return i;\\n                }\\n\\n                // Pattern is shifted by the maximum of the values\\n                // given by the good-suffix and the bad-character heuristics\\n                i += Math.Max(goodSuffix[j + 1], j - badChar[t[i + j]]);\\n            }\\n\\n            // Pattern not found\\n            return -1;\\n        }\\n\\n        /// <summary>\\n        ///     Finds out the position of its rightmost occurrence in the pattern for each symbol of the alphabet,\\n        ///     or -1 if the symbol does not occur in the pattern.\\n        /// </summary>\\n        /// <param name=\\\"p\\\">Search pattern.</param>\\n        /// <param name=\\\"m\\\">Length of the pattern.</param>\\n        /// <returns>Array of the named postition for each symbol of the alphabet.</returns>\\n        private static int[] BadCharacterRule(string p, int m)\\n        {\\n            // For each character (note that there are more than 256 characters)\\n            int[] badChar = new int[256];\\n            Array.Fill(badChar, -1);\\n\\n            // Iterate from left to right over the pattern\\n            for (var j = 0; j < m; j++)\\n            {\\n                badChar[p[j]] = j;\\n            }\\n\\n            return badChar;\\n        }\\n\\n        /// <summary>\\n        ///     Finds out the shift distance of the pattern if a mismatch at position i – 1 occurs\\n        ///     for each character of the pattern, i.e. if the suffix of the pattern starting at position i has matched.\\n        /// </summary>\\n        /// <param name=\\\"p\\\">Search pattern.</param>\\n        /// <param name=\\\"m\\\">Length of the pattern.</param>\\n        /// <returns>Array of the named shift distance for each character of the pattern.</returns>\\n        private static int[] GoodSuffixRule(string p, int m)\\n        {\\n            // CASE 1\\n            // The matching suffix occurs somewhere else in the pattern\\n            // --> matching suffix is a border of a suffix of the pattern\\n\\n            // f[i] contains starting position of the widest border of the suffix of the pattern beginning at position i\\n            int[] f = new int[p.Length + 1];\\n\\n            // Suffix of p[m] has no border --> f[m] = m+1\\n            f[m] = m + 1;\\n\\n            // Corresponding shift distance\\n            int[] s = new int[p.Length + 1];\\n\\n            // Start of suffix including border of the pattern\\n            // (hint: https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/kmpen.htm#section2)\\n            var i = m;\\n\\n            // Start of suffix of the pattern\\n            var j = m + 1;\\n\\n            while (i > 0)\\n            {\\n                // checking if a shorter border that is already known can be extended to the left by the same symbol\\n                while (j <= m && p[i - 1] != p[j - 1])\\n                {\\n                    if (s[j] == 0)\\n                    {\\n                        s[j] = j - i;\\n                    }\\n\\n                    j = f[j];\\n                }\\n\\n                --i;\\n                --j;\\n                f[i] = j;\\n            }\\n\\n            // CASE 2\\n            // Only a part of the matching suffix occurs at the beginning of the pattern\\n            // (filling remaining entries)\\n            j = f[0];\\n            for (i = 0; i <= m; i++)\\n            {\\n                // Starting postition of the greates border\\n                if (s[i] == 0)\\n                {\\n                    s[i] = j;\\n                }\\n\\n                // From position i = j, it switches to the next narrower border f[j]\\n                if (i == j)\\n                {\\n                    j = f[j];\\n                }\\n            }\\n\\n            return s;\\n        }\\n    }\\n}\\n\"",
    "general string algorithms": "\"using System;\\n\\nnamespace Algorithms.Strings\\n{\\n    /// <summary>\\n    ///     Implements simple algorithms on strings.\\n    /// </summary>\\n    public static class GeneralStringAlgorithms\\n    {\\n        /// <summary>\\n        ///     Finds character that creates longest consecutive substring with single character.\\n        /// </summary>\\n        /// <param name=\\\"input\\\">String to find in.</param>\\n        /// <returns>Tuple containing char and number of times it appeared in a row.</returns>\\n        public static Tuple<char, int> FindLongestConsecutiveCharacters(string input)\\n        {\\n            var maxChar = input[0];\\n\\n            var max = 1;\\n            var current = 1;\\n\\n            for (var i = 1; i < input.Length; i++)\\n            {\\n                if (input[i] == input[i - 1])\\n                {\\n                    current++;\\n                    if (current > max)\\n                    {\\n                        max = current;\\n                        maxChar = input[i];\\n                    }\\n                }\\n                else\\n                {\\n                    current = 1;\\n                }\\n            }\\n\\n            return new Tuple<char, int>(maxChar, max);\\n        }\\n    }\\n}\\n\"",
    "knuth morris pratt searcher": "\"using System.Collections.Generic;\\n\\nnamespace Algorithms.Strings\\n{\\n    public class KnuthMorrisPrattSearcher\\n    {\\n        /// <summary>\\n        ///     An implementation of Knuth–Morris–Pratt Algorithm.\\n        ///     Worst case time complexity: O(n + k)\\n        ///     where n - text length, k - pattern length.\\n        /// </summary>\\n        /// <param name=\\\"str\\\">The string to look in.</param>\\n        /// <param name=\\\"pat\\\">The pattern to look for.</param>\\n        /// <returns>\\n        ///     The zero-based positions of all occurrences of <paramref name=\\\"pat\\\" /> in <paramref name=\\\"str\\\" />.\\n        /// </returns>\\n        public IEnumerable<int> FindIndexes(string str, string pat)\\n        {\\n            var lps = FindLongestPrefixSuffixValues(pat);\\n\\n            for (int i = 0, j = 0; i < str.Length;)\\n            {\\n                if (pat[j] == str[i])\\n                {\\n                    j++;\\n                    i++;\\n                }\\n\\n                if (j == pat.Length)\\n                {\\n                    yield return i - j;\\n                    j = lps[j - 1];\\n                    continue;\\n                }\\n\\n                if (i < str.Length && pat[j] != str[i])\\n                {\\n                    if (j != 0)\\n                    {\\n                        j = lps[j - 1];\\n                    }\\n                    else\\n                    {\\n                        i += 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Return the longest prefix suffix values for pattern.\\n        /// </summary>\\n        /// <param name=\\\"pat\\\">pattern to seek.</param>\\n        /// <returns>The longest prefix suffix values for <paramref name=\\\"pat\\\" />.</returns>\\n        public int[] FindLongestPrefixSuffixValues(string pat)\\n        {\\n            var lps = new int[pat.Length];\\n            for (int i = 1, len = 0; i < pat.Length;)\\n            {\\n                if (pat[i] == pat[len])\\n                {\\n                    len++;\\n                    lps[i] = len;\\n                    i++;\\n                    continue;\\n                }\\n\\n                if (len != 0)\\n                {\\n                    len = lps[len - 1];\\n                }\\n                else\\n                {\\n                    lps[i] = 0;\\n                    i++;\\n                }\\n            }\\n\\n            return lps;\\n        }\\n    }\\n}\\n\"",
    "naive string search": "\"using System.Collections.Generic;\\n\\n// Implements the traditional naive string matching algorithm in C# for TheAlgorithms/C-Sharp.\\nnamespace Algorithms.Strings\\n{\\n    /// <summary>\\n    ///     Implements the traditional naive string matching algorithm in C#.\\n    /// </summary>\\n    public static class NaiveStringSearch\\n    {\\n        /// <summary>\\n        ///     NaiveSearch(Content, Pattern) will return an array containing each index of Content in which Pattern appears.\\n        ///     Cost:  O(n*m).\\n        /// </summary>\\n        /// <param name=\\\"content\\\">The text body across which to search for a given pattern.</param>\\n        /// <param name=\\\"pattern\\\">The pattern against which to check the given text body.</param>\\n        /// <returns>Array containing each index of Content in which Pattern appears.</returns>\\n        public static int[] NaiveSearch(string content, string pattern)\\n        {\\n            var m = pattern.Length;\\n            var n = content.Length;\\n            List<int> indices = new();\\n            for (var e = 0; e <= n - m; e++)\\n            {\\n                int j;\\n                for (j = 0; j < m; j++)\\n                {\\n                    if (content[e + j] != pattern[j])\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                if (j == m)\\n                {\\n                    indices.Add(e);\\n                }\\n            }\\n\\n            return indices.ToArray();\\n        }\\n    }\\n}\\n\"",
    "palindrome": "\"using System;\\nusing System.Text.RegularExpressions;\\n\\nnamespace Algorithms.Strings\\n{\\n    /// <summary>\\n    ///     TODO.\\n    /// </summary>\\n    public static class Palindrome\\n    {\\n        /// <summary>\\n        ///     TODO.\\n        /// </summary>\\n        /// <param name=\\\"word\\\">TODO. 2.</param>\\n        /// <returns>TODO. 3.</returns>\\n        public static bool IsStringPalindrome(string word) =>\\n            TypifyString(word).Equals(TypifyString(ReverseString(word)));\\n\\n        // Typify string to lower and remove white spaces.\\n        private static string TypifyString(string word) =>\\n            Regex.Replace(word.ToLowerInvariant(), @\\\"\\\\s+\\\", string.Empty);\\n\\n        private static string ReverseString(string s)\\n        {\\n            var arr = s.ToCharArray();\\n            Array.Reverse(arr);\\n            return new string(arr);\\n        }\\n    }\\n}\\n\"",
    "rabin karp": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace Algorithms.Strings\\n{\\n    /// <summary>\\n    ///     The idea: You calculate the hash for the pattern <c>p</c> and the hash values for all the prefixes of the text\\n    ///     <c>t</c>.\\n    ///     Now, you can compare a substring in constant time using the calculated hashes.\\n    ///     time complexity: O(p + t),\\n    ///     space complexity: O(t),\\n    ///     where   t - text length\\n    ///     p - pattern length.\\n    /// </summary>\\n    public static class RabinKarp\\n    {\\n        /// <summary>\\n        ///     Finds the index of all occurrences of the pattern <c>p</c> int <c>t</c>.\\n        /// </summary>\\n        /// <returns>List of starting indices of the pattern in the text.</returns>\\n        public static List<int> FindAllOccurrences(string text, string pattern)\\n        {\\n            // Prime number\\n            const ulong p = 65537;\\n\\n            // Modulo coefficient\\n            const ulong m = (ulong)1e9 + 7;\\n\\n            // p_pow[i] = P^i mod M\\n            ulong[] pPow = new ulong[Math.Max(pattern.Length, text.Length)];\\n            pPow[0] = 1;\\n            for (var i = 1; i < pPow.Length; i++)\\n            {\\n                pPow[i] = pPow[i - 1] * p % m;\\n            }\\n\\n            // hash_t[i] is the sum of the previous hash values of the letters (t[0], t[1], ..., t[i-1]) and the hash value of t[i] itself (mod M).\\n            // The hash value of a letter t[i] is equal to the product of t[i] and p_pow[i] (mod M).\\n            ulong[] hashT = new ulong[text.Length + 1];\\n            for (var i = 0; i < text.Length; i++)\\n            {\\n                hashT[i + 1] = (hashT[i] + text[i] * pPow[i]) % m;\\n            }\\n\\n            // hash_s is equal to sum of the hash values of the pattern (mod M).\\n            ulong hashS = 0;\\n            for (var i = 0; i < pattern.Length; i++)\\n            {\\n                hashS = (hashS + pattern[i] * pPow[i]) % m;\\n            }\\n\\n            // In the next step you iterate over the text with the pattern.\\n            List<int> occurrences = new();\\n            for (var i = 0; i + pattern.Length - 1 < text.Length; i++)\\n            {\\n                // In each step you calculate the hash value of the substring to be tested.\\n                // By storing the hash values of the letters as a prefixes you can do this in constant time.\\n                var currentHash = (hashT[i + pattern.Length] + m - hashT[i]) % m;\\n\\n                // Now you can compare the hash value of the substring with the product of the hash value of the pattern and p_pow[i].\\n                if (currentHash == hashS * pPow[i] % m)\\n                {\\n                    // If the hash values are identical, do a double-check in case a hash collision occurs.\\n                    var j = 0;\\n                    while (j < pattern.Length && text[i + j] == pattern[j])\\n                    {\\n                        ++j;\\n                    }\\n\\n                    if (j == pattern.Length)\\n                    {\\n                        // If the hash values are identical and the double-check passes, a substring was found that matches the pattern.\\n                        // In this case you add the index i to the list of occurences.\\n                        occurrences.Add(i);\\n                    }\\n                }\\n            }\\n\\n            return occurrences;\\n        }\\n    }\\n}\\n\"",
    "aa tree": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.AATree\\n{\\n    /// <summary>\\n    ///     A simple self-balancing binary search tree.\\n    /// </summary>\\n    /// <remarks>\\n    ///     AA Trees are a form of self-balancing binary search tree named after their inventor\\n    ///     Arne Anderson. AA Trees are designed to be simple to understand and implement.\\n    ///     This is accomplished by limiting how nodes can be added to the tree.\\n    ///     This simplifies rebalancing operations.\\n    ///     More information: https://en.wikipedia.org/wiki/AA_tree .\\n    /// </remarks>\\n    /// <typeparam name=\\\"TKey\\\">The type of key for the AA tree.</typeparam>\\n    public class AaTree<TKey>\\n    {\\n        /// <summary>\\n        ///     The comparer function to use to compare the keys.\\n        /// </summary>\\n        private readonly Comparer<TKey> comparer;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"AaTree{TKey}\\\" /> class.\\n        /// </summary>\\n        public AaTree()\\n            : this(Comparer<TKey>.Default)\\n        {\\n        }\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"AaTree{TKey}\\\" /> class with a custom comparer.\\n        /// </summary>\\n        /// <param name=\\\"customComparer\\\">The custom comparer to use to compare keys.</param>\\n        public AaTree(Comparer<TKey> customComparer) => comparer = customComparer;\\n\\n        /// <summary>\\n        ///     Gets the root of the tree.\\n        /// </summary>\\n        public AaTreeNode<TKey>? Root { get; private set; }\\n\\n        /// <summary>\\n        ///     Gets the number of elements in the tree.\\n        /// </summary>\\n        public int Count { get; private set; }\\n\\n        /// <summary>\\n        ///     Add a single element to the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The element to add to the tree.</param>\\n        public void Add(TKey key)\\n        {\\n            Root = Add(key, Root);\\n            Count++;\\n        }\\n\\n        /// <summary>\\n        ///     Add multiple elements to the tree.\\n        /// </summary>\\n        /// <param name=\\\"keys\\\">The elements to add to the tree.</param>\\n        public void AddRange(IEnumerable<TKey> keys)\\n        {\\n            foreach (var key in keys)\\n            {\\n                Root = Add(key, Root);\\n                Count++;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Remove a single element from the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Element to remove.</param>\\n        public void Remove(TKey key)\\n        {\\n            if (!Contains(key, Root))\\n            {\\n                throw new InvalidOperationException($\\\"{nameof(key)} is not in the tree\\\");\\n            }\\n\\n            Root = Remove(key, Root);\\n            Count--;\\n        }\\n\\n        /// <summary>\\n        ///     Checks if the specified element is in the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The element to look for.</param>\\n        /// <returns>true if the element is in the tree, false otherwise.</returns>\\n        public bool Contains(TKey key) => Contains(key, Root);\\n\\n        /// <summary>\\n        ///     Gets the largest element in the tree. (ie. the element in the right most node).\\n        /// </summary>\\n        /// <returns>The largest element in the tree according to the stored comparer.</returns>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if the tree is empty.</exception>\\n        public TKey GetMax()\\n        {\\n            if (Root is null)\\n            {\\n                throw new InvalidOperationException(\\\"Tree is empty!\\\");\\n            }\\n\\n            return GetMax(Root).Key;\\n        }\\n\\n        /// <summary>\\n        ///     Gets the smallest element in the tree. (ie. the element in the left most node).\\n        /// </summary>\\n        /// <returns>The smallest element in the tree according to the stored comparer.</returns>\\n        /// <throws>InvalidOperationException if the tree is empty.</throws>\\n        public TKey GetMin()\\n        {\\n            if (Root is null)\\n            {\\n                throw new InvalidOperationException(\\\"Tree is empty!\\\");\\n            }\\n\\n            return GetMin(Root).Key;\\n        }\\n\\n        /// <summary>\\n        ///     Gets all the elements in the tree in in-order order.\\n        /// </summary>\\n        /// <returns>Sequence of elements in in-order order.</returns>\\n        public IEnumerable<TKey> GetKeysInOrder()\\n        {\\n            var result = new List<TKey>();\\n            InOrderWalk(Root);\\n            return result;\\n\\n            void InOrderWalk(AaTreeNode<TKey>? node)\\n            {\\n                if (node is null)\\n                {\\n                    return;\\n                }\\n\\n                InOrderWalk(node.Left);\\n                result.Add(node.Key);\\n                InOrderWalk(node.Right);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Gets all the elements in the tree in pre-order order.\\n        /// </summary>\\n        /// <returns>Sequence of elements in pre-order order.</returns>\\n        public IEnumerable<TKey> GetKeysPreOrder()\\n        {\\n            var result = new List<TKey>();\\n            PreOrderWalk(Root);\\n            return result;\\n\\n            void PreOrderWalk(AaTreeNode<TKey>? node)\\n            {\\n                if (node is null)\\n                {\\n                    return;\\n                }\\n\\n                result.Add(node.Key);\\n                PreOrderWalk(node.Left);\\n                PreOrderWalk(node.Right);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Gets all the elements in the tree in post-order order.\\n        /// </summary>\\n        /// <returns>Sequence of elements in post-order order.</returns>\\n        public IEnumerable<TKey> GetKeysPostOrder()\\n        {\\n            var result = new List<TKey>();\\n            PostOrderWalk(Root);\\n            return result;\\n\\n            void PostOrderWalk(AaTreeNode<TKey>? node)\\n            {\\n                if (node is null)\\n                {\\n                    return;\\n                }\\n\\n                PostOrderWalk(node.Left);\\n                PostOrderWalk(node.Right);\\n                result.Add(node.Key);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Recursive function to add an element to the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The element to add.</param>\\n        /// <param name=\\\"node\\\">The node to search for a empty spot.</param>\\n        /// <returns>The node with the added element.</returns>\\n        /// <exception cref=\\\"ArgumentException\\\">Thrown if key is already in the tree.</exception>\\n        private AaTreeNode<TKey> Add(TKey key, AaTreeNode<TKey>? node)\\n        {\\n            if (node is null)\\n            {\\n                return new AaTreeNode<TKey>(key, 1);\\n            }\\n\\n            if (comparer.Compare(key, node.Key) < 0)\\n            {\\n                node.Left = Add(key, node.Left);\\n            }\\n            else if (comparer.Compare(key, node.Key) > 0)\\n            {\\n                node.Right = Add(key, node.Right);\\n            }\\n            else\\n            {\\n                throw new ArgumentException($\\\"Key \\\\\\\"{key}\\\\\\\" already in tree!\\\", nameof(key));\\n            }\\n\\n            return Split(Skew(node)) !;\\n        }\\n\\n        /// <summary>\\n        ///     Recursive function to remove an element from the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The element to remove.</param>\\n        /// <param name=\\\"node\\\">The node to search from.</param>\\n        /// <returns>The node with the specified element removed.</returns>\\n        private AaTreeNode<TKey>? Remove(TKey key, AaTreeNode<TKey>? node)\\n        {\\n            if (node is null)\\n            {\\n                return null;\\n            }\\n\\n            if (comparer.Compare(key, node.Key) < 0)\\n            {\\n                node.Left = Remove(key, node.Left);\\n            }\\n            else if (comparer.Compare(key, node.Key) > 0)\\n            {\\n                node.Right = Remove(key, node.Right);\\n            }\\n            else\\n            {\\n                if (node.Left is null && node.Right is null)\\n                {\\n                    return null;\\n                }\\n\\n                if (node.Left is null)\\n                {\\n                    var successor = GetMin(node.Right!);\\n                    node.Right = Remove(successor.Key, node.Right);\\n                    node.Key = successor.Key;\\n                }\\n                else\\n                {\\n                    var predecessor = GetMax(node.Left);\\n                    node.Left = Remove(predecessor.Key, node.Left);\\n                    node.Key = predecessor.Key;\\n                }\\n            }\\n\\n            node = DecreaseLevel(node);\\n            node = Skew(node);\\n            node!.Right = Skew(node.Right);\\n\\n            if (node.Right is not null)\\n            {\\n                node.Right.Right = Skew(node.Right.Right);\\n            }\\n\\n            node = Split(node);\\n            node!.Right = Split(node.Right);\\n            return node;\\n        }\\n\\n        /// <summary>\\n        ///     Recursive function to check if the element exists in the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The element to check for.</param>\\n        /// <param name=\\\"node\\\">The node to search from.</param>\\n        /// <returns>true if the element exists in the tree, false otherwise.</returns>\\n        private bool Contains(TKey key, AaTreeNode<TKey>? node) =>\\n            node is { }\\n            && comparer.Compare(key, node.Key) is { } v\\n            && v switch\\n            {\\n                { } when v > 0 => Contains(key, node.Right),\\n                { } when v < 0 => Contains(key, node.Left),\\n                _ => true,\\n            };\\n\\n        /// <summary>\\n        ///     Recursive to find the maximum/right-most element.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">The node to traverse from.</param>\\n        /// <returns>The node with the maximum/right-most element.</returns>\\n        private AaTreeNode<TKey> GetMax(AaTreeNode<TKey> node)\\n        {\\n            while (true)\\n            {\\n                if (node.Right is null)\\n                {\\n                    return node;\\n                }\\n\\n                node = node.Right;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Recursive to find the minimum/left-most element.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">The node to traverse from.</param>\\n        /// <returns>The node with the minimum/left-most element.</returns>\\n        private AaTreeNode<TKey> GetMin(AaTreeNode<TKey> node)\\n        {\\n            while (true)\\n            {\\n                if (node.Left is null)\\n                {\\n                    return node;\\n                }\\n\\n                node = node.Left;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Remove right-horizontal links and replaces them with left-horizontal links.\\n        ///     Accomplishes this by performing a right rotation.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">The node to rebalance from.</param>\\n        /// <returns>The rebalanced node.</returns>\\n        private AaTreeNode<TKey>? Skew(AaTreeNode<TKey>? node)\\n        {\\n            if (node?.Left is null || node.Left.Level != node.Level)\\n            {\\n                return node;\\n            }\\n\\n            var left = node.Left;\\n            node.Left = left.Right;\\n            left.Right = node;\\n            return left;\\n        }\\n\\n        /// <summary>\\n        ///     Reduces the number of right-horizontal links.\\n        ///     Accomplishes this by performing a left rotation, and incrementing level.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">The node to rebalance from.</param>\\n        /// <returns>The rebalanced node.</returns>\\n        private AaTreeNode<TKey>? Split(AaTreeNode<TKey>? node)\\n        {\\n            if (node?.Right?.Right is null || node.Level != node.Right.Right.Level)\\n            {\\n                return node;\\n            }\\n\\n            var right = node.Right;\\n            node.Right = right.Left;\\n            right.Left = node;\\n            right.Level++;\\n            return right;\\n        }\\n\\n        /// <summary>\\n        ///     Decreases the level of node if necessary.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">The node to decrease level from.</param>\\n        /// <returns>The node with modified level.</returns>\\n        private AaTreeNode<TKey> DecreaseLevel(AaTreeNode<TKey> node)\\n        {\\n            var newLevel = Math.Min(GetLevel(node.Left), GetLevel(node.Right)) + 1;\\n            if (newLevel >= node.Level)\\n            {\\n                return node;\\n            }\\n\\n            node.Level = newLevel;\\n            if (node.Right is { } && newLevel < node.Right.Level)\\n            {\\n                node.Right.Level = newLevel;\\n            }\\n\\n            return node;\\n\\n            static int GetLevel(AaTreeNode<TKey>? x) => x?.Level ?? 0;\\n        }\\n    }\\n}\\n\"",
    "aa tree node": "\"namespace DataStructures.AATree\\n{\\n    /// <summary>\\n    ///     Generic node class for AATree.\\n    /// </summary>\\n    /// <typeparam name=\\\"TKey\\\">Type of key for node.</typeparam>\\n    public class AaTreeNode<TKey>\\n    {\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"AaTreeNode{TKey}\\\" /> class.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The initial key of this node.</param>\\n        /// <param name=\\\"level\\\">The level of this node. See <see cref=\\\"AaTree{TKey}\\\" /> for more details.</param>\\n        public AaTreeNode(TKey key, int level)\\n        {\\n            Key = key;\\n            Level = level;\\n        }\\n\\n        /// <summary>\\n        ///     Gets or Sets key for this node.\\n        /// </summary>\\n        public TKey Key { get; set; }\\n\\n        /// <summary>\\n        ///     Gets or Sets level for this node.\\n        /// </summary>\\n        public int Level { get; set; }\\n\\n        /// <summary>\\n        ///     Gets or sets the left subtree of this node.\\n        /// </summary>\\n        public AaTreeNode<TKey>? Left { get; set; }\\n\\n        /// <summary>\\n        ///     Gets or sets the right subtree of this node.\\n        /// </summary>\\n        public AaTreeNode<TKey>? Right { get; set; }\\n    }\\n}\\n\"",
    "avl tree": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.AVLTree\\n{\\n    /// <summary>\\n    ///     A simple self-balancing binary tree.\\n    /// </summary>\\n    /// <remarks>\\n    ///     An AVL tree is a self-balancing binary search tree (BST) named after\\n    ///     its inventors: Adelson, Velsky, and Landis. It is the first self-\\n    ///     balancing BST invented. The primary property of an AVL tree is that\\n    ///     the height of both child subtrees for any node only differ by one.\\n    ///     Due to the balanced nature of the tree, its time complexities for\\n    ///     insertion, deletion, and search all have a worst-case time complexity\\n    ///     of O(log n). Which is an improvement over the worst-case O(n) for a\\n    ///     regular BST.\\n    ///     See https://en.wikipedia.org/wiki/AVL_tree for more information.\\n    ///     Visualizer: https://visualgo.net/en/bst.\\n    /// </remarks>\\n    /// <typeparam name=\\\"TKey\\\">Type of key for the tree.</typeparam>\\n    public class AvlTree<TKey>\\n    {\\n        /// <summary>\\n        ///     Gets the number of nodes in the tree.\\n        /// </summary>\\n        public int Count { get; private set; }\\n\\n        /// <summary>\\n        ///     Comparer to use when comparing key values.\\n        /// </summary>\\n        private readonly Comparer<TKey> comparer;\\n\\n        /// <summary>\\n        ///     Reference to the root node.\\n        /// </summary>\\n        private AvlTreeNode<TKey>? root;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"AvlTree{TKey}\\\"/> class.\\n        /// </summary>\\n        public AvlTree()\\n        {\\n            comparer = Comparer<TKey>.Default;\\n        }\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"AvlTree{TKey}\\\"/> class\\n        ///     using the specified comparer.\\n        /// </summary>\\n        /// <param name=\\\"customComparer\\\">Comparer to use when comparing keys.</param>\\n        public AvlTree(Comparer<TKey> customComparer)\\n        {\\n            comparer = customComparer;\\n        }\\n\\n        /// <summary>\\n        ///     Add a single node to the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value to add.</param>\\n        public void Add(TKey key)\\n        {\\n            if (root is null)\\n            {\\n                root = new AvlTreeNode<TKey>(key);\\n            }\\n            else\\n            {\\n                root = Add(root, key);\\n            }\\n\\n            Count++;\\n        }\\n\\n        /// <summary>\\n        ///     Add multiple nodes to the tree.\\n        /// </summary>\\n        /// <param name=\\\"keys\\\">Key values to add.</param>\\n        public void AddRange(IEnumerable<TKey> keys)\\n        {\\n            foreach(var key in keys)\\n            {\\n                Add(key);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Remove a node from the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value to remove.</param>\\n        public void Remove(TKey key)\\n        {\\n            if (root is null)\\n            {\\n                throw new InvalidOperationException(\\\"Tree is empty!\\\");\\n            }\\n            else if (!Contains(key))\\n            {\\n                throw new KeyNotFoundException($\\\"Key {key} is not in the tree\\\");\\n            }\\n            else\\n            {\\n                root = Remove(root, key);\\n                Count--;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Check if given node is in the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value to search for.</param>\\n        /// <returns>Whether or not the node is in the tree.</returns>\\n        public bool Contains(TKey key)\\n        {\\n            var node = root;\\n            while (node is not null)\\n            {\\n                var compareResult = comparer.Compare(key, node.Key);\\n                if (compareResult < 0)\\n                {\\n                    node = node.Left;\\n                }\\n                else if (compareResult > 0)\\n                {\\n                    node = node.Right;\\n                }\\n                else\\n                {\\n                    return true;\\n                }\\n            }\\n\\n            return false;\\n        }\\n\\n        /// <summary>\\n        ///     Get the minimum value in the tree.\\n        /// </summary>\\n        /// <returns>Minimum value in tree.</returns>\\n        public TKey GetMin()\\n        {\\n            if(root is null)\\n            {\\n                throw new InvalidOperationException(\\\"Tree is empty!\\\");\\n            }\\n\\n            return GetMin(root).Key;\\n        }\\n\\n        /// <summary>\\n        ///     Get the maximum value in the tree.\\n        /// </summary>\\n        /// <returns>Maximum value in tree.</returns>\\n        public TKey GetMax()\\n        {\\n            if(root is null)\\n            {\\n                throw new InvalidOperationException(\\\"Tree is empty!\\\");\\n            }\\n\\n            return GetMax(root).Key;\\n        }\\n\\n        /// <summary>\\n        ///     Get keys in order from smallest to largest as defined by the comparer.\\n        /// </summary>\\n        /// <returns>Keys in tree in order from smallest to largest.</returns>\\n        public IEnumerable<TKey> GetKeysInOrder()\\n        {\\n            List<TKey> result = new();\\n            InOrderWalk(root);\\n            return result;\\n\\n            void InOrderWalk(AvlTreeNode<TKey>? node)\\n            {\\n                if (node is null)\\n                {\\n                    return;\\n                }\\n\\n                InOrderWalk(node.Left);\\n                result.Add(node.Key);\\n                InOrderWalk(node.Right);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Get keys in the pre-order order.\\n        /// </summary>\\n        /// <returns>Keys in pre-order order.</returns>\\n        public IEnumerable<TKey> GetKeysPreOrder()\\n        {\\n            var result = new List<TKey>();\\n            PreOrderWalk(root);\\n            return result;\\n\\n            void PreOrderWalk(AvlTreeNode<TKey>? node)\\n            {\\n                if (node is null)\\n                {\\n                    return;\\n                }\\n\\n                result.Add(node.Key);\\n                PreOrderWalk(node.Left);\\n                PreOrderWalk(node.Right);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Get keys in the post-order order.\\n        /// </summary>\\n        /// <returns>Keys in the post-order order.</returns>\\n        public IEnumerable<TKey> GetKeysPostOrder()\\n        {\\n            var result = new List<TKey>();\\n            PostOrderWalk(root);\\n            return result;\\n\\n            void PostOrderWalk(AvlTreeNode<TKey>? node)\\n            {\\n                if (node is null)\\n                {\\n                    return;\\n                }\\n\\n                PostOrderWalk(node.Left);\\n                PostOrderWalk(node.Right);\\n                result.Add(node.Key);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Recursively function to add a node to the tree.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to check for null leaf.</param>\\n        /// <param name=\\\"key\\\">Key value to add.</param>\\n        /// <returns>New node with key inserted.</returns>\\n        private AvlTreeNode<TKey> Add(AvlTreeNode<TKey> node, TKey key)\\n        {\\n            // Regular binary search tree insertion\\n            int compareResult = comparer.Compare(key, node.Key);\\n            if (compareResult < 0)\\n            {\\n                if (node.Left is null)\\n                {\\n                    var newNode = new AvlTreeNode<TKey>(key);\\n                    node.Left = newNode;\\n                }\\n                else\\n                {\\n                    node.Left = Add(node.Left, key);\\n                }\\n            }\\n            else if (compareResult > 0)\\n            {\\n                if (node.Right is null)\\n                {\\n                    var newNode = new AvlTreeNode<TKey>(key);\\n                    node.Right = newNode;\\n                }\\n                else\\n                {\\n                    node.Right = Add(node.Right, key);\\n                }\\n            }\\n            else\\n            {\\n                throw new ArgumentException($\\\"Key \\\\\\\"{key}\\\\\\\" already exists in tree!\\\");\\n            }\\n\\n            // Check all of the new node's ancestors for inbalance and perform\\n            // necessary rotations\\n            node.UpdateBalanceFactor();\\n\\n            return Rebalance(node);\\n        }\\n\\n        /// <summary>\\n        ///     Recursive function to remove node from tree.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to check for key.</param>\\n        /// <param name=\\\"key\\\">Key value to remove.</param>\\n        /// <returns>New node with key removed.</returns>\\n        private AvlTreeNode<TKey>? Remove(AvlTreeNode<TKey> node, TKey key)\\n        {\\n            // Normal binary search tree removal\\n            var compareResult = comparer.Compare(key, node.Key);\\n            if (compareResult < 0)\\n            {\\n                node.Left = Remove(node.Left!, key);\\n            }\\n            else if (compareResult > 0)\\n            {\\n                node.Right = Remove(node.Right!, key);\\n            }\\n            else\\n            {\\n                if (node.Left is null && node.Right is null)\\n                {\\n                    return null;\\n                }\\n                else if (node.Left is null)\\n                {\\n                    var successor = GetMin(node.Right!);\\n                    node.Right = Remove(node.Right!, successor.Key);\\n                    node.Key = successor.Key;\\n                }\\n                else\\n                {\\n                    var predecessor = GetMax(node.Left!);\\n                    node.Left = Remove(node.Left!, predecessor.Key);\\n                    node.Key = predecessor.Key;\\n                }\\n            }\\n\\n            // Check all of the removed node's ancestors for rebalance and\\n            // perform necessary rotations.\\n            node.UpdateBalanceFactor();\\n\\n            return Rebalance(node);\\n        }\\n\\n        /// <summary>\\n        ///     Helper function to rebalance the tree so that all nodes have a\\n        ///     balance factor in the range [-1, 1].\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to rebalance.</param>\\n        /// <returns>New node that has been rebalanced.</returns>\\n        private AvlTreeNode<TKey> Rebalance(AvlTreeNode<TKey> node)\\n        {\\n            if (node.BalanceFactor > 1)\\n            {\\n                if (node.Right!.BalanceFactor == -1)\\n                {\\n                    node.Right = RotateRight(node.Right);\\n                }\\n\\n                return RotateLeft(node);\\n            }\\n            else if (node.BalanceFactor < -1)\\n            {\\n                if (node.Left!.BalanceFactor == 1)\\n                {\\n                    node.Left = RotateLeft(node.Left);\\n                }\\n\\n                return RotateRight(node);\\n            }\\n            else\\n            {\\n                return node;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Perform a left (counter-clockwise) rotation.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to rotate about.</param>\\n        /// <returns>New node with rotation applied.</returns>\\n        private AvlTreeNode<TKey> RotateLeft(AvlTreeNode<TKey> node)\\n        {\\n            var temp1 = node;\\n            var temp2 = node!.Right!.Left;\\n            node = node.Right;\\n            node.Left = temp1;\\n            node.Left.Right = temp2;\\n\\n            node.Left.UpdateBalanceFactor();\\n            node.UpdateBalanceFactor();\\n\\n            return node;\\n        }\\n\\n        /// <summary>\\n        ///     Perform a right (clockwise) rotation.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to rotate about.</param>\\n        /// <returns>New node with rotation applied.</returns>\\n        private AvlTreeNode<TKey> RotateRight(AvlTreeNode<TKey> node)\\n        {\\n            var temp1 = node;\\n            var temp2 = node!.Left!.Right;\\n            node = node.Left;\\n            node.Right = temp1;\\n            node.Right.Left = temp2;\\n\\n            node.Right.UpdateBalanceFactor();\\n            node.UpdateBalanceFactor();\\n\\n            return node;\\n        }\\n\\n        /// <summary>\\n        ///     Helper function to get node instance with minimum key value\\n        ///     in the specified subtree.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node specifying root of subtree.</param>\\n        /// <returns>Minimum value in node's subtree.</returns>\\n        private AvlTreeNode<TKey> GetMin(AvlTreeNode<TKey> node)\\n        {\\n            while (node.Left is not null)\\n            {\\n                node = node.Left;\\n            }\\n\\n            return node;\\n        }\\n\\n        /// <summary>\\n        ///     Helper function to get node instance with maximum key value\\n        ///     in the specified subtree.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node specifyng root of subtree.</param>\\n        /// <returns>Maximum value in node's subtree.</returns>\\n        private AvlTreeNode<TKey> GetMax(AvlTreeNode<TKey> node)\\n        {\\n            while (node.Right is not null)\\n            {\\n                node = node.Right;\\n            }\\n\\n            return node;\\n        }\\n    }\\n}\\n\"",
    "avl tree node": "\"using System;\\n\\nnamespace DataStructures.AVLTree\\n{\\n    /// <summary>\\n    ///     Generic class to represent nodes in an <see cref=\\\"AvlTree{TKey}\\\"/> instance.\\n    /// </summary>\\n    /// <typeparam name=\\\"TKey\\\">The type of key for the node.</typeparam>\\n    public class AvlTreeNode<TKey>\\n    {\\n        /// <summary>\\n        ///     Gets or sets key value of node.\\n        /// </summary>\\n        public TKey Key { get; set; }\\n\\n        /// <summary>\\n        ///     Gets the height of the node.\\n        /// </summary>\\n        public int Height { get; private set; }\\n\\n        /// <summary>\\n        ///     Gets the balance factor of the node.\\n        /// </summary>\\n        public int BalanceFactor { get; private set; }\\n\\n        /// <summary>\\n        ///     Gets or sets the left child of the node.\\n        /// </summary>\\n        public AvlTreeNode<TKey>? Left { get; set; }\\n\\n        /// <summary>\\n        ///     Gets or sets the right child of the node.\\n        /// </summary>\\n        public AvlTreeNode<TKey>? Right { get; set; }\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"AvlTreeNode{TKey}\\\"/> class.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value for node.</param>\\n        public AvlTreeNode(TKey key)\\n        {\\n            Key = key;\\n        }\\n\\n        /// <summary>\\n        ///     Update the node's height and balance factor.\\n        /// </summary>\\n        public void UpdateBalanceFactor()\\n        {\\n            if(Left is null && Right is null)\\n            {\\n                Height = 0;\\n                BalanceFactor = 0;\\n            }\\n            else if(Left is null)\\n            {\\n                Height = Right!.Height + 1;\\n                BalanceFactor = Height;\\n            }\\n            else if(Right is null)\\n            {\\n                Height = Left!.Height + 1;\\n                BalanceFactor = -Height;\\n            }\\n            else\\n            {\\n                Height = Math.Max(Left.Height, Right.Height) + 1;\\n                BalanceFactor = Right.Height - Left.Height;\\n            }\\n        }\\n    }\\n}\\n\"",
    "binary search tree": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.BinarySearchTree\\n{\\n    /// <summary>\\n    ///     An ordered tree with efficient insertion, removal, and lookup.\\n    /// </summary>\\n    /// <remarks>\\n    ///     A Binary Search Tree (BST) is a tree that satisfies the following properties:\\n    ///     <list type=\\\"bullet\\\">\\n    ///         <item>All nodes in the tree contain two children, usually called Left and Right.</item>\\n    ///         <item>All nodes in the Left subtree contain keys that are less than the node's key.</item>\\n    ///         <item>All nodes in the Right subtree contain keys that are greater than the node's key.</item>\\n    ///     </list>\\n    ///     A BST will have an average complexity of O(log n) for insertion, removal, and lookup operations.\\n    /// </remarks>\\n    /// <typeparam name=\\\"TKey\\\">Type of key for the BST. Keys must implement IComparable.</typeparam>\\n    public class BinarySearchTree<TKey>\\n    {\\n        /// <summary>\\n        ///     Comparer to use when comparing node elements/keys.\\n        /// </summary>\\n        private readonly Comparer<TKey> comparer;\\n\\n        /// <summary>\\n        ///     The root of the BST.\\n        /// </summary>\\n        private BinarySearchTreeNode<TKey>? root;\\n\\n        public BinarySearchTree()\\n        {\\n            root = null;\\n            Count = 0;\\n            comparer = Comparer<TKey>.Default;\\n        }\\n\\n        public BinarySearchTree(Comparer<TKey> customComparer)\\n        {\\n            root = null;\\n            Count = 0;\\n            comparer = customComparer;\\n        }\\n\\n        /// <summary>\\n        ///     Gets the number nodes currently in the BST.\\n        /// </summary>\\n        public int Count { get; private set; }\\n\\n        /// <summary>\\n        ///     Insert a key into the BST.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The key to insert.</param>\\n        /// <exception cref=\\\"ArgumentException\\\">\\n        ///     Thrown if key is already in BST.\\n        /// </exception>\\n        public void Add(TKey key)\\n        {\\n            if (root is null)\\n            {\\n                root = new BinarySearchTreeNode<TKey>(key);\\n            }\\n            else\\n            {\\n                Add(root, key);\\n            }\\n\\n            Count++;\\n        }\\n\\n        /// <summary>\\n        ///     Insert multiple keys into the BST.\\n        ///     Keys are inserted in the order they appear in the sequence.\\n        /// </summary>\\n        /// <param name=\\\"keys\\\">Sequence of keys to insert.</param>\\n        public void AddRange(IEnumerable<TKey> keys)\\n        {\\n            foreach (var key in keys)\\n            {\\n                Add(key);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Find a node with the specified key.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The key to search for.</param>\\n        /// <returns>The node with the specified key if it exists, otherwise a default value is returned.</returns>\\n        public BinarySearchTreeNode<TKey>? Search(TKey key) => Search(root, key);\\n\\n        /// <summary>\\n        ///     Checks if the specified key is in the BST.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The key to search for.</param>\\n        /// <returns>true if the key is in the BST, false otherwise.</returns>\\n        public bool Contains(TKey key) => Search(root, key) is not null;\\n\\n        /// <summary>\\n        ///     Removes a node with a key that matches <paramref name=\\\"key\\\" />.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The key to search for.</param>\\n        /// <returns>true if the removal was successful, false otherwise.</returns>\\n        public bool Remove(TKey key)\\n        {\\n            if (root is null)\\n            {\\n                return false;\\n            }\\n\\n            var result = Remove(root, root, key);\\n            if (result)\\n            {\\n                Count--;\\n            }\\n\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Returns a node with the smallest key.\\n        /// </summary>\\n        /// <returns>The node if possible, a default value otherwise.</returns>\\n        public BinarySearchTreeNode<TKey>? GetMin()\\n        {\\n            if (root is null)\\n            {\\n                return default;\\n            }\\n\\n            return GetMin(root);\\n        }\\n\\n        /// <summary>\\n        ///     Returns a node with the largest key.\\n        /// </summary>\\n        /// <returns>The node if possible, a default value otherwise.</returns>\\n        public BinarySearchTreeNode<TKey>? GetMax()\\n        {\\n            if (root is null)\\n            {\\n                return default;\\n            }\\n\\n            return GetMax(root);\\n        }\\n\\n        /// <summary>\\n        ///     Returns all the keys in the BST, sorted In-Order.\\n        /// </summary>\\n        /// <returns>A list of keys in the BST.</returns>\\n        public ICollection<TKey> GetKeysInOrder() => GetKeysInOrder(root);\\n\\n        /// <summary>\\n        ///     Returns all the keys in the BST, sorted Pre-Order.\\n        /// </summary>\\n        /// <returns>A list of keys in the BST.</returns>\\n        public ICollection<TKey> GetKeysPreOrder() => GetKeysPreOrder(root);\\n\\n        /// <summary>\\n        ///     Returns all the keys in the BST, sorted Post-Order.\\n        /// </summary>\\n        /// <returns>A list of keys in the BST.</returns>\\n        public ICollection<TKey> GetKeysPostOrder() => GetKeysPostOrder(root);\\n\\n        /// <summary>\\n        ///     Recursive method to add a key to the BST.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to search from.</param>\\n        /// <param name=\\\"key\\\">Key to add.</param>\\n        /// <exception cref=\\\"ArgumentException\\\">\\n        ///     Thrown if key is already in the BST.\\n        /// </exception>\\n        private void Add(BinarySearchTreeNode<TKey> node, TKey key)\\n        {\\n            var compareResult = comparer.Compare(node.Key, key);\\n            if (compareResult > 0)\\n            {\\n                if (node.Left is not null)\\n                {\\n                    Add(node.Left, key);\\n                }\\n                else\\n                {\\n                    var newNode = new BinarySearchTreeNode<TKey>(key);\\n                    node.Left = newNode;\\n                }\\n            }\\n            else if (compareResult < 0)\\n            {\\n                if (node.Right is not null)\\n                {\\n                    Add(node.Right, key);\\n                }\\n                else\\n                {\\n                    var newNode = new BinarySearchTreeNode<TKey>(key);\\n                    node.Right = newNode;\\n                }\\n            }\\n\\n            // Key is already in tree.\\n            else\\n            {\\n                throw new ArgumentException($\\\"Key \\\\\\\"{key}\\\\\\\" already exists in tree!\\\");\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Removes a node with the specified key from the BST.\\n        /// </summary>\\n        /// <param name=\\\"parent\\\">The parent node of <paramref name=\\\"node\\\" />.</param>\\n        /// <param name=\\\"node\\\">The node to check/search from.</param>\\n        /// <param name=\\\"key\\\">The key to remove.</param>\\n        /// <returns>true if the operation was successful, false otherwise.</returns>\\n        /// <remarks>\\n        ///     Removing a node from the BST can be split into three cases:\\n        ///     <br></br>\\n        ///     0. The node to be removed has no children. In this case, the node can just be removed from the tree.\\n        ///     <br></br>\\n        ///     1. The node to be removed has one child. In this case, the node's child is moved to the node's parent,\\n        ///     then the node is removed from the tree.\\n        ///     <br></br>\\n        ///     2. The node to be removed has two children. In this case, we must find a suitable node among the children\\n        ///     subtrees to replace the node. This can be done with either the in-order predecessor or the in-order successor.\\n        ///     The in-order predecessor is the largest node in Left subtree, or the largest node that is still smaller then the\\n        ///     current node. The in-order successor is the smallest node in the Right subtree, or the smallest node that is\\n        ///     still larger than the current node. Either way, once this suitable node is found, remove it from the tree (it\\n        ///     should be either a case 1 or 2 node) and replace the node to be removed with this suitable node.\\n        ///     <br></br>\\n        ///     More information: https://en.wikipedia.org/wiki/Binary_search_tree#Deletion .\\n        /// </remarks>\\n        private bool Remove(BinarySearchTreeNode<TKey>? parent, BinarySearchTreeNode<TKey>? node, TKey key)\\n        {\\n            if (node is null || parent is null)\\n            {\\n                return false;\\n            }\\n\\n            var compareResult = comparer.Compare(node.Key, key);\\n\\n            if (compareResult > 0)\\n            {\\n                return Remove(node, node.Left, key);\\n            }\\n\\n            if (compareResult < 0)\\n            {\\n                return Remove(node, node.Right, key);\\n            }\\n\\n            BinarySearchTreeNode<TKey>? replacementNode;\\n\\n            // Case 0: Node has no children.\\n            // Case 1: Node has one child.\\n            if (node.Left is null || node.Right is null)\\n            {\\n                replacementNode = node.Left ?? node.Right;\\n            }\\n\\n            // Case 2: Node has two children. (This implementation uses the in-order predecessor to replace node.)\\n            else\\n            {\\n                var predecessorNode = GetMax(node.Left);\\n                Remove(root, root, predecessorNode.Key);\\n                replacementNode = new BinarySearchTreeNode<TKey>(predecessorNode.Key)\\n                {\\n                    Left = node.Left,\\n                    Right = node.Right,\\n                };\\n            }\\n\\n            // Replace the relevant node with a replacement found in the previous stages.\\n            // Special case for replacing the root node.\\n            if (node == root)\\n            {\\n                root = replacementNode;\\n            }\\n            else if (parent.Left == node)\\n            {\\n                parent.Left = replacementNode;\\n            }\\n            else\\n            {\\n                parent.Right = replacementNode;\\n            }\\n\\n            return true;\\n        }\\n\\n        /// <summary>\\n        ///     Recursive method to get node with largest key.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to search from.</param>\\n        /// <returns>Node with largest value.</returns>\\n        private BinarySearchTreeNode<TKey> GetMax(BinarySearchTreeNode<TKey> node)\\n        {\\n            if (node.Right is null)\\n            {\\n                return node;\\n            }\\n\\n            return GetMax(node.Right);\\n        }\\n\\n        /// <summary>\\n        ///     Recursive method to get node with smallest key.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to search from.</param>\\n        /// <returns>Node with smallest value.</returns>\\n        private BinarySearchTreeNode<TKey> GetMin(BinarySearchTreeNode<TKey> node)\\n        {\\n            if (node.Left is null)\\n            {\\n                return node;\\n            }\\n\\n            return GetMin(node.Left);\\n        }\\n\\n        /// <summary>\\n        ///     Recursive method to get a list with the keys sorted in in-order order.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to traverse from.</param>\\n        /// <returns>List of keys in in-order order.</returns>\\n        private IList<TKey> GetKeysInOrder(BinarySearchTreeNode<TKey>? node)\\n        {\\n            if (node is null)\\n            {\\n                return new List<TKey>();\\n            }\\n\\n            var result = new List<TKey>();\\n            result.AddRange(GetKeysInOrder(node.Left));\\n            result.Add(node.Key);\\n            result.AddRange(GetKeysInOrder(node.Right));\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Recursive method to get a list with the keys sorted in pre-order order.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to traverse from.</param>\\n        /// <returns>List of keys in pre-order order.</returns>\\n        private IList<TKey> GetKeysPreOrder(BinarySearchTreeNode<TKey>? node)\\n        {\\n            if (node is null)\\n            {\\n                return new List<TKey>();\\n            }\\n\\n            var result = new List<TKey>();\\n            result.Add(node.Key);\\n            result.AddRange(GetKeysPreOrder(node.Left));\\n            result.AddRange(GetKeysPreOrder(node.Right));\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Recursive method to get a list with the keys sorted in post-order order.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to traverse from.</param>\\n        /// <returns>List of keys in post-order order.</returns>\\n        private IList<TKey> GetKeysPostOrder(BinarySearchTreeNode<TKey>? node)\\n        {\\n            if (node is null)\\n            {\\n                return new List<TKey>();\\n            }\\n\\n            var result = new List<TKey>();\\n            result.AddRange(GetKeysPostOrder(node.Left));\\n            result.AddRange(GetKeysPostOrder(node.Right));\\n            result.Add(node.Key);\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Recursive method to find a node with a matching key.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to search from.</param>\\n        /// <param name=\\\"key\\\">Key to find.</param>\\n        /// <returns>The node with the specified if it exists, a default value otherwise.</returns>\\n        private BinarySearchTreeNode<TKey>? Search(BinarySearchTreeNode<TKey>? node, TKey key)\\n        {\\n            if (node is null)\\n            {\\n                return default;\\n            }\\n\\n            var compareResult = comparer.Compare(node.Key, key);\\n            if (compareResult > 0)\\n            {\\n                return Search(node.Left, key);\\n            }\\n\\n            if (compareResult < 0)\\n            {\\n                return Search(node.Right, key);\\n            }\\n\\n            return node;\\n        }\\n    }\\n}\\n\"",
    "binary search tree node": "\"namespace DataStructures.BinarySearchTree\\n{\\n    /// <summary>\\n    ///     Generic node class for BinarySearchTree.\\n    ///     Keys for each node are immutable.\\n    /// </summary>\\n    /// <typeparam name=\\\"TKey\\\">Type of key for the node. Keys must implement IComparable.</typeparam>\\n    public class BinarySearchTreeNode<TKey>\\n    {\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"BinarySearchTreeNode{TKey}\\\" /> class.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">The key of this node.</param>\\n        public BinarySearchTreeNode(TKey key) => Key = key;\\n\\n        /// <summary>\\n        ///     Gets the key for this node.\\n        /// </summary>\\n        public TKey Key { get; }\\n\\n        /// <summary>\\n        ///     Gets or sets the reference to a child node that precedes/comes before this node.\\n        /// </summary>\\n        public BinarySearchTreeNode<TKey>? Left { get; set; }\\n\\n        /// <summary>\\n        ///     Gets or sets the reference to a child node that follows/comes after this node.\\n        /// </summary>\\n        public BinarySearchTreeNode<TKey>? Right { get; set; }\\n    }\\n}\\n\"",
    "disjoint set": "\"using System.Collections;\\n\\nnamespace DataStructures.DisjointSet\\n{\\n    /// <summary>\\n    /// Implementation of Disjoint Set with Union By Rank and Path Compression heuristics.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\"> generic type for implementation.</typeparam>\\n    public class DisjointSet<T>\\n    {\\n        /// <summary>\\n        /// make a new set and return its representative.\\n        /// </summary>\\n        /// <param name=\\\"x\\\">element to add in to the DS.</param>\\n        /// <returns>representative of x.</returns>\\n        public Node<T> MakeSet(T x) => new(x);\\n\\n        /// <summary>\\n        /// find the representative of a certain node.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">node to find representative.</param>\\n        /// <returns>representative of x.</returns>\\n        public Node<T> FindSet(Node<T> node)\\n        {\\n            if (node != node.Parent)\\n            {\\n                node.Parent = FindSet(node.Parent);\\n            }\\n\\n            return node.Parent;\\n        }\\n\\n        /// <summary>\\n        /// merge two sets.\\n        /// </summary>\\n        /// <param name=\\\"x\\\">first set member.</param>\\n        /// <param name=\\\"y\\\">second set member.</param>\\n        public void UnionSet(Node<T> x, Node<T> y)\\n        {\\n            Node<T> nx = FindSet(x);\\n            Node<T> ny = FindSet(y);\\n            if (nx == ny)\\n            {\\n                return;\\n            }\\n\\n            if (nx.Rank > ny.Rank)\\n            {\\n                ny.Parent = nx;\\n            }\\n            else if (ny.Rank > nx.Rank)\\n            {\\n                nx.Parent = ny;\\n            }\\n            else\\n            {\\n                nx.Parent = ny;\\n                ny.Rank++;\\n            }\\n        }\\n    }\\n}\\n\"",
    "node": "\"using System;\\n\\nnamespace DataStructures.ScapegoatTree\\n{\\n    /// <summary>\\n    /// Scapegoat tree node class.\\n    /// </summary>\\n    /// <typeparam name=\\\"TKey\\\">Scapegoat tree node key type.</typeparam>\\n    public class Node<TKey> where TKey : IComparable\\n    {\\n        private Node<TKey>? right;\\n        private Node<TKey>? left;\\n\\n        public TKey Key { get; }\\n\\n        public Node<TKey>? Right\\n        {\\n            get => right;\\n            set\\n            {\\n                if (value != null && !value.IsGreaterThanOrSameAs(Key))\\n                {\\n                    throw new ArgumentException(\\\"The value's key is smaller than or equal to node's right child's key.\\\", nameof(value));\\n                }\\n\\n                right = value;\\n            }\\n        }\\n\\n        public Node<TKey>? Left\\n        {\\n            get => left;\\n            set\\n            {\\n                if (value != null && value.IsGreaterThanOrSameAs(Key))\\n                {\\n                    throw new ArgumentException(\\\"The value's key is greater than or equal to node's left child's key.\\\", nameof(value));\\n                }\\n\\n                left = value;\\n            }\\n        }\\n\\n        public Node(TKey key) => Key = key;\\n\\n        public Node(TKey key, Node<TKey>? right, Node<TKey>? left)\\n            : this(key)\\n        {\\n            Right = right;\\n            Left = left;\\n        }\\n\\n        /// <summary>\\n        /// Returns number of elements in the tree.\\n        /// </summary>\\n        /// <returns>Number of elements in the tree.</returns>\\n        public int GetSize() => (Left?.GetSize() ?? 0) + 1 + (Right?.GetSize() ?? 0);\\n\\n        /// <summary>\\n        /// Gets alpha height of the current node.\\n        /// </summary>\\n        /// <param name=\\\"alpha\\\">Alpha value.</param>\\n        /// <returns>Alpha height value.</returns>\\n        public double GetAlphaHeight(double alpha) => Math.Floor(Math.Log(GetSize(), 1.0 / alpha));\\n\\n        public Node<TKey> GetSmallestKeyNode() => Left?.GetSmallestKeyNode() ?? this;\\n\\n        public Node<TKey> GetLargestKeyNode() => Right?.GetLargestKeyNode() ?? this;\\n\\n        /// <summary>\\n        /// Checks if the current node is alpha weight balanced.\\n        /// </summary>\\n        /// <param name=\\\"a\\\">Alpha value.</param>\\n        /// <returns>True - if node is alpha weight balanced. If not - false.</returns>\\n        public bool IsAlphaWeightBalanced(double a)\\n        {\\n            var isLeftBalanced = (Left?.GetSize() ?? 0) <= a * GetSize();\\n            var isRightBalanced = (Right?.GetSize() ?? 0) <= a * GetSize();\\n\\n            return isLeftBalanced && isRightBalanced;\\n        }\\n\\n        private bool IsGreaterThanOrSameAs(TKey key)\\n        {\\n            return Key.CompareTo(key) >= 0;\\n        }\\n    }\\n}\\n\"",
    "binary indexed tree": "\"using System.Collections.Generic;\\nusing System.Linq;\\n\\nnamespace DataStructures.Fenwick\\n{\\n    /// <summary>\\n    /// Represent classical realization of Fenwiсk tree or Binary Indexed tree.\\n    ///\\n    /// BITree[0..n] --> Array that represents Binary Indexed Tree.\\n    /// arr[0..n-1] --> Input array for which prefix sum is evaluated.\\n    /// </summary>\\n    public class BinaryIndexedTree\\n    {\\n        private readonly int[] fenwickTree;\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"BinaryIndexedTree\\\"/> class.\\n        /// Create Binary indexed tree from the given array.\\n        /// </summary>\\n        /// <param name=\\\"array\\\">Initial array.</param>\\n        public BinaryIndexedTree(int[] array)\\n        {\\n            fenwickTree = new int[array.Length + 1];\\n\\n            for (var i = 0; i < array.Length; i++)\\n            {\\n                UpdateTree(i, array[i]);\\n            }\\n        }\\n\\n        /// <summary>\\n        /// This method assumes that the array is preprocessed and\\n        /// partial sums of array elements are stored in BITree[].\\n        /// </summary>\\n        /// <param name=\\\"index\\\">The position to sum from.</param>\\n        /// <returns>Returns sum of arr[0..index].</returns>\\n        public int GetSum(int index)\\n        {\\n            var sum = 0;\\n            var startFrom = index + 1;\\n\\n            while (startFrom > 0)\\n            {\\n                sum += fenwickTree[startFrom];\\n                startFrom -= startFrom & (-startFrom);\\n            }\\n\\n            return sum;\\n        }\\n\\n        /// <summary>\\n        /// Updates a node in Binary Index Tree at given index.\\n        /// The given value 'val' is added to BITree[i] and all of its ancestors in tree.\\n        /// </summary>\\n        /// <param name=\\\"index\\\">Given index.</param>\\n        /// <param name=\\\"val\\\">Value to be update on.</param>\\n        public void UpdateTree(int index, int val)\\n        {\\n            var startFrom = index + 1;\\n\\n            while (startFrom <= fenwickTree.Length)\\n            {\\n                fenwickTree[startFrom] += val;\\n                startFrom += startFrom & (-startFrom);\\n            }\\n        }\\n    }\\n}\\n\"",
    "directed weighted graph": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.Graph\\n{\\n    /// <summary>\\n    ///     Implementation of the directed weighted graph via adjacency matrix.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Generic Type.</typeparam>\\n    public class DirectedWeightedGraph<T> : IDirectedWeightedGraph<T>\\n    {\\n        /// <summary>\\n        ///     Capacity of the graph, indicates the maximum amount of vertices.\\n        /// </summary>\\n        private readonly int capacity;\\n\\n        /// <summary>\\n        ///     Adjacency matrix which reflects the edges between vertices and their weight.\\n        ///     Zero value indicates no edge between two vertices.\\n        /// </summary>\\n        private readonly double[,] adjacencyMatrix;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"DirectedWeightedGraph{T}\\\"/> class.\\n        /// </summary>\\n        /// <param name=\\\"capacity\\\">Capacity of the graph, indicates the maximum amount of vertices.</param>\\n        public DirectedWeightedGraph(int capacity)\\n        {\\n            ThrowIfNegativeCapacity(capacity);\\n\\n            this.capacity = capacity;\\n            Vertices = new Vertex<T>[capacity];\\n            adjacencyMatrix = new double[capacity, capacity];\\n            Count = 0;\\n        }\\n\\n        /// <summary>\\n        ///     Gets list of vertices of the graph.\\n        /// </summary>\\n        public Vertex<T>?[] Vertices { get; private set; }\\n\\n        /// <summary>\\n        ///     Gets current amount of vertices in the graph.\\n        /// </summary>\\n        public int Count { get; private set; }\\n\\n        /// <summary>\\n        ///     Adds new vertex to the graph.\\n        /// </summary>\\n        /// <param name=\\\"data\\\">Data of the vertex.</param>\\n        /// <returns>Reference to created vertex.</returns>\\n        public Vertex<T> AddVertex(T data)\\n        {\\n            ThrowIfOverflow();\\n            var vertex = new Vertex<T>(data, Count, this);\\n            Vertices[Count] = vertex;\\n            Count++;\\n            return vertex;\\n        }\\n\\n        /// <summary>\\n        ///     Creates an edge between two vertices of the graph.\\n        /// </summary>\\n        /// <param name=\\\"startVertex\\\">Vertex, edge starts at.</param>\\n        /// <param name=\\\"endVertex\\\">Vertex, edge ends at.</param>\\n        /// <param name=\\\"weight\\\">Double weight of an edge.</param>\\n        public void AddEdge(Vertex<T> startVertex, Vertex<T> endVertex, double weight)\\n        {\\n            ThrowIfVertexNotInGraph(startVertex);\\n            ThrowIfVertexNotInGraph(endVertex);\\n\\n            ThrowIfWeightZero(weight);\\n\\n            var currentEdgeWeight = adjacencyMatrix[startVertex.Index, endVertex.Index];\\n\\n            ThrowIfEdgeExists(currentEdgeWeight);\\n\\n            adjacencyMatrix[startVertex.Index, endVertex.Index] = weight;\\n        }\\n\\n        /// <summary>\\n        ///     Removes vertex from the graph.\\n        /// </summary>\\n        /// <param name=\\\"vertex\\\">Vertex to be removed.</param>\\n        public void RemoveVertex(Vertex<T> vertex)\\n        {\\n            ThrowIfVertexNotInGraph(vertex);\\n\\n            Vertices[vertex.Index] = null;\\n            vertex.SetGraphNull();\\n\\n            for (var i = 0; i < Count; i++)\\n            {\\n                adjacencyMatrix[i, vertex.Index] = 0;\\n                adjacencyMatrix[vertex.Index, i] = 0;\\n            }\\n\\n            Count--;\\n        }\\n\\n        /// <summary>\\n        ///     Removes edge between two vertices.\\n        /// </summary>\\n        /// <param name=\\\"startVertex\\\">Vertex, edge starts at.</param>\\n        /// <param name=\\\"endVertex\\\">Vertex, edge ends at.</param>\\n        public void RemoveEdge(Vertex<T> startVertex, Vertex<T> endVertex)\\n        {\\n            ThrowIfVertexNotInGraph(startVertex);\\n            ThrowIfVertexNotInGraph(endVertex);\\n            adjacencyMatrix[startVertex.Index, endVertex.Index] = 0;\\n        }\\n\\n        /// <summary>\\n        ///     Gets a neighbors of particular vertex.\\n        /// </summary>\\n        /// <param name=\\\"vertex\\\">Vertex, method gets list of neighbors for.</param>\\n        /// <returns>Collection of the neighbors of particular vertex.</returns>\\n        public IEnumerable<Vertex<T>?> GetNeighbors(Vertex<T> vertex)\\n        {\\n            ThrowIfVertexNotInGraph(vertex);\\n\\n            for (var i = 0; i < Count; i++)\\n            {\\n                if (adjacencyMatrix[vertex.Index, i] != 0)\\n                {\\n                    yield return Vertices[i];\\n                }\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Returns true, if there is an edge between two vertices.\\n        /// </summary>\\n        /// <param name=\\\"startVertex\\\">Vertex, edge starts at.</param>\\n        /// <param name=\\\"endVertex\\\">Vertex, edge ends at.</param>\\n        /// <returns>True if edge exists, otherwise false.</returns>\\n        public bool AreAdjacent(Vertex<T> startVertex, Vertex<T> endVertex)\\n        {\\n            ThrowIfVertexNotInGraph(startVertex);\\n            ThrowIfVertexNotInGraph(endVertex);\\n\\n            return adjacencyMatrix[startVertex.Index, endVertex.Index] != 0;\\n        }\\n\\n        /// <summary>\\n        /// Return the distance between two vertices in the graph.\\n        /// </summary>\\n        /// <param name=\\\"startVertex\\\">first vertex in edge.</param>\\n        /// <param name=\\\"endVertex\\\">secnod vertex in edge.</param>\\n        /// <returns>distance between the two.</returns>\\n        public double AdjacentDistance(Vertex<T> startVertex, Vertex<T> endVertex)\\n        {\\n            if (AreAdjacent(startVertex, endVertex))\\n            {\\n                return adjacencyMatrix[startVertex.Index, endVertex.Index];\\n            }\\n\\n            return 0;\\n        }\\n\\n        private static void ThrowIfNegativeCapacity(int capacity)\\n        {\\n            if (capacity < 0)\\n            {\\n                throw new InvalidOperationException(\\\"Graph capacity should always be a non-negative integer.\\\");\\n            }\\n        }\\n\\n        private static void ThrowIfWeightZero(double weight)\\n        {\\n            if (weight.Equals(0.0d))\\n            {\\n                throw new InvalidOperationException(\\\"Edge weight cannot be zero.\\\");\\n            }\\n        }\\n\\n        private static void ThrowIfEdgeExists(double currentEdgeWeight)\\n        {\\n            if (!currentEdgeWeight.Equals(0.0d))\\n            {\\n                throw new InvalidOperationException($\\\"Vertex already exists: {currentEdgeWeight}\\\");\\n            }\\n        }\\n\\n        private void ThrowIfOverflow()\\n        {\\n            if (Count == capacity)\\n            {\\n                throw new InvalidOperationException(\\\"Graph overflow.\\\");\\n            }\\n        }\\n\\n        private void ThrowIfVertexNotInGraph(Vertex<T> vertex)\\n        {\\n            if (vertex.Graph != this)\\n            {\\n                throw new InvalidOperationException($\\\"Vertex does not belong to graph: {vertex}.\\\");\\n            }\\n        }\\n    }\\n}\\n\"",
    "i directed weighted graph": "\"using System.Collections.Generic;\\n\\nnamespace DataStructures.Graph\\n{\\n    public interface IDirectedWeightedGraph<T>\\n    {\\n        int Count { get; }\\n\\n        Vertex<T>?[] Vertices { get; }\\n\\n        void AddEdge(Vertex<T> startVertex, Vertex<T> endVertex, double weight);\\n\\n        Vertex<T> AddVertex(T data);\\n\\n        bool AreAdjacent(Vertex<T> startVertex, Vertex<T> endVertex);\\n\\n        double AdjacentDistance(Vertex<T> startVertex, Vertex<T> endVertex);\\n\\n        IEnumerable<Vertex<T>?> GetNeighbors(Vertex<T> vertex);\\n\\n        void RemoveEdge(Vertex<T> startVertex, Vertex<T> endVertex);\\n\\n        void RemoveVertex(Vertex<T> vertex);\\n    }\\n}\\n\"",
    "vertex": "\"namespace DataStructures.Graph\\n{\\n    /// <summary>\\n    ///     Implementation of graph vertex.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Generic Type.</typeparam>\\n    public class Vertex<T>\\n    {\\n        /// <summary>\\n        ///     Gets vertex data.\\n        /// </summary>\\n        public T Data { get; }\\n\\n        /// <summary>\\n        ///     Gets an index of the vertex in graph adjacency matrix.\\n        /// </summary>\\n        public int Index { get; }\\n\\n        /// <summary>\\n        ///     Gets reference to the graph this vertex belongs to.\\n        /// </summary>\\n        public DirectedWeightedGraph<T>? Graph { get; private set; }\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"Vertex{T}\\\"/> class.\\n        /// </summary>\\n        /// <param name=\\\"data\\\">Vertex data. Generic type.</param>\\n        /// <param name=\\\"index\\\">Index of the vertex in graph adjacency matrix.</param>\\n        /// <param name=\\\"graph\\\">Graph this vertex belongs to.</param>\\n        public Vertex(T data, int index, DirectedWeightedGraph<T>? graph)\\n        {\\n            Data = data;\\n            Index = index;\\n            Graph = graph;\\n        }\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"Vertex{T}\\\"/> class.\\n        /// </summary>\\n        /// <param name=\\\"data\\\">Vertex data. Generic type.</param>\\n        /// <param name=\\\"index\\\">Index of the vertex in graph adjacency matrix.</param>\\n        public Vertex(T data, int index)\\n        {\\n            Data = data;\\n            Index = index;\\n        }\\n\\n        /// <summary>\\n        ///     Sets graph reference to the null. This method called when vertex removed from the graph.\\n        /// </summary>\\n        public void SetGraphNull() => Graph = null;\\n\\n        /// <summary>\\n        ///     Override of base ToString method. Prints vertex data and index in graph adjacency matrix.\\n        /// </summary>\\n        /// <returns>String which contains vertex data and index in graph adjacency matrix..</returns>\\n        public override string ToString() => $\\\"Vertex Data: {Data}, Index: {Index}\\\";\\n    }\\n}\\n\"",
    "binary heap": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.Heap\\n{\\n    /// <summary>\\n    ///     A generic implementation of a binary heap.\\n    /// </summary>\\n    /// <remarks>\\n    ///     A binary heap is a complete binary tree that satisfies the heap property;\\n    ///     that is every node in the tree compares greater/less than or equal to its left and right\\n    ///     child nodes. Note that this is different from a binary search tree, where every node\\n    ///     must be the largest/smallest node of all of its children.\\n    ///     Although binary heaps are not very efficient, they are (probably) the simpliest heaps\\n    ///     to understand and implement.\\n    ///     More information: https://en.wikipedia.org/wiki/Binary_heap .\\n    /// </remarks>\\n    /// <typeparam name=\\\"T\\\">Type of elements in binary heap.</typeparam>\\n    public class BinaryHeap<T>\\n    {\\n        /// <summary>\\n        ///     Comparer to use when comparing elements.\\n        /// </summary>\\n        private readonly Comparer<T> comparer;\\n\\n        /// <summary>\\n        ///     List to hold the elements of the heap.\\n        /// </summary>\\n        private readonly List<T> data;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"BinaryHeap{T}\\\" /> class.\\n        /// </summary>\\n        public BinaryHeap()\\n        {\\n            data = new List<T>();\\n            comparer = Comparer<T>.Default;\\n        }\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"BinaryHeap{T}\\\" /> class with a custom comparision function.\\n        /// </summary>\\n        /// <param name=\\\"customComparer\\\">The custom comparing function to use to compare elements.</param>\\n        public BinaryHeap(Comparer<T> customComparer)\\n        {\\n            data = new List<T>();\\n            comparer = customComparer;\\n        }\\n\\n        /// <summary>\\n        ///     Gets the number of elements in the heap.\\n        /// </summary>\\n        public int Count => data.Count;\\n\\n        /// <summary>\\n        ///     Add an element to the binary heap.\\n        /// </summary>\\n        /// <remarks>\\n        ///     Adding to the heap is done by append the element to the end of the backing list,\\n        ///     and pushing the added element up until the heap property is restored.\\n        /// </remarks>\\n        /// <param name=\\\"element\\\">The element to add to the heap.</param>\\n        /// <exception cref=\\\"ArgumentException\\\">Thrown if element is already in heap.</exception>\\n        public void Push(T element)\\n        {\\n            data.Add(element);\\n            HeapifyUp(data.Count - 1);\\n        }\\n\\n        /// <summary>\\n        ///     Remove the top/root of the binary heap (ie: the largest/smallest element).\\n        /// </summary>\\n        /// <remarks>\\n        ///     Removing from the heap is done by swapping the top/root with the last element in\\n        ///     the backing list, removing the last element, and pushing the new root down\\n        ///     until the heap property is restored.\\n        /// </remarks>\\n        /// <returns>The top/root of the heap.</returns>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if heap is empty.</exception>\\n        public T Pop()\\n        {\\n            if (Count == 0)\\n            {\\n                throw new InvalidOperationException(\\\"Heap is empty!\\\");\\n            }\\n\\n            var elem = data[0];\\n            data[0] = data[^1];\\n            data.RemoveAt(data.Count - 1);\\n            HeapifyDown(0);\\n\\n            return elem;\\n        }\\n\\n        /// <summary>\\n        ///     Return the top/root of the heap without removing it.\\n        /// </summary>\\n        /// <returns>The top/root of the heap.</returns>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if heap is empty.</exception>\\n        public T Peek()\\n        {\\n            if (Count == 0)\\n            {\\n                throw new InvalidOperationException(\\\"Heap is empty!\\\");\\n            }\\n\\n            return data[0];\\n        }\\n\\n        /// <summary>\\n        ///     Returns element if it compares larger to the top/root of the heap, else\\n        ///     inserts element into the heap and returns the top/root of the heap.\\n        /// </summary>\\n        /// <param name=\\\"element\\\">The element to check/insert.</param>\\n        /// <returns>element if element compares larger than top/root of heap, top/root of heap otherwise.</returns>\\n        public T PushPop(T element)\\n        {\\n            if (Count == 0)\\n            {\\n                return element;\\n            }\\n\\n            if (comparer.Compare(element, data[0]) < 0)\\n            {\\n                var tmp = data[0];\\n                data[0] = element;\\n                HeapifyDown(0);\\n                return tmp;\\n            }\\n\\n            return element;\\n        }\\n\\n        /// <summary>\\n        ///     Check if element is in the heap.\\n        /// </summary>\\n        /// <param name=\\\"element\\\">The element to check for.</param>\\n        /// <returns>true if element is in the heap, false otherwise.</returns>\\n        public bool Contains(T element) => data.Contains(element);\\n\\n        /// <summary>\\n        ///     Remove an element from the heap.\\n        /// </summary>\\n        /// <remarks>\\n        ///     In removing an element from anywhere in the heap, we only need to push down or up\\n        ///     the replacement value depending on how the removed value compares to its\\n        ///     replacement value.\\n        /// </remarks>\\n        /// <param name=\\\"element\\\">The element to remove from the heap.</param>\\n        /// <exception cref=\\\"ArgumentException\\\">Thrown if element is not in heap.</exception>\\n        public void Remove(T element)\\n        {\\n            var idx = data.IndexOf(element);\\n\\n            if (idx == -1)\\n            {\\n                throw new ArgumentException($\\\"{element} not in heap!\\\");\\n            }\\n\\n            Swap(idx, data.Count - 1);\\n            var tmp = data[^1];\\n            data.RemoveAt(data.Count - 1);\\n\\n            if (idx < data.Count)\\n            {\\n                if (comparer.Compare(tmp, data[idx]) > 0)\\n                {\\n                    HeapifyDown(idx);\\n                }\\n                else\\n                {\\n                    HeapifyUp(idx);\\n                }\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Swap the elements in the heap array at the given indices.\\n        /// </summary>\\n        /// <param name=\\\"idx1\\\">First index.</param>\\n        /// <param name=\\\"idx2\\\">Second index.</param>\\n        private void Swap(int idx1, int idx2)\\n        {\\n            var tmp = data[idx1];\\n            data[idx1] = data[idx2];\\n            data[idx2] = tmp;\\n        }\\n\\n        /// <summary>\\n        ///     Recursive function to restore heap properties.\\n        /// </summary>\\n        /// <remarks>\\n        ///     Restores heap property by swapping the element at <paramref name=\\\"elemIdx\\\" />\\n        ///     with its parent if the element compares greater than its parent.\\n        /// </remarks>\\n        /// <param name=\\\"elemIdx\\\">The element to check with its parent.</param>\\n        private void HeapifyUp(int elemIdx)\\n        {\\n            var parent = (elemIdx - 1) / 2;\\n\\n            if (parent >= 0 && comparer.Compare(data[elemIdx], data[parent]) > 0)\\n            {\\n                Swap(elemIdx, parent);\\n                HeapifyUp(parent);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Recursive function to restore heap properties.\\n        /// </summary>\\n        /// <remarks>\\n        ///     Restores heap property by swapping the element at <paramref name=\\\"elemIdx\\\" />\\n        ///     with the larger of its children.\\n        /// </remarks>\\n        /// <param name=\\\"elemIdx\\\">The element to check with its children.</param>\\n        private void HeapifyDown(int elemIdx)\\n        {\\n            var left = 2 * elemIdx + 1;\\n            var right = 2 * elemIdx + 2;\\n\\n            var leftLargerThanElem = left < Count && comparer.Compare(data[elemIdx], data[left]) < 0;\\n            var rightLargerThanElem = right < Count && comparer.Compare(data[elemIdx], data[right]) < 0;\\n            var leftLargerThanRight = left < Count && right < Count && comparer.Compare(data[left], data[right]) > 0;\\n\\n            if (leftLargerThanElem && leftLargerThanRight)\\n            {\\n                Swap(elemIdx, left);\\n                HeapifyDown(left);\\n            }\\n            else if (rightLargerThanElem && !leftLargerThanRight)\\n            {\\n                Swap(elemIdx, right);\\n                HeapifyDown(right);\\n            }\\n        }\\n    }\\n}\\n\"",
    "min max heap": "\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\nnamespace DataStructures.Heap\\n{\\n    /// <summary>\\n    ///     This class implements min-max heap.\\n    ///     It provides functionality of both min-heap and max-heap with the same time complexity.\\n    ///     Therefore it provides constant time retrieval and logarithmic time removal\\n    ///     of both the minimum and maximum elements in it.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Generic type.</typeparam>\\n    public class MinMaxHeap<T>\\n    {\\n        private readonly List<T> heap;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"MinMaxHeap{T}\\\" /> class that contains\\n        ///     elements copied from a specified enumerable collection and that uses a specified comparer.\\n        /// </summary>\\n        /// <param name=\\\"collection\\\">The enumerable collection to be copied.</param>\\n        /// <param name=\\\"comparer\\\">The default comparer to use for comparing objects.</param>\\n        public MinMaxHeap(IEnumerable<T>? collection = null, IComparer<T>? comparer = null)\\n        {\\n            Comparer = comparer ?? Comparer<T>.Default;\\n            collection ??= Enumerable.Empty<T>();\\n\\n            heap = collection.ToList();\\n            for (var i = Count / 2 - 1; i >= 0; --i)\\n            {\\n                PushDown(i);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Gets the  <see cref=\\\"IComparer{T}\\\" />. object that is used to order the values in the <see cref=\\\"MinMaxHeap{T}\\\" />.\\n        /// </summary>\\n        public IComparer<T> Comparer { get; }\\n\\n        /// <summary>\\n        ///     Gets the number of elements in the <see cref=\\\"MinMaxHeap{T}\\\" />.\\n        /// </summary>\\n        public int Count => heap.Count;\\n\\n        /// <summary>\\n        ///     Adds an element to the heap.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">The element to add to the heap.</param>\\n        public void Add(T item)\\n        {\\n            heap.Add(item);\\n            PushUp(Count - 1);\\n        }\\n\\n        /// <summary>\\n        ///     Removes the maximum node from the heap and returns its value.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if heap is empty.</exception>\\n        /// <returns>Value of the removed maximum node.</returns>\\n        public T ExtractMax()\\n        {\\n            if (Count == 0)\\n            {\\n                throw new InvalidOperationException(\\\"Heap is empty\\\");\\n            }\\n\\n            var max = GetMax();\\n            RemoveNode(GetMaxNodeIndex());\\n            return max;\\n        }\\n\\n        /// <summary>\\n        ///     Removes the minimum node from the heap and returns its value.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if heap is empty.</exception>\\n        /// <returns>Value of the removed minimum node.</returns>\\n        public T ExtractMin()\\n        {\\n            if (Count == 0)\\n            {\\n                throw new InvalidOperationException(\\\"Heap is empty\\\");\\n            }\\n\\n            var min = GetMin();\\n            RemoveNode(0);\\n            return min;\\n        }\\n\\n        /// <summary>\\n        ///     Gets the maximum value in the heap, as defined by the comparer.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if heap is empty.</exception>\\n        /// <returns>The maximum value in the heap.</returns>\\n        public T GetMax()\\n        {\\n            if (Count == 0)\\n            {\\n                throw new InvalidOperationException(\\\"Heap is empty\\\");\\n            }\\n\\n            return heap[GetMaxNodeIndex()];\\n        }\\n\\n        /// <summary>\\n        ///     Gets the minimum value in the heap, as defined by the comparer.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if heap is empty.</exception>\\n        /// <returns>The minimum value in the heap.</returns>\\n        public T GetMin()\\n        {\\n            if (Count == 0)\\n            {\\n                throw new InvalidOperationException(\\\"Heap is empty\\\");\\n            }\\n\\n            return heap[0];\\n        }\\n\\n        /// <summary>\\n        ///     Finds maximum value among children and grandchildren of the specified node.\\n        /// </summary>\\n        /// <param name=\\\"index\\\">Index of the node in the Heap array.</param>\\n        /// <returns>Index of the maximum descendant.</returns>\\n        private int IndexOfMaxChildOrGrandchild(int index)\\n        {\\n            var descendants = new[]\\n            {\\n                2 * index + 1,\\n                2 * index + 2,\\n                4 * index + 3,\\n                4 * index + 4,\\n                4 * index + 5,\\n                4 * index + 6,\\n            };\\n            var resIndex = descendants[0];\\n            foreach (var descendant in descendants)\\n            {\\n                if (descendant >= Count)\\n                {\\n                    break;\\n                }\\n\\n                if (Comparer.Compare(heap[descendant], heap[resIndex]) > 0)\\n                {\\n                    resIndex = descendant;\\n                }\\n            }\\n\\n            return resIndex;\\n        }\\n\\n        /// <summary>\\n        ///     Finds minumum value among children and grandchildren of the specified node.\\n        /// </summary>\\n        /// <param name=\\\"index\\\">Index of the node in the Heap array.</param>\\n        /// <returns>Index of the minimum descendant.</returns>\\n        private int IndexOfMinChildOrGrandchild(int index)\\n        {\\n            var descendants = new[] { 2 * index + 1, 2 * index + 2, 4 * index + 3, 4 * index + 4, 4 * index + 5, 4 * index + 6 };\\n            var resIndex = descendants[0];\\n            foreach (var descendant in descendants)\\n            {\\n                if (descendant >= Count)\\n                {\\n                    break;\\n                }\\n\\n                if (Comparer.Compare(heap[descendant], heap[resIndex]) < 0)\\n                {\\n                    resIndex = descendant;\\n                }\\n            }\\n\\n            return resIndex;\\n        }\\n\\n        private int GetMaxNodeIndex()\\n        {\\n            return Count switch\\n            {\\n                0 => throw new InvalidOperationException(\\\"Heap is empty\\\"),\\n                1 => 0,\\n                2 => 1,\\n                _ => Comparer.Compare(heap[1], heap[2]) > 0 ? 1 : 2,\\n            };\\n        }\\n\\n        private bool HasChild(int index) => index * 2 + 1 < Count;\\n\\n        private bool IsGrandchild(int node, int grandchild) => grandchild > 2 && Grandparent(grandchild) == node;\\n\\n        /// <summary>\\n        ///     Checks if node at index belongs to Min or Max level of the heap.\\n        ///     Root node belongs to Min level, its children - Max level,\\n        ///     its grandchildren - Min level, and so on.\\n        /// </summary>\\n        /// <param name=\\\"index\\\">Index to check.</param>\\n        /// <returns>true if index is at Min level; false if it is at Max Level.</returns>\\n        private bool IsMinLevelIndex(int index)\\n        {\\n            // For all Min levels, value (index + 1) has the leftmost bit set to '1' at even position.\\n            const uint minLevelsBits = 0x55555555;\\n            const uint maxLevelsBits = 0xAAAAAAAA;\\n            return ((index + 1) & minLevelsBits) > ((index + 1) & maxLevelsBits);\\n        }\\n\\n        private int Parent(int index) => (index - 1) / 2;\\n\\n        private int Grandparent(int index) => ((index - 1) / 2 - 1) / 2;\\n\\n        /// <summary>\\n        ///     Assuming that children sub-trees are valid heaps, pushes node to lower levels\\n        ///     to make heap valid.\\n        /// </summary>\\n        /// <param name=\\\"index\\\">Node index.</param>\\n        private void PushDown(int index)\\n        {\\n            if (IsMinLevelIndex(index))\\n            {\\n                PushDownMin(index);\\n            }\\n            else\\n            {\\n                PushDownMax(index);\\n            }\\n        }\\n\\n        private void PushDownMax(int index)\\n        {\\n            if (!HasChild(index))\\n            {\\n                return;\\n            }\\n\\n            var maxIndex = IndexOfMaxChildOrGrandchild(index);\\n\\n            // If smaller element are put at min level (as result of swaping), it doesn't affect sub-tree validity.\\n            // If smaller element are put at max level, PushDownMax() should be called for that node.\\n            if (IsGrandchild(index, maxIndex))\\n            {\\n                if (Comparer.Compare(heap[maxIndex], heap[index]) > 0)\\n                {\\n                    SwapNodes(maxIndex, index);\\n                    if (Comparer.Compare(heap[maxIndex], heap[Parent(maxIndex)]) < 0)\\n                    {\\n                        SwapNodes(maxIndex, Parent(maxIndex));\\n                    }\\n\\n                    PushDownMax(maxIndex);\\n                }\\n            }\\n            else\\n            {\\n                if (Comparer.Compare(heap[maxIndex], heap[index]) > 0)\\n                {\\n                    SwapNodes(maxIndex, index);\\n                }\\n            }\\n        }\\n\\n        private void PushDownMin(int index)\\n        {\\n            if (!HasChild(index))\\n            {\\n                return;\\n            }\\n\\n            var minIndex = IndexOfMinChildOrGrandchild(index);\\n\\n            // If bigger element are put at max level (as result of swaping), it doesn't affect sub-tree validity.\\n            // If bigger element are put at min level, PushDownMin() should be called for that node.\\n            if (IsGrandchild(index, minIndex))\\n            {\\n                if (Comparer.Compare(heap[minIndex], heap[index]) < 0)\\n                {\\n                    SwapNodes(minIndex, index);\\n                    if (Comparer.Compare(heap[minIndex], heap[Parent(minIndex)]) > 0)\\n                    {\\n                        SwapNodes(minIndex, Parent(minIndex));\\n                    }\\n\\n                    PushDownMin(minIndex);\\n                }\\n            }\\n            else\\n            {\\n                if (Comparer.Compare(heap[minIndex], heap[index]) < 0)\\n                {\\n                    SwapNodes(minIndex, index);\\n                }\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Having a new node in the heap, swaps this node with its ancestors to make heap valid.\\n        ///     For node at min level. If new node is less than its parent, then it is surely less then\\n        ///     all other nodes on max levels on path to the root of the heap. So node are pushed up, by\\n        ///     swaping with its grandparent, until they are ordered correctly.\\n        ///     For node at max level algorithm is analogical.\\n        /// </summary>\\n        /// <param name=\\\"index\\\">Index of the new node.</param>\\n        private void PushUp(int index)\\n        {\\n            if (index == 0)\\n            {\\n                return;\\n            }\\n\\n            var parent = Parent(index);\\n\\n            if (IsMinLevelIndex(index))\\n            {\\n                if (Comparer.Compare(heap[index], heap[parent]) > 0)\\n                {\\n                    SwapNodes(index, parent);\\n                    PushUpMax(parent);\\n                }\\n                else\\n                {\\n                    PushUpMin(index);\\n                }\\n            }\\n            else\\n            {\\n                if (Comparer.Compare(heap[index], heap[parent]) < 0)\\n                {\\n                    SwapNodes(index, parent);\\n                    PushUpMin(parent);\\n                }\\n                else\\n                {\\n                    PushUpMax(index);\\n                }\\n            }\\n        }\\n\\n        private void PushUpMax(int index)\\n        {\\n            if (index > 2)\\n            {\\n                var grandparent = Grandparent(index);\\n                if (Comparer.Compare(heap[index], heap[grandparent]) > 0)\\n                {\\n                    SwapNodes(index, grandparent);\\n                    PushUpMax(grandparent);\\n                }\\n            }\\n        }\\n\\n        private void PushUpMin(int index)\\n        {\\n            if (index > 2)\\n            {\\n                var grandparent = Grandparent(index);\\n                if (Comparer.Compare(heap[index], heap[grandparent]) < 0)\\n                {\\n                    SwapNodes(index, grandparent);\\n                    PushUpMin(grandparent);\\n                }\\n            }\\n        }\\n\\n        private void RemoveNode(int index)\\n        {\\n            SwapNodes(index, Count - 1);\\n            heap.RemoveAt(Count - 1);\\n            if (Count != 0)\\n            {\\n                PushDown(index);\\n            }\\n        }\\n\\n        private void SwapNodes(int i, int j)\\n        {\\n            var temp = heap[i];\\n            heap[i] = heap[j];\\n            heap[j] = temp;\\n        }\\n    }\\n}\\n\"",
    "bloom filter": "\"using System;\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Text.Json;\\n\\nnamespace DataStructures.Probabilistic\\n{\\n    public class BloomFilter<T> where T : notnull\\n    {\\n        private const uint FnvPrime = 16777619;\\n        private const uint FnvOffsetBasis = 2166136261;\\n        private readonly byte[] filter;\\n        private readonly int numHashes;\\n        private readonly int sizeBits;\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"BloomFilter{T}\\\"/> class. This constructor will create a Bloom Filter\\n        /// of an optimal size with the optimal number of hashes to minimize the error rate.\\n        /// </summary>\\n        /// <param name=\\\"expectedNumElements\\\">Expected number of unique elements that could be added to the filter.</param>\\n        public BloomFilter(int expectedNumElements)\\n        {\\n            numHashes = (int)Math.Ceiling(.693 * 8 * expectedNumElements / expectedNumElements); // compute optimal number of hashes\\n            filter = new byte[expectedNumElements]; // set up filter with 8 times as many bits as elements\\n            sizeBits = expectedNumElements * 8; // number of bit slots in the filter\\n        }\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"BloomFilter{T}\\\"/> class.\\n        /// This constructor let's you decide how large you want the filter to be as well as allowing you to specify\\n        /// how many hashes it will use. Only use if you don't care to optimize false positivity.\\n        /// </summary>\\n        /// <param name=\\\"sizeBits\\\">size in bits you want the filter to be.</param>\\n        /// <param name=\\\"numHashes\\\">number of hash functions to be used.</param>\\n        public BloomFilter(int sizeBits, int numHashes)\\n        {\\n            filter = new byte[sizeBits / 8 + 1];\\n            this.numHashes = numHashes;\\n            this.sizeBits = sizeBits;\\n        }\\n\\n        /// <summary>\\n        /// Inserts an item into the bloom filter.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">The item being inserted into the Bloom Filter.</param>\\n        public void Insert(T item)\\n        {\\n            foreach (var slot in GetSlots(item))\\n            {\\n                filter[slot / 8] |= (byte)(1 << (slot % 8)); // set the filter at the decided slot to 1.\\n            }\\n        }\\n\\n        /// <summary>\\n        /// Searches the Bloom Filter to determine if the item exists in the Bloom Filter.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">The item being searched for in the Bloom Filter.</param>\\n        /// <returns>true if the item has been added to the Bloom Filter, false otherwise.</returns>\\n        public bool Search(T item)\\n        {\\n            foreach (var slot in GetSlots(item))\\n            {\\n                var @byte = filter[slot / 8]; // Extract the byte in the filter.\\n                var mask = 1 << (slot % 8); // Build the mask for the slot number.\\n                if ((@byte & mask) != mask)\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            return true;\\n        }\\n\\n        /// <summary>\\n        /// Yields the appropriate slots for the given item.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">The item to determine the slots for.</param>\\n        /// <returns>The slots of the filter to flip or check.</returns>\\n        private IEnumerable<int> GetSlots(T item)\\n        {\\n            var hash = item.GetHashCode();\\n            for (var i = 0; i < numHashes; i++)\\n            {\\n                yield return Math.Abs((i + 1) * hash) % sizeBits;\\n            }\\n        }\\n    }\\n}\\n\"",
    "count min sketch": "\"using System;\\n\\nnamespace DataStructures.Probabilistic\\n{\\n    public class CountMinSketch<T> where T : notnull\\n    {\\n        private readonly int[][] sketch;\\n        private readonly int numHashes;\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"CountMinSketch{T}\\\"/> class based off dimensions\\n        /// passed by the user.\\n        /// </summary>\\n        /// <param name=\\\"width\\\">The width of the sketch.</param>\\n        /// <param name=\\\"numHashes\\\">The number of hashes to use in the sketch.</param>\\n        public CountMinSketch(int width, int numHashes)\\n        {\\n            sketch = new int[numHashes][];\\n            for (var i = 0; i < numHashes; i++)\\n            {\\n                sketch[i] = new int[width];\\n            }\\n\\n            this.numHashes = numHashes;\\n        }\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"CountMinSketch{T}\\\"/> class based off the optimizing error rate\\n        /// and error probability formula width = e/errorRate numHashes = ln(1.0/errorProp).\\n        /// </summary>\\n        /// <param name=\\\"errorRate\\\">The amount of acceptable over counting for the sketch.</param>\\n        /// <param name=\\\"errorProb\\\">The probability that an item will be over counted.</param>\\n        public CountMinSketch(double errorRate, double errorProb)\\n        {\\n            var width = (int)Math.Ceiling(Math.E / errorRate);\\n            numHashes = (int)Math.Ceiling(Math.Log(1.0 / errorProb));\\n            sketch = new int[numHashes][];\\n            for (var i = 0; i < numHashes; i++)\\n            {\\n                sketch[i] = new int[width];\\n            }\\n        }\\n\\n        /// <summary>\\n        /// Inserts the provided item into the sketch.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">Item to insert.</param>\\n        public void Insert(T item)\\n        {\\n            var initialHash = item.GetHashCode();\\n            for (int i = 0; i < numHashes; i++)\\n            {\\n                var slot = GetSlot(i, initialHash);\\n                sketch[i][slot]++;\\n            }\\n        }\\n\\n        /// <summary>\\n        /// Queries the count of the given item that have been inserted into the sketch.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">item to insert into the sketch.</param>\\n        /// <returns>the number of times the provided item has been inserted into the sketch.</returns>\\n        public int Query(T item)\\n        {\\n            var initialHash = item.GetHashCode();\\n            var min = int.MaxValue;\\n            for (int i = 0; i < numHashes; i++)\\n            {\\n                var slot = GetSlot(i, initialHash);\\n                min = Math.Min(sketch[i][slot], min);\\n            }\\n\\n            return min;\\n        }\\n\\n        private int GetSlot(int i, int initialHash) => Math.Abs((i + 1) * initialHash) % sketch[0].Length;\\n    }\\n}\\n\"",
    "hyper log log": "\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\nnamespace DataStructures.Probabilistic\\n{\\n    public class HyperLogLog<T> where T : notnull\\n    {\\n        private const int P = 16;\\n        private const double Alpha = .673;\\n        private readonly int[] registers;\\n        private readonly HashSet<int> setRegisters;\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"HyperLogLog{T}\\\"/> class.\\n        /// </summary>\\n        public HyperLogLog()\\n        {\\n            var m = 1 << P;\\n            registers = new int[m];\\n            setRegisters = new HashSet<int>();\\n        }\\n\\n        /// <summary>\\n        /// Merge's two HyperLogLog's together to form a union HLL.\\n        /// </summary>\\n        /// <param name=\\\"first\\\">the first HLL.</param>\\n        /// <param name=\\\"second\\\">The second HLL.</param>\\n        /// <returns>A HyperLogLog with the combined values of the two sets of registers.</returns>\\n        public static HyperLogLog<T> Merge(HyperLogLog<T> first, HyperLogLog<T> second)\\n        {\\n            var output = new HyperLogLog<T>();\\n            for (var i = 0; i < second.registers.Length; i++)\\n            {\\n                output.registers[i] = Math.Max(first.registers[i], second.registers[i]);\\n            }\\n\\n            output.setRegisters.UnionWith(first.setRegisters);\\n            output.setRegisters.UnionWith(second.setRegisters);\\n            return output;\\n        }\\n\\n        /// <summary>\\n        /// Adds an item to the HyperLogLog.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">The Item to be added.</param>\\n        public void Add(T item)\\n        {\\n            var x = item.GetHashCode();\\n            var binString = Convert.ToString(x, 2); // converts hash to binary\\n            var j = Convert.ToInt32(binString.Substring(0, Math.Min(P, binString.Length)), 2); // convert first b bits to register index\\n            var w = (int)Math.Log2(x ^ (x & (x - 1))); // find position of the right most 1.\\n            registers[j] = Math.Max(registers[j], w); // set the appropriate register to the appropriate value.\\n            setRegisters.Add(j);\\n        }\\n\\n        /// <summary>\\n        /// Determines the approximate cardinality of the HyperLogLog.\\n        /// </summary>\\n        /// <returns>the approximate cardinality.</returns>\\n        public int Cardinality()\\n        {\\n            // calculate the bottom part of the harmonic mean of the registers\\n            double z = setRegisters.Sum(index => Math.Pow(2, -1 * registers[index]));\\n\\n            // calculate the harmonic mean of the set registers\\n            return (int)Math.Ceiling(Alpha * setRegisters.Count * (setRegisters.Count / z));\\n        }\\n    }\\n}\\n\"",
    "array based queue": "\"using System;\\n\\nnamespace DataStructures.Queue\\n{\\n    /// <summary>\\n    ///     Implementation of an array based queue. FIFO style.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Generic Type.</typeparam>\\n    public class ArrayBasedQueue<T>\\n    {\\n        private readonly T[] queue;\\n        private int endIndex;\\n        private bool isEmpty;\\n        private bool isFull;\\n        private int startIndex;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"ArrayBasedQueue{T}\\\" /> class.\\n        /// </summary>\\n        public ArrayBasedQueue(int capacity)\\n        {\\n            queue = new T[capacity];\\n            Clear();\\n        }\\n\\n        /// <summary>\\n        ///     Clears the queue.\\n        /// </summary>\\n        public void Clear()\\n        {\\n            startIndex = 0;\\n            endIndex = 0;\\n            isEmpty = true;\\n            isFull = false;\\n        }\\n\\n        /// <summary>\\n        ///     Returns the first item in the queue and removes it from the queue.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if the queue is empty.</exception>\\n        public T Dequeue()\\n        {\\n            if (IsEmpty())\\n            {\\n                throw new InvalidOperationException(\\\"There are no items in the queue.\\\");\\n            }\\n\\n            var dequeueIndex = endIndex;\\n            endIndex++;\\n            if (endIndex >= queue.Length)\\n            {\\n                endIndex = 0;\\n            }\\n\\n            isFull = false;\\n            isEmpty = startIndex == endIndex;\\n\\n            return queue[dequeueIndex];\\n        }\\n\\n        /// <summary>\\n        ///     Returns a boolean indicating whether the queue is empty.\\n        /// </summary>\\n        public bool IsEmpty() => isEmpty;\\n\\n        /// <summary>\\n        ///     Returns a boolean indicating whether the queue is full.\\n        /// </summary>\\n        public bool IsFull() => isFull;\\n\\n        /// <summary>\\n        ///     Returns the first item in the queue and keeps it in the queue.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if the queue is empty.</exception>\\n        public T Peek()\\n        {\\n            if (IsEmpty())\\n            {\\n                throw new InvalidOperationException(\\\"There are no items in the queue.\\\");\\n            }\\n\\n            return queue[endIndex];\\n        }\\n\\n        /// <summary>\\n        ///     Adds an item at the last position in the queue.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if the queue is full.</exception>\\n        public void Enqueue(T item)\\n        {\\n            if (IsFull())\\n            {\\n                throw new InvalidOperationException(\\\"The queue has reached its capacity.\\\");\\n            }\\n\\n            queue[startIndex] = item;\\n\\n            startIndex++;\\n            if (startIndex >= queue.Length)\\n            {\\n                startIndex = 0;\\n            }\\n\\n            isEmpty = false;\\n            isFull = startIndex == endIndex;\\n        }\\n    }\\n}\\n\"",
    "list based queue": "\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\nnamespace DataStructures.Queue\\n{\\n    /// <summary>\\n    ///     Implementation of a list based queue. FIFO style.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Generic Type.</typeparam>\\n    public class ListBasedQueue<T>\\n    {\\n        private readonly LinkedList<T> queue;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"ListBasedQueue{T}\\\" /> class.\\n        /// </summary>\\n        public ListBasedQueue() => queue = new LinkedList<T>();\\n\\n        /// <summary>\\n        ///     Clears the queue.\\n        /// </summary>\\n        public void Clear()\\n        {\\n            queue.Clear();\\n        }\\n\\n        /// <summary>\\n        ///     Returns the first item in the queue and removes it from the queue.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if the queue is empty.</exception>\\n        public T Dequeue()\\n        {\\n            if (queue.First is null)\\n            {\\n                throw new InvalidOperationException(\\\"There are no items in the queue.\\\");\\n            }\\n\\n            var item = queue.First;\\n            queue.RemoveFirst();\\n            return item.Value;\\n        }\\n\\n        /// <summary>\\n        ///     Returns a boolean indicating whether the queue is empty.\\n        /// </summary>\\n        public bool IsEmpty() => !queue.Any();\\n\\n        /// <summary>\\n        ///     Returns a boolean indicating whether the queue is full.\\n        /// </summary>\\n        public bool IsFull() => false;\\n\\n        /// <summary>\\n        ///     Returns the first item in the queue and keeps it in the queue.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if the queue is empty.</exception>\\n        public T Peek()\\n        {\\n            if (queue.First is null)\\n            {\\n                throw new InvalidOperationException(\\\"There are no items in the queue.\\\");\\n            }\\n\\n            return queue.First.Value;\\n        }\\n\\n        /// <summary>\\n        ///     Adds an item at the last position in the queue.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if the queue is full.</exception>\\n        public void Enqueue(T item)\\n        {\\n            queue.AddLast(item);\\n        }\\n    }\\n}\\n\"",
    "stack based queue": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.Queue\\n{\\n    /// <summary>\\n    ///     Implementation of a stack based queue. FIFO style.\\n    /// </summary>\\n    /// <remarks>\\n    ///     Enqueue is O(1) and Dequeue is amortized O(1).\\n    /// </remarks>\\n    /// <typeparam name=\\\"T\\\">Generic Type.</typeparam>\\n    public class StackBasedQueue<T>\\n    {\\n        private readonly Stack<T> input;\\n        private readonly Stack<T> output;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"StackBasedQueue{T}\\\" /> class.\\n        /// </summary>\\n        public StackBasedQueue()\\n        {\\n            input = new Stack<T>();\\n            output = new Stack<T>();\\n        }\\n\\n        /// <summary>\\n        ///     Clears the queue.\\n        /// </summary>\\n        public void Clear()\\n        {\\n            input.Clear();\\n            output.Clear();\\n        }\\n\\n        /// <summary>\\n        ///     Returns the first item in the queue and removes it from the queue.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if the queue is empty.</exception>\\n        public T Dequeue()\\n        {\\n            if (input.Count == 0 && output.Count == 0)\\n            {\\n                throw new InvalidOperationException(\\\"The queue contains no items.\\\");\\n            }\\n\\n            if (output.Count == 0)\\n            {\\n                while (input.Count > 0)\\n                {\\n                    var item = input.Pop();\\n                    output.Push(item);\\n                }\\n            }\\n\\n            return output.Pop();\\n        }\\n\\n        /// <summary>\\n        ///     Returns a boolean indicating whether the queue is empty.\\n        /// </summary>\\n        public bool IsEmpty() => input.Count == 0 && output.Count == 0;\\n\\n        /// <summary>\\n        ///     Returns a boolean indicating whether the queue is full.\\n        /// </summary>\\n        public bool IsFull() => false;\\n\\n        /// <summary>\\n        ///     Returns the first item in the queue and keeps it in the queue.\\n        /// </summary>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if the queue is empty.</exception>\\n        public T Peek()\\n        {\\n            if (input.Count == 0 && output.Count == 0)\\n            {\\n                throw new InvalidOperationException(\\\"The queue contains no items.\\\");\\n            }\\n\\n            if (output.Count == 0)\\n            {\\n                while (input.Count > 0)\\n                {\\n                    var item = input.Pop();\\n                    output.Push(item);\\n                }\\n            }\\n\\n            return output.Peek();\\n        }\\n\\n        /// <summary>\\n        ///     Adds an item at the last position in the queue.\\n        /// </summary>\\n        public void Enqueue(T item) => input.Push(item);\\n    }\\n}\\n\"",
    "red black tree": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.RedBlackTree\\n{\\n    /// <summary>\\n    ///     A self-balancing bindary tree.\\n    /// </summary>\\n    /// <remarks>\\n    ///     A red-black tree is a self-balancing binary search tree (BST) that\\n    ///     stores a color with each node. A node's color can either be red or\\n    ///     black. Several properties are maintained to ensure the tree remains\\n    ///     balanced.\\n    ///     <list type=\\\"number\\\">\\n    ///         <item>\\n    ///             <term>A red node does not have a red child.</term>\\n    ///         </item>\\n    ///         <item>\\n    ///             <term>All null nodes are considered black.</term>\\n    ///         </item>\\n    ///         <item>\\n    ///             <term>\\n    ///                 Every path from a node to its descendant leaf nodes\\n    ///             has the same number of black nodes.\\n    ///             </term>\\n    ///         </item>\\n    ///         <item>\\n    ///             <term>(Optional) The root is always black.</term>\\n    ///         </item>\\n    ///     </list>\\n    ///     Red-black trees are generally slightly more unbalanced than an\\n    ///     AVL tree, but insertion and deletion is generally faster.\\n    ///     See https://en.wikipedia.org/wiki/Red%E2%80%93black_tree for more information.\\n    /// </remarks>\\n    /// <typeparam name=\\\"TKey\\\">Type of key for the tree.</typeparam>\\n    public class RedBlackTree<TKey>\\n    {\\n        /// <summary>\\n        ///     Gets the number of nodes in the tree.\\n        /// </summary>\\n        public int Count { get; private set; }\\n\\n        /// <summary>\\n        ///     Comparer to use when comparing key values.\\n        /// </summary>\\n        private readonly Comparer<TKey> comparer;\\n\\n        /// <summary>\\n        ///     Reference to the root node.\\n        /// </summary>\\n        private RedBlackTreeNode<TKey>? root;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"RedBlackTree{TKey}\\\"/> class.\\n        /// </summary>\\n        public RedBlackTree()\\n        {\\n            comparer = Comparer<TKey>.Default;\\n        }\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"RedBlackTree{TKey}\\\"/> class\\n        ///     using the specified comparer.\\n        /// </summary>\\n        /// <param name=\\\"customComparer\\\">Comparer to use when comparing keys.</param>\\n        public RedBlackTree(Comparer<TKey> customComparer)\\n        {\\n            comparer = customComparer;\\n        }\\n\\n        /// <summary>\\n        ///     Add a single node to the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value to add.</param>\\n        public void Add(TKey key)\\n        {\\n            if (root is null)\\n            {\\n                // Case 3\\n                // New node is root\\n                root = new RedBlackTreeNode<TKey>(key, null)\\n                {\\n                    Color = NodeColor.Black,\\n                };\\n                Count++;\\n                return;\\n            }\\n\\n            // Regular binary tree insertion\\n            var node = Add(root, key);\\n\\n            // Get which side child was added to\\n            var childDir = comparer.Compare(node.Key, node.Parent!.Key);\\n\\n            // Set node to be new node's parent for easier handling\\n            node = node.Parent;\\n\\n            // Return tree to valid state\\n            int addCase;\\n            do\\n            {\\n                addCase = GetAddCase(node);\\n\\n                switch(addCase)\\n                {\\n                    case 1:\\n                        break;\\n                    case 2:\\n                        var oldParent = node.Parent;\\n                        node = AddCase2(node);\\n\\n                        if (node is not null)\\n                        {\\n                            childDir = comparer.Compare(oldParent!.Key, oldParent.Parent!.Key);\\n                        }\\n\\n                        break;\\n                    case 4:\\n                        node.Color = NodeColor.Black;\\n                        break;\\n                    case 56:\\n                        AddCase56(node, comparer.Compare(node.Key, node.Parent!.Key), childDir);\\n                        break;\\n                    default:\\n                        throw new InvalidOperationException(\\\"It should not be possible to get here!\\\");\\n                }\\n            }\\n            while (addCase == 2 && node is not null);\\n\\n            Count++;\\n        }\\n\\n        /// <summary>\\n        ///     Add multiple nodes to the tree.\\n        /// </summary>\\n        /// <param name=\\\"keys\\\">Key values to add.</param>\\n        public void AddRange(IEnumerable<TKey> keys)\\n        {\\n            foreach (var key in keys)\\n            {\\n                Add(key);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Remove a node from the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value to remove.</param>\\n        public void Remove(TKey key)\\n        {\\n            // Search for node\\n            var node = Remove(root, key);\\n\\n            // Simple cases\\n            node = RemoveSimpleCases(node);\\n\\n            // Exit if deleted node was not non-root black leaf\\n            if (node is null)\\n            {\\n                return;\\n            }\\n\\n            // Delete node\\n            DeleteLeaf(node.Parent!, comparer.Compare(node.Key, node.Parent!.Key));\\n\\n            // Recolor tree\\n            do\\n            {\\n                node = RemoveRecolor(node);\\n            }\\n            while (node is not null && node.Parent is not null);    // Case 2: Reached root\\n\\n            Count--;\\n        }\\n\\n        /// <summary>\\n        ///     Check if given node is in the tree.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value to search for.</param>\\n        /// <returns>Whether or not the node is in the tree.</returns>\\n        public bool Contains(TKey key)\\n        {\\n            var node = root;\\n            while (node is not null)\\n            {\\n                var compareResult = comparer.Compare(key, node.Key);\\n                if (compareResult < 0)\\n                {\\n                    node = node.Left;\\n                }\\n                else if (compareResult > 0)\\n                {\\n                    node = node.Right;\\n                }\\n                else\\n                {\\n                    return true;\\n                }\\n            }\\n\\n            return false;\\n        }\\n\\n        /// <summary>\\n        ///     Get the minimum value in the tree.\\n        /// </summary>\\n        /// <returns>Minimum value in tree.</returns>\\n        public TKey GetMin()\\n        {\\n            if (root is null)\\n            {\\n                throw new InvalidOperationException(\\\"Tree is empty!\\\");\\n            }\\n\\n            return GetMin(root).Key;\\n        }\\n\\n        /// <summary>\\n        ///     Get the maximum value in the tree.\\n        /// </summary>\\n        /// <returns>Maximum value in tree.</returns>\\n        public TKey GetMax()\\n        {\\n            if (root is null)\\n            {\\n                throw new InvalidOperationException(\\\"Tree is empty!\\\");\\n            }\\n\\n            return GetMax(root).Key;\\n        }\\n\\n        /// <summary>\\n        ///     Get keys in order from smallest to largest as defined by the comparer.\\n        /// </summary>\\n        /// <returns>Keys in tree in order from smallest to largest.</returns>\\n        public IEnumerable<TKey> GetKeysInOrder()\\n        {\\n            var result = new List<TKey>();\\n            InOrderWalk(root);\\n            return result;\\n\\n            void InOrderWalk(RedBlackTreeNode<TKey>? node)\\n            {\\n                if (node is null)\\n                {\\n                    return;\\n                }\\n\\n                InOrderWalk(node.Left);\\n                result.Add(node.Key);\\n                InOrderWalk(node.Right);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Get keys in the pre-order order.\\n        /// </summary>\\n        /// <returns>Keys in pre-order order.</returns>\\n        public IEnumerable<TKey> GetKeysPreOrder()\\n        {\\n            var result = new List<TKey>();\\n            PreOrderWalk(root);\\n            return result;\\n\\n            void PreOrderWalk(RedBlackTreeNode<TKey>? node)\\n            {\\n                if (node is null)\\n                {\\n                    return;\\n                }\\n\\n                result.Add(node.Key);\\n                PreOrderWalk(node.Left);\\n                PreOrderWalk(node.Right);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Get keys in the post-order order.\\n        /// </summary>\\n        /// <returns>Keys in the post-order order.</returns>\\n        public IEnumerable<TKey> GetKeysPostOrder()\\n        {\\n            var result = new List<TKey>();\\n            PostOrderWalk(root);\\n            return result;\\n\\n            void PostOrderWalk(RedBlackTreeNode<TKey>? node)\\n            {\\n                if (node is null)\\n                {\\n                    return;\\n                }\\n\\n                PostOrderWalk(node.Left);\\n                PostOrderWalk(node.Right);\\n                result.Add(node.Key);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Perform binary tree insertion.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Root of subtree to search from.</param>\\n        /// <param name=\\\"key\\\">Key value to insert.</param>\\n        /// <returns>Node that was added.</returns>\\n        private RedBlackTreeNode<TKey> Add(RedBlackTreeNode<TKey> node, TKey key)\\n        {\\n            int compareResult;\\n            RedBlackTreeNode<TKey> newNode;\\n            while (true)\\n            {\\n                compareResult = comparer.Compare(key, node!.Key);\\n                if (compareResult < 0)\\n                {\\n                    if (node.Left is null)\\n                    {\\n                        newNode = new RedBlackTreeNode<TKey>(key, node);\\n                        node.Left = newNode;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        node = node.Left;\\n                    }\\n                }\\n                else if (compareResult > 0)\\n                {\\n                    if (node.Right is null)\\n                    {\\n                        newNode = new RedBlackTreeNode<TKey>(key, node);\\n                        node.Right = newNode;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        node = node.Right;\\n                    }\\n                }\\n                else\\n                {\\n                    throw new ArgumentException($\\\"Key \\\\\\\"{key}\\\\\\\" already exists in tree!\\\");\\n                }\\n            }\\n\\n            return newNode;\\n        }\\n\\n        /// <summary>\\n        ///     Perform case 2 of insertion by pushing blackness down from parent.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Parent of inserted node.</param>\\n        /// <returns>Grandparent of inserted node.</returns>\\n        private RedBlackTreeNode<TKey>? AddCase2(RedBlackTreeNode<TKey> node)\\n        {\\n            var grandparent = node.Parent;\\n            var parentDir = comparer.Compare(node.Key, node.Parent!.Key);\\n            var uncle = parentDir < 0 ? grandparent!.Right : grandparent!.Left;\\n\\n            node.Color = NodeColor.Black;\\n            uncle!.Color = NodeColor.Black;\\n            grandparent.Color = NodeColor.Red;\\n\\n            // Keep root black\\n            if (node.Parent.Parent is null)\\n            {\\n                node.Parent.Color = NodeColor.Black;\\n            }\\n\\n            // Set current node as parent to move up tree\\n            return node.Parent.Parent;\\n        }\\n\\n        /// <summary>\\n        ///     Perform rotations needed for cases 5 and 6 of insertion.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Parent of node just inserted.</param>\\n        /// <param name=\\\"parentDir\\\">The side node is on of its parent.</param>\\n        /// <param name=\\\"childDir\\\">The side the child node is on.</param>\\n        private void AddCase56(RedBlackTreeNode<TKey> node, int parentDir, int childDir)\\n        {\\n            if (parentDir < 0)\\n            {\\n                // Case 5\\n                if (childDir > 0)\\n                {\\n                    node = RotateLeft(node);\\n                }\\n\\n                // Case 6\\n                node = RotateRight(node.Parent!);\\n                node.Color = NodeColor.Black;\\n                node.Right!.Color = NodeColor.Red;\\n            }\\n            else\\n            {\\n                // Case 5\\n                if (childDir < 0)\\n                {\\n                    node = RotateRight(node);\\n                }\\n\\n                // Case 6\\n                node = RotateLeft(node.Parent!);\\n                node.Color = NodeColor.Black;\\n                node.Left!.Color = NodeColor.Red;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Determine which add case applies to inserted node.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Parent of inserted node.</param>\\n        /// <returns>Case number needed to get tree in valid state. Cases 5 and 6 are represented by 56.</returns>\\n        private int GetAddCase(RedBlackTreeNode<TKey> node)\\n        {\\n            if (node.Color == NodeColor.Black)\\n            {\\n                return 1;\\n            }\\n            else if (node.Parent is null)\\n            {\\n                return 4;\\n            }\\n            else\\n            {\\n                // Remaining insert cases need uncle\\n                var grandparent = node.Parent;\\n                var parentDir = comparer.Compare(node.Key, node.Parent.Key);\\n                var uncle = parentDir < 0 ? grandparent.Right : grandparent.Left;\\n\\n                // Case 5 & 6\\n                if (uncle is null || uncle.Color == NodeColor.Black)\\n                {\\n                    return 56;\\n                }\\n\\n                return 2;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Search for the node to be deleted.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to start search from.</param>\\n        /// <param name=\\\"key\\\">Key to search for.</param>\\n        /// <returns>Node to be deleted.</returns>\\n        private RedBlackTreeNode<TKey> Remove(RedBlackTreeNode<TKey>? node, TKey key)\\n        {\\n            if (node is null)\\n            {\\n                throw new InvalidOperationException(\\\"Tree is empty!\\\");\\n            }\\n            else if (!Contains(key))\\n            {\\n                throw new KeyNotFoundException($\\\"Key {key} is not in the tree!\\\");\\n            }\\n            else\\n            {\\n                // Find node\\n                int dir;\\n                while (true)\\n                {\\n                    dir = comparer.Compare(key, node!.Key);\\n                    if (dir < 0)\\n                    {\\n                        node = node.Left;\\n                    }\\n                    else if (dir > 0)\\n                    {\\n                        node = node.Right;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                return node;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Get the tree back into a valid state after removing non-root black leaf.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Non-root black leaf being removed.</param>\\n        private RedBlackTreeNode<TKey>? RemoveRecolor(RedBlackTreeNode<TKey> node)\\n        {\\n            var removeCase = GetRemoveCase(node);\\n\\n            var dir = comparer.Compare(node.Key, node.Parent!.Key);\\n\\n            // Determine current node's sibling and nephews\\n            var sibling = dir < 0 ? node.Parent.Right : node.Parent.Left;\\n            var closeNewphew = dir < 0 ? sibling!.Left : sibling!.Right;\\n            var distantNephew = dir < 0 ? sibling!.Right : sibling!.Left;\\n\\n            switch (removeCase)\\n            {\\n                case 1:\\n                    sibling.Color = NodeColor.Red;\\n                    return node.Parent;\\n                case 3:\\n                    RemoveCase3(node, closeNewphew, dir);\\n                    break;\\n                case 4:\\n                    RemoveCase4(sibling);\\n                    break;\\n                case 5:\\n                    RemoveCase5(node, sibling, dir);\\n                    break;\\n                case 6:\\n                    RemoveCase6(node, distantNephew!, dir);\\n                    break;\\n                default:\\n                    throw new InvalidOperationException(\\\"It should not be possible to get here!\\\");\\n            }\\n\\n            return null;\\n        }\\n\\n        /// <summary>\\n        ///     Simple removal cases where black height doesn't change.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to remove.</param>\\n        /// <returns>Non-root black leaf node or null. Null indicates that removal was performed.</returns>\\n        private RedBlackTreeNode<TKey>? RemoveSimpleCases(RedBlackTreeNode<TKey> node)\\n        {\\n            // Node to delete is root and has no children\\n            if (node.Parent is null && node.Left is null && node.Right is null)\\n            {\\n                root = null;\\n                Count--;\\n                return null;\\n            }\\n\\n            // Node has two children. Swap pointers\\n            if (node.Left is not null && node.Right is not null)\\n            {\\n                var successor = GetMin(node.Right);\\n                node.Key = successor.Key;\\n                node = successor;\\n            }\\n\\n            // At this point node should have at most one child\\n            if (node.Color == NodeColor.Red)\\n            {\\n                // Node is red so it must have no children since it doesn't have two children\\n                DeleteLeaf(node.Parent!, comparer.Compare(node.Key, node.Parent!.Key));\\n\\n                Count--;\\n                return null;\\n            }\\n            else\\n            {\\n                // Node is black and may or may not be node\\n                return RemoveBlackNode(node);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Node to delete is black. If it is a leaf then we need to recolor, otherwise remove it.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Black node to examine.</param>\\n        /// <returns>Node to start recoloring from. Null if deletion occurred.</returns>\\n        private RedBlackTreeNode<TKey>? RemoveBlackNode(RedBlackTreeNode<TKey> node)\\n        {\\n            // Node is black and has at most one child. If it has a child it must be red.\\n            var child = node.Left ?? node.Right;\\n\\n            // Continue to recoloring if node is leaf\\n            if (child is null)\\n            {\\n                return node;\\n            }\\n\\n            // Recolor child\\n            child.Color = NodeColor.Black;\\n            child.Parent = node.Parent;\\n\\n            var childDir = node.Parent is null ? 0 : comparer.Compare(node.Key, node.Parent.Key);\\n\\n            // Replace node with child\\n            Transplant(node.Parent, child, childDir);\\n\\n            Count--;\\n            return null;\\n        }\\n\\n        /// <summary>\\n        ///     Perform case 3 of removal.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node that was removed.</param>\\n        /// <param name=\\\"closeNephew\\\">Close nephew of removed node.</param>\\n        /// <param name=\\\"childDir\\\">Side of parent the removed node was.</param>\\n        private void RemoveCase3(RedBlackTreeNode<TKey> node, RedBlackTreeNode<TKey>? closeNephew, int childDir)\\n        {\\n            // Rotate and recolor\\n            var sibling = childDir < 0 ? RotateLeft(node.Parent!) : RotateRight(node.Parent!);\\n            sibling.Color = NodeColor.Black;\\n            if (childDir < 0)\\n            {\\n                sibling.Left!.Color = NodeColor.Red;\\n            }\\n            else\\n            {\\n                sibling.Right!.Color = NodeColor.Red;\\n            }\\n\\n            // Get new distant newphew\\n            sibling = closeNephew!;\\n            var distantNephew = childDir < 0 ? sibling.Right : sibling.Left;\\n\\n            // Parent is red, sibling is black\\n            if (distantNephew is not null && distantNephew.Color == NodeColor.Red)\\n            {\\n                RemoveCase6(node, distantNephew, childDir);\\n                return;\\n            }\\n\\n            // Get new close nephew\\n            closeNephew = childDir < 0 ? sibling!.Left : sibling!.Right;\\n\\n            // Sibling is black, distant nephew is black\\n            if (closeNephew is not null && closeNephew.Color == NodeColor.Red)\\n            {\\n                RemoveCase5(node, sibling!, childDir);\\n                return;\\n            }\\n\\n            // Final recoloring\\n            RemoveCase4(sibling!);\\n        }\\n\\n        /// <summary>\\n        ///     Perform case 4 of removal.\\n        /// </summary>\\n        /// <param name=\\\"sibling\\\">Sibling of removed node.</param>\\n        private void RemoveCase4(RedBlackTreeNode<TKey> sibling)\\n        {\\n            sibling.Color = NodeColor.Red;\\n            sibling.Parent!.Color = NodeColor.Black;\\n        }\\n\\n        /// <summary>\\n        ///     Perform case 5 of removal.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node that was removed.</param>\\n        /// <param name=\\\"sibling\\\">Sibling of removed node.</param>\\n        /// <param name=\\\"childDir\\\">Side of parent removed node was on.</param>\\n        private void RemoveCase5(RedBlackTreeNode<TKey> node, RedBlackTreeNode<TKey> sibling, int childDir)\\n        {\\n            sibling = childDir < 0 ? RotateRight(sibling) : RotateLeft(sibling);\\n            var distantNephew = childDir < 0 ? sibling.Right! : sibling.Left!;\\n\\n            sibling.Color = NodeColor.Black;\\n            distantNephew.Color = NodeColor.Red;\\n\\n            RemoveCase6(node, distantNephew, childDir);\\n        }\\n\\n        /// <summary>\\n        ///     Perform case 6 of removal.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node that was removed.</param>\\n        /// <param name=\\\"distantNephew\\\">Distant nephew of removed node.</param>\\n        /// <param name=\\\"childDir\\\">Side of parent removed node was on.</param>\\n        private void RemoveCase6(RedBlackTreeNode<TKey> node, RedBlackTreeNode<TKey> distantNephew, int childDir)\\n        {\\n            var oldParent = node.Parent!;\\n            node = childDir < 0 ? RotateLeft(oldParent) : RotateRight(oldParent);\\n            node.Color = oldParent.Color;\\n            oldParent.Color = NodeColor.Black;\\n            distantNephew.Color = NodeColor.Black;\\n        }\\n\\n        /// <summary>\\n        ///     Determine which removal case is required.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node being removed.</param>\\n        /// <returns>Which removal case should be performed.</returns>\\n        private int GetRemoveCase(RedBlackTreeNode<TKey> node)\\n        {\\n            var dir = comparer.Compare(node.Key, node.Parent!.Key);\\n\\n            // Determine current node's sibling and nephews\\n            var sibling = dir < 0 ? node.Parent.Right : node.Parent.Left;\\n            var closeNewphew = dir < 0 ? sibling!.Left : sibling!.Right;\\n            var distantNephew = dir < 0 ? sibling!.Right : sibling!.Left;\\n\\n            if (sibling.Color == NodeColor.Red)\\n            {\\n                return 3;\\n            }\\n            else if (distantNephew is not null && distantNephew.Color == NodeColor.Red)\\n            {\\n                return 6;\\n            }\\n            else if (closeNewphew is not null && closeNewphew.Color == NodeColor.Red)\\n            {\\n                return 5;\\n            }\\n            else if (node.Parent.Color == NodeColor.Red)\\n            {\\n                return 4;\\n            }\\n            else\\n            {\\n                return 1;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Set child of node or delete leaf.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to set child of. Set to null for root.</param>\\n        /// <param name=\\\"child\\\">Node to set as child.</param>\\n        /// <param name=\\\"dir\\\">Which side of node to place child.</param>\\n        private void Transplant(RedBlackTreeNode<TKey>? node, RedBlackTreeNode<TKey>? child, int dir)\\n        {\\n            if (node is null)\\n            {\\n                root = child;\\n            }\\n            else if (child is null)\\n            {\\n                DeleteLeaf(node, dir);\\n            }\\n            else if (dir < 0)\\n            {\\n                node.Left = child;\\n            }\\n            else\\n            {\\n                node.Right = child;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Delete leaf node.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Parent of leaf node to delete.</param>\\n        /// <param name=\\\"dir\\\">Side of parent leaf is on.</param>\\n        private void DeleteLeaf(RedBlackTreeNode<TKey> node, int dir)\\n        {\\n            if (dir < 0)\\n            {\\n                node.Left = null;\\n            }\\n            else\\n            {\\n                node.Right = null;\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Perform a left (counter-clockwise) rotation.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to rotate about.</param>\\n        /// <returns>New node with rotation applied.</returns>\\n        private RedBlackTreeNode<TKey> RotateLeft(RedBlackTreeNode<TKey> node)\\n        {\\n            var temp1 = node;\\n            var temp2 = node!.Right!.Left;\\n\\n            node = node.Right;\\n            node.Parent = temp1.Parent;\\n            if (node.Parent is not null)\\n            {\\n                var nodeDir = comparer.Compare(node.Key, node.Parent.Key);\\n                if (nodeDir < 0)\\n                {\\n                    node.Parent.Left = node;\\n                }\\n                else\\n                {\\n                    node.Parent.Right = node;\\n                }\\n            }\\n\\n            node.Left = temp1;\\n            node.Left.Parent = node;\\n\\n            node.Left.Right = temp2;\\n            if (temp2 is not null)\\n            {\\n                node.Left.Right!.Parent = temp1;\\n            }\\n\\n            if (node.Parent is null)\\n            {\\n                root = node;\\n            }\\n\\n            return node;\\n        }\\n\\n        /// <summary>\\n        ///     Perform a right (clockwise) rotation.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node to rotate about.</param>\\n        /// <returns>New node with rotation applied.</returns>\\n        private RedBlackTreeNode<TKey> RotateRight(RedBlackTreeNode<TKey> node)\\n        {\\n            var temp1 = node;\\n            var temp2 = node!.Left!.Right;\\n\\n            node = node.Left;\\n            node.Parent = temp1.Parent;\\n            if (node.Parent is not null)\\n            {\\n                var nodeDir = comparer.Compare(node.Key, node.Parent.Key);\\n                if (nodeDir < 0)\\n                {\\n                    node.Parent.Left = node;\\n                }\\n                else\\n                {\\n                    node.Parent.Right = node;\\n                }\\n            }\\n\\n            node.Right = temp1;\\n            node.Right.Parent = node;\\n\\n            node.Right.Left = temp2;\\n            if (temp2 is not null)\\n            {\\n                node.Right.Left!.Parent = temp1;\\n            }\\n\\n            if (node.Parent is null)\\n            {\\n                root = node;\\n            }\\n\\n            return node;\\n        }\\n\\n        /// <summary>\\n        ///     Helper function to get node instance with minimum key value\\n        ///     in the specified subtree.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node specifying root of subtree.</param>\\n        /// <returns>Minimum value in node's subtree.</returns>\\n        private RedBlackTreeNode<TKey> GetMin(RedBlackTreeNode<TKey> node)\\n        {\\n            while (node.Left is not null)\\n            {\\n                node = node.Left;\\n            }\\n\\n            return node;\\n        }\\n\\n        /// <summary>\\n        ///     Helper function to get node instance with maximum key value\\n        ///     in the specified subtree.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Node specifyng root of subtree.</param>\\n        /// <returns>Maximum value in node's subtree.</returns>\\n        private RedBlackTreeNode<TKey> GetMax(RedBlackTreeNode<TKey> node)\\n        {\\n            while (node.Right is not null)\\n            {\\n                node = node.Right;\\n            }\\n\\n            return node;\\n        }\\n    }\\n}\\n\"",
    "red black tree node": "\"namespace DataStructures.RedBlackTree\\n{\\n    /// <summary>\\n    ///     Enum to represent node colors.\\n    /// </summary>\\n    public enum NodeColor : byte\\n    {\\n        /// <summary>\\n        ///     Represents red node\\n        /// </summary>\\n        Red,\\n\\n        /// <summary>\\n        ///     Represents black node\\n        /// </summary>\\n        Black,\\n    }\\n\\n    /// <summary>\\n    ///     Generic class to represent nodes in an <see cref=\\\"RedBlackTree{TKey}\\\"/> instance.\\n    /// </summary>\\n    /// <typeparam name=\\\"TKey\\\">The type of key for the node.</typeparam>\\n    public class RedBlackTreeNode<TKey>\\n    {\\n        /// <summary>\\n        ///     Gets or sets key value of node.\\n        /// </summary>\\n        public TKey Key { get; set; }\\n\\n        /// <summary>\\n        ///     Gets or sets the color of the node.\\n        /// </summary>\\n        public NodeColor Color { get; set; }\\n\\n        /// <summary>\\n        ///     Gets or sets the parent of the node.\\n        /// </summary>\\n        public RedBlackTreeNode<TKey>? Parent { get; set; }\\n\\n        /// <summary>\\n        ///     Gets or sets left child of the node.\\n        /// </summary>\\n        public RedBlackTreeNode<TKey>? Left { get; set; }\\n\\n        /// <summary>\\n        ///     Gets or sets the right child of the node.\\n        /// </summary>\\n        public RedBlackTreeNode<TKey>? Right { get; set; }\\n\\n        /// <summary>\\n        ///  Initializes a new instance of the <see cref=\\\"RedBlackTreeNode{TKey}\\\"/> class.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value for node.</param>\\n        /// <param name=\\\"parent\\\">Parent of node.</param>\\n        public RedBlackTreeNode(TKey key, RedBlackTreeNode<TKey>? parent)\\n        {\\n            Key = key;\\n            Parent = parent;\\n        }\\n    }\\n}\\n\"",
    "extensions": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.ScapegoatTree\\n{\\n    public static class Extensions\\n    {\\n        /// <summary>\\n        /// Flattens scapegoat tree into a list of nodes.\\n        /// </summary>\\n        /// <param name=\\\"root\\\">Scapegoat tree provided as root node.</param>\\n        /// <param name=\\\"list\\\">An empty list.</param>\\n        /// <typeparam name=\\\"TKey\\\">Scapegoat tree node key type.</typeparam>\\n        public static void FlattenTree<TKey>(Node<TKey> root, List<Node<TKey>> list) where TKey : IComparable\\n        {\\n            if (root.Left != null)\\n            {\\n                FlattenTree(root.Left, list);\\n            }\\n\\n            list.Add(root);\\n\\n            if (root.Right != null)\\n            {\\n                FlattenTree(root.Right, list);\\n            }\\n        }\\n\\n        /// <summary>\\n        /// Rebuilds a scapegoat tree from list of nodes.\\n        /// Use with <see cref=\\\"FlattenTree{TKey}\\\"/> method.\\n        /// </summary>\\n        /// <param name=\\\"list\\\">Flattened tree.</param>\\n        /// <param name=\\\"start\\\">Start index.</param>\\n        /// <param name=\\\"end\\\">End index.</param>\\n        /// <typeparam name=\\\"TKey\\\">Scapegoat tree node key type.</typeparam>\\n        /// <returns>Scapegoat tree root node.</returns>\\n        /// <exception cref=\\\"ArgumentException\\\">Thrown if start index is invalid.</exception>\\n        public static Node<TKey> RebuildFromList<TKey>(IList<Node<TKey>> list, int start, int end)\\n            where TKey : IComparable\\n        {\\n            if (start > end)\\n            {\\n                throw new ArgumentException(\\\"The parameter's value is invalid.\\\", nameof(start));\\n            }\\n\\n            var pivot = Convert.ToInt32(Math.Ceiling(start + (end - start) / 2.0));\\n\\n            return new Node<TKey>(list[pivot].Key)\\n            {\\n                Left = start > (pivot - 1) ? null : RebuildFromList(list, start, pivot - 1),\\n                Right = (pivot + 1) > end ? null : RebuildFromList(list, pivot + 1, end),\\n            };\\n        }\\n    }\\n}\\n\"",
    "scapegoat tree": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.ScapegoatTree\\n{\\n    /// <summary>\\n    /// A scapegoat implementation class.\\n    /// See https://en.wikipedia.org/wiki/Scapegoat_tree for more information about scapegoat tree.\\n    /// </summary>\\n    /// <typeparam name=\\\"TKey\\\">The scapegoat tree key type.</typeparam>\\n    public class ScapegoatTree<TKey> where TKey : IComparable\\n    {\\n        /// <summary>\\n        /// Gets the α (alpha) value of the tree.\\n        /// </summary>\\n        public double Alpha { get; private set; }\\n\\n        /// <summary>\\n        /// Gets the root node of the tree.\\n        /// </summary>\\n        public Node<TKey>? Root { get; private set; }\\n\\n        /// <summary>\\n        /// Gets the number of nodes in the tree.\\n        /// </summary>\\n        public int Size { get; private set; }\\n\\n        /// <summary>\\n        /// Gets the maximal value of the tree Size since the last time the tree was completely rebuilt.\\n        /// </summary>\\n        public int MaxSize { get; private set; }\\n\\n        /// <summary>\\n        /// Gets an event handler which will fire when tree is being balanced.\\n        /// </summary>\\n        public event EventHandler? TreeIsUnbalanced;\\n\\n        public ScapegoatTree()\\n            : this(alpha: 0.5, size: 0)\\n        {\\n        }\\n\\n        public ScapegoatTree(double alpha)\\n            : this(alpha, size: 0)\\n        {\\n        }\\n\\n        public ScapegoatTree(Node<TKey> node, double alpha)\\n            : this(alpha, size: node.GetSize())\\n        {\\n            Root = node;\\n        }\\n\\n        public ScapegoatTree(TKey key, double alpha = 0.5)\\n            : this(alpha, size: 1)\\n        {\\n            Root = new Node<TKey>(key);\\n        }\\n\\n        private ScapegoatTree(double alpha, int size)\\n        {\\n            CheckAlpha(alpha);\\n\\n            Alpha = alpha;\\n\\n            Size = size;\\n            MaxSize = size;\\n        }\\n\\n        /// <summary>\\n        /// Checks if current instance of the scapegoat tree is alpha weight balanced.\\n        /// </summary>\\n        /// <returns>True - if tree is alpha weight balanced. Otherwise, false.</returns>\\n        public bool IsAlphaWeightBalanced()\\n        {\\n            return Root?.IsAlphaWeightBalanced(Alpha) ?? true;\\n        }\\n\\n        /// <summary>\\n        /// Check if any node in the tree has specified key value.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value.</param>\\n        /// <returns>Returns true if node exists, false if not.</returns>\\n        public bool Contains(TKey key)\\n        {\\n            return Search(key) != null;\\n        }\\n\\n        /// <summary>\\n        /// Searches current instance of the scapegoat tree for specified key.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value.</param>\\n        /// <returns>Node with the specified key or null.</returns>\\n        public Node<TKey>? Search(TKey key)\\n        {\\n            if (Root == null)\\n            {\\n                return null;\\n            }\\n\\n            var current = Root;\\n\\n            while (true)\\n            {\\n                var result = current.Key.CompareTo(key);\\n\\n                switch (result)\\n                {\\n                    case 0:\\n                        return current;\\n                    case > 0 when current.Left != null:\\n                        current = current.Left;\\n                        break;\\n                    case < 0 when current.Right != null:\\n                        current = current.Right;\\n                        break;\\n                    default:\\n                        return null;\\n                }\\n            }\\n        }\\n\\n        /// <summary>\\n        /// Inserts a new key into current instance of the scapegoat tree. Rebuilds tree if it's unbalanced.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value.</param>\\n        /// <returns>True - if insertion is successful, false - if the key is already present in the tree.</returns>\\n        public bool Insert(TKey key)\\n        {\\n            var node = new Node<TKey>(key);\\n\\n            if (Root == null)\\n            {\\n                Root = node;\\n\\n                UpdateSizes();\\n\\n                return true;\\n            }\\n\\n            var path = new Stack<Node<TKey>>();\\n\\n            var current = Root;\\n\\n            var found = false;\\n\\n            while (!found)\\n            {\\n                path.Push(current);\\n\\n                var result = current.Key.CompareTo(node.Key);\\n\\n                switch (result)\\n                {\\n                    case < 0 when current.Right != null:\\n                        current = current.Right;\\n                        continue;\\n                    case < 0:\\n                        current.Right = node;\\n                        found = true;\\n                        break;\\n                    case > 0 when current.Left != null:\\n                        current = current.Left;\\n                        continue;\\n                    case > 0:\\n                        current.Left = node;\\n                        found = true;\\n                        break;\\n                    default:\\n                        return false;\\n                }\\n            }\\n\\n            UpdateSizes();\\n\\n            if (path.Count > Root.GetAlphaHeight(Alpha))\\n            {\\n                TreeIsUnbalanced?.Invoke(this, EventArgs.Empty);\\n\\n                BalanceFromPath(path);\\n\\n                MaxSize = Math.Max(MaxSize, Size);\\n            }\\n\\n            return true;\\n        }\\n\\n        /// <summary>\\n        /// Removes the specified key from the current instance of the scapegoat tree. Rebuilds tree if it's unbalanced.\\n        /// </summary>\\n        /// <param name=\\\"key\\\">Key value.</param>\\n        /// <returns>True - if key was successfully removed, false - if the key wasn't found in the tree.</returns>\\n        public bool Delete(TKey key)\\n        {\\n            if (Root == null)\\n            {\\n                return false;\\n            }\\n\\n            if (Remove(Root, Root, key))\\n            {\\n                Size--;\\n\\n                if (Root != null && Size < Alpha * MaxSize)\\n                {\\n                    TreeIsUnbalanced?.Invoke(this, EventArgs.Empty);\\n\\n                    var list = new List<Node<TKey>>();\\n\\n                    Extensions.FlattenTree(Root, list);\\n\\n                    Root = Extensions.RebuildFromList(list, 0, list.Count - 1);\\n\\n                    MaxSize = Size;\\n                }\\n\\n                return true;\\n            }\\n\\n            return false;\\n        }\\n\\n        /// <summary>\\n        /// Clears the tree.\\n        /// </summary>\\n        public void Clear()\\n        {\\n            Size = 0;\\n            MaxSize = 0;\\n            Root = null;\\n        }\\n\\n        /// <summary>\\n        /// Changes <see cref=\\\"Alpha\\\"/> value to adjust balancing.\\n        /// </summary>\\n        /// <param name=\\\"value\\\">New alpha value.</param>\\n        public void Tune(double value)\\n        {\\n            CheckAlpha(value);\\n            Alpha = value;\\n        }\\n\\n        /// <summary>\\n        /// Searches for a scapegoat node in provided stack.\\n        /// </summary>\\n        /// <param name=\\\"path\\\">Stack instance with nodes, starting with root node.</param>\\n        /// <returns>Scapegoat node with its parent node. Parent can be null if scapegoat node is root node.</returns>\\n        /// <exception cref=\\\"ArgumentException\\\">Thrown if path stack is empty.</exception>\\n        /// <exception cref=\\\"InvalidOperationException\\\">Thrown if scapegoat wasn't found.</exception>\\n        public (Node<TKey>? parent, Node<TKey> scapegoat) FindScapegoatInPath(Stack<Node<TKey>> path)\\n        {\\n            if (path.Count == 0)\\n            {\\n                throw new ArgumentException(\\\"The path collection should not be empty.\\\", nameof(path));\\n            }\\n\\n            var depth = 1;\\n\\n            while (path.TryPop(out var next))\\n            {\\n                if (depth > next.GetAlphaHeight(Alpha))\\n                {\\n                    return path.TryPop(out var parent) ? (parent, next) : (null, next);\\n                }\\n\\n                depth++;\\n            }\\n\\n            throw new InvalidOperationException(\\\"Scapegoat node wasn't found. The tree should be unbalanced.\\\");\\n        }\\n\\n        private static void CheckAlpha(double alpha)\\n        {\\n            if (alpha is < 0.5 or > 1.0)\\n            {\\n                throw new ArgumentException(\\\"The alpha parameter's value should be in 0.5..1.0 range.\\\", nameof(alpha));\\n            }\\n        }\\n\\n        private bool Remove(Node<TKey>? parent, Node<TKey>? node, TKey key)\\n        {\\n            if (node is null || parent is null)\\n            {\\n                return false;\\n            }\\n\\n            var compareResult = node.Key.CompareTo(key);\\n\\n            if (compareResult > 0)\\n            {\\n                return Remove(node, node.Left, key);\\n            }\\n\\n            if (compareResult < 0)\\n            {\\n                return Remove(node, node.Right, key);\\n            }\\n\\n            Node<TKey>? replacementNode;\\n\\n            // Case 0: Node has no children.\\n            // Case 1: Node has one child.\\n            if (node.Left is null || node.Right is null)\\n            {\\n                replacementNode = node.Left ?? node.Right;\\n            }\\n\\n            // Case 2: Node has two children. (This implementation uses the in-order predecessor to replace node.)\\n            else\\n            {\\n                var predecessorNode = node.Left.GetLargestKeyNode();\\n                Remove(Root, Root, predecessorNode.Key);\\n                replacementNode = new Node<TKey>(predecessorNode.Key)\\n                {\\n                    Left = node.Left,\\n                    Right = node.Right,\\n                };\\n            }\\n\\n            // Replace the relevant node with a replacement found in the previous stages.\\n            // Special case for replacing the root node.\\n            if (node == Root)\\n            {\\n                Root = replacementNode;\\n            }\\n            else if (parent.Left == node)\\n            {\\n                parent.Left = replacementNode;\\n            }\\n            else\\n            {\\n                parent.Right = replacementNode;\\n            }\\n\\n            return true;\\n        }\\n\\n        private void BalanceFromPath(Stack<Node<TKey>> path)\\n        {\\n            var (parent, scapegoat) = FindScapegoatInPath(path);\\n\\n            var list = new List<Node<TKey>>();\\n\\n            Extensions.FlattenTree(scapegoat, list);\\n\\n            var tree = Extensions.RebuildFromList(list, 0, list.Count - 1);\\n\\n            if (parent == null)\\n            {\\n                Root = tree;\\n            }\\n            else\\n            {\\n                var result = parent.Key.CompareTo(tree.Key);\\n\\n                if (result < 0)\\n                {\\n                    parent.Right = tree;\\n                }\\n                else\\n                {\\n                    parent.Left = tree;\\n                }\\n            }\\n        }\\n\\n        private void UpdateSizes()\\n        {\\n            Size += 1;\\n            MaxSize = Math.Max(Size, MaxSize);\\n        }\\n    }\\n}\\n\"",
    "segment tree": "\"using System;\\n\\nnamespace DataStructures.SegmentTrees\\n{\\n    /// <summary>\\n    ///     Goal:   Data structure with which you can quickly perform queries on an array (i.e. sum of subarray)\\n    ///     and at the same time efficiently update an entry\\n    ///     or apply a distributive operation to a subarray.\\n    ///     Idea:   Preprocessing special queries\\n    ///     Hint:   The query operation HAS to be associative (in this example addition).\\n    /// </summary>\\n    public class SegmentTree\\n    {\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"SegmentTree\\\" /> class.\\n        ///     Runtime complexity: O(n) where n equals the array-length.\\n        /// </summary>\\n        /// <param name=\\\"arr\\\">Array on which the queries should be made.</param>\\n        public SegmentTree(int[] arr)\\n        {\\n            // Calculates next power of two\\n            var pow = (int)Math.Pow(2, Math.Ceiling(Math.Log(arr.Length, 2)));\\n            Tree = new int[2 * pow];\\n\\n            // Transfers the input array into the last half of the segment tree array\\n            Array.Copy(arr, 0, Tree, pow, arr.Length);\\n\\n            // Calculates the first half\\n            for (var i = pow - 1; i > 0; --i)\\n            {\\n                Tree[i] = Tree[Left(i)] + Tree[Right(i)];\\n            }\\n        }\\n\\n        /// <summary>Gets the segment tree array.</summary>\\n        public int[] Tree { get; }\\n\\n        /// <summary>\\n        ///     Starts a query.\\n        ///     Runtime complexity: O(logN) where n equals the array-length.\\n        /// </summary>\\n        /// <param name=\\\"l\\\">Left border of the query.</param>\\n        /// <param name=\\\"r\\\">Right border of the query.</param>\\n        /// <returns>Sum of the subarray between <c>l</c> and <c>r</c> (including <c>l</c> and <c>r</c>).</returns>\\n        // Editing of query start at node with 1.\\n        // Node with index 1 includes the whole input subarray.\\n        public int Query(int l, int r) =>\\n            Query(++l, ++r, 1, Tree.Length / 2, 1);\\n\\n        /// <summary>\\n        ///     Calculates the right child of a node.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Current node.</param>\\n        /// <returns>Index of the right child.</returns>\\n        protected int Right(int node) => 2 * node + 1;\\n\\n        /// <summary>\\n        ///     Calculates the left child of a node.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Current node.</param>\\n        /// <returns>Index of the left child.</returns>\\n        protected int Left(int node) => 2 * node;\\n\\n        /// <summary>\\n        ///     Calculates the parent of a node.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Current node.</param>\\n        /// <returns>Index of the parent node.</returns>\\n        protected int Parent(int node) => node / 2;\\n\\n        /// <summary>\\n        ///     Edits a query.\\n        /// </summary>\\n        /// <param name=\\\"l\\\">Left border of the query.</param>\\n        /// <param name=\\\"r\\\">Right border of the query.</param>\\n        /// <param name=\\\"a\\\">Left end of the subarray enclosed by <c>i</c>.</param>\\n        /// <param name=\\\"b\\\">Right end of the subarray enclosed by <c>i</c>.</param>\\n        /// <param name=\\\"i\\\">Current node.</param>\\n        /// <returns>Sum of a subarray between <c>l</c> and <c>r</c> (including <c>l</c> and <c>r</c>).</returns>\\n        protected virtual int Query(int l, int r, int a, int b, int i)\\n        {\\n            // If a and b are in the (by l and r) specified subarray\\n            if (l <= a && b <= r)\\n            {\\n                return Tree[i];\\n            }\\n\\n            // If a or b are out of the by l and r specified subarray\\n            if (r < a || b < l)\\n            {\\n                // Returns the neutral value of the operation\\n                // (in this case 0, because x + 0 = x)\\n                return 0;\\n            }\\n\\n            // Calculates index m of the node that cuts the current subarray in half\\n            var m = (a + b) / 2;\\n\\n            // Start query of new two subarrays a:m and m+1:b\\n            // The right and left child cover this intervals\\n            return Query(l, r, a, m, Left(i)) + Query(l, r, m + 1, b, Right(i));\\n        }\\n    }\\n}\\n\"",
    "segment tree apply": "\"using System;\\n\\nnamespace DataStructures.SegmentTrees\\n{\\n    /// <summary>\\n    ///     This is an extension of a segment tree, which allows applying distributive operations to a subarray\\n    ///     (in this case multiplication).\\n    /// </summary>\\n    public class SegmentTreeApply : SegmentTree\\n    {\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"SegmentTreeApply\\\" /> class.\\n        ///     Runtime complexity: O(n) where n equals the array-length.\\n        /// </summary>\\n        /// <param name=\\\"arr\\\">Array on which the operations should be made.</param>\\n        public SegmentTreeApply(int[] arr)\\n            : base(arr)\\n        {\\n            // Initilizes and fills \\\"operand\\\" array with neutral element (in this case 1, because value * 1 = value)\\n            Operand = new int[Tree.Length];\\n            Array.Fill(Operand, 1);\\n        }\\n\\n        /// <summary>\\n        ///     Gets an array that stores for each node an operand,\\n        ///     which must be applied to all direct and indirect child nodes of this node\\n        ///     (but not to the node itself).\\n        /// </summary>\\n        public int[] Operand { get; }\\n\\n        /// <summary>\\n        ///     Applies a distributive operation to a subarray defined by <c>l</c> and <c>r</c>\\n        ///     (in this case multiplication by <c>value</c>).\\n        ///     Runtime complexity: O(logN) where N equals the initial array-length.\\n        /// </summary>\\n        /// <param name=\\\"l\\\">Left border of the subarray.</param>\\n        /// <param name=\\\"r\\\">Right border of the subarray.</param>\\n        /// <param name=\\\"value\\\">Value with which each element of the interval is calculated.</param>\\n        public void Apply(int l, int r, int value)\\n        {\\n            // The Application start at node with 1\\n            // Node with index 1 includes the whole input subarray\\n            Apply(++l, ++r, value, 1, Tree.Length / 2, 1);\\n        }\\n\\n        /// <summary>\\n        ///     Edits a query.\\n        /// </summary>\\n        /// <param name=\\\"l\\\">Left border of the query.</param>\\n        /// <param name=\\\"r\\\">Right border of the query.</param>\\n        /// <param name=\\\"a\\\">Left end of the subarray enclosed by <c>i</c>.</param>\\n        /// <param name=\\\"b\\\">Right end of the subarray enclosed by <c>i</c>.</param>\\n        /// <param name=\\\"i\\\">Current node.</param>\\n        /// <returns>Sum of a subarray between <c>l</c> and <c>r</c> (including <c>l</c> and <c>r</c>).</returns>\\n        protected override int Query(int l, int r, int a, int b, int i)\\n        {\\n            if (l <= a && b <= r)\\n            {\\n                return Tree[i];\\n            }\\n\\n            if (r < a || b < l)\\n            {\\n                return 0;\\n            }\\n\\n            var m = (a + b) / 2;\\n\\n            // Application of the saved operand to the direct and indrect child nodes\\n            return Operand[i] * (Query(l, r, a, m, Left(i)) + Query(l, r, m + 1, b, Right(i)));\\n        }\\n\\n        /// <summary>\\n        ///     Applies the operation.\\n        /// </summary>\\n        /// <param name=\\\"l\\\">Left border of the Application.</param>\\n        /// <param name=\\\"r\\\">Right border of the Application.</param>\\n        /// <param name=\\\"value\\\">Multiplier by which the subarray is to be multiplied.</param>\\n        /// <param name=\\\"a\\\">Left end of the subarray enclosed by <c>i</c>.</param>\\n        /// <param name=\\\"b\\\">Right end of the subarray enclosed by <c>i</c>.</param>\\n        /// <param name=\\\"i\\\">Current node.</param>\\n        private void Apply(int l, int r, int value, int a, int b, int i)\\n        {\\n            // If a and b are in the (by l and r) specified subarray\\n            if (l <= a && b <= r)\\n            {\\n                // Applies the operation to the current node and saves it for the direct and indirect child nodes\\n                Operand[i] = value * Operand[i];\\n                Tree[i] = value * Tree[i];\\n                return;\\n            }\\n\\n            // If a or b are out of the by l and r specified subarray stop application at this node\\n            if (r < a || b < l)\\n            {\\n                return;\\n            }\\n\\n            // Calculates index m of the node that cuts the current subarray in half\\n            var m = (a + b) / 2;\\n\\n            // Applies the operation to both halfes\\n            Apply(l, r, value, a, m, Left(i));\\n            Apply(l, r, value, m + 1, b, Right(i));\\n\\n            // Recalculates the value of this node by its (possibly new) children.\\n            Tree[i] = Operand[i] * (Tree[Left(i)] + Tree[Right(i)]);\\n        }\\n    }\\n}\\n\"",
    "segment tree update": "\"namespace DataStructures.SegmentTrees\\n{\\n    /// <summary>\\n    ///     This is an extension of a segment tree, which allows the update of a single element.\\n    /// </summary>\\n    public class SegmentTreeUpdate : SegmentTree\\n    {\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"SegmentTreeUpdate\\\" /> class.\\n        ///     Runtime complexity: O(n) where n equals the array-length.\\n        /// </summary>\\n        /// <param name=\\\"arr\\\">Array on which the queries should be made.</param>\\n        public SegmentTreeUpdate(int[] arr)\\n            : base(arr)\\n        {\\n        }\\n\\n        /// <summary>\\n        ///     Updates a single element of the input array.\\n        ///     Changes the leaf first and updates its parents afterwards.\\n        ///     Runtime complexity: O(logN) where N equals the initial array-length.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Index of the node that should be updated.</param>\\n        /// <param name=\\\"value\\\">New Value of the element.</param>\\n        public void Update(int node, int value)\\n        {\\n            Tree[node + Tree.Length / 2] = value;\\n            Propagate(Parent(node + Tree.Length / 2));\\n        }\\n\\n        /// <summary>\\n        ///     Recalculates the value of node by its children.\\n        ///     Calls its parent to do the same.\\n        /// </summary>\\n        /// <param name=\\\"node\\\">Index of current node.</param>\\n        private void Propagate(int node)\\n        {\\n            if (node == 0)\\n            {\\n                // passed root\\n                return;\\n            }\\n\\n            Tree[node] = Tree[Left(node)] + Tree[Right(node)];\\n            Propagate(Parent(node));\\n        }\\n    }\\n}\\n\"",
    "array based stack": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.Stack\\n{\\n    /// <summary>\\n    ///     Implementation of an array-based stack. LIFO style.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Generic Type.</typeparam>\\n    public class ArrayBasedStack<T>\\n    {\\n        private const int DefaultCapacity = 10;\\n        private const string StackEmptyErrorMessage = \\\"Stack is empty\\\";\\n\\n        /// <summary>\\n        ///     <see cref=\\\"Array\\\" /> based stack.\\n        /// </summary>\\n        private T[] stack;\\n\\n        /// <summary>\\n        ///     How many items are in the stack right now.\\n        /// </summary>\\n        private int top;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"ArrayBasedStack{T}\\\" /> class.\\n        /// </summary>\\n        public ArrayBasedStack()\\n        {\\n            stack = new T[DefaultCapacity];\\n            top = -1;\\n        }\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"ArrayBasedStack{T}\\\" /> class.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">Item to push onto the <see cref=\\\"ArrayBasedStack{T}\\\" />.</param>\\n        public ArrayBasedStack(T item)\\n            : this() => Push(item);\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"ArrayBasedStack{T}\\\" /> class.\\n        /// </summary>\\n        /// <param name=\\\"items\\\">Items to push onto the <see cref=\\\"ArrayBasedStack{T}\\\" />.</param>\\n        public ArrayBasedStack(IEnumerable<T> items)\\n            : this()\\n        {\\n            foreach (var item in items)\\n            {\\n                Push(item);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Gets the number of elements on the <see cref=\\\"ArrayBasedStack{T}\\\" />.\\n        /// </summary>\\n        public int Top => top;\\n\\n        /// <summary>\\n        ///     Gets or sets the Capacity of the <see cref=\\\"ArrayBasedStack{T}\\\" />.\\n        /// </summary>\\n        public int Capacity\\n        {\\n            get => stack.Length;\\n            set => Array.Resize(ref stack, value);\\n        }\\n\\n        /// <summary>\\n        ///     Removes all items from the <see cref=\\\"ArrayBasedStack{T}\\\" />.\\n        /// </summary>\\n        public void Clear()\\n        {\\n            top = -1;\\n            Capacity = DefaultCapacity;\\n        }\\n\\n        /// <summary>\\n        ///     Determines whether an element is in the <see cref=\\\"ArrayBasedStack{T}\\\" />.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">The item to locate in the <see cref=\\\"ArrayBasedStack{T}\\\" />.</param>\\n        /// <returns>True, if the item is in the stack.</returns>\\n        public bool Contains(T item) => Array.IndexOf(stack, item, 0, top + 1) > -1;\\n\\n        /// <summary>\\n        ///     Returns the item at the top of the <see cref=\\\"ArrayBasedStack{T}\\\" /> without removing it.\\n        /// </summary>\\n        /// <returns>The item at the top of the <see cref=\\\"ArrayBasedStack{T}\\\" />.</returns>\\n        public T Peek()\\n        {\\n            if (top == -1)\\n            {\\n                throw new InvalidOperationException(StackEmptyErrorMessage);\\n            }\\n\\n            return stack[top];\\n        }\\n\\n        /// <summary>\\n        ///     Removes and returns the item at the top of the <see cref=\\\"ArrayBasedStack{T}\\\" />.\\n        /// </summary>\\n        /// <returns>The item removed from the top of the <see cref=\\\"ArrayBasedStack{T}\\\" />.</returns>\\n        public T Pop()\\n        {\\n            if (top == -1)\\n            {\\n                throw new InvalidOperationException(StackEmptyErrorMessage);\\n            }\\n\\n            return stack[top--];\\n        }\\n\\n        /// <summary>\\n        ///     Inserts an item at the top of the <see cref=\\\"ArrayBasedStack{T}\\\" />.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">The item to push onto the <see cref=\\\"ArrayBasedStack{T}\\\" />.</param>\\n        public void Push(T item)\\n        {\\n            if (top == Capacity - 1)\\n            {\\n                Capacity *= 2;\\n            }\\n\\n            stack[++top] = item;\\n        }\\n    }\\n}\\n\"",
    "list based stack": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.Stack\\n{\\n    /// <summary>\\n    ///     Implementation of a list based stack. FILO style.\\n    /// </summary>\\n    /// <typeparam name=\\\"T\\\">Generic Type.</typeparam>\\n    public class ListBasedStack<T>\\n    {\\n        /// <summary>\\n        ///     <see cref=\\\"List{T}\\\" /> based stack.\\n        /// </summary>\\n        private readonly LinkedList<T> stack;\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"ListBasedStack{T}\\\" /> class.\\n        /// </summary>\\n        public ListBasedStack() => stack = new LinkedList<T>();\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"ListBasedStack{T}\\\" /> class.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">Item to push onto the <see cref=\\\"ListBasedStack{T}\\\" />.</param>\\n        public ListBasedStack(T item)\\n            : this() => Push(item);\\n\\n        /// <summary>\\n        ///     Initializes a new instance of the <see cref=\\\"ListBasedStack{T}\\\" /> class.\\n        /// </summary>\\n        /// <param name=\\\"items\\\">Items to push onto the <see cref=\\\"ListBasedStack{T}\\\" />.</param>\\n        public ListBasedStack(IEnumerable<T> items)\\n            : this()\\n        {\\n            foreach (var item in items)\\n            {\\n                Push(item);\\n            }\\n        }\\n\\n        /// <summary>\\n        ///     Gets the number of elements on the <see cref=\\\"ListBasedStack{T}\\\" />.\\n        /// </summary>\\n        public int Count => stack.Count;\\n\\n        /// <summary>\\n        ///     Removes all items from the <see cref=\\\"ListBasedStack{T}\\\" />.\\n        /// </summary>\\n        public void Clear() => stack.Clear();\\n\\n        /// <summary>\\n        ///     Determines whether an element is in the <see cref=\\\"ListBasedStack{T}\\\" />.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">The item to locate in the <see cref=\\\"ListBasedStack{T}\\\" />.</param>\\n        /// <returns>True, if the item is in the stack.</returns>\\n        public bool Contains(T item) => stack.Contains(item);\\n\\n        /// <summary>\\n        ///     Returns the item at the top of the <see cref=\\\"ListBasedStack{T}\\\" /> without removing it.\\n        /// </summary>\\n        /// <returns>The item at the top of the <see cref=\\\"ListBasedStack{T}\\\" />.</returns>\\n        public T Peek()\\n        {\\n            if (stack.First is null)\\n            {\\n                throw new InvalidOperationException(\\\"Stack is empty\\\");\\n            }\\n\\n            return stack.First.Value;\\n        }\\n\\n        /// <summary>\\n        ///     Removes and returns the item at the top of the <see cref=\\\"ListBasedStack{T}\\\" />.\\n        /// </summary>\\n        /// <returns>The item removed from the top of the <see cref=\\\"ListBasedStack{T}\\\" />.</returns>\\n        public T Pop()\\n        {\\n            if (stack.First is null)\\n            {\\n                throw new InvalidOperationException(\\\"Stack is empty\\\");\\n            }\\n\\n            var item = stack.First.Value;\\n            stack.RemoveFirst();\\n            return item;\\n        }\\n\\n        /// <summary>\\n        ///     Inserts an item at the top of the <see cref=\\\"ListBasedStack{T}\\\" />.\\n        /// </summary>\\n        /// <param name=\\\"item\\\">The item to push onto the <see cref=\\\"ListBasedStack{T}\\\" />.</param>\\n        public void Push(T item) => stack.AddFirst(item);\\n    }\\n}\\n\"",
    "trie": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.Tries\\n{\\n    /// <summary>\\n    /// A Trie is a data structure (particular case of m-ary tree) used to efficiently represent strings with common prefixes.\\n    /// Originally posed by E. Fredkin in 1960.\\n    ///     Fredkin, Edward (Sept. 1960), \\\"Trie Memory\\\", Communications of the ACM 3 (9): 490-499.\\n    /// Its name is due to retrieval because its main application is in the field of \\\"Information Retrieval\\\" (information retrieval).\\n    /// </summary>\\n    public class Trie\\n    {\\n        /// <summary>\\n        /// This character marks the end of a string.\\n        /// </summary>\\n        private const char Mark = '$';\\n\\n        /// <summary>\\n        /// This property represents the root node of the trie.\\n        /// </summary>\\n        private readonly TrieNode root;\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"Trie\\\"/> class. This instances was created without text strings, generating the root node of the trie, without children.\\n        /// </summary>\\n        public Trie()\\n        {\\n            root = new TrieNode(Mark);\\n        }\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"Trie\\\"/> class. Given a set of text strings, each of those strings inserts them into the trie using the Insert (string) method.\\n        /// </summary>\\n        /// <param name=\\\"words\\\">The array with text strings to insert in the trie.</param>\\n        public Trie(IEnumerable<string> words)\\n            : this()\\n        {\\n            foreach (string s in words)\\n            {\\n                Insert(s);\\n            }\\n        }\\n\\n        /// <summary>\\n        /// Insert a string s to the trie. The $ mark is added to the end of the chain and then it is added, this in order to indicate the end of the chain in the trie.\\n        /// </summary>\\n        /// <param name=\\\"s\\\">The string to insert into the trie.</param>\\n        public void Insert(string s)\\n        {\\n            s += Mark;\\n\\n            int index = 0;\\n            TrieNode match = PrefixQuery(s, ref index);\\n\\n            for (int i = index; i < s.Length; i++)\\n            {\\n                TrieNode t = new(s[i], match);\\n                match[s[i]] = t;\\n                match = t;\\n            }\\n        }\\n\\n        /// <summary>\\n        /// Remove a text string from the trie.\\n        /// </summary>\\n        /// <param name=\\\"s\\\">The text string to be removed from the trie.</param>\\n        public void Remove(string s)\\n        {\\n            s += Mark;\\n            int index = 0;\\n            TrieNode match = PrefixQuery(s, ref index);\\n            while(match.IsLeaf())\\n            {\\n                char c = match.Value;\\n                if(match.Parent == null)\\n                {\\n                    break;\\n                }\\n\\n                match = match.Parent;\\n                match.Children.Remove(c);\\n            }\\n        }\\n\\n        /// <summary>\\n        /// Know if a text string is in the trie.\\n        /// </summary>\\n        /// <param name=\\\"s\\\">The string s that you want to know if it is in the trie.</param>\\n        /// <returns>If the string is found, it returns true, otherwise false.</returns>\\n        public bool Find(string s)\\n        {\\n            int index = 0;\\n            return PrefixQuery(s + Mark, ref index).IsLeaf();\\n        }\\n\\n        /// <summary>\\n        /// This method analyzes which is the longest common prefix of a string s in the trie. If the string is in the trie then it is equivalent to doing Find (s).\\n        /// </summary>\\n        /// <param name=\\\"s\\\">The string for which you want to know the longest common prefix.</param>\\n        /// <param name=\\\"index\\\">The index to which the longest common prefix goes.</param>\\n        /// <returns>\\n        /// Returns the longest common prefix node found in the trie with the string s.\\n        /// </returns>\\n        private TrieNode PrefixQuery(string s, ref int index)\\n        {\\n            TrieNode current = root;\\n            for (int i = 0; i < s.Length && current != null; i++)\\n            {\\n                if (current[s[i]] != null)\\n                {\\n                    current = current[s[i]] ?? throw new NullReferenceException();\\n                    index = i + 1;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            return current ?? throw new NullReferenceException();\\n        }\\n    }\\n}\\n\"",
    "trie node": "\"using System;\\nusing System.Collections.Generic;\\n\\nnamespace DataStructures.Tries\\n{\\n    /// <summary>\\n    /// This class represents the nodes of a trie.\\n    /// </summary>\\n    internal class TrieNode\\n    {\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"TrieNode\\\"/> class. This instance was created with a character from the alphabet, and its parent will be null.\\n        /// </summary>\\n        /// <param name=\\\"value\\\">Character of the alphabet that represents the node.</param>\\n        internal TrieNode(char value)\\n            : this(value, null)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"TrieNode\\\"/> class. This instance was created with a character from the alphabet, and its parent.\\n        /// </summary>\\n        /// <param name=\\\"value\\\">Character of the alphabet that represents the node.</param>\\n        /// <param name=\\\"parent\\\">The parent or ancestor of the node in the trie structure.</param>\\n        internal TrieNode(char value, TrieNode? parent)\\n        {\\n            Children = new SortedList<char, TrieNode>();\\n            Parent = parent;\\n            Value = value;\\n        }\\n\\n        /// <summary>\\n        /// Gets all the descendants of the current node.\\n        /// </summary>\\n        /// <value>A sorted set with all the descendants.</value>\\n        internal SortedList<char, TrieNode> Children { get; private set; }\\n\\n        /// <summary>\\n        /// Gets the parent or ancestor of the node in the trie structure.\\n        /// </summary>\\n        /// <value>A TrieNode that represent a parent.</value>\\n        internal TrieNode? Parent { get; private set; }\\n\\n        /// <summary>\\n        /// Gets the character of the alphabet that represents the node.\\n        /// </summary>\\n        /// <value>A character of the alphabet.</value>\\n        internal char Value { get; private set; }\\n\\n        /// <summary>\\n        /// Index the descendants of the current node given an alphabet character.\\n        /// </summary>\\n        /// <value>A TrieNode with the character c in Children.</value>\\n        public TrieNode? this[char c]\\n        {\\n            get => Children.ContainsKey(c) ? Children[c] : null;\\n            set => Children[c] = value ?? throw new NullReferenceException();\\n        }\\n\\n        /// <summary>\\n        /// Method that checks if the current node is a trie leaf.\\n        /// </summary>\\n        /// <returns>Returns true if the current node has no children, false otherwise.</returns>\\n        public bool IsLeaf()\\n        {\\n            return Children.Count == 0;\\n        }\\n    }\\n}\\n\"",
    "unrolled linked list": "\"using System.Collections.Generic;\\n\\nnamespace DataStructures.UnrolledList\\n{\\n    /// <summary>\\n    /// Unrolled linked list is a linked list of small arrays,\\n    /// all of the same size where each is so small that the insertion\\n    /// or deletion is fast and quick, but large enough to fill the cache line.\\n    /// </summary>\\n    public class UnrolledLinkedList\\n    {\\n        private readonly int sizeNode;\\n\\n        private UnrolledLinkedListNode start = null!;\\n        private UnrolledLinkedListNode end = null!;\\n\\n        /// <summary>\\n        /// Initializes a new instance of the <see cref=\\\"UnrolledLinkedList\\\"/> class.\\n        /// Create a unrolled list with start chunk size.\\n        /// </summary>\\n        /// <param name=\\\"chunkSize\\\">The size of signe chunk.</param>\\n        public UnrolledLinkedList(int chunkSize)\\n        {\\n            sizeNode = chunkSize + 1;\\n        }\\n\\n        /// <summary>\\n        /// Add value to list [O(n)].\\n        /// </summary>\\n        /// <param name=\\\"value\\\">The entered value.</param>\\n        public void Insert(int value)\\n        {\\n            if (start == null)\\n            {\\n                start = new UnrolledLinkedListNode(sizeNode);\\n                start.Set(0, value);\\n\\n                end = start;\\n                return;\\n            }\\n\\n            if (end.Count + 1 < sizeNode)\\n            {\\n                end.Set(end.Count, value);\\n            }\\n            else\\n            {\\n                var pointer = new UnrolledLinkedListNode(sizeNode);\\n                var j = 0;\\n                for (var pos = end.Count / 2 + 1; pos < end.Count; pos++)\\n                {\\n                    pointer.Set(j++, end.Get(pos));\\n                }\\n\\n                pointer.Set(j++, value);\\n                pointer.Count = j;\\n\\n                end.Count = end.Count / 2 + 1;\\n                end.Next = pointer;\\n                end = pointer;\\n            }\\n        }\\n\\n        /// <summary>\\n        /// Help method. Get all list inside to check the state.\\n        /// </summary>\\n        /// <returns>Items from all nodes.</returns>\\n        public IEnumerable<int> GetRolledItems()\\n        {\\n            UnrolledLinkedListNode pointer = start;\\n            List<int> result = new();\\n\\n            while (pointer != null)\\n            {\\n                for (var i = 0; i < pointer.Count; i++)\\n                {\\n                    result.Add(pointer.Get(i));\\n                }\\n\\n                pointer = pointer.Next;\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n\"",
    "unrolled linked list node": "\"using System;\\n\\nnamespace DataStructures.UnrolledList\\n{\\n    /// <summary>\\n    /// Single node with array buffer for unrolled list.\\n    /// </summary>\\n    public class UnrolledLinkedListNode\\n    {\\n        private readonly int[] array;\\n\\n        public UnrolledLinkedListNode(int nodeSize)\\n        {\\n            Next = null!;\\n\\n            Count = 0;\\n            array = new int[nodeSize];\\n        }\\n\\n        public UnrolledLinkedListNode Next { get; set; }\\n\\n        public int Count { get; set; }\\n\\n        /// <summary>\\n        /// Set new item in array buffer.\\n        /// </summary>\\n        /// <param name=\\\"pos\\\">Index in array.</param>\\n        /// <param name=\\\"val\\\">The entered value.</param>\\n        /// <exception cref=\\\"ArgumentException\\\">Index is out of scope.</exception>\\n        public void Set(int pos, int val)\\n        {\\n            if (pos < 0 || pos > array.Length - 1)\\n            {\\n                throw new ArgumentException(\\\"Position is out of size\\\", nameof(pos));\\n            }\\n\\n            array[pos] = val;\\n            Count++;\\n        }\\n\\n        /// <summary>\\n        /// Get item from array buffer.\\n        /// </summary>\\n        /// <param name=\\\"pos\\\">Index in array.</param>\\n        /// <exception cref=\\\"ArgumentException\\\">Index is out of scope.</exception>\\n        public int Get(int pos)\\n        {\\n            if (pos < 0 || pos > array.Length - 1)\\n            {\\n                throw new ArgumentException(\\\"Position is out of size\\\", nameof(pos));\\n            }\\n\\n            return array[pos];\\n        }\\n    }\\n}\\n\"",
    "item not found exception": "\"using System;\\n\\nnamespace Utilities.Exceptions\\n{\\n    /// <summary>\\n    ///     Signs that sequence doesn't contain any items that one was looking for.\\n    /// </summary>\\n    public class ItemNotFoundException : ApplicationException\\n    {\\n    }\\n}\\n\"",
    "dictionary extensions": "\"using System.Collections.Generic;\\n\\nnamespace Utilities.Extensions\\n{\\n    public static class DictionaryExtensions\\n    {\\n        public static void AddMany<TKey, TValue>(\\n            this Dictionary<TKey, TValue> keys,\\n            IEnumerable<(TKey, TValue)> enumerable) where TKey : notnull\\n        {\\n            foreach (var (key, value) in enumerable)\\n            {\\n                keys.Add(key, value);\\n            }\\n        }\\n    }\\n}\\n\"",
    "matrix extensions": "\"using System;\\n\\nnamespace Utilities.Extensions\\n{\\n    public static class MatrixExtensions\\n    {\\n        /// <summary>\\n        ///     Performs immutable dot product multiplication on source matrix to operand.\\n        /// </summary>\\n        /// <param name=\\\"source\\\">Source left matrix.</param>\\n        /// <param name=\\\"operand\\\">Operand right matrix.</param>\\n        /// <returns>Dot product result.</returns>\\n        /// <exception cref=\\\"InvalidOperationException\\\">The width of a first operand should match the height of a second.</exception>\\n        public static double[,] Multiply(this double[,] source, double[,] operand)\\n        {\\n            if (source.GetLength(1) != operand.GetLength(0))\\n            {\\n                throw new InvalidOperationException(\\n                    \\\"The width of a first operand should match the height of a second.\\\");\\n            }\\n\\n            var result = new double[source.GetLength(0), operand.GetLength(1)];\\n\\n            for (var i = 0; i < result.GetLength(0); i++)\\n            {\\n                for (var j = 0; j < result.GetLength(1); j++)\\n                {\\n                    double elementProduct = 0;\\n\\n                    for (var k = 0; k < source.GetLength(1); k++)\\n                    {\\n                        elementProduct += source[i, k] * operand[k, j];\\n                    }\\n\\n                    result[i, j] = elementProduct;\\n                }\\n            }\\n\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Makes a copy of a matrix. Changes to the copy should not affect the original.\\n        /// </summary>\\n        /// <param name=\\\"matrix\\\">The matrix.</param>\\n        /// <returns>A copy of the matrix.</returns>\\n        public static double[,] Copy(this double[,] matrix)\\n        {\\n            var result = new double[matrix.GetLength(0), matrix.GetLength(1)];\\n            for (var i = 0; i < matrix.GetLength(0); i++)\\n            {\\n                for (var j = 0; j < matrix.GetLength(1); j++)\\n                {\\n                    result[i, j] = matrix[i, j];\\n                }\\n            }\\n\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Transposes a matrix.\\n        /// </summary>\\n        /// <param name=\\\"matrix\\\">The matrix.</param>\\n        /// <returns>The transposed matrix.</returns>\\n        public static double[,] Transpose(this double[,] matrix)\\n        {\\n            var result = new double[matrix.GetLength(1), matrix.GetLength(0)];\\n            for (var i = 0; i < matrix.GetLength(0); i++)\\n            {\\n                for (var j = 0; j < matrix.GetLength(1); j++)\\n                {\\n                    result[j, i] = matrix[i, j];\\n                }\\n            }\\n\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Multiplies a matrix by a vector.\\n        /// </summary>\\n        /// <param name=\\\"matrix\\\">The matrix.</param>\\n        /// <param name=\\\"vector\\\">The vector.</param>\\n        /// <returns>The product of the matrix and the vector, which is a vector.</returns>\\n        /// <exception cref=\\\"ArgumentException\\\">Dimensions of matrix and vector do not match.</exception>\\n        public static double[] MultiplyVector(this double[,] matrix, double[] vector)\\n        {\\n            var vectorReshaped = new double[vector.Length, 1];\\n            for (var i = 0; i < vector.Length; i++)\\n            {\\n                vectorReshaped[i, 0] = vector[i];\\n            }\\n\\n            var resultMatrix = matrix.Multiply(vectorReshaped);\\n            var result = new double[resultMatrix.GetLength(0)];\\n            for (var i = 0; i < result.Length; i++)\\n            {\\n                result[i] = resultMatrix[i, 0];\\n            }\\n\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Performs matrix subtraction.\\n        /// </summary>\\n        /// <param name=\\\"lhs\\\">The LHS matrix.</param>\\n        /// <param name=\\\"rhs\\\">The RHS matrix.</param>\\n        /// <returns>The difference of the two matrices.</returns>\\n        /// <exception cref=\\\"ArgumentException\\\">Dimensions of matrices do not match.</exception>\\n        public static double[,] Subtract(this double[,] lhs, double[,] rhs)\\n        {\\n            if (lhs.GetLength(0) != rhs.GetLength(0) ||\\n                lhs.GetLength(1) != rhs.GetLength(1))\\n            {\\n                throw new ArgumentException(\\\"Dimensions of matrices must be the same\\\");\\n            }\\n\\n            var result = new double[lhs.GetLength(0), lhs.GetLength(1)];\\n            for (var i = 0; i < lhs.GetLength(0); i++)\\n            {\\n                for (var j = 0; j < lhs.GetLength(1); j++)\\n                {\\n                    result[i, j] = lhs[i, j] - rhs[i, j];\\n                }\\n            }\\n\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Performs an element by element comparison on both matrices.\\n        /// </summary>\\n        /// <param name=\\\"source\\\">Source left matrix.</param>\\n        /// <param name=\\\"operand\\\">Openrand right matrix.</param>\\n        /// <returns>true: if all elements are the same; false otherwise.</returns>\\n        public static bool IsEqual(this double[,] source, double[,] operand)\\n        {\\n            if (source.Length != operand.Length ||\\n                source.GetLength(0) != operand.GetLength(0) ||\\n                source.GetLength(1) != operand.GetLength(1))\\n            {\\n                return false;\\n            }\\n\\n            for (var i = 0; i < source.GetLength(0); i++)\\n            {\\n                for (var j = 0; j < source.GetLength(0); j++)\\n                {\\n                    if (Math.Abs(source[i, j] - operand[i, j]) >= 0.0001)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n\\n            return true;\\n        }\\n\\n        /// <summary>\\n        ///     Performs a round operation on every element of the input matrix up to the neareast integer.\\n        /// </summary>\\n        /// <param name=\\\"source\\\">Input matrix.</param>\\n        /// <returns>Matrix with rounded elements.</returns>\\n        public static double[,] RoundToNextInt(this double[,] source)\\n        {\\n            var rows = source.GetLength(0);\\n            var cols = source.GetLength(1);\\n\\n            var result = new double[rows, cols];\\n\\n            for (var i = 0; i < rows; i++)\\n            {\\n                for (var j = 0; j < cols; j++)\\n                {\\n                    result[i, j] = Math.Round(source[i, j]);\\n                }\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n\"",
    "random extensions": "\"using System;\\nusing System.Linq;\\n\\nnamespace Utilities.Extensions\\n{\\n    public static class RandomExtensions\\n    {\\n        public static double[] NextVector(this Random rand, int size)\\n        {\\n            var vector = Enumerable.Range(0, size)\\n                .Select(_ => rand.NextDouble()).ToArray();\\n            var norm = vector.Magnitude();\\n            return vector.Select(x => x / norm).ToArray();\\n        }\\n    }\\n}\\n\"",
    "vector extensions": "\"using System;\\n\\nnamespace Utilities.Extensions\\n{\\n    public static class VectorExtensions\\n    {\\n        /// <summary>\\n        ///     Makes a copy of a vector. Changes to the copy should not affect the original.\\n        /// </summary>\\n        /// <param name=\\\"vector\\\">The vector.</param>\\n        /// <returns>The copy.</returns>\\n        public static double[] Copy(this double[] vector)\\n        {\\n            var result = new double[vector.Length];\\n            for (var i = 0; i < vector.Length; i++)\\n            {\\n                result[i] = vector[i];\\n            }\\n\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Computes the outer product of two vectors.\\n        /// </summary>\\n        /// <param name=\\\"lhs\\\">The LHS vector.</param>\\n        /// <param name=\\\"rhs\\\">The RHS vector.</param>\\n        /// <returns>The outer product of the two vector.</returns>\\n        public static double[,] OuterProduct(this double[] lhs, double[] rhs)\\n        {\\n            var result = new double[lhs.Length, rhs.Length];\\n            for (var i = 0; i < lhs.Length; i++)\\n            {\\n                for (var j = 0; j < rhs.Length; j++)\\n                {\\n                    result[i, j] = lhs[i] * rhs[j];\\n                }\\n            }\\n\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Computes the dot product of two vectors.\\n        /// </summary>\\n        /// <param name=\\\"lhs\\\">The LHS vector.</param>\\n        /// <param name=\\\"rhs\\\">The RHS vector.</param>\\n        /// <returns>The dot product of the two vector.</returns>\\n        /// <exception cref=\\\"ArgumentException\\\">Dimensions of vectors do not match.</exception>\\n        public static double Dot(this double[] lhs, double[] rhs)\\n        {\\n            if (lhs.Length != rhs.Length)\\n            {\\n                throw new ArgumentException(\\\"Dot product arguments must have same dimension\\\");\\n            }\\n\\n            double result = 0;\\n            for (var i = 0; i < lhs.Length; i++)\\n            {\\n                result += lhs[i] * rhs[i];\\n            }\\n\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Computes the magnitude of a vector.\\n        /// </summary>\\n        /// <param name=\\\"vector\\\">The vector.</param>\\n        /// <returns>The magnitude.</returns>\\n        public static double Magnitude(this double[] vector)\\n        {\\n            var magnitude = Dot(vector, vector);\\n            magnitude = Math.Sqrt(magnitude);\\n            return magnitude;\\n        }\\n\\n        /// <summary>\\n        ///     Returns the scaled vector.\\n        /// </summary>\\n        /// <param name=\\\"vector\\\">The vector.</param>\\n        /// <param name=\\\"factor\\\">Scale factor.</param>\\n        /// <returns>The unit vector.</returns>\\n        public static double[] Scale(this double[] vector, double factor)\\n        {\\n            var result = new double[vector.Length];\\n            for (var i = 0; i < vector.Length; i++)\\n            {\\n                result[i] = vector[i] * factor;\\n            }\\n\\n            return result;\\n        }\\n\\n        /// <summary>\\n        ///     Transpose 1d row vector to column vector.\\n        /// </summary>\\n        /// <param name=\\\"source\\\">Input 1d vector.</param>\\n        /// <returns>Column vector.</returns>\\n        public static double[,] ToColumnVector(this double[] source)\\n        {\\n            var columnVector = new double[source.Length, 1];\\n\\n            for (var i = 0; i < source.Length; i++)\\n            {\\n                columnVector[i, 0] = source[i];\\n            }\\n\\n            return columnVector;\\n        }\\n\\n        /// <summary>\\n        ///     Transpose column vector to 1d row vector.\\n        /// </summary>\\n        /// <param name=\\\"source\\\">Input column vector.</param>\\n        /// <returns>Row vector.</returns>\\n        /// <exception cref=\\\"InvalidOperationException\\\">The column vector should have only 1 element in width.</exception>\\n        public static double[] ToRowVector(this double[,] source)\\n        {\\n            if (source.GetLength(1) != 1)\\n            {\\n                throw new InvalidOperationException(\\\"The column vector should have only 1 element in width.\\\");\\n            }\\n\\n            var rowVector = new double[source.Length];\\n\\n            for (var i = 0; i < rowVector.Length; i++)\\n            {\\n                rowVector[i] = source[i, 0];\\n            }\\n\\n            return rowVector;\\n        }\\n\\n        /// <summary>\\n        ///     Generates a diagonal matrix from an specified vector.\\n        /// </summary>\\n        /// <param name=\\\"vector\\\">The input vector.</param>\\n        /// <returns>A Diagonal matrix.</returns>\\n        public static double[,] ToDiagonalMatrix(this double[] vector)\\n        {\\n            var len = vector.Length;\\n            var result = new double[len, len];\\n\\n            for (var i = 0; i < len; i++)\\n            {\\n                result[i, i] = vector[i];\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n\""
  }
}
