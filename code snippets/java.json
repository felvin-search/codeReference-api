{
  "java": {
    "iir filter": "\"package com.thealgorithms.audiofilters;\\n\\n/**\\n * N-Order IIR Filter Assumes inputs are normalized to [-1, 1]\\n *\\n * Based on the difference equation from\\n * https://en.wikipedia.org/wiki/Infinite_impulse_response\\n */\\npublic class IIRFilter {\\n\\n    private final int order;\\n    private final double[] coeffsA;\\n    private final double[] coeffsB;\\n    private final double[] historyX;\\n    private final double[] historyY;\\n\\n    /**\\n     * Construct an IIR Filter\\n     *\\n     * @param order the filter's order\\n     * @throws IllegalArgumentException if order is zero or less\\n     */\\n    public IIRFilter(int order) throws IllegalArgumentException {\\n        if (order < 1) {\\n            throw new IllegalArgumentException(\\\"order must be greater than zero\\\");\\n        }\\n\\n        this.order = order;\\n        coeffsA = new double[order + 1];\\n        coeffsB = new double[order + 1];\\n\\n        // Sane defaults\\n        coeffsA[0] = 1.0;\\n        coeffsB[0] = 1.0;\\n\\n        historyX = new double[order];\\n        historyY = new double[order];\\n    }\\n\\n    /**\\n     * Set coefficients\\n     *\\n     * @param aCoeffs Denominator coefficients\\n     * @param bCoeffs Numerator coefficients\\n     * @throws IllegalArgumentException if {@code aCoeffs} or {@code bCoeffs} is\\n     * not of size {@code order}, or if {@code aCoeffs[0]} is 0.0\\n     */\\n    public void setCoeffs(double[] aCoeffs, double[] bCoeffs) throws IllegalArgumentException {\\n        if (aCoeffs.length != order) {\\n            throw new IllegalArgumentException(\\\"aCoeffs must be of size \\\" + order + \\\", got \\\" + aCoeffs.length);\\n        }\\n\\n        if (aCoeffs[0] == 0.0) {\\n            throw new IllegalArgumentException(\\\"aCoeffs.get(0) must not be zero\\\");\\n        }\\n\\n        if (bCoeffs.length != order) {\\n            throw new IllegalArgumentException(\\\"bCoeffs must be of size \\\" + order + \\\", got \\\" + bCoeffs.length);\\n        }\\n\\n        for (int i = 0; i <= order; i++) {\\n            coeffsA[i] = aCoeffs[i];\\n            coeffsB[i] = bCoeffs[i];\\n        }\\n    }\\n\\n    /**\\n     * Process a single sample\\n     *\\n     * @param sample the sample to process\\n     * @return the processed sample\\n     */\\n    public double process(double sample) {\\n        double result = 0.0;\\n\\n        // Process\\n        for (int i = 1; i <= order; i++) {\\n            result += (coeffsB[i] * historyX[i - 1] - coeffsA[i] * historyY[i - 1]);\\n        }\\n        result = (result + coeffsB[0] * sample) / coeffsA[0];\\n\\n        // Feedback\\n        for (int i = order - 1; i > 0; i--) {\\n            historyX[i] = historyX[i - 1];\\n            historyY[i] = historyY[i - 1];\\n        }\\n\\n        historyX[0] = sample;\\n        historyY[0] = result;\\n\\n        return result;\\n    }\\n}\\n\"",
    "knights tour": "\"package com.thealgorithms.backtracking;\\n\\nimport java.util.*;\\n\\n/*\\n    * Problem Statement: -\\n    \\n    Given a N*N board with the Knight placed on the first block of an empty board. Moving according to the rules of\\n    chess knight must visit each square exactly once. Print the order of each cell in which they are visited.\\n\\n    Example: -\\n\\n    Input : N = 8\\n\\n    Output:\\n        0  59  38  33  30  17   8  63\\n        37  34  31  60   9  62  29  16\\n        58   1  36  39  32  27  18   7\\n        35  48  41  26  61  10  15  28\\n        42  57   2  49  40  23   6  19\\n        47  50  45  54  25  20  11  14\\n        56  43  52   3  22  13  24   5\\n        51  46  55  44  53   4  21  12\\n\\n */\\npublic class KnightsTour {\\n\\n    private final static int base = 12;\\n    private final static int[][] moves = {{1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}}; // Possible moves by knight on chess\\n    private static int[][] grid;    // chess grid\\n    private static int total;   // total squares in chess\\n\\n    public static void main(String[] args) {\\n        grid = new int[base][base];\\n        total = (base - 4) * (base - 4);\\n\\n        for (int r = 0; r < base; r++) {\\n            for (int c = 0; c < base; c++) {\\n                if (r < 2 || r > base - 3 || c < 2 || c > base - 3) {\\n                    grid[r][c] = -1;\\n                }\\n            }\\n        }\\n\\n        int row = 2 + (int) (Math.random() * (base - 4));\\n        int col = 2 + (int) (Math.random() * (base - 4));\\n\\n        grid[row][col] = 1;\\n\\n        if (solve(row, col, 2)) {\\n            printResult();\\n        } else {\\n            System.out.println(\\\"no result\\\");\\n        }\\n\\n    }\\n\\n    // Return True when solvable\\n    private static boolean solve(int row, int column, int count) {\\n        if (count > total) {\\n            return true;\\n        }\\n\\n        List<int[]> neighbor = neighbors(row, column);\\n\\n        if (neighbor.isEmpty() && count != total) {\\n            return false;\\n        }\\n\\n        Collections.sort(neighbor, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return a[2] - b[2];\\n            }\\n        });\\n\\n        for (int[] nb : neighbor) {\\n            row = nb[0];\\n            column = nb[1];\\n            grid[row][column] = count;\\n            if (!orphanDetected(count, row, column) && solve(row, column, count + 1)) {\\n                return true;\\n            }\\n            grid[row][column] = 0;\\n        }\\n\\n        return false;\\n    }\\n\\n    // Returns List of neighbours\\n    private static List<int[]> neighbors(int row, int column) {\\n        List<int[]> neighbour = new ArrayList<>();\\n\\n        for (int[] m : moves) {\\n            int x = m[0];\\n            int y = m[1];\\n            if (grid[row + y][column + x] == 0) {\\n                int num = countNeighbors(row + y, column + x);\\n                neighbour.add(new int[]{row + y, column + x, num});\\n            }\\n        }\\n        return neighbour;\\n    }\\n\\n    // Returns the total count of neighbors\\n    private static int countNeighbors(int row, int column) {\\n        int num = 0;\\n        for (int[] m : moves) {\\n            if (grid[row + m[1]][column + m[0]] == 0) {\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n\\n    // Returns true if it is orphan\\n    private static boolean orphanDetected(int count, int row, int column) {\\n        if (count < total - 1) {\\n            List<int[]> neighbor = neighbors(row, column);\\n            for (int[] nb : neighbor) {\\n                if (countNeighbors(nb[0], nb[1]) == 0) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // Prints the result grid\\n    private static void printResult() {\\n        for (int[] row : grid) {\\n            for (int i : row) {\\n                if (i == -1) {\\n                    continue;\\n                }\\n                System.out.printf(\\\"%2d \\\", i);\\n            }\\n            System.out.println();\\n        }\\n    }\\n}\\n\"",
    "n queens": "\"package com.thealgorithms.backtracking;\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\n/**\\n * Problem statement: Given a N x N chess board. Return all arrangements in\\n * which N queens can be placed on the board such no two queens attack each\\n * other. Ex. N = 6 Solution= There are 4 possible ways Arrangement: 1 \\\".Q....\\\",\\n * \\\"...Q..\\\", \\\".....Q\\\", \\\"Q.....\\\", \\\"..Q...\\\", \\\"....Q.\\\"\\n * <p>\\n * Arrangement: 2 \\\"..Q...\\\", \\\".....Q\\\", \\\".Q....\\\", \\\"....Q.\\\", \\\"Q.....\\\", \\\"...Q..\\\"\\n * <p>\\n * Arrangement: 3 \\\"...Q..\\\", \\\"Q.....\\\", \\\"....Q.\\\", \\\".Q....\\\", \\\".....Q\\\", \\\"..Q...\\\"\\n * <p>\\n * Arrangement: 4 \\\"....Q.\\\", \\\"..Q...\\\", \\\"Q.....\\\", \\\".....Q\\\", \\\"...Q..\\\", \\\".Q....\\\"\\n *\\n * Solution: Brute Force approach:\\n *\\n * Generate all possible arrangement to place N queens on N*N board. Check each\\n * board if queens are placed safely. If it is safe, include arrangement in\\n * solution set. Otherwise ignore it\\n *\\n * Optimized solution: This can be solved using backtracking in below steps\\n *\\n * Start with first column and place queen on first row Try placing queen in a\\n * row on second column If placing second queen in second column attacks any of\\n * the previous queens, change the row in second column otherwise move to next\\n * column and try to place next queen In case if there is no rows where a queen\\n * can be placed such that it doesn't attack previous queens, then go back to\\n * previous column and change row of previous queen. Keep doing this until last\\n * queen is not placed safely. If there is no such way then return an empty list\\n * as solution\\n */\\npublic class NQueens {\\n\\n    public static void main(String[] args) {\\n        placeQueens(1);\\n        placeQueens(2);\\n        placeQueens(3);\\n        placeQueens(4);\\n        placeQueens(5);\\n        placeQueens(6);\\n    }\\n\\n    public static void placeQueens(final int queens) {\\n        List<List<String>> arrangements = new ArrayList<List<String>>();\\n        getSolution(queens, arrangements, new int[queens], 0);\\n        if (arrangements.isEmpty()) {\\n            System.out.println(\\\"There is no way to place \\\" + queens + \\\" queens on board of size \\\" + queens + \\\"x\\\" + queens);\\n        } else {\\n            System.out.println(\\\"Arrangement for placing \\\" + queens + \\\" queens\\\");\\n        }\\n        arrangements.forEach(arrangement -> {\\n            arrangement.forEach(row -> System.out.println(row));\\n            System.out.println();\\n        });\\n    }\\n\\n    /**\\n     * This is backtracking function which tries to place queen recursively\\n     *\\n     * @param boardSize: size of chess board\\n     * @param solutions: this holds all possible arrangements\\n     * @param columns: columns[i] = rowId where queen is placed in ith column.\\n     * @param columnIndex: This is the column in which queen is being placed\\n     */\\n    private static void getSolution(int boardSize, List<List<String>> solutions, int[] columns, int columnIndex) {\\n        if (columnIndex == boardSize) {\\n            // this means that all queens have been placed\\n            List<String> sol = new ArrayList<String>();\\n            for (int i = 0; i < boardSize; i++) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 0; j < boardSize; j++) {\\n                    sb.append(j == columns[i] ? \\\"Q\\\" : \\\".\\\");\\n                }\\n                sol.add(sb.toString());\\n            }\\n            solutions.add(sol);\\n            return;\\n        }\\n\\n        // This loop tries to place queen in a row one by one\\n        for (int rowIndex = 0; rowIndex < boardSize; rowIndex++) {\\n            columns[columnIndex] = rowIndex;\\n            if (isPlacedCorrectly(columns, rowIndex, columnIndex)) {\\n                // If queen is placed successfully at rowIndex in column=columnIndex then try placing queen in next column\\n                getSolution(boardSize, solutions, columns, columnIndex + 1);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * This function checks if queen can be placed at row = rowIndex in column =\\n     * columnIndex safely\\n     *\\n     * @param columns: columns[i] = rowId where queen is placed in ith column.\\n     * @param rowIndex: row in which queen has to be placed\\n     * @param columnIndex: column in which queen is being placed\\n     * @return true: if queen can be placed safely false: otherwise\\n     */\\n    private static boolean isPlacedCorrectly(int[] columns, int rowIndex, int columnIndex) {\\n        for (int i = 0; i < columnIndex; i++) {\\n            int diff = Math.abs(columns[i] - rowIndex);\\n            if (diff == 0 || columnIndex - i == diff) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"",
    "power sum": "\"package com.thealgorithms.backtracking;\\n\\nimport java.util.Scanner;\\n\\n/*\\n * Problem Statement :\\n * Find the number of ways that a given integer, N , can be expressed as the sum of the Xth powers of unique, natural numbers.\\n * For example, if N=100 and X=3, we have to find all combinations of unique cubes adding up to 100. The only solution is 1^3+2^3+3^3+4^3.\\n * Therefore output will be 1.\\n */\\npublic class PowerSum {\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.println(\\\"Enter the number and the power\\\");\\n        int N = sc.nextInt();\\n        int X = sc.nextInt();\\n        PowerSum ps = new PowerSum();\\n        int count = ps.powSum(N, X);\\n        //printing the answer.\\n        System.out.println(\\\"Number of combinations of different natural number's raised to \\\" + X + \\\" having sum \\\" + N + \\\" are : \\\");\\n        System.out.println(count);\\n        sc.close();\\n    }\\n    private int count = 0, sum = 0;\\n\\n    public int powSum(int N, int X) {\\n        Sum(N, X, 1);\\n        return count;\\n    }\\n\\n    //here i is the natural number which will be raised by X and added in sum.\\n    public void Sum(int N, int X, int i) {\\n        //if sum is equal to N that is one of our answer and count is increased.\\n        if (sum == N) {\\n            count++;\\n            return;\\n        } //we will be adding next natural number raised to X only if on adding it in sum the result is less than N.\\n        else if (sum + power(i, X) <= N) {\\n            sum += power(i, X);\\n            Sum(N, X, i + 1);\\n            //backtracking and removing the number added last since no possible combination is there with it.\\n            sum -= power(i, X);\\n        }\\n        if (power(i, X) < N) {\\n            //calling the sum function with next natural number after backtracking if when it is raised to X is still less than X.\\n            Sum(N, X, i + 1);\\n        }\\n    }\\n\\n    //creating a separate power function so that it can be used again and again when required. \\n    private int power(int a, int b) {\\n        return (int) Math.pow(a, b);\\n    }\\n}\\n\"",
    "aes": "\"package com.thealgorithms.ciphers;\\n\\nimport java.math.BigInteger;\\nimport java.util.Scanner;\\n\\n/**\\n * This class is build to demonstrate the application of the AES-algorithm on a\\n * single 128-Bit block of data.\\n */\\npublic class AES {\\n\\n    /**\\n     * Precalculated values for x to the power of 2 in Rijndaels galois field.\\n     * Used as 'RCON' during the key expansion.\\n     */\\n    private static final int[] RCON = {\\n        0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,\\n        0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,\\n        0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,\\n        0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,\\n        0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,\\n        0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,\\n        0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,\\n        0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,\\n        0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,\\n        0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,\\n        0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,\\n        0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,\\n        0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,\\n        0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,\\n        0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,\\n        0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d\\n    };\\n\\n    /**\\n     * Rijndael S-box Substitution table used for encryption in the subBytes\\n     * step, as well as the key expansion.\\n     */\\n    private static final int[] SBOX = {\\n        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16\\n    };\\n\\n    /**\\n     * Inverse Rijndael S-box Substitution table used for decryption in the\\n     * subBytesDec step.\\n     */\\n    private static final int[] INVERSE_SBOX = {\\n        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\\n        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\\n        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\\n        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\\n        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\\n        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\\n        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\\n        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\\n        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\\n        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\\n        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\\n        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\\n        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\\n        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\\n        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\\n        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D\\n    };\\n\\n    /**\\n     * Precalculated lookup table for galois field multiplication by 2 used in\\n     * the MixColums step during encryption.\\n     */\\n    private static final int[] MULT2 = {\\n        0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,\\n        0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,\\n        0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,\\n        0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,\\n        0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,\\n        0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,\\n        0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,\\n        0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,\\n        0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,\\n        0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,\\n        0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,\\n        0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,\\n        0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,\\n        0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,\\n        0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,\\n        0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5\\n    };\\n\\n    /**\\n     * Precalculated lookup table for galois field multiplication by 3 used in\\n     * the MixColums step during encryption.\\n     */\\n    private static final int[] MULT3 = {\\n        0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,\\n        0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,\\n        0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,\\n        0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,\\n        0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,\\n        0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,\\n        0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,\\n        0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,\\n        0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,\\n        0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,\\n        0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,\\n        0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,\\n        0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,\\n        0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,\\n        0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,\\n        0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a\\n    };\\n\\n    /**\\n     * Precalculated lookup table for galois field multiplication by 9 used in\\n     * the MixColums step during decryption.\\n     */\\n    private static final int[] MULT9 = {\\n        0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,\\n        0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,\\n        0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,\\n        0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,\\n        0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,\\n        0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,\\n        0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,\\n        0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,\\n        0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,\\n        0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,\\n        0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,\\n        0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,\\n        0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,\\n        0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,\\n        0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,\\n        0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46\\n    };\\n\\n    /**\\n     * Precalculated lookup table for galois field multiplication by 11 used in\\n     * the MixColums step during decryption.\\n     */\\n    private static final int[] MULT11 = {\\n        0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,\\n        0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,\\n        0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,\\n        0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,\\n        0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,\\n        0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,\\n        0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,\\n        0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,\\n        0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,\\n        0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,\\n        0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,\\n        0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,\\n        0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,\\n        0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,\\n        0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,\\n        0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3\\n    };\\n\\n    /**\\n     * Precalculated lookup table for galois field multiplication by 13 used in\\n     * the MixColums step during decryption.\\n     */\\n    private static final int[] MULT13 = {\\n        0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,\\n        0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,\\n        0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,\\n        0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,\\n        0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,\\n        0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,\\n        0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,\\n        0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,\\n        0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,\\n        0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,\\n        0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,\\n        0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,\\n        0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,\\n        0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,\\n        0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,\\n        0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97\\n    };\\n\\n    /**\\n     * Precalculated lookup table for galois field multiplication by 14 used in\\n     * the MixColums step during decryption.\\n     */\\n    private static final int[] MULT14 = {\\n        0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,\\n        0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,\\n        0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,\\n        0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,\\n        0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,\\n        0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,\\n        0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,\\n        0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,\\n        0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,\\n        0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,\\n        0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,\\n        0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,\\n        0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,\\n        0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,\\n        0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,\\n        0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d\\n    };\\n\\n    /**\\n     * Subroutine of the Rijndael key expansion.\\n     */\\n    public static BigInteger scheduleCore(BigInteger t, int rconCounter) {\\n        StringBuilder rBytes = new StringBuilder(t.toString(16));\\n\\n        // Add zero padding\\n        while (rBytes.length() < 8) {\\n            rBytes.insert(0, \\\"0\\\");\\n        }\\n\\n        // rotate the first 16 bits to the back\\n        String rotatingBytes = rBytes.substring(0, 2);\\n        String fixedBytes = rBytes.substring(2);\\n\\n        rBytes = new StringBuilder(fixedBytes + rotatingBytes);\\n\\n        // apply S-Box to all 8-Bit Substrings\\n        for (int i = 0; i < 4; i++) {\\n            StringBuilder currentByteBits = new StringBuilder(rBytes.substring(i * 2, (i + 1) * 2));\\n\\n            int currentByte = Integer.parseInt(currentByteBits.toString(), 16);\\n            currentByte = SBOX[currentByte];\\n\\n            // add the current RCON value to the first byte\\n            if (i == 0) {\\n                currentByte = currentByte ^ RCON[rconCounter];\\n            }\\n\\n            currentByteBits = new StringBuilder(Integer.toHexString(currentByte));\\n\\n            // Add zero padding\\n            while (currentByteBits.length() < 2) {\\n                currentByteBits.insert(0, '0');\\n            }\\n\\n            // replace bytes in original string\\n            rBytes = new StringBuilder(rBytes.substring(0, i * 2) + currentByteBits + rBytes.substring((i + 1) * 2));\\n        }\\n\\n        // t = new BigInteger(rBytes, 16);\\n        // return t;\\n        return new BigInteger(rBytes.toString(), 16);\\n    }\\n\\n    /**\\n     * Returns an array of 10 + 1 round keys that are calculated by using\\n     * Rijndael key schedule\\n     *\\n     * @return array of 10 + 1 round keys\\n     */\\n    public static BigInteger[] keyExpansion(BigInteger initialKey) {\\n        BigInteger[] roundKeys = {\\n            initialKey,\\n            new BigInteger(\\\"0\\\"),\\n            new BigInteger(\\\"0\\\"),\\n            new BigInteger(\\\"0\\\"),\\n            new BigInteger(\\\"0\\\"),\\n            new BigInteger(\\\"0\\\"),\\n            new BigInteger(\\\"0\\\"),\\n            new BigInteger(\\\"0\\\"),\\n            new BigInteger(\\\"0\\\"),\\n            new BigInteger(\\\"0\\\"),\\n            new BigInteger(\\\"0\\\"),};\\n\\n        // initialize rcon iteration\\n        int rconCounter = 1;\\n\\n        for (int i = 1; i < 11; i++) {\\n\\n            // get the previous 32 bits the key\\n            BigInteger t = roundKeys[i - 1].remainder(new BigInteger(\\\"100000000\\\", 16));\\n\\n            // split previous key into 8-bit segments\\n            BigInteger[] prevKey = {\\n                roundKeys[i - 1].remainder(new BigInteger(\\\"100000000\\\", 16)),\\n                roundKeys[i - 1]\\n                .remainder(new BigInteger(\\\"10000000000000000\\\", 16))\\n                .divide(new BigInteger(\\\"100000000\\\", 16)),\\n                roundKeys[i - 1]\\n                .remainder(new BigInteger(\\\"1000000000000000000000000\\\", 16))\\n                .divide(new BigInteger(\\\"10000000000000000\\\", 16)),\\n                roundKeys[i - 1].divide(new BigInteger(\\\"1000000000000000000000000\\\", 16)),};\\n\\n            // run schedule core\\n            t = scheduleCore(t, rconCounter);\\n            rconCounter += 1;\\n\\n            // Calculate partial round key\\n            BigInteger t0 = t.xor(prevKey[3]);\\n            BigInteger t1 = t0.xor(prevKey[2]);\\n            BigInteger t2 = t1.xor(prevKey[1]);\\n            BigInteger t3 = t2.xor(prevKey[0]);\\n\\n            // Join round key segments\\n            t2 = t2.multiply(new BigInteger(\\\"100000000\\\", 16));\\n            t1 = t1.multiply(new BigInteger(\\\"10000000000000000\\\", 16));\\n            t0 = t0.multiply(new BigInteger(\\\"1000000000000000000000000\\\", 16));\\n            roundKeys[i] = t0.add(t1).add(t2).add(t3);\\n        }\\n        return roundKeys;\\n    }\\n\\n    /**\\n     * representation of the input 128-bit block as an array of 8-bit integers.\\n     *\\n     * @param block of 128-bit integers\\n     * @return array of 8-bit integers\\n     */\\n    public static int[] splitBlockIntoCells(BigInteger block) {\\n\\n        int[] cells = new int[16];\\n        StringBuilder blockBits = new StringBuilder(block.toString(2));\\n\\n        // Append leading 0 for full \\\"128-bit\\\" string\\n        while (blockBits.length() < 128) {\\n            blockBits.insert(0, '0');\\n        }\\n\\n        // split 128 to 8 bit cells\\n        for (int i = 0; i < cells.length; i++) {\\n            String cellBits = blockBits.substring(8 * i, 8 * (i + 1));\\n            cells[i] = Integer.parseInt(cellBits, 2);\\n        }\\n\\n        return cells;\\n    }\\n\\n    /**\\n     * Returns the 128-bit BigInteger representation of the input of an array of\\n     * 8-bit integers.\\n     *\\n     * @param cells that we need to merge\\n     * @return block of merged cells\\n     */\\n    public static BigInteger mergeCellsIntoBlock(int[] cells) {\\n\\n        StringBuilder blockBits = new StringBuilder();\\n        for (int i = 0; i < 16; i++) {\\n            StringBuilder cellBits = new StringBuilder(Integer.toBinaryString(cells[i]));\\n\\n            // Append leading 0 for full \\\"8-bit\\\" strings\\n            while (cellBits.length() < 8) {\\n                cellBits.insert(0, '0');\\n            }\\n\\n            blockBits.append(cellBits);\\n        }\\n\\n        return new BigInteger(blockBits.toString(), 2);\\n    }\\n\\n    /**\\n     * @return ciphertext XOR key\\n     */\\n    public static BigInteger addRoundKey(BigInteger ciphertext, BigInteger key) {\\n        return ciphertext.xor(key);\\n    }\\n\\n    /**\\n     * substitutes 8-Bit long substrings of the input using the S-Box and\\n     * returns the result.\\n     *\\n     * @return subtraction Output\\n     */\\n    public static BigInteger subBytes(BigInteger ciphertext) {\\n\\n        int[] cells = splitBlockIntoCells(ciphertext);\\n\\n        for (int i = 0; i < 16; i++) {\\n            cells[i] = SBOX[cells[i]];\\n        }\\n\\n        return mergeCellsIntoBlock(cells);\\n    }\\n\\n    /**\\n     * substitutes 8-Bit long substrings of the input using the inverse S-Box\\n     * for decryption and returns the result.\\n     *\\n     * @return subtraction Output\\n     */\\n    public static BigInteger subBytesDec(BigInteger ciphertext) {\\n\\n        int[] cells = splitBlockIntoCells(ciphertext);\\n\\n        for (int i = 0; i < 16; i++) {\\n            cells[i] = INVERSE_SBOX[cells[i]];\\n        }\\n\\n        return mergeCellsIntoBlock(cells);\\n    }\\n\\n    /**\\n     * Cell permutation step. Shifts cells within the rows of the input and\\n     * returns the result.\\n     */\\n    public static BigInteger shiftRows(BigInteger ciphertext) {\\n        int[] cells = splitBlockIntoCells(ciphertext);\\n        int[] output = new int[16];\\n\\n        // do nothing in the first row\\n        output[0] = cells[0];\\n        output[4] = cells[4];\\n        output[8] = cells[8];\\n        output[12] = cells[12];\\n\\n        // shift the second row backwards by one cell\\n        output[1] = cells[5];\\n        output[5] = cells[9];\\n        output[9] = cells[13];\\n        output[13] = cells[1];\\n\\n        // shift the third row backwards by two cell\\n        output[2] = cells[10];\\n        output[6] = cells[14];\\n        output[10] = cells[2];\\n        output[14] = cells[6];\\n\\n        // shift the forth row backwards by tree cell\\n        output[3] = cells[15];\\n        output[7] = cells[3];\\n        output[11] = cells[7];\\n        output[15] = cells[11];\\n\\n        return mergeCellsIntoBlock(output);\\n    }\\n\\n    /**\\n     * Cell permutation step for decryption . Shifts cells within the rows of\\n     * the input and returns the result.\\n     */\\n    public static BigInteger shiftRowsDec(BigInteger ciphertext) {\\n        int[] cells = splitBlockIntoCells(ciphertext);\\n        int[] output = new int[16];\\n\\n        // do nothing in the first row\\n        output[0] = cells[0];\\n        output[4] = cells[4];\\n        output[8] = cells[8];\\n        output[12] = cells[12];\\n\\n        // shift the second row forwards by one cell\\n        output[1] = cells[13];\\n        output[5] = cells[1];\\n        output[9] = cells[5];\\n        output[13] = cells[9];\\n\\n        // shift the third row forwards by two cell\\n        output[2] = cells[10];\\n        output[6] = cells[14];\\n        output[10] = cells[2];\\n        output[14] = cells[6];\\n\\n        // shift the forth row forwards by tree cell\\n        output[3] = cells[7];\\n        output[7] = cells[11];\\n        output[11] = cells[15];\\n        output[15] = cells[3];\\n\\n        return mergeCellsIntoBlock(output);\\n    }\\n\\n    /**\\n     * Applies the Rijndael MixColumns to the input and returns the result.\\n     */\\n    public static BigInteger mixColumns(BigInteger ciphertext) {\\n\\n        int[] cells = splitBlockIntoCells(ciphertext);\\n        int[] outputCells = new int[16];\\n\\n        for (int i = 0; i < 4; i++) {\\n            int[] row = {cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3]};\\n\\n            outputCells[i * 4] = MULT2[row[0]] ^ MULT3[row[1]] ^ row[2] ^ row[3];\\n            outputCells[i * 4 + 1] = row[0] ^ MULT2[row[1]] ^ MULT3[row[2]] ^ row[3];\\n            outputCells[i * 4 + 2] = row[0] ^ row[1] ^ MULT2[row[2]] ^ MULT3[row[3]];\\n            outputCells[i * 4 + 3] = MULT3[row[0]] ^ row[1] ^ row[2] ^ MULT2[row[3]];\\n        }\\n        return mergeCellsIntoBlock(outputCells);\\n    }\\n\\n    /**\\n     * Applies the inverse Rijndael MixColumns for decryption to the input and\\n     * returns the result.\\n     */\\n    public static BigInteger mixColumnsDec(BigInteger ciphertext) {\\n\\n        int[] cells = splitBlockIntoCells(ciphertext);\\n        int[] outputCells = new int[16];\\n\\n        for (int i = 0; i < 4; i++) {\\n            int[] row = {cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3]};\\n\\n            outputCells[i * 4] = MULT14[row[0]] ^ MULT11[row[1]] ^ MULT13[row[2]] ^ MULT9[row[3]];\\n            outputCells[i * 4 + 1] = MULT9[row[0]] ^ MULT14[row[1]] ^ MULT11[row[2]] ^ MULT13[row[3]];\\n            outputCells[i * 4 + 2] = MULT13[row[0]] ^ MULT9[row[1]] ^ MULT14[row[2]] ^ MULT11[row[3]];\\n            outputCells[i * 4 + 3] = MULT11[row[0]] ^ MULT13[row[1]] ^ MULT9[row[2]] ^ MULT14[row[3]];\\n        }\\n        return mergeCellsIntoBlock(outputCells);\\n    }\\n\\n    /**\\n     * Encrypts the plaintext with the key and returns the result\\n     *\\n     * @param plainText which we want to encrypt\\n     * @param key the key for encrypt\\n     * @return EncryptedText\\n     */\\n    public static BigInteger encrypt(BigInteger plainText, BigInteger key) {\\n        BigInteger[] roundKeys = keyExpansion(key);\\n\\n        // Initial round\\n        plainText = addRoundKey(plainText, roundKeys[0]);\\n\\n        // Main rounds\\n        for (int i = 1; i < 10; i++) {\\n            plainText = subBytes(plainText);\\n            plainText = shiftRows(plainText);\\n            plainText = mixColumns(plainText);\\n            plainText = addRoundKey(plainText, roundKeys[i]);\\n        }\\n\\n        // Final round\\n        plainText = subBytes(plainText);\\n        plainText = shiftRows(plainText);\\n        plainText = addRoundKey(plainText, roundKeys[10]);\\n\\n        return plainText;\\n    }\\n\\n    /**\\n     * Decrypts the ciphertext with the key and returns the result\\n     *\\n     * @param cipherText The Encrypted text which we want to decrypt\\n     * @return decryptedText\\n     */\\n    public static BigInteger decrypt(BigInteger cipherText, BigInteger key) {\\n\\n        BigInteger[] roundKeys = keyExpansion(key);\\n\\n        // Invert final round\\n        cipherText = addRoundKey(cipherText, roundKeys[10]);\\n        cipherText = shiftRowsDec(cipherText);\\n        cipherText = subBytesDec(cipherText);\\n\\n        // Invert main rounds\\n        for (int i = 9; i > 0; i--) {\\n            cipherText = addRoundKey(cipherText, roundKeys[i]);\\n            cipherText = mixColumnsDec(cipherText);\\n            cipherText = shiftRowsDec(cipherText);\\n            cipherText = subBytesDec(cipherText);\\n        }\\n\\n        // Invert initial round\\n        cipherText = addRoundKey(cipherText, roundKeys[0]);\\n\\n        return cipherText;\\n    }\\n\\n    public static void main(String[] args) {\\n\\n        try (Scanner input = new Scanner(System.in)) {\\n            System.out.println(\\\"Enter (e) letter for encrpyt or (d) letter for decrypt :\\\");\\n            char choice = input.nextLine().charAt(0);\\n            String in;\\n            switch (choice) {\\n                case 'E', 'e' -> {\\n                    System.out.println(\\\"Choose a plaintext block (128-Bit Integer in base 16):\\\");\\n                    in = input.nextLine();\\n                    BigInteger plaintext = new BigInteger(in, 16);\\n                    System.out.println(\\\"Choose a Key (128-Bit Integer in base 16):\\\");\\n                    in = input.nextLine();\\n                    BigInteger encryptionKey = new BigInteger(in, 16);\\n                    System.out.println(\\n                            \\\"The encrypted message is: \\\\n\\\" + encrypt(plaintext, encryptionKey).toString(16));\\n                }\\n                case 'D', 'd' -> {\\n                    System.out.println(\\\"Enter your ciphertext block (128-Bit Integer in base 16):\\\");\\n                    in = input.nextLine();\\n                    BigInteger ciphertext = new BigInteger(in, 16);\\n                    System.out.println(\\\"Choose a Key (128-Bit Integer in base 16):\\\");\\n                    in = input.nextLine();\\n                    BigInteger decryptionKey = new BigInteger(in, 16);\\n                    System.out.println(\\n                            \\\"The deciphered message is:\\\\n\\\" + decrypt(ciphertext, decryptionKey).toString(16));\\n                }\\n                default ->\\n                    System.out.println(\\\"** End **\\\");\\n            }\\n        }\\n    }\\n}\\n\"",
    "a e s encryption": "\"package com.thealgorithms.ciphers;\\n\\nimport javax.crypto.*;\\nimport java.security.InvalidKeyException;\\nimport java.security.NoSuchAlgorithmException;\\n\\n/**\\n * This example program shows how AES encryption and decryption can be done in\\n * Java. Please note that secret key and encrypted text is unreadable binary and\\n * hence in the following program we display it in hexadecimal format of the\\n * underlying bytes.\\n */\\npublic class AESEncryption {\\n\\n    private static final char[] HEX_ARRAY = \\\"0123456789ABCDEF\\\".toCharArray();\\n\\n    /**\\n     * 1. Generate a plain text for encryption 2. Get a secret key (printed in\\n     * hexadecimal form). In actual use this must by encrypted and kept safe.\\n     * The same key is required for decryption.\\n     */\\n    public static void main(String[] args) throws Exception {\\n        String plainText = \\\"Hello World\\\";\\n        SecretKey secKey = getSecretEncryptionKey();\\n        byte[] cipherText = encryptText(plainText, secKey);\\n        String decryptedText = decryptText(cipherText, secKey);\\n\\n        System.out.println(\\\"Original Text:\\\" + plainText);\\n        System.out.println(\\\"AES Key (Hex Form):\\\" + bytesToHex(secKey.getEncoded()));\\n        System.out.println(\\\"Encrypted Text (Hex Form):\\\" + bytesToHex(cipherText));\\n        System.out.println(\\\"Descrypted Text:\\\" + decryptedText);\\n    }\\n\\n    /**\\n     * gets the AES encryption key. In your actual programs, this should be\\n     * safely stored.\\n     *\\n     * @return secKey (Secret key that we encrypt using it)\\n     * @throws NoSuchAlgorithmException (from KeyGenrator)\\n     */\\n    public static SecretKey getSecretEncryptionKey() throws NoSuchAlgorithmException {\\n        KeyGenerator aesKeyGenerator = KeyGenerator.getInstance(\\\"AES\\\");\\n        aesKeyGenerator.init(128); // The AES key size in number of bits\\n        return aesKeyGenerator.generateKey();\\n    }\\n\\n    /**\\n     * Encrypts plainText in AES using the secret key\\n     *\\n     * @return byteCipherText (The encrypted text)\\n     * @throws NoSuchPaddingException (from Cipher)\\n     * @throws NoSuchAlgorithmException (from Cipher)\\n     * @throws InvalidKeyException (from Cipher)\\n     * @throws BadPaddingException (from Cipher)\\n     * @throws IllegalBlockSizeException (from Cipher)\\n     */\\n    public static byte[] encryptText(String plainText, SecretKey secKey)\\n            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\\n            IllegalBlockSizeException, BadPaddingException {\\n        // AES defaults to AES/ECB/PKCS5Padding in Java 7\\n        Cipher aesCipher = Cipher.getInstance(\\\"AES\\\");\\n        aesCipher.init(Cipher.ENCRYPT_MODE, secKey);\\n        return aesCipher.doFinal(plainText.getBytes());\\n    }\\n\\n    /**\\n     * Decrypts encrypted byte array using the key used for encryption.\\n     *\\n     * @return plainText\\n     */\\n    public static String decryptText(byte[] byteCipherText, SecretKey secKey)\\n            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\\n            IllegalBlockSizeException, BadPaddingException {\\n        // AES defaults to AES/ECB/PKCS5Padding in Java 7\\n        Cipher aesCipher = Cipher.getInstance(\\\"AES\\\");\\n        aesCipher.init(Cipher.DECRYPT_MODE, secKey);\\n        byte[] bytePlainText = aesCipher.doFinal(byteCipherText);\\n        return new String(bytePlainText);\\n    }\\n\\n    /**\\n     * Convert a binary byte array into readable hex form Old library is\\n     * deprecated on OpenJdk 11 and this is faster regarding other solution is\\n     * using StringBuilder\\n     *\\n     * @return hexHash\\n     */\\n    public static String bytesToHex(byte[] bytes) {\\n        char[] hexChars = new char[bytes.length * 2];\\n        for (int j = 0; j < bytes.length; j++) {\\n            int v = bytes[j] & 0xFF;\\n            hexChars[j * 2] = HEX_ARRAY[v >>> 4];\\n            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];\\n        }\\n        return new String(hexChars);\\n    }\\n}\\n\"",
    "affine cipher": "\"package com.thealgorithms.ciphers;\\n\\nclass AffineCipher {\\n\\n    // Key values of a and b\\n    static int a = 17;\\n    static int b = 20;\\n\\n    static String encryptMessage(char[] msg) {\\n        /// Cipher Text initially empty\\n        String cipher = \\\"\\\";\\n        for (int i = 0; i < msg.length; i++) {\\n            // Avoid space to be encrypted\\n            /* applying encryption formula ( a x + b ) mod m\\n            {here x is msg[i] and m is 26} and added 'A' to\\n            bring it in range of ascii alphabet[ 65-90 | A-Z ] */\\n            if (msg[i] != ' ') {\\n                cipher = cipher\\n                        + (char) ((((a * (msg[i] - 'A')) + b) % 26) + 'A');\\n            } else // else simply append space character\\n            {\\n                cipher += msg[i];\\n            }\\n        }\\n        return cipher;\\n    }\\n\\n    static String decryptCipher(String cipher) {\\n        String msg = \\\"\\\";\\n        int a_inv = 0;\\n        int flag = 0;\\n\\n        //Find a^-1 (the multiplicative inverse of a\\n        //in the group of integers modulo m.)\\n        for (int i = 0; i < 26; i++) {\\n            flag = (a * i) % 26;\\n\\n            // Check if (a*i)%26 == 1,\\n            // then i will be the multiplicative inverse of a\\n            if (flag == 1) {\\n                a_inv = i;\\n            }\\n        }\\n        for (int i = 0; i < cipher.length(); i++) {\\n            /*Applying decryption formula a^-1 ( x - b ) mod m\\n            {here x is cipher[i] and m is 26} and added 'A'\\n            to bring it in range of ASCII alphabet[ 65-90 | A-Z ] */\\n            if (cipher.charAt(i) != ' ') {\\n                msg = msg + (char) (((a_inv\\n                        * ((cipher.charAt(i) + 'A' - b)) % 26)) + 'A');\\n            } else //else simply append space character\\n            {\\n                msg += cipher.charAt(i);\\n            }\\n        }\\n\\n        return msg;\\n    }\\n\\n    // Driver code\\n    public static void main(String[] args) {\\n        String msg = \\\"AFFINE CIPHER\\\";\\n\\n        // Calling encryption function\\n        String cipherText = encryptMessage(msg.toCharArray());\\n        System.out.println(\\\"Encrypted Message is : \\\" + cipherText);\\n\\n        // Calling Decryption function\\n        System.out.println(\\\"Decrypted Message is: \\\" + decryptCipher(cipherText));\\n\\n    }\\n}\\n\"",
    "caesar": "\"package com.thealgorithms.ciphers;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * A Java implementation of Caesar Cipher. /It is a type of substitution cipher\\n * in which each letter in the plaintext is replaced by a letter some fixed\\n * number of positions down the alphabet. /\\n *\\n * @author FAHRI YARDIMCI\\n * @author khalil2535\\n */\\npublic class Caesar {\\n\\n    /**\\n     * Encrypt text by shifting every Latin char by add number shift for ASCII\\n     * Example : A + 1 -> B\\n     *\\n     * @return Encrypted message\\n     */\\n    public static String encode(String message, int shift) {\\n        StringBuilder encoded = new StringBuilder();\\n\\n        shift %= 26;\\n\\n        final int length = message.length();\\n        for (int i = 0; i < length; i++) {\\n\\n            //            int current = message.charAt(i); //using char to shift characters because ascii\\n            // is in-order latin alphabet\\n            char current = message.charAt(i); // Java law : char + int = char\\n\\n            if (IsCapitalLatinLetter(current)) {\\n\\n                current += shift;\\n                encoded.append((char) (current > 'Z' ? current - 26 : current)); // 26 = number of latin letters\\n\\n            } else if (IsSmallLatinLetter(current)) {\\n\\n                current += shift;\\n                encoded.append((char) (current > 'z' ? current - 26 : current)); // 26 = number of latin letters\\n\\n            } else {\\n                encoded.append(current);\\n            }\\n        }\\n        return encoded.toString();\\n    }\\n\\n    /**\\n     * Decrypt message by shifting back every Latin char to previous the ASCII\\n     * Example : B - 1 -> A\\n     *\\n     * @return message\\n     */\\n    public static String decode(String encryptedMessage, int shift) {\\n        StringBuilder decoded = new StringBuilder();\\n\\n        shift %= 26;\\n\\n        final int length = encryptedMessage.length();\\n        for (int i = 0; i < length; i++) {\\n            char current = encryptedMessage.charAt(i);\\n            if (IsCapitalLatinLetter(current)) {\\n\\n                current -= shift;\\n                decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters\\n\\n            } else if (IsSmallLatinLetter(current)) {\\n\\n                current -= shift;\\n                decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters\\n\\n            } else {\\n                decoded.append(current);\\n            }\\n        }\\n        return decoded.toString();\\n    }\\n\\n    /**\\n     * @return true if character is capital Latin letter or false for others\\n     */\\n    private static boolean IsCapitalLatinLetter(char c) {\\n        return c >= 'A' && c <= 'Z';\\n    }\\n\\n    /**\\n     * @return true if character is small Latin letter or false for others\\n     */\\n    private static boolean IsSmallLatinLetter(char c) {\\n        return c >= 'a' && c <= 'z';\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner input = new Scanner(System.in);\\n        System.out.println(\\\"Please enter the message (Latin Alphabet)\\\");\\n        String message = input.nextLine();\\n        System.out.println(message);\\n        System.out.println(\\\"Please enter the shift number\\\");\\n        int shift = input.nextInt() % 26;\\n        System.out.println(\\\"(E)ncode or (D)ecode ?\\\");\\n        char choice = input.next().charAt(0);\\n        switch (choice) {\\n            case 'E':\\n            case 'e':\\n                System.out.println(\\n                        \\\"ENCODED MESSAGE IS \\\\n\\\" + encode(message, shift)); // send our function to handle\\n                break;\\n            case 'D':\\n            case 'd':\\n                System.out.println(\\\"DECODED MESSAGE IS \\\\n\\\" + decode(message, shift));\\n            default:\\n                System.out.println(\\\"default case\\\");\\n        }\\n        input.close();\\n    }\\n}\\n\"",
    "columnar transposition cipher": "\"package com.thealgorithms.ciphers;\\n\\nimport java.util.Objects;\\n\\n/**\\n * Columnar Transposition Cipher Encryption and Decryption.\\n *\\n * @author <a href=\\\"https://github.com/freitzzz\\\">freitzzz</a>\\n */\\npublic class ColumnarTranspositionCipher {\\n\\n    private static String keyword;\\n    private static Object[][] table;\\n    private static String abecedarium;\\n    public static final String ABECEDARIUM\\n            = \\\"abcdefghijklmnopqrstuvwxyzABCDEFG\\\" + \\\"HIJKLMNOPQRSTUVWXYZ0123456789,.;:-@\\\";\\n    private static final String ENCRYPTION_FIELD = \\\"≈\\\";\\n    private static final char ENCRYPTION_FIELD_CHAR = '≈';\\n\\n    /**\\n     * Encrypts a certain String with the Columnar Transposition Cipher Rule\\n     *\\n     * @param word Word being encrypted\\n     * @param keyword String with keyword being used\\n     * @return a String with the word encrypted by the Columnar Transposition\\n     * Cipher Rule\\n     */\\n    public static String encrpyter(String word, String keyword) {\\n        ColumnarTranspositionCipher.keyword = keyword;\\n        abecedariumBuilder(500);\\n        table = tableBuilder(word);\\n        Object[][] sortedTable = sortTable(table);\\n        StringBuilder wordEncrypted = new StringBuilder();\\n        for (int i = 0; i < sortedTable[i].length; i++) {\\n            for (int j = 1; j < sortedTable.length; j++) {\\n                wordEncrypted.append(sortedTable[j][i]);\\n            }\\n        }\\n        return wordEncrypted.toString();\\n    }\\n\\n    /**\\n     * Encrypts a certain String with the Columnar Transposition Cipher Rule\\n     *\\n     * @param word Word being encrypted\\n     * @param keyword String with keyword being used\\n     * @param abecedarium String with the abecedarium being used. null for\\n     * default one\\n     * @return a String with the word encrypted by the Columnar Transposition\\n     * Cipher Rule\\n     */\\n    public static String encrpyter(String word, String keyword, String abecedarium) {\\n        ColumnarTranspositionCipher.keyword = keyword;\\n        ColumnarTranspositionCipher.abecedarium = Objects.requireNonNullElse(abecedarium, ABECEDARIUM);\\n        table = tableBuilder(word);\\n        Object[][] sortedTable = sortTable(table);\\n        StringBuilder wordEncrypted = new StringBuilder();\\n        for (int i = 0; i < sortedTable[0].length; i++) {\\n            for (int j = 1; j < sortedTable.length; j++) {\\n                wordEncrypted.append(sortedTable[j][i]);\\n            }\\n        }\\n        return wordEncrypted.toString();\\n    }\\n\\n    /**\\n     * Decrypts a certain encrypted String with the Columnar Transposition\\n     * Cipher Rule\\n     *\\n     * @return a String decrypted with the word encrypted by the Columnar\\n     * Transposition Cipher Rule\\n     */\\n    public static String decrypter() {\\n        StringBuilder wordDecrypted = new StringBuilder();\\n        for (int i = 1; i < table.length; i++) {\\n            for (Object item : table[i]) {\\n                wordDecrypted.append(item);\\n            }\\n        }\\n        return wordDecrypted.toString().replaceAll(ENCRYPTION_FIELD, \\\"\\\");\\n    }\\n\\n    /**\\n     * Builds a table with the word to be encrypted in rows by the Columnar\\n     * Transposition Cipher Rule\\n     *\\n     * @return An Object[][] with the word to be encrypted filled in rows and\\n     * columns\\n     */\\n    private static Object[][] tableBuilder(String word) {\\n        Object[][] table = new Object[numberOfRows(word) + 1][keyword.length()];\\n        char[] wordInChards = word.toCharArray();\\n        // Fils in the respective numbers\\n        table[0] = findElements();\\n        int charElement = 0;\\n        for (int i = 1; i < table.length; i++) {\\n            for (int j = 0; j < table[i].length; j++) {\\n                if (charElement < wordInChards.length) {\\n                    table[i][j] = wordInChards[charElement];\\n                    charElement++;\\n                } else {\\n                    table[i][j] = ENCRYPTION_FIELD_CHAR;\\n                }\\n            }\\n        }\\n        return table;\\n    }\\n\\n    /**\\n     * Determines the number of rows the table should have regarding the\\n     * Columnar Transposition Cipher Rule\\n     *\\n     * @return an int with the number of rows that the table should have in\\n     * order to respect the Columnar Transposition Cipher Rule.\\n     */\\n    private static int numberOfRows(String word) {\\n        if (word.length() / keyword.length() > word.length() / keyword.length()) {\\n            return (word.length() / keyword.length()) + 1;\\n        } else {\\n            return word.length() / keyword.length();\\n        }\\n    }\\n\\n    /**\\n     * @return charValues\\n     */\\n    private static Object[] findElements() {\\n        Object[] charValues = new Object[keyword.length()];\\n        for (int i = 0; i < charValues.length; i++) {\\n            int charValueIndex = abecedarium.indexOf(keyword.charAt(i));\\n            charValues[i] = charValueIndex > -1 ? charValueIndex : null;\\n        }\\n        return charValues;\\n    }\\n\\n    /**\\n     * @return tableSorted\\n     */\\n    private static Object[][] sortTable(Object[][] table) {\\n        Object[][] tableSorted = new Object[table.length][table[0].length];\\n        for (int i = 0; i < tableSorted.length; i++) {\\n            System.arraycopy(table[i], 0, tableSorted[i], 0, tableSorted[i].length);\\n        }\\n        for (int i = 0; i < tableSorted[0].length; i++) {\\n            for (int j = i + 1; j < tableSorted[0].length; j++) {\\n                if ((int) tableSorted[0][i] > (int) table[0][j]) {\\n                    Object[] column = getColumn(tableSorted, tableSorted.length, i);\\n                    switchColumns(tableSorted, j, i, column);\\n                }\\n            }\\n        }\\n        return tableSorted;\\n    }\\n\\n    /**\\n     * @return columnArray\\n     */\\n    private static Object[] getColumn(Object[][] table, int rows, int column) {\\n        Object[] columnArray = new Object[rows];\\n        for (int i = 0; i < rows; i++) {\\n            columnArray[i] = table[i][column];\\n        }\\n        return columnArray;\\n    }\\n\\n    private static void switchColumns(\\n            Object[][] table, int firstColumnIndex, int secondColumnIndex, Object[] columnToSwitch) {\\n        for (int i = 0; i < table.length; i++) {\\n            table[i][secondColumnIndex] = table[i][firstColumnIndex];\\n            table[i][firstColumnIndex] = columnToSwitch[i];\\n        }\\n    }\\n\\n    /**\\n     * Creates an abecedarium with a specified ascii inded\\n     *\\n     * @param value Number of characters being used based on the ASCII Table\\n     */\\n    private static void abecedariumBuilder(int value) {\\n        StringBuilder t = new StringBuilder();\\n        for (int i = 0; i < value; i++) {\\n            t.append((char) i);\\n        }\\n        abecedarium = t.toString();\\n    }\\n\\n    private static void showTable() {\\n        for (Object[] table1 : table) {\\n            for (Object item : table1) {\\n                System.out.print(item + \\\" \\\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        String keywordForExample = \\\"asd215\\\";\\n        String wordBeingEncrypted = \\\"This is a test of the Columnar Transposition Cipher\\\";\\n        System.out.println(\\\"### Example of Columnar Transposition Cipher ###\\\\n\\\");\\n        System.out.println(\\\"Word being encryped ->>> \\\" + wordBeingEncrypted);\\n        System.out.println(\\n                \\\"Word encrypted ->>> \\\"\\n                + ColumnarTranspositionCipher.encrpyter(wordBeingEncrypted, keywordForExample));\\n        System.out.println(\\\"Word decryped ->>> \\\" + ColumnarTranspositionCipher.decrypter());\\n        System.out.println(\\\"\\\\n### Encrypted Table ###\\\");\\n        showTable();\\n    }\\n}\\n\"",
    "hill cipher": "\"package com.thealgorithms.ciphers;\\n\\nimport java.util.Scanner;\\n\\n/*\\n * Java Implementation of Hill Cipher\\n * Hill cipher is a polyalphabetic substitution cipher. Each letter is represented by a number belonging to the set Z26 where A=0 , B=1, ..... Z=25.\\n * To encrypt a message, each block of n letters (since matrix size is n x n) is multiplied by an invertible n × n matrix, against modulus 26.\\n * To decrypt the message, each block is multiplied by the inverse of the matrix used for encryption.\\n * The cipher key and plaintext/ciphertext are user inputs.\\n * @author Ojasva Jain\\n */\\npublic class HillCipher {\\n\\n    static Scanner in = new Scanner(System.in);\\n\\n    /* Following function encrypts the message\\n     */\\n    static void encrypt(String message) {\\n        message = message.toUpperCase();\\n        // Get key matrix\\n        System.out.println(\\\"Enter key matrix size\\\");\\n        int n = in.nextInt();\\n        System.out.println(\\\"Enter Key/encryptionKey matrix \\\");\\n        int keyMatrix[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                keyMatrix[i][j] = in.nextInt();\\n            }\\n        }\\n        //check if det = 0\\n        if (determinant(keyMatrix, n) % 26 == 0) {\\n            System.out.println(\\\"Invalid key, as determinant = 0. Program Terminated\\\");\\n            return;\\n        }\\n\\n        int[][] messageVector = new int[n][1];\\n        String CipherText = \\\"\\\";\\n        int cipherMatrix[][] = new int[n][1];\\n        int j = 0;\\n        while (j < message.length()) {\\n            for (int i = 0; i < n; i++) {\\n                if (j >= message.length()) {\\n                    messageVector[i][0] = 23;\\n                } else {\\n                    messageVector[i][0] = (message.charAt(j)) % 65;\\n                }\\n                System.out.println(messageVector[i][0]);\\n                j++;\\n            }\\n            int x, i;\\n            for (i = 0; i < n; i++) {\\n                cipherMatrix[i][0] = 0;\\n\\n                for (x = 0; x < n; x++) {\\n                    cipherMatrix[i][0] += keyMatrix[i][x] * messageVector[x][0];\\n                }\\n                System.out.println(cipherMatrix[i][0]);\\n                cipherMatrix[i][0] = cipherMatrix[i][0] % 26;\\n            }\\n            for (i = 0; i < n; i++) {\\n                CipherText += (char) (cipherMatrix[i][0] + 65);\\n            }\\n        }\\n        System.out.println(\\\"Ciphertext: \\\" + CipherText);\\n    }\\n\\n    //Following function decrypts a message\\n    static void decrypt(String message) {\\n        message = message.toUpperCase();\\n        // Get key matrix\\n        System.out.println(\\\"Enter key matrix size\\\");\\n        int n = in.nextInt();\\n        System.out.println(\\\"Enter inverseKey/decryptionKey matrix \\\");\\n        int keyMatrix[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                keyMatrix[i][j] = in.nextInt();\\n            }\\n        }\\n        //check if det = 0\\n        if (determinant(keyMatrix, n) % 26 == 0) {\\n            System.out.println(\\\"Invalid key, as determinant = 0. Program Terminated\\\");\\n            return;\\n        }\\n        //solving for the required plaintext message\\n        int[][] messageVector = new int[n][1];\\n        String PlainText = \\\"\\\";\\n        int plainMatrix[][] = new int[n][1];\\n        int j = 0;\\n        while (j < message.length()) {\\n            for (int i = 0; i < n; i++) {\\n                if (j >= message.length()) {\\n                    messageVector[i][0] = 23;\\n                } else {\\n                    messageVector[i][0] = (message.charAt(j)) % 65;\\n                }\\n                System.out.println(messageVector[i][0]);\\n                j++;\\n            }\\n            int x, i;\\n            for (i = 0; i < n; i++) {\\n                plainMatrix[i][0] = 0;\\n\\n                for (x = 0; x < n; x++) {\\n                    plainMatrix[i][0] += keyMatrix[i][x] * messageVector[x][0];\\n                }\\n\\n                plainMatrix[i][0] = plainMatrix[i][0] % 26;\\n            }\\n            for (i = 0; i < n; i++) {\\n                PlainText += (char) (plainMatrix[i][0] + 65);\\n            }\\n        }\\n        System.out.println(\\\"Plaintext: \\\" + PlainText);\\n    }\\n\\n    // Determinant calculator\\n    public static int determinant(int a[][], int n) {\\n        int det = 0, sign = 1, p = 0, q = 0;\\n\\n        if (n == 1) {\\n            det = a[0][0];\\n        } else {\\n            int b[][] = new int[n - 1][n - 1];\\n            for (int x = 0; x < n; x++) {\\n                p = 0;\\n                q = 0;\\n                for (int i = 1; i < n; i++) {\\n                    for (int j = 0; j < n; j++) {\\n                        if (j != x) {\\n                            b[p][q++] = a[i][j];\\n                            if (q % (n - 1) == 0) {\\n                                p++;\\n                                q = 0;\\n                            }\\n                        }\\n                    }\\n                }\\n                det = det + a[0][x] * determinant(b, n - 1) * sign;\\n                sign = -sign;\\n            }\\n        }\\n        return det;\\n    }\\n\\n    // Function to implement Hill Cipher\\n    static void hillcipher(String message) {\\n        message.toUpperCase();\\n        System.out.println(\\\"What do you want to process from the message?\\\");\\n        System.out.println(\\\"Press 1: To Encrypt\\\");\\n        System.out.println(\\\"Press 2: To Decrypt\\\");\\n        short sc = in.nextShort();\\n        if (sc == 1) {\\n            encrypt(message);\\n        } else if (sc == 2) {\\n            decrypt(message);\\n        } else {\\n            System.out.println(\\\"Invalid input, program terminated.\\\");\\n        }\\n    }\\n\\n    // Driver code\\n    public static void main(String[] args) {\\n        // Get the message to be encrypted\\n        System.out.println(\\\"Enter message\\\");\\n        String message = in.nextLine();\\n        hillcipher(message);\\n    }\\n}\\n\"",
    "product cipher": "\"package com.thealgorithms.ciphers;\\n\\nimport java.util.Scanner;\\n\\nclass ProductCipher {\\n\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.println(\\\"Enter the input to be encrypted: \\\");\\n        String substitutionInput = sc.nextLine();\\n        System.out.println(\\\" \\\");\\n        System.out.println(\\\"Enter a number: \\\");\\n        int n = sc.nextInt();\\n\\n        // Substitution encryption\\n        StringBuffer substitutionOutput = new StringBuffer();\\n        for (int i = 0; i < substitutionInput.length(); i++) {\\n            char c = substitutionInput.charAt(i);\\n            substitutionOutput.append((char) (c + 5));\\n        }\\n        System.out.println(\\\" \\\");\\n        System.out.println(\\\"Substituted text: \\\");\\n        System.out.println(substitutionOutput);\\n\\n        // Transposition encryption\\n        String transpositionInput = substitutionOutput.toString();\\n        int modulus;\\n        if ((modulus = transpositionInput.length() % n) != 0) {\\n            modulus = n - modulus;\\n\\n            for (; modulus != 0; modulus--) {\\n                transpositionInput += \\\"/\\\";\\n            }\\n        }\\n        StringBuffer transpositionOutput = new StringBuffer();\\n        System.out.println(\\\" \\\");\\n        System.out.println(\\\"Transposition Matrix: \\\");\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < transpositionInput.length() / n; j++) {\\n                char c = transpositionInput.charAt(i + (j * n));\\n                System.out.print(c);\\n                transpositionOutput.append(c);\\n            }\\n            System.out.println();\\n        }\\n        System.out.println(\\\" \\\");\\n        System.out.println(\\\"Final encrypted text: \\\");\\n        System.out.println(transpositionOutput);\\n\\n        // Transposition decryption\\n        n = transpositionOutput.length() / n;\\n        StringBuffer transpositionPlaintext = new StringBuffer();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < transpositionOutput.length() / n; j++) {\\n                char c = transpositionOutput.charAt(i + (j * n));\\n                transpositionPlaintext.append(c);\\n            }\\n        }\\n\\n        // Substitution decryption\\n        StringBuffer plaintext = new StringBuffer();\\n        for (int i = 0; i < transpositionPlaintext.length(); i++) {\\n            char c = transpositionPlaintext.charAt(i);\\n            plaintext.append((char) (c - 5));\\n        }\\n\\n        System.out.println(\\\"Plaintext: \\\");\\n        System.out.println(plaintext);\\n        sc.close();\\n    }\\n\\n}\\n\"",
    "rsa": "\"package com.thealgorithms.ciphers;\\n\\nimport javax.swing.*;\\nimport java.math.BigInteger;\\nimport java.security.SecureRandom;\\n\\n/**\\n * @author Nguyen Duy Tiep on 23-Oct-17.\\n */\\npublic final class RSA {\\n\\n    public static void main(String[] args) {\\n\\n        RSA rsa = new RSA(1024);\\n        String text1 = JOptionPane.showInputDialog(\\\"Enter a message to encrypt :\\\");\\n\\n        String ciphertext = rsa.encrypt(text1);\\n        JOptionPane.showMessageDialog(null, \\\"Your encrypted message : \\\" + ciphertext);\\n\\n        JOptionPane.showMessageDialog(null, \\\"Your message after decrypt : \\\" + rsa.decrypt(ciphertext));\\n    }\\n\\n    private BigInteger modulus, privateKey, publicKey;\\n\\n    public RSA(int bits) {\\n        generateKeys(bits);\\n    }\\n\\n    /**\\n     * @return encrypted message\\n     */\\n    public synchronized String encrypt(String message) {\\n        return (new BigInteger(message.getBytes())).modPow(publicKey, modulus).toString();\\n    }\\n\\n    /**\\n     * @return encrypted message as big integer\\n     */\\n    public synchronized BigInteger encrypt(BigInteger message) {\\n        return message.modPow(publicKey, modulus);\\n    }\\n\\n    /**\\n     * @return plain message\\n     */\\n    public synchronized String decrypt(String encryptedMessage) {\\n        return new String((new BigInteger(encryptedMessage)).modPow(privateKey, modulus).toByteArray());\\n    }\\n\\n    /**\\n     * @return plain message as big integer\\n     */\\n    public synchronized BigInteger decrypt(BigInteger encryptedMessage) {\\n        return encryptedMessage.modPow(privateKey, modulus);\\n    }\\n\\n    /**\\n     * Generate a new public and private key set.\\n     */\\n    public synchronized void generateKeys(int bits) {\\n        SecureRandom r = new SecureRandom();\\n        BigInteger p = new BigInteger(bits / 2, 100, r);\\n        BigInteger q = new BigInteger(bits / 2, 100, r);\\n        modulus = p.multiply(q);\\n\\n        BigInteger m = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));\\n\\n        publicKey = new BigInteger(\\\"3\\\");\\n\\n        while (m.gcd(publicKey).intValue() > 1) {\\n            publicKey = publicKey.add(new BigInteger(\\\"2\\\"));\\n        }\\n\\n        privateKey = publicKey.modInverse(m);\\n    }\\n}\\n\"",
    "simple sub cipher": "\"package com.thealgorithms.ciphers;\\n\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n/**\\n * The simple substitution cipher is a cipher that has been in use for many\\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\\n * Book'). It basically consists of substituting every plaintext character for a\\n * different ciphertext character. It differs from the Caesar cipher in that the\\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\\n */\\npublic class SimpleSubCipher {\\n\\n    /**\\n     * Encrypt text by replacing each element with its opposite character.\\n     *\\n     * @param message\\n     * @param cipherSmall\\n     * @return Encrypted message\\n     */\\n    public static String encode(String message, String cipherSmall) {\\n        String encoded = \\\"\\\";\\n\\n        // This map is used to encode\\n        Map<Character, Character> cipherMap = new HashMap<>();\\n\\n        char beginSmallLetter = 'a';\\n        char beginCapitalLetter = 'A';\\n\\n        cipherSmall = cipherSmall.toLowerCase();\\n        String cipherCapital = cipherSmall.toUpperCase();\\n\\n        // To handle Small and Capital letters\\n        for (int i = 0; i < cipherSmall.length(); i++) {\\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\\n        }\\n\\n        for (int i = 0; i < message.length(); i++) {\\n            if (Character.isAlphabetic(message.charAt(i))) {\\n                encoded += cipherMap.get(message.charAt(i));\\n            } else {\\n                encoded += message.charAt(i);\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Decrypt message by replacing each element with its opposite character in\\n     * cipher.\\n     *\\n     * @param encryptedMessage\\n     * @param cipherSmall\\n     * @return message\\n     */\\n    public static String decode(String encryptedMessage, String cipherSmall) {\\n        String decoded = \\\"\\\";\\n\\n        Map<Character, Character> cipherMap = new HashMap<Character, Character>();\\n\\n        char beginSmallLetter = 'a';\\n        char beginCapitalLetter = 'A';\\n\\n        cipherSmall = cipherSmall.toLowerCase();\\n        String cipherCapital = cipherSmall.toUpperCase();\\n\\n        for (int i = 0; i < cipherSmall.length(); i++) {\\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\\n        }\\n\\n        for (int i = 0; i < encryptedMessage.length(); i++) {\\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\\n                decoded += cipherMap.get(encryptedMessage.charAt(i));\\n            } else {\\n                decoded += encryptedMessage.charAt(i);\\n            }\\n        }\\n\\n        return decoded;\\n    }\\n\\n    public static void main(String[] args) {\\n        String a = encode(\\\"defend the east wall of the castle\\\", \\\"phqgiumeaylnofdxjkrcvstzwb\\\");\\n        String b = decode(a, \\\"phqgiumeaylnofdxjkrcvstzwb\\\");\\n        System.out.println(b);\\n    }\\n\\n}\\n\"",
    "simple substitution cipher": "\"package com.thealgorithms.ciphers;\\n\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n/**\\n * The simple substitution cipher is a cipher that has been in use for many\\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\\n * Book'). It basically consists of substituting every plaintext character for a\\n * different ciphertext character. It differs from the Caesar cipher in that the\\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\\n *\\n * @author Hassan Elseoudy\\n */\\npublic class SimpleSubstitutionCipher {\\n\\n    /**\\n     * Encrypt text by replacing each element with its opposite character.\\n     *\\n     * @return Encrypted message\\n     */\\n    public static String encode(String message, String cipherSmall) {\\n        StringBuilder encoded = new StringBuilder();\\n\\n        // This map is used to encode\\n        Map<Character, Character> cipherMap = new HashMap<>();\\n\\n        char beginSmallLetter = 'a';\\n        char beginCapitalLetter = 'A';\\n\\n        cipherSmall = cipherSmall.toLowerCase();\\n        String cipherCapital = cipherSmall.toUpperCase();\\n\\n        // To handle Small and Capital letters\\n        for (int i = 0; i < cipherSmall.length(); i++) {\\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\\n        }\\n\\n        for (int i = 0; i < message.length(); i++) {\\n            if (Character.isAlphabetic(message.charAt(i))) {\\n                encoded.append(cipherMap.get(message.charAt(i)));\\n            } else {\\n                encoded.append(message.charAt(i));\\n            }\\n        }\\n\\n        return encoded.toString();\\n    }\\n\\n    /**\\n     * Decrypt message by replacing each element with its opposite character in\\n     * cipher.\\n     *\\n     * @return message\\n     */\\n    public static String decode(String encryptedMessage, String cipherSmall) {\\n        StringBuilder decoded = new StringBuilder();\\n\\n        Map<Character, Character> cipherMap = new HashMap<>();\\n\\n        char beginSmallLetter = 'a';\\n        char beginCapitalLetter = 'A';\\n\\n        cipherSmall = cipherSmall.toLowerCase();\\n        String cipherCapital = cipherSmall.toUpperCase();\\n\\n        for (int i = 0; i < cipherSmall.length(); i++) {\\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\\n        }\\n\\n        for (int i = 0; i < encryptedMessage.length(); i++) {\\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\\n                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\\n            } else {\\n                decoded.append(encryptedMessage.charAt(i));\\n            }\\n        }\\n\\n        return decoded.toString();\\n    }\\n\\n    /**\\n     * TODO remove main and make JUnit Testing\\n     */\\n    public static void main(String[] args) {\\n        String a = encode(\\\"defend the east wall of the castle\\\", \\\"phqgiumeaylnofdxjkrcvstzwb\\\");\\n        String b = decode(a, \\\"phqgiumeaylnofdxjkrcvstzwb\\\");\\n        System.out.println(b);\\n    }\\n}\\n\"",
    "vigenere": "\"package com.thealgorithms.ciphers;\\n\\n/**\\n * A Java implementation of Vigenere Cipher.\\n *\\n * @author straiffix\\n * @author beingmartinbmc\\n */\\npublic class Vigenere {\\n\\n    public static String encrypt(final String message, final String key) {\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0, j = 0; i < message.length(); i++) {\\n            char c = message.charAt(i);\\n            if (Character.isLetter(c)) {\\n                if (Character.isUpperCase(c)) {\\n                    result.append((char) ((c + key.toUpperCase().charAt(j) - 2 * 'A') % 26 + 'A'));\\n\\n                } else {\\n                    result.append((char) ((c + key.toLowerCase().charAt(j) - 2 * 'a') % 26 + 'a'));\\n                }\\n            } else {\\n                result.append(c);\\n            }\\n            j = ++j % key.length();\\n        }\\n        return result.toString();\\n    }\\n\\n    public static String decrypt(final String message, final String key) {\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0, j = 0; i < message.length(); i++) {\\n\\n            char c = message.charAt(i);\\n            if (Character.isLetter(c)) {\\n                if (Character.isUpperCase(c)) {\\n                    result.append((char) ('Z' - (25 - (c - key.toUpperCase().charAt(j))) % 26));\\n\\n                } else {\\n                    result.append((char) ('z' - (25 - (c - key.toLowerCase().charAt(j))) % 26));\\n                }\\n            } else {\\n                result.append(c);\\n            }\\n\\n            j = ++j % key.length();\\n        }\\n        return result.toString();\\n    }\\n\\n    public static void main(String[] args) {\\n        String text = \\\"Hello World!\\\";\\n        String key = \\\"itsakey\\\";\\n        System.out.println(text);\\n        String ciphertext = encrypt(text, key);\\n        System.out.println(ciphertext);\\n        System.out.println(decrypt(ciphertext, key));\\n    }\\n}\\n\"",
    "any base to any base": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Arrays;\\nimport java.util.HashSet;\\nimport java.util.InputMismatchException;\\nimport java.util.Scanner;\\n\\n/**\\n * Class for converting from \\\"any\\\" base to \\\"any\\\" other base, when \\\"any\\\" means\\n * from 2-36. Works by going from base 1 to decimal to base 2. Includes\\n * auxiliary method for determining whether a number is valid for a given base.\\n *\\n * @author Michael Rolland\\n * @version 2017.10.10\\n */\\npublic class AnyBaseToAnyBase {\\n\\n    /**\\n     * Smallest and largest base you want to accept as valid input\\n     */\\n    static final int MINIMUM_BASE = 2;\\n\\n    static final int MAXIMUM_BASE = 36;\\n\\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in);\\n        String n;\\n        int b1, b2;\\n        while (true) {\\n            try {\\n                System.out.print(\\\"Enter number: \\\");\\n                n = in.next();\\n                System.out.print(\\n                        \\\"Enter beginning base (between \\\" + MINIMUM_BASE + \\\" and \\\" + MAXIMUM_BASE + \\\"): \\\");\\n                b1 = in.nextInt();\\n                if (b1 > MAXIMUM_BASE || b1 < MINIMUM_BASE) {\\n                    System.out.println(\\\"Invalid base!\\\");\\n                    continue;\\n                }\\n                if (!validForBase(n, b1)) {\\n                    System.out.println(\\\"The number is invalid for this base!\\\");\\n                    continue;\\n                }\\n                System.out.print(\\n                        \\\"Enter end base (between \\\" + MINIMUM_BASE + \\\" and \\\" + MAXIMUM_BASE + \\\"): \\\");\\n                b2 = in.nextInt();\\n                if (b2 > MAXIMUM_BASE || b2 < MINIMUM_BASE) {\\n                    System.out.println(\\\"Invalid base!\\\");\\n                    continue;\\n                }\\n                break;\\n            } catch (InputMismatchException e) {\\n                System.out.println(\\\"Invalid input.\\\");\\n                in.next();\\n            }\\n        }\\n        System.out.println(base2base(n, b1, b2));\\n        in.close();\\n    }\\n\\n    /**\\n     * Checks if a number (as a String) is valid for a given base.\\n     */\\n    public static boolean validForBase(String n, int base) {\\n        char[] validDigits = {\\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\\n            'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\\n        };\\n        // digitsForBase contains all the valid digits for the base given\\n        char[] digitsForBase = Arrays.copyOfRange(validDigits, 0, base);\\n\\n        // Convert character array into set for convenience of contains() method\\n        HashSet<Character> digitsList = new HashSet<>();\\n        for (int i = 0; i < digitsForBase.length; i++) {\\n            digitsList.add(digitsForBase[i]);\\n        }\\n\\n        // Check that every digit in n is within the list of valid digits for that base.\\n        for (char c : n.toCharArray()) {\\n            if (!digitsList.contains(c)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Method to convert any integer from base b1 to base b2. Works by\\n     * converting from b1 to decimal, then decimal to b2.\\n     *\\n     * @param n The integer to be converted.\\n     * @param b1 Beginning base.\\n     * @param b2 End base.\\n     * @return n in base b2.\\n     */\\n    public static String base2base(String n, int b1, int b2) {\\n        // Declare variables: decimal value of n,\\n        // character of base b1, character of base b2,\\n        // and the string that will be returned.\\n        int decimalValue = 0, charB2;\\n        char charB1;\\n        String output = \\\"\\\";\\n        // Go through every character of n\\n        for (int i = 0; i < n.length(); i++) {\\n            // store the character in charB1\\n            charB1 = n.charAt(i);\\n            // if it is a non-number, convert it to a decimal value >9 and store it in charB2\\n            if (charB1 >= 'A' && charB1 <= 'Z') {\\n                charB2 = 10 + (charB1 - 'A');\\n            } // Else, store the integer value in charB2\\n            else {\\n                charB2 = charB1 - '0';\\n            }\\n            // Convert the digit to decimal and add it to the\\n            // decimalValue of n\\n            decimalValue = decimalValue * b1 + charB2;\\n        }\\n\\n        // Converting the decimal value to base b2:\\n        // A number is converted from decimal to another base\\n        // by continuously dividing by the base and recording\\n        // the remainder until the quotient is zero. The number in the\\n        // new base is the remainders, with the last remainder\\n        // being the left-most digit.\\n        if (0 == decimalValue) {\\n            return \\\"0\\\";\\n        }\\n        // While the quotient is NOT zero:\\n        while (decimalValue != 0) {\\n            // If the remainder is a digit < 10, simply add it to\\n            // the left side of the new number.\\n            if (decimalValue % b2 < 10) {\\n                output = Integer.toString(decimalValue % b2) + output;\\n            } // If the remainder is >= 10, add a character with the\\n            // corresponding value to the new number. (A = 10, B = 11, C = 12, ...)\\n            else {\\n                output = (char) ((decimalValue % b2) + 55) + output;\\n            }\\n            // Divide by the new base again\\n            decimalValue /= b2;\\n        }\\n        return output;\\n    }\\n}\\n\"",
    "any base to decimal": "\"package com.thealgorithms.conversions;\\n\\n/**\\n * @author Varun Upadhyay (https://github.com/varunu28)\\n */\\n// Driver program\\npublic class AnyBaseToDecimal {\\n\\n    public static void main(String[] args) {\\n        assert convertToDecimal(\\\"1010\\\", 2) == Integer.valueOf(\\\"1010\\\", 2);\\n        assert convertToDecimal(\\\"777\\\", 8) == Integer.valueOf(\\\"777\\\", 8);\\n        assert convertToDecimal(\\\"999\\\", 10) == Integer.valueOf(\\\"999\\\", 10);\\n        assert convertToDecimal(\\\"ABCDEF\\\", 16) == Integer.valueOf(\\\"ABCDEF\\\", 16);\\n        assert convertToDecimal(\\\"XYZ\\\", 36) == Integer.valueOf(\\\"XYZ\\\", 36);\\n    }\\n\\n    /**\\n     * Convert any radix to decimal number\\n     *\\n     * @param s the string to be convert\\n     * @param radix the radix\\n     * @return decimal of bits\\n     * @throws NumberFormatException if {@code bits} or {@code radix} is invalid\\n     */\\n    public static int convertToDecimal(String s, int radix) {\\n        int num = 0;\\n        int pow = 1;\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            int digit = valOfChar(s.charAt(i));\\n            if (digit >= radix) {\\n                throw new NumberFormatException(\\\"For input string \\\" + s);\\n            }\\n            num += valOfChar(s.charAt(i)) * pow;\\n            pow *= radix;\\n        }\\n        return num;\\n    }\\n\\n    /**\\n     * Convert character to integer\\n     *\\n     * @param c the character\\n     * @return represented digit of given character\\n     * @throws NumberFormatException if {@code ch} is not UpperCase or Digit\\n     * character.\\n     */\\n    public static int valOfChar(char c) {\\n        if (!(Character.isUpperCase(c) || Character.isDigit(c))) {\\n            throw new NumberFormatException(\\\"invalid character :\\\" + c);\\n        }\\n        return Character.isDigit(c) ? c - '0' : c - 'A' + 10;\\n    }\\n}\\n\"",
    "anyto any": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Scanner;\\n// given a source number , source base, destination base, this code can give you the destination\\n// number.\\n// sn ,sb,db ---> ()dn  .   this is what we have to do    .\\n\\npublic class AnytoAny {\\n\\n    public static void main(String[] args) {\\n        Scanner scn = new Scanner(System.in);\\n        int sn = scn.nextInt();\\n        int sb = scn.nextInt();\\n        int db = scn.nextInt();\\n        int m = 1, dec = 0, dn = 0;\\n        while (sn != 0) {\\n            dec = dec + (sn % 10) * m;\\n            m *= sb;\\n            sn /= 10;\\n        }\\n        m = 1;\\n        while (dec != 0) {\\n            dn = dn + (dec % db) * m;\\n            m *= 10;\\n            dec /= db;\\n        }\\n        System.out.println(dn);\\n        scn.close();\\n    }\\n}\\n\"",
    "binary to decimal": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * This class converts a Binary number to a Decimal number\\n */\\nclass BinaryToDecimal {\\n\\n    /**\\n     * Main Method\\n     *\\n     * @param args Command line arguments\\n     */\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n        int binNum, binCopy, d, s = 0, power = 0;\\n        System.out.print(\\\"Binary number: \\\");\\n        binNum = sc.nextInt();\\n        binCopy = binNum;\\n        while (binCopy != 0) {\\n            d = binCopy % 10;\\n            s += d * (int) Math.pow(2, power++);\\n            binCopy /= 10;\\n        }\\n        System.out.println(\\\"Decimal equivalent:\\\" + s);\\n        sc.close();\\n    }\\n}\\n\"",
    "binary to hexadecimal": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.*;\\n\\n/**\\n * Converts any Binary Number to a Hexadecimal Number\\n *\\n * @author Nishita Aggarwal\\n */\\npublic class BinaryToHexadecimal {\\n\\n    /**\\n     * This method converts a binary number to a hexadecimal number.\\n     *\\n     * @param binary The binary number\\n     * @return The hexadecimal number\\n     */\\n    static String binToHex(int binary) {\\n        // hm to store hexadecimal codes for binary numbers within the range: 0000 to 1111 i.e. for\\n        // decimal numbers 0 to 15\\n        HashMap<Integer, String> hm = new HashMap<>();\\n        // String to store hexadecimal code\\n        String hex = \\\"\\\";\\n        int i;\\n        for (i = 0; i < 10; i++) {\\n            hm.put(i, String.valueOf(i));\\n        }\\n        for (i = 10; i < 16; i++) {\\n            hm.put(i, String.valueOf((char) ('A' + i - 10)));\\n        }\\n        int currbit;\\n        while (binary != 0) {\\n            int code4 = 0; // to store decimal equivalent of number formed by 4 decimal digits\\n            for (i = 0; i < 4; i++) {\\n                currbit = binary % 10;\\n                binary = binary / 10;\\n                code4 += currbit * Math.pow(2, i);\\n            }\\n            hex = hm.get(code4) + hex;\\n        }\\n        return hex;\\n    }\\n\\n    /**\\n     * Main method\\n     *\\n     * @param args Command line arguments\\n     */\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.println(\\\"Enter binary number:\\\");\\n        int binary = sc.nextInt();\\n        String hex = binToHex(binary);\\n        System.out.println(\\\"Hexadecimal Code:\\\" + hex);\\n        sc.close();\\n    }\\n}\\n\"",
    "binary to octal": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * Converts any Binary number to an Octal Number\\n *\\n * @author Zachary Jones\\n */\\npublic class BinaryToOctal {\\n\\n    /**\\n     * Main method\\n     *\\n     * @param args Command line arguments\\n     */\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.println(\\\"Input the binary number: \\\");\\n        int b = sc.nextInt();\\n        System.out.println(\\\"Octal equivalent: \\\" + convertBinaryToOctal(b));\\n        sc.close();\\n    }\\n\\n    /**\\n     * This method converts a binary number to an octal number.\\n     *\\n     * @param binary The binary number\\n     * @return The octal number\\n     */\\n    public static String convertBinaryToOctal(int binary) {\\n        String octal = \\\"\\\";\\n        int currBit = 0, j = 1;\\n        while (binary != 0) {\\n            int code3 = 0;\\n            for (int i = 0; i < 3; i++) {\\n                currBit = binary % 10;\\n                binary = binary / 10;\\n                code3 += currBit * j;\\n                j *= 2;\\n            }\\n            octal = code3 + octal;\\n            j = 1;\\n        }\\n        return octal;\\n    }\\n}\\n\"",
    "decimal to any base": "\"package com.thealgorithms.conversions;\\n\\nimport java.io.BufferedReader;\\nimport java.io.InputStreamReader;\\nimport java.util.ArrayList;\\n\\n/**\\n * @author Varun Upadhyay (https://github.com/varunu28)\\n */\\n// Driver Program\\npublic class DecimalToAnyBase {\\n\\n    public static void main(String[] args) throws Exception {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        System.out.println(\\\"Enter the decimal input below: \\\");\\n        int decInput = Integer.parseInt(br.readLine());\\n        System.out.println();\\n\\n        System.out.println(\\\"Enter the base below: \\\");\\n        int base = Integer.parseInt(br.readLine());\\n        System.out.println();\\n\\n        System.out.println(\\\"Decimal Input\\\" + \\\" is: \\\" + decInput);\\n        System.out.println(\\n                \\\"Value of \\\" + decInput + \\\" in base \\\" + base + \\\" is: \\\" + convertToAnyBase(decInput, base));\\n\\n        br.close();\\n    }\\n\\n    /**\\n     * This method produces a String value of any given input decimal in any\\n     * base\\n     *\\n     * @param inp Decimal of which we need the value in base in String format\\n     * @return string format of the converted value in the given base\\n     */\\n    public static String convertToAnyBase(int inp, int base) {\\n        ArrayList<Character> charArr = new ArrayList<>();\\n\\n        while (inp > 0) {\\n            charArr.add(reVal(inp % base));\\n            inp /= base;\\n        }\\n\\n        StringBuilder str = new StringBuilder(charArr.size());\\n\\n        for (Character ch : charArr) {\\n            str.append(ch);\\n        }\\n\\n        return str.reverse().toString();\\n    }\\n\\n    /**\\n     * This method produces character value of the input integer and returns it\\n     *\\n     * @param num integer of which we need the character value of\\n     * @return character value of input integer\\n     */\\n    public static char reVal(int num) {\\n        if (num >= 0 && num <= 9) {\\n            return (char) (num + '0');\\n        } else {\\n            return (char) (num - 10 + 'A');\\n        }\\n    }\\n}\\n\"",
    "decimal to binary": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * This class converts a Decimal number to a Binary number\\n */\\nclass DecimalToBinary {\\n\\n    /**\\n     * Main Method\\n     *\\n     * @param args Command Line Arguments\\n     */\\n    public static void main(String args[]) {\\n        conventionalConversion();\\n        bitwiseConversion();\\n    }\\n\\n    /**\\n     * This method converts a decimal number to a binary number using a\\n     * conventional algorithm.\\n     */\\n    public static void conventionalConversion() {\\n        int n, b = 0, c = 0, d;\\n        Scanner input = new Scanner(System.in);\\n        System.out.printf(\\\"Conventional conversion.%n Enter the decimal number: \\\");\\n        n = input.nextInt();\\n        while (n != 0) {\\n            d = n % 2;\\n            b = b + d * (int) Math.pow(10, c++);\\n            n /= 2;\\n        } // converting decimal to binary\\n        System.out.println(\\\"\\\\tBinary number: \\\" + b);\\n        input.close();\\n    }\\n\\n    /**\\n     * This method converts a decimal number to a binary number using a bitwise\\n     * algorithm\\n     */\\n    public static void bitwiseConversion() {\\n        int n, b = 0, c = 0, d;\\n        Scanner input = new Scanner(System.in);\\n        System.out.printf(\\\"Bitwise conversion.%n Enter the decimal number: \\\");\\n        n = input.nextInt();\\n        while (n != 0) {\\n            d = (n & 1);\\n            b += d * (int) Math.pow(10, c++);\\n            n >>= 1;\\n        }\\n        System.out.println(\\\"\\\\tBinary number: \\\" + b);\\n        input.close();\\n    }\\n}\\n\"",
    "decimal to hexa decimal": "\"package com.thealgorithms.conversions;\\n\\n// hex = [0 - 9] -> [A - F]\\nclass DecimalToHexaDecimal {\\n\\n    private static final int sizeOfIntInHalfBytes = 8;\\n    private static final int numberOfBitsInAHalfByte = 4;\\n    private static final int halfByte = 0x0F;\\n    private static final char[] hexDigits = {\\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\\n    };\\n\\n    // Returns the hex value of the dec entered in the parameter.\\n    public static String decToHex(int dec) {\\n        StringBuilder hexBuilder = new StringBuilder(sizeOfIntInHalfBytes);\\n        hexBuilder.setLength(sizeOfIntInHalfBytes);\\n        for (int i = sizeOfIntInHalfBytes - 1; i >= 0; --i) {\\n            int j = dec & halfByte;\\n            hexBuilder.setCharAt(i, hexDigits[j]);\\n            dec >>= numberOfBitsInAHalfByte;\\n        }\\n        return hexBuilder.toString().toLowerCase();\\n    }\\n\\n    // Test above function.\\n    public static void main(String[] args) {\\n        System.out.println(\\\"Test...\\\");\\n        int dec = 305445566;\\n        String libraryDecToHex = Integer.toHexString(dec);\\n        String decToHex = decToHex(dec);\\n        System.out.println(\\\"Result from the library : \\\" + libraryDecToHex);\\n        System.out.println(\\\"Result decToHex method : \\\" + decToHex);\\n    }\\n}\\n\"",
    "decimal to octal": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * This class converts Decimal numbers to Octal Numbers\\n */\\npublic class DecimalToOctal {\\n\\n    /**\\n     * Main Method\\n     *\\n     * @param args Command line Arguments\\n     */\\n\\n    // enter in a decimal value to get Octal output\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        int n, k, d, s = 0, c = 0;\\n        System.out.print(\\\"Decimal number: \\\");\\n        n = sc.nextInt();\\n        k = n;\\n        while (k != 0) {\\n            d = k % 8;\\n            s += d * (int) Math.pow(10, c++);\\n            k /= 8;\\n        }\\n\\n        System.out.println(\\\"Octal equivalent:\\\" + s);\\n        sc.close();\\n    }\\n}\\n\"",
    "hexa decimal to binary": "\"package com.thealgorithms.conversions;\\n\\n// Hex [0-9],[A-F] -> Binary [0,1]\\npublic class HexaDecimalToBinary {\\n\\n    private final int LONG_BITS = 8;\\n\\n    public void convert(String numHex) {\\n        // String a HexaDecimal:\\n        int conHex = Integer.parseInt(numHex, 16);\\n        // Hex a Binary:\\n        String binary = Integer.toBinaryString(conHex);\\n        // Output:\\n        System.out.println(numHex + \\\" = \\\" + completeDigits(binary));\\n    }\\n\\n    public String completeDigits(String binNum) {\\n        for (int i = binNum.length(); i < LONG_BITS; i++) {\\n            binNum = \\\"0\\\" + binNum;\\n        }\\n        return binNum;\\n    }\\n\\n    public static void main(String[] args) {\\n\\n        // Testing Numbers:\\n        String[] hexNums = {\\\"1\\\", \\\"A1\\\", \\\"ef\\\", \\\"BA\\\", \\\"AA\\\", \\\"BB\\\", \\\"19\\\", \\\"01\\\", \\\"02\\\", \\\"03\\\", \\\"04\\\"};\\n        HexaDecimalToBinary objConvert = new HexaDecimalToBinary();\\n\\n        for (String num : hexNums) {\\n            objConvert.convert(num);\\n        }\\n    }\\n}\\n\"",
    "hexa decimal to decimal": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Scanner;\\n\\npublic class HexaDecimalToDecimal {\\n\\n    // convert hexadecimal to decimal\\n    public static int getHexaToDec(String hex) {\\n        String digits = \\\"0123456789ABCDEF\\\";\\n        hex = hex.toUpperCase();\\n        int val = 0;\\n        for (int i = 0; i < hex.length(); i++) {\\n            int d = digits.indexOf(hex.charAt(i));\\n            val = 16 * val + d;\\n        }\\n        return val;\\n    }\\n\\n    // Main method gets the hexadecimal input from user and converts it into Decimal output.\\n    public static void main(String args[]) {\\n        String hexa_Input;\\n        int dec_output;\\n        Scanner scan = new Scanner(System.in);\\n\\n        System.out.print(\\\"Enter Hexadecimal Number : \\\");\\n        hexa_Input = scan.nextLine();\\n\\n        // convert hexadecimal to decimal\\n        dec_output = getHexaToDec(hexa_Input);\\n        /*\\n    Pass the string to the getHexaToDec function\\n    and it returns the decimal form in the variable dec_output.\\n         */\\n        System.out.println(\\\"Number in Decimal: \\\" + dec_output);\\n        scan.close();\\n    }\\n}\\n\"",
    "hex to oct": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * Converts any Hexadecimal Number to Octal\\n *\\n * @author Tanmay Joshi\\n */\\npublic class HexToOct {\\n\\n    /**\\n     * This method converts a Hexadecimal number to a decimal number\\n     *\\n     * @param s The Hexadecimal Number\\n     * @return The Decimal number\\n     */\\n    public static int hex2decimal(String s) {\\n        String str = \\\"0123456789ABCDEF\\\";\\n        s = s.toUpperCase();\\n        int val = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char a = s.charAt(i);\\n            int n = str.indexOf(a);\\n            val = 16 * val + n;\\n        }\\n        return val;\\n    }\\n\\n    /**\\n     * This method converts a Decimal number to a octal number\\n     *\\n     * @param q The Decimal Number\\n     * @return The Octal number\\n     */\\n    public static int decimal2octal(int q) {\\n        int now;\\n        int i = 1;\\n        int octnum = 0;\\n        while (q > 0) {\\n            now = q % 8;\\n            octnum = (now * (int) (Math.pow(10, i))) + octnum;\\n            q /= 8;\\n            i++;\\n        }\\n        octnum /= 10;\\n        return octnum;\\n    }\\n\\n    /**\\n     * Main method that gets the hex input from user and converts it into octal.\\n     *\\n     * @param args arguments\\n     */\\n    public static void main(String args[]) {\\n        String hexadecnum;\\n        int decnum, octalnum;\\n        Scanner scan = new Scanner(System.in);\\n\\n        System.out.print(\\\"Enter Hexadecimal Number : \\\");\\n        hexadecnum = scan.nextLine();\\n\\n        // first convert hexadecimal to decimal\\n        decnum\\n                = hex2decimal(\\n                        hexadecnum); // Pass the string to the hex2decimal function and get the decimal form in\\n        // variable decnum\\n\\n        // convert decimal to octal\\n        octalnum = decimal2octal(decnum);\\n        System.out.println(\\\"Number in octal: \\\" + octalnum);\\n        scan.close();\\n    }\\n}\\n\"",
    "integer to roman": "\"package com.thealgorithms.conversions;\\n\\n/**\\n * Converting Integers into Roman Numerals\\n *\\n * <p>\\n * ('I', 1); ('IV',4); ('V', 5); ('IX',9); ('X', 10); ('XL',40); ('L', 50);\\n * ('XC',90); ('C', 100); ('D', 500); ('M', 1000);\\n */\\npublic class IntegerToRoman {\\n\\n    private static int[] allArabianRomanNumbers\\n            = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    private static String[] allRomanNumbers\\n            = new String[]{\\\"M\\\", \\\"CM\\\", \\\"D\\\", \\\"CD\\\", \\\"C\\\", \\\"XC\\\", \\\"L\\\", \\\"XL\\\", \\\"X\\\", \\\"IX\\\", \\\"V\\\", \\\"IV\\\", \\\"I\\\"};\\n\\n    // Value must be > 0\\n    public static String integerToRoman(int num) {\\n        if (num <= 0) {\\n            return \\\"\\\";\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n\\n        for (int a = 0; a < allArabianRomanNumbers.length; a++) {\\n            int times = num / allArabianRomanNumbers[a];\\n            for (int b = 0; b < times; b++) {\\n                builder.append(allRomanNumbers[a]);\\n            }\\n\\n            num -= times * allArabianRomanNumbers[a];\\n        }\\n\\n        return builder.toString();\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(IntegerToRoman.integerToRoman(2131));\\n    }\\n}\\n\"",
    "octal to decimal": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * Converts any Octal Number to a Decimal Number\\n *\\n * @author Zachary Jones\\n */\\npublic class OctalToDecimal {\\n\\n    /**\\n     * Main method\\n     *\\n     * @param args Command line arguments\\n     */\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.print(\\\"Octal Input: \\\");\\n        String inputOctal = sc.nextLine();\\n        int result = convertOctalToDecimal(inputOctal);\\n        if (result != -1) {\\n            System.out.println(\\\"Result convertOctalToDecimal : \\\" + result);\\n        }\\n        sc.close();\\n    }\\n\\n    /**\\n     * This method converts an octal number to a decimal number.\\n     *\\n     * @param inputOctal The octal number\\n     * @return The decimal number\\n     */\\n    public static int convertOctalToDecimal(String inputOctal) {\\n\\n        try {\\n            // Actual conversion of Octal to Decimal:\\n            Integer outputDecimal = Integer.parseInt(inputOctal, 8);\\n            return outputDecimal;\\n        } catch (NumberFormatException ne) {\\n            // Printing a warning message if the input is not a valid octal\\n            // number:\\n            System.out.println(\\\"Invalid Input, Expecting octal number 0-7\\\");\\n            return -1;\\n        }\\n    }\\n}\\n\"",
    "octal to hexadecimal": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * Converts any Octal Number to HexaDecimal\\n *\\n * @author Tanmay Joshi\\n */\\npublic class OctalToHexadecimal {\\n\\n    /**\\n     * This method converts a Octal number to a decimal number\\n     *\\n     * @param s The Octal Number\\n     * @return The Decimal number\\n     */\\n    public static int octToDec(String s) {\\n        int i = 0;\\n        for (int j = 0; j < s.length(); j++) {\\n            char num = s.charAt(j);\\n            num -= '0';\\n            i *= 8;\\n            i += num;\\n        }\\n        return i;\\n    }\\n\\n    /**\\n     * This method converts a Decimal number to a Hexadecimal number\\n     *\\n     * @param d The Decimal Number\\n     * @return The Hexadecimal number\\n     */\\n    public static String decimalToHex(int d) {\\n        String digits = \\\"0123456789ABCDEF\\\";\\n        if (d <= 0) {\\n            return \\\"0\\\";\\n        }\\n        String hex = \\\"\\\";\\n        while (d > 0) {\\n            int digit = d % 16;\\n            hex = digits.charAt(digit) + hex;\\n            d = d / 16;\\n        }\\n        return hex;\\n    }\\n\\n    public static void main(String args[]) {\\n\\n        Scanner input = new Scanner(System.in);\\n        System.out.print(\\\"Enter the Octal number: \\\");\\n        // Take octal number as input from user in a string\\n        String oct = input.next();\\n\\n        // Pass the octal number to function and get converted decimal form\\n        int decimal = octToDec(oct);\\n\\n        // Pass the decimal number to function and get converted Hex form of the number\\n        String hex = decimalToHex(decimal);\\n        System.out.println(\\\"The Hexadecimal equivalant is: \\\" + hex);\\n        input.close();\\n    }\\n}\\n\"",
    "rgb hsv conversion": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Arrays;\\n\\n/**\\n * The RGB color model is an additive color model in which red, green, and blue\\n * light are added together in various ways to reproduce a broad array of\\n * colors. The name of the model comes from the initials of the three additive\\n * primary colors, red, green, and blue. Meanwhile, the HSV representation\\n * models how colors appear under light. In it, colors are represented using\\n * three components: hue, saturation and (brightness-)value. This class provides\\n * methods for converting colors from one representation to the other.\\n * (description adapted from https://en.wikipedia.org/wiki/RGB_color_model and\\n * https://en.wikipedia.org/wiki/HSL_and_HSV).\\n */\\npublic class RgbHsvConversion {\\n\\n    public static void main(String[] args) {\\n        // Expected RGB-values taken from https://www.rapidtables.com/convert/color/hsv-to-rgb.html\\n\\n        // Test hsvToRgb-method\\n        assert Arrays.equals(hsvToRgb(0, 0, 0), new int[]{0, 0, 0});\\n        assert Arrays.equals(hsvToRgb(0, 0, 1), new int[]{255, 255, 255});\\n        assert Arrays.equals(hsvToRgb(0, 1, 1), new int[]{255, 0, 0});\\n        assert Arrays.equals(hsvToRgb(60, 1, 1), new int[]{255, 255, 0});\\n        assert Arrays.equals(hsvToRgb(120, 1, 1), new int[]{0, 255, 0});\\n        assert Arrays.equals(hsvToRgb(240, 1, 1), new int[]{0, 0, 255});\\n        assert Arrays.equals(hsvToRgb(300, 1, 1), new int[]{255, 0, 255});\\n        assert Arrays.equals(hsvToRgb(180, 0.5, 0.5), new int[]{64, 128, 128});\\n        assert Arrays.equals(hsvToRgb(234, 0.14, 0.88), new int[]{193, 196, 224});\\n        assert Arrays.equals(hsvToRgb(330, 0.75, 0.5), new int[]{128, 32, 80});\\n\\n        // Test rgbToHsv-method\\n        // approximate-assertions needed because of small deviations due to converting between\\n        // int-values and double-values.\\n        assert approximatelyEqualHsv(rgbToHsv(0, 0, 0), new double[]{0, 0, 0});\\n        assert approximatelyEqualHsv(rgbToHsv(255, 255, 255), new double[]{0, 0, 1});\\n        assert approximatelyEqualHsv(rgbToHsv(255, 0, 0), new double[]{0, 1, 1});\\n        assert approximatelyEqualHsv(rgbToHsv(255, 255, 0), new double[]{60, 1, 1});\\n        assert approximatelyEqualHsv(rgbToHsv(0, 255, 0), new double[]{120, 1, 1});\\n        assert approximatelyEqualHsv(rgbToHsv(0, 0, 255), new double[]{240, 1, 1});\\n        assert approximatelyEqualHsv(rgbToHsv(255, 0, 255), new double[]{300, 1, 1});\\n        assert approximatelyEqualHsv(rgbToHsv(64, 128, 128), new double[]{180, 0.5, 0.5});\\n        assert approximatelyEqualHsv(rgbToHsv(193, 196, 224), new double[]{234, 0.14, 0.88});\\n        assert approximatelyEqualHsv(rgbToHsv(128, 32, 80), new double[]{330, 0.75, 0.5});\\n    }\\n\\n    /**\\n     * Conversion from the HSV-representation to the RGB-representation.\\n     *\\n     * @param hue Hue of the color.\\n     * @param saturation Saturation of the color.\\n     * @param value Brightness-value of the color.\\n     * @return The tuple of RGB-components.\\n     */\\n    public static int[] hsvToRgb(double hue, double saturation, double value) {\\n        if (hue < 0 || hue > 360) {\\n            throw new IllegalArgumentException(\\\"hue should be between 0 and 360\\\");\\n        }\\n\\n        if (saturation < 0 || saturation > 1) {\\n            throw new IllegalArgumentException(\\\"saturation should be between 0 and 1\\\");\\n        }\\n\\n        if (value < 0 || value > 1) {\\n            throw new IllegalArgumentException(\\\"value should be between 0 and 1\\\");\\n        }\\n\\n        double chroma = value * saturation;\\n        double hueSection = hue / 60;\\n        double secondLargestComponent = chroma * (1 - Math.abs(hueSection % 2 - 1));\\n        double matchValue = value - chroma;\\n\\n        return getRgbBySection(hueSection, chroma, matchValue, secondLargestComponent);\\n    }\\n\\n    /**\\n     * Conversion from the RGB-representation to the HSV-representation.\\n     *\\n     * @param red Red-component of the color.\\n     * @param green Green-component of the color.\\n     * @param blue Blue-component of the color.\\n     * @return The tuple of HSV-components.\\n     */\\n    public static double[] rgbToHsv(int red, int green, int blue) {\\n        if (red < 0 || red > 255) {\\n            throw new IllegalArgumentException(\\\"red should be between 0 and 255\\\");\\n        }\\n\\n        if (green < 0 || green > 255) {\\n            throw new IllegalArgumentException(\\\"green should be between 0 and 255\\\");\\n        }\\n\\n        if (blue < 0 || blue > 255) {\\n            throw new IllegalArgumentException(\\\"blue should be between 0 and 255\\\");\\n        }\\n\\n        double dRed = (double) red / 255;\\n        double dGreen = (double) green / 255;\\n        double dBlue = (double) blue / 255;\\n        double value = Math.max(Math.max(dRed, dGreen), dBlue);\\n        double chroma = value - Math.min(Math.min(dRed, dGreen), dBlue);\\n        double saturation = value == 0 ? 0 : chroma / value;\\n        double hue;\\n\\n        if (chroma == 0) {\\n            hue = 0;\\n        } else if (value == dRed) {\\n            hue = 60 * (0 + (dGreen - dBlue) / chroma);\\n        } else if (value == dGreen) {\\n            hue = 60 * (2 + (dBlue - dRed) / chroma);\\n        } else {\\n            hue = 60 * (4 + (dRed - dGreen) / chroma);\\n        }\\n\\n        hue = (hue + 360) % 360;\\n\\n        return new double[]{hue, saturation, value};\\n    }\\n\\n    private static boolean approximatelyEqualHsv(double[] hsv1, double[] hsv2) {\\n        boolean bHue = Math.abs(hsv1[0] - hsv2[0]) < 0.2;\\n        boolean bSaturation = Math.abs(hsv1[1] - hsv2[1]) < 0.002;\\n        boolean bValue = Math.abs(hsv1[2] - hsv2[2]) < 0.002;\\n\\n        return bHue && bSaturation && bValue;\\n    }\\n\\n    private static int[] getRgbBySection(\\n            double hueSection, double chroma, double matchValue, double secondLargestComponent) {\\n        int red;\\n        int green;\\n        int blue;\\n\\n        if (hueSection >= 0 && hueSection <= 1) {\\n            red = convertToInt(chroma + matchValue);\\n            green = convertToInt(secondLargestComponent + matchValue);\\n            blue = convertToInt(matchValue);\\n        } else if (hueSection > 1 && hueSection <= 2) {\\n            red = convertToInt(secondLargestComponent + matchValue);\\n            green = convertToInt(chroma + matchValue);\\n            blue = convertToInt(matchValue);\\n        } else if (hueSection > 2 && hueSection <= 3) {\\n            red = convertToInt(matchValue);\\n            green = convertToInt(chroma + matchValue);\\n            blue = convertToInt(secondLargestComponent + matchValue);\\n        } else if (hueSection > 3 && hueSection <= 4) {\\n            red = convertToInt(matchValue);\\n            green = convertToInt(secondLargestComponent + matchValue);\\n            blue = convertToInt(chroma + matchValue);\\n        } else if (hueSection > 4 && hueSection <= 5) {\\n            red = convertToInt(secondLargestComponent + matchValue);\\n            green = convertToInt(matchValue);\\n            blue = convertToInt(chroma + matchValue);\\n        } else {\\n            red = convertToInt(chroma + matchValue);\\n            green = convertToInt(matchValue);\\n            blue = convertToInt(secondLargestComponent + matchValue);\\n        }\\n\\n        return new int[]{red, green, blue};\\n    }\\n\\n    private static int convertToInt(double input) {\\n        return (int) Math.round(255 * input);\\n    }\\n}\\n\"",
    "roman to integer": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.*;\\n\\npublic class RomanToInteger {\\n\\n    private static Map<Character, Integer> map\\n            = new HashMap<Character, Integer>() {\\n        /**\\n         *          */\\n        private static final long serialVersionUID = 87605733047260530L;\\n\\n        {\\n            put('I', 1);\\n            put('V', 5);\\n            put('X', 10);\\n            put('L', 50);\\n            put('C', 100);\\n            put('D', 500);\\n            put('M', 1000);\\n        }\\n    };\\n    // Roman Number = Roman Numerals\\n\\n    /**\\n     * This function convert Roman number into Integer\\n     *\\n     * @param A Roman number string\\n     * @return integer\\n     */\\n    public static int romanToInt(String A) {\\n\\n        A = A.toUpperCase();\\n        char prev = ' ';\\n\\n        int sum = 0;\\n\\n        int newPrev = 0;\\n        for (int i = A.length() - 1; i >= 0; i--) {\\n            char c = A.charAt(i);\\n\\n            if (prev != ' ') {\\n                // checking current Number greater then previous or not\\n                newPrev = map.get(prev) > newPrev ? map.get(prev) : newPrev;\\n            }\\n\\n            int currentNum = map.get(c);\\n\\n            // if current number greater then prev max previous then add\\n            if (currentNum >= newPrev) {\\n                sum += currentNum;\\n            } else {\\n                // subtract upcoming number until upcoming number not greater then prev max\\n                sum -= currentNum;\\n            }\\n\\n            prev = c;\\n        }\\n\\n        return sum;\\n    }\\n\\n    public static void main(String[] args) {\\n        int sum = romanToInt(\\\"MDCCCIV\\\");\\n        System.out.println(sum);\\n    }\\n}\\n\"",
    "turkish to latin conversion": "\"package com.thealgorithms.conversions;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * Converts turkish character to latin character\\n *\\n * @author Özgün Gökşenli\\n */\\npublic class TurkishToLatinConversion {\\n\\n    /**\\n     * Main method\\n     *\\n     * @param args Command line arguments\\n     */\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.println(\\\"Input the string: \\\");\\n        String b = sc.next();\\n        System.out.println(\\\"Converted: \\\" + convertTurkishToLatin(b));\\n        sc.close();\\n    }\\n\\n    /**\\n     * This method converts a turkish character to latin character.\\n     *\\n     * @param param String paramter\\n     * @return String\\n     */\\n    public static String convertTurkishToLatin(String param) {\\n        char[] turkishChars\\n                = new char[]{0x131, 0x130, 0xFC, 0xDC, 0xF6, 0xD6, 0x15F, 0x15E, 0xE7, 0xC7, 0x11F, 0x11E};\\n        char[] latinChars = new char[]{'i', 'I', 'u', 'U', 'o', 'O', 's', 'S', 'c', 'C', 'g', 'G'};\\n        for (int i = 0; i < turkishChars.length; i++) {\\n            param\\n                    = param.replaceAll(\\n                            new String(new char[]{turkishChars[i]}), new String(new char[]{latinChars[i]}));\\n        }\\n        return param;\\n    }\\n}\\n\"",
    "binary exponentiation": "\"package com.thealgorithms.divideandconquer;\\n\\npublic class BinaryExponentiation {\\n\\n    public static void main(String args[]) {\\n        System.out.println(calculatePower(2, 30));\\n    }\\n\\n    // Function to calculate x^y\\n    // Time Complexity: O(logn)\\n    public static long calculatePower(long x, long y) {\\n        if (y == 0) {\\n            return 1;\\n        }\\n        long val = calculatePower(x, y / 2);\\n        val *= val;\\n        if (y % 2 == 1) {\\n            val *= x;\\n        }\\n        return val;\\n    }\\n}\\n\"",
    "closest pair": "\"package com.thealgorithms.divideandconquer;\\n\\n/**\\n * For a set of points in a coordinates system (10000 maximum), ClosestPair\\n * class calculates the two closest points.\\n */\\npublic final class ClosestPair {\\n\\n    /**\\n     * Number of points\\n     */\\n    int numberPoints;\\n    /**\\n     * Input data, maximum 10000.\\n     */\\n    private Location[] array;\\n    /**\\n     * Minimum point coordinate.\\n     */\\n    Location point1 = null;\\n    /**\\n     * Minimum point coordinate.\\n     */\\n    Location point2 = null;\\n    /**\\n     * Minimum point length.\\n     */\\n    private static double minNum = Double.MAX_VALUE;\\n\\n    public static void setMinNum(double minNum) {\\n        ClosestPair.minNum = minNum;\\n    }\\n\\n    public static void setSecondCount(int secondCount) {\\n        ClosestPair.secondCount = secondCount;\\n    }\\n\\n    /**\\n     * secondCount\\n     */\\n    private static int secondCount = 0;\\n\\n    /**\\n     * Constructor.\\n     */\\n    ClosestPair(int points) {\\n        numberPoints = points;\\n        array = new Location[numberPoints];\\n    }\\n\\n    /**\\n     * Location class is an auxiliary type to keep points coordinates.\\n     */\\n    public static class Location {\\n\\n        double x;\\n        double y;\\n\\n        /**\\n         * @param xpar (IN Parameter) x coordinate <br>\\n         * @param ypar (IN Parameter) y coordinate <br>\\n         */\\n        Location(final double xpar, final double ypar) { // Save x, y coordinates\\n            this.x = xpar;\\n            this.y = ypar;\\n        }\\n    }\\n\\n    public Location[] createLocation(int numberValues) {\\n        return new Location[numberValues];\\n    }\\n\\n    public Location buildLocation(double x, double y) {\\n        return new Location(x, y);\\n    }\\n\\n    /**\\n     * xPartition function: arrange x-axis.\\n     *\\n     * @param a (IN Parameter) array of points <br>\\n     * @param first (IN Parameter) first point <br>\\n     * @param last (IN Parameter) last point <br>\\n     * @return pivot index\\n     */\\n    public int xPartition(final Location[] a, final int first, final int last) {\\n\\n        Location pivot = a[last]; // pivot\\n        int i = first - 1;\\n        Location temp; // Temporarily store value for position transformation\\n        for (int j = first; j <= last - 1; j++) {\\n            if (a[j].x <= pivot.x) { // Less than or less than pivot\\n                i++;\\n                temp = a[i]; // array[i] <-> array[j]\\n                a[i] = a[j];\\n                a[j] = temp;\\n            }\\n        }\\n        i++;\\n        temp = a[i]; // array[pivot] <-> array[i]\\n        a[i] = a[last];\\n        a[last] = temp;\\n        return i; // pivot index\\n    }\\n\\n    /**\\n     * yPartition function: arrange y-axis.\\n     *\\n     * @param a (IN Parameter) array of points <br>\\n     * @param first (IN Parameter) first point <br>\\n     * @param last (IN Parameter) last point <br>\\n     * @return pivot index\\n     */\\n    public int yPartition(final Location[] a, final int first, final int last) {\\n\\n        Location pivot = a[last]; // pivot\\n        int i = first - 1;\\n        Location temp; // Temporarily store value for position transformation\\n        for (int j = first; j <= last - 1; j++) {\\n            if (a[j].y <= pivot.y) { // Less than or less than pivot\\n                i++;\\n                temp = a[i]; // array[i] <-> array[j]\\n                a[i] = a[j];\\n                a[j] = temp;\\n            }\\n        }\\n        i++;\\n        temp = a[i]; // array[pivot] <-> array[i]\\n        a[i] = a[last];\\n        a[last] = temp;\\n        return i; // pivot index\\n    }\\n\\n    /**\\n     * xQuickSort function: //x-axis Quick Sorting.\\n     *\\n     * @param a (IN Parameter) array of points <br>\\n     * @param first (IN Parameter) first point <br>\\n     * @param last (IN Parameter) last point <br>\\n     */\\n    public void xQuickSort(final Location[] a, final int first, final int last) {\\n\\n        if (first < last) {\\n            int q = xPartition(a, first, last); // pivot\\n            xQuickSort(a, first, q - 1); // Left\\n            xQuickSort(a, q + 1, last); // Right\\n        }\\n    }\\n\\n    /**\\n     * yQuickSort function: //y-axis Quick Sorting.\\n     *\\n     * @param a (IN Parameter) array of points <br>\\n     * @param first (IN Parameter) first point <br>\\n     * @param last (IN Parameter) last point <br>\\n     */\\n    public void yQuickSort(final Location[] a, final int first, final int last) {\\n\\n        if (first < last) {\\n            int q = yPartition(a, first, last); // pivot\\n            yQuickSort(a, first, q - 1); // Left\\n            yQuickSort(a, q + 1, last); // Right\\n        }\\n    }\\n\\n    /**\\n     * closestPair function: find closest pair.\\n     *\\n     * @param a (IN Parameter) array stored before divide <br>\\n     * @param indexNum (IN Parameter) number coordinates divideArray <br>\\n     * @return minimum distance <br>\\n     */\\n    public double closestPair(final Location[] a, final int indexNum) {\\n\\n        Location[] divideArray = new Location[indexNum];\\n        System.arraycopy(a, 0, divideArray, 0, indexNum); // Copy previous array\\n        int divideX = indexNum / 2; // Intermediate value for divide\\n        Location[] leftArray = new Location[divideX]; // divide - left array\\n        // divide-right array\\n        Location[] rightArray = new Location[indexNum - divideX];\\n        if (indexNum <= 3) { // If the number of coordinates is 3 or less\\n            return bruteForce(divideArray);\\n        }\\n        // divide-left array\\n        System.arraycopy(divideArray, 0, leftArray, 0, divideX);\\n        // divide-right array\\n        System.arraycopy(divideArray, divideX, rightArray, 0, indexNum - divideX);\\n\\n        double minLeftArea; // Minimum length of left array\\n        double minRightArea; // Minimum length of right array\\n        double minValue; // Minimum lengt\\n\\n        minLeftArea = closestPair(leftArray, divideX); // recursive closestPair\\n        minRightArea = closestPair(rightArray, indexNum - divideX);\\n        // window size (= minimum length)\\n        minValue = Math.min(minLeftArea, minRightArea);\\n\\n        // Create window.  Set the size for creating a window\\n        // and creating a new array for the coordinates in the window\\n        for (int i = 0; i < indexNum; i++) {\\n            double xGap = Math.abs(divideArray[divideX].x - divideArray[i].x);\\n            if (xGap < minValue) {\\n                ClosestPair.setSecondCount(secondCount + 1); // size of the array\\n            } else {\\n                if (divideArray[i].x > divideArray[divideX].x) {\\n                    break;\\n                }\\n            }\\n        }\\n        // new array for coordinates in window\\n        Location[] firstWindow = new Location[secondCount];\\n        int k = 0;\\n        for (int i = 0; i < indexNum; i++) {\\n            double xGap = Math.abs(divideArray[divideX].x - divideArray[i].x);\\n            if (xGap < minValue) { // if it's inside a window\\n                firstWindow[k] = divideArray[i]; // put in an array\\n                k++;\\n            } else {\\n                if (divideArray[i].x > divideArray[divideX].x) {\\n                    break;\\n                }\\n            }\\n        }\\n        yQuickSort(firstWindow, 0, secondCount - 1); // Sort by y coordinates\\n        /* Coordinates in Window */\\n        double length;\\n        // size comparison within window\\n        for (int i = 0; i < secondCount - 1; i++) {\\n            for (int j = (i + 1); j < secondCount; j++) {\\n                double xGap = Math.abs(firstWindow[i].x - firstWindow[j].x);\\n                double yGap = Math.abs(firstWindow[i].y - firstWindow[j].y);\\n                if (yGap < minValue) {\\n                    length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));\\n                    // If measured distance is less than current min distance\\n                    if (length < minValue) {\\n                        // Change minimum distance to current distance\\n                        minValue = length;\\n                        // Conditional for registering final coordinate\\n                        if (length < minNum) {\\n                            ClosestPair.setMinNum(length);\\n                            point1 = firstWindow[i];\\n                            point2 = firstWindow[j];\\n                        }\\n                    }\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        ClosestPair.setSecondCount(0);\\n        return minValue;\\n    }\\n\\n    /**\\n     * bruteForce function: When the number of coordinates is less than 3.\\n     *\\n     * @param arrayParam (IN Parameter) array stored before divide <br>\\n     * @return <br>\\n     */\\n    public double bruteForce(final Location[] arrayParam) {\\n\\n        double minValue = Double.MAX_VALUE; // minimum distance\\n        double length;\\n        double xGap; // Difference between x coordinates\\n        double yGap; // Difference between y coordinates\\n        double result = 0;\\n\\n        if (arrayParam.length == 2) {\\n            // Difference between x coordinates\\n            xGap = (arrayParam[0].x - arrayParam[1].x);\\n            // Difference between y coordinates\\n            yGap = (arrayParam[0].y - arrayParam[1].y);\\n            // distance between coordinates\\n            length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));\\n            // Conditional statement for registering final coordinate\\n            if (length < minNum) {\\n                ClosestPair.setMinNum(length);\\n            }\\n            point1 = arrayParam[0];\\n            point2 = arrayParam[1];\\n            result = length;\\n        }\\n        if (arrayParam.length == 3) {\\n            for (int i = 0; i < arrayParam.length - 1; i++) {\\n                for (int j = (i + 1); j < arrayParam.length; j++) {\\n                    // Difference between x coordinates\\n                    xGap = (arrayParam[i].x - arrayParam[j].x);\\n                    // Difference between y coordinates\\n                    yGap = (arrayParam[i].y - arrayParam[j].y);\\n                    // distance between coordinates\\n                    length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));\\n                    // If measured distance is less than current min distance\\n                    if (length < minValue) {\\n                        // Change minimum distance to current distance\\n                        minValue = length;\\n                        if (length < minNum) {\\n                            // Registering final coordinate\\n                            ClosestPair.setMinNum(length);\\n                            point1 = arrayParam[i];\\n                            point2 = arrayParam[j];\\n                        }\\n                    }\\n                }\\n            }\\n            result = minValue;\\n        }\\n        return result; // If only one point returns 0.\\n    }\\n\\n    /**\\n     * main function: execute class.\\n     *\\n     * @param args (IN Parameter) <br>\\n     */\\n    public static void main(final String[] args) {\\n\\n        // Input data consists of one x-coordinate and one y-coordinate\\n        ClosestPair cp = new ClosestPair(12);\\n        cp.array[0] = cp.buildLocation(2, 3);\\n        cp.array[1] = cp.buildLocation(2, 16);\\n        cp.array[2] = cp.buildLocation(3, 9);\\n        cp.array[3] = cp.buildLocation(6, 3);\\n        cp.array[4] = cp.buildLocation(7, 7);\\n        cp.array[5] = cp.buildLocation(19, 4);\\n        cp.array[6] = cp.buildLocation(10, 11);\\n        cp.array[7] = cp.buildLocation(15, 2);\\n        cp.array[8] = cp.buildLocation(15, 19);\\n        cp.array[9] = cp.buildLocation(16, 11);\\n        cp.array[10] = cp.buildLocation(17, 13);\\n        cp.array[11] = cp.buildLocation(9, 12);\\n\\n        System.out.println(\\\"Input data\\\");\\n        System.out.println(\\\"Number of points: \\\" + cp.array.length);\\n        for (int i = 0; i < cp.array.length; i++) {\\n            System.out.println(\\\"x: \\\" + cp.array[i].x + \\\", y: \\\" + cp.array[i].y);\\n        }\\n\\n        cp.xQuickSort(cp.array, 0, cp.array.length - 1); // Sorting by x value\\n\\n        double result; // minimum distance\\n\\n        result = cp.closestPair(cp.array, cp.array.length);\\n        // ClosestPair start\\n        // minimum distance coordinates and distance output\\n        System.out.println(\\\"Output Data\\\");\\n        System.out.println(\\\"(\\\" + cp.point1.x + \\\", \\\" + cp.point1.y + \\\")\\\");\\n        System.out.println(\\\"(\\\" + cp.point2.x + \\\", \\\" + cp.point2.y + \\\")\\\");\\n        System.out.println(\\\"Minimum Distance : \\\" + result);\\n    }\\n}\\n\"",
    "skyline algorithm": "\"package com.thealgorithms.divideandconquer;\\n\\nimport java.util.ArrayList;\\nimport java.util.Comparator;\\n\\n/**\\n * @author dimgrichr\\n * <p>\\n * Space complexity: O(n) Time complexity: O(nlogn), because it is a divide and\\n * conquer algorithm\\n */\\npublic class SkylineAlgorithm {\\n\\n    private ArrayList<Point> points;\\n\\n    /**\\n     * Main constructor of the application. ArrayList points gets created, which\\n     * represents the sum of all edges.\\n     */\\n    public SkylineAlgorithm() {\\n        points = new ArrayList<>();\\n    }\\n\\n    /**\\n     * @return points, the ArrayList that includes all points.\\n     */\\n    public ArrayList<Point> getPoints() {\\n        return points;\\n    }\\n\\n    /**\\n     * The main divide and conquer, and also recursive algorithm. It gets an\\n     * ArrayList full of points as an argument. If the size of that ArrayList is\\n     * 1 or 2, the ArrayList is returned as it is, or with one less point (if\\n     * the initial size is 2 and one of it's points, is dominated by the other\\n     * one). On the other hand, if the ArrayList's size is bigger than 2, the\\n     * function is called again, twice, with arguments the corresponding half of\\n     * the initial ArrayList each time. Once the flashback has ended, the\\n     * function produceFinalSkyLine gets called, in order to produce the final\\n     * skyline, and return it.\\n     *\\n     * @param list, the initial list of points\\n     * @return leftSkyLine, the combination of first half's and second half's\\n     * skyline\\n     * @see Point\\n     */\\n    public ArrayList<Point> produceSubSkyLines(ArrayList<Point> list) {\\n\\n        // part where function exits flashback\\n        int size = list.size();\\n        if (size == 1) {\\n            return list;\\n        } else if (size == 2) {\\n            if (list.get(0).dominates(list.get(1))) {\\n                list.remove(1);\\n            } else {\\n                if (list.get(1).dominates(list.get(0))) {\\n                    list.remove(0);\\n                }\\n            }\\n            return list;\\n        }\\n\\n        // recursive part of the function\\n        ArrayList<Point> leftHalf = new ArrayList<>();\\n        ArrayList<Point> rightHalf = new ArrayList<>();\\n        for (int i = 0; i < list.size(); i++) {\\n            if (i < list.size() / 2) {\\n                leftHalf.add(list.get(i));\\n            } else {\\n                rightHalf.add(list.get(i));\\n            }\\n        }\\n        ArrayList<Point> leftSubSkyLine = produceSubSkyLines(leftHalf);\\n        ArrayList<Point> rightSubSkyLine = produceSubSkyLines(rightHalf);\\n\\n        // skyline is produced\\n        return produceFinalSkyLine(leftSubSkyLine, rightSubSkyLine);\\n    }\\n\\n    /**\\n     * The first half's skyline gets cleared from some points that are not part\\n     * of the final skyline (Points with same x-value and different y=values.\\n     * The point with the smallest y-value is kept). Then, the minimum y-value\\n     * of the points of first half's skyline is found. That helps us to clear\\n     * the second half's skyline, because, the points of second half's skyline\\n     * that have greater y-value of the minimum y-value that we found before,\\n     * are dominated, so they are not part of the final skyline. Finally, the\\n     * \\\"cleaned\\\" first half's and second half's skylines, are combined,\\n     * producing the final skyline, which is returned.\\n     *\\n     * @param left the skyline of the left part of points\\n     * @param right the skyline of the right part of points\\n     * @return left the final skyline\\n     */\\n    public ArrayList<Point> produceFinalSkyLine(ArrayList<Point> left, ArrayList<Point> right) {\\n\\n        // dominated points of ArrayList left are removed\\n        for (int i = 0; i < left.size() - 1; i++) {\\n            if (left.get(i).x == left.get(i + 1).x && left.get(i).y > left.get(i + 1).y) {\\n                left.remove(i);\\n                i--;\\n            }\\n        }\\n\\n        // minimum y-value is found\\n        int min = left.get(0).y;\\n        for (int i = 1; i < left.size(); i++) {\\n            if (min > left.get(i).y) {\\n                min = left.get(i).y;\\n                if (min == 1) {\\n                    i = left.size();\\n                }\\n            }\\n        }\\n\\n        // dominated points of ArrayList right are removed\\n        for (int i = 0; i < right.size(); i++) {\\n            if (right.get(i).y >= min) {\\n                right.remove(i);\\n                i--;\\n            }\\n        }\\n\\n        // final skyline found and returned\\n        left.addAll(right);\\n        return left;\\n    }\\n\\n    public static class Point {\\n\\n        private int x;\\n        private int y;\\n\\n        /**\\n         * The main constructor of Point Class, used to represent the 2\\n         * Dimension points.\\n         *\\n         * @param x the point's x-value.\\n         * @param y the point's y-value.\\n         */\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        /**\\n         * @return x, the x-value\\n         */\\n        public int getX() {\\n            return x;\\n        }\\n\\n        /**\\n         * @return y, the y-value\\n         */\\n        public int getY() {\\n            return y;\\n        }\\n\\n        /**\\n         * Based on the skyline theory, it checks if the point that calls the\\n         * function dominates the argument point.\\n         *\\n         * @param p1 the point that is compared\\n         * @return true if the point wich calls the function dominates p1 false\\n         * otherwise.\\n         */\\n        public boolean dominates(Point p1) {\\n            // checks if p1 is dominated\\n            return (this.x < p1.x && this.y <= p1.y) || (this.x <= p1.x && this.y < p1.y);\\n        }\\n    }\\n\\n    /**\\n     * It is used to compare the 2 Dimension points, based on their x-values, in\\n     * order get sorted later.\\n     */\\n    class XComparator implements Comparator<Point> {\\n\\n        @Override\\n        public int compare(Point a, Point b) {\\n            return Integer.compare(a.x, b.x);\\n        }\\n    }\\n}\\n\"",
    "strassen matrix multiplication": "\"package com.thealgorithms.divideandconquer;\\n\\n// Java Program to Implement Strassen Algorithm\\n// Class Strassen matrix multiplication\\npublic class StrassenMatrixMultiplication {\\n\\n    // Method 1\\n    // Function to multiply matrices\\n    public int[][] multiply(int[][] A, int[][] B) {\\n        int n = A.length;\\n\\n        int[][] R = new int[n][n];\\n\\n        if (n == 1) {\\n            R[0][0] = A[0][0] * B[0][0];\\n        } else {\\n            // Dividing Matrix into parts\\n            // by storing sub-parts to variables\\n            int[][] A11 = new int[n / 2][n / 2];\\n            int[][] A12 = new int[n / 2][n / 2];\\n            int[][] A21 = new int[n / 2][n / 2];\\n            int[][] A22 = new int[n / 2][n / 2];\\n            int[][] B11 = new int[n / 2][n / 2];\\n            int[][] B12 = new int[n / 2][n / 2];\\n            int[][] B21 = new int[n / 2][n / 2];\\n            int[][] B22 = new int[n / 2][n / 2];\\n\\n            // Dividing matrix A into 4 parts\\n            split(A, A11, 0, 0);\\n            split(A, A12, 0, n / 2);\\n            split(A, A21, n / 2, 0);\\n            split(A, A22, n / 2, n / 2);\\n\\n            // Dividing matrix B into 4 parts\\n            split(B, B11, 0, 0);\\n            split(B, B12, 0, n / 2);\\n            split(B, B21, n / 2, 0);\\n            split(B, B22, n / 2, n / 2);\\n\\n            // Using Formulas as described in algorithm\\n            // M1:=(A1+A3)×(B1+B2)\\n            int[][] M1\\n                    = multiply(add(A11, A22), add(B11, B22));\\n\\n            // M2:=(A2+A4)×(B3+B4)\\n            int[][] M2 = multiply(add(A21, A22), B11);\\n\\n            // M3:=(A1−A4)×(B1+A4)\\n            int[][] M3 = multiply(A11, sub(B12, B22));\\n\\n            // M4:=A1×(B2−B4)\\n            int[][] M4 = multiply(A22, sub(B21, B11));\\n\\n            // M5:=(A3+A4)×(B1)\\n            int[][] M5 = multiply(add(A11, A12), B22);\\n\\n            // M6:=(A1+A2)×(B4)\\n            int[][] M6\\n                    = multiply(sub(A21, A11), add(B11, B12));\\n\\n            // M7:=A4×(B3−B1)\\n            int[][] M7\\n                    = multiply(sub(A12, A22), add(B21, B22));\\n\\n            // P:=M2+M3−M6−M7\\n            int[][] C11 = add(sub(add(M1, M4), M5), M7);\\n\\n            // Q:=M4+M6\\n            int[][] C12 = add(M3, M5);\\n\\n            // R:=M5+M7\\n            int[][] C21 = add(M2, M4);\\n\\n            // S:=M1−M3−M4−M5\\n            int[][] C22 = add(sub(add(M1, M3), M2), M6);\\n\\n            join(C11, R, 0, 0);\\n            join(C12, R, 0, n / 2);\\n            join(C21, R, n / 2, 0);\\n            join(C22, R, n / 2, n / 2);\\n        }\\n\\n        return R;\\n    }\\n\\n    // Method 2\\n    // Function to subtract two matrices\\n    public int[][] sub(int[][] A, int[][] B) {\\n        int n = A.length;\\n\\n        int[][] C = new int[n][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                C[i][j] = A[i][j] - B[i][j];\\n            }\\n        }\\n\\n        return C;\\n    }\\n\\n    // Method 3\\n    // Function to add two matrices\\n    public int[][] add(int[][] A, int[][] B) {\\n\\n        int n = A.length;\\n\\n        int[][] C = new int[n][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                C[i][j] = A[i][j] + B[i][j];\\n            }\\n        }\\n\\n        return C;\\n    }\\n\\n    // Method 4\\n    // Function to split parent matrix\\n    // into child matrices\\n    public void split(int[][] P, int[][] C, int iB, int jB) {\\n        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {\\n            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {\\n                C[i1][j1] = P[i2][j2];\\n            }\\n        }\\n    }\\n\\n    // Method 5\\n    // Function to join child matrices\\n    // into (to) parent matrix\\n    public void join(int[][] C, int[][] P, int iB, int jB) {\\n        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {\\n            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {\\n                P[i2][j2] = C[i1][j1];\\n            }\\n        }\\n    }\\n\\n    // Method 5\\n    // Main driver method\\n    public static void main(String[] args) {\\n        System.out.println(\\\"Strassen Multiplication Algorithm Implementation For Matrix Multiplication :\\\\n\\\");\\n\\n        StrassenMatrixMultiplication s = new StrassenMatrixMultiplication();\\n\\n        // Size of matrix\\n        // Considering size as 4 in order to illustrate\\n        int N = 4;\\n\\n        // Matrix A\\n        // Custom input to matrix\\n        int[][] A = {{1, 2, 5, 4},\\n        {9, 3, 0, 6},\\n        {4, 6, 3, 1},\\n        {0, 2, 0, 6}};\\n\\n        // Matrix B\\n        // Custom input to matrix\\n        int[][] B = {{1, 0, 4, 1},\\n        {1, 2, 0, 2},\\n        {0, 3, 1, 3},\\n        {1, 8, 1, 2}};\\n\\n        // Matrix C computations\\n        // Matrix C calling method to get Result\\n        int[][] C = s.multiply(A, B);\\n\\n        System.out.println(\\\"\\\\nProduct of matrices A and  B : \\\");\\n\\n        // Print the output\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                System.out.print(C[i][j] + \\\" \\\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n}\\n\"",
    "board path": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/*\\n* this is an important Algo in which\\n* we have starting and ending of board and we have to reach\\n* we have to count no. of ways\\n* that help to reach end point i.e number by rolling dice\\n* which have 1 to 6 digits\\n\\nTest Case:\\nhere target is 10\\n\\nint n=10;\\n\\t\\tstartAlgo();\\n\\t\\tSystem.out.println(bpR(0,n));\\n\\t\\tSystem.out.println(endAlgo()+\\\"ms\\\");\\n\\t\\tint[] strg=new int [n+1];\\n\\t\\tstartAlgo();\\n\\t\\tSystem.out.println(bpRS(0,n,strg));\\n\\t\\tSystem.out.println(endAlgo()+\\\"ms\\\");\\n\\t\\tstartAlgo();\\n\\t\\tSystem.out.println(bpIS(0,n,strg));\\n\\t\\tSystem.out.println(endAlgo()+\\\"ms\\\");\\n\\n\\n\\n */\\npublic class BoardPath {\\n\\n    public static long startTime;\\n    public static long endTime;\\n\\n    public static void startAlgo() {\\n        startTime = System.currentTimeMillis();\\n    }\\n\\n    public static long endAlgo() {\\n        endTime = System.currentTimeMillis();\\n        return endTime - startTime;\\n    }\\n\\n    public static int bpR(int start, int end) {\\n        if (start == end) {\\n            return 1;\\n        } else if (start > end) {\\n            return 0;\\n        }\\n        int count = 0;\\n        for (int dice = 1; dice <= 6; dice++) {\\n            count += bpR(start + dice, end);\\n        }\\n        return count;\\n    }\\n\\n    public static int bpRS(int curr, int end, int strg[]) {\\n        if (curr == end) {\\n            return 1;\\n        } else if (curr > end) {\\n            return 0;\\n        }\\n        if (strg[curr] != 0) {\\n            return strg[curr];\\n        }\\n        int count = 0;\\n        for (int dice = 1; dice <= 6; dice++) {\\n            count += bpRS(curr + dice, end, strg);\\n        }\\n        strg[curr] = count;\\n        return count;\\n    }\\n\\n    public static int bpIS(int curr, int end, int[] strg) {\\n        strg[end] = 1;\\n        for (int i = end - 1; i >= 0; i--) {\\n            int count = 0;\\n            for (int dice = 1; dice <= 6 && dice + i < strg.length; dice++) {\\n                count += strg[i + dice];\\n            }\\n            strg[i] = count;\\n        }\\n        return strg[0];\\n    }\\n}\\n\"",
    "boundary fill": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * Java program for Boundary fill algorithm.\\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\\n */\\npublic class BoundaryFill {\\n\\t\\n    /**\\n     * Get the color at the given co-odrinates of a 2D image\\n     *\\n     * @param image The image to be filled\\n     * @param x_co_ordinate The x co-ordinate of which color is to be obtained\\n     * @param y_co_ordinate The y co-ordinate of which color is to be obtained\\n     */\\n\\tpublic static int getPixel(int[][] image, int x_co_ordinate, int y_co_ordinate) {\\n\\t\\n\\t\\treturn image[x_co_ordinate][y_co_ordinate];\\n\\t\\n\\t}\\n\\t\\n    /**\\n     * Put the color at the given co-odrinates of a 2D image\\n     *\\n     * @param image The image to be filed\\n     * @param x_co_ordinate The x co-ordinate at which color is to be filled\\n     * @param y_co_ordinate The y co-ordinate at which color is to be filled\\n     */\\n\\tpublic static void putPixel(int[][] image, int x_co_ordinate, int y_co_ordinate, int new_color) {\\n\\t\\t\\n\\t\\timage[x_co_ordinate][y_co_ordinate] = new_color;\\n\\t\\n\\t}\\n\\t\\n    /**\\n     * Fill the 2D image with new color\\n     *\\n     * @param image The image to be filed\\n     * @param x_co_ordinate The x co-ordinate at which color is to be filled\\n     * @param y_co_ordinate The y co-ordinate at which color is to be filled\\n     * @param new_color The new color which to be filled in the image\\n     * @param boundary_color The old color which is to be replaced in the image\\n     */\\n\\tpublic static void boundaryFill(int[][] image, int x_co_ordinate, int y_co_ordinate, int new_color, int boundary_color) {\\n\\t\\tif(x_co_ordinate >= 0 && y_co_ordinate >= 0 && getPixel(image, x_co_ordinate, y_co_ordinate) != new_color && getPixel(image, x_co_ordinate, y_co_ordinate) != boundary_color) {\\n\\t\\t\\t\\n\\t\\t\\tputPixel(image, x_co_ordinate, y_co_ordinate, new_color);\\n\\t\\t\\tboundaryFill(image, x_co_ordinate + 1, y_co_ordinate, new_color, boundary_color);\\n\\t\\t\\tboundaryFill(image, x_co_ordinate - 1, y_co_ordinate, new_color, boundary_color);\\n\\t\\t\\tboundaryFill(image, x_co_ordinate, y_co_ordinate + 1, new_color, boundary_color);\\n\\t\\t\\tboundaryFill(image, x_co_ordinate, y_co_ordinate - 1, new_color, boundary_color);\\n\\t\\t\\tboundaryFill(image, x_co_ordinate + 1, y_co_ordinate - 1, new_color, boundary_color);\\n\\t\\t\\tboundaryFill(image, x_co_ordinate - 1, y_co_ordinate + 1, new_color, boundary_color);\\n\\t\\t\\tboundaryFill(image, x_co_ordinate + 1, y_co_ordinate + 1, new_color, boundary_color);\\n\\t\\t\\tboundaryFill(image, x_co_ordinate - 1, y_co_ordinate - 1, new_color, boundary_color);\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t\\n    /**\\n     * This method will print the 2D image matrix\\n     *\\n     * @param image The image to be printed on the console\\n     */\\n\\tpublic static void printImageArray(int[][] image) {\\n\\t\\t\\n\\t\\tfor(int i=0 ; i<image.length ; i++) {\\n\\t\\t\\tfor(int j=0 ; j<image[0].length ; j++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tSystem.out.print(image[i][j]+\\\"  \\\");\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tSystem.out.println();\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t\\n\\t// Driver Program\\n\\tpublic static void main(String[] args) {\\n\\t\\t\\n\\t\\t//Input 2D image matrix\\n\\t\\tint[][] image = {\\n\\t\\t\\t\\t{0,0,0,0,0,0,0},\\n\\t\\t\\t\\t{0,3,3,3,3,0,0},\\n\\t\\t\\t\\t{0,3,0,0,3,0,0},\\n\\t\\t\\t\\t{0,3,0,0,3,3,3},\\n\\t\\t\\t\\t{0,3,3,3,0,0,3},\\n\\t\\t\\t\\t{0,0,0,3,0,0,3},\\n\\t\\t\\t\\t{0,0,0,3,3,3,3}\\n\\t\\t};\\n\\t\\t\\n\\t\\t\\n\\t\\tboundaryFill(image,2,2,5,3);\\n\\t\\t\\n\\t\\t/* Output ==>\\n\\t\\t * 0  0  0  0  0  0  0  \\n\\t\\t   0  3  3  3  3  0  0  \\n\\t\\t   0  3  5  5  3  0  0  \\n           0  3  5  5  3  3  3  \\n           0  3  3  3  5  5  3  \\n           0  0  0  3  5  5  3  \\n           0  0  0  3  3  3  3\\n\\t\\t * */\\n\\t\\t\\n\\t\\t//print 2D image matrix\\n\\t\\tprintImageArray(image);\\n\\t}\\n\\n}\"",
    "brute force knapsack": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/* A Naive recursive implementation\\nof 0-1 Knapsack problem */\\npublic class BruteForceKnapsack {\\n\\n    // A utility function that returns\\n    // maximum of two integers\\n    static int max(int a, int b) {\\n        return (a > b) ? a : b;\\n    }\\n\\n    // Returns the maximum value that\\n    // can be put in a knapsack of\\n    // capacity W\\n    static int knapSack(int W, int wt[], int val[], int n) {\\n        // Base Case\\n        if (n == 0 || W == 0) {\\n            return 0;\\n        }\\n\\n        // If weight of the nth item is\\n        // more than Knapsack capacity W,\\n        // then this item cannot be included\\n        // in the optimal solution\\n        if (wt[n - 1] > W) {\\n            return knapSack(W, wt, val, n - 1);\\n        } // Return the maximum of two cases:\\n        // (1) nth item included\\n        // (2) not included\\n        else {\\n            return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1), knapSack(W, wt, val, n - 1));\\n        }\\n    }\\n\\n    // Driver code\\n    public static void main(String args[]) {\\n        int val[] = new int[]{60, 100, 120};\\n        int wt[] = new int[]{10, 20, 30};\\n        int W = 50;\\n        int n = val.length;\\n        System.out.println(knapSack(W, wt, val, n));\\n    }\\n}\\n\"",
    "catalan number": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * This file contains an implementation of finding the nth CATALAN NUMBER using\\n * dynamic programming Wikipedia: https://en.wikipedia.org/wiki/Catalan_number\\n *\\n * Time Complexity: O(n^2) Space Complexity: O(n)\\n *\\n * @author AMRITESH ANAND (https://github.com/amritesh19)\\n */\\nimport java.util.Scanner;\\n\\npublic class CatalanNumber {\\n\\n    /**\\n     * This method finds the nth Catalan number\\n     *\\n     * @param n input n which determines the nth Catalan number n should be less\\n     * than equal to 50 as 50th Catalan number is 6,533,841,209,031,609,592 for\\n     * n > 50, BigInteger class should be used instead long\\n     *\\n     * @return catalanArray[n] the nth Catalan number\\n     */\\n    static long findNthCatalan(int n) {\\n\\n        // Array to store the results of subproblems i.e Catalan numbers from [1...n-1]\\n        long catalanArray[] = new long[n + 1];\\n\\n        // Initialising C₀ = 1 and C₁ = 1 \\n        catalanArray[0] = 1;\\n        catalanArray[1] = 1;\\n\\n        /**\\n         * The Catalan numbers satisfy the recurrence relation C₀=1 and Cn = Σ\\n         * (Ci * Cn-1-i), i = 0 to n-1 , n > 0\\n         */\\n        for (int i = 2; i <= n; i++) {\\n            catalanArray[i] = 0;\\n            for (int j = 0; j < i; j++) {\\n                catalanArray[i] += catalanArray[j] * catalanArray[i - j - 1];\\n            }\\n        }\\n\\n        return catalanArray[n];\\n    }\\n\\n    // Main method\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n\\n        System.out.println(\\\"Enter the number n to find nth Catalan number (n <= 50)\\\");\\n        int n = sc.nextInt();\\n        System.out.println(n + \\\"th Catalan number is \\\" + findNthCatalan(n));\\n\\n        sc.close();\\n    }\\n}\\n\"",
    "coin change": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * @author Varun Upadhyay (https://github.com/varunu28)\\n */\\npublic class CoinChange {\\n\\n    // Driver Program\\n    public static void main(String[] args) {\\n\\n        int amount = 12;\\n        int[] coins = {2, 4, 5};\\n\\n        System.out.println(\\n                \\\"Number of combinations of getting change for \\\" + amount + \\\" is: \\\" + change(coins, amount));\\n        System.out.println(\\n                \\\"Minimum number of coins required for amount :\\\"\\n                + amount\\n                + \\\" is: \\\"\\n                + minimumCoins(coins, amount));\\n    }\\n\\n    /**\\n     * This method finds the number of combinations of getting change for a\\n     * given amount and change coins\\n     *\\n     * @param coins The list of coins\\n     * @param amount The amount for which we need to find the change Finds the\\n     * number of combinations of change\\n     */\\n    public static int change(int[] coins, int amount) {\\n\\n        int[] combinations = new int[amount + 1];\\n        combinations[0] = 1;\\n\\n        for (int coin : coins) {\\n            for (int i = coin; i < amount + 1; i++) {\\n                combinations[i] += combinations[i - coin];\\n            }\\n            // Uncomment the below line to see the state of combinations for each coin\\n            // printAmount(combinations);\\n        }\\n\\n        return combinations[amount];\\n    }\\n\\n    /**\\n     * This method finds the minimum number of coins needed for a given amount.\\n     *\\n     * @param coins The list of coins\\n     * @param amount The amount for which we need to find the minimum number of\\n     * coins. Finds the the minimum number of coins that make a given value.\\n     */\\n    public static int minimumCoins(int[] coins, int amount) {\\n        // minimumCoins[i] will store the minimum coins needed for amount i\\n        int[] minimumCoins = new int[amount + 1];\\n\\n        minimumCoins[0] = 0;\\n\\n        for (int i = 1; i <= amount; i++) {\\n            minimumCoins[i] = Integer.MAX_VALUE;\\n        }\\n        for (int i = 1; i <= amount; i++) {\\n            for (int coin : coins) {\\n                if (coin <= i) {\\n                    int sub_res = minimumCoins[i - coin];\\n                    if (sub_res != Integer.MAX_VALUE && sub_res + 1 < minimumCoins[i]) {\\n                        minimumCoins[i] = sub_res + 1;\\n                    }\\n                }\\n            }\\n        }\\n        // Uncomment the below line to see the state of combinations for each coin\\n        // printAmount(minimumCoins);\\n        return minimumCoins[amount];\\n    }\\n\\n    // A basic print method which prints all the contents of the array\\n    public static void printAmount(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            System.out.print(arr[i] + \\\" \\\");\\n        }\\n        System.out.println();\\n    }\\n}\\n\"",
    "dice throw": "\"package com.thealgorithms.dynamicprogramming;\\n\\n// Given N dice each with M faces, numbered from 1 to M, find the number of ways to get sum X.\\n// X is the summation of values on each face when all the dice are thrown.\\n\\n/* The Naive approach is to find all the possible combinations of values from n dice and\\nkeep on counting the results that sum to X. This can be done using recursion. */\\n// The above recursion solution exhibits overlapping subproblems.\\n\\n/* Hence, storing the results of the solved sub-problems saves time.\\nAnd it can be done using Dynamic Programming(DP).\\nFollowing is implementation of Dynamic Programming approach. */\\n// Code ---->\\n// Java program to find number of ways to get sum 'x' with 'n' \\n// dice where every dice has 'm' faces \\nclass DP {\\n\\n    /* The main function that returns the number of ways to get sum 'x' with 'n' dice and 'm' with m faces. */\\n    public static long findWays(int m, int n, int x) {\\n\\n        /* Create a table to store the results of subproblems. \\n    One extra row and column are used for simplicity \\n    (Number of dice is directly used as row index and sum is directly used as column index). \\n    The entries in 0th row and 0th column are never used. */\\n        long[][] table = new long[n + 1][x + 1];\\n\\n        /* Table entries for only one dice */\\n        for (int j = 1; j <= m && j <= x; j++) {\\n            table[1][j] = 1;\\n        }\\n\\n        /* Fill rest of the entries in table using recursive relation \\n    i: number of dice, j: sum */\\n        for (int i = 2; i <= n; i++) {\\n            for (int j = 1; j <= x; j++) {\\n                for (int k = 1; k < j && k <= m; k++) {\\n                    table[i][j] += table[i - 1][j - k];\\n                }\\n            }\\n        }\\n\\n        return table[n][x];\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(findWays(4, 2, 1));\\n        System.out.println(findWays(2, 2, 3));\\n        System.out.println(findWays(6, 3, 8));\\n        System.out.println(findWays(4, 2, 5));\\n        System.out.println(findWays(4, 3, 5));\\n    }\\n}\\n\\n/*\\nOUTPUT:\\n0\\n2\\n21\\n4\\n6\\n */\\n// Time Complexity: O(m * n * x) where m is number of faces, n is number of dice and x is given sum.\\n\\n\"",
    "dyanamic programming knapsack": "\"package com.thealgorithms.dynamicprogramming;\\n\\n// A Dynamic Programming based solution\\n// for 0-1 Knapsack problem\\npublic class DyanamicProgrammingKnapsack {\\n\\n    static int max(int a, int b) {\\n        return (a > b) ? a : b;\\n    }\\n\\n    // Returns the maximum value that can\\n    // be put in a knapsack of capacity W\\n    static int knapSack(int W, int wt[], int val[], int n) {\\n        int i, w;\\n        int K[][] = new int[n + 1][W + 1];\\n\\n        // Build table K[][] in bottom up manner\\n        for (i = 0; i <= n; i++) {\\n            for (w = 0; w <= W; w++) {\\n                if (i == 0 || w == 0) {\\n                    K[i][w] = 0;\\n                } else if (wt[i - 1] <= w) {\\n                    K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]);\\n                } else {\\n                    K[i][w] = K[i - 1][w];\\n                }\\n            }\\n        }\\n\\n        return K[n][W];\\n    }\\n\\n    // Driver code\\n    public static void main(String args[]) {\\n        int val[] = new int[]{60, 100, 120};\\n        int wt[] = new int[]{10, 20, 30};\\n        int W = 50;\\n        int n = val.length;\\n        System.out.println(knapSack(W, wt, val, n));\\n    }\\n}\\n\"",
    "edit distance": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * A DynamicProgramming based solution for Edit Distance problem In Java\\n * Description of Edit Distance with an Example:\\n *\\n * <p>\\n * Edit distance is a way of quantifying how dissimilar two strings (e.g.,\\n * words) are to one another, by counting the minimum number of operations\\n * required to transform one string into the other. The distance operations are\\n * the removal, insertion, or substitution of a character in the string.\\n *\\n * <p>\\n *\\n * <p>\\n * The Distance between \\\"kitten\\\" and \\\"sitting\\\" is 3. A minimal edit script that\\n * transforms the former into the latter is:\\n *\\n * <p>\\n * kitten → sitten (substitution of \\\"s\\\" for \\\"k\\\") sitten → sittin (substitution\\n * of \\\"i\\\" for \\\"e\\\") sittin → sitting (insertion of \\\"g\\\" at the end).\\n *\\n * @author SUBHAM SANGHAI\\n */\\nimport java.util.Scanner;\\n\\npublic class EditDistance {\\n\\n    public static int minDistance(String word1, String word2) {\\n        int len1 = word1.length();\\n        int len2 = word2.length();\\n        // len1+1, len2+1, because finally return dp[len1][len2]\\n        int[][] dp = new int[len1 + 1][len2 + 1];\\n        /* If second string is empty, the only option is to\\n    insert all characters of first string into second*/\\n        for (int i = 0; i <= len1; i++) {\\n            dp[i][0] = i;\\n        }\\n        /* If first string is empty, the only option is to\\n    insert all characters of second string into first*/\\n        for (int j = 0; j <= len2; j++) {\\n            dp[0][j] = j;\\n        }\\n        // iterate though, and check last char\\n        for (int i = 0; i < len1; i++) {\\n            char c1 = word1.charAt(i);\\n            for (int j = 0; j < len2; j++) {\\n                char c2 = word2.charAt(j);\\n                // if last two chars equal\\n                if (c1 == c2) {\\n                    // update dp value for +1 length\\n                    dp[i + 1][j + 1] = dp[i][j];\\n                } else {\\n                    /* if two characters are different ,\\n          then take the minimum of the various operations(i.e insertion,removal,substitution)*/\\n                    int replace = dp[i][j] + 1;\\n                    int insert = dp[i][j + 1] + 1;\\n                    int delete = dp[i + 1][j] + 1;\\n\\n                    int min = replace > insert ? insert : replace;\\n                    min = delete > min ? min : delete;\\n                    dp[i + 1][j + 1] = min;\\n                }\\n            }\\n        }\\n        /* return the final answer , after traversing through both the strings*/\\n        return dp[len1][len2];\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner input = new Scanner(System.in);\\n        String s1, s2;\\n        System.out.println(\\\"Enter the First String\\\");\\n        s1 = input.nextLine();\\n        System.out.println(\\\"Enter the Second String\\\");\\n        s2 = input.nextLine();\\n        // ans stores the final Edit Distance between the two strings\\n        int ans = minDistance(s1, s2);\\n        System.out.println(\\n                \\\"The minimum Edit Distance between \\\\\\\"\\\" + s1 + \\\"\\\\\\\" and \\\\\\\"\\\" + s2 + \\\"\\\\\\\" is \\\" + ans);\\n        input.close();\\n    }\\n\\n    // edit distance problem\\n    public static int editDistance(String s1, String s2) {\\n        int[][] storage = new int[s1.length() + 1][s2.length() + 1];\\n        return editDistance(s1, s2, storage);\\n\\n    }\\n\\n    public static int editDistance(String s1, String s2, int[][] storage) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        if (storage[m][n] > 0) {\\n            return storage[m][n];\\n\\n        }\\n        if (m == 0) {\\n            storage[m][n] = n;\\n            return storage[m][n];\\n\\n        }\\n        if (n == 0) {\\n            storage[m][n] = m;\\n            return storage[m][n];\\n\\n        }\\n        if (s1.charAt(0) == s2.charAt(0)) {\\n            storage[m][n] = editDistance(s1.substring(1), s2.substring(1), storage);\\n            return storage[m][n];\\n\\n        } else {\\n            int op1 = editDistance(s1, s2.substring(1), storage);\\n            int op2 = editDistance(s1.substring(1), s2, storage);\\n            int op3 = editDistance(s1.substring(1), s2.substring(1), storage);\\n            storage[m][n] = 1 + Math.min(op1, Math.min(op2, op3));\\n            return storage[m][n];\\n        }\\n    }\\n}\\n\"",
    "egg dropping": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * DynamicProgramming solution for the Egg Dropping Puzzle\\n */\\npublic class EggDropping {\\n\\n    // min trials with n eggs and m floors\\n    private static int minTrials(int n, int m) {\\n\\n        int[][] eggFloor = new int[n + 1][m + 1];\\n        int result, x;\\n\\n        for (int i = 1; i <= n; i++) {\\n            eggFloor[i][0] = 0; // Zero trial for zero floor.\\n            eggFloor[i][1] = 1; // One trial for one floor\\n        }\\n\\n        // j trials for only 1 egg\\n        for (int j = 1; j <= m; j++) {\\n            eggFloor[1][j] = j;\\n        }\\n\\n        // Using bottom-up approach in DP\\n        for (int i = 2; i <= n; i++) {\\n            for (int j = 2; j <= m; j++) {\\n                eggFloor[i][j] = Integer.MAX_VALUE;\\n                for (x = 1; x <= j; x++) {\\n                    result = 1 + Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);\\n\\n                    // choose min of all values for particular x\\n                    if (result < eggFloor[i][j]) {\\n                        eggFloor[i][j] = result;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return eggFloor[n][m];\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 2, m = 4;\\n        // result outputs min no. of trials in worst case for n eggs and m floors\\n        int result = minTrials(n, m);\\n        System.out.println(result);\\n    }\\n}\\n\"",
    "fibonacci": "\"package com.thealgorithms.matrixexponentiation;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * @author Anirudh Buvanesh (https://github.com/anirudhb11) For more information\\n * see https://www.geeksforgeeks.org/matrix-exponentiation/\\n *\\n */\\npublic class Fibonacci {\\n\\n    // Exponentiation matrix for Fibonacci sequence\\n    private static final int[][] fibMatrix = {{1, 1}, {1, 0}};\\n    private static final int[][] identityMatrix = {{1, 0}, {0, 1}};\\n    //First 2 fibonacci numbers\\n    private static final int[][] baseFibNumbers = {{1}, {0}};\\n\\n    /**\\n     * Performs multiplication of 2 matrices\\n     *\\n     * @param matrix1\\n     * @param matrix2\\n     * @return The product of matrix1 and matrix2\\n     */\\n    private static int[][] matrixMultiplication(int[][] matrix1, int[][] matrix2) {\\n        //Check if matrices passed can be multiplied\\n        int rowsInMatrix1 = matrix1.length;\\n        int columnsInMatrix1 = matrix1[0].length;\\n\\n        int rowsInMatrix2 = matrix2.length;\\n        int columnsInMatrix2 = matrix2[0].length;\\n\\n        assert columnsInMatrix1 == rowsInMatrix2;\\n        int[][] product = new int[rowsInMatrix1][columnsInMatrix2];\\n        for (int rowIndex = 0; rowIndex < rowsInMatrix1; rowIndex++) {\\n            for (int colIndex = 0; colIndex < columnsInMatrix2; colIndex++) {\\n                int matrixEntry = 0;\\n                for (int intermediateIndex = 0; intermediateIndex < columnsInMatrix1; intermediateIndex++) {\\n                    matrixEntry += matrix1[rowIndex][intermediateIndex] * matrix2[intermediateIndex][colIndex];\\n                }\\n                product[rowIndex][colIndex] = matrixEntry;\\n            }\\n        }\\n        return product;\\n    }\\n\\n    /**\\n     * Calculates the fibonacci number using matrix exponentiaition technique\\n     *\\n     * @param n The input n for which we have to determine the fibonacci number\\n     * Outputs the nth * fibonacci number\\n     * @return a 2 X 1 array as { {F_n+1}, {F_n} }\\n     */\\n    public static int[][] fib(int n) {\\n        if (n == 0) {\\n            return Fibonacci.identityMatrix;\\n        } else {\\n            int[][] cachedResult = fib(n / 2);\\n            int[][] matrixExpResult = matrixMultiplication(cachedResult, cachedResult);\\n            if (n % 2 == 0) {\\n                return matrixExpResult;\\n            } else {\\n                return matrixMultiplication(Fibonacci.fibMatrix, matrixExpResult);\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        // Returns [0, 1, 1, 2, 3, 5 ..] for n = [0, 1, 2, 3, 4, 5.. ]\\n        Scanner sc = new Scanner(System.in);\\n        int n = sc.nextInt();\\n        int[][] result = matrixMultiplication(fib(n), baseFibNumbers);\\n        System.out.println(\\\"Fib(\\\" + n + \\\") = \\\" + result[1][0]);\\n        sc.close();\\n    }\\n}\\n\"",
    "flood fill": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * Java program for Flood fill algorithm.\\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\\n */\\npublic class FloodFill {\\n\\n    /**\\n     * Get the color at the given co-odrinates of a 2D image\\n     *\\n     * @param image The image to be filled\\n     * @param x_co_ordinate The x co-ordinate of which color is to be obtained\\n     * @param y_co_ordinate The y co-ordinate of which color is to be obtained\\n     */\\n\\t\\n\\tpublic static int getPixel(int[][] image, int x_co_ordinate, int y_co_ordinate) {\\n\\t\\n\\t\\treturn image[x_co_ordinate][y_co_ordinate];\\n\\t\\n\\t}\\n\\t\\n    /**\\n     * Put the color at the given co-odrinates of a 2D image\\n     *\\n     * @param image The image to be filed\\n     * @param x_co_ordinate The x co-ordinate at which color is to be filled\\n     * @param y_co_ordinate The y co-ordinate at which color is to be filled\\n     */\\n\\tpublic static void putPixel(int[][] image, int x_co_ordinate, int y_co_ordinate, int new_color) {\\n\\t\\t\\n\\t\\timage[x_co_ordinate][y_co_ordinate] = new_color;\\n\\t\\n\\t}\\n\\t\\n\\t\\n    /**\\n     * Fill the 2D image with new color\\n     *\\n     * @param image The image to be filed\\n     * @param x_co_ordinate The x co-ordinate at which color is to be filled\\n     * @param y_co_ordinate The y co-ordinate at which color is to be filled\\n     * @param new_color The new color which to be filled in the image\\n     * @param old_color The old color which is to be replaced in the image\\n     * @return\\n     */\\n\\tpublic static void floodFill(int[][] image, int x_co_ordinate, int y_co_ordinate, int new_color, int old_color) {\\n\\t\\tif(x_co_ordinate >= 0 && y_co_ordinate >= 0 && getPixel(image, x_co_ordinate, y_co_ordinate) == old_color) {\\n\\t\\t\\t\\n\\t\\t\\tputPixel(image, x_co_ordinate, y_co_ordinate, new_color);\\n\\t\\t\\tfloodFill(image, x_co_ordinate + 1, y_co_ordinate, new_color, old_color);\\n\\t\\t\\tfloodFill(image, x_co_ordinate - 1, y_co_ordinate, new_color, old_color);\\n\\t\\t\\tfloodFill(image, x_co_ordinate, y_co_ordinate + 1, new_color, old_color);\\n\\t\\t\\tfloodFill(image, x_co_ordinate, y_co_ordinate - 1, new_color, old_color);\\n\\t\\t\\tfloodFill(image, x_co_ordinate + 1, y_co_ordinate - 1, new_color, old_color);\\n\\t\\t\\tfloodFill(image, x_co_ordinate - 1, y_co_ordinate + 1, new_color, old_color);\\n\\t\\t\\tfloodFill(image, x_co_ordinate + 1, y_co_ordinate + 1, new_color, old_color);\\n\\t\\t\\tfloodFill(image, x_co_ordinate - 1, y_co_ordinate - 1, new_color, old_color);\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t\\n    /**\\n     * This method will print the 2D image matrix\\n     *\\n     * @param image The image to be printed on the console\\n     */\\n\\tpublic static void printImageArray(int[][] image) {\\n\\t\\t\\n\\t\\tfor(int i=0 ; i<image.length ; i++) {\\n\\t\\t\\tfor(int j=0 ; j<image[0].length ; j++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tSystem.out.print(image[i][j]+\\\"  \\\");\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tSystem.out.println();\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t\\n\\t// Driver Program\\n\\tpublic static void main(String[] args) {\\n\\t\\t\\n\\t\\t\\n\\t\\t//Input 2D image matrix\\n\\t\\tint[][] image = {\\n\\t\\t\\t\\t{0,0,0,0,0,0,0},\\n\\t\\t\\t\\t{0,3,3,3,3,0,0},\\n\\t\\t\\t\\t{0,3,1,1,5,0,0},\\n\\t\\t\\t\\t{0,3,1,1,5,5,3},\\n\\t\\t\\t\\t{0,3,5,5,1,1,3},\\n\\t\\t\\t\\t{0,0,0,5,1,1,3},\\n\\t\\t\\t\\t{0,0,0,3,3,3,3}\\n\\t\\t};\\n\\t\\t\\n\\t\\tfloodFill(image,2,2,2,1);\\n\\n\\t\\t/* Output ==>\\n\\t\\t * 0  0  0  0  0  0  0  \\n\\t\\t   0  3  3  3  3  0  0  \\n\\t\\t   0  3  2  2  5  0  0  \\n           0  3  2  2  5  5  3  \\n           0  3  5  5  2  2  3  \\n           0  0  0  5  2  2  3  \\n           0  0  0  3  3  3  3\\n\\t\\t * */\\n\\t\\t\\n\\t\\t//print 2D image matrix\\n\\t\\tprintImageArray(image);\\n\\t}\\n\\n}\"",
    "ford fulkerson": "\"package com.thealgorithms.dynamicprogramming;\\n\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\nimport java.util.Vector;\\n\\npublic class FordFulkerson {\\n\\n    static final int INF = 987654321;\\n    // edges\\n    static int V;\\n    static int[][] capacity, flow;\\n\\n    public static void main(String[] args) {\\n        System.out.println(\\\"V : 6\\\");\\n        V = 6;\\n        capacity = new int[V][V];\\n\\n        capacity[0][1] = 12;\\n        capacity[0][3] = 13;\\n        capacity[1][2] = 10;\\n        capacity[2][3] = 13;\\n        capacity[2][4] = 3;\\n        capacity[2][5] = 15;\\n        capacity[3][2] = 7;\\n        capacity[3][4] = 15;\\n        capacity[4][5] = 17;\\n\\n        System.out.println(\\\"Max capacity in networkFlow : \\\" + networkFlow(0, 5));\\n    }\\n\\n    private static int networkFlow(int source, int sink) {\\n        flow = new int[V][V];\\n        int totalFlow = 0;\\n        while (true) {\\n            Vector<Integer> parent = new Vector<>(V);\\n            for (int i = 0; i < V; i++) {\\n                parent.add(-1);\\n            }\\n            Queue<Integer> q = new LinkedList<>();\\n            parent.set(source, source);\\n            q.add(source);\\n            while (!q.isEmpty() && parent.get(sink) == -1) {\\n                int here = q.peek();\\n                q.poll();\\n                for (int there = 0; there < V; ++there) {\\n                    if (capacity[here][there] - flow[here][there] > 0 && parent.get(there) == -1) {\\n                        q.add(there);\\n                        parent.set(there, here);\\n                    }\\n                }\\n            }\\n            if (parent.get(sink) == -1) {\\n                break;\\n            }\\n\\n            int amount = INF;\\n            String printer = \\\"path : \\\";\\n            StringBuilder sb = new StringBuilder();\\n            for (int p = sink; p != source; p = parent.get(p)) {\\n                amount = Math.min(capacity[parent.get(p)][p] - flow[parent.get(p)][p], amount);\\n                sb.append(p + \\\"-\\\");\\n            }\\n            sb.append(source);\\n            for (int p = sink; p != source; p = parent.get(p)) {\\n                flow[parent.get(p)][p] += amount;\\n                flow[p][parent.get(p)] -= amount;\\n            }\\n            totalFlow += amount;\\n            printer += sb.reverse() + \\\" / max flow : \\\" + totalFlow;\\n            System.out.println(printer);\\n        }\\n\\n        return totalFlow;\\n    }\\n}\\n\"",
    "kadane algorithm": "\"package com.thealgorithms.dynamicprogramming;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * Program to implement Kadane’s Algorithm to calculate maximum contiguous\\n * subarray sum of an array Time Complexity: O(n)\\n *\\n * @author Nishita Aggarwal\\n */\\npublic class KadaneAlgorithm {\\n\\n    /**\\n     * This method implements Kadane's Algorithm\\n     *\\n     * @param arr The input array\\n     * @return The maximum contiguous subarray sum of the array\\n     */\\n    static int largestContiguousSum(int arr[]) {\\n        int i, len = arr.length, cursum = 0, maxsum = Integer.MIN_VALUE;\\n        if (len == 0) // empty array\\n        {\\n            return 0;\\n        }\\n        for (i = 0; i < len; i++) {\\n            cursum += arr[i];\\n            if (cursum > maxsum) {\\n                maxsum = cursum;\\n            }\\n            if (cursum <= 0) {\\n                cursum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n\\n    /**\\n     * Main method\\n     *\\n     * @param args Command line arguments\\n     */\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        int n, arr[], i;\\n        n = sc.nextInt();\\n        arr = new int[n];\\n        for (i = 0; i < n; i++) {\\n            arr[i] = sc.nextInt();\\n        }\\n        int maxContSum = largestContiguousSum(arr);\\n        System.out.println(maxContSum);\\n        sc.close();\\n    }\\n}\\n\"",
    "knapsack": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * A DynamicProgramming based solution for 0-1 Knapsack problem\\n */\\npublic class Knapsack {\\n\\n    private static int knapSack(int W, int wt[], int val[], int n) throws IllegalArgumentException {\\n        if (wt == null || val == null) {\\n            throw new IllegalArgumentException();\\n        }\\n        int i, w;\\n        int rv[][] = new int[n + 1][W + 1]; // rv means return value\\n\\n        // Build table rv[][] in bottom up manner\\n        for (i = 0; i <= n; i++) {\\n            for (w = 0; w <= W; w++) {\\n                if (i == 0 || w == 0) {\\n                    rv[i][w] = 0;\\n                } else if (wt[i - 1] <= w) {\\n                    rv[i][w] = Math.max(val[i - 1] + rv[i - 1][w - wt[i - 1]], rv[i - 1][w]);\\n                } else {\\n                    rv[i][w] = rv[i - 1][w];\\n                }\\n            }\\n        }\\n\\n        return rv[n][W];\\n    }\\n\\n    // Driver program to test above function\\n    public static void main(String args[]) {\\n        int val[] = new int[]{50, 100, 130};\\n        int wt[] = new int[]{10, 20, 40};\\n        int W = 50;\\n        System.out.println(knapSack(W, wt, val, val.length));\\n    }\\n}\\n\"",
    "knapsack memoization": "\"package com.thealgorithms.dynamicprogramming;\\n\\nimport java.util.Arrays;\\n\\n/**\\n * Recursive Solution for 0-1 knapsack with memoization\\n */\\npublic class KnapsackMemoization {\\n\\n    private static int[][] t;\\n\\n    // Returns the maximum value that can\\n    // be put in a knapsack of capacity W\\n    public static int knapsack(int[] wt, int[] value, int W, int n) {\\n        if (t[n][W] != -1) {\\n            return t[n][W];\\n        }\\n        if (n == 0 || W == 0) {\\n            return 0;\\n        }\\n        if (wt[n - 1] <= W) {\\n            t[n - 1][W - wt[n - 1]] = knapsack(wt, value, W - wt[n - 1], n - 1);\\n            // Include item in the bag. In that case add the value of the item and call for the remaining items\\n            int tmp1 = value[n - 1] + t[n - 1][W - wt[n - 1]];\\n            // Don't include the nth item in the bag anl call for remaining item without reducing the weight\\n            int tmp2 = knapsack(wt, value, W, n - 1);\\n            t[n - 1][W] = tmp2;\\n            // include the larger one\\n            int tmp = tmp1 > tmp2 ? tmp1 : tmp2;\\n            t[n][W] = tmp;\\n            return tmp;\\n            // If Weight for the item is more than the desired weight then don't include it\\n            // Call for rest of the n-1 items\\n        } else if (wt[n - 1] > W) {\\n            t[n][W] = knapsack(wt, value, W, n - 1);\\n            return t[n][W];\\n        }\\n        return -1;\\n    }\\n\\n    // Driver code\\n    public static void main(String args[]) {\\n        int[] wt = {1, 3, 4, 5};\\n        int[] value = {1, 4, 5, 7};\\n        int W = 10;\\n        t = new int[wt.length + 1][W + 1];\\n        Arrays.stream(t).forEach(a -> Arrays.fill(a, -1));\\n        int res = knapsack(wt, value, W, wt.length);\\n        System.out.println(\\\"Maximum knapsack value \\\" + res);\\n    }\\n}\\n\"",
    "levenshtein distance": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * @author Kshitij VERMA (github.com/kv19971) LEVENSHTEIN DISTANCE dyamic\\n * programming implementation to show the difference between two strings\\n * (https://en.wikipedia.org/wiki/Levenshtein_distance)\\n */\\npublic class LevenshteinDistance {\\n\\n    private static int minimum(int a, int b, int c) {\\n        if (a < b && a < c) {\\n            return a;\\n        } else if (b < a && b < c) {\\n            return b;\\n        } else {\\n            return c;\\n        }\\n    }\\n\\n    private static int calculate_distance(String a, String b) {\\n        int len_a = a.length() + 1;\\n        int len_b = b.length() + 1;\\n        int[][] distance_mat = new int[len_a][len_b];\\n        for (int i = 0; i < len_a; i++) {\\n            distance_mat[i][0] = i;\\n        }\\n        for (int j = 0; j < len_b; j++) {\\n            distance_mat[0][j] = j;\\n        }\\n        for (int i = 0; i < len_a; i++) {\\n            for (int j = 0; j < len_b; j++) {\\n                int cost;\\n                if (a.charAt(i) == b.charAt(j)) {\\n                    cost = 0;\\n                } else {\\n                    cost = 1;\\n                }\\n                distance_mat[i][j]\\n                        = minimum(distance_mat[i - 1][j], distance_mat[i - 1][j - 1], distance_mat[i][j - 1])\\n                        + cost;\\n            }\\n        }\\n        return distance_mat[len_a - 1][len_b - 1];\\n    }\\n\\n    public static void main(String[] args) {\\n        String a = \\\"\\\"; // enter your string here\\n        String b = \\\"\\\"; // enter your string here\\n\\n        System.out.print(\\\"Levenshtein distance between \\\" + a + \\\" and \\\" + b + \\\" is: \\\");\\n        System.out.println(calculate_distance(a, b));\\n    }\\n}\\n\"",
    "longest alternating subsequence": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/*\\n\\n * Problem Statement: - \\n * Find Longest Alternating Subsequence\\n\\n * A sequence {x1, x2, .. xn} is alternating sequence if its elements satisfy one of the following relations : \\n\\n   x1 < x2 > x3 < x4 > x5 < …. xn or \\n   x1 > x2 < x3 > x4 < x5 > …. xn\\n */\\npublic class LongestAlternatingSubsequence {\\n\\n    /* Function to return longest alternating subsequence length*/\\n    static int AlternatingLength(int arr[], int n) {\\n        /*\\n\\n\\t\\tlas[i][0] = Length of the longest\\n\\t\\t\\talternating subsequence ending at\\n\\t\\t\\tindex i and last element is\\n\\t\\t\\tgreater than its previous element\\n\\n\\t\\tlas[i][1] = Length of the longest\\n\\t\\t\\talternating subsequence ending at\\n\\t\\t\\tindex i and last element is\\n\\t\\t\\tsmaller than its previous\\n\\t\\t\\telement \\n\\n         */\\n        int las[][] = new int[n][2]; // las = LongestAlternatingSubsequence\\n\\n        for (int i = 0; i < n; i++) {\\n            las[i][0] = las[i][1] = 1;\\n        }\\n\\n        int result = 1; // Initialize result\\n\\n        /* Compute values in bottom up manner */\\n        for (int i = 1; i < n; i++) {\\n\\n            /* Consider all elements as previous of arr[i]*/\\n            for (int j = 0; j < i; j++) {\\n\\n                /* If arr[i] is greater, then check with las[j][1] */\\n                if (arr[j] < arr[i] && las[i][0] < las[j][1] + 1) {\\n                    las[i][0] = las[j][1] + 1;\\n                }\\n\\n                /* If arr[i] is smaller, then check with las[j][0]*/\\n                if (arr[j] > arr[i] && las[i][1] < las[j][0] + 1) {\\n                    las[i][1] = las[j][0] + 1;\\n                }\\n            }\\n\\n            /* Pick maximum of both values at index i */\\n            if (result < Math.max(las[i][0], las[i][1])) {\\n                result = Math.max(las[i][0], las[i][1]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {10, 22, 9, 33, 49, 50, 31, 60};\\n        int n = arr.length;\\n        System.out.println(\\\"Length of Longest \\\" + \\\"alternating subsequence is \\\" + AlternatingLength(arr, n));\\n    }\\n}\\n\"",
    "longest common subsequence": "\"package com.thealgorithms.dynamicprogramming;\\n\\nclass LongestCommonSubsequence {\\n\\n    public static String getLCS(String str1, String str2) {\\n\\n        // At least one string is null\\n        if (str1 == null || str2 == null) {\\n            return null;\\n        }\\n\\n        // At least one string is empty\\n        if (str1.length() == 0 || str2.length() == 0) {\\n            return \\\"\\\";\\n        }\\n\\n        String[] arr1 = str1.split(\\\"\\\");\\n        String[] arr2 = str2.split(\\\"\\\");\\n\\n        // lcsMatrix[i][j]  = LCS of first i elements of arr1 and first j characters of arr2\\n        int[][] lcsMatrix = new int[arr1.length + 1][arr2.length + 1];\\n\\n        for (int i = 0; i < arr1.length + 1; i++) {\\n            lcsMatrix[i][0] = 0;\\n        }\\n        for (int j = 1; j < arr2.length + 1; j++) {\\n            lcsMatrix[0][j] = 0;\\n        }\\n        for (int i = 1; i < arr1.length + 1; i++) {\\n            for (int j = 1; j < arr2.length + 1; j++) {\\n                if (arr1[i - 1].equals(arr2[j - 1])) {\\n                    lcsMatrix[i][j] = lcsMatrix[i - 1][j - 1] + 1;\\n                } else {\\n                    lcsMatrix[i][j]\\n                            = lcsMatrix[i - 1][j] > lcsMatrix[i][j - 1] ? lcsMatrix[i - 1][j] : lcsMatrix[i][j - 1];\\n                }\\n            }\\n        }\\n        return lcsString(str1, str2, lcsMatrix);\\n    }\\n\\n    public static String lcsString(String str1, String str2, int[][] lcsMatrix) {\\n        StringBuilder lcs = new StringBuilder();\\n        int i = str1.length(), j = str2.length();\\n        while (i > 0 && j > 0) {\\n            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\\n                lcs.append(str1.charAt(i - 1));\\n                i--;\\n                j--;\\n            } else if (lcsMatrix[i - 1][j] > lcsMatrix[i][j - 1]) {\\n                i--;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return lcs.reverse().toString();\\n    }\\n\\n    public static void main(String[] args) {\\n        String str1 = \\\"DSGSHSRGSRHTRD\\\";\\n        String str2 = \\\"DATRGAGTSHS\\\";\\n        String lcs = getLCS(str1, str2);\\n\\n        // Print LCS\\n        if (lcs != null) {\\n            System.out.println(\\\"String 1: \\\" + str1);\\n            System.out.println(\\\"String 2: \\\" + str2);\\n            System.out.println(\\\"LCS: \\\" + lcs);\\n            System.out.println(\\\"LCS length: \\\" + lcs.length());\\n        }\\n    }\\n}\\n\"",
    "longest increasing subsequence": "\"package com.thealgorithms.dynamicprogramming;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * @author Afrizal Fikri (https://github.com/icalF)\\n */\\npublic class LongestIncreasingSubsequence {\\n\\n    public static void main(String[] args) {\\n\\n        Scanner sc = new Scanner(System.in);\\n        int n = sc.nextInt();\\n\\n        int arr[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = sc.nextInt();\\n        }\\n\\n        System.out.println(LIS(arr));\\n        System.out.println(findLISLen(arr));\\n        sc.close();\\n    }\\n\\n    private static int upperBound(int[] ar, int l, int r, int key) {\\n        while (l < r - 1) {\\n            int m = (l + r) >>> 1;\\n            if (ar[m] >= key) {\\n                r = m;\\n            } else {\\n                l = m;\\n            }\\n        }\\n\\n        return r;\\n    }\\n\\n    private static int LIS(int[] array) {\\n        int N = array.length;\\n        if (N == 0) {\\n            return 0;\\n        }\\n\\n        int[] tail = new int[N];\\n\\n        // always points empty slot in tail\\n        int length = 1;\\n\\n        tail[0] = array[0];\\n        for (int i = 1; i < N; i++) {\\n\\n            // new smallest value\\n            if (array[i] < tail[0]) {\\n                tail[0] = array[i];\\n            } // array[i] extends largest subsequence\\n            else if (array[i] > tail[length - 1]) {\\n                tail[length++] = array[i];\\n            } // array[i] will become end candidate of an existing subsequence or\\n            // Throw away larger elements in all LIS, to make room for upcoming grater elements than\\n            // array[i]\\n            // (and also, array[i] would have already appeared in one of LIS, identify the location and\\n            // replace it)\\n            else {\\n                tail[upperBound(tail, -1, length - 1, array[i])] = array[i];\\n            }\\n        }\\n\\n        return length;\\n    }\\n\\n    /**\\n     * @author Alon Firestein (https://github.com/alonfirestein)\\n     */\\n    // A function for finding the length of the LIS algorithm in O(nlogn) complexity.\\n    public static int findLISLen(int a[]) {\\n        int size = a.length;\\n        int arr[] = new int[size];\\n        arr[0] = a[0];\\n        int lis = 1;\\n        for (int i = 1; i < size; i++) {\\n            int index = binarySearchBetween(arr, lis, a[i]);\\n            arr[index] = a[i];\\n            if (index > lis) {\\n                lis++;\\n            }\\n        }\\n        return lis;\\n    }\\n    // O(logn)\\n\\n    private static int binarySearchBetween(int[] t, int end, int key) {\\n        int left = 0;\\n        int right = end;\\n        if (key < t[0]) {\\n            return 0;\\n        }\\n        if (key > t[end]) {\\n            return end + 1;\\n        }\\n        while (left < right - 1) {\\n            int middle = (left + right) / 2;\\n            if (t[middle] < key) {\\n                left = middle;\\n            } else {\\n                right = middle;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n\"",
    "longest palindromic subsequence": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * Algorithm explanation\\n * https://www.educative.io/edpresso/longest-palindromic-subsequence-algorithm\\n */\\npublic class LongestPalindromicSubsequence {\\n\\n    public static void main(String[] args) {\\n        String a = \\\"BBABCBCAB\\\";\\n        String b = \\\"BABCBAB\\\";\\n\\n        String aLPS = LPS(a);\\n        String bLPS = LPS(b);\\n\\n        System.out.println(a + \\\" => \\\" + aLPS);\\n        System.out.println(b + \\\" => \\\" + bLPS);\\n    }\\n\\n    public static String LPS(String original) throws IllegalArgumentException {\\n        StringBuilder reverse = new StringBuilder(original);\\n        reverse = reverse.reverse();\\n        return recursiveLPS(original, reverse.toString());\\n    }\\n\\n    private static String recursiveLPS(String original, String reverse) {\\n        String bestResult = \\\"\\\";\\n\\n        // no more chars, then return empty\\n        if (original.length() == 0 || reverse.length() == 0) {\\n            bestResult = \\\"\\\";\\n        } else {\\n\\n            // if the last chars match, then remove it from both strings and recur\\n            if (original.charAt(original.length() - 1) == reverse.charAt(reverse.length() - 1)) {\\n                String bestSubResult\\n                        = recursiveLPS(\\n                                original.substring(0, original.length() - 1),\\n                                reverse.substring(0, reverse.length() - 1));\\n\\n                bestResult = reverse.charAt(reverse.length() - 1) + bestSubResult;\\n            } else {\\n                // otherwise (1) ignore the last character of reverse, and recur on original and updated\\n                // reverse again\\n                // (2) ignore the last character of original and recur on the updated original and reverse\\n                // again\\n                // then select the best result from these two subproblems.\\n\\n                String bestSubResult1 = recursiveLPS(original, reverse.substring(0, reverse.length() - 1));\\n                String bestSubResult2 = recursiveLPS(original.substring(0, original.length() - 1), reverse);\\n                if (bestSubResult1.length() > bestSubResult2.length()) {\\n                    bestResult = bestSubResult1;\\n                } else {\\n                    bestResult = bestSubResult2;\\n                }\\n            }\\n        }\\n\\n        return bestResult;\\n    }\\n}\\n\"",
    "longest palindromic substring": "\"package com.thealgorithms.strings;\\n\\n// Longest Palindromic Substring\\nimport java.util.Scanner;\\n\\n;\\n\\nclass LongestPalindromicSubstring {\\n\\n    public static void main(String[] args) {\\n        Solution s = new Solution();\\n        String str = \\\"\\\";\\n        Scanner sc = new Scanner(System.in);\\n        System.out.print(\\\"Enter the string: \\\");\\n        str = sc.nextLine();\\n        System.out.println(\\\"Longest substring is : \\\" + s.longestPalindrome(str));\\n    }\\n}\\n\\nclass Solution {\\n\\n    public String longestPalindrome(String s) {\\n        if (s == null || s.length() == 0) {\\n            return \\\"\\\";\\n        }\\n        int n = s.length();\\n        String maxStr = \\\"\\\";\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i; j < n; ++j) {\\n                if (isValid(s, i, j) == true) {\\n                    if (j - i + 1 > maxStr.length()) { // update maxStr\\n                        maxStr = s.substring(i, j + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return maxStr;\\n    }\\n\\n    private boolean isValid(String s, int lo, int hi) {\\n        int n = hi - lo + 1;\\n        for (int i = 0; i < n / 2; ++i) {\\n            if (s.charAt(lo + i) != s.charAt(hi - i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"",
    "longest valid parentheses": "\"package com.thealgorithms.dynamicprogramming;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * Given a string containing just the characters '(' and ')', find the length of\\n * the longest valid (well-formed) parentheses substring.\\n *\\n * @author Libin Yang (https://github.com/yanglbme)\\n * @since 2018/10/5\\n */\\npublic class LongestValidParentheses {\\n\\n    public static int getLongestValidParentheses(String s) {\\n        if (s == null || s.length() < 2) {\\n            return 0;\\n        }\\n        char[] chars = s.toCharArray();\\n        int n = chars.length;\\n        int[] res = new int[n];\\n        res[0] = 0;\\n        res[1] = chars[1] == ')' && chars[0] == '(' ? 2 : 0;\\n\\n        int max = res[1];\\n\\n        for (int i = 2; i < n; ++i) {\\n            if (chars[i] == ')') {\\n                if (chars[i - 1] == '(') {\\n                    res[i] = res[i - 2] + 2;\\n                } else {\\n                    int index = i - res[i - 1] - 1;\\n                    if (index >= 0 && chars[index] == '(') {\\n                        // ()(())\\n                        res[i] = res[i - 1] + 2 + (index - 1 >= 0 ? res[index - 1] : 0);\\n                    }\\n                }\\n            }\\n            max = Math.max(max, res[i]);\\n        }\\n\\n        return max;\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n\\n        while (true) {\\n            String str = sc.nextLine();\\n            if (\\\"quit\\\".equals(str)) {\\n                break;\\n            }\\n\\n            System.out.println(\\\"Len is: \\\" + getLongestValidParentheses(str));\\n        }\\n\\n        sc.close();\\n    }\\n}\\n\"",
    "matrix chain multiplication": "\"package com.thealgorithms.dynamicprogramming;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Scanner;\\n\\npublic class MatrixChainMultiplication {\\n\\n    private static Scanner scan = new Scanner(System.in);\\n    private static ArrayList<Matrix> mArray = new ArrayList<>();\\n    private static int size;\\n    private static int[][] m;\\n    private static int[][] s;\\n    private static int[] p;\\n\\n    public static void main(String[] args) {\\n        int count = 1;\\n        while (true) {\\n            String[] mSize = input(\\\"input size of matrix A(\\\" + count + \\\") ( ex. 10 20 ) : \\\");\\n            int col = Integer.parseInt(mSize[0]);\\n            if (col == 0) {\\n                break;\\n            }\\n            int row = Integer.parseInt(mSize[1]);\\n\\n            Matrix matrix = new Matrix(count, col, row);\\n            mArray.add(matrix);\\n            count++;\\n        }\\n        for (Matrix m : mArray) {\\n            System.out.format(\\\"A(%d)  =  %2d  x  %2d%n\\\", m.count(), m.col(), m.row());\\n        }\\n\\n        size = mArray.size();\\n        m = new int[size + 1][size + 1];\\n        s = new int[size + 1][size + 1];\\n        p = new int[size + 1];\\n\\n        for (int i = 0; i < size + 1; i++) {\\n            Arrays.fill(m[i], -1);\\n            Arrays.fill(s[i], -1);\\n        }\\n\\n        for (int i = 0; i < p.length; i++) {\\n            p[i] = i == 0 ? mArray.get(i).col() : mArray.get(i - 1).row();\\n        }\\n\\n        matrixChainOrder();\\n        for (int i = 0; i < size; i++) {\\n            System.out.print(\\\"-------\\\");\\n        }\\n        System.out.println();\\n        printArray(m);\\n        for (int i = 0; i < size; i++) {\\n            System.out.print(\\\"-------\\\");\\n        }\\n        System.out.println();\\n        printArray(s);\\n        for (int i = 0; i < size; i++) {\\n            System.out.print(\\\"-------\\\");\\n        }\\n        System.out.println();\\n\\n        System.out.println(\\\"Optimal solution : \\\" + m[1][size]);\\n        System.out.print(\\\"Optimal parens : \\\");\\n        printOptimalParens(1, size);\\n    }\\n\\n    private static void printOptimalParens(int i, int j) {\\n        if (i == j) {\\n            System.out.print(\\\"A\\\" + i);\\n        } else {\\n            System.out.print(\\\"(\\\");\\n            printOptimalParens(i, s[i][j]);\\n            printOptimalParens(s[i][j] + 1, j);\\n            System.out.print(\\\")\\\");\\n        }\\n    }\\n\\n    private static void printArray(int[][] array) {\\n        for (int i = 1; i < size + 1; i++) {\\n            for (int j = 1; j < size + 1; j++) {\\n                System.out.print(String.format(\\\"%7d\\\", array[i][j]));\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    private static void matrixChainOrder() {\\n        for (int i = 1; i < size + 1; i++) {\\n            m[i][i] = 0;\\n        }\\n\\n        for (int l = 2; l < size + 1; l++) {\\n            for (int i = 1; i < size - l + 2; i++) {\\n                int j = i + l - 1;\\n                m[i][j] = Integer.MAX_VALUE;\\n\\n                for (int k = i; k < j; k++) {\\n                    int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];\\n                    if (q < m[i][j]) {\\n                        m[i][j] = q;\\n                        s[i][j] = k;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    private static String[] input(String string) {\\n        System.out.print(string);\\n        return (scan.nextLine().split(\\\" \\\"));\\n    }\\n}\\n\\nclass Matrix {\\n\\n    private int count;\\n    private int col;\\n    private int row;\\n\\n    Matrix(int count, int col, int row) {\\n        this.count = count;\\n        this.col = col;\\n        this.row = row;\\n    }\\n\\n    int count() {\\n        return count;\\n    }\\n\\n    int col() {\\n        return col;\\n    }\\n\\n    int row() {\\n        return row;\\n    }\\n}\\n\"",
    "matrix chain recursive top down memoisation": "\"package com.thealgorithms.dynamicprogramming;\\n\\n// Matrix-chain Multiplication\\n// Problem Statement\\n// we have given a chain A1,A2,...,Ani of n matrices, where for i = 1,2,...,n, \\n// matrix Ai has dimension pi−1 ×pi\\n// , fully parenthesize the product A1A2 ···An in a way that\\n// minimizes the number of scalar multiplications.\\npublic class MatrixChainRecursiveTopDownMemoisation {\\n\\n    static int Memoized_Matrix_Chain(int p[]) {\\n        int n = p.length;\\n        int m[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                m[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        return Lookup_Chain(m, p, 1, n - 1);\\n    }\\n\\n    static int Lookup_Chain(int m[][], int p[], int i, int j) {\\n        if (i == j) {\\n            m[i][j] = 0;\\n            return m[i][j];\\n        }\\n        if (m[i][j] < Integer.MAX_VALUE) {\\n            return m[i][j];\\n        } else {\\n            for (int k = i; k < j; k++) {\\n                int q = Lookup_Chain(m, p, i, k) + Lookup_Chain(m, p, k + 1, j) + (p[i - 1] * p[k] * p[j]);\\n                if (q < m[i][j]) {\\n                    m[i][j] = q;\\n                }\\n            }\\n        }\\n        return m[i][j];\\n    }\\n\\n    // in this code we are taking the example of 4 matrixes whose orders are 1x2,2x3,3x4,4x5 respectively\\n    // output should be  Minimum number of multiplications is 38\\n    public static void main(String[] args) {\\n\\n        int arr[] = {1, 2, 3, 4, 5};\\n        System.out.println(\\\"Minimum number of multiplications is \\\" + Memoized_Matrix_Chain(arr));\\n    }\\n}\\n\"",
    "memoization technique knapsack": "\"package com.thealgorithms.dynamicprogramming;\\n// Here is the top-down approach of\\n// dynamic programming\\n\\npublic class MemoizationTechniqueKnapsack {\\n\\n    // A utility function that returns\\n    // maximum of two integers\\n    static int max(int a, int b) {\\n        return (a > b) ? a : b;\\n    }\\n\\n    // Returns the value of maximum profit\\n    static int knapSackRec(int W, int wt[], int val[], int n, int[][] dp) {\\n\\n        // Base condition\\n        if (n == 0 || W == 0) {\\n            return 0;\\n        }\\n\\n        if (dp[n][W] != -1) {\\n            return dp[n][W];\\n        }\\n\\n        if (wt[n - 1] > W) // Store the value of function call\\n        // stack in table before return\\n        {\\n            return dp[n][W] = knapSackRec(W, wt, val, n - 1, dp);\\n        } else // Return value of table after storing\\n        {\\n            return dp[n][W]\\n                    = max(\\n                            (val[n - 1] + knapSackRec(W - wt[n - 1], wt, val, n - 1, dp)),\\n                            knapSackRec(W, wt, val, n - 1, dp));\\n        }\\n    }\\n\\n    static int knapSack(int W, int wt[], int val[], int N) {\\n\\n        // Declare the table dynamically\\n        int dp[][] = new int[N + 1][W + 1];\\n\\n        // Loop to initially filled the\\n        // table with -1\\n        for (int i = 0; i < N + 1; i++) {\\n            for (int j = 0; j < W + 1; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n\\n        return knapSackRec(W, wt, val, N, dp);\\n    }\\n\\n    // Driver Code\\n    public static void main(String[] args) {\\n        int val[] = {60, 100, 120};\\n        int wt[] = {10, 20, 30};\\n\\n        int W = 50;\\n        int N = val.length;\\n\\n        System.out.println(knapSack(W, wt, val, N));\\n    }\\n}\\n\"",
    "minimum path sum": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/*\\nGiven the following grid with length m and width n:\\n\\\\---\\\\---\\\\---\\\\ (n)\\n\\\\ 1 \\\\ 3 \\\\ 1 \\\\\\n\\\\---\\\\---\\\\---\\\\\\n\\\\ 1 \\\\ 5 \\\\ 1 \\\\\\n\\\\---\\\\---\\\\---\\\\\\n\\\\ 4 \\\\ 2 \\\\ 1 \\\\\\n\\\\---\\\\---\\\\---\\\\\\n(m)\\nFind the path where its sum is the smallest.\\n\\nAll numbers given are positive.\\nThe Time Complexity of your algorithm should be smaller than or equal to O(mn).\\nThe Space Complexity of your algorithm should be smaller than or equal to O(mn).\\nYou can only move from the top left corner to the down right corner.\\nYou can only move one step down or right.\\n\\nEXAMPLE:\\nINPUT: grid = [[1,3,1],[1,5,1],[4,2,1]]\\nOUTPUT: 7\\nEXPLANATIONS: 1 + 3 + 1 + 1 + 1 = 7\\n\\nFor more information see https://www.geeksforgeeks.org/maximum-path-sum-matrix/\\n */\\npublic class MinimumPathSum {\\n\\n    public void testRegular() {\\n        int[][] grid = {\\n            {1, 3, 1},\\n            {1, 5, 1},\\n            {4, 2, 1}\\n        };\\n        System.out.println(minimumPathSum(grid));\\n    }\\n\\n    public void testLessColumns() {\\n        int[][] grid = {\\n            {1, 2},\\n            {5, 6},\\n            {1, 1}\\n        };\\n        System.out.println(minimumPathSum(grid));\\n    }\\n\\n    public void testLessRows() {\\n        int[][] grid = {\\n            {2, 3, 3},\\n            {7, 2, 1}\\n        };\\n        System.out.println(minimumPathSum(grid));\\n    }\\n\\n    public void testOneRowOneColumn() {\\n        int[][] grid = {{2}};\\n        System.out.println(minimumPathSum(grid));\\n    }\\n\\n    public static int minimumPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        if (n == 0) {\\n            return 0;\\n        }\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        for (int i = 0; i < n - 1; i++) {\\n            dp[0][i + 1] = dp[0][i] + grid[0][i + 1];\\n        }\\n        for (int i = 0; i < m - 1; i++) {\\n            dp[i + 1][0] = dp[i][0] + grid[i + 1][0];\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n}\\n\"",
    "minimum sum partition": "\"package com.thealgorithms.dynamicprogramming;\\n// Partition a set into two subsets such that the difference of subset sums is minimum\\n\\n/*\\nInput:  arr[] = {1, 6, 11, 5}\\nOutput: 1\\nExplanation:\\nSubset1 = {1, 5, 6}, sum of Subset1 = 12\\nSubset2 = {11}, sum of Subset2 = 11\\n\\nInput:  arr[] = {36, 7, 46, 40}\\nOutput: 23\\nExplanation:\\nSubset1 = {7, 46} ;  sum of Subset1 = 53\\nSubset2 = {36, 40} ; sum of Subset2  = 76\\n */\\npublic class MinimumSumPartition {\\n\\n    public static int subSet(int[] arr) {\\n        int n = arr.length;\\n        int sum = getSum(arr);\\n        boolean[][] dp = new boolean[n + 1][sum + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int j = 0; j <= sum; j++) {\\n            dp[0][j] = false;\\n        }\\n\\n        // fill dp array\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= sum; j++) {\\n                if (arr[i - 1] < j) {\\n                    dp[i][j] = dp[i - 1][j - arr[i - 1]] || dp[i - 1][j];\\n                } else if (arr[i - 1] == j) {\\n                    dp[i][j] = true;\\n                } else {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n\\n        // fill the index array\\n        int[] index = new int[sum];\\n        int p = 0;\\n        for (int i = 0; i <= sum / 2; i++) {\\n            if (dp[n][i]) {\\n                index[p++] = i;\\n            }\\n        }\\n\\n        return getMin(index, sum);\\n    }\\n\\n    /**\\n     * Calculate sum of array elements\\n     *\\n     * @param arr the array\\n     * @return sum of given array\\n     */\\n    public static int getSum(int[] arr) {\\n        int sum = 0;\\n        for (int temp : arr) {\\n            sum += temp;\\n        }\\n        return sum;\\n    }\\n\\n    public static int getMin(int[] arr, int sum) {\\n        if (arr.length == 0) {\\n            return 0;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int temp : arr) {\\n            min = Math.min(min, sum - 2 * temp);\\n        }\\n        return min;\\n    }\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        assert subSet(new int[]{1, 6, 11, 5}) == 1;\\n        assert subSet(new int[]{36, 7, 46, 40}) == 23;\\n        assert subSet(new int[]{1, 2, 3, 9}) == 3;\\n    }\\n}\\n\"",
    "palindromic partitioning": "\"package com.thealgorithms.dynamicprogramming;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * @file @brief Implements [Palindrome\\n * Partitioning](https://leetcode.com/problems/palindrome-partitioning-ii/)\\n * algorithm, giving you the minimum number of partitions you need to make\\n *\\n * @details palindrome partitioning uses dynamic programming and goes to all the\\n * possible partitions to find the minimum you are given a string and you need\\n * to give minimum number of partitions needed to divide it into a number of\\n * palindromes [Palindrome Partitioning]\\n * (https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/) overall time\\n * complexity O(n^2) For example: example 1:- String : \\\"nitik\\\" Output : 2 => \\\"n\\n * | iti | k\\\" For example: example 2:- String : \\\"ababbbabbababa\\\" Output : 3 =>\\n * \\\"aba | b | bbabb | ababa\\\"\\n * @author [Syed] (https://github.com/roeticvampire)\\n */\\npublic class PalindromicPartitioning {\\n\\n    public static int minimalpartitions(String word) {\\n        int len = word.length();\\n        /* We Make two arrays to create a bottom-up solution.\\n           minCuts[i] = Minimum number of cuts needed for palindrome partitioning of substring word[0..i]\\n           isPalindrome[i][j] = true if substring str[i..j] is palindrome\\n           Base Condition: C[i] is 0 if P[0][i]= true\\n         */\\n        int[] minCuts = new int[len];\\n        boolean[][] isPalindrome = new boolean[len][len];\\n\\n        int i, j, L; // different looping variables\\n\\n        // Every substring of length 1 is a palindrome\\n        for (i = 0; i < len; i++) {\\n            isPalindrome[i][i] = true;\\n        }\\n\\n        /* L is substring length. Build the solution in bottom up manner by considering all substrings of length starting from 2 to n. */\\n        for (L = 2; L <= len; L++) {\\n            // For substring of length L, set different possible starting indexes\\n            for (i = 0; i < len - L + 1; i++) {\\n                j = i + L - 1; // Ending index\\n                // If L is 2, then we just need to\\n                // compare two characters. Else need to\\n                // check two corner characters and value\\n                // of P[i+1][j-1]\\n                if (L == 2) {\\n                    isPalindrome[i][j] = (word.charAt(i) == word.charAt(j));\\n                } else {\\n                    if ((word.charAt(i) == word.charAt(j)) && isPalindrome[i + 1][j - 1]) {\\n                        isPalindrome[i][j] = true;\\n                    } else {\\n                        isPalindrome[i][j] = false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        //We find the minimum for each index\\n        for (i = 0; i < len; i++) {\\n            if (isPalindrome[0][i] == true) {\\n                minCuts[i] = 0;\\n            } else {\\n                minCuts[i] = Integer.MAX_VALUE;\\n                for (j = 0; j < i; j++) {\\n                    if (isPalindrome[j + 1][i] == true && 1 + minCuts[j] < minCuts[i]) {\\n                        minCuts[i] = 1 + minCuts[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return the min cut value for complete\\n        // string. i.e., str[0..n-1]\\n        return minCuts[len - 1];\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner input = new Scanner(System.in);\\n        String word;\\n        System.out.println(\\\"Enter the First String\\\");\\n        word = input.nextLine();\\n        // ans stores the final minimal cut count needed for partitioning\\n        int ans = minimalpartitions(word);\\n        System.out.println(\\n                \\\"The minimum cuts needed to partition \\\\\\\"\\\" + word + \\\"\\\\\\\" into palindromes is \\\" + ans);\\n        input.close();\\n    }\\n}\\n\"",
    "regex matching": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * Given a text and wildcard pattern implement a wildcard pattern matching\\n * algorithm that finds if wildcard is matched with text. The matching should\\n * cover the entire text ?-> matches single characters *-> match the sequence of\\n * characters\\n *\\n */\\n/**\\n * For calculation of Time and Space Complexity. Let N be length of src and M be\\n * length of pat\\n *\\n */\\npublic class RegexMatching {\\n\\n    // Method 1: Using Recursion\\n    // Time Complexity=0(2^(N+M)) Space Complexity=Recursion Extra Space\\n    static boolean regexRecursion(String src, String pat) {\\n        if (src.length() == 0 && pat.length() == 0) {\\n            return true;\\n        }\\n        if (src.length() != 0 && pat.length() == 0) {\\n            return false;\\n        }\\n        if (src.length() == 0 && pat.length() != 0) {\\n            for (int i = 0; i < pat.length(); i++) {\\n                if (pat.charAt(i) != '*') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        char chs = src.charAt(0);\\n        char chp = pat.charAt(0);\\n\\n        String ros = src.substring(1);\\n        String rop = pat.substring(1);\\n\\n        boolean ans;\\n        if (chs == chp || chp == '?') {\\n            ans = regexRecursion(ros, rop);\\n        } else if (chp == '*') {\\n            boolean blank = regexRecursion(src, rop);\\n            boolean multiple = regexRecursion(ros, pat);\\n            ans = blank || multiple;\\n        } else {\\n            ans = false;\\n        }\\n        return ans;\\n    }\\n\\n    // Method 2: Using Recursion and breaking string using virtual index\\n    // Time Complexity=0(2^(N+M)) Space Complexity=Recursion Extra Space\\n    static boolean regexRecursion(String src, String pat, int svidx, int pvidx) {\\n        if (src.length() == svidx && pat.length() == pvidx) {\\n            return true;\\n        }\\n        if (src.length() != svidx && pat.length() == pvidx) {\\n            return false;\\n        }\\n        if (src.length() == svidx && pat.length() != pvidx) {\\n            for (int i = pvidx; i < pat.length(); i++) {\\n                if (pat.charAt(i) != '*') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        char chs = src.charAt(svidx);\\n        char chp = pat.charAt(pvidx);\\n\\n        boolean ans;\\n        if (chs == chp || chp == '?') {\\n            ans = regexRecursion(src, pat, svidx + 1, pvidx + 1);\\n        } else if (chp == '*') {\\n            boolean blank = regexRecursion(src, pat, svidx, pvidx + 1);\\n            boolean multiple = regexRecursion(src, pat, svidx + 1, pvidx);\\n            ans = blank || multiple;\\n        } else {\\n            ans = false;\\n        }\\n        return ans;\\n    }\\n\\n    // Method 3: Top-Down DP(Memoization)\\n    // Time Complexity=0(N*M) Space Complexity=0(N*M)+Recursion Extra Space\\n    static boolean regexRecursion(String src, String pat, int svidx, int pvidx, int[][] strg) {\\n        if (src.length() == svidx && pat.length() == pvidx) {\\n            return true;\\n        }\\n        if (src.length() != svidx && pat.length() == pvidx) {\\n            return false;\\n        }\\n        if (src.length() == svidx && pat.length() != pvidx) {\\n            for (int i = pvidx; i < pat.length(); i++) {\\n                if (pat.charAt(i) != '*') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        if (strg[svidx][pvidx] != 0) {\\n            return strg[svidx][pvidx] == 1 ? false : true;\\n        }\\n        char chs = src.charAt(svidx);\\n        char chp = pat.charAt(pvidx);\\n\\n        boolean ans;\\n        if (chs == chp || chp == '?') {\\n            ans = regexRecursion(src, pat, svidx + 1, pvidx + 1, strg);\\n        } else if (chp == '*') {\\n            boolean blank = regexRecursion(src, pat, svidx, pvidx + 1, strg);\\n            boolean multiple = regexRecursion(src, pat, svidx + 1, pvidx, strg);\\n            ans = blank || multiple;\\n        } else {\\n            ans = false;\\n        }\\n        strg[svidx][pvidx] = ans == false ? 1 : 2;\\n        return ans;\\n    }\\n\\n    // Method 4: Bottom-Up DP(Tabulation)\\n    // Time Complexity=0(N*M) Space Complexity=0(N*M)\\n    static boolean regexBU(String src, String pat) {\\n\\n        boolean strg[][] = new boolean[src.length() + 1][pat.length() + 1];\\n        strg[src.length()][pat.length()] = true;\\n        for (int row = src.length(); row >= 0; row--) {\\n            for (int col = pat.length() - 1; col >= 0; col--) {\\n                if (row == src.length()) {\\n                    if (pat.charAt(col) == '*') {\\n                        strg[row][col] = strg[row][col + 1];\\n                    } else {\\n                        strg[row][col] = false;\\n                    }\\n                } else {\\n                    char chs = src.charAt(row);\\n                    char chp = pat.charAt(col);\\n\\n                    boolean ans;\\n                    if (chs == chp || chp == '?') {\\n                        ans = strg[row + 1][col + 1];\\n                    } else if (chp == '*') {\\n                        boolean blank = strg[row][col + 1];\\n                        boolean multiple = strg[row + 1][col];\\n                        ans = blank || multiple;\\n                    } else {\\n                        ans = false;\\n                    }\\n                    strg[row][col] = ans;\\n                }\\n            }\\n        }\\n        return strg[0][0];\\n    }\\n\\n    public static void main(String[] args) {\\n\\n        String src = \\\"aa\\\";\\n        String pat = \\\"*\\\";\\n        System.out.println(\\\"Method 1: \\\" + regexRecursion(src, pat));\\n        System.out.println(\\\"Method 2: \\\" + regexRecursion(src, pat, 0, 0));\\n        System.out.println(\\\"Method 3: \\\" + regexRecursion(src, pat, 0, 0, new int[src.length()][pat.length()]));\\n        System.out.println(\\\"Method 4: \\\" + regexBU(src, pat));\\n\\n    }\\n\\n}\\n// Memoization vs Tabulation : https://www.geeksforgeeks.org/tabulation-vs-memoization/\\n// Question Link : https://practice.geeksforgeeks.org/problems/wildcard-pattern-matching/1\\n\"",
    "rod cutting": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * A DynamicProgramming solution for Rod cutting problem Returns the best\\n * obtainable price for a rod of length n and price[] as prices of different\\n * pieces\\n */\\npublic class RodCutting {\\n\\n    private static int cutRod(int[] price, int n) {\\n        int val[] = new int[n + 1];\\n        val[0] = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            int max_val = Integer.MIN_VALUE;\\n            for (int j = 0; j < i; j++) {\\n                max_val = Math.max(max_val, price[j] + val[i - j - 1]);\\n            }\\n\\n            val[i] = max_val;\\n        }\\n\\n        return val[n];\\n    }\\n\\n    // main function to test\\n    public static void main(String args[]) {\\n        int[] arr = new int[]{2, 5, 13, 19, 20};\\n        int result = cutRod(arr, arr.length);\\n        System.out.println(\\\"Maximum Obtainable Value is \\\" + result);\\n    }\\n}\\n\"",
    "shortest common supersequence length": "\"package com.thealgorithms.dynamicprogramming;\\n\\n// Java program to find length of the shortest supersequence\\nclass ShortestSuperSequence {\\n\\n    // Function to find length of the\\n    // shortest supersequence of X and Y.\\n    static int shortestSuperSequence(String X, String Y) {\\n        int m = X.length();\\n        int n = Y.length();\\n\\n        // find lcs\\n        int l = lcs(X, Y, m, n);\\n\\n        // Result is sum of input string\\n        // lengths - length of lcs\\n        return (m + n - l);\\n    }\\n\\n    // Returns length of LCS\\n    // for X[0..m - 1], Y[0..n - 1]\\n    static int lcs(String X, String Y, int m, int n) {\\n        int[][] L = new int[m + 1][n + 1];\\n        int i, j;\\n\\n        // Following steps build L[m + 1][n + 1]\\n        // in bottom up fashion. Note that\\n        // L[i][j] contains length of LCS\\n        // of X[0..i - 1]and Y[0..j - 1]\\n        for (i = 0; i <= m; i++) {\\n            for (j = 0; j <= n; j++) {\\n                if (i == 0 || j == 0) {\\n                    L[i][j] = 0;\\n                } else if (X.charAt(i - 1) == Y.charAt(j - 1)) {\\n                    L[i][j] = L[i - 1][j - 1] + 1;\\n                } else {\\n                    L[i][j] = Math.max(L[i - 1][j],\\n                            L[i][j - 1]);\\n                }\\n            }\\n        }\\n\\n        // L[m][n] contains length of LCS\\n        // for X[0..n - 1] and Y[0..m - 1]\\n        return L[m][n];\\n    }\\n\\n    // Driver code\\n    public static void main(String args[]) {\\n        String X = \\\"AGGTAB\\\";\\n        String Y = \\\"GXTXAYB\\\";\\n\\n        System.out.println(\\\"Length of the shortest \\\"\\n                + \\\"supersequence is \\\"\\n                + shortestSuperSequence(X, Y));\\n    }\\n}\\n\"",
    "subset sum": "\"package com.thealgorithms.dynamicprogramming;\\n\\npublic class SubsetSum {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        int[] arr = new int[]{50, 4, 10, 15, 34};\\n        assert subsetSum(arr, 64);\\n        /* 4 + 10 + 15 + 34 = 64 */\\n        assert subsetSum(arr, 99);\\n        /* 50 + 15 + 34 = 99 */\\n        assert !subsetSum(arr, 5);\\n        assert !subsetSum(arr, 66);\\n    }\\n\\n    /**\\n     * Test if a set of integers contains a subset that sum to a given integer.\\n     *\\n     * @param arr the array contains integers.\\n     * @param sum target sum of subset.\\n     * @return {@code true} if subset exists, otherwise {@code false}.\\n     */\\n    private static boolean subsetSum(int[] arr, int sum) {\\n        int n = arr.length;\\n        boolean[][] isSum = new boolean[n + 2][sum + 1];\\n\\n        isSum[n + 1][0] = true;\\n        for (int i = 1; i <= sum; i++) {\\n            isSum[n + 1][i] = false;\\n        }\\n\\n        for (int i = n; i > 0; i--) {\\n            isSum[i][0] = true;\\n            for (int j = 1; j <= arr[i - 1] - 1; j++) {\\n                if (j <= sum) {\\n                    isSum[i][j] = isSum[i + 1][j];\\n                }\\n            }\\n            for (int j = arr[i - 1]; j <= sum; j++) {\\n                isSum[i][j] = (isSum[i + 1][j] || isSum[i + 1][j - arr[i - 1]]);\\n            }\\n        }\\n\\n        return isSum[1][sum];\\n    }\\n}\\n\"",
    "sum  of  subset": "\"package com.thealgorithms.dynamicprogramming;\\n\\npublic class Sum_Of_Subset {\\n\\n    public static void main(String[] args) {\\n\\n        int[] arr = {7, 3, 2, 5, 8};\\n        int Key = 14;\\n\\n        if (subsetSum(arr, arr.length - 1, Key)) {\\n            System.out.print(\\\"Yes, that sum exists\\\");\\n        } else {\\n            System.out.print(\\\"Nope, that number does not exist\\\");\\n        }\\n    }\\n\\n    public static boolean subsetSum(int[] arr, int num, int Key) {\\n        if (Key == 0) {\\n            return true;\\n        }\\n        if (num < 0 || Key < 0) {\\n            return false;\\n        }\\n\\n        boolean include = subsetSum(arr, num - 1, Key - arr[num]);\\n        boolean exclude = subsetSum(arr, num - 1, Key);\\n\\n        return include || exclude;\\n    }\\n}\\n\"",
    "wine problem": "\"package com.thealgorithms.dynamicprogramming;\\n\\n/**\\n * Imagine you have a collection of N wines placed next to each other on the\\n * shelf. The price of ith wine is pi(Prices of different wines are different).\\n * Because wine gets better every year supposing today is year 1, on year y the\\n * price would be y*pi i.e y times the value of the initial year. You want to\\n * sell all wines but you have to sell one wine per year. One more constraint on\\n * each year you are allowed to sell either leftmost or rightmost wine on the\\n * shelf. You are not allowed to reorder. You have to find the maximum profit\\n *\\n */\\npublic class WineProblem {\\n\\n    // Method 1: Using Recursion\\n    // Time Complexity=0(2^N) Space Complexity=Recursion extra space\\n    public static int WPRecursion(int[] arr, int si, int ei) {\\n        int n = arr.length;\\n        int year = (n - (ei - si + 1)) + 1;\\n        if (si == ei) {\\n            return arr[si] * year;\\n        }\\n\\n        int start = WPRecursion(arr, si + 1, ei) + arr[si] * year;\\n        int end = WPRecursion(arr, si, ei - 1) + arr[ei] * year;\\n\\n        int ans = Math.max(start, end);\\n\\n        return ans;\\n    }\\n\\n    // Method 2: Top-Down DP(Memoization)\\n    // Time Complexity=0(N*N) Space Complexity=0(N*N)+Recursion extra space\\n    public static int WPTD(int[] arr, int si, int ei, int[][] strg) {\\n        int n = arr.length;\\n        int year = (n - (ei - si + 1)) + 1;\\n        if (si == ei) {\\n            return arr[si] * year;\\n        }\\n\\n        if (strg[si][ei] != 0) {\\n            return strg[si][ei];\\n        }\\n        int start = WPTD(arr, si + 1, ei, strg) + arr[si] * year;\\n        int end = WPTD(arr, si, ei - 1, strg) + arr[ei] * year;\\n\\n        int ans = Math.max(start, end);\\n\\n        strg[si][ei] = ans;\\n\\n        return ans;\\n    }\\n\\n    // Method 3: Bottom-Up DP(Tabulation)\\n    // Time Complexity=0(N*N/2)->0(N*N) Space Complexity=0(N*N)\\n    public static int WPBU(int[] arr) {\\n        int n = arr.length;\\n        int[][] strg = new int[n][n];\\n\\n        for (int slide = 0; slide <= n - 1; slide++) {\\n            for (int si = 0; si <= n - slide - 1; si++) {\\n                int ei = si + slide;\\n                int year = (n - (ei - si + 1)) + 1;\\n                if (si == ei) {\\n                    strg[si][ei] = arr[si] * year;\\n                } else {\\n                    int start = strg[si + 1][ei] + arr[si] * year;\\n                    int end = strg[si][ei - 1] + arr[ei] * year;\\n\\n                    strg[si][ei] = Math.max(start, end);\\n\\n                }\\n            }\\n        }\\n        return strg[0][n - 1];\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] arr = {2, 3, 5, 1, 4};\\n        System.out.println(\\\"Method 1: \\\" + WPRecursion(arr, 0, arr.length - 1));\\n        System.out.println(\\\"Method 2: \\\" + WPTD(arr, 0, arr.length - 1, new int[arr.length][arr.length]));\\n        System.out.println(\\\"Method 3: \\\" + WPBU(arr));\\n\\n    }\\n\\n}\\n// Memoization vs Tabulation : https://www.geeksforgeeks.org/tabulation-vs-memoization/\\n// Question Link : https://www.geeksforgeeks.org/maximum-profit-sale-wines/\\n\"",
    "absolute max": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Arrays;\\n\\n/**\\n * description:\\n *\\n * <p>\\n * absMax([0, 5, 1, 11]) = 11, absMax([3 , -10, -2]) = -10\\n */\\npublic class AbsoluteMax {\\n\\n    public static void main(String[] args) {\\n        int[] testnums = {-2, 0, 16};\\n        assert absMax(testnums) == 16;\\n\\n        int[] numbers = {3, -10, -2};\\n        System.out.println(\\\"absMax(\\\" + Arrays.toString(numbers) + \\\") = \\\" + absMax(numbers));\\n    }\\n\\n    /**\\n     * get the value, return the absolute max value\\n     *\\n     * @param numbers contains elements\\n     * @return the absolute max value\\n     */\\n    public static int absMax(int[] numbers) {\\n        int absMaxValue = numbers[0];\\n        for (int i = 1, length = numbers.length; i < length; ++i) {\\n            if (Math.abs(numbers[i]) > Math.abs(absMaxValue)) {\\n                absMaxValue = numbers[i];\\n            }\\n        }\\n        return absMaxValue;\\n    }\\n}\\n\"",
    "absolute min": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Arrays;\\n\\n/**\\n * description:\\n *\\n * <p>\\n * absMin([0, 5, 1, 11]) = 0, absMin([3 , -10, -2]) = -2\\n */\\npublic class AbsoluteMin {\\n\\n    public static void main(String[] args) {\\n        int[] testnums = {4, 0, 16};\\n        assert absMin(testnums) == 0;\\n\\n        int[] numbers = {3, -10, -2};\\n        System.out.println(\\\"absMin(\\\" + Arrays.toString(numbers) + \\\") = \\\" + absMin(numbers));\\n    }\\n\\n    /**\\n     * get the value, returns the absolute min value min\\n     *\\n     * @param numbers contains elements\\n     * @return the absolute min value\\n     */\\n    public static int absMin(int[] numbers) {\\n        int absMinValue = numbers[0];\\n        for (int i = 1, length = numbers.length; i < length; ++i) {\\n            if (Math.abs(numbers[i]) < Math.abs(absMinValue)) {\\n                absMinValue = numbers[i];\\n            }\\n        }\\n        return absMinValue;\\n    }\\n}\\n\"",
    "absolute value": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Random;\\n\\npublic class AbsoluteValue {\\n\\n    public static void main(String[] args) {\\n        Random random = new Random();\\n\\n        /* test 1000 random numbers */\\n        for (int i = 1; i <= 1000; ++i) {\\n            int randomNumber = random.nextInt();\\n            assert absVal(randomNumber) == Math.abs(randomNumber);\\n        }\\n    }\\n\\n    /**\\n     * If value is less than zero, make value positive.\\n     *\\n     * @param value a number\\n     * @return the absolute value of a number\\n     */\\n    public static int absVal(int value) {\\n        return value < 0 ? -value : value;\\n    }\\n}\\n\"",
    "a d t fraction": "\"package com.thealgorithms.maths;\\n\\npublic class ADTFraction {\\n\\n    public static void main(String[] args) {\\n        // TODO code application logic here\\n\\n        ADTFraction f1 = new ADTFraction(3, 5);\\n        f1.display();\\n        ADTFraction f2 = new ADTFraction(7, 8);\\n        f2.display();\\n        ADTFraction f3 = f1.plus(f2);\\n        f3.display();\\n        ADTFraction f4 = f1.times(f2);\\n        f4.display();\\n        ADTFraction f5 = f1.times(4);\\n        f5.display();\\n\\n    }\\n\\n    private int n; //numerator\\n    private int d; //denomenator\\n\\n    public ADTFraction() {\\n        this.n = 0;\\n        this.d = 1;\\n    }\\n\\n    public ADTFraction(int a, int b) {//parameter constructor\\n\\n        if (b != 0) {\\n            this.n = a;\\n            this.d = b;\\n        } else {\\n            this.n = 0;\\n            this.d = 1;\\n            System.out.println(\\\"denomerator cannot be 0,default values assinged\\\");\\n        }\\n    }\\n\\n    public void set(int a, int b) {//set numerator and denomenator\\n\\n        if (b != 0) {\\n            this.n = a;\\n            this.d = b;\\n        } else {\\n            this.n = 0;\\n            this.d = 1;\\n            System.out.println(\\\"denomerator cannot be 0,default values assinged\\\");\\n        }\\n\\n    }\\n\\n    //add two fractions\\n    public ADTFraction plus(ADTFraction x) {\\n\\n        int num, den;\\n        num = this.d * x.n + this.n * x.d;\\n        den = this.d * x.d;\\n        ADTFraction f = new ADTFraction(num, den);\\n        return f;\\n\\n    }\\n\\n    public ADTFraction times(int a) {//multiply fraction by a number\\n\\n        int num, den;\\n        num = this.n * a;\\n        den = this.d;\\n        ADTFraction f1 = new ADTFraction(num, den);\\n        return f1;\\n\\n    }\\n\\n    public ADTFraction times(ADTFraction x) {//multiply two fractions\\n\\n        int num, dem;\\n        num = this.n * x.n;\\n        dem = this.d * x.d;\\n        ADTFraction f3 = new ADTFraction(num, dem);\\n        return f3;\\n\\n    }\\n\\n    //reciprocal of a fraction\\n    public ADTFraction reciprocal() {\\n        ADTFraction f1 = new ADTFraction(this.d, this.n);\\n        return f1;\\n    }\\n\\n    //numerical value of a fraction\\n    public float value() {\\n        return (float) this.n / this.d;\\n    }\\n\\n    //display the fraction in the format n/d\\n    public void display() {\\n        System.out.println(this.n + \\\"/\\\" + this.d);\\n    }\\n}\\n\"",
    "aliquot sum": "\"package com.thealgorithms.maths;\\n\\n/**\\n * In number theory, the aliquot sum s(n) of a positive integer n is the sum of\\n * all proper divisors of n, that is, all divisors of n other than n itself. For\\n * example, the proper divisors of 15 (that is, the positive divisors of 15 that\\n * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 +\\n * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum\\n */\\npublic class AliquotSum {\\n\\n    public static void main(String[] args) {\\n        assert aliquotSum(1) == 0;\\n        assert aliquotSum(6) == 6;\\n        assert aliquotSum(15) == 9;\\n        assert aliquotSum(19) == 1;\\n    }\\n\\n    /**\\n     * Finds the aliquot sum of an integer number\\n     *\\n     * @param number a positive integer\\n     * @return aliquot sum of given {@code number}\\n     */\\n    public static int aliquotSum(int number) {\\n        int sum = 0;\\n        for (int i = 1, limit = number / 2; i <= limit; ++i) {\\n            if (number % i == 0) {\\n                sum += i;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\"",
    "amicable number": "\"package com.thealgorithms.maths;\\n\\n/**\\n * Amicable numbers are two different numbers so related that the sum of the\\n * proper divisors of each is equal to the other number. (A proper divisor of a\\n * number is a positive factor of that number other than the number itself. For\\n * example, the proper divisors of 6 are 1, 2, and 3.) A pair of amicable\\n * numbers constitutes an aliquot sequence of period 2. It is unknown if there\\n * are infinitely many pairs of amicable numbers. *\\n *\\n * <p>\\n * link: https://en.wikipedia.org/wiki/Amicable_numbers *\\n *\\n * <p>\\n * Simple Example : (220,284) 220 is divisible by {1,2,4,5,10,11,20,22,44,55,110\\n * } <- Sum = 284\\n * 284 is divisible by -> 1,2,4,71,142 and the Sum of that is. Yes right you\\n * probably expected it 220\\n */\\npublic class AmicableNumber {\\n\\n    public static void main(String[] args) {\\n\\n        AmicableNumber.findAllInRange(1, 3000);\\n        /* Res -> Int Range of 1 till 3000there are 3Amicable_numbers These are  1: = ( 220,284)\\t2: = ( 1184,1210)\\n    3: = ( 2620,2924) So it worked\\t*/\\n\\n    }\\n\\n    /**\\n     * @param startValue\\n     * @param stopValue\\n     * @return\\n     */\\n    static void findAllInRange(int startValue, int stopValue) {\\n\\n        /* the 2 for loops are to avoid to double check tuple. For example (200,100) and (100,200) is the same calculation\\n     * also to avoid is to check the number with it self. a number with itself is always a AmicableNumber\\n     * */\\n        StringBuilder res = new StringBuilder();\\n        int countofRes = 0;\\n\\n        for (int i = startValue; i < stopValue; i++) {\\n            for (int j = i + 1; j <= stopValue; j++) {\\n                if (isAmicableNumber(i, j)) {\\n                    countofRes++;\\n                    res.append(\\\"\\\" + countofRes + \\\": = ( \\\" + i + \\\",\\\" + j + \\\")\\\" + \\\"\\\\t\\\");\\n                }\\n            }\\n        }\\n        res.insert(\\n                0,\\n                \\\"Int Range of \\\"\\n                + startValue\\n                + \\\" till \\\"\\n                + stopValue\\n                + \\\" there are \\\"\\n                + countofRes\\n                + \\\" Amicable_numbers.These are \\\\n \\\");\\n        System.out.println(res.toString());\\n    }\\n\\n    /**\\n     * Check if {@code numberOne and numberTwo } are AmicableNumbers or not\\n     *\\n     * @param numberOne numberTwo\\n     * @return {@code true} if {@code numberOne numberTwo} isAmicableNumbers\\n     * otherwise false\\n     */\\n    static boolean isAmicableNumber(int numberOne, int numberTwo) {\\n\\n        return ((recursiveCalcOfDividerSum(numberOne, numberOne) == numberTwo\\n                && numberOne == recursiveCalcOfDividerSum(numberTwo, numberTwo)));\\n    }\\n\\n    /**\\n     * calculated in recursive calls the Sum of all the Dividers beside it self\\n     *\\n     * @param number div = the next to test dividely by using the modulo\\n     * operator\\n     * @return sum of all the dividers\\n     */\\n    static int recursiveCalcOfDividerSum(int number, int div) {\\n\\n        if (div == 1) {\\n            return 0;\\n        } else if (number % --div == 0) {\\n            return recursiveCalcOfDividerSum(number, div) + div;\\n        } else {\\n            return recursiveCalcOfDividerSum(number, div);\\n        }\\n    }\\n}\\n\"",
    "area": "\"package com.thealgorithms.maths;\\n\\n/**\\n * Find the area of various geometric shapes\\n */\\npublic class Area {\\n\\n    public static void main(String[] args) {\\n\\n        /* test cube */\\n        assert Double.compare(surfaceAreaCube(1), 6.0) == 0;\\n\\n        /* test sphere */\\n        assert Double.compare(surfaceAreaSphere(5), 314.1592653589793) == 0;\\n        assert Double.compare(surfaceAreaSphere(1), 12.566370614359172) == 0;\\n\\n        /* test rectangle */\\n        assert Double.compare(surfaceAreaRectangle(10, 20), 200.0) == 0;\\n\\n        /* test square */\\n        assert Double.compare(surfaceAreaSquare(10), 100.0) == 0;\\n\\n        /* test triangle */\\n        assert Double.compare(surfaceAreaTriangle(10, 10), 50.0) == 0;\\n\\n        /* test parallelogram */\\n        assert Double.compare(surfaceAreaParallelogram(10, 20), 200.0) == 0;\\n\\n        /* test trapezium */\\n        assert Double.compare(surfaceAreaTrapezium(10, 20, 30), 450.0) == 0;\\n\\n        /* test circle */\\n        assert Double.compare(surfaceAreaCircle(20), 1256.6370614359173) == 0;\\n\\n        /* test cylinder */\\n        assert Double.compare(surfaceAreaCylinder(1, 2), 18.84955592153876) == 0;\\n\\n        /* test hemisphere */\\n        assert Double.compare(surfaceAreaHemisphere(5), 235.61944901923448) == 0;\\n        assert Double.compare(surfaceAreaHemisphere(1), 9.42477796076938) == 0;\\n\\n        /* test cone */\\n        assert Double.compare(surfaceAreaCone(6, 8), 301.59289474462014) == 0;\\n        assert Double.compare(surfaceAreaCone(10, 24), 1130.9733552923256) == 0;\\n\\n    }\\n\\n    /**\\n     * Calculate the surface area of a cube.\\n     *\\n     * @param sideLength side length of cube\\n     * @return surface area of given cube\\n     */\\n    private static double surfaceAreaCube(double sideLength) {\\n        return 6 * sideLength * sideLength;\\n    }\\n\\n    /**\\n     * Calculate the surface area of a sphere.\\n     *\\n     * @param radius radius of sphere\\n     * @return surface area of given sphere\\n     */\\n    private static double surfaceAreaSphere(double radius) {\\n        return 4 * Math.PI * radius * radius;\\n    }\\n\\n    /**\\n     * Calculate the area of a rectangle\\n     *\\n     * @param length length of rectangle\\n     * @param width width of rectangle\\n     * @return area of given rectangle\\n     */\\n    private static double surfaceAreaRectangle(double length, double width) {\\n        return length * width;\\n    }\\n\\n    /**\\n     * Calculate surface area of a cylinder\\n     *\\n     * @param radius radius of the floor\\n     * @param height height of the cylinder.\\n     * @return volume of given cylinder\\n     */\\n    private static double surfaceAreaCylinder(double radius, double height) {\\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\\n    }\\n\\n    /**\\n     * Calculate the area of a square\\n     *\\n     * @param sideLength side length of square\\n     * @return area of given square\\n     */\\n    private static double surfaceAreaSquare(double sideLength) {\\n        return sideLength * sideLength;\\n    }\\n\\n    /**\\n     * Calculate the area of a triangle\\n     *\\n     * @param base base of triangle\\n     * @param height height of triangle\\n     * @return area of given triangle\\n     */\\n    private static double surfaceAreaTriangle(double base, double height) {\\n        return base * height / 2;\\n    }\\n\\n    /**\\n     * Calculate the area of a parallelogram\\n     *\\n     * @param base base of parallelogram\\n     * @param height height of parallelogram\\n     * @return area of given parallelogram\\n     */\\n    private static double surfaceAreaParallelogram(double base, double height) {\\n        return base * height;\\n    }\\n\\n    /**\\n     * Calculate the area of a trapezium\\n     *\\n     * @param base1 upper base of trapezium\\n     * @param base2 bottom base of trapezium\\n     * @param height height of trapezium\\n     * @return area of given trapezium\\n     */\\n    private static double surfaceAreaTrapezium(double base1, double base2, double height) {\\n        return (base1 + base2) * height / 2;\\n    }\\n\\n    /**\\n     * Calculate the area of a circle\\n     *\\n     * @param radius radius of circle\\n     * @return area of given circle\\n     */\\n    private static double surfaceAreaCircle(double radius) {\\n        return Math.PI * radius * radius;\\n    }\\n\\n    /**\\n     * Calculate the surface area of a hemisphere.\\n     *\\n     * @param radius radius of hemisphere\\n     * @return surface area of given hemisphere\\n     */\\n    private static double surfaceAreaHemisphere(double radius) {\\n        return 3 * Math.PI * radius * radius;\\n    }\\n\\n    /**\\n     * Calculate the surface area of a cone.\\n     *\\n     * @param radius radius of cone.\\n     * @param height of cone.\\n     * @return surface area of given cone.\\n     */\\n    private static double surfaceAreaCone(double radius, double height) {\\n        return Math.PI * radius * (radius + Math.pow((height * height + radius * radius), 0.5));\\n    }\\n}\\n\"",
    "armstrong": "\"package com.thealgorithms.maths;\\n\\n/**\\n * An Armstrong number is equal to the sum of the cubes of its digits. For\\n * example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370. An\\n * Armstrong number is often called Narcissistic number.\\n */\\npublic class Armstrong {\\n\\n    public static void main(String[] args) {\\n        assert (isArmStrong(0));\\n        assert (isArmStrong(1));\\n        assert (isArmStrong(153));\\n        assert (isArmStrong(1634));\\n        assert (isArmStrong(371));\\n        assert (!isArmStrong(200));\\n    }\\n\\n    /**\\n     * Checks whether a given number is an armstrong number or not.\\n     *\\n     * @param number number to check\\n     * @return {@code true} if given number is armstrong number, {@code false}\\n     * otherwise\\n     */\\n    private static boolean isArmStrong(int number) {\\n        int sum = 0;\\n        int temp = number;\\n        int numberOfDigits = 0;\\n        while (temp != 0) {\\n            numberOfDigits++;\\n            temp /= 10;\\n        }\\n        temp = number;\\n        /* copy number again */\\n        while (number > 0) {\\n            int remainder = number % 10;\\n            int power = 1;\\n            for (int i = 1; i <= numberOfDigits; power *= remainder, ++i)\\n        ;\\n            sum = sum + power;\\n            number /= 10;\\n        }\\n        return sum == temp;\\n    }\\n}\\n\"",
    "automorphic number": "\"package com.thealgorithms.maths;\\n\\n/**\\n * A number is said to be an Automorphic, if it is present in the last digit(s)\\n * of its square. Example- Let the number be 25, its square is 625. Since,\\n * 25(The input number) is present in the last two digits of its square(625), it\\n * is an Automorphic Number.\\n */\\nimport java.io.*;\\n\\npublic class AutomorphicNumber {\\n\\n    //returns True if the number is a Automorphic number and False if it is not an Automorphic number\\n    public static boolean isAutomorphic(int n) {\\n        int m, c, r, p, k;\\n        c = 0;\\n        /**\\n         * m = Temporary variable to store a copy of the number entered by the\\n         * user. n = The number entered by the user c = Count the digits of the\\n         * number entered by user. p = To calculate the square of the number. k\\n         * = Support variable to count the digits of the number\\n         */\\n        double s;\\n        m = n;\\n        p = m * m; //Calculating square of the number\\n        do {\\n            k = n / 10;\\n            c = c + 1; //Counting the digits of the number entered by user.\\n            n = k;\\n        } while (n != 0);\\n        s = Math.pow(10, c);\\n        r = p % (int) s;\\n        if (m == r) //Checking if the original number entered is present at the end of the square\\n        {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * Method to check if number is Automorphic Number or Not 1) Input - Enter a\\n     * Number: 25 Output - It is an Automorphic Number. 2) Input - Enter a\\n     * Number: 7 Output - It is not an Automorphic Number.\\n     */\\n    public static void main(String args[]) throws IOException {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        System.out.println(\\\"Enter a Number: \\\");\\n        int n = Integer.parseInt(br.readLine());\\n        if (isAutomorphic(n)) {\\n            System.out.println(\\\"It is an Automorphic Number.\\\");\\n        } else {\\n            System.out.println(\\\"It is not an Automorphic Number.\\\");\\n        }\\n    }\\n}\\n\"",
    "average": "\"package com.thealgorithms.maths;\\n\\n/**\\n * Calculate average of a list of numbers\\n */\\npublic class Average {\\n\\n    private static final double SMALL_VALUE = 0.00001f;\\n\\n    public static void main(String[] args) {\\n        assert Math.abs(average(new double[]{3, 6, 9, 12, 15, 18, 21}) - 12) < SMALL_VALUE;\\n        assert Math.abs(average(new double[]{5, 10, 15, 20, 25, 30, 35}) - 20) < SMALL_VALUE;\\n        assert Math.abs(average(new double[]{1, 2, 3, 4, 5, 6, 7, 8}) - 4.5) < SMALL_VALUE;\\n        int[] array = {2, 4, 10};\\n        assert average(array) == 5;\\n    }\\n\\n    /**\\n     * Calculate average of a list of numbers\\n     *\\n     * @param numbers array to store numbers\\n     * @return mean of given numbers\\n     */\\n    public static double average(double[] numbers) {\\n        double sum = 0;\\n        for (double number : numbers) {\\n            sum += number;\\n        }\\n        return sum / numbers.length;\\n    }\\n\\n    /**\\n     * find average value of int array\\n     *\\n     * @param array the array contains element and the sum does not excess long\\n     * value limit\\n     * @return average value\\n     */\\n    public static int average(int[] array) {\\n        long sum = 0;\\n        for (int i = 0; i < array.length; ++i) {\\n            sum += array[i];\\n        }\\n        return (int) (sum / array.length);\\n    }\\n}\\n\"",
    "binary pow": "\"package com.thealgorithms.maths;\\n\\npublic class BinaryPow {\\n\\n    /**\\n     * Calculate a^p using binary exponentiation\\n     * [Binary-Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)\\n     *\\n     * @param a the base for exponentiation\\n     * @param p the exponent - must be greater than 0\\n     * @return a^p\\n     */\\n    public static int binPow(int a, int p) {\\n        int res = 1;\\n        while (p > 0) {\\n            if ((p & 1) == 1) {\\n                res = res * a;\\n            }\\n            a = a * a;\\n            p >>>= 1;\\n        }\\n        return res;\\n    }\\n\\n    /**\\n     * Function for testing binary exponentiation\\n     *\\n     * @param a the base\\n     * @param p the exponent\\n     */\\n    public static void test(int a, int p) {\\n        int res = binPow(a, p);\\n        assert res == (int) Math.pow(a, p) : \\\"Incorrect Implementation\\\";\\n        System.out.println(a + \\\"^\\\" + p + \\\": \\\" + res);\\n    }\\n\\n    /**\\n     * Main Function to call tests\\n     *\\n     * @param args System Line Arguments\\n     */\\n    public static void main(String[] args) {\\n        // prints 2^15: 32768\\n        test(2, 15);\\n\\n        // prints 3^9: 19683\\n        test(3, 9);\\n    }\\n}\\n\"",
    "binomial coefficient": "\"package com.thealgorithms.maths;\\n\\n/*\\n * Java program for Binomial Cofficients\\n * Binomial Cofficients: A binomial cofficient C(n,k) gives number ways\\n * in which k objects can be chosen from n objects.\\n * Wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient\\n * \\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\\n * \\n * */\\n\\npublic class BinomialCoefficient {\\n\\t\\n\\t/**\\n     * This method returns the number of ways in which k objects can be chosen from n objects\\n     *\\n     * @param total_objects Total number of objects\\n     * @param no_of_objects Number of objects to be chosen from total_objects\\n     * @return number of ways in which no_of_objects objects can be chosen from total_objects objects\\n     */\\n\\t\\n\\tstatic int binomialCoefficient(int total_objects, int no_of_objects) {\\n\\t\\t\\n\\t\\t//Base Case\\n\\t\\tif(no_of_objects > total_objects) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\t//Base Case\\n\\t\\tif(no_of_objects == 0 || no_of_objects == total_objects) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\t//Recursive Call\\n\\t\\treturn binomialCoefficient(total_objects - 1, no_of_objects - 1)\\n\\t\\t\\t\\t+ binomialCoefficient(total_objects - 1, no_of_objects);\\n\\t}\\n\\t\\n\\tpublic static void main(String[] args) {\\n\\t\\tSystem.out.println(binomialCoefficient(20,2));\\n\\t\\t\\n\\t\\t//Output: 190\\n\\t}\\n\\n}\\n\"",
    "ceil": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Random;\\n\\npublic class Ceil {\\n\\n    public static void main(String[] args) {\\n        Random random = new Random();\\n        for (int i = 1; i <= 1000; ++i) {\\n            double randomNumber = random.nextDouble();\\n            assert ceil(randomNumber) == Math.ceil(randomNumber);\\n        }\\n    }\\n\\n    /**\\n     * Returns the smallest (closest to negative infinity)\\n     *\\n     * @param number the number\\n     * @return the smallest (closest to negative infinity) of given\\n     * {@code number}\\n     */\\n    public static double ceil(double number) {\\n        if (number - (int) number == 0) {\\n            return number;\\n        } else if (number - (int) number > 0) {\\n            return (int) (number + 1);\\n        } else {\\n            return (int) number;\\n        }\\n    }\\n}\\n\"",
    "circular convolution f f t": "\"package com.thealgorithms.maths;\\n\\nimport java.util.ArrayList;\\n\\n/**\\n * Class for circular convolution of two discrete signals using the convolution\\n * theorem.\\n *\\n * @author Ioannis Karavitsis\\n * @version 1.0\\n */\\npublic class CircularConvolutionFFT {\\n\\n    /**\\n     * This method pads the signal with zeros until it reaches the new size.\\n     *\\n     * @param x The signal to be padded.\\n     * @param newSize The new size of the signal.\\n     */\\n    private static void padding(ArrayList<FFT.Complex> x, int newSize) {\\n        if (x.size() < newSize) {\\n            int diff = newSize - x.size();\\n            for (int i = 0; i < diff; i++) {\\n                x.add(new FFT.Complex());\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Discrete circular convolution function. It uses the convolution theorem\\n     * for discrete signals: convolved = IDFT(DFT(a)*DFT(b)). Then we use the\\n     * FFT algorithm for faster calculations of the two DFTs and the final IDFT.\\n     *\\n     * <p>\\n     * More info: https://en.wikipedia.org/wiki/Convolution_theorem\\n     *\\n     * @param a The first signal.\\n     * @param b The other signal.\\n     * @return The convolved signal.\\n     */\\n    public static ArrayList<FFT.Complex> fftCircularConvolution(\\n            ArrayList<FFT.Complex> a, ArrayList<FFT.Complex> b) {\\n        int convolvedSize\\n                = Math.max(\\n                        a.size(), b.size()); // The two signals must have the same size equal to the bigger one\\n        padding(a, convolvedSize); // Zero padding the smaller signal\\n        padding(b, convolvedSize);\\n\\n        /* Find the FFTs of both signal. Here we use the Bluestein algorithm because we want the FFT to have the same length with the signal and not bigger */\\n        FFTBluestein.fftBluestein(a, false);\\n        FFTBluestein.fftBluestein(b, false);\\n        ArrayList<FFT.Complex> convolved = new ArrayList<>();\\n\\n        for (int i = 0; i < a.size(); i++) {\\n            convolved.add(a.get(i).multiply(b.get(i))); // FFT(a)*FFT(b)\\n        }\\n        FFTBluestein.fftBluestein(convolved, true); // IFFT\\n\\n        return convolved;\\n    }\\n}\\n\"",
    "combinations": "\"package com.thealgorithms.maths;\\n\\n/**\\n * @see <a href=\\\"https://en.wikipedia.org/wiki/Combination\\\">Combination</a>\\n */\\npublic class Combinations {\\n\\n    public static void main(String[] args) {\\n        assert combinations(1, 1) == 1;\\n        assert combinations(10, 5) == 252;\\n        assert combinations(6, 3) == 20;\\n        assert combinations(20, 5) == 15504;\\n\\n        // Since, 200 is a big number its factorial will go beyond limits of long even when 200C5 can be saved in a long\\n        // variable. So below will fail\\n        // assert combinations(200, 5) == 2535650040l;\\n        assert combinationsOptimized(100, 0) == 1;\\n        assert combinationsOptimized(1, 1) == 1;\\n        assert combinationsOptimized(10, 5) == 252;\\n        assert combinationsOptimized(6, 3) == 20;\\n        assert combinationsOptimized(20, 5) == 15504;\\n        assert combinationsOptimized(200, 5) == 2535650040l;\\n    }\\n\\n    /**\\n     * Calculate of factorial\\n     *\\n     * @param n the number\\n     * @return factorial of given number\\n     */\\n    public static long factorial(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\\\"number is negative\\\");\\n        }\\n        return n == 0 || n == 1 ? 1 : n * factorial(n - 1);\\n    }\\n\\n    /**\\n     * Calculate combinations\\n     *\\n     * @param n first number\\n     * @param k second number\\n     * @return combinations of given {@code n} and {@code k}\\n     */\\n    public static long combinations(int n, int k) {\\n        return factorial(n) / (factorial(k) * factorial(n - k));\\n    }\\n\\n    /**\\n     * The above method can exceed limit of long (overflow) when factorial(n) is\\n     * larger than limits of long variable. Thus even if nCk is within range of\\n     * long variable above reason can lead to incorrect result. This is an\\n     * optimized version of computing combinations. Observations: nC(k + 1) = (n\\n     * - k) * nCk / (k + 1) We know the value of nCk when k = 1 which is nCk = n\\n     * Using this base value and above formula we can compute the next term\\n     * nC(k+1)\\n     *\\n     * @param n\\n     * @param k\\n     * @return nCk\\n     */\\n    public static long combinationsOptimized(int n, int k) {\\n        if (n < 0 || k < 0) {\\n            throw new IllegalArgumentException(\\\"n or k can't be negative\\\");\\n        }\\n        if (n < k) {\\n            throw new IllegalArgumentException(\\\"n can't be smaller than k\\\");\\n        }\\n        // nC0 is always 1\\n        long solution = 1;\\n        for (int i = 0; i < k; i++) {\\n            long next = (n - i) * solution / (i + 1);\\n            solution = next;\\n        }\\n        return solution;\\n    }\\n}\\n\"",
    "convolution": "\"package com.thealgorithms.maths;\\n\\n/**\\n * Class for linear convolution of two discrete signals\\n *\\n * @author Ioannis Karavitsis\\n * @version 1.0\\n */\\npublic class Convolution {\\n\\n    /**\\n     * Discrete linear convolution function. Both input signals and the output\\n     * signal must start from 0. If you have a signal that has values before 0\\n     * then shift it to start from 0.\\n     *\\n     * @param A The first discrete signal\\n     * @param B The second discrete signal\\n     * @return The convolved signal\\n     */\\n    public static double[] convolution(double[] A, double[] B) {\\n        double[] convolved = new double[A.length + B.length - 1];\\n\\n        /*\\n    The discrete convolution of two signals A and B is defined as:\\n\\n          A.length\\n    C[i] = Σ (A[k]*B[i-k])\\n          k=0\\n\\n    It's obvious that:  0 <= k <= A.length , 0 <= i <= A.length + B.length - 2  and  0 <= i-k <= B.length - 1\\n    From the last inequality we get that:  i - B.length + 1 <= k <= i and thus we get the conditions below.\\n         */\\n        for (int i = 0; i < convolved.length; i++) {\\n            convolved[i] = 0;\\n            int k = Math.max(i - B.length + 1, 0);\\n\\n            while (k < i + 1 && k < A.length) {\\n                convolved[i] += A[k] * B[i - k];\\n                k++;\\n            }\\n        }\\n\\n        return convolved;\\n    }\\n}\\n\"",
    "convolution f f t": "\"package com.thealgorithms.maths;\\n\\nimport java.util.ArrayList;\\n\\n/**\\n * Class for linear convolution of two discrete signals using the convolution\\n * theorem.\\n *\\n * @author Ioannis Karavitsis\\n * @version 1.0\\n */\\npublic class ConvolutionFFT {\\n\\n    /**\\n     * This method pads the signal with zeros until it reaches the new size.\\n     *\\n     * @param x The signal to be padded.\\n     * @param newSize The new size of the signal.\\n     */\\n    private static void padding(ArrayList<FFT.Complex> x, int newSize) {\\n        if (x.size() < newSize) {\\n            int diff = newSize - x.size();\\n            for (int i = 0; i < diff; i++) {\\n                x.add(new FFT.Complex());\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Discrete linear convolution function. It uses the convolution theorem for\\n     * discrete signals convolved: = IDFT(DFT(a)*DFT(b)). This is true for\\n     * circular convolution. In order to get the linear convolution of the two\\n     * signals we first pad the two signals to have the same size equal to the\\n     * convolved signal (a.size() + b.size() - 1). Then we use the FFT algorithm\\n     * for faster calculations of the two DFTs and the final IDFT.\\n     *\\n     * <p>\\n     * More info: https://en.wikipedia.org/wiki/Convolution_theorem\\n     * https://ccrma.stanford.edu/~jos/ReviewFourier/FFT_Convolution.html\\n     *\\n     * @param a The first signal.\\n     * @param b The other signal.\\n     * @return The convolved signal.\\n     */\\n    public static ArrayList<FFT.Complex> convolutionFFT(\\n            ArrayList<FFT.Complex> a, ArrayList<FFT.Complex> b) {\\n        int convolvedSize = a.size() + b.size() - 1; // The size of the convolved signal\\n        padding(a, convolvedSize); // Zero padding both signals\\n        padding(b, convolvedSize);\\n\\n        /* Find the FFTs of both signals (Note that the size of the FFTs will be bigger than the convolvedSize because of the extra zero padding in FFT algorithm) */\\n        FFT.fft(a, false);\\n        FFT.fft(b, false);\\n        ArrayList<FFT.Complex> convolved = new ArrayList<>();\\n\\n        for (int i = 0; i < a.size(); i++) {\\n            convolved.add(a.get(i).multiply(b.get(i))); // FFT(a)*FFT(b)\\n        }\\n        FFT.fft(convolved, true); // IFFT\\n        convolved\\n                .subList(convolvedSize, convolved.size())\\n                .clear(); // Remove the remaining zeros after the convolvedSize. These extra zeros came from\\n        // paddingPowerOfTwo() method inside the fft() method.\\n\\n        return convolved;\\n    }\\n}\\n\"",
    "determinant of matrix": "\"package com.thealgorithms.maths;\\n\\nimport java.util.*;\\n\\n/* \\n* @author Ojasva Jain\\n* Determinant of Matrix Wikipedia link : https://en.wikipedia.org/wiki/Determinant\\n */\\npublic class DeterminantOfMatrix {\\n\\n    // Determinant calculator\\n    //@return determinant of the input matrix\\n    static int determinant(int a[][], int n) {\\n        int det = 0, sign = 1, p = 0, q = 0;\\n        if (n == 1) {\\n            det = a[0][0];\\n        } else {\\n            int b[][] = new int[n - 1][n - 1];\\n            for (int x = 0; x < n; x++) {\\n                p = 0;\\n                q = 0;\\n                for (int i = 1; i < n; i++) {\\n                    for (int j = 0; j < n; j++) {\\n                        if (j != x) {\\n                            b[p][q++] = a[i][j];\\n                            if (q % (n - 1) == 0) {\\n                                p++;\\n                                q = 0;\\n                            }\\n                        }\\n                    }\\n                }\\n                det = det + a[0][x] * determinant(b, n - 1) * sign;\\n                sign = -sign;\\n            }\\n        }\\n        return det;\\n    }\\n\\n    //Driver Method\\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in);\\n        //Input Matrix\\n        System.out.println(\\\"Enter matrix size (Square matrix only)\\\");\\n        int n = in.nextInt();\\n        System.out.println(\\\"Enter matrix\\\");\\n        int a[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                a[i][j] = in.nextInt();\\n            }\\n        }\\n        System.out.println(determinant(a, n));\\n    }\\n}\\n\"",
    "digital root": "\"/** Author : Suraj Kumar Modi\\n * https://github.com/skmodi649\\n */\\n/** You are given a number n. You need to find the digital root of n.\\n * DigitalRoot of a number is the recursive sum of its digits until we get a single digit number.\\n *\\n * Test Case 1:\\n * Input:\\n * n = 1\\n * Output:  1\\n * Explanation: Digital root of 1 is 1\\n *\\n * Test Case 2:\\n * Input:\\n * n = 99999\\n * Output: 9\\n * Explanation: Sum of digits of 99999 is 45\\n * which is not a single digit number, hence\\n * sum of digit of 45 is 9 which is a single\\n * digit number.\\n */\\n/** Algorithm :\\n * Step 1 : Define a method digitalRoot(int n)\\n * Step 2 : Define another method single(int n)\\n * Step 3 : digitalRoot(int n) method takes output of single(int n) as input\\n * if(single(int n) <= 9)\\n * return single(n)\\n * else\\n * return digitalRoot(single(n))\\n * Step 4 : single(int n) calculates the sum of digits of number n recursively\\n * if(n<=9)\\n * return n;\\n * else\\n * return (n%10) + (n/10)\\n * Step 5 : In main method simply take n as input and then call digitalRoot(int n) function and print the result\\n */\\npackage com.thealgorithms.maths;\\n\\nimport java.util.*;\\n\\nclass DigitalRoot {\\n\\n    public static int digitalRoot(int n) {\\n        if (single(n) <= 9) // If n is already single digit than simply call single method and return the value\\n        {\\n            return single(n);\\n        } else {\\n            return digitalRoot(single(n));\\n        }\\n    }\\n\\n    // This function is used for finding the sum of digits of number\\n    public static int single(int n) {\\n        if (n <= 9) // if n becomes less than 10 than return n\\n        {\\n            return n;\\n        } else {\\n            return (n % 10) + single(n / 10);                     // n % 10 for extracting digits one by one\\n        }\\n    }                                                             // n / 10 is the number obtainded after removing the digit one by one  \\n    // Sum of digits is stored in the Stack memory and then finally returned\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.println(\\\"Enter the number : \\\");\\n        int n = sc.nextInt();                                     // Taking a number as input from the user\\n        System.out.println(\\\"Digital Root : \\\" + digitalRoot(n));     // Printing the value returned by digitalRoot() method\\n    }\\n}\\n\\n/**\\n * Time Complexity : O((Number of Digits)^2) Auxiliary Space Complexity :\\n * O(Number of Digits) Constraints : 1 <= n <= 10^7\\n */\\n\"",
    "dudeney number": "\"/**\\n * A number is said to be Dudeney if the sum of the digits, is the cube root of the entered number.\\n * Example- Let the number be 512, its sum of digits is 5+1+2=8. The cube root of 512 is also 8.\\n *          Since, the sum of the digits is equal to the cube root of the entered number;\\n *          it is a Dudeney Number.\\n */\\npackage com.thealgorithms.maths;\\n\\nimport java.io.*;\\n\\npublic class DudeneyNumber {\\n\\n    //returns True if the number is a Dudeney number and False if it is not a Dudeney number.\\n    public static boolean isDudeney(int n) {\\n        // Calculating Cube Root\\n        int cube_root = (int) (Math.round((Math.pow(n, 1.0 / 3.0))));\\n        // If the number is not a perfect cube the method returns false.\\n        if (cube_root * cube_root * cube_root != n) {\\n            return false;\\n        }\\n        int sum_of_digits = 0;// Stores the sums of the digit of the entered number\\n        int temp = n;//A temporary variable to store the entered number\\n        // Loop to calculate sum of the digits.\\n        while (temp > 0) {\\n\\n            // Extracting Last digit of the number\\n            int rem = temp % 10;\\n\\n            // Calculating sum of digits.\\n            sum_of_digits += rem;\\n\\n            // Removing the last digit\\n            temp /= 10;\\n        }\\n\\n        //If the cube root of the number is not equal to the sum of its digits we return false.  \\n        if (cube_root != sum_of_digits) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Method to check if number is Dudeney Number or Not 1) Input - Enter a\\n     * Number: 512 Output - It is a Dudeney Number. 2) Input - Enter a Number:\\n     * 125 Output - It is not a Dudeney Number.\\n     */\\n    public static void main(String args[]) throws IOException {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        System.out.println(\\\"Enter a Number: \\\");\\n        int n = Integer.parseInt(br.readLine());\\n        if (isDudeney(n)) {\\n            System.out.println(\\\"It is a Dudeney Number.\\\");\\n        } else {\\n            System.out.println(\\\"It is not a Dudeney Number.\\\");\\n        }\\n    }\\n}\\n\"",
    "euler method": "\"package com.thealgorithms.maths;\\n\\nimport java.util.ArrayList;\\nimport java.util.function.BiFunction;\\n\\n/**\\n * In mathematics and computational science, the Euler method (also called\\n * forward Euler method) is a first-order numerical procedure for solving\\n * ordinary differential equations (ODEs) with a given initial value. It is the\\n * most basic explicit method for numerical integration of ordinary differential\\n * equations. The method proceeds in a series of steps. At each step the y-value\\n * is calculated by evaluating the differential equation at the previous step,\\n * multiplying the result with the step-size and adding it to the last y-value:\\n * y_n+1 = y_n + stepSize * f(x_n, y_n). (description adapted from\\n * https://en.wikipedia.org/wiki/Euler_method ) (see also:\\n * https://www.geeksforgeeks.org/euler-method-solving-differential-equation/ )\\n */\\npublic class EulerMethod {\\n\\n    /**\\n     * Illustrates how the algorithm is used in 3 examples and prints the\\n     * results to the console.\\n     */\\n    public static void main(String[] args) {\\n        System.out.println(\\\"example 1:\\\");\\n        BiFunction<Double, Double, Double> exampleEquation1 = (x, y) -> x;\\n        ArrayList<double[]> points1 = eulerFull(0, 4, 0.1, 0, exampleEquation1);\\n        assert points1.get(points1.size() - 1)[1] == 7.800000000000003;\\n        points1.forEach(\\n                point -> System.out.println(String.format(\\\"x: %1$f; y: %2$f\\\", point[0], point[1])));\\n\\n        // example from https://en.wikipedia.org/wiki/Euler_method\\n        System.out.println(\\\"\\\\n\\\\nexample 2:\\\");\\n        BiFunction<Double, Double, Double> exampleEquation2 = (x, y) -> y;\\n        ArrayList<double[]> points2 = eulerFull(0, 4, 0.1, 1, exampleEquation2);\\n        assert points2.get(points2.size() - 1)[1] == 45.25925556817596;\\n        points2.forEach(\\n                point -> System.out.println(String.format(\\\"x: %1$f; y: %2$f\\\", point[0], point[1])));\\n\\n        // example from https://www.geeksforgeeks.org/euler-method-solving-differential-equation/\\n        System.out.println(\\\"\\\\n\\\\nexample 3:\\\");\\n        BiFunction<Double, Double, Double> exampleEquation3 = (x, y) -> x + y + x * y;\\n        ArrayList<double[]> points3 = eulerFull(0, 0.1, 0.025, 1, exampleEquation3);\\n        assert points3.get(points3.size() - 1)[1] == 1.1116729841674804;\\n        points3.forEach(\\n                point -> System.out.println(String.format(\\\"x: %1$f; y: %2$f\\\", point[0], point[1])));\\n    }\\n\\n    /**\\n     * calculates the next y-value based on the current value of x, y and the\\n     * stepSize the console.\\n     *\\n     * @param xCurrent Current x-value.\\n     * @param stepSize Step-size on the x-axis.\\n     * @param yCurrent Current y-value.\\n     * @param differentialEquation The differential equation to be solved.\\n     * @return The next y-value.\\n     */\\n    public static double eulerStep(\\n            double xCurrent,\\n            double stepSize,\\n            double yCurrent,\\n            BiFunction<Double, Double, Double> differentialEquation) {\\n        if (stepSize <= 0) {\\n            throw new IllegalArgumentException(\\\"stepSize should be greater than zero\\\");\\n        }\\n        double yNext = yCurrent + stepSize * differentialEquation.apply(xCurrent, yCurrent);\\n        return yNext;\\n    }\\n\\n    /**\\n     * Loops through all the steps until xEnd is reached, adds a point for each\\n     * step and then returns all the points\\n     *\\n     * @param xStart First x-value.\\n     * @param xEnd Last x-value.\\n     * @param stepSize Step-size on the x-axis.\\n     * @param yStart First y-value.\\n     * @param differentialEquation The differential equation to be solved.\\n     * @return The points constituting the solution of the differential\\n     * equation.\\n     */\\n    public static ArrayList<double[]> eulerFull(\\n            double xStart,\\n            double xEnd,\\n            double stepSize,\\n            double yStart,\\n            BiFunction<Double, Double, Double> differentialEquation) {\\n        if (xStart >= xEnd) {\\n            throw new IllegalArgumentException(\\\"xEnd should be greater than xStart\\\");\\n        }\\n        if (stepSize <= 0) {\\n            throw new IllegalArgumentException(\\\"stepSize should be greater than zero\\\");\\n        }\\n\\n        ArrayList<double[]> points = new ArrayList<double[]>();\\n        double[] firstPoint = {xStart, yStart};\\n        points.add(firstPoint);\\n        double yCurrent = yStart;\\n        double xCurrent = xStart;\\n\\n        while (xCurrent < xEnd) {\\n            // Euler method for next step\\n            yCurrent = eulerStep(xCurrent, stepSize, yCurrent, differentialEquation);\\n            xCurrent += stepSize;\\n            double[] point = {xCurrent, yCurrent};\\n            points.add(point);\\n        }\\n\\n        return points;\\n    }\\n}\\n\"",
    "factorial": "\"package com.thealgorithms.maths;\\n\\npublic class Factorial {\\n\\n    /* Driver Code */\\n    public static void main(String[] args) {\\n        assert factorial(0) == 1;\\n        assert factorial(1) == 1;\\n        assert factorial(5) == 120;\\n        assert factorial(10) == 3628800;\\n    }\\n\\n    /**\\n     * Calculate factorial N using iteration\\n     *\\n     * @param n the number\\n     * @return the factorial of {@code n}\\n     */\\n    public static long factorial(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\\\"number is negative\\\");\\n        }\\n        long factorial = 1;\\n        for (int i = 1; i <= n; factorial *= i, ++i)\\n      ;\\n        return factorial;\\n    }\\n}\\n\"",
    "factorial recursion": "\"package com.thealgorithms.maths;\\n\\npublic class FactorialRecursion {\\n\\n    /* Driver Code */\\n    public static void main(String[] args) {\\n        assert factorial(0) == 1;\\n        assert factorial(1) == 1;\\n        assert factorial(2) == 2;\\n        assert factorial(3) == 6;\\n        assert factorial(5) == 120;\\n    }\\n\\n    /**\\n     * Recursive FactorialRecursion Method\\n     *\\n     * @param n The number to factorial\\n     * @return The factorial of the number\\n     */\\n    public static long factorial(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\\\"number is negative\\\");\\n        }\\n        return n == 0 || n == 1 ? 1 : n * factorial(n - 1);\\n    }\\n}\\n\"",
    "f f t": "\"package com.thealgorithms.maths;\\n\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\n\\n/**\\n * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal\\n * using the Cooley-Tukey algorithm.\\n *\\n * @author Ioannis Karavitsis\\n * @version 1.0\\n */\\npublic class FFT {\\n\\n    /**\\n     * This class represents a complex number and has methods for basic\\n     * operations.\\n     *\\n     * <p>\\n     * More info:\\n     * https://introcs.cs.princeton.edu/java/32class/Complex.java.html\\n     */\\n    static class Complex {\\n\\n        private double real, img;\\n\\n        /**\\n         * Default Constructor. Creates the complex number 0.\\n         */\\n        public Complex() {\\n            real = 0;\\n            img = 0;\\n        }\\n\\n        /**\\n         * Constructor. Creates a complex number.\\n         *\\n         * @param r The real part of the number.\\n         * @param i The imaginary part of the number.\\n         */\\n        public Complex(double r, double i) {\\n            real = r;\\n            img = i;\\n        }\\n\\n        /**\\n         * Returns the real part of the complex number.\\n         *\\n         * @return The real part of the complex number.\\n         */\\n        public double getReal() {\\n            return real;\\n        }\\n\\n        /**\\n         * Returns the imaginary part of the complex number.\\n         *\\n         * @return The imaginary part of the complex number.\\n         */\\n        public double getImaginary() {\\n            return img;\\n        }\\n\\n        /**\\n         * Adds this complex number to another.\\n         *\\n         * @param z The number to be added.\\n         * @return The sum.\\n         */\\n        public Complex add(Complex z) {\\n            Complex temp = new Complex();\\n            temp.real = this.real + z.real;\\n            temp.img = this.img + z.img;\\n            return temp;\\n        }\\n\\n        /**\\n         * Subtracts a number from this complex number.\\n         *\\n         * @param z The number to be subtracted.\\n         * @return The difference.\\n         */\\n        public Complex subtract(Complex z) {\\n            Complex temp = new Complex();\\n            temp.real = this.real - z.real;\\n            temp.img = this.img - z.img;\\n            return temp;\\n        }\\n\\n        /**\\n         * Multiplies this complex number by another.\\n         *\\n         * @param z The number to be multiplied.\\n         * @return The product.\\n         */\\n        public Complex multiply(Complex z) {\\n            Complex temp = new Complex();\\n            temp.real = this.real * z.real - this.img * z.img;\\n            temp.img = this.real * z.img + this.img * z.real;\\n            return temp;\\n        }\\n\\n        /**\\n         * Multiplies this complex number by a scalar.\\n         *\\n         * @param n The real number to be multiplied.\\n         * @return The product.\\n         */\\n        public Complex multiply(double n) {\\n            Complex temp = new Complex();\\n            temp.real = this.real * n;\\n            temp.img = this.img * n;\\n            return temp;\\n        }\\n\\n        /**\\n         * Finds the conjugate of this complex number.\\n         *\\n         * @return The conjugate.\\n         */\\n        public Complex conjugate() {\\n            Complex temp = new Complex();\\n            temp.real = this.real;\\n            temp.img = -this.img;\\n            return temp;\\n        }\\n\\n        /**\\n         * Finds the magnitude of the complex number.\\n         *\\n         * @return The magnitude.\\n         */\\n        public double abs() {\\n            return Math.hypot(this.real, this.img);\\n        }\\n\\n        /**\\n         * Divides this complex number by another.\\n         *\\n         * @param z The divisor.\\n         * @return The quotient.\\n         */\\n        public Complex divide(Complex z) {\\n            Complex temp = new Complex();\\n            temp.real = (this.real * z.real + this.img * z.img) / (z.abs() * z.abs());\\n            temp.img = (this.img * z.real - this.real * z.img) / (z.abs() * z.abs());\\n            return temp;\\n        }\\n\\n        /**\\n         * Divides this complex number by a scalar.\\n         *\\n         * @param n The divisor which is a real number.\\n         * @return The quotient.\\n         */\\n        public Complex divide(double n) {\\n            Complex temp = new Complex();\\n            temp.real = this.real / n;\\n            temp.img = this.img / n;\\n            return temp;\\n        }\\n    }\\n\\n    /**\\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\\n     * it isn't then it is padded with zeros and the output FFT will be bigger\\n     * than the input signal.\\n     *\\n     * <p>\\n     * More info:\\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\\n     * https://cp-algorithms.com/algebra/fft.html\\n     *\\n     * @param x The discrete signal which is then converted to the FFT or the\\n     * IFFT of signal x.\\n     * @param inverse True if you want to find the inverse FFT.\\n     */\\n    public static void fft(ArrayList<Complex> x, boolean inverse) {\\n        /* Pad the signal with zeros if necessary */\\n        paddingPowerOfTwo(x);\\n        int N = x.size();\\n\\n        /* Find the log2(N) */\\n        int log2N = 0;\\n        while ((1 << log2N) < N) {\\n            log2N++;\\n        }\\n\\n        /* Swap the values of the signal with bit-reversal method */\\n        int reverse;\\n        for (int i = 0; i < N; i++) {\\n            reverse = reverseBits(i, log2N);\\n            if (i < reverse) {\\n                Collections.swap(x, i, reverse);\\n            }\\n        }\\n\\n        int direction = inverse ? -1 : 1;\\n\\n        /* Main loop of the algorithm */\\n        for (int len = 2; len <= N; len *= 2) {\\n            double angle = -2 * Math.PI / len * direction;\\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\\n            for (int i = 0; i < N; i += len) {\\n                Complex w = new Complex(1, 0);\\n                for (int j = 0; j < len / 2; j++) {\\n                    Complex u = x.get(i + j);\\n                    Complex v = w.multiply(x.get(i + j + len / 2));\\n                    x.set(i + j, u.add(v));\\n                    x.set(i + j + len / 2, u.subtract(v));\\n                    w = w.multiply(wlen);\\n                }\\n            }\\n        }\\n\\n        /* Divide by N if we want the inverse FFT */\\n        if (inverse) {\\n            for (int i = 0; i < x.size(); i++) {\\n                Complex z = x.get(i);\\n                x.set(i, z.divide(N));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * This function reverses the bits of a number. It is used in Cooley-Tukey\\n     * FFT algorithm.\\n     *\\n     * <p>\\n     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =\\n     * 10110000 in binary\\n     *\\n     * <p>\\n     * More info: https://cp-algorithms.com/algebra/fft.html\\n     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/\\n     *\\n     * @param num The integer you want to reverse its bits.\\n     * @param log2N The number of bits you want to reverse.\\n     * @return The reversed number\\n     */\\n    private static int reverseBits(int num, int log2N) {\\n        int reversed = 0;\\n        for (int i = 0; i < log2N; i++) {\\n            if ((num & (1 << i)) != 0) {\\n                reversed |= 1 << (log2N - 1 - i);\\n            }\\n        }\\n        return reversed;\\n    }\\n\\n    /**\\n     * This method pads an ArrayList with zeros in order to have a size equal to\\n     * the next power of two of the previous size.\\n     *\\n     * @param x The ArrayList to be padded.\\n     */\\n    private static void paddingPowerOfTwo(ArrayList<Complex> x) {\\n        int n = 1;\\n        int oldSize = x.size();\\n        while (n < oldSize) {\\n            n *= 2;\\n        }\\n        for (int i = 0; i < n - oldSize; i++) {\\n            x.add(new Complex());\\n        }\\n    }\\n}\\n\"",
    "f f t bluestein": "\"package com.thealgorithms.maths;\\n\\nimport java.util.ArrayList;\\n\\n/**\\n * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal\\n * using the Bluestein's algorithm.\\n *\\n * @author Ioannis Karavitsis\\n * @version 1.0\\n */\\npublic class FFTBluestein {\\n\\n    /**\\n     * Bluestein's FFT Algorithm.\\n     *\\n     * <p>\\n     * More info:\\n     * https://en.wikipedia.org/wiki/Chirp_Z-transform#Bluestein.27s_algorithm\\n     * http://tka4.org/materials/lib/Articles-Books/Numerical%20Algorithms/Hartley_Trasform/Bluestein%27s%20FFT%20algorithm%20-%20Wikipedia,%20the%20free%20encyclopedia.htm\\n     *\\n     * @param x The discrete signal which is then converted to the FFT or the\\n     * IFFT of signal x.\\n     * @param inverse True if you want to find the inverse FFT.\\n     */\\n    public static void fftBluestein(ArrayList<FFT.Complex> x, boolean inverse) {\\n        int N = x.size();\\n        int bnSize = 2 * N - 1;\\n        int direction = inverse ? -1 : 1;\\n        ArrayList<FFT.Complex> an = new ArrayList<>();\\n        ArrayList<FFT.Complex> bn = new ArrayList<>();\\n\\n        /* Initialization of the b(n) sequence (see Wikipedia's article above for the symbols used)*/\\n        for (int i = 0; i < bnSize; i++) {\\n            bn.add(new FFT.Complex());\\n        }\\n\\n        for (int i = 0; i < N; i++) {\\n            double angle = (i - N + 1) * (i - N + 1) * Math.PI / N * direction;\\n            bn.set(i, new FFT.Complex(Math.cos(angle), Math.sin(angle)));\\n            bn.set(bnSize - i - 1, new FFT.Complex(Math.cos(angle), Math.sin(angle)));\\n        }\\n\\n        /* Initialization of the a(n) sequence */\\n        for (int i = 0; i < N; i++) {\\n            double angle = -i * i * Math.PI / N * direction;\\n            an.add(x.get(i).multiply(new FFT.Complex(Math.cos(angle), Math.sin(angle))));\\n        }\\n\\n        ArrayList<FFT.Complex> convolution = ConvolutionFFT.convolutionFFT(an, bn);\\n\\n        /* The final multiplication of the convolution with the b*(k) factor  */\\n        for (int i = 0; i < N; i++) {\\n            double angle = -1 * i * i * Math.PI / N * direction;\\n            FFT.Complex bk = new FFT.Complex(Math.cos(angle), Math.sin(angle));\\n            x.set(i, bk.multiply(convolution.get(i + N - 1)));\\n        }\\n\\n        /* Divide by N if we want the inverse FFT */\\n        if (inverse) {\\n            for (int i = 0; i < N; i++) {\\n                FFT.Complex z = x.get(i);\\n                x.set(i, z.divide(N));\\n            }\\n        }\\n    }\\n}\\n\"",
    "fibonacci java streams": "\"package com.thealgorithms.maths;\\n\\nimport java.math.BigDecimal;\\nimport java.util.List;\\nimport java.util.Objects;\\nimport java.util.Optional;\\nimport java.util.stream.Stream;\\n\\n/**\\n * @author: caos321\\n * @date: 14 October 2021 (Thursday)\\n */\\npublic class FibonacciJavaStreams {\\n\\n    public static Optional<BigDecimal> calculate(final BigDecimal index) {\\n        if (index == null || index.compareTo(BigDecimal.ZERO) < 0) {\\n            return Optional.empty();\\n        }\\n\\n        if (index.compareTo(BigDecimal.ONE) < 0) {\\n            return Optional.of(BigDecimal.ZERO);\\n        }\\n\\n        if (index.compareTo(new BigDecimal(2)) < 0) {\\n            return Optional.of(BigDecimal.ONE);\\n        }\\n\\n        final List<BigDecimal> results = Stream.iterate(\\n                index,\\n                x -> x.compareTo(BigDecimal.ZERO) > 0,\\n                x -> x.subtract(BigDecimal.ONE)\\n        )\\n                .reduce(\\n                        List.of(),\\n                        (list, current)\\n                        -> list.isEmpty() || list.size() < 2\\n                        ? List.of(BigDecimal.ZERO, BigDecimal.ONE)\\n                        : List.of(list.get(1), list.get(0).add(list.get(1))),\\n                        (list1, list2) -> list1\\n                );\\n\\n        return results.isEmpty()\\n                ? Optional.empty()\\n                : Optional.of(results.get(results.size() - 1));\\n    }\\n\\n    public static void assertThat(final Object actual, final Object expected) {\\n        if (!Objects.equals(actual, expected)) {\\n            throw new AssertionError(String.format(\\\"expected=%s but was actual=%s\\\", expected, actual));\\n        }\\n    }\\n\\n    public static void main(final String[] args) {\\n        {\\n            final Optional<BigDecimal> result = calculate(new BigDecimal(-1));\\n            assertThat(result.isEmpty(), true);\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(BigDecimal.ZERO);\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, BigDecimal.ZERO));\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(BigDecimal.ONE);\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, BigDecimal.ONE));\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(new BigDecimal(2));\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, BigDecimal.ONE));\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(new BigDecimal(3));\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, new BigDecimal(2)));\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(new BigDecimal(10));\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, new BigDecimal(55)));\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(new BigDecimal(20));\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, new BigDecimal(6765)));\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(new BigDecimal(30));\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, new BigDecimal(832040)));\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(new BigDecimal(40));\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, new BigDecimal(102334155)));\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(new BigDecimal(50));\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, new BigDecimal(12586269025L)));\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(new BigDecimal(100));\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, new BigDecimal(\\\"354224848179261915075\\\")));\\n        }\\n        {\\n            final Optional<BigDecimal> result = calculate(new BigDecimal(200));\\n            assertThat(result.isPresent(), true);\\n            result.ifPresent(value -> assertThat(value, new BigDecimal(\\\"280571172992510140037611932413038677189525\\\")));\\n        }\\n    }\\n}\\n\"",
    "fibonacci number": "\"package com.thealgorithms.maths;\\n\\n/**\\n * Fibonacci: 0 1 1 2 3 5 8 13 21 ...\\n */\\npublic class FibonacciNumber {\\n\\n    public static void main(String[] args) {\\n        assert isFibonacciNumber(1);\\n        assert isFibonacciNumber(2);\\n        assert isFibonacciNumber(21);\\n        assert !isFibonacciNumber(9);\\n        assert !isFibonacciNumber(10);\\n    }\\n\\n    /**\\n     * Check if a number is perfect square number\\n     *\\n     * @param number the number to be checked\\n     * @return <tt>true</tt> if {@code number} is perfect square, otherwise\\n     * <tt>false</tt>\\n     */\\n    public static boolean isPerfectSquare(int number) {\\n        int sqrt = (int) Math.sqrt(number);\\n        return sqrt * sqrt == number;\\n    }\\n\\n    /**\\n     * Check if a number is fibonacci number This is true if and only if at\\n     * least one of 5x^2+4 or 5x^2-4 is a perfect square\\n     *\\n     * @param number the number\\n     * @return <tt>true</tt> if {@code number} is fibonacci number, otherwise\\n     * <tt>false</tt>\\n     * @link https://en.wikipedia.org/wiki/Fibonacci_number#Identification\\n     */\\n    public static boolean isFibonacciNumber(int number) {\\n        return isPerfectSquare(5 * number * number + 4) || isPerfectSquare(5 * number * number - 4);\\n    }\\n}\\n\"",
    "find max": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\n\\npublic class FindMax {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        Random random = new Random();\\n\\n        /* random size */\\n        int size = random.nextInt(100) + 1;\\n        int[] array = new int[size];\\n\\n        /* init array with random numbers */\\n        for (int i = 0; i < size; i++) {\\n            array[i] = random.nextInt() % 100;\\n        }\\n\\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\\n    }\\n\\n    /**\\n     * find max of array\\n     *\\n     * @param array the array contains element\\n     * @return max value of given array\\n     */\\n    public static int findMax(int[] array) {\\n        int max = array[0];\\n        for (int i = 1; i < array.length; ++i) {\\n            if (array[i] > max) {\\n                max = array[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\"",
    "find max recursion": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\n\\npublic class FindMaxRecursion {\\n\\n    public static void main(String[] args) {\\n        Random rand = new Random();\\n\\n        /* rand size */\\n        int size = rand.nextInt(100) + 1;\\n        int[] array = new int[size];\\n\\n        /* init array with rand numbers */\\n        for (int i = 0; i < size; i++) {\\n            array[i] = rand.nextInt() % 100;\\n        }\\n\\n        assert max(array, array.length) == Arrays.stream(array).max().getAsInt();\\n        assert max(array, 0, array.length - 1) == Arrays.stream(array).max().getAsInt();\\n    }\\n\\n    /**\\n     * Get max of array using divide and conquer algorithm\\n     *\\n     * @param array contains elements\\n     * @param low the index of the first element\\n     * @param high the index of the last element\\n     * @return max of {@code array}\\n     */\\n    public static int max(int[] array, int low, int high) {\\n        if (low == high) {\\n            return array[low]; // or array[high]\\n        }\\n\\n        int mid = (low + high) >>> 1;\\n\\n        int leftMax = max(array, low, mid); // get max in [low, mid]\\n        int rightMax = max(array, mid + 1, high); // get max in [mid+1, high]\\n\\n        return Math.max(leftMax, rightMax);\\n    }\\n\\n    /**\\n     * Get max of array using recursion algorithm\\n     *\\n     * @param array contains elements\\n     * @param len length of given array\\n     * @return max value of {@code array}\\n     */\\n    public static int max(int[] array, int len) {\\n        return len == 1 ? array[0] : Math.max(max(array, len - 1), array[len - 1]);\\n    }\\n}\\n\"",
    "find min": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\n\\npublic class FindMin {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        Random random = new Random();\\n\\n        /* random size */\\n        int size = random.nextInt(100) + 1;\\n        int[] array = new int[size];\\n\\n        /* init array with random numbers */\\n        for (int i = 0; i < size; i++) {\\n            array[i] = random.nextInt() % 100;\\n        }\\n\\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\\n    }\\n\\n    /**\\n     * Find the minimum number of an array of numbers.\\n     *\\n     * @param array the array contains element\\n     * @return min value\\n     */\\n    public static int findMin(int[] array) {\\n        int min = array[0];\\n        for (int i = 1; i < array.length; ++i) {\\n            if (array[i] < min) {\\n                min = array[i];\\n            }\\n        }\\n        return min;\\n    }\\n}\\n\"",
    "find min recursion": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\n\\npublic class FindMinRecursion {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        Random rand = new Random();\\n\\n        /* rand size */\\n        int size = rand.nextInt(100) + 1;\\n        int[] array = new int[size];\\n\\n        /* init array with rand numbers */\\n        for (int i = 0; i < size; i++) {\\n            array[i] = rand.nextInt() % 100;\\n        }\\n\\n        assert min(array, 0, array.length - 1) == Arrays.stream(array).min().getAsInt();\\n        assert min(array, array.length) == Arrays.stream(array).min().getAsInt();\\n    }\\n\\n    /**\\n     * Get min of array using divide and conquer algorithm\\n     *\\n     * @param array contains elements\\n     * @param low the index of the first element\\n     * @param high the index of the last element\\n     * @return min of {@code array}\\n     */\\n    public static int min(int[] array, int low, int high) {\\n        if (low == high) {\\n            return array[low]; // or array[high]\\n        }\\n\\n        int mid = (low + high) >>> 1;\\n\\n        int leftMin = min(array, low, mid); // get min in [low, mid]\\n        int rightMin = min(array, mid + 1, high); // get min in [mid+1, high]\\n\\n        return Math.min(leftMin, rightMin);\\n    }\\n\\n    /**\\n     * Get min of array using recursion algorithm\\n     *\\n     * @param array contains elements\\n     * @param len length of given array\\n     * @return min value of {@code array}\\n     */\\n    public static int min(int[] array, int len) {\\n        return len == 1 ? array[0] : Math.min(min(array, len - 1), array[len - 1]);\\n    }\\n}\\n\"",
    "floor": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Random;\\n\\npublic class Floor {\\n\\n    public static void main(String[] args) {\\n        Random random = new Random();\\n        for (int i = 1; i <= 1000; ++i) {\\n            double randomNumber = random.nextDouble();\\n            assert floor(randomNumber) == Math.floor(randomNumber);\\n        }\\n    }\\n\\n    /**\\n     * Returns the largest (closest to positive infinity)\\n     *\\n     * @param number the number\\n     * @return the largest (closest to positive infinity) of given\\n     * {@code number}\\n     */\\n    public static double floor(double number) {\\n        if (number - (int) number == 0) {\\n            return number;\\n        } else if (number - (int) number > 0) {\\n            return (int) number;\\n        } else {\\n            return (int) number - 1;\\n        }\\n    }\\n}\\n\"",
    "gaussian": "\"/**\\n * \\\\file\\n * \\\\brief [Gaussian elimination\\n * method](https://en.wikipedia.org/wiki/Gaussian_elimination)\\n * @author [Sachwin Kohli](https://github.com/Sachwin-Kohli)\\n */\\npackage com.thealgorithms.maths;\\n\\nimport java.util.*;\\n\\n/**\\n * Main function\\n */\\npublic class Gaussian {\\n\\n    public static void main(String[] args) {\\n        int mat_size, i, j, step;\\n        Scanner sc = new Scanner(System.in);\\n\\n        System.out.println(\\\"Matrix Size : \\\");\\n        mat_size = sc.nextInt();\\n\\n        double[][] mat = new double[mat_size + 1][mat_size + 1];\\n        double[][] x = new double[mat_size][mat_size + 1];\\n\\n        System.out.println(\\\"Enter value of the matrix\\\");\\n        System.out.println(' ');\\n        for (i = 0; i < mat_size; i++) {\\n            for (j = 0; j <= mat_size; j++) {\\n                mat[i][j] = sc.nextInt();\\n            }\\n        }\\n\\n        // perform Gaussian elimination\\n        for (step = 0; step < mat_size - 1; step++) {\\n            for (i = step; i < mat_size - 1; i++) {\\n                double a = (mat[i + 1][step] / mat[step][step]);\\n\\n                for (j = step; j <= mat_size; j++) {\\n                    mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]);\\n                }\\n            }\\n        }\\n\\n        System.out.println(\\\"Matrix using Gaussian Elimination method: \\\");\\n        System.out.println(\\\" \\\");\\n        for (i = 0; i < mat_size; i++) {\\n            for (j = 0; j <= mat_size; j++) {\\n                x[i][j] = mat[i][j];\\n                System.out.print(mat[i][j] + \\\" \\\");\\n            }\\n            System.out.println();\\n        }\\n        System.out.println(\\\"Value of the Gaussian Elimination method: \\\");\\n        System.out.println(\\\" \\\");\\n\\n        for (i = mat_size - 1; i >= 0; i--) {\\n            double sum = 0;\\n            for (j = mat_size - 1; j > i; j--) {\\n                x[i][j] = x[j][j] * x[i][j];\\n                sum = x[i][j] + sum;\\n            }\\n            if (x[i][i] == 0) {\\n                x[i][i] = 0;\\n            } else {\\n                x[i][i] = (x[i][mat_size] - sum) / (x[i][i]);\\n            }\\n            System.out.print(\\\"x\\\" + i + \\\"=\\\" + x[i][i]);\\n            System.out.println(\\\" \\\");\\n        }\\n    }\\n}\\n\"",
    "g c d": "\"package com.thealgorithms.maths;\\n\\n/**\\n * This is Euclid's algorithm which is used to find the greatest common\\n * denominator Overide function name gcd\\n *\\n * @author Oskar Enmalm 3/10/17\\n */\\npublic class GCD {\\n\\n    /**\\n     * get greatest common divisor\\n     *\\n     * @param num1 the first number\\n     * @param num2 the second number\\n     * @return gcd\\n     */\\n    public static int gcd(int num1, int num2) {\\n        if (num1 < 0 || num2 < 0) {\\n            throw new ArithmeticException();\\n        }\\n\\n        if (num1 == 0 || num2 == 0) {\\n            return Math.abs(num1 - num2);\\n        }\\n\\n        while (num1 % num2 != 0) {\\n            int remainder = num1 % num2;\\n            num1 = num2;\\n            num2 = remainder;\\n        }\\n        return num2;\\n    }\\n\\n    /**\\n     * get greatest common divisor in array\\n     *\\n     * @param number contains number\\n     * @return gcd\\n     */\\n    public static int gcd(int[] number) {\\n        int result = number[0];\\n        for (int i = 1; i < number.length; i++) // call gcd function (input two value)\\n        {\\n            result = gcd(result, number[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] myIntArray = {4, 16, 32};\\n\\n        // call gcd function (input array)\\n        System.out.println(gcd(myIntArray)); // => 4\\n        System.out.printf(\\\"gcd(40,24)=%d gcd(24,40)=%d%n\\\", gcd(40, 24), gcd(24, 40)); // => 8\\n    }\\n}\\n\"",
    "g c d recursion": "\"package com.thealgorithms.maths;\\n\\n/**\\n * @author https://github.com/shellhub/\\n */\\npublic class GCDRecursion {\\n\\n    public static void main(String[] args) {\\n        System.out.println(gcd(20, 15));\\n        /* output: 5 */\\n        System.out.println(gcd(10, 8));\\n        /* output: 2 */\\n        System.out.println(gcd(gcd(10, 5), gcd(5, 10)));\\n        /* output: 5 */\\n    }\\n\\n    /**\\n     * get greatest common divisor\\n     *\\n     * @param a the first number\\n     * @param b the second number\\n     * @return gcd\\n     */\\n    public static int gcd(int a, int b) {\\n\\n        if (a < 0 || b < 0) {\\n            throw new ArithmeticException();\\n        }\\n\\n        if (a == 0 || b == 0) {\\n            return Math.abs(a - b);\\n        }\\n\\n        if (a % b == 0) {\\n            return b;\\n        } else {\\n            return gcd(b, a % b);\\n        }\\n    }\\n}\\n\"",
    "generic root": "\"package com.thealgorithms.maths;\\n\\n/*\\n * Algorithm explanation: https://technotip.com/6774/c-program-to-find-generic-root-of-a-number/#:~:text=Generic%20Root%3A%20of%20a%20number,get%20a%20single%2Ddigit%20output.&text=For%20Example%3A%20If%20user%20input,%2B%204%20%2B%205%20%3D%2015.\\n */\\npublic class GenericRoot {\\n\\n    public static void main(String[] args) {\\n        int number1 = 1234;\\n        int number2 = 12345;\\n        int result1 = genericRoot(number1);\\n        int result2 = genericRoot(number2);\\n        System.out.println(\\\"Generic root of \\\" + number1 + \\\" is: \\\" + result1);\\n        System.out.println(\\\"Generic root of \\\" + number2 + \\\" is: \\\" + result2);\\n    }\\n\\n    private static int genericRoot(int n) {\\n        int root = 0;\\n        while (n > 0 || root > 9) {\\n            if (n == 0) {\\n                n = root;\\n                root = 0;\\n            }\\n            root += n % 10;\\n            n /= 10;\\n        }\\n        return root;\\n    }\\n}\\n\"",
    "harshad number": "\"// Wikipedia for Harshad Number : https://en.wikipedia.org/wiki/Harshad_number\\npackage com.thealgorithms.maths;\\n\\nimport java.util.Scanner;\\n\\npublic class HarshadNumber {\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.print(\\\"Enter a number : \\\");\\n        long a = sc.nextLong();\\n\\n        checkHarshadNumber(a);\\n    }\\n\\n    /**\\n     * A function to check if a number is Harshad number or not\\n     *\\n     * @param a The number which should be checked\\n     */\\n    public static void checkHarshadNumber(long a) {\\n\\n        long b = a;\\n        int sum = 0;\\n\\n        // this is just for showing the explanation else it's of no use you can ommit it\\n        int[] each = new int[Long.toString(a).length()];\\n\\n        int c = 0;\\n\\n        while (b > 0) {\\n            sum += b % 10;\\n            each[c] = (int) (b % 10);\\n            b /= 10;\\n            c++;\\n        }\\n\\n        if (a % sum == 0) {\\n            System.out.println(a + \\\" is a Harshad Number\\\");\\n\\n            // For you better explanation how is that a Harshad Number\\n            System.out.println(\\\"\\\\nExplaination :\\\");\\n\\n            for (int i = each.length - 1; i >= 0; i--) {\\n                System.out.print(each[i] + \\\" \\\");\\n                if (i != 0) {\\n                    System.out.print(\\\"+ \\\");\\n                }\\n            }\\n\\n            System.out.println(\\\"= \\\" + sum);\\n            System.out.println(sum + \\\" × \\\" + (a / sum) + \\\" = \\\" + a);\\n        } else {\\n            System.out.println(a + \\\" is not a Harshad Number\\\");\\n        }\\n    }\\n}\\n\"",
    "juggler sequence": "\"package com.thealgorithms.maths;\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\n/*\\n * Java program for printing juggler sequence \\n * Wikipedia: https://en.wikipedia.org/wiki/Juggler_sequence\\n * \\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\\n * \\n * */\\n\\npublic class JugglerSequence {\\n    /**\\n     * This method prints juggler sequence starting with the number in the parameter\\n     *\\n     * @param inputNumber Number from which juggler sequence is to be started\\n     */\\n    public static void jugglerSequence(int inputNumber) {\\n        // Copy method argument to a local variable\\n        int n = inputNumber;\\n        List<String> seq = new ArrayList<>();\\n        seq.add(n + \\\"\\\");\\n        // Looping till n reaches 1\\n        while (n != 1) {\\n            int temp;\\n            // if previous term is even then\\n            // next term in the sequence is square root of previous term\\n            // if previous term is odd then\\n            // next term is floor value of 3 time the square root of previous term\\n\\n            // Check if previous term is even or odd\\n            if (n % 2 == 0) {\\n                temp = (int) Math.floor(Math.sqrt(n));\\n            } else {\\n                temp = (int) Math.floor(Math.sqrt(n) * Math.sqrt(n) * Math.sqrt(n));\\n            }\\n            n = temp;\\n            seq.add(n + \\\"\\\");\\n        }\\n        String res = String.join(\\\",\\\", seq);\\n        System.out.println(res);\\n    }\\n\\n    // Driver code\\n    public static void main(String[] args) {\\n        jugglerSequence(3);\\n        // Output: 3,5,11,36,6,2,1\\n    }\\n}\\n\"",
    "keith number": "\"package com.thealgorithms.maths;\\n\\nimport java.util.*;\\n\\nclass KeithNumber {\\n\\n    //user-defined function that checks if the given number is Keith or not  \\n    static boolean isKeith(int x) {\\n        //List stores all the digits of the X  \\n        ArrayList<Integer> terms = new ArrayList<Integer>();\\n        //n denotes the number of digits   \\n        int temp = x, n = 0;\\n        //executes until the condition becomes false  \\n        while (temp > 0) {\\n            //determines the last digit of the number and add it to the List      \\n            terms.add(temp % 10);\\n            //removes the last digit  \\n            temp = temp / 10;\\n            //increments the number of digits (n) by 1  \\n            n++;\\n        }\\n        //reverse the List  \\n        Collections.reverse(terms);\\n        int next_term = 0, i = n;\\n        //finds next term for the series  \\n        //loop executes until the condition returns true  \\n        while (next_term < x) {\\n            next_term = 0;\\n            //next term is the sum of previous n terms (it depends on number of digits the number has)  \\n            for (int j = 1; j <= n; j++) {\\n                next_term = next_term + terms.get(i - j);\\n            }\\n            terms.add(next_term);\\n            i++;\\n        }\\n        //when the control comes out of the while loop, there will be two conditions:  \\n        //either next_term will be equal to x or greater than x  \\n        //if equal, the given number is Keith, else not  \\n        return (next_term == x);\\n    }\\n\\n    //driver code  \\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in);\\n        int n = in.nextInt();\\n        if (isKeith(n)) {\\n            System.out.println(\\\"Yes, the given number is a Keith number.\\\");\\n        } else {\\n            System.out.println(\\\"No, the given number is not a Keith number.\\\");\\n        }\\n    }\\n}\\n\"",
    "krishnamurthy number": "\"package com.thealgorithms.maths;\\n\\n/* This is a program to check if a number is a Krishnamurthy number or not.\\nA number is a Krishnamurthy number if the sum of the factorials of the digits of the number is equal to the number itself.\\nFor example, 1, 2 and 145 are Krishnamurthy numbers.\\nKrishnamurthy number is also referred to as a Strong number.\\n */\\nimport java.io.*;\\n\\npublic class KrishnamurthyNumber {\\n    //returns True if the number is a Krishnamurthy number and False if it is not.\\n\\n    public static boolean isKMurthy(int n) {\\n        //initialising the variable s that will store the sum of the factorials of the digits to 0\\n        int s = 0;\\n        //storing the number n in a temporary variable tmp\\n        int tmp = n;\\n\\n        //Krishnamurthy numbers are positive\\n        if (n <= 0) {\\n            return false;\\n        } //checking if the number is a Krishnamurthy number\\n        else {\\n            while (n != 0) {\\n                //initialising the variable fact that will store the factorials of the digits\\n                int fact = 1;\\n                //computing factorial of each digit\\n                for (int i = 1; i <= n % 10; i++) {\\n                    fact = fact * i;\\n                }\\n                //computing the sum of the factorials\\n                s = s + fact;\\n                //discarding the digit for which factorial has been calculated\\n                n = n / 10;\\n            }\\n\\n            //evaluating if sum of the factorials of the digits equals the number itself\\n            if (tmp == s) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    public static void main(String args[]) throws IOException {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        System.out.println(\\\"Enter a number to check if it is a Krishnamurthy number: \\\");\\n        int n = Integer.parseInt(br.readLine());\\n        if (isKMurthy(n)) {\\n            System.out.println(n + \\\" is a Krishnamurthy number.\\\");\\n        } else {\\n            System.out.println(n + \\\" is NOT a Krishnamurthy number.\\\");\\n        }\\n    }\\n}\\n\"",
    "leonardo number": "\"package com.thealgorithms.maths;\\n\\npublic class LeonardoNumber {\\n\\n    public static int leonardoNumber(int n) {\\n        if (n < 0) {\\n            return 0;\\n        }\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return (leonardoNumber(n - 1) + leonardoNumber(n - 2) + 1);\\n    }\\n\\n    public static void main(String args[]) {\\n        for (int i = 0; i < 20; i++) {\\n            System.out.print(leonardoNumber(i) + \\\" \\\");\\n        }\\n\\n    }\\n}\\n\"",
    "linear diophantine equations solver": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Objects;\\n\\npublic final class LinearDiophantineEquationsSolver {\\n\\n    public static void main(String[] args) {\\n        // 3x + 4y = 7\\n        final var toSolve = new Equation(3, 4, 7);\\n        System.out.println(findAnySolution(toSolve));\\n    }\\n\\n    public static Solution findAnySolution(final Equation equation) {\\n        if (equation.a() == 0 && equation.b() == 0 && equation.c() == 0) {\\n            return Solution.INFINITE_SOLUTIONS;\\n        }\\n        final var stub = new GcdSolutionWrapper(0, new Solution(0, 0));\\n        final var gcdSolution = gcd(equation.a(), equation.b(), stub);\\n        if (equation.c() % gcdSolution.getGcd() != 0) {\\n            return Solution.NO_SOLUTION;\\n        }\\n        final var toReturn = new Solution(0, 0);\\n        var xToSet = stub.getSolution().getX() * (equation.c() / stub.getGcd());\\n        var yToSet = stub.getSolution().getY() * (equation.c() / stub.getGcd());\\n        toReturn.setX(xToSet);\\n        toReturn.setY(yToSet);\\n        return toReturn;\\n    }\\n\\n    private static GcdSolutionWrapper gcd(final int a, final int b, final GcdSolutionWrapper previous) {\\n        if (b == 0) {\\n            return new GcdSolutionWrapper(a, new Solution(1, 0));\\n        }\\n        // stub wrapper becomes the `previous` of the next recursive call\\n        final var stubWrapper = new GcdSolutionWrapper(0, new Solution(0, 0));\\n        final var next = /* recursive call */ gcd(b, a % b, stubWrapper);\\n        previous.getSolution().setX(next.getSolution().getY());\\n        previous.getSolution().setY(next.getSolution().getX() - (a / b) * (next.getSolution().getY()));\\n        previous.setGcd(next.getGcd());\\n        return new GcdSolutionWrapper(next.getGcd(), previous.getSolution());\\n    }\\n\\n    public static final class Solution {\\n\\n        public static final Solution NO_SOLUTION = new Solution(Integer.MAX_VALUE, Integer.MAX_VALUE);\\n        public static final Solution INFINITE_SOLUTIONS = new Solution(Integer.MIN_VALUE, Integer.MIN_VALUE);\\n        private int x;\\n        private int y;\\n\\n        public Solution(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public int getX() {\\n            return x;\\n        }\\n\\n        public int getY() {\\n            return y;\\n        }\\n\\n        public void setX(int x) {\\n            this.x = x;\\n        }\\n\\n        public void setY(int y) {\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (obj == this) {\\n                return true;\\n            }\\n            if (obj == null || obj.getClass() != this.getClass()) {\\n                return false;\\n            }\\n            var that = (Solution) obj;\\n            return this.x == that.x\\n                    && this.y == that.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \\\"Solution[\\\"\\n                    + \\\"x=\\\" + x + \\\", \\\"\\n                    + \\\"y=\\\" + y + ']';\\n        }\\n\\n    }\\n\\n    public record Equation(int a, int b, int c) {\\n\\n    }\\n\\n    public static final class GcdSolutionWrapper {\\n\\n        private int gcd;\\n        private Solution solution;\\n\\n        public GcdSolutionWrapper(int gcd, Solution solution) {\\n            this.gcd = gcd;\\n            this.solution = solution;\\n        }\\n\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (obj == this) {\\n                return true;\\n            }\\n            if (obj == null || obj.getClass() != this.getClass()) {\\n                return false;\\n            }\\n            var that = (GcdSolutionWrapper) obj;\\n            return this.gcd == that.gcd\\n                    && Objects.equals(this.solution, that.solution);\\n        }\\n\\n        public int getGcd() {\\n            return gcd;\\n        }\\n\\n        public void setGcd(int gcd) {\\n            this.gcd = gcd;\\n        }\\n\\n        public Solution getSolution() {\\n            return solution;\\n        }\\n\\n        public void setSolution(Solution solution) {\\n            this.solution = solution;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(gcd, solution);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \\\"GcdSolutionWrapper[\\\"\\n                    + \\\"gcd=\\\" + gcd + \\\", \\\"\\n                    + \\\"solution=\\\" + solution + ']';\\n        }\\n\\n    }\\n}\\n\"",
    "lucas series": "\"package com.thealgorithms.maths;\\n\\n/**\\n * https://en.wikipedia.org/wiki/Lucas_number\\n */\\npublic class LucasSeries {\\n\\n    public static void main(String[] args) {\\n        assert lucasSeries(1) == 2 && lucasSeriesIteration(1) == 2;\\n        assert lucasSeries(2) == 1 && lucasSeriesIteration(2) == 1;\\n        assert lucasSeries(3) == 3 && lucasSeriesIteration(3) == 3;\\n        assert lucasSeries(4) == 4 && lucasSeriesIteration(4) == 4;\\n        assert lucasSeries(5) == 7 && lucasSeriesIteration(5) == 7;\\n        assert lucasSeries(6) == 11 && lucasSeriesIteration(6) == 11;\\n        assert lucasSeries(11) == 123 && lucasSeriesIteration(11) == 123;\\n    }\\n\\n    /**\\n     * Calculate nth number of lucas series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,\\n     * 123, ....) using recursion\\n     *\\n     * @param n nth\\n     * @return nth number of lucas series\\n     */\\n    public static int lucasSeries(int n) {\\n        return n == 1 ? 2 : n == 2 ? 1 : lucasSeries(n - 1) + lucasSeries(n - 2);\\n    }\\n\\n    /**\\n     * Calculate nth number of lucas series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,\\n     * 123, ....) using iteration\\n     *\\n     * @param n nth\\n     * @return nth number of lucas series\\n     */\\n    public static int lucasSeriesIteration(int n) {\\n        int previous = 2;\\n        int current = 1;\\n        for (int i = 1; i < n; i++) {\\n            int next = previous + current;\\n            previous = current;\\n            current = next;\\n        }\\n        return previous;\\n    }\\n}\\n\"",
    "magic square": "\"package com.thealgorithms.maths;\\n\\nimport java.util.*;\\n\\n/*A magic square of order n is an arrangement of distinct n^2 integers,in a square, such that the n numbers in all\\nrows, all columns, and both diagonals sum to the same constant. A magic square contains the integers from 1 to n^2.*/\\npublic class MagicSquare {\\n\\n    public static void main(String[] args) {\\n\\n        Scanner sc = new Scanner(System.in);\\n        System.out.print(\\\"Input a number: \\\");\\n        int num = sc.nextInt();\\n        if ((num % 2 == 0) || (num <= 0)) {\\n            System.out.print(\\\"Input number must be odd and >0\\\");\\n            System.exit(0);\\n        }\\n\\n        int[][] magic_square = new int[num][num];\\n\\n        int row_num = num / 2;\\n        int col_num = num - 1;\\n        magic_square[row_num][col_num] = 1;\\n\\n        for (int i = 2; i <= num * num; i++) {\\n            if (magic_square[(row_num - 1 + num) % num][(col_num + 1) % num] == 0) {\\n                row_num = (row_num - 1 + num) % num;\\n                col_num = (col_num + 1) % num;\\n            } else {\\n                col_num = (col_num - 1 + num) % num;\\n            }\\n            magic_square[row_num][col_num] = i;\\n        }\\n\\n        // print the square\\n        for (int i = 0; i < num; i++) {\\n            for (int j = 0; j < num; j++) {\\n                if (magic_square[i][j] < 10) {\\n                    System.out.print(\\\" \\\");\\n                }\\n                if (magic_square[i][j] < 100) {\\n                    System.out.print(\\\" \\\");\\n                }\\n                System.out.print(magic_square[i][j] + \\\" \\\");\\n            }\\n            System.out.println();\\n        }\\n\\n    }\\n}\\n\"",
    "matrix util": "\"package com.thealgorithms.maths;\\n\\nimport java.math.BigDecimal;\\nimport java.util.Arrays;\\nimport java.util.Objects;\\nimport java.util.Optional;\\nimport java.util.function.BiFunction;\\nimport java.util.stream.IntStream;\\n\\n/**\\n * @author: caos321\\n * @date: 31 October 2021 (Sunday)\\n */\\npublic class MatrixUtil {\\n\\n    public static boolean isValid(final BigDecimal[][] matrix) {\\n        return matrix != null && matrix.length > 0 && matrix[0].length > 0;\\n    }\\n\\n    public static boolean hasEqualSizes(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {\\n        return isValid(matrix1) && isValid(matrix2)\\n                && matrix1.length == matrix2.length\\n                && matrix1[0].length == matrix2[0].length;\\n    }\\n\\n    public static boolean canMultiply(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {\\n        return isValid(matrix1) && isValid(matrix2)\\n                && matrix1[0].length == matrix2.length;\\n    }\\n\\n    public static Optional<BigDecimal[][]> operate(final BigDecimal[][] matrix1,\\n            final BigDecimal[][] matrix2,\\n            final BiFunction<BigDecimal, BigDecimal, BigDecimal> operation) {\\n        if (!hasEqualSizes(matrix1, matrix2)) {\\n            return Optional.empty();\\n        }\\n\\n        final int rowSize = matrix1.length;\\n        final int columnSize = matrix1[0].length;\\n\\n        final BigDecimal[][] result = new BigDecimal[rowSize][columnSize];\\n\\n        IntStream.range(0, rowSize).forEach(rowIndex\\n                -> IntStream.range(0, columnSize).forEach(columnIndex -> {\\n                    final BigDecimal value1 = matrix1[rowIndex][columnIndex];\\n                    final BigDecimal value2 = matrix2[rowIndex][columnIndex];\\n\\n                    result[rowIndex][columnIndex] = operation.apply(value1, value2);\\n                }));\\n\\n        return Optional.of(result);\\n    }\\n\\n    public static Optional<BigDecimal[][]> add(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {\\n        return operate(matrix1, matrix2, BigDecimal::add);\\n    }\\n\\n    public static Optional<BigDecimal[][]> subtract(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {\\n        return operate(matrix1, matrix2, BigDecimal::subtract);\\n    }\\n\\n    public static Optional<BigDecimal[][]> multiply(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {\\n        if (!canMultiply(matrix1, matrix2)) {\\n            return Optional.empty();\\n        }\\n\\n        final int size = matrix1[0].length;\\n\\n        final int matrix1RowSize = matrix1.length;\\n        final int matrix2ColumnSize = matrix2[0].length;\\n\\n        final BigDecimal[][] result = new BigDecimal[matrix1RowSize][matrix2ColumnSize];\\n\\n        IntStream.range(0, matrix1RowSize).forEach(rowIndex\\n                -> IntStream.range(0, matrix2ColumnSize).forEach(columnIndex\\n                        -> result[rowIndex][columnIndex] = IntStream.range(0, size).mapToObj(index -> {\\n                    final BigDecimal value1 = matrix1[rowIndex][index];\\n                    final BigDecimal value2 = matrix2[index][columnIndex];\\n\\n                    return value1.multiply(value2);\\n                })\\n                        .reduce(BigDecimal.ZERO, BigDecimal::add)\\n                )\\n        );\\n\\n        return Optional.of(result);\\n    }\\n\\n    public static void assertThat(final BigDecimal[][] actual, final BigDecimal[][] expected) {\\n        if (!Objects.deepEquals(actual, expected)) {\\n            throw new AssertionError(String.format(\\n                    \\\"expected=%s but was actual=%s\\\",\\n                    Arrays.deepToString(expected),\\n                    Arrays.deepToString(actual)\\n            ));\\n        }\\n    }\\n\\n    public static void main(final String[] args) {\\n        {\\n            final BigDecimal[][] matrix1 = {\\n                {new BigDecimal(3), new BigDecimal(2)},\\n                {new BigDecimal(0), new BigDecimal(1)},};\\n\\n            final BigDecimal[][] matrix2 = {\\n                {new BigDecimal(1), new BigDecimal(3)},\\n                {new BigDecimal(2), new BigDecimal(0)},};\\n\\n            final BigDecimal[][] actual = add(matrix1, matrix2)\\n                    .orElseThrow(() -> new AssertionError(\\\"Could not compute matrix!\\\"));\\n\\n            final BigDecimal[][] expected = {\\n                {new BigDecimal(4), new BigDecimal(5)},\\n                {new BigDecimal(2), new BigDecimal(1)}\\n            };\\n\\n            assertThat(actual, expected);\\n        }\\n\\n        {\\n            final BigDecimal[][] matrix1 = {\\n                {new BigDecimal(1), new BigDecimal(4)},\\n                {new BigDecimal(5), new BigDecimal(6)},};\\n\\n            final BigDecimal[][] matrix2 = {\\n                {new BigDecimal(2), new BigDecimal(0)},\\n                {new BigDecimal(-2), new BigDecimal(-3)},};\\n\\n            final BigDecimal[][] actual = subtract(matrix1, matrix2)\\n                    .orElseThrow(() -> new AssertionError(\\\"Could not compute matrix!\\\"));\\n\\n            final BigDecimal[][] expected = {\\n                {new BigDecimal(-1), new BigDecimal(4)},\\n                {new BigDecimal(7), new BigDecimal(9)}\\n            };\\n\\n            assertThat(actual, expected);\\n        }\\n\\n        {\\n            final BigDecimal[][] matrix1 = {\\n                {new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)},\\n                {new BigDecimal(4), new BigDecimal(5), new BigDecimal(6)},\\n                {new BigDecimal(7), new BigDecimal(8), new BigDecimal(9)}\\n            };\\n\\n            final BigDecimal[][] matrix2 = {\\n                {new BigDecimal(1), new BigDecimal(2)},\\n                {new BigDecimal(3), new BigDecimal(4)},\\n                {new BigDecimal(5), new BigDecimal(6)}\\n            };\\n\\n            final BigDecimal[][] actual = multiply(matrix1, matrix2)\\n                    .orElseThrow(() -> new AssertionError(\\\"Could not compute matrix!\\\"));\\n\\n            final BigDecimal[][] expected = {\\n                {new BigDecimal(22), new BigDecimal(28)},\\n                {new BigDecimal(49), new BigDecimal(64)},\\n                {new BigDecimal(76), new BigDecimal(100)}\\n            };\\n\\n            assertThat(actual, expected);\\n        }\\n    }\\n}\\n\"",
    "max value": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Random;\\n\\npublic class MaxValue {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        Random rand = new Random();\\n\\n        /* test 100 times using rand numbers */\\n        for (int i = 1; i <= 100; ++i) {\\n            /* generate number from -50 to 49 */\\n            int a = rand.nextInt(100) - 50;\\n            int b = rand.nextInt(100) - 50;\\n            assert max(a, b) == Math.max(a, b);\\n        }\\n    }\\n\\n    /**\\n     * Returns the greater of two {@code int} values. That is, the result is the\\n     * argument closer to the value of {@link Integer#MAX_VALUE}. If the\\n     * arguments have the same value, the result is that same value.\\n     *\\n     * @param a an argument.\\n     * @param b another argument.\\n     * @return the larger of {@code a} and {@code b}.\\n     */\\n    public static int max(int a, int b) {\\n        return a >= b ? a : b;\\n    }\\n}\\n\"",
    "median": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Arrays;\\n\\n/**\\n * Wikipedia: https://en.wikipedia.org/wiki/Median\\n */\\npublic class Median {\\n\\n    public static void main(String[] args) {\\n        assert median(new int[]{0}) == 0;\\n        assert median(new int[]{1, 2}) == 1.5;\\n        assert median(new int[]{4, 1, 3, 2}) == 2.5;\\n        assert median(new int[]{1, 3, 3, 6, 7, 8, 9}) == 6;\\n        assert median(new int[]{1, 2, 3, 4, 5, 6, 8, 9}) == 4.5;\\n    }\\n\\n    /**\\n     * Calculate average median\\n     *\\n     * @param values number series\\n     * @return median of given {@code values}\\n     */\\n    public static double median(int[] values) {\\n        Arrays.sort(values);\\n        int length = values.length;\\n        return length % 2 == 0\\n                ? (values[length / 2] + values[length / 2 - 1]) / 2.0\\n                : values[length / 2];\\n    }\\n}\\n\"",
    "min value": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Random;\\n\\npublic class MinValue {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        Random rand = new Random();\\n\\n        /* test 100 times using rand numbers */\\n        for (int i = 1; i <= 100; ++i) {\\n            /* generate number from -50 to 49 */\\n            int a = rand.nextInt(100) - 50;\\n            int b = rand.nextInt(100) - 50;\\n            assert min(a, b) == Math.min(a, b);\\n        }\\n    }\\n\\n    /**\\n     * Returns the smaller of two {@code int} values. That is, the result the\\n     * argument closer to the value of {@link Integer#MIN_VALUE}. If the\\n     * arguments have the same value, the result is that same value.\\n     *\\n     * @param a an argument.\\n     * @param b another argument.\\n     * @return the smaller of {@code a} and {@code b}.\\n     */\\n    public static int min(int a, int b) {\\n        return a <= b ? a : b;\\n    }\\n}\\n\"",
    "mode": "\"package com.thealgorithms.maths;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.HashMap;\\n\\n/*\\n * Find the mode of an array of numbers\\n *\\n * The mode of an array of numbers is the most frequently occurring number in the array,\\n * or the most frequently occurring numbers if there are multiple numbers with the same frequency\\n */\\npublic class Mode {\\n\\n    public static void main(String[] args) {\\n\\n        /* Test array of integers */\\n        assert (mode(new int[]{})) == null;\\n        assert Arrays.equals(mode(new int[]{5}), new int[]{5});\\n        assert Arrays.equals(mode(new int[]{1, 2, 3, 4, 5}), new int[]{1, 2, 3, 4, 5});\\n        assert Arrays.equals(mode(new int[]{7, 9, 9, 4, 5, 6, 7, 7, 8}), new int[]{7});\\n        assert Arrays.equals(mode(new int[]{7, 9, 9, 4, 5, 6, 7, 7, 9}), new int[]{7, 9});\\n    }\\n\\n    /*\\n   * Find the mode of an array of integers\\n   *\\n   * @param numbers array of integers\\n   * @return mode of the array\\n     */\\n    public static int[] mode(int[] numbers) {\\n\\n        if (numbers.length == 0) {\\n            return null;\\n        }\\n\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n\\n        for (int num : numbers) {\\n            if (count.containsKey(num)) {\\n\\n                count.put(num, count.get(num) + 1);\\n\\n            } else {\\n\\n                count.put(num, 1);\\n            }\\n        }\\n\\n        int max = Collections.max(count.values());\\n        ArrayList<Integer> modes = new ArrayList<>();\\n\\n        for (int num : count.keySet()) {\\n            if (count.get(num) == max) {\\n                modes.add(num);\\n            }\\n        }\\n        return modes.stream().mapToInt(n -> n).toArray();\\n    }\\n}\\n\"",
    "non repeating element": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Scanner;\\n\\n/*\\n * Find the 2 elements which are non repeating in an array\\n * Reason to use bitwise operator: It makes our program faster as we are operating on bits and not on\\n * actual numbers.  \\n */\\npublic class NonRepeatingElement {\\n\\n    public static void main(String[] args) {\\n\\n        Scanner sc = new Scanner(System.in);\\n        int i, res = 0;\\n        System.out.println(\\\"Enter the number of elements in the array\\\");\\n        int n = sc.nextInt();\\n        if ((n & 1) == 1) {\\n            //Not allowing odd number of elements as we are expecting 2 non repeating numbers\\n            System.out.println(\\\"Array should contain even number of elements\\\");\\n            return;\\n        }\\n        int arr[] = new int[n];\\n\\n        System.out.println(\\\"Enter \\\" + n + \\\" elements in the array. NOTE: Only 2 elements should not repeat\\\");\\n        for (i = 0; i < n; i++) {\\n            arr[i] = sc.nextInt();\\n        }\\n\\n        try {\\n            sc.close();\\n        } catch (Exception e) {\\n            System.out.println(\\\"Unable to close scanner\\\" + e);\\n        }\\n\\n        //Find XOR of the 2 non repeating elements\\n        for (i = 0; i < n; i++) {\\n            res ^= arr[i];\\n        }\\n\\n        //Finding the rightmost set bit\\n        res = res & (-res);\\n        int num1 = 0, num2 = 0;\\n\\n        for (i = 0; i < n; i++) {\\n            if ((res & arr[i]) > 0)//Case 1 explained below\\n            {\\n                num1 ^= arr[i];\\n            } else {\\n                num2 ^= arr[i];//Case 2 explained below\\n            }\\n        }\\n\\n        System.out.println(\\\"The two non repeating elements are \\\" + num1 + \\\" and \\\" + num2);\\n\\n    }\\n\\n    /* \\n  Explanation of the code:\\n  let us assume we have an array [1,2,1,2,3,4]\\n  Property of XOR: num ^ num = 0. \\n  If we XOR all the elemnets of the array we will be left with 3 ^ 4 as 1 ^ 1 and 2 ^ 2 would give 0.\\n  Our task is to find num1 and num2 from the result of 3 ^ 4 = 7.\\n  We need to find two's complement of 7 and find the rightmost set bit. i.e. (num & (-num))\\n  Two's complement of 7 is 001 and hence res = 1.\\n  There can be 2 options when we Bitise AND this res with all the elements in our array\\n  1. Result will come non zero number\\n  2. Result will be 0.\\n  In the first case we will XOR our element with the first number (which is initially 0)\\n  In the second case we will XOR our element with the second number(which is initially 0)\\n  This is how we will get non repeating elements with the help of bitwise operators. \\n     */\\n}\\n\"",
    "nth ugly number": "\"// Ugly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, … shows the first 11 ugly numbers.\\n// By convention, 1 is included.\\n// A program to find the nth Ugly number\\n// Algorithm :\\n// Initialize three-pointers two, three, and five pointing to zero.\\n// Take 3 variables nm2, nm3, and nm5 to keep track of next multiple of 2,3 and 5.\\n// Make an array of size n to store the ugly numbers with 1 at 0th index.\\n// Initialize a variable next which stores the value of the last element in the array.\\n// Run a loop n-1 times and perform steps 6,7 and 8.\\n// Update the values of nm2, nm3, nm5 as ugly[two]*2, ugly[three]*3, ugly[5]*5 respectively.\\n// Select the minimum value from nm2, nm3, and nm5 and increment the pointer related to it.\\n// Store the minimum value in variable next and array.\\n// Return next.\\npackage com.thealgorithms.maths;\\n\\nimport java.util.*;\\n\\nclass NthUglyNumber {\\n\\n    /* Function to get the nth ugly number*/\\n    public long getNthUglyNo(int n) {\\n        long[] ugly = new long[n];\\n        int two = 0, three = 0, five = 0;\\n        long nm2 = 2, nm3 = 3, nm5 = 5;\\n        long next = 1;\\n\\n        ugly[0] = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            next = Math.min(nm2, Math.min(nm3, nm5));\\n\\n            ugly[i] = next;\\n            if (next == nm2) {\\n                two = two + 1;\\n                nm2 = ugly[two] * 2;\\n            }\\n            if (next == nm3) {\\n                three = three + 1;\\n                nm3 = ugly[three] * 3;\\n            }\\n            if (next == nm5) {\\n                five = five + 1;\\n                nm5 = ugly[five] * 5;\\n            }\\n        }\\n        return next;\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.println(\\\"Enter the value of n : \\\");\\n        int n = sc.nextInt();\\n        NthUglyNumber ob = new NthUglyNumber();\\n        long ugly = ob.getNthUglyNo(n);\\n        System.out.println(\\\"nth Ugly number is : \\\" + ugly);\\n    }\\n}\\n\"",
    "number of digits": "\"package com.thealgorithms.maths;\\n\\n/**\\n * Find the number of digits in a number.\\n */\\npublic class NumberOfDigits {\\n\\n    public static void main(String[] args) {\\n        int[] numbers = {0, 12, 123, 1234, -12345, 123456, 1234567, 12345678, 123456789};\\n        for (int i = 0; i < numbers.length; ++i) {\\n            assert numberOfDigits(numbers[i]) == i + 1;\\n            assert numberOfDigitsFast(numbers[i]) == i + 1;\\n            assert numberOfDigitsFaster(numbers[i]) == i + 1;\\n            assert numberOfDigitsRecursion(numbers[i]) == i + 1;\\n        }\\n    }\\n\\n    /**\\n     * Find the number of digits in a number.\\n     *\\n     * @param number number to find\\n     * @return number of digits of given number\\n     */\\n    private static int numberOfDigits(int number) {\\n        int digits = 0;\\n        do {\\n            digits++;\\n            number /= 10;\\n        } while (number != 0);\\n        return digits;\\n    }\\n\\n    /**\\n     * Find the number of digits in a number fast version.\\n     *\\n     * @param number number to find\\n     * @return number of digits of given number\\n     */\\n    private static int numberOfDigitsFast(int number) {\\n        return number == 0 ? 1 : (int) Math.floor(Math.log10(Math.abs(number)) + 1);\\n    }\\n\\n    /**\\n     * Find the number of digits in a number faster version.\\n     *\\n     * @param number number to find\\n     * @return number of digits of given number\\n     */\\n    private static int numberOfDigitsFaster(int number) {\\n        return number < 0 ? (-number + \\\"\\\").length() : (number + \\\"\\\").length();\\n    }\\n\\n    /**\\n     * Find the number of digits in a number using recursion.\\n     *\\n     * @param number number to find\\n     * @return number of digits of given number\\n     */\\n    private static int numberOfDigitsRecursion(int number) {\\n        return number / 10 == 0 ? 1 : 1 + numberOfDigitsRecursion(number / 10);\\n    }\\n}\\n\"",
    "palindrome number": "\"package com.thealgorithms.maths;\\n\\npublic class PalindromeNumber {\\n\\n    public static void main(String[] args) {\\n\\n        assert isPalindrome(12321);\\n        assert !isPalindrome(1234);\\n        assert isPalindrome(1);\\n    }\\n\\n    /**\\n     * Check if {@code n} is palindrome number or not\\n     *\\n     * @param number the number\\n     * @return {@code true} if {@code n} is palindrome number, otherwise\\n     * {@code false}\\n     */\\n    public static boolean isPalindrome(int number) {\\n        if (number < 0) {\\n            throw new IllegalArgumentException(number + \\\"\\\");\\n        }\\n        int numberCopy = number;\\n        int reverseNumber = 0;\\n        while (numberCopy != 0) {\\n            int remainder = numberCopy % 10;\\n            reverseNumber = reverseNumber * 10 + remainder;\\n            numberCopy /= 10;\\n        }\\n        return number == reverseNumber;\\n    }\\n}\\n\"",
    "parse integer": "\"package com.thealgorithms.maths;\\n\\npublic class ParseInteger {\\n\\n    public static void main(String[] args) {\\n        assert parseInt(\\\"123\\\") == Integer.parseInt(\\\"123\\\");\\n        assert parseInt(\\\"-123\\\") == Integer.parseInt(\\\"-123\\\");\\n        assert parseInt(\\\"0123\\\") == Integer.parseInt(\\\"0123\\\");\\n        assert parseInt(\\\"+123\\\") == Integer.parseInt(\\\"+123\\\");\\n    }\\n\\n    /**\\n     * Parse a string to integer\\n     *\\n     * @param s the string\\n     * @return the integer value represented by the argument in decimal.\\n     * @throws NumberFormatException if the {@code string} does not contain a\\n     * parsable integer.\\n     */\\n    public static int parseInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            throw new NumberFormatException(\\\"null\\\");\\n        }\\n        boolean isNegative = s.charAt(0) == '-';\\n        boolean isPositive = s.charAt(0) == '+';\\n        int number = 0;\\n        for (int i = isNegative ? 1 : isPositive ? 1 : 0, length = s.length(); i < length; ++i) {\\n            if (!Character.isDigit(s.charAt(i))) {\\n                throw new NumberFormatException(\\\"s=\\\" + s);\\n            }\\n            number = number * 10 + s.charAt(i) - '0';\\n        }\\n        return isNegative ? -number : number;\\n    }\\n}\\n\"",
    "perfect cube": "\"package com.thealgorithms.maths;\\n\\n/**\\n * https://en.wikipedia.org/wiki/Cube_(algebra)\\n */\\npublic class PerfectCube {\\n\\n    public static void main(String[] args) {\\n        assert !isPerfectCube(-1);\\n        assert isPerfectCube(0);\\n        assert isPerfectCube(1);\\n        assert !isPerfectCube(4);\\n        assert isPerfectCube(8);\\n        assert isPerfectCube(27);\\n    }\\n\\n    /**\\n     * Check if a number is perfect cube or not\\n     *\\n     * @param number number to check\\n     * @return {@code true} if {@code number} is perfect cube, otherwise\\n     * {@code false}\\n     */\\n    public static boolean isPerfectCube(int number) {\\n        int a = (int) Math.pow(number, 1.0 / 3);\\n        return a * a * a == number;\\n    }\\n}\\n\"",
    "perfect number": "\"package com.thealgorithms.maths;\\n\\n/**\\n * In number theory, a perfect number is a positive integer that is equal to the\\n * sum of its positive divisors, excluding the number itself. For instance, 6\\n * has divisors 1, 2 and 3 (excluding itself), and 1 + 2 + 3 = 6, so 6 is a\\n * perfect number.\\n *\\n * <p>\\n * link:https://en.wikipedia.org/wiki/Perfect_number\\n */\\npublic class PerfectNumber {\\n\\n    public static void main(String[] args) {\\n        assert isPerfectNumber(6);\\n        /* 1 + 2 + 3 == 6 */\\n        assert !isPerfectNumber(8);\\n        /* 1 + 2 + 4 != 8 */\\n        assert isPerfectNumber(28);\\n        /* 1 + 2 + 4 + 7 + 14 == 28 */\\n    }\\n\\n    /**\\n     * Check if {@code number} is perfect number or not\\n     *\\n     * @param number the number\\n     * @return {@code true} if {@code number} is perfect number, otherwise false\\n     */\\n    public static boolean isPerfectNumber(int number) {\\n        int sum = 0;\\n        /* sum of its positive divisors */\\n        for (int i = 1; i < number; ++i) {\\n            if (number % i == 0) {\\n                sum += i;\\n            }\\n        }\\n        return sum == number;\\n    }\\n}\\n\"",
    "perfect square": "\"package com.thealgorithms.maths;\\n\\n/**\\n * https://en.wikipedia.org/wiki/Perfect_square\\n */\\npublic class PerfectSquare {\\n\\n    public static void main(String[] args) {\\n        assert !isPerfectSquare(-1);\\n        assert !isPerfectSquare(3);\\n        assert !isPerfectSquare(5);\\n        assert isPerfectSquare(9);\\n        assert isPerfectSquare(100);\\n    }\\n\\n    /**\\n     * Check if a number is perfect square number\\n     *\\n     * @param number the number to be checked\\n     * @return <tt>true</tt> if {@code number} is perfect square, otherwise\\n     * <tt>false</tt>\\n     */\\n    public static boolean isPerfectSquare(int number) {\\n        int sqrt = (int) Math.sqrt(number);\\n        return sqrt * sqrt == number;\\n    }\\n}\\n\"",
    "pi nilakantha": "\"package com.thealgorithms.maths;\\n\\npublic class PiNilakantha {\\n\\n    // Calculates Pi using Nilakantha's infinite series\\n    // Method 2 in the following link explains the algorithm\\n    // https://en.scratch-wiki.info/wiki/Calculating_Pi\\n    public static void main(String[] args) {\\n        assert calculatePi(0) == 3.0;\\n        assert calculatePi(10) > 3.0;\\n        assert calculatePi(100) < 4.0;\\n\\n        System.out.println(calculatePi(500));\\n    }\\n\\n    /**\\n     * @param iterations number of times the infinite series gets repeated Pi\\n     * get more accurate the higher the value of iterations is Values from 0 up\\n     * to 500 are allowed since double precision is not sufficient for more than\\n     * about 500 repetitions of this algorithm\\n     * @return the pi value of the calculation with a precision of x iteration\\n     */\\n    public static double calculatePi(int iterations) {\\n        if (iterations < 0 || iterations > 500) {\\n            throw new IllegalArgumentException(\\\"Please input Integer Number between 0 and 500\\\");\\n        }\\n\\n        double pi = 3;\\n        int divCounter = 2;\\n\\n        for (int i = 0; i < iterations; i++) {\\n\\n            if (i % 2 == 0) {\\n                pi = pi + 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2));\\n            } else {\\n                pi = pi - 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2));\\n            }\\n\\n            divCounter += 2;\\n        }\\n        return pi;\\n    }\\n}\\n\"",
    "pow": "\"package com.thealgorithms.maths;\\n\\n// POWER (exponentials) Examples (a^b)\\npublic class Pow {\\n\\n    public static void main(String[] args) {\\n        assert pow(2, 0) == Math.pow(2, 0); // == 1\\n        assert pow(0, 2) == Math.pow(0, 2); // == 0\\n        assert pow(2, 10) == Math.pow(2, 10); // == 1024\\n        assert pow(10, 2) == Math.pow(10, 2); // == 100\\n    }\\n\\n    /**\\n     * Returns the value of the first argument raised to the power of the second\\n     * argument\\n     *\\n     * @param a the base.\\n     * @param b the exponent.\\n     * @return the value {@code a}<sup>{@code b}</sup>.\\n     */\\n    public static long pow(int a, int b) {\\n        long result = 1;\\n        for (int i = 1; i <= b; i++) {\\n            result *= a;\\n        }\\n        return result;\\n    }\\n}\\n\"",
    "power of two or not": "\"package com.thealgorithms.maths;\\n\\n/**\\n * A utility to check if a given number is power of two or not. For example 8,16\\n * etc.\\n */\\npublic class PowerOfTwoOrNot {\\n\\n    public static void main(String[] args) {\\n        assert !checkIfPowerOfTwoOrNot(0);\\n        assert checkIfPowerOfTwoOrNot(1);\\n        assert checkIfPowerOfTwoOrNot(8);\\n        assert checkIfPowerOfTwoOrNot(16);\\n        assert checkIfPowerOfTwoOrNot(1024);\\n    }\\n\\n    /**\\n     * Checks whether given number is power of two or not.\\n     *\\n     * @param number the number to check\\n     * @return {@code true} if given number is power of two, otherwise\\n     * {@code false}\\n     */\\n    public static boolean checkIfPowerOfTwoOrNot(int number) {\\n        return number != 0 && ((number & (number - 1)) == 0);\\n    }\\n}\\n\"",
    "pow recursion": "\"package com.thealgorithms.maths;\\n\\npublic class PowRecursion {\\n\\n    public static void main(String[] args) {\\n        assert Double.compare(pow(2, 0), Math.pow(2, 0)) == 0;\\n        assert Double.compare(pow(0, 2), Math.pow(0, 2)) == 0;\\n        assert Double.compare(pow(2, 10), Math.pow(2, 10)) == 0;\\n        assert Double.compare(pow(10, 2), Math.pow(10, 2)) == 0;\\n    }\\n\\n    /**\\n     * Returns the value of the first argument raised to the power of the second\\n     * argument\\n     *\\n     * @param a the base.\\n     * @param b the exponent.\\n     * @return the value {@code a}<sup>{@code b}</sup>.\\n     */\\n    public static long pow(int a, int b) {\\n        return b == 0 ? 1 : a * pow(a, b - 1);\\n    }\\n}\\n\"",
    "prime check": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Scanner;\\n\\npublic class PrimeCheck {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\\\"Enter a number: \\\");\\n        int n = scanner.nextInt();\\n        if (isPrime(n)) {\\n            System.out.println(n + \\\" is a prime number\\\");\\n        } else {\\n            System.out.println(n + \\\" is not a prime number\\\");\\n        }\\n        scanner.close();\\n    }\\n\\n    /**\\n     * *\\n     * Checks if a number is prime or not\\n     *\\n     * @param n the number\\n     * @return {@code true} if {@code n} is prime\\n     */\\n    public static boolean isPrime(int n) {\\n        if (n == 2) {\\n            return true;\\n        }\\n        if (n < 2 || n % 2 == 0) {\\n            return false;\\n        }\\n        for (int i = 3, limit = (int) Math.sqrt(n); i <= limit; i += 2) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"",
    "prime factorization": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Scanner;\\n\\npublic class PrimeFactorization {\\n\\n    public static void main(String[] args) {\\n        System.out.println(\\\"## all prime factors ##\\\");\\n        Scanner scanner = new Scanner(System.in);\\n        System.out.print(\\\"Enter a number: \\\");\\n        int n = scanner.nextInt();\\n        System.out.print((\\\"printing factors of \\\" + n + \\\" : \\\"));\\n        pfactors(n);\\n        scanner.close();\\n    }\\n\\n    public static void pfactors(int n) {\\n\\n        while (n % 2 == 0) {\\n            System.out.print(2 + \\\" \\\");\\n            n /= 2;\\n        }\\n\\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n            while (n % i == 0) {\\n                System.out.print(i + \\\" \\\");\\n                n /= i;\\n            }\\n        }\\n\\n        if (n > 2) {\\n            System.out.print(n);\\n        }\\n    }\\n}\\n\"",
    "pythagorean triple": "\"package com.thealgorithms.maths;\\n\\n/**\\n * https://en.wikipedia.org/wiki/Pythagorean_triple\\n */\\npublic class PythagoreanTriple {\\n\\n    public static void main(String[] args) {\\n        assert isPythagTriple(3, 4, 5);\\n        assert isPythagTriple(5, 12, 13);\\n        assert isPythagTriple(6, 8, 10);\\n        assert !isPythagTriple(10, 20, 30);\\n        assert !isPythagTriple(6, 8, 100);\\n        assert !isPythagTriple(-1, -1, 1);\\n    }\\n\\n    /**\\n     * Check if a,b,c are a Pythagorean Triple\\n     *\\n     * @param a x/y component length of a right triangle\\n     * @param b y/x component length of a right triangle\\n     * @param c hypotenuse length of a right triangle\\n     * @return boolean <tt>true</tt> if a, b, c satisfy the Pythagorean theorem,\\n     * otherwise\\n     * <tt>false</tt>\\n     */\\n    public static boolean isPythagTriple(int a, int b, int c) {\\n        if (a <= 0 || b <= 0 || c <= 0) {\\n            return false;\\n        } else {\\n            return (a * a) + (b * b) == (c * c);\\n        }\\n    }\\n}\\n\"",
    "reverse number": "\"package com.thealgorithms.maths;\\n\\nimport java.util.Scanner;\\nimport java.util.NoSuchElementException;\\nimport java.lang.IllegalStateException;\\n\\npublic class ReverseNumber {\\n\\n    public static void main(String[] args) {\\n        int number;\\n        int reverse = 0;\\n\\n        try (Scanner sc = new Scanner(System.in)) {\\n            System.out.println(\\\"Enter a number:\\\");\\n            number = sc.nextInt();\\n        } catch (NoSuchElementException | IllegalStateException e) {\\n            System.out.println(\\\"ERROR: Invalid input\\\");\\n            return;\\n        }\\n\\n        while (number != 0) {\\n            int remainder = number % 10;\\n\\n            reverse = reverse * 10 + remainder;\\n            number = number / 10;\\n        }\\n\\n        System.out.println(\\\"The reverse of the given number is: \\\" + reverse);\\n    }\\n}\\n\"",
    "roman numeral util": "\"package com.thealgorithms.maths;\\n\\n/**\\n * Translates numbers into the Roman Numeral System.\\n *\\n * @see <a href=\\\"https://en.wikipedia.org/wiki/Roman_numerals\\\">Roman\\n * numerals</a>\\n * @author Sokratis Fotkatzikis\\n * @version 1.0\\n */\\npublic class RomanNumeralUtil {\\n\\n    private static final int MIN_VALUE = 1;\\n    private static final int MAX_VALUE = 5999;\\n    //1000-5999\\n    private static final String[] RN_M = {\\\"\\\", \\\"M\\\", \\\"MM\\\", \\\"MMM\\\", \\\"MMMM\\\", \\\"MMMMM\\\"};\\n    //100-900\\n    private static final String[] RN_C = {\\\"\\\", \\\"C\\\", \\\"CC\\\", \\\"CCC\\\", \\\"CD\\\", \\\"D\\\", \\\"DC\\\", \\\"DCC\\\", \\\"DCCC\\\", \\\"CM\\\"};\\n    //10-90\\n    private static final String[] RN_X = {\\\"\\\", \\\"X\\\", \\\"XX\\\", \\\"XXX\\\", \\\"XL\\\", \\\"L\\\", \\\"LX\\\", \\\"LXX\\\", \\\"LXXX\\\", \\\"XC\\\"};\\n    //1-9\\n    private static final String[] RN_I = {\\\"\\\", \\\"I\\\", \\\"II\\\", \\\"III\\\", \\\"IV\\\", \\\"V\\\", \\\"VI\\\", \\\"VII\\\", \\\"VIII\\\", \\\"IX\\\"};\\n\\n    public static String generate(int number) {\\n        if (number < MIN_VALUE || number > MAX_VALUE) {\\n            throw new IllegalArgumentException(\\n                    String.format(\\n                            \\\"The number must be in the range [%d, %d]\\\",\\n                            MIN_VALUE,\\n                            MAX_VALUE\\n                    )\\n            );\\n        }\\n\\n        return RN_M[number / 1000]\\n                + RN_C[number % 1000 / 100]\\n                + RN_X[number % 100 / 10]\\n                + RN_I[number % 10];\\n    }\\n}\\n\"",
    "simpson integration": "\"package com.thealgorithms.maths;\\n\\nimport java.util.TreeMap;\\n\\npublic class SimpsonIntegration {\\n\\n    /*\\n     * Calculate definite integrals by using Composite Simpson's rule.\\n     * Wiki: https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule\\n     * Given f a function and an even number N of intervals that divide the integration interval e.g. [a, b],\\n     * we calculate the step h = (b-a)/N and create a table that contains all the x points of\\n     * the real axis xi = x0 + i*h and the value f(xi) that corresponds to these xi.\\n     *\\n     * To evaluate the integral i use the formula below:\\n     * I = h/3 * {f(x0) + 4*f(x1) + 2*f(x2) + 4*f(x3) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}\\n     *\\n     */\\n    public static void main(String[] args) {\\n        SimpsonIntegration integration = new SimpsonIntegration();\\n\\n        // Give random data for the example purposes\\n        int N = 16;\\n        double a = 1;\\n        double b = 3;\\n\\n        // Check so that N is even\\n        if (N % 2 != 0) {\\n            System.out.println(\\\"N must be even number for Simpsons method. Aborted\\\");\\n            System.exit(1);\\n        }\\n\\n        // Calculate step h and evaluate the integral\\n        double h = (b - a) / (double) N;\\n        double integralEvaluation = integration.simpsonsMethod(N, h, a);\\n        System.out.println(\\\"The integral is equal to: \\\" + integralEvaluation);\\n    }\\n\\n    /*\\n     * @param N: Number of intervals (must be even number N=2*k)\\n     * @param h: Step h = (b-a)/N\\n     * @param a: Starting point of the interval\\n     * @param b: Ending point of the interval\\n     *\\n     * The interpolation points xi = x0 + i*h are stored the treeMap data\\n     *\\n     * @return result of the integral evaluation\\n     */\\n    public double simpsonsMethod(int N, double h, double a) {\\n        TreeMap<Integer, Double> data = new TreeMap<>(); // Key: i, Value: f(xi)\\n        double temp;\\n        double xi = a; // Initialize the variable xi = x0 + 0*h\\n\\n        // Create the table of xi and yi points\\n        for (int i = 0; i <= N; i++) {\\n            temp = f(xi); // Get the value of the function at that point\\n            data.put(i, temp);\\n            xi += h; // Increase the xi to the next point\\n        }\\n\\n        // Apply the formula\\n        double integralEvaluation = 0;\\n        for (int i = 0; i < data.size(); i++) {\\n            if (i == 0 || i == data.size() - 1) {\\n                integralEvaluation += data.get(i);\\n                System.out.println(\\\"Multiply f(x\\\" + i + \\\") by 1\\\");\\n            } else if (i % 2 == 1) {\\n                integralEvaluation += (double) 4 * data.get(i);\\n                System.out.println(\\\"Multiply f(x\\\" + i + \\\") by 4\\\");\\n            } else {\\n                integralEvaluation += (double) 2 * data.get(i);\\n                System.out.println(\\\"Multiply f(x\\\" + i + \\\") by 2\\\");\\n            }\\n        }\\n\\n        // Multiply by h/3\\n        integralEvaluation = h / 3 * integralEvaluation;\\n\\n        // Return the result\\n        return integralEvaluation;\\n    }\\n\\n    // Sample function f\\n    // Function f(x) = e^(-x) * (4 - x^2)\\n    public double f(double x) {\\n        return Math.exp(-x) * (4 - Math.pow(x, 2));\\n//        return Math.sqrt(x);\\n    }\\n\\n}\\n\"",
    "sum of arithmetic series": "\"package com.thealgorithms.maths;\\n\\n/**\\n * In mathematics, an arithmetic progression (AP) or arithmetic sequence is a\\n * sequence of numbers such that the difference between the consecutive terms is\\n * constant. Difference here means the second minus the first. For instance, the\\n * sequence 5, 7, 9, 11, 13, 15, . . . is an arithmetic progression with common\\n * difference of 2.\\n *\\n * <p>\\n * Wikipedia: https://en.wikipedia.org/wiki/Arithmetic_progression\\n */\\npublic class SumOfArithmeticSeries {\\n\\n    public static void main(String[] args) {\\n\\n        /* 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 */\\n        assert Double.compare(55.0, sumOfSeries(1, 1, 10)) == 0;\\n\\n        /* 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15 + 17 + 19 */\\n        assert Double.compare(100.0, sumOfSeries(1, 2, 10)) == 0;\\n\\n        /* 1 + 11 + 21 + 31 + 41 + 51 + 61 + 71 + 81 + 91 */\\n        assert Double.compare(460.0, sumOfSeries(1, 10, 10)) == 0;\\n\\n        /* 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 0.6 + 0.7 + 0.8 + 0.9 + 1.0 */\\n        assert Double.compare(5.5, sumOfSeries(0.1, 0.1, 10)) == 0;\\n\\n        assert Double.compare(49600.0, sumOfSeries(1, 10, 100)) == 0;\\n    }\\n\\n    /**\\n     * Calculate sum of arithmetic series\\n     *\\n     * @param firstTerm the initial term of an arithmetic series\\n     * @param commonDiff the common difference of an arithmetic series\\n     * @param numOfTerms the total terms of an arithmetic series\\n     * @return sum of given arithmetic series\\n     */\\n    private static double sumOfSeries(double firstTerm, double commonDiff, int numOfTerms) {\\n        return numOfTerms / 2.0 * (2 * firstTerm + (numOfTerms - 1) * commonDiff);\\n    }\\n}\\n\"",
    "sum of digits": "\"package com.thealgorithms.maths;\\n\\npublic class SumOfDigits {\\n\\n    public static void main(String[] args) {\\n        assert sumOfDigits(-123) == 6 && sumOfDigitsRecursion(-123) == 6 && sumOfDigitsFast(-123) == 6;\\n\\n        assert sumOfDigits(0) == 0 && sumOfDigitsRecursion(0) == 0 && sumOfDigitsFast(0) == 0;\\n\\n        assert sumOfDigits(12345) == 15\\n                && sumOfDigitsRecursion(12345) == 15\\n                && sumOfDigitsFast(12345) == 15;\\n    }\\n\\n    /**\\n     * Calculate the sum of digits of a number\\n     *\\n     * @param number the number contains digits\\n     * @return sum of digits of given {@code number}\\n     */\\n    public static int sumOfDigits(int number) {\\n        number = number < 0 ? -number : number;\\n        /* calculate abs value */\\n        int sum = 0;\\n        while (number != 0) {\\n            sum += number % 10;\\n            number /= 10;\\n        }\\n        return sum;\\n    }\\n\\n    /**\\n     * Calculate the sum of digits of a number using recursion\\n     *\\n     * @param number the number contains digits\\n     * @return sum of digits of given {@code number}\\n     */\\n    public static int sumOfDigitsRecursion(int number) {\\n        number = number < 0 ? -number : number;\\n        /* calculate abs value */\\n        return number < 10 ? number : number % 10 + sumOfDigitsRecursion(number / 10);\\n    }\\n\\n    /**\\n     * Calculate the sum of digits of a number using char array\\n     *\\n     * @param number the number contains digits\\n     * @return sum of digits of given {@code number}\\n     */\\n    public static int sumOfDigitsFast(int number) {\\n        number = number < 0 ? -number : number;\\n        /* calculate abs value */\\n        char[] digits = (number + \\\"\\\").toCharArray();\\n        int sum = 0;\\n        for (int i = 0; i < digits.length; ++i) {\\n            sum += digits[i] - '0';\\n        }\\n        return sum;\\n    }\\n}\\n\"",
    "trinomial triangle": "\"package com.thealgorithms.maths;\\n\\n/**\\n * The trinomial triangle is a variation of Pascal’s triangle. The difference\\n * between the two is that an entry in the trinomial triangle is the sum of the\\n * three (rather than the two in Pasacal’s triangle) entries above it\\n *\\n * Example Input: n = 4 Output 1 1 1 1 1 2 3 2 1 1 3 6 7 6 3 1\\n */\\npublic class TrinomialTriangle {\\n\\n    public static int TrinomialValue(int n, int k) {\\n        if (n == 0 && k == 0) {\\n            return 1;\\n        }\\n\\n        if (k < -n || k > n) {\\n            return 0;\\n        }\\n\\n        return TrinomialValue(n - 1, k - 1) + TrinomialValue(n - 1, k) + TrinomialValue(n - 1, k + 1);\\n    }\\n\\n    public static void printTrinomial(int n) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = -i; j <= 0; j++) {\\n                System.out.print(TrinomialValue(i, j) + \\\" \\\");\\n            }\\n\\n            for (int j = 1; j <= i; j++) {\\n                System.out.print(TrinomialValue(i, j) + \\\" \\\");\\n            }\\n\\n            System.out.println();\\n        }\\n    }\\n\\n    public static void main(String argc[]) {\\n        int n = 6;\\n        printTrinomial(n);\\n    }\\n}\\n\"",
    "vampire number": "\"package com.thealgorithms.maths;\\n\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\n\\n/**\\n * n number theory, a vampire number (or true vampire number) is a composite\\n * natural number with an even number of digits, that can be factored into two\\n * natural numbers each with half as many digits as the original number and not\\n * both with trailing zeroes, where the two factors contain precisely all the\\n * digits of the original number, in any order, counting multiplicity. The first\\n * vampire number is 1260 = 21 × 60. *\\n *\\n * <p>\\n * link: https://en.wikipedia.org/wiki/Vampire_number *\\n *\\n * <p>\\n */\\npublic class VampireNumber {\\n\\n    public static void main(String[] args) {\\n\\n        test(10, 1000);\\n    }\\n\\n    static void test(int startValue, int stopValue) {\\n        int countofRes = 1;\\n        StringBuilder res = new StringBuilder();\\n\\n        for (int i = startValue; i <= stopValue; i++) {\\n            for (int j = i; j <= stopValue; j++) {\\n                // System.out.println(i+ \\\" \\\"+ j);\\n                if (isVampireNumber(i, j, true)) {\\n                    countofRes++;\\n                    res.append(\\\"\\\" + countofRes + \\\": = ( \\\" + i + \\\",\\\" + j + \\\" = \\\" + i * j + \\\")\\\" + \\\"\\\\n\\\");\\n                }\\n            }\\n        }\\n        System.out.println(res);\\n    }\\n\\n    static boolean isVampireNumber(int a, int b, boolean noPseudoVamireNumbers) {\\n\\n        // this is for pseudoVampireNumbers  pseudovampire number need not be of length n/2 digits for\\n        // example\\n        // 126 = 6 x 21\\n        if (noPseudoVamireNumbers) {\\n            if (a * 10 <= b || b * 10 <= a) {\\n                return false;\\n            }\\n        }\\n\\n        String mulDigits = splitIntoDigits(a * b, 0);\\n        String faktorDigits = splitIntoDigits(a, b);\\n\\n        return mulDigits.equals(faktorDigits);\\n    }\\n\\n    // methode to Split the numbers to Digits\\n    static String splitIntoDigits(int num, int num2) {\\n\\n        StringBuilder res = new StringBuilder();\\n\\n        ArrayList<Integer> digits = new ArrayList<>();\\n        while (num > 0) {\\n            digits.add(num % 10);\\n            num /= 10;\\n        }\\n        while (num2 > 0) {\\n            digits.add(num2 % 10);\\n            num2 /= 10;\\n        }\\n        Collections.sort(digits);\\n        for (int i : digits) {\\n            res.append(i);\\n        }\\n\\n        return res.toString();\\n    }\\n}\\n\"",
    "vector cross product": "\"package com.thealgorithms.maths;\\n\\n/**\\n * @file\\n *\\n * @brief Calculates the [Cross\\n * Product](https://en.wikipedia.org/wiki/Cross_product) and the magnitude of\\n * two mathematical 3D vectors.\\n *\\n *\\n * @details Cross Product of two vectors gives a vector. Direction Ratios of a\\n * vector are the numeric parts of the given vector. They are the tree parts of\\n * the vector which determine the magnitude (value) of the vector. The method of\\n * finding a cross product is the same as finding the determinant of an order 3\\n * matrix consisting of the first row with unit vectors of magnitude 1, the\\n * second row with the direction ratios of the first vector and the third row\\n * with the direction ratios of the second vector. The magnitude of a vector is\\n * it's value expressed as a number. Let the direction ratios of the first\\n * vector, P be: a, b, c Let the direction ratios of the second vector, Q be: x,\\n * y, z Therefore the calculation for the cross product can be arranged as:\\n *\\n * ``` P x Q: 1\\t1\\t1 a\\tb\\tc x\\ty\\tz ```\\n *\\n * The direction ratios (DR) are calculated as follows: 1st DR, J: (b * z) - (c\\n * * y) 2nd DR, A: -((a * z) - (c * x)) 3rd DR, N: (a * y) - (b * x)\\n *\\n * Therefore, the direction ratios of the cross product are: J, A, N The\\n * following Java Program calculates the direction ratios of the cross products\\n * of two vector. The program uses a function, cross() for doing so. The\\n * direction ratios for the first and the second vector has to be passed one by\\n * one seperated by a space character.\\n *\\n * Magnitude of a vector is the square root of the sum of the squares of the\\n * direction ratios.\\n *\\n *\\n * For maintaining filename consistency, Vector class has been termed as\\n * VectorCrossProduct\\n *\\n * @author [Syed](https://github.com/roeticvampire)\\n */\\npublic class VectorCrossProduct {\\n\\n    int x;\\n    int y;\\n    int z;\\n\\n    //Default constructor, initialises all three Direction Ratios to 0\\n    VectorCrossProduct() {\\n        x = 0;\\n        y = 0;\\n        z = 0;\\n    }\\n\\n    /**\\n     * constructor, initialises Vector with given Direction Ratios\\n     *\\n     * @param _x set to x\\n     * @param _y set to y\\n     * @param _z set to z\\n     */\\n    VectorCrossProduct(int _x, int _y, int _z) {\\n        x = _x;\\n        y = _y;\\n        z = _z;\\n    }\\n\\n    /**\\n     * Returns the magnitude of the vector\\n     *\\n     * @return double\\n     */\\n    double magnitude() {\\n        return Math.sqrt(x * x + y * y + z * z);\\n    }\\n\\n    /**\\n     * Returns the dot product of the current vector with a given vector\\n     *\\n     * @param b: the second vector\\n     * @return int: the dot product\\n     */\\n    int dotProduct(VectorCrossProduct b) {\\n        return x * b.x + y * b.y + z * b.z;\\n    }\\n\\n    /**\\n     * Returns the cross product of the current vector with a given vector\\n     *\\n     * @param b: the second vector\\n     * @return vectorCrossProduct: the cross product\\n     */\\n    VectorCrossProduct crossProduct(VectorCrossProduct b) {\\n        VectorCrossProduct product = new VectorCrossProduct();\\n        product.x = (y * b.z) - (z * b.y);\\n        product.y = -((x * b.z) - (z * b.x));\\n        product.z = (x * b.y) - (y * b.x);\\n        return product;\\n    }\\n\\n    /**\\n     * Display the Vector\\n     */\\n    void displayVector() {\\n        System.out.println(\\\"x : \\\" + x + \\\"\\\\ty : \\\" + y + \\\"\\\\tz : \\\" + z);\\n    }\\n\\n    public static void main(String[] args) {\\n        test();\\n    }\\n\\n    static void test() {\\n        //Create two vectors\\n        VectorCrossProduct A = new VectorCrossProduct(1, -2, 3);\\n        VectorCrossProduct B = new VectorCrossProduct(2, 0, 3);\\n\\n        //Determine cross product\\n        VectorCrossProduct crossProd = A.crossProduct(B);\\n        crossProd.displayVector();\\n\\n        //Determine dot product\\n        int dotProd = A.dotProduct(B);\\n        System.out.println(\\\"Dot Product of A and B: \\\" + dotProd);\\n\\n    }\\n\\n}\\n\"",
    "volume": "\"package com.thealgorithms.maths;\\n\\n\\n/* Find volume of various shapes.*/\\npublic class Volume {\\n\\n    public static void main(String[] args) {\\n\\n        /* test cube */\\n        assert Double.compare(volumeCube(7), 343.0) == 0;\\n\\n        /* test cuboid */\\n        assert Double.compare(volumeCuboid(2, 5, 7), 70.0) == 0;\\n\\n        /* test sphere */\\n        assert Double.compare(volumeSphere(5), 523.5987755982989) == 0;\\n\\n        /* test cylinder */\\n        assert Double.compare(volumeCylinder(1, 2), 12.566370614359172) == 0;\\n\\n        /* test hemisphere */\\n        assert Double.compare(volumeHemisphere(5), 261.79938779914943) == 0;\\n\\n        /* test cone */\\n        assert Double.compare(volumeCone(5, 7), 916.297857297023) == 0;\\n\\n    }\\n\\n    /**\\n     * Calculate the volume of a cube.\\n     *\\n     * @param sideLength side length of cube\\n     * @return volume of given cube\\n     */\\n    private static double volumeCube(double sidelength) {\\n        return sidelength * sidelength * sidelength;\\n    }\\n\\n    /**\\n     * Calculate the volume of a cuboid.\\n     *\\n     * @param width of cuboid\\n     * @param height of cuboid\\n     * @param length of cuboid\\n     * @return volume of given cuboid\\n     */\\n    private static double volumeCuboid(double width, double height, double length) {\\n        return width * height * length;\\n    }\\n\\n    /**\\n     * Calculate the volume of a sphere.\\n     *\\n     * @param radius radius of sphere\\n     * @return volume of given sphere\\n     */\\n    private static double volumeSphere(double radius) {\\n        return 4 / 3 * Math.PI * radius * radius * radius;\\n    }\\n\\n    /**\\n     * Calculate volume of a cylinder\\n     *\\n     * @param radius radius of the floor\\n     * @param height height of the cylinder.\\n     * @return volume of given cylinder\\n     */\\n    private static double volumeCylinder(double radius, double height) {\\n        return Math.PI * radius * radius * height;\\n    }\\n\\n    /**\\n     * Calculate the volume of a hemisphere.\\n     *\\n     * @param radius radius of hemisphere\\n     * @return volume of given hemisphere\\n     */\\n    private static double volumeHemisphere(double radius) {\\n        return 2 / 3 * Math.PI * radius * radius * radius;\\n    }\\n\\n    /**\\n     * Calculate the volume of a cone.\\n     *\\n     * @param radius radius of cone.\\n     * @param height of cone.\\n     * @return volume of given cone.\\n     */\\n    private static double volumeCone(double radius, double height) {\\n        return Math.PI * radius * radius * height / 3;\\n    }\\n}\\n\"",
    "lateness data": "\"6\\n3 6\\n2 8\\n1 9\\n4 9\\n3 14\\n2 15\"",
    "minimizing lateness": "\"package com.thealgorithms.minimizinglateness;\\n\\nimport java.io.BufferedReader;\\nimport java.io.FileReader;\\nimport java.io.IOException;\\nimport java.util.StringTokenizer;\\n\\npublic class MinimizingLateness {\\n\\n    private static class Schedule { // Schedule class\\n\\n        int t = 0; // Time required for the operation to be performed\\n        int d = 0; // Time the job should be completed\\n        int s = 0; // Start time of the task\\n        int f = 0; // End time of the operation\\n\\n        public Schedule(int t, int d) {\\n            this.t = t;\\n            this.d = d;\\n        }\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        StringTokenizer token;\\n\\n        BufferedReader in = new BufferedReader(new FileReader(\\\"MinimizingLateness/lateness_data.txt\\\"));\\n        String ch = in.readLine();\\n        if (ch == null || ch.isEmpty()) {\\n            in.close();\\n            return;\\n        }\\n        int indexCount = Integer.parseInt(ch);\\n        System.out.println(\\\"Input Data : \\\");\\n        System.out.println(indexCount); // number of operations\\n        Schedule[] array = new Schedule[indexCount]; // Create an array to hold the operation\\n        int i = 0;\\n        while ((ch = in.readLine()) != null) {\\n            token = new StringTokenizer(ch, \\\" \\\");\\n            // Include the time required for the operation to be performed in the array and the time it\\n            // should be completed.\\n            array[i]\\n                    = new Schedule(Integer.parseInt(token.nextToken()), Integer.parseInt(token.nextToken()));\\n            i++;\\n            System.out.println(array[i - 1].t + \\\" \\\" + array[i - 1].d);\\n        }\\n\\n        int tryTime = 0; // Total time worked\\n        int lateness = 0; // Lateness\\n        for (int j = 0; j < indexCount - 1; j++) {\\n            array[j].s = tryTime; // Start time of the task\\n            array[j].f = tryTime + array[j].t; // Time finished\\n            tryTime = tryTime + array[j].t; // Add total work time\\n            // Lateness\\n            lateness = lateness + Math.max(0, tryTime - array[j].d);\\n        }\\n        System.out.println();\\n        System.out.println(\\\"Output Data : \\\");\\n        System.out.println(lateness);\\n        in.close();\\n    }\\n}\\n\"",
    "color contrast ratio": "\"package com.thealgorithms.misc;\\n\\nimport java.awt.Color;\\n\\n/**\\n * @brief A Java implementation of the offcial W3 documented procedure to\\n * calculate contrast ratio between colors on the web. This is used to calculate\\n * the readability of a foreground color on top of a background color.\\n * @since 2020-10-15\\n * @see [Color Contrast\\n * Ratio](https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-procedure)\\n * @author [Seth Falco](https://github.com/SethFalco)\\n */\\npublic class ColorContrastRatio {\\n\\n    /**\\n     * @brief Calculates the contrast ratio between two given colors.\\n     * @param a Any color, used to get the red, green, and blue values.\\n     * @param b Another color, which will be compared against the first color.\\n     * @return The contrast ratio between the two colors.\\n     */\\n    public double getContrastRatio(Color a, Color b) {\\n        final double aColorLuminance = getRelativeLuminance(a);\\n        final double bColorLuminance = getRelativeLuminance(b);\\n\\n        if (aColorLuminance > bColorLuminance) {\\n            return (aColorLuminance + 0.05) / (bColorLuminance + 0.05);\\n        }\\n\\n        return (bColorLuminance + 0.05) / (aColorLuminance + 0.05);\\n    }\\n\\n    /**\\n     * @brief Calculates the relative luminance of a given color.\\n     * @param color Any color, used to get the red, green, and blue values.\\n     * @return The relative luminance of the color.\\n     * @see [More info on relative\\n     * luminance.](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef)\\n     */\\n    public double getRelativeLuminance(Color color) {\\n        final double red = getColor(color.getRed());\\n        final double green = getColor(color.getGreen());\\n        final double blue = getColor(color.getBlue());\\n\\n        return 0.2126 * red + 0.7152 * green + 0.0722 * blue;\\n    }\\n\\n    /**\\n     * @brief Calculates the final value for a color to be used in the relative\\n     * luminance formula as described in step 1.\\n     * @param color8Bit 8-bit representation of a color component value.\\n     * @return Value for the provided color component to be used in the relative\\n     * luminance formula.\\n     */\\n    public double getColor(int color8Bit) {\\n        final double sRgb = getColorSRgb(color8Bit);\\n        return (sRgb <= 0.03928) ? sRgb / 12.92 : Math.pow((sRgb + 0.055) / 1.055, 2.4);\\n    }\\n\\n    /**\\n     * @brief Calculates the Color sRGB value as denoted in step 1 of the\\n     * procedure document.\\n     * @param color8Bit 8-bit representation of a color component value.\\n     * @return A percentile value of the color component.\\n     */\\n    private double getColorSRgb(double color8Bit) {\\n        return color8Bit / 255.0;\\n    }\\n\\n    /**\\n     * You can check this example against another open-source implementation\\n     * available on GitHub.\\n     *\\n     * @see [Online Contrast\\n     * Ratio](https://contrast-ratio.com/#rgb%28226%2C%20229%2C%20248-on-rgb%2823%2C%20103%2C%20154%29)\\n     * @see [GitHub Repository for Online Contrast\\n     * Ratio](https://github.com/LeaVerou/contrast-ratio)\\n     */\\n    private static void test() {\\n        final ColorContrastRatio algImpl = new ColorContrastRatio();\\n\\n        final Color black = Color.BLACK;\\n        final double blackLuminance = algImpl.getRelativeLuminance(black);\\n        assert blackLuminance == 0 : \\\"Test 1 Failed - Incorrect relative luminance.\\\";\\n\\n        final Color white = Color.WHITE;\\n        final double whiteLuminance = algImpl.getRelativeLuminance(white);\\n        assert whiteLuminance == 1 : \\\"Test 2 Failed - Incorrect relative luminance.\\\";\\n\\n        final double highestColorRatio = algImpl.getContrastRatio(black, white);\\n        assert highestColorRatio == 21 : \\\"Test 3 Failed - Incorrect contrast ratio.\\\";\\n\\n        final Color foreground = new Color(23, 103, 154);\\n        final double foregroundLuminance = algImpl.getRelativeLuminance(foreground);\\n        assert foregroundLuminance == 0.12215748057375966 : \\\"Test 4 Failed - Incorrect relative luminance.\\\";\\n\\n        final Color background = new Color(226, 229, 248);\\n        final double backgroundLuminance = algImpl.getRelativeLuminance(background);\\n        assert backgroundLuminance == 0.7898468477881603 : \\\"Test 5 Failed - Incorrect relative luminance.\\\";\\n\\n        final double contrastRatio = algImpl.getContrastRatio(foreground, background);\\n        assert contrastRatio == 4.878363954846178 : \\\"Test 6 Failed - Incorrect contrast ratio.\\\";\\n    }\\n\\n    public static void main(String args[]) {\\n        test();\\n    }\\n}\\n\"",
    "inverse of matrix": "\"package com.thealgorithms.misc;\\n\\nimport java.util.Scanner;\\n\\n/*\\n* Wikipedia link : https://en.wikipedia.org/wiki/Invertible_matrix\\n*\\n* Here we use gauss elimination method to find the inverse of a given matrix.\\n* To understand gauss elimination method to find inverse of a matrix: https://www.sangakoo.com/en/unit/inverse-matrix-method-of-gaussian-elimination\\n*\\n* We can also find the inverse of a matrix \\n */\\npublic class InverseOfMatrix {\\n\\n    public static void main(String argv[]) {\\n        Scanner input = new Scanner(System.in);\\n        System.out.println(\\\"Enter the matrix size (Square matrix only): \\\");\\n        int n = input.nextInt();\\n        double a[][] = new double[n][n];\\n        System.out.println(\\\"Enter the elements of matrix: \\\");\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                a[i][j] = input.nextDouble();\\n            }\\n        }\\n\\n        double d[][] = invert(a);\\n        System.out.println();\\n        System.out.println(\\\"The inverse is: \\\");\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                System.out.print(d[i][j] + \\\"  \\\");\\n            }\\n            System.out.println();\\n        }\\n        input.close();\\n    }\\n\\n    public static double[][] invert(double a[][]) {\\n        int n = a.length;\\n        double x[][] = new double[n][n];\\n        double b[][] = new double[n][n];\\n        int index[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            b[i][i] = 1;\\n        }\\n\\n        // Transform the matrix into an upper triangle\\n        gaussian(a, index);\\n\\n        // Update the matrix b[i][j] with the ratios stored\\n        for (int i = 0; i < n - 1; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    b[index[j]][k]\\n                            -= a[index[j]][i] * b[index[i]][k];\\n                }\\n            }\\n        }\\n\\n        // Perform backward substitutions\\n        for (int i = 0; i < n; ++i) {\\n            x[n - 1][i] = b[index[n - 1]][i] / a[index[n - 1]][n - 1];\\n            for (int j = n - 2; j >= 0; --j) {\\n                x[j][i] = b[index[j]][i];\\n                for (int k = j + 1; k < n; ++k) {\\n                    x[j][i] -= a[index[j]][k] * x[k][i];\\n                }\\n                x[j][i] /= a[index[j]][j];\\n            }\\n        }\\n        return x;\\n    }\\n\\n// Method to carry out the partial-pivoting Gaussian\\n// elimination.  Here index[] stores pivoting order.\\n    public static void gaussian(double a[][], int index[]) {\\n        int n = index.length;\\n        double c[] = new double[n];\\n\\n        // Initialize the index\\n        for (int i = 0; i < n; ++i) {\\n            index[i] = i;\\n        }\\n\\n        // Find the rescaling factors, one from each row\\n        for (int i = 0; i < n; ++i) {\\n            double c1 = 0;\\n            for (int j = 0; j < n; ++j) {\\n                double c0 = Math.abs(a[i][j]);\\n                if (c0 > c1) {\\n                    c1 = c0;\\n                }\\n            }\\n            c[i] = c1;\\n        }\\n\\n        // Search the pivoting element from each column\\n        int k = 0;\\n        for (int j = 0; j < n - 1; ++j) {\\n            double pi1 = 0;\\n            for (int i = j; i < n; ++i) {\\n                double pi0 = Math.abs(a[index[i]][j]);\\n                pi0 /= c[index[i]];\\n                if (pi0 > pi1) {\\n                    pi1 = pi0;\\n                    k = i;\\n                }\\n            }\\n            // Interchange rows according to the pivoting order\\n            int itmp = index[j];\\n            index[j] = index[k];\\n            index[k] = itmp;\\n            for (int i = j + 1; i < n; ++i) {\\n                double pj = a[index[i]][j] / a[index[j]][j];\\n\\n                // Record pivoting ratios below the diagonal\\n                a[index[i]][j] = pj;\\n\\n                // Modify other elements accordingly\\n                for (int l = j + 1; l < n; ++l) {\\n                    a[index[i]][l] -= pj * a[index[j]][l];\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "matrix transpose": "\"package com.thealgorithms.misc;\\n\\nimport java.util.Scanner;\\n\\n/**\\n *\\n *\\n * <h1>Find the Transpose of Matrix!</h1>\\n *\\n * Simply take input from the user and print the matrix before the transpose and\\n * after the transpose.\\n *\\n * <p>\\n * <b>Note:</b> Giving proper comments in your program makes it more user\\n * friendly and it is assumed as a high quality code.\\n *\\n * @author Rajat-Jain29\\n * @version 11.0.9\\n * @since 2014-03-31\\n */\\npublic class matrixTranspose {\\n\\n    public static void main(String[] args) {\\n        /*\\n     * This is the main method\\n     *\\n     * @param args Unused.\\n     *\\n     * @return Nothing.\\n         */\\n        Scanner sc = new Scanner(System.in);\\n        int i, j, row, column;\\n        System.out.println(\\\"Enter the number of rows in the 2D matrix:\\\");\\n\\n        /*\\n     * Take input from user for how many rows to be print\\n         */\\n        row = sc.nextInt();\\n\\n        System.out.println(\\\"Enter the number of columns in the 2D matrix:\\\");\\n\\n        /*\\n     * Take input from user for how many coloumn to be print\\n         */\\n        column = sc.nextInt();\\n        int[][] arr = new int[row][column];\\n        System.out.println(\\\"Enter the elements\\\");\\n        for (i = 0; i < row; i++) {\\n            for (j = 0; j < column; j++) {\\n                arr[i][j] = sc.nextInt();\\n            }\\n        }\\n\\n        /*\\n     * Print matrix before the Transpose in proper way\\n         */\\n        System.out.println(\\\"The matrix is:\\\");\\n        for (i = 0; i < row; i++) {\\n            for (j = 0; j < column; j++) {\\n                System.out.print(arr[i][j] + \\\"\\\\t\\\");\\n            }\\n            System.out.print(\\\"\\\\n\\\");\\n        }\\n\\n        /*\\n     * Print matrix after the tranpose in proper way Transpose means Interchanging\\n     * of rows wth column so we interchange the rows in next loop Thus at last\\n     * matrix of transpose is obtained through user input...\\n         */\\n        System.out.println(\\\"The Transpose of the given matrix is:\\\");\\n        for (i = 0; i < column; i++) {\\n            for (j = 0; j < row; j++) {\\n                System.out.print(arr[j][i] + \\\"\\\\t\\\");\\n            }\\n            System.out.print(\\\"\\\\n\\\");\\n        }\\n    }\\n}\\n\"",
    "median of running array": "\"package com.thealgorithms.misc;\\n\\nimport java.util.Collections;\\nimport java.util.PriorityQueue;\\n\\n/**\\n * @author shrutisheoran\\n */\\npublic class MedianOfRunningArray {\\n\\n    private PriorityQueue<Integer> p1;\\n    private PriorityQueue<Integer> p2;\\n\\n    // Constructor\\n    public MedianOfRunningArray() {\\n        this.p1 = new PriorityQueue<>(Collections.reverseOrder()); // Max Heap\\n        this.p2 = new PriorityQueue<>(); // Min Heap\\n    }\\n\\n    /*\\n      Inserting lower half of array to max Heap\\n      and upper half to min heap\\n     */\\n    public void insert(Integer e) {\\n        p2.add(e);\\n        if (p2.size() - p1.size() > 1) {\\n            p1.add(p2.remove());\\n        }\\n    }\\n\\n    /*\\n      Returns median at any given point\\n     */\\n    public Integer median() {\\n        if (p1.size() == p2.size()) {\\n            return (p1.peek() + p2.peek()) / 2;\\n        }\\n        return p1.size() > p2.size() ? p1.peek() : p2.peek();\\n    }\\n\\n    public static void main(String[] args) {\\n        /*\\n        Testing the median function\\n         */\\n\\n        MedianOfRunningArray p = new MedianOfRunningArray();\\n        int arr[] = {10, 7, 4, 9, 2, 3, 11, 17, 14};\\n        for (int i = 0; i < 9; i++) {\\n            p.insert(arr[i]);\\n            System.out.print(p.median() + \\\" \\\");\\n        }\\n    }\\n}\\n\"",
    "palindrome prime": "\"package com.thealgorithms.misc;\\n\\nimport java.util.Scanner;\\n\\npublic class PalindromePrime {\\n\\n    public static void main(String[] args) { // Main funtion\\n        Scanner in = new Scanner(System.in);\\n        System.out.println(\\\"Enter the quantity of First Palindromic Primes you want\\\");\\n        int n = in.nextInt(); // Input of how many first palindromic prime we want\\n        functioning(n); // calling function - functioning\\n        in.close();\\n    }\\n\\n    public static boolean prime(int num) { // checking if number is prime or not\\n        for (int divisor = 3; divisor <= Math.sqrt(num); divisor += 2) {\\n            if (num % divisor == 0) {\\n                return false; //  false if not prime\\n            }\\n        }\\n        return true; // True if prime\\n    }\\n\\n    public static int reverse(int n) { //  Returns  the reverse of the number\\n        int reverse = 0;\\n        while (n != 0) {\\n            reverse *= 10;\\n            reverse += n % 10;\\n            n /= 10;\\n        }\\n        return reverse;\\n    }\\n\\n    public static void functioning(int y) {\\n        if (y == 0) {\\n            return;\\n        }\\n        System.out.print(2 + \\\"\\\\n\\\"); // print the first Palindromic Prime\\n        int count = 1;\\n        int num = 3;\\n        while (count < y) {\\n            if (num == reverse(num) && prime(num)) { // number is prime and it's reverse is same\\n                count++; // counts check when to terminate while loop\\n                System.out.print(num + \\\"\\\\n\\\"); // print the Palindromic Prime\\n            }\\n            num += 2; // inrease iterator value by two\\n        }\\n    }\\n}\\n\"",
    "palindrome singly linked list": "\"package com.thealgorithms.misc;\\n\\nimport java.util.Stack;\\nimport com.thealgorithms.datastructures.lists.SinglyLinkedList;\\n\\n/**\\n * A simple way of knowing if a singly linked list is palindrome is to push all\\n * the values into a Stack and then compare the list to popped vales from the\\n * Stack.\\n *\\n * See more:\\n * https://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/\\n */\\npublic class PalindromeSinglyLinkedList {\\n\\n    public static void main(String[] args) {\\n        SinglyLinkedList linkedList = new SinglyLinkedList();\\n\\n        linkedList.insertHead(3);\\n        linkedList.insertNth(2, 1);\\n        linkedList.insertNth(1, 2);\\n        linkedList.insertNth(2, 3);\\n        linkedList.insertNth(3, 4);\\n\\n        if (isPalindrome(linkedList)) {\\n            System.out.println(\\\"It's a palindrome list\\\");\\n        } else {\\n            System.out.println(\\\"It's NOT a palindrome list\\\");\\n        }\\n    }\\n\\n    public static boolean isPalindrome(SinglyLinkedList linkedList) {\\n        boolean ret = true;\\n        Stack<Integer> linkedListValues = new Stack<>();\\n\\n        for (int i = 0; i < linkedList.size(); i++) {\\n            linkedListValues.push(linkedList.getNth(i));\\n        }\\n\\n        for (int i = 0; i < linkedList.size(); i++) {\\n            if (linkedList.getNth(i) != linkedListValues.pop()) {\\n                ret = false;\\n                break;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\\n\"",
    "range in sorted array": "\"package com.thealgorithms.misc;\\n\\nimport java.util.*;\\n\\npublic class RangeInSortedArray {\\n\\n    public static void main(String[] args) {\\n        // Testcases\\n        assert Arrays.equals(sortedRange(new int[]{1, 2, 3, 3, 3, 4, 5}, 3), new int[]{2, 4});\\n        assert Arrays.equals(sortedRange(new int[]{1, 2, 3, 3, 3, 4, 5}, 4), new int[]{5, 5});\\n        assert Arrays.equals(sortedRange(new int[]{0, 1, 2}, 3), new int[]{-1, -1});\\n    }\\n\\n    // Get the 1st and last occurrence index of a number 'key' in a non-decreasing array 'nums'\\n    // Gives [-1, -1] in case element doesn't exist in array\\n    public static int[] sortedRange(int[] nums, int key) {\\n        int[] range = new int[]{-1, -1};\\n        alteredBinSearchIter(nums, key, 0, nums.length - 1, range, true);\\n        alteredBinSearchIter(nums, key, 0, nums.length - 1, range, false);\\n        return range;\\n    }\\n\\n    // Recursive altered binary search which searches for leftmost as well as rightmost occurrence of\\n    // 'key'\\n    public static void alteredBinSearch(\\n            int[] nums, int key, int left, int right, int[] range, boolean goLeft) {\\n        if (left > right) {\\n            return;\\n        }\\n        int mid = (left + right) / 2;\\n        if (nums[mid] > key) {\\n            alteredBinSearch(nums, key, left, mid - 1, range, goLeft);\\n        } else if (nums[mid] < key) {\\n            alteredBinSearch(nums, key, mid + 1, right, range, goLeft);\\n        } else {\\n            if (goLeft) {\\n                if (mid == 0 || nums[mid - 1] != key) {\\n                    range[0] = mid;\\n                } else {\\n                    alteredBinSearch(nums, key, left, mid - 1, range, goLeft);\\n                }\\n            } else {\\n                if (mid == nums.length - 1 || nums[mid + 1] != key) {\\n                    range[1] = mid;\\n                } else {\\n                    alteredBinSearch(nums, key, mid + 1, right, range, goLeft);\\n                }\\n            }\\n        }\\n    }\\n\\n    // Iterative altered binary search which searches for leftmost as well as rightmost occurrence of\\n    // 'key'\\n    public static void alteredBinSearchIter(\\n            int[] nums, int key, int left, int right, int[] range, boolean goLeft) {\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (nums[mid] > key) {\\n                right = mid - 1;\\n            } else if (nums[mid] < key) {\\n                left = mid + 1;\\n            } else {\\n                if (goLeft) {\\n                    if (mid == 0 || nums[mid - 1] != key) {\\n                        range[0] = mid;\\n                        return;\\n                    } else {\\n                        right = mid - 1;\\n                    }\\n                } else {\\n                    if (mid == nums.length - 1 || nums[mid + 1] != key) {\\n                        range[1] = mid;\\n                        return;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    public static int getCountLessThan(int[] nums, int key) {\\n        return getLessThan(nums, key, 0, nums.length - 1);\\n    }\\n\\n    public static int getLessThan(int[] nums, int key, int left, int right) {\\n        int count = 0;\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (nums[mid] > key) {\\n                right = mid - 1;\\n            } else if (nums[mid] <= key) {\\n                count = mid + 1; // Atleast mid+1 elements exist which are <= key\\n                left = mid + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\"",
    "sort012 d": "\"package com.thealgorithms.misc;\\n\\nimport java.util.*;\\n\\n/**\\n * The array is divided into four sections: a[1..Lo-1] zeroes a[Lo..Mid-1] ones\\n * a[Mid..Hi] unknown a[Hi+1..N] twos If array [mid] =0, then swap array [mid]\\n * with array [low] and increment both pointers once. If array [mid] = 1, then\\n * no swapping is required. Increment mid pointer once. If array [mid] = 2, then\\n * we swap array [mid] with array [high] and decrement the high pointer once.\\n * For more information on the Dutch national flag algorithm refer\\n * https://en.wikipedia.org/wiki/Dutch_national_flag_problem\\n */\\npublic class Sort012D {\\n\\n    public static void main(String args[]) {\\n        Scanner np = new Scanner(System.in);\\n        int n = np.nextInt();\\n        int a[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            a[i] = np.nextInt();\\n        }\\n        sort012(a);\\n    }\\n\\n    public static void sort012(int[] a) {\\n        int l = 0;\\n        int h = a.length - 1;\\n        int mid = 0;\\n        int temp;\\n        while (mid <= h) {\\n            switch (a[mid]) {\\n                case 0: {\\n                    temp = a[l];\\n                    a[l] = a[mid];\\n                    a[mid] = temp;\\n                    l++;\\n                    mid++;\\n                    break;\\n                }\\n                case 1:\\n                    mid++;\\n                    break;\\n                case 2: {\\n                    temp = a[mid];\\n                    a[mid] = a[h];\\n                    a[h] = temp;\\n                    h--;\\n                    break;\\n                }\\n            }\\n        }\\n        System.out.println(\\\"the Sorted array is \\\");\\n        for (int i = 0; i < a.length; i++) {\\n            System.out.print(+a[i] + \\\" \\\");\\n        }\\n    }\\n}\\n\"",
    "sparcity": "\"package com.thealgorithms.misc;\\n\\nimport java.util.*;\\n\\n/*\\n*A matrix is sparse if many of its coefficients are zero (In general if 2/3rd of matrix elements are 0, it is considered as sparse). \\n*The interest in sparsity arises because its exploitation can lead to enormous computational savings and because many large matrix problems that occur in practice are sparse.\\n*\\n* @author Ojasva Jain\\n */\\n\\nclass Sparcity {\\n\\n    /*\\n    * @return Sparcity of matrix\\n    * \\n    * where sparcity = number of zeroes/total elements in matrix\\n    *\\n     */\\n    static double sparcity(double[][] mat) {\\n        int zero = 0;\\n        //Traversing the matrix to count number of zeroes \\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[i].length; j++) {\\n                if (mat[i][j] == 0) {\\n                    zero++;\\n                }\\n            }\\n        }\\n        //return sparcity\\n        return ((double) zero / (mat.length * mat[1].length));\\n    }\\n\\n    //Driver method\\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in);\\n        System.out.println(\\\"Enter number of rows in matrix: \\\");\\n        int n = in.nextInt();\\n        System.out.println(\\\"Enter number of Columns in matrix: \\\");\\n        int m = in.nextInt();\\n\\n        System.out.println(\\\"Enter Matrix elements: \\\");\\n        double[][] mat = new double[n][m];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                mat[i][j] = in.nextDouble();\\n            }\\n        }\\n        System.out.println(\\\"Sparcity of matrix is: \\\" + sparcity(mat));\\n    }\\n}\\n\"",
    "three sum problem": "\"package com.thealgorithms.misc;\\n\\nimport java.util.*;\\n\\npublic class ThreeSumProblem {\\n\\n    public static void main(String args[]) {\\n        Scanner scan = new Scanner(System.in);\\n        System.out.print(\\\"Enter the target sum \\\");\\n        int ts = scan.nextInt();\\n        System.out.print(\\\"Enter the number of elements in the array \\\");\\n        int n = scan.nextInt();\\n        System.out.println(\\\"Enter all your array elements:\\\");\\n        int arr[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = scan.nextInt();\\n        }\\n        ThreeSumProblem th = new ThreeSumProblem();\\n        System.out.println(\\\"Brute Force Approach\\\\n\\\" + (th.BruteForce(arr, ts)) + \\\"\\\\n\\\");\\n        System.out.println(\\\"Two Pointer Approach\\\\n\\\" + (th.TwoPointer(arr, ts)) + \\\"\\\\n\\\");\\n        System.out.println(\\\"Hashmap Approach\\\\n\\\" + (th.Hashmap(arr, ts)));\\n\\n    }\\n\\n    public List<List<Integer>> BruteForce(int[] nums, int target) {\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                for (int k = j + 1; k < nums.length; k++) {\\n                    if (nums[i] + nums[j] + nums[k] == target) {\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(nums[i]);\\n                        temp.add(nums[j]);\\n                        temp.add(nums[k]);\\n                        Collections.sort(temp);\\n                        arr.add(temp);\\n                    }\\n\\n                }\\n            }\\n        }\\n        arr = new ArrayList<List<Integer>>(new LinkedHashSet<List<Integer>>(arr));\\n        return arr;\\n    }\\n\\n    public List<List<Integer>> TwoPointer(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        int start = 0;\\n        int end = 0;\\n        int i = 0;\\n        while (i < nums.length - 1) {\\n            start = i + 1;\\n            end = nums.length - 1;\\n            while (start < end) {\\n                if (nums[start] + nums[end] + nums[i] == target) {\\n                    List<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    arr.add(temp);\\n                    start++;\\n                    end--;\\n                } else if (nums[start] + nums[end] + nums[i] < target) {\\n                    start += 1;\\n                } else {\\n                    end -= 1;\\n                }\\n\\n            }\\n            i++;\\n        }\\n        Set<List<Integer>> set = new LinkedHashSet<List<Integer>>(arr);\\n        return new ArrayList<List<Integer>>(set);\\n    }\\n\\n    public List<List<Integer>> Hashmap(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> ts = new HashSet();\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            hm.put(nums[i], i);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int t = target - nums[i] - nums[j];\\n                if (hm.containsKey(t) && hm.get(t) > j) {\\n                    List<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(t);\\n                    ts.add(temp);\\n                }\\n            }\\n        }\\n        return new ArrayList(ts);\\n    }\\n\\n}\\n\"",
    "two sum problem": "\"package com.thealgorithms.misc;\\n\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\npublic class TwoSumProblem {\\n\\n    public static void main(String args[]) {\\n        Scanner scan = new Scanner(System.in);\\n        System.out.print(\\\"Enter the target sum \\\");\\n        int ts = scan.nextInt();\\n        System.out.print(\\\"Enter the number of elements in the array \\\");\\n        int n = scan.nextInt();\\n        System.out.println(\\\"Enter all your array elements:\\\");\\n        int arr[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = scan.nextInt();\\n        }\\n        TwoSumProblem t = new TwoSumProblem();\\n        System.out.println(\\\"Brute Force Approach\\\\n\\\" + Arrays.toString(t.BruteForce(arr, ts)) + \\\"\\\\n\\\");\\n        System.out.println(\\\"Two Pointer Approach\\\\n\\\" + Arrays.toString(t.TwoPointer(arr, ts)) + \\\"\\\\n\\\");\\n        System.out.println(\\\"Hashmap Approach\\\\n\\\" + Arrays.toString(t.HashMap(arr, ts)));\\n\\n    }\\n\\n    public int[] BruteForce(int[] nums, int target) {\\n        //Brute Force Approach \\n        int ans[] = new int[2];\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] + nums[j] == target) {\\n                    ans[0] = i;\\n                    ans[1] = j;\\n\\n                    break;\\n                }\\n\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int[] TwoPointer(int[] nums, int target) {\\n        // HashMap Approach\\n        int ans[] = new int[2];\\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            hm.put(i, nums[i]);\\n        }\\n        HashMap<Integer, Integer> temp\\n                = hm.entrySet()\\n                        .stream()\\n                        .sorted((i1, i2)\\n                                -> i1.getValue().compareTo(\\n                                i2.getValue()))\\n                        .collect(Collectors.toMap(\\n                                Map.Entry::getKey,\\n                                Map.Entry::getValue,\\n                                (e1, e2) -> e1, LinkedHashMap::new));\\n\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start < end) {\\n            int currSum = (Integer) temp.values().toArray()[start] + (Integer) temp.values().toArray()[end];\\n\\n            if (currSum == target) {\\n                ans[0] = (Integer) temp.keySet().toArray()[start];\\n                ans[1] = (Integer) temp.keySet().toArray()[end];\\n                break;\\n            } else if (currSum > target) {\\n                end -= 1;\\n            } else if (currSum < target) {\\n                start += 1;\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n\\n    public int[] HashMap(int[] nums, int target) {\\n        //Using Hashmaps\\n        int ans[] = new int[2];\\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            hm.put(nums[i], i);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            int t = target - nums[i];\\n            if (hm.containsKey(t) && hm.get(t) != i) {\\n                ans[0] = i;\\n                ans[1] = hm.get(t);\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n\"",
    "word boggle": "\"package com.thealgorithms.misc;\\n\\nimport java.util.*;\\n\\npublic class WordBoggle {\\n\\n    /**\\n     * O(nm * 8^s + ws) time where n = width of boggle board, m = height of\\n     * boggle board, s = length of longest word in string array, w = length of\\n     * string array, 8 is due to 8 explorable neighbours O(nm + ws) space.\\n     */\\n    public static List<String> boggleBoard(char[][] board, String[] words) {\\n        Trie trie = new Trie();\\n        for (String word : words) {\\n            trie.add(word);\\n        }\\n        Set<String> finalWords = new HashSet<>();\\n        boolean[][] visited = new boolean[board.length][board.length];\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                explore(i, j, board, trie.root, visited, finalWords);\\n            }\\n        }\\n        return new ArrayList<>(finalWords);\\n    }\\n\\n    public static void main(String[] args) {\\n        // Testcase\\n        List<String> ans\\n                = new ArrayList<>(\\n                        Arrays.asList(\\\"a\\\", \\\"boggle\\\", \\\"this\\\", \\\"NOTRE_PEATED\\\", \\\"is\\\", \\\"simple\\\", \\\"board\\\"));\\n        assert (boggleBoard(\\n                new char[][]{\\n                    {'t', 'h', 'i', 's', 'i', 's', 'a'},\\n                    {'s', 'i', 'm', 'p', 'l', 'e', 'x'},\\n                    {'b', 'x', 'x', 'x', 'x', 'e', 'b'},\\n                    {'x', 'o', 'g', 'g', 'l', 'x', 'o'},\\n                    {'x', 'x', 'x', 'D', 'T', 'r', 'a'},\\n                    {'R', 'E', 'P', 'E', 'A', 'd', 'x'},\\n                    {'x', 'x', 'x', 'x', 'x', 'x', 'x'},\\n                    {'N', 'O', 'T', 'R', 'E', '_', 'P'},\\n                    {'x', 'x', 'D', 'E', 'T', 'A', 'E'},},\\n                new String[]{\\n                    \\\"this\\\",\\n                    \\\"is\\\",\\n                    \\\"not\\\",\\n                    \\\"a\\\",\\n                    \\\"simple\\\",\\n                    \\\"test\\\",\\n                    \\\"boggle\\\",\\n                    \\\"board\\\",\\n                    \\\"REPEATED\\\",\\n                    \\\"NOTRE_PEATED\\\",})\\n                .equals(ans));\\n    }\\n\\n    public static void explore(\\n            int i,\\n            int j,\\n            char[][] board,\\n            TrieNode trieNode,\\n            boolean[][] visited,\\n            Set<String> finalWords) {\\n        if (visited[i][j]) {\\n            return;\\n        }\\n\\n        char letter = board[i][j];\\n        if (!trieNode.children.containsKey(letter)) {\\n            return;\\n        }\\n        visited[i][j] = true;\\n        trieNode = trieNode.children.get(letter);\\n        if (trieNode.children.containsKey('*')) {\\n            finalWords.add(trieNode.word);\\n        }\\n\\n        List<Integer[]> neighbors = getNeighbors(i, j, board);\\n        for (Integer[] neighbor : neighbors) {\\n            explore(neighbor[0], neighbor[1], board, trieNode, visited, finalWords);\\n        }\\n\\n        visited[i][j] = false;\\n    }\\n\\n    public static List<Integer[]> getNeighbors(int i, int j, char[][] board) {\\n        List<Integer[]> neighbors = new ArrayList<>();\\n        if (i > 0 && j > 0) {\\n            neighbors.add(new Integer[]{i - 1, j - 1});\\n        }\\n\\n        if (i > 0 && j < board[0].length - 1) {\\n            neighbors.add(new Integer[]{i - 1, j + 1});\\n        }\\n\\n        if (i < board.length - 1 && j < board[0].length - 1) {\\n            neighbors.add(new Integer[]{i + 1, j + 1});\\n        }\\n\\n        if (i < board.length - 1 && j > 0) {\\n            neighbors.add(new Integer[]{i + 1, j - 1});\\n        }\\n\\n        if (i > 0) {\\n            neighbors.add(new Integer[]{i - 1, j});\\n        }\\n\\n        if (i < board.length - 1) {\\n            neighbors.add(new Integer[]{i + 1, j});\\n        }\\n\\n        if (j > 0) {\\n            neighbors.add(new Integer[]{i, j - 1});\\n        }\\n\\n        if (j < board[0].length - 1) {\\n            neighbors.add(new Integer[]{i, j + 1});\\n        }\\n\\n        return neighbors;\\n    }\\n}\\n\\n// Trie used to optimize string search\\nclass TrieNode {\\n\\n    Map<Character, TrieNode> children = new HashMap<>();\\n    String word = \\\"\\\";\\n}\\n\\nclass Trie {\\n\\n    TrieNode root;\\n    char endSymbol;\\n\\n    public Trie() {\\n        this.root = new TrieNode();\\n        this.endSymbol = '*';\\n    }\\n\\n    public void add(String str) {\\n        TrieNode node = this.root;\\n        for (int i = 0; i < str.length(); i++) {\\n            char letter = str.charAt(i);\\n            if (!node.children.containsKey(letter)) {\\n                TrieNode newNode = new TrieNode();\\n                node.children.put(letter, newNode);\\n            }\\n            node = node.children.get(letter);\\n        }\\n        node.children.put(this.endSymbol, null);\\n        node.word = str;\\n    }\\n}\\n\"",
    "array left rotation": "\"package com.thealgorithms.others;\\n\\n/*\\n * A left rotation operation on an array\\n * shifts each of the array's elements\\n * given integer n unit to the left.\\n * \\n * @author sangin-lee \\n */\\n\\npublic class ArrayLeftRotation {\\n\\n\\t/*\\n\\t * Returns the result of left rotation of given array arr and integer n\\n\\t * \\n\\t * @param arr : int[] given array\\n\\t * \\n\\t * @param n : int given integer\\n\\t * \\n\\t * @return : int[] result of left rotation\\n\\t */\\n\\tpublic static int[] rotateLeft(int[] arr, int n) {\\n\\t\\tint size = arr.length;\\n\\t\\tint[] dst = new int[size];\\n\\t\\tn = n % size;\\n\\t\\tfor(int i = 0; i < size; i++) {\\n\\t\\t\\tdst[i] = arr[n];\\n\\t\\t\\tn = (n + 1) % size;\\n\\t\\t}\\n\\t\\treturn dst;\\n\\t}\\n\\n}\\n\"",
    "bankers algorithm": "\"package com.thealgorithms.others;\\n\\n/**\\n * This file contains an implementation of BANKER'S ALGORITM Wikipedia:\\n * https://en.wikipedia.org/wiki/Banker%27s_algorithm\\n *\\n * The algorithm for finding out whether or not a system is in a safe state can\\n * be described as follows: 1. Let Work and Finish be vectors of length ‘m’ and\\n * ‘n’ respectively. Initialize: Work= Available Finish [i]=false; for\\n * i=1,2,……,n 2. Find an i such that both a) Finish [i]=false b) Need_i<=work\\n *\\n * if no such i exists goto step (4) 3. Work=Work + Allocation_i Finish[i]= true\\n * goto step(2) 4. If Finish[i]=true for all i, then the system is in safe\\n * state.\\n *\\n * Time Complexity: O(n*n*m) Space Complexity: O(n*m) where n = number of\\n * processes and m = number of resources.\\n *\\n * @author AMRITESH ANAND (https://github.com/amritesh19)\\n */\\nimport java.util.Scanner;\\n\\npublic class BankersAlgorithm {\\n\\n    /**\\n     * This method finds the need of each process\\n     */\\n    static void calculateNeed(int needArray[][], int maxArray[][], int allocationArray[][], int totalProcess, int totalResources) {\\n        for (int i = 0; i < totalProcess; i++) {\\n            for (int j = 0; j < totalResources; j++) {\\n                needArray[i][j] = maxArray[i][j] - allocationArray[i][j];\\n            }\\n        }\\n    }\\n\\n    /**\\n     * This method find the system is in safe state or not\\n     *\\n     * @param processes[] int array of processes (0...n-1), size = n\\n     * @param availableArray[] int array of number of instances of each\\n     * resource, size = m\\n     * @param maxArray[][] int matrix(2-D array) of maximum demand of each\\n     * process in a system, size = n*m\\n     * @param allocationArray[][] int matrix(2-D array) of the number of\\n     * resources of each type currently allocated to each process, size = n*m\\n     * @param totalProcess number of total processes, n\\n     * @param totalResources number of total resources, m\\n     *\\n     * @return boolean if the system is in safe state or not\\n     */\\n    static boolean checkSafeSystem(int processes[], int availableArray[], int maxArray[][], int allocationArray[][], int totalProcess, int totalResources) {\\n        int[][] needArray = new int[totalProcess][totalResources];\\n\\n        calculateNeed(needArray, maxArray, allocationArray, totalProcess, totalResources);\\n\\n        boolean[] finishProcesses = new boolean[totalProcess];\\n\\n        int[] safeSequenceArray = new int[totalProcess];\\n\\n        int[] workArray = new int[totalResources];\\n\\n        for (int i = 0; i < totalResources; i++) {\\n            workArray[i] = availableArray[i];\\n        }\\n\\n        int count = 0;\\n\\n        // While all processes are not finished or system is not in safe state.\\n        while (count < totalProcess) {\\n            boolean foundSafeSystem = false;\\n            for (int m = 0; m < totalProcess; m++) {\\n                if (finishProcesses[m] == false) {\\n                    int j;\\n\\n                    for (j = 0; j < totalResources; j++) {\\n                        if (needArray[m][j] > workArray[j]) {\\n                            break;\\n                        }\\n                    }\\n\\n                    if (j == totalResources) {\\n                        for (int k = 0; k < totalResources; k++) {\\n                            workArray[k] += allocationArray[m][k];\\n                        }\\n\\n                        safeSequenceArray[count++] = m;\\n\\n                        finishProcesses[m] = true;\\n\\n                        foundSafeSystem = true;\\n                    }\\n                }\\n            }\\n\\n            // If we could not find a next process in safe sequence.\\n            if (foundSafeSystem == false) {\\n                System.out.print(\\\"The system is not in the safe state because lack of resources\\\");\\n                return false;\\n            }\\n        }\\n\\n        System.out.print(\\\"The system is in safe sequence and the sequence is as follows: \\\");\\n        for (int i = 0; i < totalProcess; i++) {\\n            System.out.print(\\\"P\\\" + safeSequenceArray[i] + \\\" \\\");\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * This is main method of Banker's Algorithm\\n     */\\n    public static void main(String[] args) {\\n        int numberOfProcesses, numberOfResources;\\n\\n        Scanner sc = new Scanner(System.in);\\n\\n        System.out.println(\\\"Enter total number of processes\\\");\\n        numberOfProcesses = sc.nextInt();\\n\\n        System.out.println(\\\"Enter total number of resources\\\");\\n        numberOfResources = sc.nextInt();\\n\\n        int processes[] = new int[numberOfProcesses];\\n        for (int i = 0; i < numberOfProcesses; i++) {\\n            processes[i] = i;\\n        }\\n\\n        System.out.println(\\\"--Enter the availability of--\\\");\\n\\n        int availableArray[] = new int[numberOfResources];\\n        for (int i = 0; i < numberOfResources; i++) {\\n            System.out.println(\\\"resource \\\" + i + \\\": \\\");\\n            availableArray[i] = sc.nextInt();\\n        }\\n\\n        System.out.println(\\\"--Enter the maximum matrix--\\\");\\n\\n        int maxArray[][] = new int[numberOfProcesses][numberOfResources];\\n        for (int i = 0; i < numberOfProcesses; i++) {\\n            System.out.println(\\\"For process \\\" + i + \\\": \\\");\\n            for (int j = 0; j < numberOfResources; j++) {\\n                System.out.println(\\\"Enter the maximum instances of resource \\\" + j);\\n                maxArray[i][j] = sc.nextInt();\\n            }\\n        }\\n\\n        System.out.println(\\\"--Enter the allocation matrix--\\\");\\n\\n        int allocationArray[][] = new int[numberOfProcesses][numberOfResources];\\n        for (int i = 0; i < numberOfProcesses; i++) {\\n            System.out.println(\\\"For process \\\" + i + \\\": \\\");\\n            for (int j = 0; j < numberOfResources; j++) {\\n                System.out.println(\\\"Allocated instances of resource \\\" + j);\\n                allocationArray[i][j] = sc.nextInt();\\n            }\\n        }\\n\\n        checkSafeSystem(processes, availableArray, maxArray, allocationArray, numberOfProcesses, numberOfResources);\\n\\n        sc.close();\\n    }\\n}\\n\\n/*\\n    Example: \\n    n = 5\\n    m = 3\\n\\n    Process     Allocation      Max       Available\\n                0   1   2    0   1   2    0   1   2\\n\\n        0       0   1   0    7   5   3    3   3   2\\n        1       2   0   0    3   2   2 \\n        2       3   0   2    9   0   2\\n        3       2   1   1    2   2   2\\n        4       0   0   2    4   3   3\\n\\n    Result: The system is in safe sequence and the sequence is as follows: P1, P3, P4, P0, P2 \\n */\\n\"",
    "best fit": "\"package com.thealgorithms.others;\\n\\nimport java.util.ArrayList;\\n\\n/**\\n * @author Dekas Dimitrios\\n */\\npublic class BestFit {\\n\\n    private static final int NO_ALLOCATION\\n            = -255; // if a process has been allocated in position -255,\\n    // it means that it has not been actually allocated.\\n\\n    /**\\n     * Method to find the maximum valued element of an array filled with\\n     * positive integers.\\n     *\\n     * @param array: an array filled with positive integers.\\n     * @return the maximum valued element of the array.\\n     */\\n    private static int findMaxElement(int[] array) {\\n        int max = -1;\\n        for (int value : array) {\\n            if (value > max) {\\n                max = value;\\n            }\\n        }\\n        return max;\\n    }\\n\\n    /**\\n     * Method to find the index of the memory block that is going to fit the\\n     * given process based on the best fit algorithm.\\n     *\\n     * @param blocks: the array with the available memory blocks.\\n     * @param process: the size of the process.\\n     * @return the index of the block that fits, or -255 if no such block\\n     * exists.\\n     */\\n    private static int findBestFit(int[] blockSizes, int processSize) {\\n        // Initialize minDiff with an unreachable value by a difference between a blockSize and the\\n        // processSize.\\n        int minDiff = findMaxElement(blockSizes);\\n        int index\\n                = NO_ALLOCATION; // If there is no block that can fit the process, return NO_ALLOCATION as the\\n        // result.\\n        for (int i = 0;\\n                i < blockSizes.length;\\n                i++) { // Find the most fitting memory block for the given process.\\n            if (blockSizes[i] - processSize < minDiff && blockSizes[i] - processSize >= 0) {\\n                minDiff = blockSizes[i] - processSize;\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Method to allocate memory to blocks according to the best fit algorithm.\\n     * It should return an ArrayList of Integers, where the index is the process\\n     * ID (zero-indexed) and the value is the block number (also zero-indexed).\\n     *\\n     * @param sizeOfBlocks: an int array that contains the sizes of the memory\\n     * blocks available.\\n     * @param sizeOfProcesses: an int array that contains the sizes of the\\n     * processes we need memory blocks for.\\n     * @return the ArrayList filled with Integers repressenting the memory\\n     * allocation that took place.\\n     */\\n    static ArrayList<Integer> bestFit(int[] sizeOfBlocks, int[] sizeOfProcesses) {\\n        // The array list responsible for saving the memory allocations done by the best-fit algorithm\\n        ArrayList<Integer> memAlloc = new ArrayList<>();\\n        // Do this for every process\\n        for (int processSize : sizeOfProcesses) {\\n            int chosenBlockIdx\\n                    = findBestFit(\\n                            sizeOfBlocks, processSize); // Find the index of the memory block going to be used\\n            memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list\\n            if (chosenBlockIdx\\n                    != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,\\n                sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size\\n            }\\n        }\\n        return memAlloc;\\n    }\\n\\n    /**\\n     * Method to print the memory allocated.\\n     *\\n     * @param memAllocation: an ArrayList of Integer representing the memory\\n     * allocation done by the bestFit method.\\n     */\\n    public static void printMemoryAllocation(ArrayList<Integer> memAllocation) {\\n        System.out.println(\\\"Process No.\\\\tBlock No.\\\");\\n        System.out.println(\\\"===========\\\\t=========\\\");\\n        for (int i = 0; i < memAllocation.size(); i++) {\\n            System.out.print(\\\" \\\" + i + \\\"\\\\t\\\\t\\\");\\n            if (memAllocation.get(i) != NO_ALLOCATION) {\\n                System.out.print(memAllocation.get(i));\\n            } else {\\n                System.out.print(\\\"Not Allocated\\\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n}\\n\"",
    "b f p r t": "\"package com.thealgorithms.others;\\n\\nimport java.util.Arrays;\\n\\n/**\\n * BFPRT algorithm.\\n */\\npublic class BFPRT {\\n\\n    public static int[] getMinKNumsByBFPRT(int[] arr, int k) {\\n        if (k < 1 || k > arr.length) {\\n            return null;\\n        }\\n        int minKth = getMinKthByBFPRT(arr, k);\\n        int[] res = new int[k];\\n        int index = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] < minKth) {\\n                res[index++] = arr[i];\\n            }\\n        }\\n        for (; index != res.length; index++) {\\n            res[index] = minKth;\\n        }\\n        return res;\\n    }\\n\\n    public static int getMinKthByBFPRT(int[] arr, int k) {\\n        int[] copyArr = copyArray(arr);\\n        return bfprt(copyArr, 0, copyArr.length - 1, k - 1);\\n    }\\n\\n    public static int[] copyArray(int[] arr) {\\n        int[] copyArr = new int[arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            copyArr[i] = arr[i];\\n        }\\n        return copyArr;\\n    }\\n\\n    public static int bfprt(int[] arr, int begin, int end, int i) {\\n        if (begin == end) {\\n            return arr[begin];\\n        }\\n        int pivot = medianOfMedians(arr, begin, end);\\n        int[] pivotRange = partition(arr, begin, end, pivot);\\n        if (i >= pivotRange[0] && i <= pivotRange[1]) {\\n            return arr[i];\\n        } else if (i < pivotRange[0]) {\\n            return bfprt(arr, begin, pivotRange[0] - 1, i);\\n        } else {\\n            return bfprt(arr, pivotRange[1] + 1, end, i);\\n        }\\n    }\\n\\n    /**\\n     * wikipedia: https://en.wikipedia.org/wiki/Median_of_medians .\\n     *\\n     * @param arr an array.\\n     * @param begin begin num.\\n     * @param end end num.\\n     * @return median of medians.\\n     */\\n    public static int medianOfMedians(int[] arr, int begin, int end) {\\n        int num = end - begin + 1;\\n        int offset = num % 5 == 0 ? 0 : 1;\\n        int[] mArr = new int[num / 5 + offset];\\n        for (int i = 0; i < mArr.length; i++) {\\n            mArr[i] = getMedian(arr, begin + i * 5, Math.min(end, begin + i * 5 + 4));\\n        }\\n        return bfprt(mArr, 0, mArr.length - 1, mArr.length / 2);\\n    }\\n\\n    public static void swap(int[] arr, int i, int j) {\\n        int swap = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = swap;\\n    }\\n\\n    public static int[] partition(int[] arr, int begin, int end, int num) {\\n        int small = begin - 1;\\n        int cur = begin;\\n        int big = end + 1;\\n        while (cur != big) {\\n            if (arr[cur] < num) {\\n                swap(arr, ++small, cur++);\\n            } else if (arr[cur] > num) {\\n                swap(arr, --big, cur);\\n            } else {\\n                cur++;\\n            }\\n        }\\n        int[] pivotRange = new int[2];\\n        pivotRange[0] = small + 1;\\n        pivotRange[1] = big - 1;\\n        return pivotRange;\\n    }\\n\\n    public static int getMedian(int[] arr, int begin, int end) {\\n        insertionSort(arr, begin, end);\\n        int sum = begin + end;\\n        int mid = sum / 2 + (sum % 2);\\n        return arr[mid];\\n    }\\n\\n    public static void insertionSort(int[] arr, int begin, int end) {\\n        if (arr == null || arr.length < 2) {\\n            return;\\n        }\\n        for (int i = begin + 1; i != end + 1; i++) {\\n            for (int j = i; j != begin; j--) {\\n                if (arr[j - 1] > arr[j]) {\\n                    swap(arr, j - 1, j);\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] arr = {11, 9, 1, 3, 9, 2, 2, 5, 6, 5, 3, 5, 9, 7, 2, 5, 5, 1, 9};\\n        int[] minK = getMinKNumsByBFPRT(arr, 5);\\n        System.out.println(Arrays.toString(minK));\\n    }\\n}\\n\"",
    "boyer moore": "\"/* this Code is the illustration of Boyer moore's voting algorithm to\\nfind the majority element is an array that appears more than n/2 times in an array\\nwhere \\\"n\\\" is the length of the array.\\nFor more information on the algorithm refer https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\\n */\\npackage com.thealgorithms.others;\\n\\nimport java.util.*;\\n\\npublic class BoyerMoore {\\n\\n    public static int findmajor(int[] a) {\\n        int count = 0;\\n        int cand = -1;\\n        for (int i = 0; i < a.length; i++) {\\n            if (count == 0) {\\n                cand = a[i];\\n                count = 1;\\n            } else {\\n                if (a[i] == cand) {\\n                    count++;\\n                } else {\\n                    count--;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == cand) {\\n                count++;\\n            }\\n        }\\n        if (count > (a.length / 2)) {\\n            return cand;\\n        }\\n        return -1;\\n    }\\n\\n    public static void main(String args[]) {\\n        Scanner input = new Scanner(System.in);\\n        int n = input.nextInt();\\n        int a[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            a[i] = input.nextInt();\\n        }\\n        System.out.println(\\\"the majority element is \\\" + findmajor(a));\\n\\n    }\\n}\\n\"",
    "brian kernighan algorithm": "\"package com.thealgorithms.others;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * @author Nishita Aggarwal\\n * <p>\\n * Brian Kernighan’s Algorithm\\n * <p>\\n * algorithm to count the number of set bits in a given number\\n * <p>\\n * Subtraction of 1 from a number toggles all the bits (from right to left) till\\n * the rightmost set bit(including the rightmost set bit). So if we subtract a\\n * number by 1 and do bitwise & with itself i.e. (n & (n-1)), we unset the\\n * rightmost set bit.\\n * <p>\\n * If we do n & (n-1) in a loop and count the no of times loop executes we get\\n * the set bit count.\\n * <p>\\n * <p>\\n * Time Complexity: O(logn)\\n */\\npublic class BrianKernighanAlgorithm {\\n\\n    /**\\n     * @param num: number in which we count the set bits\\n     * @return int: Number of set bits\\n     */\\n    static int countSetBits(int num) {\\n        int cnt = 0;\\n        while (num != 0) {\\n            num = num & (num - 1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n\\n    /**\\n     * @param args : command line arguments\\n     */\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n        int num = sc.nextInt();\\n        int setBitCount = countSetBits(num);\\n        System.out.println(setBitCount);\\n        sc.close();\\n    }\\n}\\n\"",
    "count char": "\"package com.thealgorithms.others;\\n\\nimport java.util.Scanner;\\n\\npublic class CountChar {\\n\\n    public static void main(String[] args) {\\n        Scanner input = new Scanner(System.in);\\n        System.out.print(\\\"Enter your text: \\\");\\n        String str = input.nextLine();\\n        input.close();\\n        System.out.println(\\\"There are \\\" + CountCharacters(str) + \\\" characters.\\\");\\n    }\\n\\n    /**\\n     * Count non space character in string\\n     *\\n     * @param str String to count the characters\\n     * @return number of character in the specified string\\n     */\\n    private static int CountCharacters(String str) {\\n        return str.replaceAll(\\\"\\\\\\\\s\\\", \\\"\\\").length();\\n    }\\n}\\n\"",
    "count words": "\"package com.thealgorithms.others;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * You enter a string into this program, and it will return how many words were\\n * in that particular string\\n *\\n * @author Marcus\\n */\\npublic class CountWords {\\n\\n    public static void main(String[] args) {\\n        Scanner input = new Scanner(System.in);\\n        System.out.println(\\\"Enter your text: \\\");\\n        String str = input.nextLine();\\n\\n        System.out.println(\\\"Your text has \\\" + wordCount(str) + \\\" word(s)\\\");\\n        System.out.println(\\\"Your text has \\\" + secondaryWordCount(str) + \\\" word(s)\\\");\\n        input.close();\\n    }\\n\\n    private static int wordCount(String s) {\\n        if (s == null || s.isEmpty()) {\\n            return 0;\\n        }\\n        return s.trim().split(\\\"[\\\\\\\\s]+\\\").length;\\n    }\\n\\n    /**\\n     * counts the number of words in a sentence but ignores all potential\\n     * non-alphanumeric characters that do not represent a word. runs in O(n)\\n     * where n is the length of s\\n     *\\n     * @param s String: sentence with word(s)\\n     * @return int: number of words\\n     */\\n    private static int secondaryWordCount(String s) {\\n        if (s == null || s.isEmpty()) {\\n            return 0;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (Character.isLetter(c) || Character.isDigit(c)) {\\n                sb.append(c);\\n            }\\n        }\\n        s = sb.toString();\\n        return s.trim().split(\\\"[\\\\\\\\s]+\\\").length;\\n    }\\n}\\n\"",
    "crc32": "\"package com.thealgorithms.others;\\n\\nimport java.util.BitSet;\\n\\n/**\\n * Generates a crc32 checksum for a given string or byte array\\n */\\npublic class CRC32 {\\n\\n    public static void main(String[] args) {\\n        System.out.println(Integer.toHexString(crc32(\\\"Hello World\\\")));\\n    }\\n\\n    public static int crc32(String str) {\\n        return crc32(str.getBytes());\\n    }\\n\\n    public static int crc32(byte[] data) {\\n        BitSet bitSet = BitSet.valueOf(data);\\n        int crc32 = 0xFFFFFFFF; // initial value\\n        for (int i = 0; i < data.length * 8; i++) {\\n            if (((crc32 >>> 31) & 1) != (bitSet.get(i) ? 1 : 0)) {\\n                crc32 = (crc32 << 1) ^ 0x04C11DB7; // xor with polynomial\\n            } else {\\n                crc32 = (crc32 << 1);\\n            }\\n        }\\n        crc32 = Integer.reverse(crc32); // result reflect\\n        return crc32 ^ 0xFFFFFFFF; // final xor value\\n    }\\n}\\n\"",
    "crc algorithm": "\"package com.thealgorithms.others;\\n\\nimport java.util.ArrayList;\\nimport java.util.Random;\\nimport java.util.concurrent.ThreadLocalRandom;\\n\\n/**\\n * @author dimgrichr\\n */\\npublic class CRCAlgorithm {\\n\\n    private int correctMess;\\n\\n    private int wrongMess;\\n\\n    private int wrongMessCaught;\\n\\n    private int wrongMessNotCaught;\\n\\n    private int messSize;\\n\\n    private double ber;\\n\\n    private boolean messageChanged;\\n\\n    private ArrayList<Integer> message;\\n\\n    private ArrayList<Integer> dividedMessage;\\n\\n    private ArrayList<Integer> p;\\n\\n    private Random randomGenerator;\\n\\n    /**\\n     * The algorithm's main constructor. The most significant variables, used in\\n     * the algorithm, are set in their initial values.\\n     *\\n     * @param str The binary number P, in a string form, which is used by the\\n     * CRC algorithm\\n     * @param size The size of every transmitted message\\n     * @param ber The Bit Error Rate\\n     */\\n    public CRCAlgorithm(String str, int size, double ber) {\\n        messageChanged = false;\\n        message = new ArrayList<>();\\n        messSize = size;\\n        dividedMessage = new ArrayList<>();\\n        p = new ArrayList<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            p.add(Character.getNumericValue(str.charAt(i)));\\n        }\\n        randomGenerator = new Random();\\n        correctMess = 0;\\n        wrongMess = 0;\\n        wrongMessCaught = 0;\\n        wrongMessNotCaught = 0;\\n        this.ber = ber;\\n    }\\n\\n    /**\\n     * Returns the counter wrongMess\\n     *\\n     * @return wrongMess, the number of Wrong Messages\\n     */\\n    public int getWrongMess() {\\n        return wrongMess;\\n    }\\n\\n    /**\\n     * Returns the counter wrongMessCaught\\n     *\\n     * @return wrongMessCaught, the number of wrong messages, which are caught\\n     * by the CRC algoriithm\\n     */\\n    public int getWrongMessCaught() {\\n        return wrongMessCaught;\\n    }\\n\\n    /**\\n     * Returns the counter wrongMessNotCaught\\n     *\\n     * @return wrongMessNotCaught, the number of wrong messages, which are not\\n     * caught by the CRC algorithm\\n     */\\n    public int getWrongMessNotCaught() {\\n        return wrongMessNotCaught;\\n    }\\n\\n    /**\\n     * Returns the counter correctMess\\n     *\\n     * @return correctMess, the number of the Correct Messages\\n     */\\n    public int getCorrectMess() {\\n        return correctMess;\\n    }\\n\\n    /**\\n     * Resets some of the object's values, used on the main function, so that it\\n     * can be re-used, in order not to waste too much memory and time, by\\n     * creating new objects.\\n     */\\n    public void refactor() {\\n        messageChanged = false;\\n        message = new ArrayList<>();\\n        dividedMessage = new ArrayList<>();\\n    }\\n\\n    /**\\n     * Random messages, consisted of 0's and 1's, are generated, so that they\\n     * can later be transmitted\\n     */\\n    public void generateRandomMess() {\\n        for (int i = 0; i < messSize; i++) {\\n            int x = ThreadLocalRandom.current().nextInt(0, 2);\\n            message.add(x);\\n        }\\n    }\\n\\n    /**\\n     * The most significant part of the CRC algorithm. The message is divided by\\n     * P, so the dividedMessage ArrayList<Integer> is created. If check == true,\\n     * the dividedMessaage is examined, in order to see if it contains any 1's.\\n     * If it does, the message is considered to be wrong by the receiver,so the\\n     * variable wrongMessCaught changes. If it does not, it is accepted, so one\\n     * of the variables correctMess, wrongMessNotCaught, changes. If check ==\\n     * false, the diviided Message is added at the end of the ArrayList<integer>\\n     * message.\\n     *\\n     * @param check the variable used to determine, if the message is going to\\n     * be checked from the receiver if true, it is checked otherwise, it is not\\n     */\\n    public void divideMessageWithP(boolean check) {\\n        ArrayList<Integer> x = new ArrayList<>();\\n        ArrayList<Integer> k = (ArrayList<Integer>) message.clone();\\n        if (!check) {\\n            for (int i = 0; i < p.size() - 1; i++) {\\n                k.add(0);\\n            }\\n        }\\n        while (!k.isEmpty()) {\\n            while (x.size() < p.size() && !k.isEmpty()) {\\n                x.add(k.get(0));\\n                k.remove(0);\\n            }\\n            if (x.size() == p.size()) {\\n                for (int i = 0; i < p.size(); i++) {\\n                    if (x.get(i) == p.get(i)) {\\n                        x.set(i, 0);\\n                    } else {\\n                        x.set(i, 1);\\n                    }\\n                }\\n                for (int i = 0; i < x.size() && x.get(i) != 1; i++) {\\n                    x.remove(0);\\n                }\\n            }\\n        }\\n        dividedMessage = (ArrayList<Integer>) x.clone();\\n        if (!check) {\\n            for (int z : dividedMessage) {\\n                message.add(z);\\n            }\\n        } else {\\n            if (dividedMessage.contains(1) && messageChanged) {\\n                wrongMessCaught++;\\n            } else if (!dividedMessage.contains(1) && messageChanged) {\\n                wrongMessNotCaught++;\\n            } else if (!messageChanged) {\\n                correctMess++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Once the message is transmitted, some of it's elements, is possible to\\n     * change from 1 to 0, or from 0 to 1, because of the Bit Error Rate (ber).\\n     * For every element of the message, a random double number is created. If\\n     * that number is smaller than ber, then the spesific element changes. On\\n     * the other hand, if it's bigger than ber, it does not. Based on these\\n     * changes. the boolean variable messageChanged, gets the value: true, or\\n     * false.\\n     */\\n    public void changeMess() {\\n        for (int y : message) {\\n            double x = randomGenerator.nextDouble();\\n            while (x < 0.0000 || x > 1.00000) {\\n                x = randomGenerator.nextDouble();\\n            }\\n            if (x < ber) {\\n                messageChanged = true;\\n                if (y == 1) {\\n                    message.set(message.indexOf(y), 0);\\n                } else {\\n                    message.set(message.indexOf(y), 1);\\n                }\\n            }\\n        }\\n        if (messageChanged) {\\n            wrongMess++;\\n        }\\n    }\\n}\\n\"",
    "damm": "\"package com.thealgorithms.others;\\n\\nimport java.util.Objects;\\n\\n/**\\n * Damm algorithm is a check digit algorithm that detects all single-digit\\n * errors and all adjacent transposition errors. It was presented by H. Michael\\n * Damm in 2004. Essential part of the algorithm is a quasigroup of order 10\\n * (i.e. having a 10 × 10 Latin square as the body of its operation table) with\\n * the special feature of being weakly totally anti-symmetric. Damm revealed\\n * several methods to create totally anti-symmetric quasigroups of order 10 and\\n * gave some examples in his doctoral dissertation.\\n *\\n * @see <a href=\\\"https://en.wikipedia.org/wiki/Damm_algorithm\\\">Wiki. Damm\\n * algorithm</a>\\n */\\npublic class Damm {\\n\\n    /**\\n     * Weakly totally anti-symmetric quasigroup of order 10. This table is not\\n     * the only possible realisation of weak totally anti-symmetric quasigroup\\n     * but the most common one (taken from Damm doctoral dissertation). All\\n     * zeros lay on the diagonal because it simplifies the check digit\\n     * calculation.\\n     */\\n    private static final byte[][] DAMM_TABLE = {\\n        {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},\\n        {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},\\n        {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},\\n        {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},\\n        {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},\\n        {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},\\n        {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},\\n        {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},\\n        {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},\\n        {2, 5, 8, 1, 4, 3, 6, 7, 9, 0}\\n    };\\n\\n    /**\\n     * Check input digits by Damm algorithm.\\n     *\\n     * @param digits input to check\\n     * @return true if check was successful, false otherwise\\n     * @throws IllegalArgumentException if input parameter contains not only\\n     * digits\\n     * @throws NullPointerException if input is null\\n     */\\n    public static boolean dammCheck(String digits) {\\n        checkInput(digits);\\n        int[] numbers = toIntArray(digits);\\n\\n        int checksum = 0;\\n        for (int number : numbers) {\\n            checksum = DAMM_TABLE[checksum][number];\\n        }\\n\\n        return checksum == 0;\\n    }\\n\\n    /**\\n     * Calculate check digit for initial digits and add it tho the last\\n     * position.\\n     *\\n     * @param initialDigits initial value\\n     * @return digits with the checksum in the last position\\n     * @throws IllegalArgumentException if input parameter contains not only\\n     * digits\\n     * @throws NullPointerException if input is null\\n     */\\n    public static String addDammChecksum(String initialDigits) {\\n        checkInput(initialDigits);\\n        int[] numbers = toIntArray(initialDigits);\\n\\n        int checksum = 0;\\n        for (int number : numbers) {\\n            checksum = DAMM_TABLE[checksum][number];\\n        }\\n\\n        return initialDigits + checksum;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(\\\"Damm algorithm usage examples:\\\");\\n        var validInput = \\\"5724\\\";\\n        var invalidInput = \\\"5824\\\";\\n        checkAndPrint(validInput);\\n        checkAndPrint(invalidInput);\\n\\n        System.out.println(\\\"\\\\nCheck digit generation example:\\\");\\n        var input = \\\"572\\\";\\n        generateAndPrint(input);\\n    }\\n\\n    private static void checkAndPrint(String input) {\\n        String validationResult = Damm.dammCheck(input)\\n                ? \\\"valid\\\"\\n                : \\\"not valid\\\";\\n        System.out.println(\\\"Input '\\\" + input + \\\"' is \\\" + validationResult);\\n    }\\n\\n    private static void generateAndPrint(String input) {\\n        String result = addDammChecksum(input);\\n        System.out.println(\\\"Generate and add checksum to initial value '\\\" + input + \\\"'. Result: '\\\" + result + \\\"'\\\");\\n    }\\n\\n    private static void checkInput(String input) {\\n        Objects.requireNonNull(input);\\n        if (!input.matches(\\\"\\\\\\\\d+\\\")) {\\n            throw new IllegalArgumentException(\\\"Input '\\\" + input + \\\"' contains not only digits\\\");\\n        }\\n    }\\n\\n    private static int[] toIntArray(String string) {\\n        return string.chars()\\n                .map(i -> Character.digit(i, 10))\\n                .toArray();\\n    }\\n}\\n\"",
    "dijkstra": "\"package com.thealgorithms.others;\\n\\n/**\\n * Dijkstra's algorithm,is a graph search algorithm that solves the\\n * single-source shortest path problem for a graph with nonnegative edge path\\n * costs, producing a shortest path tree.\\n *\\n * <p>\\n * NOTE: The inputs to Dijkstra's algorithm are a directed and weighted graph\\n * consisting of 2 or more nodes, generally represented by an adjacency matrix\\n * or list, and a start node.\\n *\\n * <p>\\n * Original source of code:\\n * https://rosettacode.org/wiki/Dijkstra%27s_algorithm#Java Also most of the\\n * comments are from RosettaCode.\\n */\\nimport java.util.*;\\n\\npublic class Dijkstra {\\n\\n    private static final Graph.Edge[] GRAPH = {\\n        // Distance from node \\\"a\\\" to node \\\"b\\\" is 7.\\n        // In the current Graph there is no way to move the other way (e,g, from \\\"b\\\" to \\\"a\\\"),\\n        // a new edge would be needed for that\\n        new Graph.Edge(\\\"a\\\", \\\"b\\\", 7),\\n        new Graph.Edge(\\\"a\\\", \\\"c\\\", 9),\\n        new Graph.Edge(\\\"a\\\", \\\"f\\\", 14),\\n        new Graph.Edge(\\\"b\\\", \\\"c\\\", 10),\\n        new Graph.Edge(\\\"b\\\", \\\"d\\\", 15),\\n        new Graph.Edge(\\\"c\\\", \\\"d\\\", 11),\\n        new Graph.Edge(\\\"c\\\", \\\"f\\\", 2),\\n        new Graph.Edge(\\\"d\\\", \\\"e\\\", 6),\\n        new Graph.Edge(\\\"e\\\", \\\"f\\\", 9),};\\n    private static final String START = \\\"a\\\";\\n    private static final String END = \\\"e\\\";\\n\\n    /**\\n     * main function Will run the code with \\\"GRAPH\\\" that was defined above.\\n     */\\n    public static void main(String[] args) {\\n        Graph g = new Graph(GRAPH);\\n        g.dijkstra(START);\\n        g.printPath(END);\\n        // g.printAllPaths();\\n    }\\n}\\n\\nclass Graph {\\n    // mapping of vertex names to Vertex objects, built from a set of Edges\\n\\n    private final Map<String, Vertex> graph;\\n\\n    /**\\n     * One edge of the graph (only used by Graph constructor)\\n     */\\n    public static class Edge {\\n\\n        public final String v1, v2;\\n        public final int dist;\\n\\n        public Edge(String v1, String v2, int dist) {\\n            this.v1 = v1;\\n            this.v2 = v2;\\n            this.dist = dist;\\n        }\\n    }\\n\\n    /**\\n     * One vertex of the graph, complete with mappings to neighbouring vertices\\n     */\\n    public static class Vertex implements Comparable<Vertex> {\\n\\n        public final String name;\\n        // MAX_VALUE assumed to be infinity\\n        public int dist = Integer.MAX_VALUE;\\n        public Vertex previous = null;\\n        public final Map<Vertex, Integer> neighbours = new HashMap<>();\\n\\n        public Vertex(String name) {\\n            this.name = name;\\n        }\\n\\n        private void printPath() {\\n            if (this == this.previous) {\\n                System.out.printf(\\\"%s\\\", this.name);\\n            } else if (this.previous == null) {\\n                System.out.printf(\\\"%s(unreached)\\\", this.name);\\n            } else {\\n                this.previous.printPath();\\n                System.out.printf(\\\" -> %s(%d)\\\", this.name, this.dist);\\n            }\\n        }\\n\\n        public int compareTo(Vertex other) {\\n            if (dist == other.dist) {\\n                return name.compareTo(other.name);\\n            }\\n\\n            return Integer.compare(dist, other.dist);\\n        }\\n\\n        @Override\\n        public boolean equals(Object object) {\\n            if (this == object) {\\n                return true;\\n            }\\n            if (object == null || getClass() != object.getClass()) {\\n                return false;\\n            }\\n            if (!super.equals(object)) {\\n                return false;\\n            }\\n\\n            Vertex vertex = (Vertex) object;\\n\\n            if (dist != vertex.dist) {\\n                return false;\\n            }\\n            if (name != null ? !name.equals(vertex.name) : vertex.name != null) {\\n                return false;\\n            }\\n            if (previous != null ? !previous.equals(vertex.previous) : vertex.previous != null) {\\n                return false;\\n            }\\n            if (neighbours != null ? !neighbours.equals(vertex.neighbours) : vertex.neighbours != null) {\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            int result = super.hashCode();\\n            result = 31 * result + (name != null ? name.hashCode() : 0);\\n            result = 31 * result + dist;\\n            result = 31 * result + (previous != null ? previous.hashCode() : 0);\\n            result = 31 * result + (neighbours != null ? neighbours.hashCode() : 0);\\n            return result;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \\\"(\\\" + name + \\\", \\\" + dist + \\\")\\\";\\n        }\\n    }\\n\\n    /**\\n     * Builds a graph from a set of edges\\n     */\\n    public Graph(Edge[] edges) {\\n        graph = new HashMap<>(edges.length);\\n\\n        // one pass to find all vertices\\n        for (Edge e : edges) {\\n            if (!graph.containsKey(e.v1)) {\\n                graph.put(e.v1, new Vertex(e.v1));\\n            }\\n            if (!graph.containsKey(e.v2)) {\\n                graph.put(e.v2, new Vertex(e.v2));\\n            }\\n        }\\n\\n        // another pass to set neighbouring vertices\\n        for (Edge e : edges) {\\n            graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);\\n            // graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected\\n            // graph\\n        }\\n    }\\n\\n    /**\\n     * Runs dijkstra using a specified source vertex\\n     */\\n    public void dijkstra(String startName) {\\n        if (!graph.containsKey(startName)) {\\n            System.err.printf(\\\"Graph doesn't contain start vertex \\\\\\\"%s\\\\\\\"%n\\\", startName);\\n            return;\\n        }\\n        final Vertex source = graph.get(startName);\\n        NavigableSet<Vertex> q = new TreeSet<>();\\n\\n        // set-up vertices\\n        for (Vertex v : graph.values()) {\\n            v.previous = v == source ? source : null;\\n            v.dist = v == source ? 0 : Integer.MAX_VALUE;\\n            q.add(v);\\n        }\\n\\n        dijkstra(q);\\n    }\\n\\n    /**\\n     * Implementation of dijkstra's algorithm using a binary heap.\\n     */\\n    private void dijkstra(final NavigableSet<Vertex> q) {\\n        Vertex u, v;\\n        while (!q.isEmpty()) {\\n            // vertex with shortest distance (first iteration will return source)\\n            u = q.pollFirst();\\n            if (u.dist == Integer.MAX_VALUE) {\\n                break; // we can ignore u (and any other remaining vertices) since they are unreachable\\n            }\\n            // look at distances to each neighbour\\n            for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {\\n                v = a.getKey(); // the neighbour in this iteration\\n\\n                final int alternateDist = u.dist + a.getValue();\\n                if (alternateDist < v.dist) { // shorter path to neighbour found\\n                    q.remove(v);\\n                    v.dist = alternateDist;\\n                    v.previous = u;\\n                    q.add(v);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Prints a path from the source to the specified vertex\\n     */\\n    public void printPath(String endName) {\\n        if (!graph.containsKey(endName)) {\\n            System.err.printf(\\\"Graph doesn't contain end vertex \\\\\\\"%s\\\\\\\"%n\\\", endName);\\n            return;\\n        }\\n\\n        graph.get(endName).printPath();\\n        System.out.println();\\n    }\\n\\n    /**\\n     * Prints the path from the source to every vertex (output order is not\\n     * guaranteed)\\n     */\\n    public void printAllPaths() {\\n        for (Vertex v : graph.values()) {\\n            v.printPath();\\n            System.out.println();\\n        }\\n    }\\n}\\n\"",
    "eulers function": "\"package com.thealgorithms.others;\\n\\n/**\\n * You can read more about Euler's totient function\\n *\\n * <p>\\n * See https://en.wikipedia.org/wiki/Euler%27s_totient_function\\n */\\npublic class EulersFunction {\\n    // This method returns us number of x that (x < n) and gcd(x, n) == 1 in O(sqrt(n)) time\\n    // complexity;\\n\\n    public static int getEuler(int n) {\\n        int result = n;\\n        for (int i = 2; i * i <= n; i++) {\\n            if (n % i == 0) {\\n                while (n % i == 0) {\\n                    n /= i;\\n                }\\n                result -= result / i;\\n            }\\n        }\\n        if (n > 1) {\\n            result -= result / n;\\n        }\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        for (int i = 1; i < 100; i++) {\\n            System.out.println(getEuler(i));\\n        }\\n    }\\n}\\n\"",
    "fibbonaci series": "\"package com.thealgorithms.others;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * Fibonacci sequence, and characterized by the fact that every number after the\\n * first two is the sum of the two preceding ones.\\n *\\n * <p>\\n * Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21,...\\n *\\n * <p>\\n * Source for the explanation: https://en.wikipedia.org/wiki/Fibonacci_number\\n *\\n * Problem Statement: print all Fibonacci numbers that are smaller than your\\n * given input N\\n */\\npublic class FibbonaciSeries {\\n\\n    public static void main(String[] args) {\\n        // Get input from the user\\n        Scanner scan = new Scanner(System.in);\\n        int n = scan.nextInt();\\n        int first = 0, second = 1;\\n        scan.close();\\n        while (first <= n) {\\n            // print first fibo 0 then add second fibo into it while updating second as well\\n            System.out.println(first);\\n            int next = first + second;\\n            first = second;\\n            second = next;\\n        }\\n    }\\n}\\n\"",
    "first fit": "\"package com.thealgorithms.others;\\n\\nimport java.util.ArrayList;\\n\\n/**\\n * @author Dekas Dimitrios\\n */\\npublic class FirstFit {\\n\\n    private static final int NO_ALLOCATION\\n            = -255; // if a process has been allocated in position -255,\\n    // it means that it has not been actually allocated.\\n\\n    /**\\n     * Method to find the index of the memory block that is going to fit the\\n     * given process based on the first fit algorithm.\\n     *\\n     * @param blocks: the array with the available memory blocks.\\n     * @param process: the size of the process.\\n     * @return the index of the block that fits, or -255 if no such block\\n     * exists.\\n     */\\n    private static int findFirstFit(int[] blockSizes, int processSize) {\\n        for (int i = 0; i < blockSizes.length; i++) {\\n            if (blockSizes[i] >= processSize) {\\n                return i;\\n            }\\n        }\\n        // If there is not a block that can fit the process, return -255 as the result\\n        return NO_ALLOCATION;\\n    }\\n\\n    /**\\n     * Method to allocate memory to blocks according to the first fit algorithm.\\n     * It should return an ArrayList of Integers, where the index is the process\\n     * ID (zero-indexed) and the value is the block number (also zero-indexed).\\n     *\\n     * @param sizeOfBlocks: an int array that contains the sizes of the memory\\n     * blocks available.\\n     * @param sizeOfProcesses: an int array that contains the sizes of the\\n     * processes we need memory blocks for.\\n     * @return the ArrayList filled with Integers repressenting the memory\\n     * allocation that took place.\\n     */\\n    static ArrayList<Integer> firstFit(int[] sizeOfBlocks, int[] sizeOfProcesses) {\\n        // The array list responsible for saving the memory allocations done by the first-fit algorithm\\n        ArrayList<Integer> memAlloc = new ArrayList<>();\\n        // Do this for every process\\n        for (int processSize : sizeOfProcesses) {\\n            int chosenBlockIdx\\n                    = findFirstFit(\\n                            sizeOfBlocks, processSize); // Find the index of the memory block going to be used\\n            memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list\\n            if (chosenBlockIdx\\n                    != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,\\n                sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size\\n            }\\n        }\\n        return memAlloc;\\n    }\\n\\n    /**\\n     * Method to print the memory allocated.\\n     *\\n     * @param memAllocation: an ArrayList of Integer representing the memory\\n     * allocation done by the firstFit method.\\n     */\\n    public static void printMemoryAllocation(ArrayList<Integer> memAllocation) {\\n        System.out.println(\\\"Process No.\\\\tBlock No.\\\");\\n        System.out.println(\\\"===========\\\\t=========\\\");\\n        for (int i = 0; i < memAllocation.size(); i++) {\\n            System.out.print(\\\" \\\" + i + \\\"\\\\t\\\\t\\\");\\n            if (memAllocation.get(i) != NO_ALLOCATION) {\\n                System.out.print(memAllocation.get(i));\\n            } else {\\n                System.out.print(\\\"Not Allocated\\\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n}\\n\"",
    "floyd triangle": "\"package com.thealgorithms.others;\\n\\nimport java.util.Scanner;\\n\\nclass FloydTriangle {\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.println(\\\"Enter the number of rows which you want in your Floyd Triangle: \\\");\\n        int r = sc.nextInt(), n = 0;\\n        sc.close();\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                System.out.print(++n + \\\" \\\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n}\\n\"",
    "guass legendre": "\"package com.thealgorithms.others;\\n\\n/**\\n * Guass Legendre Algorithm ref\\n * https://en.wikipedia.org/wiki/Gauss–Legendre_algorithm\\n *\\n * @author AKS1996\\n */\\npublic class GuassLegendre {\\n\\n    public static void main(String[] args) {\\n        for (int i = 1; i <= 3; ++i) {\\n            System.out.println(pi(i));\\n        }\\n    }\\n\\n    static double pi(int l) {\\n        /*\\n     * l: No of loops to run\\n         */\\n\\n        double a = 1, b = Math.pow(2, -0.5), t = 0.25, p = 1;\\n        for (int i = 0; i < l; ++i) {\\n            double temp[] = update(a, b, t, p);\\n            a = temp[0];\\n            b = temp[1];\\n            t = temp[2];\\n            p = temp[3];\\n        }\\n\\n        return Math.pow(a + b, 2) / (4 * t);\\n    }\\n\\n    static double[] update(double a, double b, double t, double p) {\\n        double values[] = new double[4];\\n        values[0] = (a + b) / 2;\\n        values[1] = Math.sqrt(a * b);\\n        values[2] = t - p * Math.pow(a - values[0], 2);\\n        values[3] = 2 * p;\\n\\n        return values;\\n    }\\n}\\n\"",
    "happy numbers seq": "\"package com.thealgorithms.others;\\n\\nimport java.util.Arrays;\\nimport java.util.HashSet;\\nimport java.util.Scanner;\\nimport java.util.Set;\\n\\npublic class HappyNumbersSeq {\\n    private static final Set<Integer> CYCLE_NUMS = new HashSet<>(Arrays.asList(4, 16, 20, 37, 58, 145));\\n\\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in);\\n        System.out.print(\\\"Enter number: \\\");\\n        int n = in.nextInt();\\n        while (n != 1 && !isSad(n)) {\\n            System.out.print(n + \\\" \\\");\\n            n = sumSquares(n);\\n        }\\n        String res = n == 1 ? \\\"1 Happy number\\\" : \\\"Sad number\\\";\\n        System.out.println(res);\\n    }\\n\\n    private static int sumSquares(int n) {\\n        int s = 0;\\n        for (; n > 0; n /= 10) {\\n            int r = n % 10;\\n            s += r * r;\\n        }\\n        return s;\\n    }\\n\\n    private static boolean isSad(int n) {\\n        return CYCLE_NUMS.contains(n);\\n    }\\n}\\n\"",
    "huffman": "\"package com.thealgorithms.others;\\n\\nimport java.util.PriorityQueue;\\nimport java.util.Scanner;\\nimport java.util.Comparator;\\n\\n// node class is the basic structure \\n// of each node present in the Huffman - tree. \\nclass HuffmanNode {\\n\\n    int data;\\n    char c;\\n\\n    HuffmanNode left;\\n    HuffmanNode right;\\n}\\n\\n// comparator class helps to compare the node \\n// on the basis of one of its attribute. \\n// Here we will be compared \\n// on the basis of data values of the nodes. \\nclass MyComparator implements Comparator<HuffmanNode> {\\n\\n    public int compare(HuffmanNode x, HuffmanNode y) {\\n\\n        return x.data - y.data;\\n    }\\n}\\n\\npublic class Huffman {\\n\\n    // recursive function to print the \\n    // huffman-code through the tree traversal. \\n    // Here s is the huffman - code generated. \\n    public static void printCode(HuffmanNode root, String s) {\\n\\n        // base case; if the left and right are null \\n        // then its a leaf node and we print \\n        // the code s generated by traversing the tree. \\n        if (root.left\\n                == null\\n                && root.right\\n                == null\\n                && Character.isLetter(root.c)) {\\n\\n            // c is the character in the node \\n            System.out.println(root.c + \\\":\\\" + s);\\n\\n            return;\\n        }\\n\\n        // if we go to left then add \\\"0\\\" to the code. \\n        // if we go to the right add\\\"1\\\" to the code. \\n        // recursive calls for left and \\n        // right sub-tree of the generated tree. \\n        printCode(root.left, s + \\\"0\\\");\\n        printCode(root.right, s + \\\"1\\\");\\n    }\\n\\n    // main function \\n    public static void main(String[] args) {\\n\\n        Scanner s = new Scanner(System.in);\\n\\n        // number of characters. \\n        int n = 6;\\n        char[] charArray = {'a', 'b', 'c', 'd', 'e', 'f'};\\n        int[] charfreq = {5, 9, 12, 13, 16, 45};\\n\\n        // creating a priority queue q. \\n        // makes a min-priority queue(min-heap). \\n        PriorityQueue<HuffmanNode> q\\n                = new PriorityQueue<HuffmanNode>(n, new MyComparator());\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            // creating a Huffman node object \\n            // and add it to the priority queue. \\n            HuffmanNode hn = new HuffmanNode();\\n\\n            hn.c = charArray[i];\\n            hn.data = charfreq[i];\\n\\n            hn.left = null;\\n            hn.right = null;\\n\\n            // add functions adds \\n            // the huffman node to the queue. \\n            q.add(hn);\\n        }\\n\\n        // create a root node \\n        HuffmanNode root = null;\\n\\n        // Here we will extract the two minimum value \\n        // from the heap each time until \\n        // its size reduces to 1, extract until \\n        // all the nodes are extracted. \\n        while (q.size() > 1) {\\n\\n            // first min extract. \\n            HuffmanNode x = q.peek();\\n            q.poll();\\n\\n            // second min extarct. \\n            HuffmanNode y = q.peek();\\n            q.poll();\\n\\n            // new node f which is equal \\n            HuffmanNode f = new HuffmanNode();\\n\\n            // to the sum of the frequency of the two nodes \\n            // assigning values to the f node. \\n            f.data = x.data + y.data;\\n            f.c = '-';\\n\\n            // first extracted node as left child. \\n            f.left = x;\\n\\n            // second extracted node as the right child. \\n            f.right = y;\\n\\n            // marking the f node as the root node. \\n            root = f;\\n\\n            // add this node to the priority-queue. \\n            q.add(f);\\n        }\\n\\n        // print the codes by traversing the tree \\n        printCode(root, \\\"\\\");\\n    }\\n}\\n\"",
    "implementing auto completing features using trie": "\"package com.thealgorithms.others;\\n\\n// Java Program to implement Auto-Complete \\n// Feature using Trie\\nclass Trieac {\\n\\n    // Alphabet size (# of symbols) \\n    public static final int ALPHABET_SIZE = 26;\\n\\n    // Trie node \\n    static class TrieNode {\\n\\n        TrieNode children[] = new TrieNode[ALPHABET_SIZE];\\n\\n        // isWordEnd is true if the node represents \\n        // end of a word \\n        boolean isWordEnd;\\n    };\\n\\n    // Returns new trie node (initialized to NULLs) \\n    static TrieNode getNode() {\\n        TrieNode pNode = new TrieNode();\\n        pNode.isWordEnd = false;\\n\\n        for (int i = 0; i < ALPHABET_SIZE; i++) {\\n            pNode.children[i] = null;\\n        }\\n\\n        return pNode;\\n    }\\n\\n    // If not present, inserts key into trie. If the \\n    // key is prefix of trie node, just marks leaf node \\n    static void insert(TrieNode root, final String key) {\\n        TrieNode pCrawl = root;\\n\\n        for (int level = 0; level < key.length(); level++) {\\n            int index = (key.charAt(level) - 'a');\\n            if (pCrawl.children[index] == null) {\\n                pCrawl.children[index] = getNode();\\n            }\\n            pCrawl = pCrawl.children[index];\\n        }\\n\\n        // mark last node as leaf \\n        pCrawl.isWordEnd = true;\\n    }\\n\\n    // Returns true if key presents in trie, else false \\n    boolean search(TrieNode root, final String key) {\\n        int length = key.length();\\n        TrieNode pCrawl = root;\\n\\n        for (int level = 0; level < length; level++) {\\n            int index = (key.charAt(level) - 'a');\\n\\n            if (pCrawl.children[index] == null) {\\n                pCrawl = pCrawl.children[index];\\n            }\\n        }\\n\\n        return (pCrawl != null && pCrawl.isWordEnd);\\n    }\\n\\n    // Returns 0 if current node has a child \\n    // If all children are NULL, return 1. \\n    static boolean isLastNode(TrieNode root) {\\n        for (int i = 0; i < ALPHABET_SIZE; i++) {\\n            if (root.children[i] != null) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    // Recursive function to print auto-suggestions \\n    // for given node. \\n    static void suggestionsRec(TrieNode root, String currPrefix) {\\n        // found a string in Trie with the given prefix \\n        if (root.isWordEnd) {\\n            System.out.println(currPrefix);\\n        }\\n\\n        // All children struct node pointers are NULL \\n        if (isLastNode(root)) {\\n            return;\\n        }\\n\\n        for (int i = 0; i < ALPHABET_SIZE; i++) {\\n            if (root.children[i] != null) {\\n                // append current character to currPrefix string \\n                currPrefix += (char) (97 + i);\\n\\n                // recur over the rest \\n                suggestionsRec(root.children[i], currPrefix);\\n            }\\n        }\\n    }\\n\\n    // Fucntion  to print suggestions for\\n    // given query prefix.\\n    static int printAutoSuggestions(TrieNode root,\\n            final String query) {\\n        TrieNode pCrawl = root;\\n\\n        // Check if prefix is present and find the \\n        // the node (of last level) with last character \\n        // of given string. \\n        int level;\\n        int n = query.length();\\n\\n        for (level = 0; level < n; level++) {\\n            int index = (query.charAt(level) - 'a');\\n\\n            // no string in the Trie has this prefix \\n            if (pCrawl.children[index] == null) {\\n                return 0;\\n            }\\n\\n            pCrawl = pCrawl.children[index];\\n        }\\n\\n        // If prefix is present as a word. \\n        boolean isWord = (pCrawl.isWordEnd == true);\\n\\n        // If prefix is last node of tree (has no \\n        // children) \\n        boolean isLast = isLastNode(pCrawl);\\n\\n        // If prefix is present as a word, but \\n        // there is no subtree below the last \\n        // matching node. \\n        if (isWord && isLast) {\\n            System.out.println(query);\\n            return -1;\\n        }\\n\\n        // If there are are nodes below last \\n        // matching character. \\n        if (!isLast) {\\n            String prefix = query;\\n            suggestionsRec(pCrawl, prefix);\\n            return 1;\\n        }\\n\\n        return 0;\\n    }\\n\\n    // Driver code\\n    public static void main(String[] args) {\\n        TrieNode root = getNode();\\n        insert(root, \\\"hello\\\");\\n        insert(root, \\\"dog\\\");\\n        insert(root, \\\"hell\\\");\\n        insert(root, \\\"cat\\\");\\n        insert(root, \\\"a\\\");\\n        insert(root, \\\"hel\\\");\\n        insert(root, \\\"help\\\");\\n        insert(root, \\\"helps\\\");\\n        insert(root, \\\"helping\\\");\\n        int comp = printAutoSuggestions(root, \\\"hel\\\");\\n\\n        if (comp == -1) {\\n            System.out.println(\\\"No other strings found \\\"\\n                    + \\\"with this prefix\\\\n\\\");\\n        } else if (comp == 0) {\\n            System.out.println(\\\"No string found with\\\"\\n                    + \\\" this prefix\\\\n\\\");\\n        }\\n    }\\n}\\n\"",
    "insert delete in array": "\"package com.thealgorithms.others;\\n\\nimport java.util.*;\\n\\npublic class InsertDeleteInArray {\\n\\n    public static void main(String[] args) {\\n        Scanner s = new Scanner(System.in); // Input statement\\n        System.out.println(\\\"Enter the size of the array\\\");\\n        int size = s.nextInt();\\n        int a[] = new int[size];\\n        int i;\\n\\n        // To enter the initial elements\\n        for (i = 0; i < size; i++) {\\n            System.out.println(\\\"Enter the element\\\");\\n            a[i] = s.nextInt();\\n        }\\n\\n        // To insert a new element(we are creating a new array)\\n        System.out.println(\\\"Enter the index at which the element should be inserted\\\");\\n        int insert_pos = s.nextInt();\\n        System.out.println(\\\"Enter the element to be inserted\\\");\\n        int ins = s.nextInt();\\n        int size2 = size + 1;\\n        int b[] = new int[size2];\\n        for (i = 0; i < size2; i++) {\\n            if (i <= insert_pos) {\\n                b[i] = a[i];\\n            } else {\\n                b[i] = a[i - 1];\\n            }\\n        }\\n        b[insert_pos] = ins;\\n        for (i = 0; i < size2; i++) {\\n            System.out.println(b[i]);\\n        }\\n\\n        // To delete an element given the index\\n        System.out.println(\\\"Enter the index at which element is to be deleted\\\");\\n        int del_pos = s.nextInt();\\n        for (i = del_pos; i < size2 - 1; i++) {\\n            b[i] = b[i + 1];\\n        }\\n        for (i = 0; i < size2 - 1; i++) {\\n            System.out.println(b[i]);\\n        }\\n        s.close();\\n    }\\n}\\n\"",
    "kmp": "\"package com.thealgorithms.others;\\n\\n/**\\n * Implementation of Knuth–Morris–Pratt algorithm Usage: see the main function\\n * for an example\\n */\\npublic class KMP {\\n    // a working example\\n\\n    public static void main(String[] args) {\\n        final String haystack = \\\"AAAAABAAABA\\\"; // This is the full string\\n        final String needle = \\\"AAAA\\\"; // This is the substring that we want to find\\n        KMPmatcher(haystack, needle);\\n    }\\n\\n    // find the starting index in string haystack[] that matches the search word P[]\\n    public static void KMPmatcher(final String haystack, final String needle) {\\n        final int m = haystack.length();\\n        final int n = needle.length();\\n        final int[] pi = computePrefixFunction(needle);\\n        int q = 0;\\n        for (int i = 0; i < m; i++) {\\n            while (q > 0 && haystack.charAt(i) != needle.charAt(q)) {\\n                q = pi[q - 1];\\n            }\\n\\n            if (haystack.charAt(i) == needle.charAt(q)) {\\n                q++;\\n            }\\n\\n            if (q == n) {\\n                System.out.println(\\\"Pattern starts: \\\" + (i + 1 - n));\\n                q = pi[q - 1];\\n            }\\n        }\\n    }\\n\\n    // return the prefix function\\n    private static int[] computePrefixFunction(final String P) {\\n        final int n = P.length();\\n        final int[] pi = new int[n];\\n        pi[0] = 0;\\n        int q = 0;\\n        for (int i = 1; i < n; i++) {\\n            while (q > 0 && P.charAt(q) != P.charAt(i)) {\\n                q = pi[q - 1];\\n            }\\n\\n            if (P.charAt(q) == P.charAt(i)) {\\n                q++;\\n            }\\n\\n            pi[i] = q;\\n        }\\n        return pi;\\n    }\\n}\\n\"",
    "koch snowflake": "\"package com.thealgorithms.others;\\n\\nimport java.awt.*;\\nimport java.awt.image.BufferedImage;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.util.ArrayList;\\nimport javax.imageio.ImageIO;\\n\\n/**\\n * The Koch snowflake is a fractal curve and one of the earliest fractals to\\n * have been described. The Koch snowflake can be built up iteratively, in a\\n * sequence of stages. The first stage is an equilateral triangle, and each\\n * successive stage is formed by adding outward bends to each side of the\\n * previous stage, making smaller equilateral triangles. This can be achieved\\n * through the following steps for each line: 1. divide the line segment into\\n * three segments of equal length. 2. draw an equilateral triangle that has the\\n * middle segment from step 1 as its base and points outward. 3. remove the line\\n * segment that is the base of the triangle from step 2. (description adapted\\n * from https://en.wikipedia.org/wiki/Koch_snowflake ) (for a more detailed\\n * explanation and an implementation in the Processing language, see\\n * https://natureofcode.com/book/chapter-8-fractals/\\n * #84-the-koch-curve-and-the-arraylist-technique ).\\n */\\npublic class KochSnowflake {\\n\\n    public static void main(String[] args) {\\n        // Test Iterate-method\\n        ArrayList<Vector2> vectors = new ArrayList<Vector2>();\\n        vectors.add(new Vector2(0, 0));\\n        vectors.add(new Vector2(1, 0));\\n        ArrayList<Vector2> result = Iterate(vectors, 1);\\n\\n        assert result.get(0).x == 0;\\n        assert result.get(0).y == 0;\\n\\n        assert result.get(1).x == 1. / 3;\\n        assert result.get(1).y == 0;\\n\\n        assert result.get(2).x == 1. / 2;\\n        assert result.get(2).y == Math.sin(Math.PI / 3) / 3;\\n\\n        assert result.get(3).x == 2. / 3;\\n        assert result.get(3).y == 0;\\n\\n        assert result.get(4).x == 1;\\n        assert result.get(4).y == 0;\\n\\n        // Test GetKochSnowflake-method\\n        int imageWidth = 600;\\n        double offsetX = imageWidth / 10.;\\n        double offsetY = imageWidth / 3.7;\\n        BufferedImage image = GetKochSnowflake(imageWidth, 5);\\n\\n        // The background should be white\\n        assert image.getRGB(0, 0) == new Color(255, 255, 255).getRGB();\\n\\n        // The snowflake is drawn in black and this is the position of the first vector\\n        assert image.getRGB((int) offsetX, (int) offsetY) == new Color(0, 0, 0).getRGB();\\n\\n        // Save image\\n        try {\\n            ImageIO.write(image, \\\"png\\\", new File(\\\"KochSnowflake.png\\\"));\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n    /**\\n     * Go through the number of iterations determined by the argument \\\"steps\\\".\\n     * Be careful with high values (above 5) since the time to calculate\\n     * increases exponentially.\\n     *\\n     * @param initialVectors The vectors composing the shape to which the\\n     * algorithm is applied.\\n     * @param steps The number of iterations.\\n     * @return The transformed vectors after the iteration-steps.\\n     */\\n    public static ArrayList<Vector2> Iterate(ArrayList<Vector2> initialVectors, int steps) {\\n        ArrayList<Vector2> vectors = initialVectors;\\n        for (int i = 0; i < steps; i++) {\\n            vectors = IterationStep(vectors);\\n        }\\n\\n        return vectors;\\n    }\\n\\n    /**\\n     * Method to render the Koch snowflake to a image.\\n     *\\n     * @param imageWidth The width of the rendered image.\\n     * @param steps The number of iterations.\\n     * @return The image of the rendered Koch snowflake.\\n     */\\n    public static BufferedImage GetKochSnowflake(int imageWidth, int steps) {\\n        if (imageWidth <= 0) {\\n            throw new IllegalArgumentException(\\\"imageWidth should be greater than zero\\\");\\n        }\\n\\n        double offsetX = imageWidth / 10.;\\n        double offsetY = imageWidth / 3.7;\\n        Vector2 vector1 = new Vector2(offsetX, offsetY);\\n        Vector2 vector2\\n                = new Vector2(imageWidth / 2, Math.sin(Math.PI / 3) * imageWidth * 0.8 + offsetY);\\n        Vector2 vector3 = new Vector2(imageWidth - offsetX, offsetY);\\n        ArrayList<Vector2> initialVectors = new ArrayList<Vector2>();\\n        initialVectors.add(vector1);\\n        initialVectors.add(vector2);\\n        initialVectors.add(vector3);\\n        initialVectors.add(vector1);\\n        ArrayList<Vector2> vectors = Iterate(initialVectors, steps);\\n        return GetImage(vectors, imageWidth, imageWidth);\\n    }\\n\\n    /**\\n     * Loops through each pair of adjacent vectors. Each line between two\\n     * adjacent vectors is divided into 4 segments by adding 3 additional\\n     * vectors in-between the original two vectors. The vector in the middle is\\n     * constructed through a 60 degree rotation so it is bent outwards.\\n     *\\n     * @param vectors The vectors composing the shape to which the algorithm is\\n     * applied.\\n     * @return The transformed vectors after the iteration-step.\\n     */\\n    private static ArrayList<Vector2> IterationStep(ArrayList<Vector2> vectors) {\\n        ArrayList<Vector2> newVectors = new ArrayList<Vector2>();\\n        for (int i = 0; i < vectors.size() - 1; i++) {\\n            Vector2 startVector = vectors.get(i);\\n            Vector2 endVector = vectors.get(i + 1);\\n            newVectors.add(startVector);\\n            Vector2 differenceVector = endVector.subtract(startVector).multiply(1. / 3);\\n            newVectors.add(startVector.add(differenceVector));\\n            newVectors.add(startVector.add(differenceVector).add(differenceVector.rotate(60)));\\n            newVectors.add(startVector.add(differenceVector.multiply(2)));\\n        }\\n\\n        newVectors.add(vectors.get(vectors.size() - 1));\\n        return newVectors;\\n    }\\n\\n    /**\\n     * Utility-method to render the Koch snowflake to an image.\\n     *\\n     * @param vectors The vectors defining the edges to be rendered.\\n     * @param imageWidth The width of the rendered image.\\n     * @param imageHeight The height of the rendered image.\\n     * @return The image of the rendered edges.\\n     */\\n    private static BufferedImage GetImage(\\n            ArrayList<Vector2> vectors, int imageWidth, int imageHeight) {\\n        BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);\\n        Graphics2D g2d = image.createGraphics();\\n\\n        // Set the background white\\n        g2d.setBackground(Color.WHITE);\\n        g2d.fillRect(0, 0, imageWidth, imageHeight);\\n\\n        // Draw the edges\\n        g2d.setColor(Color.BLACK);\\n        BasicStroke bs = new BasicStroke(1);\\n        g2d.setStroke(bs);\\n        for (int i = 0; i < vectors.size() - 1; i++) {\\n            int x1 = (int) vectors.get(i).x;\\n            int y1 = (int) vectors.get(i).y;\\n            int x2 = (int) vectors.get(i + 1).x;\\n            int y2 = (int) vectors.get(i + 1).y;\\n\\n            g2d.drawLine(x1, y1, x2, y2);\\n        }\\n\\n        return image;\\n    }\\n\\n    /**\\n     * Inner class to handle the vector calculations.\\n     */\\n    private static class Vector2 {\\n\\n        double x, y;\\n\\n        public Vector2(double x, double y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return String.format(\\\"[%f, %f]\\\", this.x, this.y);\\n        }\\n\\n        /**\\n         * Vector addition\\n         *\\n         * @param vector The vector to be added.\\n         * @return The sum-vector.\\n         */\\n        public Vector2 add(Vector2 vector) {\\n            double x = this.x + vector.x;\\n            double y = this.y + vector.y;\\n            return new Vector2(x, y);\\n        }\\n\\n        /**\\n         * Vector subtraction\\n         *\\n         * @param vector The vector to be subtracted.\\n         * @return The difference-vector.\\n         */\\n        public Vector2 subtract(Vector2 vector) {\\n            double x = this.x - vector.x;\\n            double y = this.y - vector.y;\\n            return new Vector2(x, y);\\n        }\\n\\n        /**\\n         * Vector scalar multiplication\\n         *\\n         * @param scalar The factor by which to multiply the vector.\\n         * @return The scaled vector.\\n         */\\n        public Vector2 multiply(double scalar) {\\n            double x = this.x * scalar;\\n            double y = this.y * scalar;\\n            return new Vector2(x, y);\\n        }\\n\\n        /**\\n         * Vector rotation (see https://en.wikipedia.org/wiki/Rotation_matrix)\\n         *\\n         * @param angleInDegrees The angle by which to rotate the vector.\\n         * @return The rotated vector.\\n         */\\n        public Vector2 rotate(double angleInDegrees) {\\n            double radians = angleInDegrees * Math.PI / 180;\\n            double ca = Math.cos(radians);\\n            double sa = Math.sin(radians);\\n            double x = ca * this.x - sa * this.y;\\n            double y = sa * this.x + ca * this.y;\\n            return new Vector2(x, y);\\n        }\\n    }\\n}\\n\"",
    "krishnamurthy": "\"package com.thealgorithms.others;\\n\\nimport java.util.Scanner;\\n\\nclass Krishnamurthy {\\n\\n    static int fact(int n) {\\n        int i, p = 1;\\n        for (i = n; i >= 1; i--) {\\n            p = p * i;\\n        }\\n        return p;\\n    }\\n\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n        int a, b, s = 0;\\n        System.out.print(\\\"Enter the number : \\\");\\n        a = sc.nextInt();\\n        int n = a;\\n        while (a > 0) {\\n            b = a % 10;\\n            s = s + fact(b);\\n            a = a / 10;\\n        }\\n        if (s == n) {\\n            System.out.print(n + \\\" is a krishnamurthy number\\\");\\n        } else {\\n            System.out.print(n + \\\" is not a krishnamurthy number\\\");\\n        }\\n        sc.close();\\n    }\\n}\\n\"",
    "linear congruential generator": "\"package com.thealgorithms.others;\\n\\n/**\\n * *\\n * A pseudorandom number generator.\\n *\\n * @author Tobias Carryer\\n * @date October 10, 2017\\n */\\npublic class LinearCongruentialGenerator {\\n\\n    private double a, c, m, previousValue;\\n\\n    /**\\n     * *\\n     * These parameters are saved and used when nextNumber() is called. The\\n     * current timestamp in milliseconds is used as the seed.\\n     *\\n     * @param multiplier\\n     * @param increment\\n     * @param modulo The maximum number that can be generated (exclusive). A\\n     * common value is 2^32.\\n     */\\n    public LinearCongruentialGenerator(double multiplier, double increment, double modulo) {\\n        this(System.currentTimeMillis(), multiplier, increment, modulo);\\n    }\\n\\n    /**\\n     * *\\n     * These parameters are saved and used when nextNumber() is called.\\n     *\\n     * @param seed\\n     * @param multiplier\\n     * @param increment\\n     * @param modulo The maximum number that can be generated (exclusive). A\\n     * common value is 2^32.\\n     */\\n    public LinearCongruentialGenerator(\\n            double seed, double multiplier, double increment, double modulo) {\\n        this.previousValue = seed;\\n        this.a = multiplier;\\n        this.c = increment;\\n        this.m = modulo;\\n    }\\n\\n    /**\\n     * The smallest number that can be generated is zero. The largest number\\n     * that can be generated is modulo-1. modulo is set in the constructor.\\n     *\\n     * @return a pseudorandom number.\\n     */\\n    public double nextNumber() {\\n        previousValue = (a * previousValue + c) % m;\\n        return previousValue;\\n    }\\n\\n    public static void main(String[] args) {\\n        // Show the LCG in action.\\n        // Decisive proof that the LCG works could be made by adding each number\\n        // generated to a Set while checking for duplicates.\\n        LinearCongruentialGenerator lcg\\n                = new LinearCongruentialGenerator(1664525, 1013904223, Math.pow(2.0, 32.0));\\n        for (int i = 0; i < 512; i++) {\\n            System.out.println(lcg.nextNumber());\\n        }\\n    }\\n}\\n\"",
    "lowest base palindrome": "\"package com.thealgorithms.others;\\n\\nimport java.util.InputMismatchException;\\nimport java.util.Scanner;\\n\\n/**\\n * Class for finding the lowest base in which a given integer is a palindrome.\\n * Includes auxiliary methods for converting between bases and reversing\\n * strings.\\n *\\n * <p>\\n * NOTE: There is potential for error, see note at line 63.\\n *\\n * @author RollandMichael\\n * @version 2017.09.28\\n */\\npublic class LowestBasePalindrome {\\n\\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in);\\n        int n = 0;\\n        while (true) {\\n            try {\\n                System.out.print(\\\"Enter number: \\\");\\n                n = in.nextInt();\\n                break;\\n            } catch (InputMismatchException e) {\\n                System.out.println(\\\"Invalid input!\\\");\\n                in.next();\\n            }\\n        }\\n        System.out.println(n + \\\" is a palindrome in base \\\" + lowestBasePalindrome(n));\\n        System.out.println(base2base(Integer.toString(n), 10, lowestBasePalindrome(n)));\\n        in.close();\\n    }\\n\\n    /**\\n     * Given a number in base 10, returns the lowest base in which the number is\\n     * represented by a palindrome (read the same left-to-right and\\n     * right-to-left).\\n     *\\n     * @param num A number in base 10.\\n     * @return The lowest base in which num is a palindrome.\\n     */\\n    public static int lowestBasePalindrome(int num) {\\n        int base, num2 = num;\\n        int digit;\\n        char digitC;\\n        boolean foundBase = false;\\n        String newNum = \\\"\\\";\\n        String digits = \\\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\";\\n\\n        while (!foundBase) {\\n            // Try from bases 2 to num-1\\n            for (base = 2; base < num2; base++) {\\n                newNum = \\\"\\\";\\n                while (num > 0) {\\n                    // Obtain the first digit of n in the current base,\\n                    // which is equivalent to the integer remainder of (n/base).\\n                    // The next digit is obtained by dividing n by the base and\\n                    // continuing the process of getting the remainder. This is done\\n                    // until n is <=0 and the number in the new base is obtained.\\n                    digit = (num % base);\\n                    num /= base;\\n                    // If the digit isn't in the set of [0-9][A-Z] (beyond base 36), its character\\n                    // form is just its value in ASCII.\\n\\n                    // NOTE: This may cause problems, as the capital letters are ASCII values\\n                    // 65-90. It may cause false positives when one digit is, for instance 10 and assigned\\n                    // 'A' from the character array and the other is 65 and also assigned 'A'.\\n                    // Regardless, the character is added to the representation of n\\n                    // in the current base.\\n                    if (digit >= digits.length()) {\\n                        digitC = (char) (digit);\\n                        newNum += digitC;\\n                        continue;\\n                    }\\n                    newNum += digits.charAt(digit);\\n                }\\n                // Num is assigned back its original value for the next iteration.\\n                num = num2;\\n                // Auxiliary method reverses the number.\\n                String reverse = reverse(newNum);\\n                // If the number is read the same as its reverse, then it is a palindrome.\\n                // The current base is returned.\\n                if (reverse.equals(newNum)) {\\n                    foundBase = true;\\n                    return base;\\n                }\\n            }\\n        }\\n        // If all else fails, n is always a palindrome in base n-1. (\\\"11\\\")\\n        return num - 1;\\n    }\\n\\n    private static String reverse(String str) {\\n        String reverse = \\\"\\\";\\n        for (int i = str.length() - 1; i >= 0; i--) {\\n            reverse += str.charAt(i);\\n        }\\n        return reverse;\\n    }\\n\\n    private static String base2base(String n, int b1, int b2) {\\n        // Declare variables: decimal value of n,\\n        // character of base b1, character of base b2,\\n        // and the string that will be returned.\\n        int decimalValue = 0, charB2;\\n        char charB1;\\n        String output = \\\"\\\";\\n        // Go through every character of n\\n        for (int i = 0; i < n.length(); i++) {\\n            // store the character in charB1\\n            charB1 = n.charAt(i);\\n            // if it is a non-number, convert it to a decimal value >9 and store it in charB2\\n            if (charB1 >= 'A' && charB1 <= 'Z') {\\n                charB2 = 10 + (charB1 - 'A');\\n            } // Else, store the integer value in charB2\\n            else {\\n                charB2 = charB1 - '0';\\n            }\\n            // Convert the digit to decimal and add it to the\\n            // decimalValue of n\\n            decimalValue = decimalValue * b1 + charB2;\\n        }\\n\\n        // Converting the decimal value to base b2:\\n        // A number is converted from decimal to another base\\n        // by continuously dividing by the base and recording\\n        // the remainder until the quotient is zero. The number in the\\n        // new base is the remainders, with the last remainder\\n        // being the left-most digit.\\n        // While the quotient is NOT zero:\\n        while (decimalValue != 0) {\\n            // If the remainder is a digit < 10, simply add it to\\n            // the left side of the new number.\\n            if (decimalValue % b2 < 10) {\\n                output = Integer.toString(decimalValue % b2) + output;\\n            } // If the remainder is >= 10, add a character with the\\n            // corresponding value to the new number. (A = 10, B = 11, C = 12, ...)\\n            else {\\n                output = (char) ((decimalValue % b2) + 55) + output;\\n            }\\n            // Divide by the new base again\\n            decimalValue /= b2;\\n        }\\n        return output;\\n    }\\n}\\n\"",
    "luhn": "\"package com.thealgorithms.others;\\n\\nimport java.util.Arrays;\\nimport java.util.Objects;\\n\\n/**\\n * The Luhn algorithm or Luhn formula, also known as the \\\"modulus 10\\\" or \\\"mod\\n * 10\\\" algorithm, named after its creator, IBM scientist Hans Peter Luhn, is a\\n * simple checksum formula used to validate a variety of identification numbers.\\n *\\n * <p>\\n * The algorithm is in the public domain and is in wide use today. It is\\n * specified in ISO/IEC 7812-1. It is not intended to be a cryptographically\\n * secure hash function; it was designed to protect against accidental errors,\\n * not malicious attacks. Most credit cards and many government identification\\n * numbers use the algorithm as a simple method of distinguishing valid numbers\\n * from mistyped or otherwise incorrect numbers.</p>\\n *\\n * <p>\\n * The Luhn algorithm will detect any single-digit error, as well as almost all\\n * transpositions of adjacent digits. It will not, however, detect transposition\\n * of the two-digit sequence 09 to 90 (or vice versa). It will detect most of\\n * the possible twin errors (it will not detect 22 ↔ 55, 33 ↔ 66 or 44 ↔\\n * 77).</p>\\n *\\n * <p>\\n * The check digit is computed as follows:</p>\\n * <ol>\\n * <li>Take the original number and starting from the rightmost digit moving\\n * left, double the value of every second digit (including the rightmost\\n * digit).</li>\\n * <li>Replace the resulting value at each position with the sum of the digits\\n * of this position's value or just subtract 9 from all numbers more or equal\\n * then 10.</li>\\n * <li>Sum up the resulting values from all positions (s).</li>\\n * <li>The calculated check digit is equal to {@code 10 - s % 10}.</li>\\n * </ol>\\n *\\n * @see <a href=\\\"https://en.wikipedia.org/wiki/Luhn_algorithm\\\">Wiki</a>\\n */\\npublic class Luhn {\\n\\n    /**\\n     * Check input digits array by Luhn algorithm. Initial array doesn't change\\n     * while processing.\\n     *\\n     * @param digits array of digits from 0 to 9\\n     * @return true if check was successful, false otherwise\\n     */\\n    public static boolean luhnCheck(int[] digits) {\\n        int[] numbers = Arrays.copyOf(digits, digits.length);\\n        int sum = 0;\\n\\n        for (int i = numbers.length - 1; i >= 0; i--) {\\n            if (i % 2 == 0) {\\n                int temp = numbers[i] * 2;\\n                if (temp > 9) {\\n                    temp = temp - 9;\\n                }\\n                numbers[i] = temp;\\n            }\\n            sum += numbers[i];\\n        }\\n\\n        return sum % 10 == 0;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(\\\"Luhn algorithm usage examples:\\\");\\n        int[] validInput = {4, 5, 6, 1, 2, 6, 1, 2, 1, 2, 3, 4, 5, 4, 6, 7};\\n        int[] invalidInput = {4, 5, 6, 1, 2, 6, 1, 2, 1, 2, 3, 4, 5, 4, 6, 4}; //typo in last symbol\\n        checkAndPrint(validInput);\\n        checkAndPrint(invalidInput);\\n\\n        System.out.println(\\\"\\\\nBusiness examples:\\\");\\n        String validCardNumber = \\\"5265 9251 6151 1412\\\";\\n        String invalidCardNumber = \\\"4929 3231 3088 1896\\\";\\n        String illegalCardNumber = \\\"4F15 BC06 3A88 76D5\\\";\\n        businessExample(validCardNumber);\\n        businessExample(invalidCardNumber);\\n        businessExample(illegalCardNumber);\\n    }\\n\\n    private static void checkAndPrint(int[] input) {\\n        String validationResult = Luhn.luhnCheck(input)\\n                ? \\\"valid\\\"\\n                : \\\"not valid\\\";\\n        System.out.println(\\\"Input \\\" + Arrays.toString(input) + \\\" is \\\" + validationResult);\\n    }\\n\\n\\n    /*\\n        ========================\\n         Business usage example\\n        ========================\\n     */\\n    /**\\n     * Object representation of credit card.\\n     */\\n    private record CreditCard(int[] digits) {\\n\\n        private static final int DIGITS_COUNT = 16;\\n\\n        /**\\n         * @param cardNumber string representation of credit card number - 16\\n         * digits. Can have spaces for digits separation\\n         * @return credit card object\\n         * @throws IllegalArgumentException if input string is not 16 digits or\\n         * if Luhn check was failed\\n         */\\n        public static CreditCard fromString(String cardNumber) {\\n            Objects.requireNonNull(cardNumber);\\n            String trimmedCardNumber = cardNumber.replaceAll(\\\" \\\", \\\"\\\");\\n            if (trimmedCardNumber.length() != DIGITS_COUNT || !trimmedCardNumber.matches(\\\"\\\\\\\\d+\\\")) {\\n                throw new IllegalArgumentException(\\\"{\\\" + cardNumber + \\\"} - is not a card number\\\");\\n            }\\n\\n            int[] cardNumbers = toIntArray(trimmedCardNumber);\\n            boolean isValid = luhnCheck(cardNumbers);\\n            if (!isValid) {\\n                throw new IllegalArgumentException(\\\"Credit card number {\\\" + cardNumber + \\\"} - have a typo\\\");\\n            }\\n\\n            return new CreditCard(cardNumbers);\\n        }\\n\\n        /**\\n         * @return string representation separated by space every 4 digits.\\n         * Example: \\\"5265 9251 6151 1412\\\"\\n         */\\n        public String number() {\\n            StringBuilder result = new StringBuilder();\\n            for (int i = 0; i < DIGITS_COUNT; i++) {\\n                if (i % 4 == 0 && i != 0) {\\n                    result.append(\\\" \\\");\\n                }\\n                result.append(digits[i]);\\n            }\\n            return result.toString();\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return String.format(\\\"%s {%s}\\\", CreditCard.class.getSimpleName(), number());\\n        }\\n\\n        private static int[] toIntArray(String string) {\\n            return string.chars()\\n                    .map(i -> Character.digit(i, 10))\\n                    .toArray();\\n        }\\n    }\\n\\n    private static void businessExample(String cardNumber) {\\n        try {\\n            System.out.println(\\\"Trying to create CreditCard object from valid card number: \\\" + cardNumber);\\n            CreditCard creditCard = CreditCard.fromString(cardNumber);\\n            System.out.println(\\\"And business object is successfully created: \\\" + creditCard + \\\"\\\\n\\\");\\n        } catch (IllegalArgumentException e) {\\n            System.out.println(\\\"And fail with exception message: \\\" + e.getMessage() + \\\"\\\\n\\\");\\n        }\\n    }\\n}\\n\"",
    "mandelbrot": "\"package com.thealgorithms.others;\\n\\nimport java.awt.*;\\nimport java.awt.image.BufferedImage;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport javax.imageio.ImageIO;\\n\\n/**\\n * The Mandelbrot set is the set of complex numbers \\\"c\\\" for which the series\\n * \\\"z_(n+1) = z_n * z_n + c\\\" does not diverge, i.e. remains bounded. Thus, a\\n * complex number \\\"c\\\" is a member of the Mandelbrot set if, when starting with\\n * \\\"z_0 = 0\\\" and applying the iteration repeatedly, the absolute value of \\\"z_n\\\"\\n * remains bounded for all \\\"n > 0\\\". Complex numbers can be written as \\\"a + b*i\\\":\\n * \\\"a\\\" is the real component, usually drawn on the x-axis, and \\\"b*i\\\" is the\\n * imaginary component, usually drawn on the y-axis. Most visualizations of the\\n * Mandelbrot set use a color-coding to indicate after how many steps in the\\n * series the numbers outside the set cross the divergence threshold. Images of\\n * the Mandelbrot set exhibit an elaborate and infinitely complicated boundary\\n * that reveals progressively ever-finer recursive detail at increasing\\n * magnifications, making the boundary of the Mandelbrot set a fractal curve.\\n * (description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set ) (see\\n * also https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set\\n * )\\n */\\npublic class Mandelbrot {\\n\\n    public static void main(String[] args) {\\n        // Test black and white\\n        BufferedImage blackAndWhiteImage = getImage(800, 600, -0.6, 0, 3.2, 50, false);\\n\\n        // Pixel outside the Mandelbrot set should be white.\\n        assert blackAndWhiteImage.getRGB(0, 0) == new Color(255, 255, 255).getRGB();\\n\\n        // Pixel inside the Mandelbrot set should be black.\\n        assert blackAndWhiteImage.getRGB(400, 300) == new Color(0, 0, 0).getRGB();\\n\\n        // Test color-coding\\n        BufferedImage coloredImage = getImage(800, 600, -0.6, 0, 3.2, 50, true);\\n\\n        // Pixel distant to the Mandelbrot set should be red.\\n        assert coloredImage.getRGB(0, 0) == new Color(255, 0, 0).getRGB();\\n\\n        // Pixel inside the Mandelbrot set should be black.\\n        assert coloredImage.getRGB(400, 300) == new Color(0, 0, 0).getRGB();\\n\\n        // Save image\\n        try {\\n            ImageIO.write(coloredImage, \\\"png\\\", new File(\\\"Mandelbrot.png\\\"));\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n    /**\\n     * Method to generate the image of the Mandelbrot set. Two types of\\n     * coordinates are used: image-coordinates that refer to the pixels and\\n     * figure-coordinates that refer to the complex numbers inside and outside\\n     * the Mandelbrot set. The figure-coordinates in the arguments of this\\n     * method determine which section of the Mandelbrot set is viewed. The main\\n     * area of the Mandelbrot set is roughly between \\\"-1.5 < x < 0.5\\\" and \\\"-1 <\\n     * y < 1\\\" in the figure-coordinates.\\n     *\\n     * @param imageWidth The width of the rendered image.\\n     * @param imageHeight The height of the rendered image.\\n     * @param figureCenterX The x-coordinate of the center of the figure.\\n     * @param figureCenterY The y-coordinate of the center of the figure.\\n     * @param figureWidth The width of the figure.\\n     * @param maxStep Maximum number of steps to check for divergent behavior.\\n     * @param useDistanceColorCoding Render in color or black and white.\\n     * @return The image of the rendered Mandelbrot set.\\n     */\\n    public static BufferedImage getImage(\\n            int imageWidth,\\n            int imageHeight,\\n            double figureCenterX,\\n            double figureCenterY,\\n            double figureWidth,\\n            int maxStep,\\n            boolean useDistanceColorCoding) {\\n        if (imageWidth <= 0) {\\n            throw new IllegalArgumentException(\\\"imageWidth should be greater than zero\\\");\\n        }\\n\\n        if (imageHeight <= 0) {\\n            throw new IllegalArgumentException(\\\"imageHeight should be greater than zero\\\");\\n        }\\n\\n        if (maxStep <= 0) {\\n            throw new IllegalArgumentException(\\\"maxStep should be greater than zero\\\");\\n        }\\n\\n        BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);\\n        double figureHeight = figureWidth / imageWidth * imageHeight;\\n\\n        // loop through the image-coordinates\\n        for (int imageX = 0; imageX < imageWidth; imageX++) {\\n            for (int imageY = 0; imageY < imageHeight; imageY++) {\\n                // determine the figure-coordinates based on the image-coordinates\\n                double figureX = figureCenterX + ((double) imageX / imageWidth - 0.5) * figureWidth;\\n                double figureY = figureCenterY + ((double) imageY / imageHeight - 0.5) * figureHeight;\\n\\n                double distance = getDistance(figureX, figureY, maxStep);\\n\\n                // color the corresponding pixel based on the selected coloring-function\\n                image.setRGB(\\n                        imageX,\\n                        imageY,\\n                        useDistanceColorCoding\\n                                ? colorCodedColorMap(distance).getRGB()\\n                                : blackAndWhiteColorMap(distance).getRGB());\\n            }\\n        }\\n\\n        return image;\\n    }\\n\\n    /**\\n     * Black and white color-coding that ignores the relative distance. The\\n     * Mandelbrot set is black, everything else is white.\\n     *\\n     * @param distance Distance until divergence threshold\\n     * @return The color corresponding to the distance.\\n     */\\n    private static Color blackAndWhiteColorMap(double distance) {\\n        return distance >= 1 ? new Color(0, 0, 0) : new Color(255, 255, 255);\\n    }\\n\\n    /**\\n     * Color-coding taking the relative distance into account. The Mandelbrot\\n     * set is black.\\n     *\\n     * @param distance Distance until divergence threshold.\\n     * @return The color corresponding to the distance.\\n     */\\n    private static Color colorCodedColorMap(double distance) {\\n        if (distance >= 1) {\\n            return new Color(0, 0, 0);\\n        } else {\\n            // simplified transformation of HSV to RGB\\n            // distance determines hue\\n            double hue = 360 * distance;\\n            double saturation = 1;\\n            double val = 255;\\n            int hi = (int) (Math.floor(hue / 60)) % 6;\\n            double f = hue / 60 - Math.floor(hue / 60);\\n\\n            int v = (int) val;\\n            int p = 0;\\n            int q = (int) (val * (1 - f * saturation));\\n            int t = (int) (val * (1 - (1 - f) * saturation));\\n\\n            switch (hi) {\\n                case 0:\\n                    return new Color(v, t, p);\\n                case 1:\\n                    return new Color(q, v, p);\\n                case 2:\\n                    return new Color(p, v, t);\\n                case 3:\\n                    return new Color(p, q, v);\\n                case 4:\\n                    return new Color(t, p, v);\\n                default:\\n                    return new Color(v, p, q);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Return the relative distance (ratio of steps taken to maxStep) after\\n     * which the complex number constituted by this x-y-pair diverges. Members\\n     * of the Mandelbrot set do not diverge so their distance is 1.\\n     *\\n     * @param figureX The x-coordinate within the figure.\\n     * @param figureX The y-coordinate within the figure.\\n     * @param maxStep Maximum number of steps to check for divergent behavior.\\n     * @return The relative distance as the ratio of steps taken to maxStep.\\n     */\\n    private static double getDistance(double figureX, double figureY, int maxStep) {\\n        double a = figureX;\\n        double b = figureY;\\n        int currentStep = 0;\\n        for (int step = 0; step < maxStep; step++) {\\n            currentStep = step;\\n            double aNew = a * a - b * b + figureX;\\n            b = 2 * a * b + figureY;\\n            a = aNew;\\n\\n            // divergence happens for all complex number with an absolute value\\n            // greater than 4 (= divergence threshold)\\n            if (a * a + b * b > 4) {\\n                break;\\n            }\\n        }\\n        return (double) currentStep / (maxStep - 1);\\n    }\\n}\\n\"",
    "mini max algorithm": "\"package com.thealgorithms.others;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\n\\n/**\\n * MiniMax is an algorithm used int artificial intelligence and game theory for\\n * minimizing the possible loss for the worst case scenario.\\n *\\n * See more (https://en.wikipedia.org/wiki/Minimax,\\n * https://www.geeksforgeeks.org/minimax-algorithm-in-game-theory-set-1-introduction/).\\n *\\n * @author aitofi (https://github.com/aitorfi)\\n */\\npublic class MiniMaxAlgorithm {\\n\\n    /**\\n     * Game tree represented as an int array containing scores. Each array\\n     * element is a leaf node.\\n     */\\n    private int[] scores;\\n    private int height;\\n\\n    /**\\n     * Initializes the scores with 8 random leaf nodes\\n     */\\n    public MiniMaxAlgorithm() {\\n        scores = getRandomScores(3, 99);\\n        height = log2(scores.length);\\n    }\\n\\n    public static void main(String[] args) {\\n        MiniMaxAlgorithm miniMaxAlgorith = new MiniMaxAlgorithm();\\n        boolean isMaximizer = true; // Specifies the player that goes first.\\n        boolean verbose = true; // True to show each players choices.\\n        int bestScore;\\n\\n        bestScore = miniMaxAlgorith.miniMax(0, isMaximizer, 0, verbose);\\n\\n        if (verbose) {\\n            System.out.println();\\n        }\\n\\n        System.out.println(Arrays.toString(miniMaxAlgorith.getScores()));\\n        System.out.println(\\n                \\\"The best score for \\\" + (isMaximizer ? \\\"Maximizer\\\" : \\\"Minimizer\\\") + \\\" is \\\" + String.valueOf(bestScore));\\n    }\\n\\n    /**\\n     * Returns the optimal score assuming that both players play their best.\\n     *\\n     * @param depth Indicates how deep we are into the game tree.\\n     * @param isMaximizer True if it is maximizers turn; otherwise false.\\n     * @param index Index of the leaf node that is being evaluated.\\n     * @param verbose True to show each players choices.\\n     * @return The optimal score for the player that made the first move.\\n     */\\n    public int miniMax(int depth, boolean isMaximizer, int index, boolean verbose) {\\n        int bestScore, score1, score2;\\n\\n        if (depth == height) { // Leaf node reached.\\n            return scores[index];\\n        }\\n\\n        score1 = miniMax(depth + 1, !isMaximizer, index * 2, verbose);\\n        score2 = miniMax(depth + 1, !isMaximizer, (index * 2) + 1, verbose);\\n\\n        if (isMaximizer) {\\n            // Maximizer player wants to get the maximum possible score.\\n            bestScore = Math.max(score1, score2);\\n        } else {\\n            // Minimizer player wants to get the minimum possible score.\\n            bestScore = Math.min(score1, score2);\\n        }\\n\\n        // Leaf nodes can be sequentially inspected by\\n        // recurssively multiplying (0 * 2) and ((0 * 2) + 1):\\n        // (0 x 2) = 0; ((0 x 2) + 1) = 1\\n        // (1 x 2) = 2; ((1 x 2) + 1) = 3\\n        // (2 x 2) = 4; ((2 x 2) + 1) = 5 ...\\n        if (verbose) {\\n            System.out.println(String.format(\\\"From %02d and %02d, %s chooses %02d\\\", score1, score2,\\n                    (isMaximizer ? \\\"Maximizer\\\" : \\\"Minimizer\\\"), bestScore));\\n        }\\n\\n        return bestScore;\\n    }\\n\\n    /**\\n     * Returns an array of random numbers which lenght is a power of 2.\\n     *\\n     * @param size The power of 2 that will determine the lenght of the array.\\n     * @param maxScore The maximum possible score.\\n     * @return An array of random numbers.\\n     */\\n    public static int[] getRandomScores(int size, int maxScore) {\\n        int[] randomScores = new int[(int) Math.pow(2, size)];\\n        Random rand = new Random();\\n\\n        for (int i = 0; i < randomScores.length; i++) {\\n            randomScores[i] = rand.nextInt(maxScore) + 1;\\n        }\\n\\n        return randomScores;\\n    }\\n\\n    // A utility function to find Log n in base 2\\n    private int log2(int n) {\\n        return (n == 1) ? 0 : log2(n / 2) + 1;\\n    }\\n\\n    public void setScores(int[] scores) {\\n        if (scores.length % 1 == 0) {\\n            this.scores = scores;\\n            height = log2(this.scores.length);\\n        } else {\\n            System.out.println(\\\"The number of scores must be a power of 2.\\\");\\n        }\\n    }\\n\\n    public int[] getScores() {\\n        return scores;\\n    }\\n\\n    public int getHeight() {\\n        return height;\\n    }\\n}\\n\"",
    "page rank": "\"package com.thealgorithms.others;\\n\\nimport java.util.*;\\n\\nclass PageRank {\\n\\n    public static void main(String args[]) {\\n        int nodes, i, j;\\n        Scanner in = new Scanner(System.in);\\n        System.out.print(\\\"Enter the Number of WebPages: \\\");\\n        nodes = in.nextInt();\\n        PageRank p = new PageRank();\\n        System.out.println(\\\"Enter the Adjacency Matrix with 1->PATH & 0->NO PATH Between two WebPages: \\\");\\n        for (i = 1; i <= nodes; i++) {\\n            for (j = 1; j <= nodes; j++) {\\n                p.path[i][j] = in.nextInt();\\n                if (j == i) {\\n                    p.path[i][j] = 0;\\n                }\\n            }\\n        }\\n        p.calc(nodes);\\n    }\\n\\n    public int path[][] = new int[10][10];\\n    public double pagerank[] = new double[10];\\n\\n    public void calc(double totalNodes) {\\n\\n        double InitialPageRank;\\n        double OutgoingLinks = 0;\\n        double DampingFactor = 0.85;\\n        double TempPageRank[] = new double[10];\\n        int ExternalNodeNumber;\\n        int InternalNodeNumber;\\n        int k = 1; // For Traversing\\n        int ITERATION_STEP = 1;\\n        InitialPageRank = 1 / totalNodes;\\n        System.out.printf(\\n                \\\" Total Number of Nodes :\\\" + totalNodes + \\\"\\\\t Initial PageRank  of All Nodes :\\\" + InitialPageRank + \\\"\\\\n\\\");\\n\\n        // 0th ITERATION _ OR _ INITIALIZATION PHASE //\\n        for (k = 1; k <= totalNodes; k++) {\\n            this.pagerank[k] = InitialPageRank;\\n        }\\n        System.out.printf(\\\"\\\\n Initial PageRank Values , 0th Step \\\\n\\\");\\n\\n        for (k = 1; k <= totalNodes; k++) {\\n            System.out.printf(\\\" Page Rank of \\\" + k + \\\" is :\\\\t\\\" + this.pagerank[k] + \\\"\\\\n\\\");\\n        }\\n\\n        while (ITERATION_STEP <= 2) // Iterations\\n        {\\n            // Store the PageRank for All Nodes in Temporary Array\\n            for (k = 1; k <= totalNodes; k++) {\\n                TempPageRank[k] = this.pagerank[k];\\n                this.pagerank[k] = 0;\\n            }\\n\\n            for (InternalNodeNumber = 1; InternalNodeNumber <= totalNodes; InternalNodeNumber++) {\\n                for (ExternalNodeNumber = 1; ExternalNodeNumber <= totalNodes; ExternalNodeNumber++) {\\n                    if (this.path[ExternalNodeNumber][InternalNodeNumber] == 1) {\\n                        k = 1;\\n                        OutgoingLinks = 0; // Count the Number of Outgoing Links for each ExternalNodeNumber\\n                        while (k <= totalNodes) {\\n                            if (this.path[ExternalNodeNumber][k] == 1) {\\n                                OutgoingLinks = OutgoingLinks + 1; // Counter for Outgoing Links\\n                            }\\n                            k = k + 1;\\n                        }\\n                        // Calculate PageRank\\n                        this.pagerank[InternalNodeNumber] += TempPageRank[ExternalNodeNumber] * (1 / OutgoingLinks);\\n                    }\\n                }\\n                System.out.printf(\\\"\\\\n After \\\" + ITERATION_STEP + \\\"th Step \\\\n\\\");\\n\\n                for (k = 1; k <= totalNodes; k++) {\\n                    System.out.printf(\\\" Page Rank of \\\" + k + \\\" is :\\\\t\\\" + this.pagerank[k] + \\\"\\\\n\\\");\\n                }\\n\\n                ITERATION_STEP = ITERATION_STEP + 1;\\n            }\\n\\n            // Add the Damping Factor to PageRank\\n            for (k = 1; k <= totalNodes; k++) {\\n                this.pagerank[k] = (1 - DampingFactor) + DampingFactor * this.pagerank[k];\\n            }\\n\\n            // Display PageRank\\n            System.out.printf(\\\"\\\\n Final Page Rank : \\\\n\\\");\\n            for (k = 1; k <= totalNodes; k++) {\\n                System.out.printf(\\\" Page Rank of \\\" + k + \\\" is :\\\\t\\\" + this.pagerank[k] + \\\"\\\\n\\\");\\n            }\\n\\n        }\\n    }\\n}\\n\"",
    "password gen": "\"package com.thealgorithms.others;\\n\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.List;\\nimport java.util.Random;\\n\\n/**\\n * Creates a random password from ASCII letters Given password length bounds\\n *\\n * @author AKS1996\\n * @date 2017.10.25\\n */\\nclass PasswordGen {\\n\\n    public static void main(String args[]) {\\n        String password = generatePassword(8, 16);\\n        System.out.print(\\\"Password: \\\" + password);\\n    }\\n\\n    static String generatePassword(int min_length, int max_length) {\\n        Random random = new Random();\\n\\n        String upper = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\";\\n        String lower = \\\"abcdefghijklmnopqrstuvwxyz\\\";\\n        String numbers = \\\"0123456789\\\";\\n        String specialChars = \\\"!@#$%^&*(){}?\\\";\\n\\n        String allChars = upper + lower + numbers + specialChars;\\n\\n        List<Character> letters = new ArrayList<Character>();\\n        for (char c : allChars.toCharArray()) {\\n            letters.add(c);\\n        }\\n\\n        // Inbuilt method to randomly shuffle a elements of a list\\n        Collections.shuffle(letters);\\n        StringBuilder password = new StringBuilder();\\n\\n        // Note that size of the password is also random\\n        for (int i = random.nextInt(max_length - min_length) + min_length; i > 0; --i) {\\n            password.append(letters.get(random.nextInt(letters.size())));\\n        }\\n\\n        return password.toString();\\n    }\\n}\\n\"",
    "perlin noise": "\"package com.thealgorithms.others;\\n\\nimport java.util.Random;\\nimport java.util.Scanner;\\n\\n/**\\n * For detailed info and implementation see: <a\\n * href=\\\"http://devmag.org.za/2009/04/25/perlin-noise/\\\">Perlin-Noise</a>\\n */\\npublic class PerlinNoise {\\n\\n    /**\\n     * @param width width of noise array\\n     * @param height height of noise array\\n     * @param octaveCount numbers of layers used for blending noise\\n     * @param persistence value of impact each layer get while blending\\n     * @param seed used for randomizer\\n     * @return float array containing calculated \\\"Perlin-Noise\\\" values\\n     */\\n    static float[][] generatePerlinNoise(\\n            int width, int height, int octaveCount, float persistence, long seed) {\\n        final float[][] base = new float[width][height];\\n        final float[][] perlinNoise = new float[width][height];\\n        final float[][][] noiseLayers = new float[octaveCount][][];\\n\\n        Random random = new Random(seed);\\n        // fill base array with random values as base for noise\\n        for (int x = 0; x < width; x++) {\\n            for (int y = 0; y < height; y++) {\\n                base[x][y] = random.nextFloat();\\n            }\\n        }\\n\\n        // calculate octaves with different roughness\\n        for (int octave = 0; octave < octaveCount; octave++) {\\n            noiseLayers[octave] = generatePerlinNoiseLayer(base, width, height, octave);\\n        }\\n\\n        float amplitude = 1f;\\n        float totalAmplitude = 0f;\\n\\n        // calculate perlin noise by blending each layer together with specific persistence\\n        for (int octave = octaveCount - 1; octave >= 0; octave--) {\\n            amplitude *= persistence;\\n            totalAmplitude += amplitude;\\n\\n            for (int x = 0; x < width; x++) {\\n                for (int y = 0; y < height; y++) {\\n                    // adding each value of the noise layer to the noise\\n                    // by increasing amplitude the rougher noises will have more impact\\n                    perlinNoise[x][y] += noiseLayers[octave][x][y] * amplitude;\\n                }\\n            }\\n        }\\n\\n        // normalize values so that they stay between 0..1\\n        for (int x = 0; x < width; x++) {\\n            for (int y = 0; y < height; y++) {\\n                perlinNoise[x][y] /= totalAmplitude;\\n            }\\n        }\\n\\n        return perlinNoise;\\n    }\\n\\n    /**\\n     * @param base base random float array\\n     * @param width width of noise array\\n     * @param height height of noise array\\n     * @param octave current layer\\n     * @return float array containing calculated \\\"Perlin-Noise-Layer\\\" values\\n     */\\n    static float[][] generatePerlinNoiseLayer(float[][] base, int width, int height, int octave) {\\n        float[][] perlinNoiseLayer = new float[width][height];\\n\\n        // calculate period (wavelength) for different shapes\\n        int period = 1 << octave; // 2^k\\n        float frequency = 1f / period; // 1/2^k\\n\\n        for (int x = 0; x < width; x++) {\\n            // calculates the horizontal sampling indices\\n            int x0 = (x / period) * period;\\n            int x1 = (x0 + period) % width;\\n            float horizintalBlend = (x - x0) * frequency;\\n\\n            for (int y = 0; y < height; y++) {\\n                // calculates the vertical sampling indices\\n                int y0 = (y / period) * period;\\n                int y1 = (y0 + period) % height;\\n                float verticalBlend = (y - y0) * frequency;\\n\\n                // blend top corners\\n                float top = interpolate(base[x0][y0], base[x1][y0], horizintalBlend);\\n\\n                // blend bottom corners\\n                float bottom = interpolate(base[x0][y1], base[x1][y1], horizintalBlend);\\n\\n                // blend top and bottom interpolation to get the final blend value for this cell\\n                perlinNoiseLayer[x][y] = interpolate(top, bottom, verticalBlend);\\n            }\\n        }\\n\\n        return perlinNoiseLayer;\\n    }\\n\\n    /**\\n     * @param a value of point a\\n     * @param b value of point b\\n     * @param alpha determine which value has more impact (closer to 0 -> a,\\n     * closer to 1 -> b)\\n     * @return interpolated value\\n     */\\n    static float interpolate(float a, float b, float alpha) {\\n        return a * (1 - alpha) + alpha * b;\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in);\\n\\n        final int width;\\n        final int height;\\n        final int octaveCount;\\n        final float persistence;\\n        final long seed;\\n        final String charset;\\n        final float[][] perlinNoise;\\n\\n        System.out.println(\\\"Width (int): \\\");\\n        width = in.nextInt();\\n\\n        System.out.println(\\\"Height (int): \\\");\\n        height = in.nextInt();\\n\\n        System.out.println(\\\"Octave count (int): \\\");\\n        octaveCount = in.nextInt();\\n\\n        System.out.println(\\\"Persistence (float): \\\");\\n        persistence = in.nextFloat();\\n\\n        System.out.println(\\\"Seed (long): \\\");\\n        seed = in.nextLong();\\n\\n        System.out.println(\\\"Charset (String): \\\");\\n        charset = in.next();\\n\\n        perlinNoise = generatePerlinNoise(width, height, octaveCount, persistence, seed);\\n        final char[] chars = charset.toCharArray();\\n        final int length = chars.length;\\n        final float step = 1f / length;\\n        // output based on charset\\n        for (int x = 0; x < width; x++) {\\n            for (int y = 0; y < height; y++) {\\n                float value = step;\\n                float noiseValue = perlinNoise[x][y];\\n\\n                for (char c : chars) {\\n                    if (noiseValue <= value) {\\n                        System.out.print(c);\\n                        break;\\n                    }\\n\\n                    value += step;\\n                }\\n            }\\n\\n            System.out.println();\\n        }\\n        in.close();\\n    }\\n}\\n\"",
    "queue using two stacks": "\"package com.thealgorithms.others;\\n\\nimport java.util.Stack;\\n\\n/**\\n * This implements Queue using two Stacks.\\n *\\n * <p>\\n * Big O Runtime: insert(): O(1) remove(): O(1) amortized isEmpty(): O(1)\\n *\\n * <p>\\n * A queue data structure functions the same as a real world queue. The elements\\n * that are added first are the first to be removed. New elements are added to\\n * the back/rear of the queue.\\n *\\n * @author sahilb2 (https://www.github.com/sahilb2)\\n */\\nclass QueueWithStack {\\n\\n    // Stack to keep track of elements inserted into the queue\\n    private Stack<Object> inStack;\\n    // Stack to keep track of elements to be removed next in queue\\n    private Stack<Object> outStack;\\n\\n    /**\\n     * Constructor\\n     */\\n    public QueueWithStack() {\\n        this.inStack = new Stack<>();\\n        this.outStack = new Stack<>();\\n    }\\n\\n    /**\\n     * Inserts an element at the rear of the queue\\n     *\\n     * @param x element to be added\\n     */\\n    public void insert(Object x) {\\n        // Insert element into inStack\\n        this.inStack.push(x);\\n    }\\n\\n    /**\\n     * Remove an element from the front of the queue\\n     *\\n     * @return the new front of the queue\\n     */\\n    public Object remove() {\\n        if (this.outStack.isEmpty()) {\\n            // Move all elements from inStack to outStack (preserving the order)\\n            while (!this.inStack.isEmpty()) {\\n                this.outStack.push(this.inStack.pop());\\n            }\\n        }\\n        return this.outStack.pop();\\n    }\\n\\n    /**\\n     * Peek at the element from the front of the queue\\n     *\\n     * @return the front element of the queue\\n     */\\n    public Object peekFront() {\\n        if (this.outStack.isEmpty()) {\\n            // Move all elements from inStack to outStack (preserving the order)\\n            while (!this.inStack.isEmpty()) {\\n                this.outStack.push(this.inStack.pop());\\n            }\\n        }\\n        return this.outStack.peek();\\n    }\\n\\n    /**\\n     * Peek at the element from the back of the queue\\n     *\\n     * @return the back element of the queue\\n     */\\n    public Object peekBack() {\\n        return this.inStack.peek();\\n    }\\n\\n    /**\\n     * Returns true if the queue is empty\\n     *\\n     * @return true if the queue is empty\\n     */\\n    public boolean isEmpty() {\\n        return (this.inStack.isEmpty() && this.outStack.isEmpty());\\n    }\\n\\n    /**\\n     * Returns true if the inStack is empty.\\n     *\\n     * @return true if the inStack is empty.\\n     */\\n    public boolean isInStackEmpty() {\\n        return (inStack.size() == 0);\\n    }\\n\\n    /**\\n     * Returns true if the outStack is empty.\\n     *\\n     * @return true if the outStack is empty.\\n     */\\n    public boolean isOutStackEmpty() {\\n        return (outStack.size() == 0);\\n    }\\n}\\n\\n/**\\n * This class is the example for the Queue class\\n *\\n * @author sahilb2 (https://www.github.com/sahilb2)\\n */\\npublic class QueueUsingTwoStacks {\\n\\n    /**\\n     * Main method\\n     *\\n     * @param args Command line arguments\\n     */\\n    public static void main(String args[]) {\\n        QueueWithStack myQueue = new QueueWithStack();\\n        myQueue.insert(1);\\n        System.out.println(myQueue.peekBack()); // Will print 1\\n        // instack: [(top) 1]\\n        // outStack: []\\n        myQueue.insert(2);\\n        System.out.println(myQueue.peekBack()); // Will print 2\\n        // instack: [(top) 2, 1]\\n        // outStack: []\\n        myQueue.insert(3);\\n        System.out.println(myQueue.peekBack()); // Will print 3\\n        // instack: [(top) 3, 2, 1]\\n        // outStack: []\\n        myQueue.insert(4);\\n        System.out.println(myQueue.peekBack()); // Will print 4\\n        // instack: [(top) 4, 3, 2, 1]\\n        // outStack: []\\n\\n        System.out.println(myQueue.isEmpty()); // Will print false\\n\\n        System.out.println(myQueue.remove()); // Will print 1\\n        System.out.println((myQueue.isInStackEmpty()) ? \\\"null\\\" : myQueue.peekBack()); // Will print NULL\\n        // instack: []\\n        // outStack: [(top) 2, 3, 4]\\n\\n        myQueue.insert(5);\\n        System.out.println(myQueue.peekFront()); // Will print 2\\n        // instack: [(top) 5]\\n        // outStack: [(top) 2, 3, 4]\\n\\n        myQueue.remove();\\n        System.out.println(myQueue.peekFront()); // Will print 3\\n        // instack: [(top) 5]\\n        // outStack: [(top) 3, 4]\\n        myQueue.remove();\\n        System.out.println(myQueue.peekFront()); // Will print 4\\n        // instack: [(top) 5]\\n        // outStack: [(top) 4]\\n        myQueue.remove();\\n        // instack: [(top) 5]\\n        // outStack: []\\n        System.out.println(myQueue.peekFront()); // Will print 5\\n        // instack: []\\n        // outStack: [(top) 5]\\n        myQueue.remove();\\n        // instack: []\\n        // outStack: []\\n\\n        System.out.println(myQueue.isEmpty()); // Will print true\\n    }\\n}\\n\"",
    "rabin karp": "\"package com.thealgorithms.others;\\n\\n/**\\n * @author Prateek Kumar Oraon (https://github.com/prateekKrOraon)\\n */\\nimport java.util.Scanner;\\n\\n// An implementation of Rabin-Karp string matching algorithm\\n// Program will simply end if there is no match\\npublic class RabinKarp {\\n\\n    public static Scanner scanner = null;\\n    public static final int d = 256;\\n\\n    public static void main(String[] args) {\\n\\n        scanner = new Scanner(System.in);\\n        System.out.println(\\\"Enter String\\\");\\n        String text = scanner.nextLine();\\n        System.out.println(\\\"Enter pattern\\\");\\n        String pattern = scanner.nextLine();\\n\\n        int q = 101;\\n        searchPat(text, pattern, q);\\n    }\\n\\n    private static void searchPat(String text, String pattern, int q) {\\n\\n        int m = pattern.length();\\n        int n = text.length();\\n        int t = 0;\\n        int p = 0;\\n        int h = 1;\\n        int j = 0;\\n        int i = 0;\\n\\n        h = (int) Math.pow(d, m - 1) % q;\\n\\n        for (i = 0; i < m; i++) {\\n            // hash value is calculated for each character and then added with the hash value of the next\\n            // character for pattern\\n            // as well as the text for length equal to the length of pattern\\n            p = (d * p + pattern.charAt(i)) % q;\\n            t = (d * t + text.charAt(i)) % q;\\n        }\\n\\n        for (i = 0; i <= n - m; i++) {\\n\\n            // if the calculated hash value of the pattern and text matches then\\n            // all the characters of the pattern is matched with the text of length equal to length of the\\n            // pattern\\n            // if all matches then pattern exist in string\\n            // if not then the hash value of the first character of the text is subtracted and hash value\\n            // of the next character after the end\\n            // of the evaluated characters is added\\n            if (p == t) {\\n\\n                // if hash value matches then the individual characters are matched\\n                for (j = 0; j < m; j++) {\\n\\n                    // if not matched then break out of the loop\\n                    if (text.charAt(i + j) != pattern.charAt(j)) {\\n                        break;\\n                    }\\n                }\\n\\n                // if all characters are matched then pattern exist in the string\\n                if (j == m) {\\n                    System.out.println(\\\"Pattern found at index \\\" + i);\\n                }\\n            }\\n\\n            // if i<n-m then hash value of the first character of the text is subtracted and hash value of\\n            // the next character after the end\\n            // of the evaluated characters is added to get the hash value of the next window of characters\\n            // in the text\\n            if (i < n - m) {\\n                t = (d * (t - text.charAt(i) * h) + text.charAt(i + m)) % q;\\n\\n                // if hash value becomes less than zero than q is added to make it positive\\n                if (t < 0) {\\n                    t = (t + q);\\n                }\\n            }\\n        }\\n    }\\n}\\n\"",
    "remove duplicate from string": "\"package com.thealgorithms.others;\\n\\nimport java.io.BufferedReader;\\nimport java.io.InputStreamReader;\\n\\n/**\\n * @author Varun Upadhyay (https://github.com/varunu28)\\n */\\npublic class RemoveDuplicateFromString {\\n\\n    public static void main(String[] args) throws Exception {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        String inpStr = br.readLine();\\n\\n        System.out.println(\\\"Actual string is: \\\" + inpStr);\\n        System.out.println(\\\"String after removing duplicates: \\\" + removeDuplicate(inpStr));\\n\\n        br.close();\\n    }\\n\\n    /**\\n     * This method produces a string after removing all the duplicate characters\\n     * from input string and returns it Example: Input String - \\\"aabbbccccddddd\\\"\\n     * Output String - \\\"abcd\\\"\\n     *\\n     * @param s String from which duplicate characters have to be removed\\n     * @return string with only unique characters\\n     */\\n    public static String removeDuplicate(String s) {\\n        if (s == null || s.isEmpty()) {\\n            return s;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        int n = s.length();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (sb.toString().indexOf(s.charAt(i)) == -1) {\\n                sb.append(String.valueOf(s.charAt(i)));\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\"",
    "return subsequence": "\"package com.thealgorithms.others;\\n\\nimport java.util.Scanner;\\n\\npublic class ReturnSubsequence {\\n\\n    public static void main(String[] args) {\\n        System.out.println(\\\"Enter String: \\\");\\n        Scanner s = new Scanner(System.in);\\n        String givenString = s.next(); // given string\\n        String[] subsequence = returnSubsequence(givenString); // calling returnSubsequence() function\\n        System.out.println(\\\"Subsequences : \\\");\\n        // print the given array of subsequences\\n        for (int i = 0; i < subsequence.length; i++) {\\n            System.out.println(subsequence[i]);\\n        }\\n        s.close();\\n    }\\n\\n    /**\\n     * @param givenString\\n     * @return subsequence\\n     */\\n    private static String[] returnSubsequence(String givenString) {\\n        if (givenString.length()\\n                == 0) // If string is empty we will create an array of size=1 and insert \\\"\\\" (Empty string)\\n        // in it\\n        {\\n            String[] ans = new String[1];\\n            ans[0] = \\\"\\\";\\n            return ans;\\n        }\\n        String[] SmallAns\\n                = returnSubsequence(\\n                        givenString.substring(\\n                                1)); // recursive call to get subsequences of substring starting from index\\n        // position=1\\n\\n        String[] ans\\n                = new String[2 * SmallAns.length]; // Our answer will be an array off string of size=2*SmallAns\\n        int i = 0;\\n        for (; i < SmallAns.length; i++) {\\n            ans[i] = SmallAns[i]; // Copying all the strings present in SmallAns to ans string array\\n        }\\n        for (int k = 0; k < SmallAns.length; k++) {\\n            ans[k + SmallAns.length]\\n                    = givenString.charAt(0)\\n                    + SmallAns[k]; // Insert character at index=0 of the given substring in front of every string\\n            // in SmallAns\\n        }\\n        return ans;\\n    }\\n}\\n\"",
    "reverse stack using recursion": "\"package com.thealgorithms.others;\\n\\n/* Program to reverse a Stack using Recursion*/\\nimport java.util.Stack;\\n\\npublic class ReverseStackUsingRecursion {\\n\\n    // Stack\\n    private static Stack<Integer> stack = new Stack<>();\\n\\n    // Main function\\n    public static void main(String[] args) {\\n        // To Create a Dummy Stack containing integers from 0-9\\n        for (int i = 0; i < 10; i++) {\\n            stack.push(i);\\n        }\\n        System.out.println(\\\"STACK\\\");\\n\\n        // To print that dummy Stack\\n        for (int k = 9; k >= 0; k--) {\\n            System.out.println(k);\\n        }\\n\\n        // Reverse Function called\\n        reverseUsingRecursion(stack);\\n\\n        System.out.println(\\\"REVERSED STACK : \\\");\\n        // To print reversed  stack\\n        while (!stack.isEmpty()) {\\n            System.out.println(stack.pop());\\n        }\\n    }\\n\\n    // Function Used to reverse Stack Using Recursion\\n    private static void reverseUsingRecursion(Stack<Integer> stack) {\\n        if (stack.isEmpty()) // If stack is empty then return\\n        {\\n            return;\\n        }\\n        /* All items are stored in call stack until we reach the end*/\\n\\n        int temptop = stack.peek();\\n        stack.pop();\\n        reverseUsingRecursion(stack); // Recursion call\\n        insertAtEnd(temptop); // Insert items held in call stack one by one into stack\\n    }\\n\\n    // Function used to insert element at the end of stack\\n    private static void insertAtEnd(int temptop) {\\n        if (stack.isEmpty()) {\\n            stack.push(temptop); // If stack is empty push the element\\n        } else {\\n            int temp = stack.peek();\\n            /* All the items are stored in call stack until we reach end*/\\n            stack.pop();\\n\\n            insertAtEnd(temptop); // Recursive call\\n\\n            stack.push(temp);\\n        }\\n    }\\n}\\n\"",
    "root precision": "\"package com.thealgorithms.others;\\n\\nimport java.util.Scanner;\\n\\npublic class RootPrecision {\\n\\n    public static void main(String[] args) {\\n        // take input\\n        Scanner scn = new Scanner(System.in);\\n\\n        // N is the input number\\n        int N = scn.nextInt();\\n\\n        // P is precision value for eg - P is 3 in 2.564 and 5 in 3.80870.\\n        int P = scn.nextInt();\\n        System.out.println(squareRoot(N, P));\\n\\n        scn.close();\\n    }\\n\\n    public static double squareRoot(int N, int P) {\\n        // rv means return value\\n        double rv;\\n\\n        double root = Math.pow(N, 0.5);\\n\\n        // calculate precision to power of 10 and then multiply it with root value.\\n        int precision = (int) Math.pow(10, P);\\n        root = root * precision;\\n        /*typecast it into integer then divide by precision and again typecast into double\\n    so as to have decimal points upto P precision */\\n\\n        rv = (int) root;\\n        return rv / precision;\\n    }\\n}\\n\"",
    "rotate matrice by90 degree": "\"package com.thealgorithms.others;\\n\\n/**\\n * Given a matrix of size n x n We have to rotate this matrix by 90 Degree Here\\n * is the algorithm for this problem .\\n */\\nimport java.util.*;\\n\\nclass Rotate_by_90_degree {\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        int t = sc.nextInt();\\n\\n        while (t-- > 0) {\\n            int n = sc.nextInt();\\n            int[][] arr = new int[n][n];\\n\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    arr[i][j] = sc.nextInt();\\n                }\\n            }\\n\\n            Rotate g = new Rotate();\\n            g.rotate(arr);\\n            printMatrix(arr);\\n        }\\n        sc.close();\\n    }\\n\\n    static void printMatrix(int arr[][]) {\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = 0; j < arr[0].length; j++) {\\n                System.out.print(arr[i][j] + \\\" \\\");\\n            }\\n            System.out.println(\\\"\\\");\\n        }\\n    }\\n}\\n\\n/**\\n * Class containing the algo to roate matrix by 90 degree\\n */\\nclass Rotate {\\n\\n    static void rotate(int a[][]) {\\n        int n = a.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i > j) {\\n                    int temp = a[i][j];\\n                    a[i][j] = a[j][i];\\n                    a[j][i] = temp;\\n                }\\n            }\\n        }\\n        int i = 0, k = n - 1;\\n        while (i < k) {\\n            for (int j = 0; j < n; j++) {\\n                int temp = a[i][j];\\n                a[i][j] = a[k][j];\\n                a[k][j] = temp;\\n            }\\n\\n            i++;\\n            k--;\\n        }\\n    }\\n}\\n\"",
    "sieve of eratosthenes": "\"package com.thealgorithms.others;\\n\\nimport java.util.Arrays;\\n\\n/**\\n * Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers\\n * up to any given limit. It does so by iteratively marking as composite (i.e.,\\n * not prime) the multiples of each prime, starting with the first prime number,\\n * 2. The multiples of a given prime are generated as a sequence of numbers\\n * starting from that prime, with constant difference between them that is equal\\n * to that prime. This is the sieve's key distinction from using trial division\\n * to sequentially test each candidate number for divisibility by each prime.\\n * Once all the multiples of each discovered prime have been marked as\\n * composites, the remaining unmarked numbers are primes.\\n * <p>\\n * Poetry about Sieve of Eratosthenes:\\n * <p>\\n * <i>Sift the Two's and Sift the Three's:</i></p>\\n * <p>\\n * <i>The Sieve of Eratosthenes.</i></p>\\n * <p>\\n * <i>When the multiples sublime,</i></p>\\n * <p>\\n * <i>The numbers that remain are Prime.</i></p>\\n *\\n * @see <a href=\\\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\\\">Wiki</a>\\n */\\npublic class SieveOfEratosthenes {\\n\\n    /**\\n     * @param n The number till which we have to check for prime Prints all the\\n     * prime numbers till n. Should be more than 1.\\n     * @return array of all prime numbers between 0 to n\\n     */\\n    public static int[] findPrimesTill(int n) {\\n        // Create array where index is number and value is flag - is that number a prime or not.\\n        // size of array is n + 1 cause in Java array indexes starts with 0\\n        Type[] numbers = new Type[n + 1];\\n\\n        // Start with assumption that all numbers except 0 and 1 are primes.\\n        Arrays.fill(numbers, Type.PRIME);\\n        numbers[0] = numbers[1] = Type.NOT_PRIME;\\n\\n        double cap = Math.sqrt(n);\\n        // Main algorithm: mark all numbers which are multiples of some other values as not prime\\n        for (int i = 2; i <= cap; i++) {\\n            if (numbers[i] == Type.PRIME) {\\n                for (int j = 2; i * j <= n; j++) {\\n                    numbers[i * j] = Type.NOT_PRIME;\\n                }\\n            }\\n        }\\n\\n        //Write all primes to result array\\n        int primesCount = (int) Arrays.stream(numbers)\\n                .filter(element -> element == Type.PRIME)\\n                .count();\\n        int[] primes = new int[primesCount];\\n\\n        int primeIndex = 0;\\n        for (int i = 0; i < n + 1; i++) {\\n            if (numbers[i] == Type.PRIME) {\\n                primes[primeIndex++] = i;\\n            }\\n        }\\n\\n        return primes;\\n    }\\n\\n    private enum Type {\\n        PRIME, NOT_PRIME\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 100;\\n        System.out.println(\\\"Searching for all primes from zero to \\\" + n);\\n        int[] primes = findPrimesTill(n);\\n        System.out.println(\\\"Found: \\\" + Arrays.toString(primes));\\n    }\\n}\\n\"",
    "sjf": "\"package com.thealgorithms.others;\\n\\n/**\\n *\\n *\\n * <h2>Shortest job first.</h2>\\n *\\n * <p>\\n * Shortest job first (SJF) or shortest job next, is a scheduling policy that\\n * selects the waiting process with the smallest execution time to execute next\\n * Shortest Job first has the advantage of having minimum average waiting time\\n * among all scheduling algorithms. It is a Greedy Algorithm. It may cause\\n * starvation if shorter processes keep coming. This problem has been solved\\n * using the concept of aging.\\n *\\n * @author shivg7706\\n * @since 2018/10/27\\n */\\nimport java.util.*;\\nimport java.util.ArrayList;\\nimport java.util.Comparator;\\nimport java.util.Scanner;\\n\\nclass Process {\\n\\n    public int pid;\\n    public int arrivalTime;\\n    public int burstTime;\\n    public int priority;\\n    public int turnAroundTime;\\n    public int waitTime;\\n    public int remainingTime;\\n}\\n\\nclass Schedule {\\n\\n    private int noOfProcess;\\n    private int timer = 0;\\n    private ArrayList<Process> processes;\\n    private ArrayList<Process> remainingProcess;\\n    private ArrayList<Integer> gantChart;\\n    private float burstAll;\\n    private Map<Integer, ArrayList<Process>> arrivals;\\n\\n    Schedule() {\\n        Scanner in = new Scanner(System.in);\\n\\n        processes = new ArrayList<Process>();\\n        remainingProcess = new ArrayList<Process>();\\n\\n        gantChart = new ArrayList<>();\\n        arrivals = new HashMap<>();\\n\\n        System.out.print(\\\"Enter the no. of processes: \\\");\\n        noOfProcess = in.nextInt();\\n        System.out.println(\\\"Enter the arrival, burst and priority of processes\\\");\\n        for (int i = 0; i < noOfProcess; i++) {\\n            Process p = new Process();\\n            p.pid = i;\\n            p.arrivalTime = in.nextInt();\\n            p.burstTime = in.nextInt();\\n            p.priority = in.nextInt();\\n            p.turnAroundTime = 0;\\n            p.waitTime = 0;\\n            p.remainingTime = p.burstTime;\\n\\n            if (arrivals.get(p.arrivalTime) == null) {\\n                arrivals.put(p.arrivalTime, new ArrayList<Process>());\\n            }\\n            arrivals.get(p.arrivalTime).add(p);\\n            processes.add(p);\\n            burstAll += p.burstTime;\\n        }\\n        in.close();\\n    }\\n\\n    void startScheduling() {\\n\\n        processes.sort(\\n                new Comparator<Process>() {\\n            @Override\\n            public int compare(Process a, Process b) {\\n                return a.arrivalTime - b.arrivalTime;\\n            }\\n        });\\n\\n        while (!(arrivals.size() == 0 && remainingProcess.size() == 0)) {\\n            removeFinishedProcess();\\n            if (arrivals.get(timer) != null) {\\n                remainingProcess.addAll(arrivals.get(timer));\\n                arrivals.remove(timer);\\n            }\\n\\n            remainingProcess.sort(\\n                    new Comparator<Process>() {\\n                private int alpha = 6;\\n                private int beta = 1;\\n\\n                @Override\\n                public int compare(Process a, Process b) {\\n                    int aRem = a.remainingTime;\\n                    int bRem = b.remainingTime;\\n                    int aprior = a.priority;\\n                    int bprior = b.priority;\\n                    return (alpha * aRem + beta * aprior) - (alpha * bRem + beta * bprior);\\n                }\\n            });\\n\\n            int k = timeElapsed(timer);\\n            ageing(k);\\n            timer++;\\n        }\\n\\n        System.out.println(\\\"Total time required: \\\" + (timer - 1));\\n    }\\n\\n    void removeFinishedProcess() {\\n        ArrayList<Integer> completed = new ArrayList<Integer>();\\n        for (int i = 0; i < remainingProcess.size(); i++) {\\n            if (remainingProcess.get(i).remainingTime == 0) {\\n                completed.add(i);\\n            }\\n        }\\n\\n        for (int i = 0; i < completed.size(); i++) {\\n            int pid = remainingProcess.get(completed.get(i)).pid;\\n            processes.get(pid).waitTime = remainingProcess.get(completed.get(i)).waitTime;\\n            remainingProcess.remove(remainingProcess.get(completed.get(i)));\\n        }\\n    }\\n\\n    public int timeElapsed(int i) {\\n        if (!remainingProcess.isEmpty()) {\\n            gantChart.add(i, remainingProcess.get(0).pid);\\n            remainingProcess.get(0).remainingTime--;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    public void ageing(int k) {\\n        for (int i = k; i < remainingProcess.size(); i++) {\\n            remainingProcess.get(i).waitTime++;\\n            if (remainingProcess.get(i).waitTime % 7 == 0) {\\n                remainingProcess.get(i).priority--;\\n            }\\n        }\\n    }\\n\\n    public void solve() {\\n        System.out.println(\\\"Gant chart \\\");\\n        for (int i = 0; i < gantChart.size(); i++) {\\n            System.out.print(gantChart.get(i) + \\\" \\\");\\n        }\\n        System.out.println();\\n\\n        float waitTimeTot = 0;\\n        float tatTime = 0;\\n\\n        for (int i = 0; i < noOfProcess; i++) {\\n            processes.get(i).turnAroundTime = processes.get(i).waitTime + processes.get(i).burstTime;\\n\\n            waitTimeTot += processes.get(i).waitTime;\\n            tatTime += processes.get(i).turnAroundTime;\\n\\n            System.out.println(\\n                    \\\"Process no.: \\\"\\n                    + i\\n                    + \\\" Wait time: \\\"\\n                    + processes.get(i).waitTime\\n                    + \\\" Turn Around Time: \\\"\\n                    + processes.get(i).turnAroundTime);\\n        }\\n\\n        System.out.println(\\\"Average Waiting Time: \\\" + waitTimeTot / noOfProcess);\\n        System.out.println(\\\"Average TAT Time: \\\" + tatTime / noOfProcess);\\n        System.out.println(\\\"Throughput: \\\" + (float) noOfProcess / (timer - 1));\\n    }\\n}\\n\\npublic class SJF {\\n\\n    public static void main(String[] args) {\\n        Schedule s = new Schedule();\\n        s.startScheduling();\\n        s.solve();\\n    }\\n}\\n\"",
    "skyline problem": "\"package com.thealgorithms.others;\\n\\nimport java.util.ArrayList;\\nimport java.util.Iterator;\\nimport java.util.Scanner;\\n\\npublic class SkylineProblem {\\n\\n    Building[] building;\\n    int count;\\n\\n    public void run() {\\n        Scanner sc = new Scanner(System.in);\\n\\n        int num = sc.nextInt();\\n        this.building = new Building[num];\\n\\n        for (int i = 0; i < num; i++) {\\n            String input = sc.next();\\n            String[] data = input.split(\\\",\\\");\\n            this.add(Integer.parseInt(data[0]), Integer.parseInt(data[1]), Integer.parseInt(data[2]));\\n        }\\n        this.print(this.findSkyline(0, num - 1));\\n\\n        sc.close();\\n    }\\n\\n    public void add(int left, int height, int right) {\\n        building[count++] = new Building(left, height, right);\\n    }\\n\\n    public void print(ArrayList<Skyline> skyline) {\\n        Iterator<Skyline> it = skyline.iterator();\\n\\n        while (it.hasNext()) {\\n            Skyline temp = it.next();\\n            System.out.print(temp.coordinates + \\\",\\\" + temp.height);\\n            if (it.hasNext()) {\\n                System.out.print(\\\",\\\");\\n            }\\n        }\\n    }\\n\\n    public ArrayList<Skyline> findSkyline(int start, int end) {\\n        if (start == end) {\\n            ArrayList<Skyline> list = new ArrayList<>();\\n            list.add(new Skyline(building[start].left, building[start].height));\\n            list.add(new Skyline(building[end].right, 0));\\n\\n            return list;\\n        }\\n\\n        int mid = (start + end) / 2;\\n\\n        ArrayList<Skyline> sky1 = this.findSkyline(start, mid);\\n        ArrayList<Skyline> sky2 = this.findSkyline(mid + 1, end);\\n\\n        return this.mergeSkyline(sky1, sky2);\\n    }\\n\\n    public ArrayList<Skyline> mergeSkyline(ArrayList<Skyline> sky1, ArrayList<Skyline> sky2) {\\n        int currentH1 = 0, currentH2 = 0;\\n        ArrayList<Skyline> skyline = new ArrayList<>();\\n        int maxH = 0;\\n\\n        while (!sky1.isEmpty() && !sky2.isEmpty()) {\\n            if (sky1.get(0).coordinates < sky2.get(0).coordinates) {\\n                int currentX = sky1.get(0).coordinates;\\n                currentH1 = sky1.get(0).height;\\n\\n                if (currentH1 < currentH2) {\\n                    sky1.remove(0);\\n                    if (maxH != currentH2) {\\n                        skyline.add(new Skyline(currentX, currentH2));\\n                    }\\n                } else {\\n                    maxH = currentH1;\\n                    sky1.remove(0);\\n                    skyline.add(new Skyline(currentX, currentH1));\\n                }\\n            } else {\\n                int currentX = sky2.get(0).coordinates;\\n                currentH2 = sky2.get(0).height;\\n\\n                if (currentH2 < currentH1) {\\n                    sky2.remove(0);\\n                    if (maxH != currentH1) {\\n                        skyline.add(new Skyline(currentX, currentH1));\\n                    }\\n                } else {\\n                    maxH = currentH2;\\n                    sky2.remove(0);\\n                    skyline.add(new Skyline(currentX, currentH2));\\n                }\\n            }\\n        }\\n\\n        while (!sky1.isEmpty()) {\\n            skyline.add(sky1.get(0));\\n            sky1.remove(0);\\n        }\\n\\n        while (!sky2.isEmpty()) {\\n            skyline.add(sky2.get(0));\\n            sky2.remove(0);\\n        }\\n\\n        return skyline;\\n    }\\n\\n    public class Skyline {\\n\\n        public int coordinates;\\n        public int height;\\n\\n        public Skyline(int coordinates, int height) {\\n            this.coordinates = coordinates;\\n            this.height = height;\\n        }\\n    }\\n\\n    public class Building {\\n\\n        public int left;\\n        public int height;\\n        public int right;\\n\\n        public Building(int left, int height, int right) {\\n            this.left = left;\\n            this.height = height;\\n            this.right = right;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        SkylineProblem skylineProblem = new SkylineProblem();\\n        skylineProblem.run();\\n    }\\n}\\n\"",
    "stack postfix notation": "\"package com.thealgorithms.others;\\n\\nimport java.util.*;\\n\\npublic class StackPostfixNotation {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String post = scanner.nextLine(); // Takes input with spaces in between eg. \\\"1 21 +\\\"\\n        System.out.println(postfixEvaluate(post));\\n        scanner.close();\\n    }\\n\\n    // Evaluates the given postfix expression string and returns the result.\\n    public static int postfixEvaluate(String exp) {\\n        Stack<Integer> s = new Stack<Integer>();\\n        Scanner tokens = new Scanner(exp);\\n\\n        while (tokens.hasNext()) {\\n            if (tokens.hasNextInt()) {\\n                s.push(tokens.nextInt()); // If int then push to stack\\n            } else { // else pop top two values and perform the operation\\n                int num2 = s.pop();\\n                int num1 = s.pop();\\n                String op = tokens.next();\\n\\n                if (op.equals(\\\"+\\\")) {\\n                    s.push(num1 + num2);\\n                } else if (op.equals(\\\"-\\\")) {\\n                    s.push(num1 - num2);\\n                } else if (op.equals(\\\"*\\\")) {\\n                    s.push(num1 * num2);\\n                } else {\\n                    s.push(num1 / num2);\\n                }\\n\\n                //  \\\"+\\\", \\\"-\\\", \\\"*\\\", \\\"/\\\"\\n            }\\n        }\\n        tokens.close();\\n        return s.pop();\\n    }\\n}\\n\"",
    "string match finite automata": "\"package com.thealgorithms.others;\\n\\n/**\\n * @author Prateek Kumar Oraon (https://github.com/prateekKrOraon)\\n */\\nimport java.util.Scanner;\\n\\n// An implementaion of string matching using finite automata\\npublic class StringMatchFiniteAutomata {\\n\\n    public static final int CHARS = 256;\\n    public static int[][] FA;\\n    public static Scanner scanner = null;\\n\\n    public static void main(String[] args) {\\n\\n        scanner = new Scanner(System.in);\\n        System.out.println(\\\"Enter String\\\");\\n        String text = scanner.nextLine();\\n        System.out.println(\\\"Enter pattern\\\");\\n        String pat = scanner.nextLine();\\n\\n        searchPat(text, pat);\\n\\n        scanner.close();\\n    }\\n\\n    public static void searchPat(String text, String pat) {\\n\\n        int m = pat.length();\\n        int n = text.length();\\n\\n        FA = new int[m + 1][CHARS];\\n\\n        computeFA(pat, m, FA);\\n\\n        int state = 0;\\n        for (int i = 0; i < n; i++) {\\n            state = FA[state][text.charAt(i)];\\n\\n            if (state == m) {\\n                System.out.println(\\\"Pattern found at index \\\" + (i - m + 1));\\n            }\\n        }\\n    }\\n\\n    // Computes finite automata for the partern\\n    public static void computeFA(String pat, int m, int[][] FA) {\\n\\n        for (int state = 0; state <= m; ++state) {\\n            for (int x = 0; x < CHARS; ++x) {\\n                FA[state][x] = getNextState(pat, m, state, x);\\n            }\\n        }\\n    }\\n\\n    public static int getNextState(String pat, int m, int state, int x) {\\n\\n        // if current state is less than length of pattern\\n        // and input character of pattern matches the character in the alphabet\\n        // then automata goes to next state\\n        if (state < m && x == pat.charAt(state)) {\\n            return state + 1;\\n        }\\n\\n        for (int ns = state; ns > 0; ns--) {\\n\\n            if (pat.charAt(ns - 1) == x) {\\n\\n                for (int i = 0; i < ns - 1; i++) {\\n\\n                    if (pat.charAt(i) != pat.charAt(state - ns + i + 1)) {\\n                        break;\\n                    }\\n\\n                    if (i == ns - 1) {\\n                        return ns;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\"",
    "sudoku": "\"package com.thealgorithms.others;\\n\\nclass Sudoku {\\n\\n    public static boolean isSafe(int[][] board,\\n            int row, int col,\\n            int num) {\\n        // Row has the unique (row-clash)\\n        for (int d = 0; d < board.length; d++) {\\n\\n            // Check if the number we are trying to\\n            // place is already present in\\n            // that row, return false;\\n            if (board[row][d] == num) {\\n                return false;\\n            }\\n        }\\n\\n        // Column has the unique numbers (column-clash)\\n        for (int r = 0; r < board.length; r++) {\\n\\n            // Check if the number\\n            // we are trying to\\n            // place is already present in\\n            // that column, return false;\\n            if (board[r][col] == num) {\\n                return false;\\n            }\\n        }\\n\\n        // Corresponding square has\\n        // unique number (box-clash)\\n        int sqrt = (int) Math.sqrt(board.length);\\n        int boxRowStart = row - row % sqrt;\\n        int boxColStart = col - col % sqrt;\\n\\n        for (int r = boxRowStart;\\n                r < boxRowStart + sqrt; r++) {\\n            for (int d = boxColStart;\\n                    d < boxColStart + sqrt; d++) {\\n                if (board[r][d] == num) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        // if there is no clash, it's safe\\n        return true;\\n    }\\n\\n    public static boolean solveSudoku(\\n            int[][] board, int n) {\\n        int row = -1;\\n        int col = -1;\\n        boolean isEmpty = true;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == 0) {\\n                    row = i;\\n                    col = j;\\n\\n                    // We still have some remaining\\n                    // missing values in Sudoku\\n                    isEmpty = false;\\n                    break;\\n                }\\n            }\\n            if (!isEmpty) {\\n                break;\\n            }\\n        }\\n\\n        // No empty space left\\n        if (isEmpty) {\\n            return true;\\n        }\\n\\n        // Else for each-row backtrack\\n        for (int num = 1; num <= n; num++) {\\n            if (isSafe(board, row, col, num)) {\\n                board[row][col] = num;\\n                if (solveSudoku(board, n)) {\\n                    // print(board, n);\\n                    return true;\\n                } else {\\n                    // replace it\\n                    board[row][col] = 0;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void print(\\n            int[][] board, int N) {\\n\\n        // We got the answer, just print it\\n        for (int r = 0; r < N; r++) {\\n            for (int d = 0; d < N; d++) {\\n                System.out.print(board[r][d]);\\n                System.out.print(\\\" \\\");\\n            }\\n            System.out.print(\\\"\\\\n\\\");\\n\\n            if ((r + 1) % (int) Math.sqrt(N) == 0) {\\n                System.out.print(\\\"\\\");\\n            }\\n        }\\n    }\\n\\n    // Driver Code\\n    public static void main(String args[]) {\\n\\n        int[][] board = new int[][]{\\n            {3, 0, 6, 5, 0, 8, 4, 0, 0},\\n            {5, 2, 0, 0, 0, 0, 0, 0, 0},\\n            {0, 8, 7, 0, 0, 0, 0, 3, 1},\\n            {0, 0, 3, 0, 1, 0, 0, 8, 0},\\n            {9, 0, 0, 8, 6, 3, 0, 0, 5},\\n            {0, 5, 0, 0, 9, 0, 6, 0, 0},\\n            {1, 3, 0, 0, 0, 0, 2, 5, 0},\\n            {0, 0, 0, 0, 0, 0, 0, 7, 4},\\n            {0, 0, 5, 2, 0, 6, 3, 0, 0}\\n        };\\n        int N = board.length;\\n\\n        if (solveSudoku(board, N)) {\\n            // print solution\\n            print(board, N);\\n        } else {\\n            System.out.println(\\\"No solution\\\");\\n        }\\n    }\\n}\\n\"",
    "three sum": "\"package com.thealgorithms.others;\\n\\nimport java.util.Arrays;\\nimport java.util.Scanner;\\n\\n/**\\n * To find triplet equals to given sum in complexity O(n*log(n))\\n *\\n * <p>\\n * Array must be sorted\\n *\\n * @author Ujjawal Joshi\\n * @date 2020.05.18\\n * <p>\\n * Test Cases: Input: 6 //Length of array 12 3 4 1 6 9 target=24 Output:3 9 12\\n * Explanation: There is a triplet (12, 3 and 9) present in the array whose sum\\n * is 24.\\n */\\nclass ThreeSum {\\n\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n        int n = sc.nextInt(); // Length of an array\\n\\n        int a[] = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = sc.nextInt();\\n        }\\n        System.out.println(\\\"Target\\\");\\n        int n_find = sc.nextInt();\\n\\n        Arrays.sort(a); // Sort the array if array is not sorted\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            int l = i + 1, r = n - 1;\\n\\n            while (l < r) {\\n                if (a[i] + a[l] + a[r] == n_find) {\\n                    System.out.println(a[i] + \\\" \\\" + a[l] + \\\" \\\" + a[r]);\\n                    break;\\n                } // if you want all the triplets write l++;r--; insted of break;\\n                else if (a[i] + a[l] + a[r] < n_find) {\\n                    l++;\\n                } else {\\n                    r--;\\n                }\\n            }\\n        }\\n\\n        sc.close();\\n    }\\n}\\n\"",
    "top k words": "\"package com.thealgorithms.others;\\n\\nimport java.io.*;\\nimport java.util.*;\\n\\n/* display the most frequent K words in the file and the times it appear\\nin the file – shown in order (ignore case and periods) */\\npublic class TopKWords {\\n\\n    static class CountWords {\\n\\n        private String fileName;\\n\\n        public CountWords(String fileName) {\\n            this.fileName = fileName;\\n        }\\n\\n        public Map<String, Integer> getDictionary() {\\n            Map<String, Integer> dictionary = new HashMap<>();\\n            FileInputStream fis = null;\\n\\n            try {\\n\\n                fis = new FileInputStream(fileName); // open the file\\n                int in = 0;\\n                String s = \\\"\\\"; // init a empty word\\n                in = fis.read(); // read one character\\n\\n                while (-1 != in) {\\n                    if (Character.isLetter((char) in)) {\\n                        s += (char) in; // if get a letter, append to s\\n                    } else {\\n                        // this branch means an entire word has just been read\\n                        if (s.length() > 0) {\\n                            // see whether word exists or not\\n                            if (dictionary.containsKey(s)) {\\n                                // if exist, count++\\n                                dictionary.put(s, dictionary.get(s) + 1);\\n                            } else {\\n                                // if not exist, initiate count of this word with 1\\n                                dictionary.put(s, 1);\\n                            }\\n                        }\\n                        s = \\\"\\\"; // reInit a empty word\\n                    }\\n                    in = fis.read();\\n                }\\n                return dictionary;\\n            } catch (IOException e) {\\n                e.printStackTrace();\\n            } finally {\\n                try {\\n                    // you always have to close the I/O streams\\n                    if (fis != null) {\\n                        fis.close();\\n                    }\\n                } catch (IOException e) {\\n                    e.printStackTrace();\\n                }\\n            }\\n            return null;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        // you can replace the filePath with yours\\n        CountWords cw = new CountWords(\\\"/Users/lisanaaa/Desktop/words.txt\\\");\\n        Map<String, Integer> dictionary\\n                = cw.getDictionary(); // get the words dictionary: {word: frequency}\\n\\n        // we change the map to list for convenient sort\\n        List<Map.Entry<String, Integer>> list = new ArrayList<>(dictionary.entrySet());\\n\\n        // sort by lambda valueComparator\\n        list.sort(Comparator.comparing(m -> m.getValue()));\\n\\n        Scanner input = new Scanner(System.in);\\n        int k = input.nextInt();\\n        while (k > list.size()) {\\n            System.out.println(\\\"Retype a number, your number is too large\\\");\\n            input = new Scanner(System.in);\\n            k = input.nextInt();\\n        }\\n        for (int i = 0; i < k; i++) {\\n            System.out.println(list.get(list.size() - i - 1));\\n        }\\n        input.close();\\n    }\\n}\\n\"",
    "tower of hanoi": "\"package com.thealgorithms.others;\\n\\nimport java.util.Scanner;\\n\\nclass TowerOfHanoi {\\n\\n    public static void shift(int n, String startPole, String intermediatePole, String endPole) {\\n        // if n becomes zero the program returns thus ending the loop.\\n        if (n != 0) {\\n            // Shift function is called in recursion for swapping the n-1 disc from the startPole to the\\n            // intermediatePole\\n            shift(n - 1, startPole, endPole, intermediatePole);\\n            System.out.format(\\\"Move %d from %s to %s\\\\n\\\", n, startPole, endPole); // Result Printing\\n            // Shift function is called in recursion for swapping the n-1 disc from the intermediatePole\\n            // to the endPole\\n            shift(n - 1, intermediatePole, startPole, endPole);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.print(\\\"Enter number of discs on Pole 1: \\\");\\n        Scanner scanner = new Scanner(System.in);\\n        int numberOfDiscs = scanner.nextInt(); // input of number of discs on pole 1\\n        shift(numberOfDiscs, \\\"Pole1\\\", \\\"Pole2\\\", \\\"Pole3\\\"); // Shift function called\\n        scanner.close();\\n    }\\n}\\n\"",
    "two pointers": "\"package com.thealgorithms.others;\\n\\nimport java.util.Arrays;\\n\\n/**\\n * The two pointer technique is a useful tool to utilize when searching for\\n * pairs in a sorted array.\\n *\\n * <p>\\n * link: https://www.geeksforgeeks.org/two-pointers-technique/\\n */\\nclass TwoPointers {\\n\\n    public static void main(String[] args) {\\n        int[] arr = {10, 20, 35, 50, 75, 80};\\n        int key = 70;\\n        assert isPairedSum(arr, key);\\n        /* 20 + 60 == 70 */\\n\\n        arr = new int[]{1, 2, 3, 4, 5, 6, 7};\\n        key = 13;\\n        assert isPairedSum(arr, key);\\n        /* 6 + 7 == 13 */\\n\\n        key = 14;\\n        assert !isPairedSum(arr, key);\\n    }\\n\\n    /**\\n     * Given a sorted array arr (sorted in ascending order). Find if there\\n     * exists any pair of elements such that their sum is equal to key.\\n     *\\n     * @param arr the array contains elements\\n     * @param key the number to search\\n     * @return {@code true} if there exists a pair of elements, {@code false}\\n     * otherwise.\\n     */\\n    private static boolean isPairedSum(int[] arr, int key) {\\n        /* array sorting is necessary for this algorithm to function correctly */\\n        Arrays.sort(arr);\\n        int i = 0;\\n        /* index of first element */\\n        int j = arr.length - 1;\\n        /* index of last element */\\n\\n        while (i < j) {\\n            if (arr[i] + arr[j] == key) {\\n                return true;\\n            } else if (arr[i] + arr[j] < key) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\"",
    "verhoeff": "\"package com.thealgorithms.others;\\n\\nimport java.util.Objects;\\n\\n/**\\n * The Verhoeff algorithm is a checksum formula for error detection developed by\\n * the Dutch mathematician Jacobus Verhoeff and was first published in 1969. It\\n * was the first decimal check digit algorithm which detects all single-digit\\n * errors, and all transposition errors involving two adjacent digits.\\n *\\n * <p>\\n * The strengths of the algorithm are that it detects all transliteration and\\n * transposition errors, and additionally most twin, twin jump, jump\\n * transposition and phonetic errors. The main weakness of the Verhoeff\\n * algorithm is its complexity. The calculations required cannot easily be\\n * expressed as a formula. For easy calculation three tables are required:</p>\\n * <ol>\\n * <li>multiplication table</li>\\n * <li>inverse table</li>\\n * <li>permutation table</li>\\n * </ol>\\n *\\n * @see <a href=\\\"https://en.wikipedia.org/wiki/Verhoeff_algorithm\\\">Wiki.\\n * Verhoeff algorithm</a>\\n */\\npublic class Verhoeff {\\n\\n    /**\\n     * Table {@code d}. Based on multiplication in the dihedral group D5 and is\\n     * simply the Cayley table of the group. Note that this group is not\\n     * commutative, that is, for some values of {@code j} and {@code k},\\n     * {@code d(j,k) ≠ d(k, j)}.\\n     *\\n     * @see <a href=\\\"https://en.wikipedia.org/wiki/Dihedral_group\\\">Wiki.\\n     * Dihedral group</a>\\n     */\\n    private static final byte[][] MULTIPLICATION_TABLE = {\\n        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\\n        {1, 2, 3, 4, 0, 6, 7, 8, 9, 5},\\n        {2, 3, 4, 0, 1, 7, 8, 9, 5, 6},\\n        {3, 4, 0, 1, 2, 8, 9, 5, 6, 7},\\n        {4, 0, 1, 2, 3, 9, 5, 6, 7, 8},\\n        {5, 9, 8, 7, 6, 0, 4, 3, 2, 1},\\n        {6, 5, 9, 8, 7, 1, 0, 4, 3, 2},\\n        {7, 6, 5, 9, 8, 2, 1, 0, 4, 3},\\n        {8, 7, 6, 5, 9, 3, 2, 1, 0, 4},\\n        {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}\\n    };\\n\\n    /**\\n     * The inverse table {@code inv}. Represents the multiplicative inverse of a\\n     * digit, that is, the value that satisfies {@code d(j, inv(j)) = 0}.\\n     */\\n    private static final byte[] MULTIPLICATIVE_INVERSE = {0, 4, 3, 2, 1, 5, 6, 7, 8, 9};\\n\\n    /**\\n     * The permutation table {@code p}. Applies a permutation to each digit\\n     * based on its position in the number. This is actually a single\\n     * permutation {@code (1 5 8 9 4 2 7 0)(3 6)} applied iteratively; i.e.\\n     * {@code p(i+j,n) = p(i, p(j,n))}.\\n     */\\n    private static final byte[][] PERMUTATION_TABLE = {\\n        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\\n        {1, 5, 7, 6, 2, 8, 3, 0, 9, 4},\\n        {5, 8, 0, 3, 7, 9, 6, 1, 4, 2},\\n        {8, 9, 1, 6, 0, 4, 3, 5, 2, 7},\\n        {9, 4, 5, 3, 1, 2, 6, 8, 7, 0},\\n        {4, 2, 8, 6, 5, 7, 3, 9, 0, 1},\\n        {2, 7, 9, 3, 8, 0, 6, 4, 1, 5},\\n        {7, 0, 4, 6, 9, 1, 3, 2, 5, 8}\\n    };\\n\\n    /**\\n     * Check input digits by Verhoeff algorithm.\\n     *\\n     * @param digits input to check\\n     * @return true if check was successful, false otherwise\\n     * @throws IllegalArgumentException if input parameter contains not only\\n     * digits\\n     * @throws NullPointerException if input is null\\n     */\\n    public static boolean verhoeffCheck(String digits) {\\n        checkInput(digits);\\n        int[] numbers = toIntArray(digits);\\n\\n        // The Verhoeff algorithm\\n        int checksum = 0;\\n        for (int i = 0; i < numbers.length; i++) {\\n            int index = numbers.length - i - 1;\\n            byte b = PERMUTATION_TABLE[i % 8][numbers[index]];\\n            checksum = MULTIPLICATION_TABLE[checksum][b];\\n        }\\n\\n        return checksum == 0;\\n    }\\n\\n    /**\\n     * Calculate check digit for initial digits and add it tho the last\\n     * position.\\n     *\\n     * @param initialDigits initial value\\n     * @return digits with the checksum in the last position\\n     * @throws IllegalArgumentException if input parameter contains not only\\n     * digits\\n     * @throws NullPointerException if input is null\\n     */\\n    public static String addVerhoeffChecksum(String initialDigits) {\\n        checkInput(initialDigits);\\n\\n        // Add zero to end of input value\\n        var modifiedDigits = initialDigits + \\\"0\\\";\\n\\n        int[] numbers = toIntArray(modifiedDigits);\\n\\n        int checksum = 0;\\n        for (int i = 0; i < numbers.length; i++) {\\n            int index = numbers.length - i - 1;\\n            byte b = PERMUTATION_TABLE[i % 8][numbers[index]];\\n            checksum = MULTIPLICATION_TABLE[checksum][b];\\n        }\\n        checksum = MULTIPLICATIVE_INVERSE[checksum];\\n\\n        return initialDigits + checksum;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(\\\"Verhoeff algorithm usage examples:\\\");\\n        var validInput = \\\"2363\\\";\\n        var invalidInput = \\\"2364\\\";\\n        checkAndPrint(validInput);\\n        checkAndPrint(invalidInput);\\n\\n        System.out.println(\\\"\\\\nCheck digit generation example:\\\");\\n        var input = \\\"236\\\";\\n        generateAndPrint(input);\\n    }\\n\\n    private static void checkAndPrint(String input) {\\n        String validationResult = Verhoeff.verhoeffCheck(input)\\n                ? \\\"valid\\\"\\n                : \\\"not valid\\\";\\n        System.out.println(\\\"Input '\\\" + input + \\\"' is \\\" + validationResult);\\n    }\\n\\n    private static void generateAndPrint(String input) {\\n        String result = addVerhoeffChecksum(input);\\n        System.out.println(\\\"Generate and add checksum to initial value '\\\" + input + \\\"'. Result: '\\\" + result + \\\"'\\\");\\n    }\\n\\n    private static void checkInput(String input) {\\n        Objects.requireNonNull(input);\\n        if (!input.matches(\\\"\\\\\\\\d+\\\")) {\\n            throw new IllegalArgumentException(\\\"Input '\\\" + input + \\\"' contains not only digits\\\");\\n        }\\n    }\\n\\n    private static int[] toIntArray(String string) {\\n        return string.chars()\\n                .map(i -> Character.digit(i, 10))\\n                .toArray();\\n    }\\n}\\n\"",
    "worst fit": "\"package com.thealgorithms.others;\\n\\nimport java.util.ArrayList;\\n\\n/**\\n * @author Dekas Dimitrios\\n */\\npublic class WorstFit {\\n\\n    private static final int NO_ALLOCATION\\n            = -255; // if a process has been allocated in position -255,\\n    // it means that it has not been actually allocated.\\n\\n    /**\\n     * Method to find the index of the memory block that is going to fit the\\n     * given process based on the worst fit algorithm.\\n     *\\n     * @param blocks: the array with the available memory blocks.\\n     * @param process: the size of the process.\\n     * @return the index of the block that fits, or -255 if no such block\\n     * exists.\\n     */\\n    private static int findWorstFit(int[] blockSizes, int processSize) {\\n        int max = -1;\\n        int index = -1;\\n        for (int i = 0;\\n                i < blockSizes.length;\\n                i++) { // Find the index of the biggest memory block available.\\n            if (blockSizes[i] > max) {\\n                max = blockSizes[i];\\n                index = i;\\n            }\\n        }\\n        // If the biggest memory block cannot fit the process, return -255 as the result\\n        if (processSize > blockSizes[index]) {\\n            return NO_ALLOCATION;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Method to allocate memory to blocks according to the worst fit algorithm.\\n     * It should return an ArrayList of Integers, where the index is the process\\n     * ID (zero-indexed) and the value is the block number (also zero-indexed).\\n     *\\n     * @param sizeOfBlocks: an int array that contains the sizes of the memory\\n     * blocks available.\\n     * @param sizeOfProcesses: an int array that contains the sizes of the\\n     * processes we need memory blocks for.\\n     * @return the ArrayList filled with Integers repressenting the memory\\n     * allocation that took place.\\n     */\\n    static ArrayList<Integer> worstFit(int[] sizeOfBlocks, int[] sizeOfProcesses) {\\n        // The array list responsible for saving the memory allocations done by the worst-fit algorithm\\n        ArrayList<Integer> memAlloc = new ArrayList<>();\\n        // Do this for every process\\n        for (int processSize : sizeOfProcesses) {\\n            int chosenBlockIdx\\n                    = findWorstFit(\\n                            sizeOfBlocks, processSize); // Find the index of the memory block going to be used\\n            memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list\\n            if (chosenBlockIdx\\n                    != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,\\n                sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size\\n            }\\n        }\\n        return memAlloc;\\n    }\\n\\n    /**\\n     * Method to print the memory allocated.\\n     *\\n     * @param memAllocation: an ArrayList of Integer representing the memory\\n     * allocation done by the worstFit method.\\n     */\\n    public static void printMemoryAllocation(ArrayList<Integer> memAllocation) {\\n        System.out.println(\\\"Process No.\\\\tBlock No.\\\");\\n        System.out.println(\\\"===========\\\\t=========\\\");\\n        for (int i = 0; i < memAllocation.size(); i++) {\\n            System.out.print(\\\" \\\" + i + \\\"\\\\t\\\\t\\\");\\n            if (memAllocation.get(i) != NO_ALLOCATION) {\\n                System.out.print(memAllocation.get(i));\\n            } else {\\n                System.out.print(\\\"Not Allocated\\\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n}\\n\"",
    "binary search": "\"package com.thealgorithms.searches;\\n\\nimport static java.lang.String.format;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\nimport java.util.concurrent.ThreadLocalRandom;\\nimport java.util.stream.IntStream;\\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\\n\\n/**\\n * Binary search is one of the most popular algorithms The algorithm finds the\\n * position of a target value within a sorted array\\n *\\n * <p>\\n * Worst-case performance O(log n) Best-case performance O(1) Average\\n * performance O(log n) Worst-case space complexity O(1)\\n *\\n * @author Varun Upadhyay (https://github.com/varunu28)\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @see SearchAlgorithm\\n * @see IterativeBinarySearch\\n */\\nclass BinarySearch implements SearchAlgorithm {\\n\\n    /**\\n     * @param array is an array where the element should be found\\n     * @param key is an element which should be found\\n     * @param <T> is any comparable type\\n     * @return index of the element\\n     */\\n    @Override\\n    public <T extends Comparable<T>> int find(T[] array, T key) {\\n        return search(array, key, 0, array.length);\\n    }\\n\\n    /**\\n     * This method implements the Generic Binary Search\\n     *\\n     * @param array The array to make the binary search\\n     * @param key The number you are looking for\\n     * @param left The lower bound\\n     * @param right The upper bound\\n     * @return the location of the key\\n     */\\n    private <T extends Comparable<T>> int search(T array[], T key, int left, int right) {\\n        if (right < left) {\\n            return -1; // this means that the key not found\\n        }\\n        // find median\\n        int median = (left + right) >>> 1;\\n        int comp = key.compareTo(array[median]);\\n\\n        if (comp == 0) {\\n            return median;\\n        } else if (comp < 0) {\\n            return search(array, key, left, median - 1);\\n        } else {\\n            return search(array, key, median + 1, right);\\n        }\\n    }\\n\\n    // Driver Program\\n    public static void main(String[] args) {\\n        // Just generate data\\n        Random r = ThreadLocalRandom.current();\\n\\n        int size = 100;\\n        int maxElement = 100000;\\n\\n        Integer[] integers\\n                = IntStream.generate(() -> r.nextInt(maxElement))\\n                        .limit(size)\\n                        .sorted()\\n                        .boxed()\\n                        .toArray(Integer[]::new);\\n\\n        // The element that should be found\\n        int shouldBeFound = integers[r.nextInt(size - 1)];\\n\\n        BinarySearch search = new BinarySearch();\\n        int atIndex = search.find(integers, shouldBeFound);\\n\\n        System.out.println(\\n                format(\\n                        \\\"Should be found: %d. Found %d at index %d. An array length %d\\\",\\n                        shouldBeFound, integers[atIndex], atIndex, size));\\n\\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\\n        System.out.println(\\n                format(\\n                        \\\"Found by system method at an index: %d. Is equal: %b\\\", toCheck, toCheck == atIndex));\\n    }\\n}\\n\"",
    "breadth first search": "\"package com.thealgorithms.searches;\\n\\nimport com.thealgorithms.searches.DepthFirstSearch.Node;\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Objects;\\nimport java.util.Optional;\\n\\n/**\\n * @author: caos321\\n * @date: 31 October 2021 (Sunday)\\n */\\npublic class BreadthFirstSearch {\\n\\n    public static Optional<Node> search(final Node node, final String name) {\\n        if (node.getName().equals(name)) {\\n            return Optional.of(node);\\n        }\\n\\n        List<Node> queue = new ArrayList<>(node.getSubNodes());\\n\\n        while (!queue.isEmpty()) {\\n            final Node current = queue.get(0);\\n\\n            if (current.getName().equals(name)) {\\n                return Optional.of(current);\\n            }\\n\\n            queue.addAll(current.getSubNodes());\\n\\n            queue.remove(0);\\n        }\\n\\n        return Optional.empty();\\n    }\\n\\n    public static void assertThat(final Object actual, final Object expected) {\\n        if (!Objects.equals(actual, expected)) {\\n            throw new AssertionError(String.format(\\\"expected=%s but was actual=%s\\\", expected, actual));\\n        }\\n    }\\n\\n    public static void main(final String[] args) {\\n        final Node rootNode = new Node(\\\"A\\\", List.of(\\n                new Node(\\\"B\\\", List.of(new Node(\\\"D\\\"), new Node(\\\"F\\\", List.of(\\n                        new Node(\\\"H\\\"), new Node(\\\"I\\\")\\n                )))),\\n                new Node(\\\"C\\\", List.of(new Node(\\\"G\\\"))),\\n                new Node(\\\"E\\\")\\n        ));\\n\\n        {\\n            final String expected = \\\"I\\\";\\n\\n            final Node result = search(rootNode, expected)\\n                    .orElseThrow(() -> new AssertionError(\\\"Node not found!\\\"));\\n\\n            assertThat(result.getName(), expected);\\n        }\\n\\n        {\\n            final String expected = \\\"G\\\";\\n\\n            final Node result = search(rootNode, expected)\\n                    .orElseThrow(() -> new AssertionError(\\\"Node not found!\\\"));\\n\\n            assertThat(result.getName(), expected);\\n        }\\n\\n        {\\n            final String expected = \\\"E\\\";\\n\\n            final Node result = search(rootNode, expected)\\n                    .orElseThrow(() -> new AssertionError(\\\"Node not found!\\\"));\\n\\n            assertThat(result.getName(), expected);\\n        }\\n    }\\n}\\n\"",
    "depth first search": "\"package com.thealgorithms.searches;\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Objects;\\nimport java.util.Optional;\\n\\n/**\\n * @author: caos321\\n * @date: 31 October 2021 (Sunday)\\n */\\npublic class DepthFirstSearch {\\n\\n    static class Node {\\n\\n        private final String name;\\n        private final List<Node> subNodes;\\n\\n        public Node(final String name) {\\n            this.name = name;\\n            this.subNodes = new ArrayList<>();\\n        }\\n\\n        public Node(final String name, final List<Node> subNodes) {\\n            this.name = name;\\n            this.subNodes = subNodes;\\n        }\\n\\n        public String getName() {\\n            return name;\\n        }\\n\\n        public List<Node> getSubNodes() {\\n            return subNodes;\\n        }\\n    }\\n\\n    public static Optional<Node> search(final Node node, final String name) {\\n        if (node.getName().equals(name)) {\\n            return Optional.of(node);\\n        }\\n\\n        return node.getSubNodes()\\n                .stream()\\n                .map(value -> search(value, name))\\n                .flatMap(Optional::stream)\\n                .findAny();\\n    }\\n\\n    public static void assertThat(final Object actual, final Object expected) {\\n        if (!Objects.equals(actual, expected)) {\\n            throw new AssertionError(String.format(\\\"expected=%s but was actual=%s\\\", expected, actual));\\n        }\\n    }\\n\\n    public static void main(final String[] args) {\\n        final Node rootNode = new Node(\\\"A\\\", List.of(\\n                new Node(\\\"B\\\", List.of(new Node(\\\"D\\\"), new Node(\\\"F\\\", List.of(\\n                        new Node(\\\"H\\\"), new Node(\\\"I\\\")\\n                )))),\\n                new Node(\\\"C\\\", List.of(new Node(\\\"G\\\"))),\\n                new Node(\\\"E\\\")\\n        ));\\n\\n        {\\n            final String expected = \\\"I\\\";\\n\\n            final Node result = search(rootNode, expected)\\n                    .orElseThrow(() -> new AssertionError(\\\"Node not found!\\\"));\\n\\n            assertThat(result.getName(), expected);\\n        }\\n\\n        {\\n            final String expected = \\\"G\\\";\\n\\n            final Node result = search(rootNode, expected)\\n                    .orElseThrow(() -> new AssertionError(\\\"Node not found!\\\"));\\n\\n            assertThat(result.getName(), expected);\\n        }\\n\\n        {\\n            final String expected = \\\"E\\\";\\n\\n            final Node result = search(rootNode, expected)\\n                    .orElseThrow(() -> new AssertionError(\\\"Node not found!\\\"));\\n\\n            assertThat(result.getName(), expected);\\n        }\\n    }\\n}\\n\"",
    "exponental search": "\"package com.thealgorithms.searches;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\nimport java.util.concurrent.ThreadLocalRandom;\\nimport java.util.stream.IntStream;\\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\\n\\nimport static java.lang.String.format;\\n\\nclass ExponentialSearch implements SearchAlgorithm {\\n\\n    public static void main(String[] args) {\\n        Random r = ThreadLocalRandom.current();\\n\\n        int size = 100;\\n        int maxElement = 100000;\\n\\n        Integer[] integers\\n                = IntStream.generate(() -> r.nextInt(maxElement))\\n                        .limit(size)\\n                        .sorted()\\n                        .boxed()\\n                        .toArray(Integer[]::new);\\n\\n        // The element that should be found\\n        int shouldBeFound = integers[r.nextInt(size - 1)];\\n\\n        ExponentialSearch search = new ExponentialSearch();\\n        int atIndex = search.find(integers, shouldBeFound);\\n\\n        System.out.println(\\n                format(\\n                        \\\"Should be found: %d. Found %d at index %d. An array length %d\\\",\\n                        shouldBeFound, integers[atIndex], atIndex, size));\\n\\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\\n        System.out.println(\\n                format(\\n                        \\\"Found by system method at an index: %d. Is equal: %b\\\", toCheck, toCheck == atIndex));\\n\\n    }\\n\\n    @Override\\n    public <T extends Comparable<T>> int find(T[] array, T key) {\\n        if (array[0] == key) {\\n            return 0;\\n        }\\n        if (array[array.length - 1] == key) {\\n            return array.length;\\n        }\\n\\n        int range = 1;\\n\\n        while (range < array.length && array[range].compareTo(key) <= -1) {\\n            range = range * 2;\\n        }\\n\\n        return Arrays.binarySearch(array, range / 2, Math.min(range, array.length), key);\\n    }\\n}\\n\"",
    "fibonacci search": "\"package com.thealgorithms.searches;\\n\\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\\n\\n/*\\n*  Fibonacci Search is a popular algorithm which finds the position of a target value in\\n*  a sorted array\\n*\\n*  The time complexity for this search algorithm is O(log3(n))\\n*  The space complexity for this search algorithm is O(1)\\n*  @author Kanakalatha Vemuru (https://github.com/KanakalathaVemuru)\\n */\\npublic class FibonacciSearch implements SearchAlgorithm {\\n\\n    /**\\n     * @param array is a sorted array where the element has to be searched\\n     * @param key is an element whose position has to be found\\n     * @param <T> is any comparable type\\n     * @return index of the element\\n     */\\n    @Override\\n    public <T extends Comparable<T>> int find(T[] array, T key) {\\n        int fibMinus1 = 1;\\n        int fibMinus2 = 0;\\n        int fibNumber = fibMinus1 + fibMinus2;\\n        int n = array.length;\\n\\n        while (fibNumber < n) {\\n            fibMinus2 = fibMinus1;\\n            fibMinus1 = fibNumber;\\n            fibNumber = fibMinus2 + fibMinus1;\\n        }\\n\\n        int offset = -1;\\n\\n        while (fibNumber > 1) {\\n            int i = Math.min(offset + fibMinus2, n - 1);\\n\\n            if (array[i].compareTo(key) < 0) {\\n                fibNumber = fibMinus1;\\n                fibMinus1 = fibMinus2;\\n                fibMinus2 = fibNumber - fibMinus1;\\n                offset = i;\\n            } else if (array[i].compareTo(key) > 0) {\\n                fibNumber = fibMinus2;\\n                fibMinus1 = fibMinus1 - fibMinus2;\\n                fibMinus2 = fibNumber - fibMinus1;\\n            } else {\\n                return i;\\n            }\\n        }\\n\\n        if (fibMinus1 == 1 && array[offset + 1] == key) {\\n            return offset + 1;\\n        }\\n\\n        return -1;\\n    }\\n\\n    // Driver Program\\n    public static void main(String[] args) {\\n        Integer[] integers = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};\\n\\n        int size = integers.length;\\n        Integer shouldBeFound = 128;\\n        FibonacciSearch fsearch = new FibonacciSearch();\\n        int atIndex = fsearch.find(integers, shouldBeFound);\\n\\n        System.out.println(\\n                \\\"Should be found: \\\" + shouldBeFound + \\\". Found \\\" + integers[atIndex] + \\\" at index \\\" + atIndex + \\\". An array length \\\" + size);\\n    }\\n\\n}\\n\"",
    "how many times rotated": "\"package com.thealgorithms.searches;\\n\\nimport java.util.*;\\n\\n/*\\n    Problem Statement: \\n    Given an array, find out how many times it has to been rotated \\n    from its initial sorted position.\\n    Input-Output:\\n    Eg. [11,12,15,18,2,5,6,8]\\n    It has been rotated: 4 times\\n    (One rotation means putting the first element to the end)\\n    Note: The array cannot contain duplicates\\n\\n    Logic: \\n    The position of the minimum element will give the number of times the array has been rotated\\n    from its initial sorted position.\\n    Eg. For [2,5,6,8,11,12,15,18], 1 rotation gives [5,6,8,11,12,15,18,2], 2 rotations [6,8,11,12,15,18,2,5] and so on.\\n    Finding the minimum element will take O(N) time but, we can  use Binary Search to find the mimimum element, we can reduce the complexity to O(log N).\\n    If we look at the rotated array, to identify the minimum element (say a[i]), we observe that  a[i-1]>a[i]<a[i+1].\\n\\n    Some other test cases: \\n    1. [1,2,3,4] Number of rotations: 0 or 4(Both valid)\\n    2. [15,17,2,3,5] Number of rotations: 3\\n */\\nclass HowManyTimesRotated {\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        int n = sc.nextInt();\\n        int[] a = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            a[i] = sc.nextInt();\\n        }\\n\\n        System.out.println(\\\"The array has been rotated \\\" + rotated(a) + \\\" times\\\");\\n        sc.close();\\n\\n    }\\n\\n    public static int rotated(int[] a) {\\n        int low = 0;\\n        int high = a.length - 1;\\n        int mid = 0; // low + (high-low)/2 = (low + high)/2\\n\\n        while (low <= high) {\\n            mid = low + (high - low) / 2;\\n\\n            if (a[mid] < a[mid - 1] && a[mid] < a[mid + 1]) {\\n                break;\\n            } else if (a[mid] > a[mid - 1] && a[mid] < a[mid + 1]) {\\n                high = mid + 1;\\n            } else if (a[mid] > a[mid - 1] && a[mid] > a[mid + 1]) {\\n                low = mid - 1;\\n            }\\n        }\\n\\n        return mid;\\n    }\\n}\\n\"",
    "interpolation search": "\"package com.thealgorithms.searches;\\n\\nimport static java.lang.String.format;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\nimport java.util.stream.IntStream;\\n\\n/**\\n * Interpolation search algorithm implementation\\n *\\n * <p>\\n * Worst-case performance O(n) Best-case performance O(1) Average performance\\n * O(log(log(n))) if the elements are uniformly distributed if not O(n)\\n * Worst-case space complexity O(1)\\n *\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n */\\nclass InterpolationSearch {\\n\\n    /**\\n     * @param array is a sorted array\\n     * @param key is a value what shoulb be found in the array\\n     * @return an index if the array contains the key unless -1\\n     */\\n    public int find(int array[], int key) {\\n        // Find indexes of two corners\\n        int start = 0, end = (array.length - 1);\\n\\n        // Since array is sorted, an element present\\n        // in array must be in range defined by corner\\n        while (start <= end && key >= array[start] && key <= array[end]) {\\n            // Probing the position with keeping\\n            // uniform distribution in mind.\\n            int pos = start + (((end - start) / (array[end] - array[start])) * (key - array[start]));\\n\\n            // Condition of target found\\n            if (array[pos] == key) {\\n                return pos;\\n            }\\n\\n            // If key is larger, key is in upper part\\n            if (array[pos] < key) {\\n                start = pos + 1;\\n            } // If key is smaller, x is in lower part\\n            else {\\n                end = pos - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    // Driver method\\n    public static void main(String[] args) {\\n        Random r = new Random();\\n        int size = 100;\\n        int maxElement = 100000;\\n        int[] integers = IntStream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray();\\n\\n        // the element that should be found\\n        Integer shouldBeFound = integers[r.nextInt(size - 1)];\\n\\n        InterpolationSearch search = new InterpolationSearch();\\n        int atIndex = search.find(integers, shouldBeFound);\\n\\n        System.out.println(\\n                String.format(\\n                        \\\"Should be found: %d. Found %d at index %d. An array length %d\\\",\\n                        shouldBeFound, integers[atIndex], atIndex, size));\\n\\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\\n        System.out.println(\\n                format(\\n                        \\\"Found by system method at an index: %d. Is equal: %b\\\", toCheck, toCheck == atIndex));\\n    }\\n}\\n\"",
    "iterative binary search": "\"package com.thealgorithms.searches;\\n\\nimport static java.lang.String.format;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\nimport java.util.stream.Stream;\\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\\n\\n/**\\n * Binary search is one of the most popular algorithms This class represents\\n * iterative version {@link BinarySearch} Iterative binary search is likely to\\n * have lower constant factors because it doesn't involve the overhead of\\n * manipulating the call stack. But in java the recursive version can be\\n * optimized by the compiler to this version.\\n *\\n * <p>\\n * Worst-case performance O(log n) Best-case performance O(1) Average\\n * performance O(log n) Worst-case space complexity O(1)\\n *\\n * @author Gabriele La Greca : https://github.com/thegabriele97\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @see SearchAlgorithm\\n * @see BinarySearch\\n */\\npublic final class IterativeBinarySearch implements SearchAlgorithm {\\n\\n    /**\\n     * This method implements an iterative version of binary search algorithm\\n     *\\n     * @param array a sorted array\\n     * @param key the key to search in array\\n     * @return the index of key in the array or -1 if not found\\n     */\\n    @Override\\n    public <T extends Comparable<T>> int find(T[] array, T key) {\\n        int l, r, k, cmp;\\n\\n        l = 0;\\n        r = array.length - 1;\\n\\n        while (l <= r) {\\n            k = (l + r) >>> 1;\\n            cmp = key.compareTo(array[k]);\\n\\n            if (cmp == 0) {\\n                return k;\\n            } else if (cmp < 0) {\\n                r = --k;\\n            } else {\\n                l = ++k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    // Only a main method for test purpose\\n    public static void main(String[] args) {\\n        Random r = new Random();\\n        int size = 100;\\n        int maxElement = 100000;\\n        Integer[] integers\\n                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);\\n\\n        // the element that should be found\\n        Integer shouldBeFound = integers[r.nextInt(size - 1)];\\n\\n        IterativeBinarySearch search = new IterativeBinarySearch();\\n        int atIndex = search.find(integers, shouldBeFound);\\n\\n        System.out.println(\\n                String.format(\\n                        \\\"Should be found: %d. Found %d at index %d. An array length %d\\\",\\n                        shouldBeFound, integers[atIndex], atIndex, size));\\n\\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\\n        System.out.println(\\n                format(\\n                        \\\"Found by system method at an index: %d. Is equal: %b\\\", toCheck, toCheck == atIndex));\\n    }\\n}\\n\"",
    "iterative ternary search": "\"package com.thealgorithms.searches;\\n\\nimport static java.lang.String.format;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\nimport java.util.stream.Stream;\\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\\n\\n/**\\n * A iterative version of a ternary search algorithm This is better way to\\n * implement the ternary search, because a recursive version adds some overhead\\n * to a stack. But in java the compile can transform the recursive version to\\n * iterative implicitly, so there are no much differences between these two\\n * algorithms\\n *\\n * <p>\\n * Worst-case performance Θ(log3(N)) Best-case performance O(1) Average\\n * performance Θ(log3(N)) Worst-case space complexity O(1)\\n *\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @see SearchAlgorithm\\n * @see TernarySearch\\n * @since 2018-04-13\\n */\\npublic class IterativeTernarySearch implements SearchAlgorithm {\\n\\n    @Override\\n    public <T extends Comparable<T>> int find(T[] array, T key) {\\n        int left = 0;\\n        int right = array.length - 1;\\n\\n        while (right > left) {\\n\\n            int leftCmp = array[left].compareTo(key);\\n            int rightCmp = array[right].compareTo(key);\\n            if (leftCmp == 0) {\\n                return left;\\n            }\\n            if (rightCmp == 0) {\\n                return right;\\n            }\\n\\n            int leftThird = left + (right - left) / 3 + 1;\\n            int rightThird = right - (right - left) / 3 - 1;\\n\\n            if (array[leftThird].compareTo(key) <= 0) {\\n                left = leftThird;\\n            } else {\\n                right = rightThird;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    public static void main(String[] args) {\\n        // just generate data\\n        Random r = new Random();\\n        int size = 100;\\n        int maxElement = 100000;\\n        Integer[] integers\\n                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);\\n\\n        // the element that should be found\\n        Integer shouldBeFound = integers[r.nextInt(size - 1)];\\n\\n        IterativeTernarySearch search = new IterativeTernarySearch();\\n        int atIndex = search.find(integers, shouldBeFound);\\n\\n        System.out.println(\\n                format(\\n                        \\\"Should be found: %d. Found %d at index %d. An array length %d\\\",\\n                        shouldBeFound, integers[atIndex], atIndex, size));\\n\\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\\n        System.out.println(\\n                format(\\n                        \\\"Found by system method at an index: %d. Is equal: %b\\\", toCheck, toCheck == atIndex));\\n    }\\n}\\n\"",
    "jump search": "\"package com.thealgorithms.searches;\\n\\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\\n\\npublic class JumpSearch implements SearchAlgorithm {\\n\\n    public static void main(String[] args) {\\n        JumpSearch jumpSearch = new JumpSearch();\\n        Integer[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\\n        for (int i = 0; i < array.length; i++) {\\n            assert jumpSearch.find(array, i) == i;\\n        }\\n        assert jumpSearch.find(array, -1) == -1;\\n        assert jumpSearch.find(array, 11) == -1;\\n    }\\n\\n    /**\\n     * Jump Search algorithm implements\\n     *\\n     * @param array the array contains elements\\n     * @param key to be searched\\n     * @return index of {@code key} if found, otherwise <tt>-1</tt>\\n     */\\n    @Override\\n    public <T extends Comparable<T>> int find(T[] array, T key) {\\n        int length = array.length;\\n        /* length of array */\\n        int blockSize = (int) Math.sqrt(length);\\n        /* block size to be jumped */\\n\\n        int limit = blockSize;\\n        while (key.compareTo(array[limit]) > 0 && limit < array.length - 1) {\\n            limit = Math.min(limit + blockSize, array.length - 1);\\n        }\\n\\n        for (int i = limit - blockSize; i <= limit; i++) {\\n            if (array[i] == key) {\\n                /* execute linear search */\\n                return i;\\n            }\\n        }\\n        return -1;\\n        /* not found */\\n    }\\n}\\n\"",
    "linear search": "\"package com.thealgorithms.searches;\\n\\nimport java.util.Random;\\nimport java.util.stream.Stream;\\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\\n\\n/**\\n * Linear search is the easiest search algorithm It works with sorted and\\n * unsorted arrays (an binary search works only with sorted array) This\\n * algorithm just compares all elements of an array to find a value\\n *\\n * <p>\\n * Worst-case performance O(n) Best-case performance O(1) Average performance\\n * O(n) Worst-case space complexity\\n *\\n * @author Varun Upadhyay (https://github.com/varunu28)\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @see BinarySearch\\n * @see SearchAlgorithm\\n */\\npublic class LinearSearch implements SearchAlgorithm {\\n\\n    /**\\n     * Generic Linear search method\\n     *\\n     * @param array List to be searched\\n     * @param value Key being searched for\\n     * @return Location of the key\\n     */\\n    @Override\\n    public <T extends Comparable<T>> int find(T[] array, T value) {\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i].compareTo(value) == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public static void main(String[] args) {\\n        // just generate data\\n        Random r = new Random();\\n        int size = 200;\\n        int maxElement = 100;\\n        Integer[] integers\\n                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).toArray(Integer[]::new);\\n\\n        // the element that should be found\\n        Integer shouldBeFound = integers[r.nextInt(size - 1)];\\n\\n        LinearSearch search = new LinearSearch();\\n        int atIndex = search.find(integers, shouldBeFound);\\n\\n        System.out.println(\\n                String.format(\\n                        \\\"Should be found: %d. Found %d at index %d. An array length %d\\\",\\n                        shouldBeFound, integers[atIndex], atIndex, size));\\n    }\\n}\\n\"",
    "linear search thread": "\"package com.thealgorithms.searches;\\n\\nimport java.util.Scanner;\\n\\npublic class LinearSearchThread {\\n    public static void main(String[] args) {\\n        int[] list = new int[200];\\n        for (int j = 0; j < list.length; j++) {\\n            list[j] = (int) (Math.random() * 100);\\n        }\\n        for (int y : list) {\\n            System.out.print(y + \\\" \\\");\\n        }\\n        System.out.println();\\n        System.out.print(\\\"Enter number to search for: \\\");\\n        Scanner in = new Scanner(System.in);\\n        int x = in.nextInt();\\n        Searcher t = new Searcher(list, 0, 50, x);\\n        Searcher t1 = new Searcher(list, 50, 100, x);\\n        Searcher t2 = new Searcher(list, 100, 150, x);\\n        Searcher t3 = new Searcher(list, 150, 200, x);\\n        t.start();\\n        t1.start();\\n        t2.start();\\n        t3.start();\\n        try {\\n            t.join();\\n            t1.join();\\n            t2.join();\\n            t3.join();\\n        } catch (InterruptedException e) {\\n        }\\n        boolean found = t.getResult() || t1.getResult() || t2.getResult() || t3.getResult();\\n        System.out.println(\\\"Found = \\\" + found);\\n    }\\n}\\n\\nclass Searcher extends Thread {\\n    private final int[] arr;\\n    private final int left, right;\\n    private final int x;\\n    private boolean found;\\n\\n    Searcher(int[] arr, int left, int right, int x) {\\n        this.arr = arr;\\n        this.left = left;\\n        this.right = right;\\n        this.x = x;\\n    }\\n\\n    @Override\\n    public void run() {\\n        int k = left;\\n        found = false;\\n        while (k < right && !found) {\\n            if (arr[k++] == x) {\\n                found = true;\\n            }\\n        }\\n    }\\n\\n    boolean getResult() {\\n        return found;\\n    }\\n}\\n\"",
    "lower bound": "\"package com.thealgorithms.searches;\\n\\nimport static java.lang.String.format;\\n\\nimport java.util.Random;\\nimport java.util.concurrent.ThreadLocalRandom;\\nimport java.util.stream.IntStream;\\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\\n\\n/**\\n * The LowerBound method is used to return an index pointing to the first\\n * element in the range [first, last) which has a value not less than val, i.e.\\n * the index of the next smallest number just greater than or equal to that\\n * number. If there are multiple values that are equal to val it returns the\\n * index of the first such value.\\n *\\n * <p>\\n * This is an extension of BinarySearch.\\n *\\n * <p>\\n * Worst-case performance O(log n) Best-case performance O(1) Average\\n * performance O(log n) Worst-case space complexity O(1)\\n *\\n * @author Pratik Padalia (https://github.com/15pratik)\\n * @see SearchAlgorithm\\n * @see BinarySearch\\n */\\nclass LowerBound implements SearchAlgorithm {\\n\\n    // Driver Program\\n    public static void main(String[] args) {\\n        // Just generate data\\n        Random r = ThreadLocalRandom.current();\\n\\n        int size = 100;\\n        int maxElement = 100000;\\n\\n        Integer[] integers\\n                = IntStream.generate(() -> r.nextInt(maxElement))\\n                        .limit(size)\\n                        .sorted()\\n                        .boxed()\\n                        .toArray(Integer[]::new);\\n\\n        // The element for which the lower bound is to be found\\n        int val = integers[r.nextInt(size - 1)] + 1;\\n\\n        LowerBound search = new LowerBound();\\n        int atIndex = search.find(integers, val);\\n\\n        System.out.println(\\n                format(\\n                        \\\"Val: %d. Lower Bound Found %d at index %d. An array length %d\\\",\\n                        val, integers[atIndex], atIndex, size));\\n\\n        boolean toCheck = integers[atIndex] >= val || integers[size - 1] < val;\\n        System.out.println(\\n                format(\\n                        \\\"Lower Bound found at an index: %d. Is greater or max element: %b\\\", atIndex, toCheck));\\n    }\\n\\n    /**\\n     * @param array is an array where the LowerBound value is to be found\\n     * @param key is an element for which the LowerBound is to be found\\n     * @param <T> is any comparable type\\n     * @return index of the LowerBound element\\n     */\\n    @Override\\n    public <T extends Comparable<T>> int find(T[] array, T key) {\\n        return search(array, key, 0, array.length - 1);\\n    }\\n\\n    /**\\n     * This method implements the Generic Binary Search\\n     *\\n     * @param array The array to make the binary search\\n     * @param key The number you are looking for\\n     * @param left The lower bound\\n     * @param right The upper bound\\n     * @return the location of the key\\n     */\\n    private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) {\\n        if (right <= left) {\\n            return left;\\n        }\\n\\n        // find median\\n        int median = (left + right) >>> 1;\\n        int comp = key.compareTo(array[median]);\\n\\n        if (comp == 0) {\\n            return median;\\n        } else if (comp < 0) {\\n            // median position can be a possible solution\\n            return search(array, key, left, median);\\n        } else {\\n            // key we are looking is greater, so we must look on the right of median position\\n            return search(array, key, median + 1, right);\\n        }\\n    }\\n}\\n\"",
    "monte carlo tree search": "\"package com.thealgorithms.searches;\\n\\nimport java.util.Collections;\\nimport java.util.ArrayList;\\nimport java.util.Comparator;\\nimport java.util.Random;\\n\\n/**\\n * Monte Carlo Tree Search (MCTS) is a heuristic search algorithm used in\\n * decition taking problems especially games.\\n *\\n * See more: https://en.wikipedia.org/wiki/Monte_Carlo_tree_search,\\n * https://www.baeldung.com/java-monte-carlo-tree-search\\n */\\npublic class MonteCarloTreeSearch {\\n\\n    public class Node {\\n\\n        Node parent;\\n        ArrayList<Node> childNodes;\\n        boolean isPlayersTurn; // True if it is the player's turn.\\n        boolean playerWon; // True if the player won; false if the opponent won.\\n        int score;\\n        int visitCount;\\n\\n        public Node() {\\n        }\\n\\n        public Node(Node parent, boolean isPlayersTurn) {\\n            this.parent = parent;\\n            childNodes = new ArrayList<>();\\n            this.isPlayersTurn = isPlayersTurn;\\n            playerWon = false;\\n            score = 0;\\n            visitCount = 0;\\n        }\\n    }\\n\\n    static final int WIN_SCORE = 10;\\n    static final int TIME_LIMIT = 500; // Time the algorithm will be running for (in milliseconds).\\n\\n    public static void main(String[] args) {\\n        MonteCarloTreeSearch mcts = new MonteCarloTreeSearch();\\n\\n        mcts.monteCarloTreeSearch(mcts.new Node(null, true));\\n    }\\n\\n    /**\\n     * Explores a game tree using Monte Carlo Tree Search (MCTS) and returns the\\n     * most promising node.\\n     *\\n     * @param rootNode Root node of the game tree.\\n     * @return The most promising child of the root node.\\n     */\\n    public Node monteCarloTreeSearch(Node rootNode) {\\n        Node winnerNode;\\n        double timeLimit;\\n\\n        // Expand the root node.\\n        addChildNodes(rootNode, 10);\\n\\n        timeLimit = System.currentTimeMillis() + TIME_LIMIT;\\n\\n        // Explore the tree until the time limit is reached.\\n        while (System.currentTimeMillis() < timeLimit) {\\n            Node promisingNode;\\n\\n            // Get a promising node using UCT.\\n            promisingNode = getPromisingNode(rootNode);\\n\\n            // Expand the promising node.\\n            if (promisingNode.childNodes.size() == 0) {\\n                addChildNodes(promisingNode, 10);\\n            }\\n\\n            simulateRandomPlay(promisingNode);\\n        }\\n\\n        winnerNode = getWinnerNode(rootNode);\\n        printScores(rootNode);\\n        System.out.format(\\\"\\\\nThe optimal node is: %02d\\\\n\\\", rootNode.childNodes.indexOf(winnerNode) + 1);\\n\\n        return winnerNode;\\n    }\\n\\n    public void addChildNodes(Node node, int childCount) {\\n        for (int i = 0; i < childCount; i++) {\\n            node.childNodes.add(new Node(node, !node.isPlayersTurn));\\n        }\\n    }\\n\\n    /**\\n     * Uses UCT to find a promising child node to be explored.\\n     *\\n     * UCT: Upper Confidence bounds applied to Trees.\\n     *\\n     * @param rootNode Root node of the tree.\\n     * @return The most promising node according to UCT.\\n     */\\n    public Node getPromisingNode(Node rootNode) {\\n        Node promisingNode = rootNode;\\n\\n        // Iterate until a node that hasn't been expanded is found.\\n        while (promisingNode.childNodes.size() != 0) {\\n            double uctIndex = Double.MIN_VALUE;\\n            int nodeIndex = 0;\\n\\n            // Iterate through child nodes and pick the most promising one\\n            // using UCT (Upper Confidence bounds applied to Trees).\\n            for (int i = 0; i < promisingNode.childNodes.size(); i++) {\\n                Node childNode = promisingNode.childNodes.get(i);\\n                double uctTemp;\\n\\n                // If child node has never been visited\\n                // it will have the highest uct value.\\n                if (childNode.visitCount == 0) {\\n                    nodeIndex = i;\\n                    break;\\n                }\\n\\n                uctTemp = ((double) childNode.score / childNode.visitCount)\\n                        + 1.41 * Math.sqrt(Math.log(promisingNode.visitCount) / (double) childNode.visitCount);\\n\\n                if (uctTemp > uctIndex) {\\n                    uctIndex = uctTemp;\\n                    nodeIndex = i;\\n                }\\n            }\\n\\n            promisingNode = promisingNode.childNodes.get(nodeIndex);\\n        }\\n\\n        return promisingNode;\\n    }\\n\\n    /**\\n     * Simulates a random play from a nodes current state and back propagates\\n     * the result.\\n     *\\n     * @param promisingNode Node that will be simulated.\\n     */\\n    public void simulateRandomPlay(Node promisingNode) {\\n        Random rand = new Random();\\n        Node tempNode = promisingNode;\\n        boolean isPlayerWinner;\\n\\n        // The following line randomly determines whether the simulated play is a win or loss.\\n        // To use the MCTS algorithm correctly this should be a simulation of the nodes' current\\n        // state of the game until it finishes (if possible) and use an evaluation function to\\n        // determine how good or bad the play was.\\n        // e.g. Play tic tac toe choosing random squares until the game ends. \\n        promisingNode.playerWon = (rand.nextInt(6) == 0);\\n\\n        isPlayerWinner = promisingNode.playerWon;\\n\\n        // Back propagation of the random play.\\n        while (tempNode != null) {\\n            tempNode.visitCount++;\\n\\n            // Add wining scores to bouth player and opponent depending on the turn.\\n            if ((tempNode.isPlayersTurn && isPlayerWinner)\\n                    || (!tempNode.isPlayersTurn && !isPlayerWinner)) {\\n                tempNode.score += WIN_SCORE;\\n            }\\n\\n            tempNode = tempNode.parent;\\n        }\\n    }\\n\\n    public Node getWinnerNode(Node rootNode) {\\n        return Collections.max(rootNode.childNodes, Comparator.comparing(c -> c.score));\\n    }\\n\\n    public void printScores(Node rootNode) {\\n        System.out.println(\\\"N.\\\\tScore\\\\t\\\\tVisits\\\");\\n\\n        for (int i = 0; i < rootNode.childNodes.size(); i++) {\\n            System.out.println(String.format(\\\"%02d\\\\t%d\\\\t\\\\t%d\\\", i + 1,\\n                    rootNode.childNodes.get(i).score, rootNode.childNodes.get(i).visitCount));\\n        }\\n    }\\n}\\n\"",
    "perfect binary search": "\"package com.thealgorithms.searches;\\n\\nclass PerfectBinarySearch {\\n\\n    static int binarySearch(int[] arr, int target) {\\n        int low = 0;\\n        int high = arr.length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] > target) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public static void main(String[] args) {\\n        PerfectBinarySearch BinarySearch = new PerfectBinarySearch();\\n        int[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\\n        assert BinarySearch.binarySearch(array, -1) == -1;\\n        assert BinarySearch.binarySearch(array, 11) == -1;\\n    }\\n}\\n\"",
    "quick select": "\"package com.thealgorithms.searches;\\n\\nimport java.util.*;\\n\\n/**\\n * An implementation of the Quickselect algorithm as described\\n * <a href=\\\"https://en.wikipedia.org/wiki/Median_of_medians\\\">here</a>.\\n */\\npublic final class QuickSelect {\\n\\n    /**\\n     * Selects the {@code n}-th largest element of {@code list}, i.e. the element that would\\n     * be at index n if the list was sorted.\\n     * <p>\\n     * Calling this function might change the order of elements in {@code list}.\\n     *\\n     * @param list the list of elements\\n     * @param n    the index\\n     * @param <T>  the type of list elements\\n     * @return the n-th largest element in the list\\n     * @throws IndexOutOfBoundsException if n is less than 0 or greater or equal to\\n     *                                   the number of elements in the list\\n     * @throws IllegalArgumentException  if the list is empty\\n     * @throws NullPointerException      if {@code list} is null\\n     */\\n    public static <T extends Comparable<T>> T select(List<T> list, int n) {\\n        Objects.requireNonNull(list, \\\"The list of elements must not be null.\\\");\\n\\n        if (list.size() == 0) {\\n            String msg = \\\"The list of elements must not be empty.\\\";\\n            throw new IllegalArgumentException(msg);\\n        }\\n\\n        if (n < 0) {\\n            String msg = \\\"The index must not be negative.\\\";\\n            throw new IndexOutOfBoundsException(msg);\\n        }\\n\\n        if (n >= list.size()) {\\n            String msg = \\\"The index must be less than the number of elements.\\\";\\n            throw new IndexOutOfBoundsException(msg);\\n        }\\n\\n        int index = selectIndex(list, n);\\n        return list.get(index);\\n    }\\n\\n    private static <T extends Comparable<T>> int selectIndex(List<T> list, int n) {\\n        return selectIndex(list, 0, list.size() - 1, n);\\n    }\\n\\n    private static <T extends Comparable<T>> int selectIndex(\\n            List<T> list,\\n            int left,\\n            int right,\\n            int n\\n    ) {\\n        while (true) {\\n            if (left == right)\\n                return left;\\n            int pivotIndex = pivot(list, left, right);\\n            pivotIndex = partition(list, left, right, pivotIndex, n);\\n            if (n == pivotIndex) {\\n                return n;\\n            } else if (n < pivotIndex) {\\n                right = pivotIndex - 1;\\n            } else {\\n                left = pivotIndex + 1;\\n            }\\n        }\\n    }\\n\\n    private static <T extends Comparable<T>> int partition(\\n            List<T> list,\\n            int left,\\n            int right,\\n            int pivotIndex,\\n            int n\\n    ) {\\n        T pivotValue = list.get(pivotIndex);\\n        Collections.swap(list, pivotIndex, right);\\n        int storeIndex = left;\\n\\n        for (int i = left; i < right; i++) {\\n            if (list.get(i).compareTo(pivotValue) < 0) {\\n                Collections.swap(list, storeIndex, i);\\n                storeIndex++;\\n            }\\n        }\\n\\n        int storeIndexEq = storeIndex;\\n\\n        for (int i = storeIndex; i < right; i++) {\\n            if (list.get(i).compareTo(pivotValue) == 0) {\\n                Collections.swap(list, storeIndexEq, i);\\n                storeIndexEq++;\\n            }\\n        }\\n\\n        Collections.swap(list, right, storeIndexEq);\\n\\n        return (n < storeIndex)\\n                ? storeIndex\\n                : Math.min(n, storeIndexEq);\\n    }\\n\\n    private static <T extends Comparable<T>> int pivot(\\n            List<T> list,\\n            int left,\\n            int right\\n    ) {\\n        if (right - left < 5) {\\n            return partition5(list, left, right);\\n        }\\n\\n        for (int i = left; i < right; i += 5) {\\n            int subRight = i + 4;\\n            if (subRight > right) {\\n                subRight = right;\\n            }\\n            int median5 = partition5(list, i, subRight);\\n            int rightIndex = left + (i - left) / 5;\\n            Collections.swap(list, median5, rightIndex);\\n        }\\n\\n        int mid = (right - left) / 10 + left + 1;\\n        int rightIndex = left + (right - left) / 5;\\n        return selectIndex(list, left, rightIndex, mid);\\n    }\\n\\n    private static <T extends Comparable<T>> int partition5(\\n            List<T> list,\\n            int left,\\n            int right\\n    ) {\\n        List<T> ts = list.subList(left, right);\\n        ts.sort(Comparator.naturalOrder());\\n        return (left + right) >>> 1;\\n    }\\n}\\n\"",
    "saddleback search": "\"package com.thealgorithms.searches;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * Program to perform Saddleback Search Given a sorted 2D array(elements are\\n * sorted across every row and column, assuming ascending order) of size n*m we\\n * can search a given element in O(n+m)\\n *\\n * <p>\\n * we start from bottom left corner if the current element is greater than the\\n * given element then we move up else we move right Sample Input: 5 5\\n * ->Dimensions -10 -5 -3 4 9 -6 -2 0 5 10 -4 -1 1 6 12 2 3 7 8 13 100 120 130\\n * 140 150 140 ->element to be searched output: 4 3 // first value is row,\\n * second one is column\\n *\\n * @author Nishita Aggarwal\\n */\\npublic class SaddlebackSearch {\\n\\n    /**\\n     * This method performs Saddleback Search\\n     *\\n     * @param arr The **Sorted** array in which we will search the element.\\n     * @param row the current row.\\n     * @param col the current column.\\n     * @param key the element that we want to search for.\\n     * @return The index(row and column) of the element if found. Else returns\\n     * -1 -1.\\n     */\\n    private static int[] find(int arr[][], int row, int col, int key) {\\n\\n        // array to store the answer row and column\\n        int ans[] = {-1, -1};\\n        if (row < 0 || col >= arr[row].length) {\\n            return ans;\\n        }\\n        if (arr[row][col] == key) {\\n            ans[0] = row;\\n            ans[1] = col;\\n            return ans;\\n        } // if the current element is greater than the given element then we move up\\n        else if (arr[row][col] > key) {\\n            return find(arr, row - 1, col, key);\\n        }\\n        // else we move right\\n        return find(arr, row, col + 1, key);\\n    }\\n\\n    /**\\n     * Main method\\n     *\\n     * @param args Command line arguments\\n     */\\n    public static void main(String[] args) {\\n        // TODO Auto-generated method stub\\n        Scanner sc = new Scanner(System.in);\\n        int arr[][];\\n        int i, j, rows = sc.nextInt(), col = sc.nextInt();\\n        arr = new int[rows][col];\\n        for (i = 0; i < rows; i++) {\\n            for (j = 0; j < col; j++) {\\n                arr[i][j] = sc.nextInt();\\n            }\\n        }\\n        int ele = sc.nextInt();\\n        // we start from bottom left corner\\n        int ans[] = find(arr, rows - 1, 0, ele);\\n        System.out.println(ans[0] + \\\" \\\" + ans[1]);\\n        sc.close();\\n    }\\n}\\n\"",
    "square root binary search": "\"package com.thealgorithms.searches;\\n\\nimport java.util.Scanner;\\n\\n/**\\n * Given an integer x, find the square root of x. If x is not a perfect square,\\n * then return floor(√x).\\n * <p>\\n * For example, if x = 5, The answer should be 2 which is the floor value of √5.\\n * <p>\\n * The approach that will be used for solving the above problem is not going to\\n * be a straight forward Math.sqrt(). Instead we will be using Binary Search to\\n * find the square root of a number in the most optimised way.\\n *\\n * @author sahil\\n */\\npublic class SquareRootBinarySearch {\\n\\n    /**\\n     * This is the driver method.\\n     *\\n     * @param args Command line arguments\\n     */\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.print(\\\"Enter a number you want to calculate square root of : \\\");\\n        int num = sc.nextInt();\\n        long ans = squareRoot(num);\\n        System.out.println(\\\"The square root is : \\\" + ans);\\n    }\\n\\n    /**\\n     * This function calculates the floor of square root of a number. We use\\n     * Binary Search algorithm to calculate the square root in a more optimised\\n     * way.\\n     *\\n     * @param num Number\\n     * @return answer\\n     */\\n    private static long squareRoot(long num) {\\n        if (num == 0 || num == 1) {\\n            return num;\\n        }\\n        long l = 1;\\n        long r = num;\\n        long ans = 0;\\n        while (l <= r) {\\n            long mid = l + (r - l) / 2;\\n            if (mid == num / mid) {\\n                return mid;\\n            } else if (mid < num / mid) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\"",
    "ternary search": "\"package com.thealgorithms.searches;\\n\\nimport static java.lang.String.format;\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\nimport java.util.stream.Stream;\\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\\n\\n/**\\n * A ternary search algorithm is a technique in computer science for finding the\\n * minimum or maximum of a unimodal function The algorithm determines either\\n * that the minimum or maximum cannot be in the first third of the domain or\\n * that it cannot be in the last third of the domain, then repeats on the\\n * remaining third.\\n *\\n * <p>\\n * Worst-case performance Θ(log3(N)) Best-case performance O(1) Average\\n * performance Θ(log3(N)) Worst-case space complexity O(1)\\n *\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @see SearchAlgorithm\\n * @see IterativeBinarySearch\\n */\\npublic class TernarySearch implements SearchAlgorithm {\\n\\n    /**\\n     * @param arr The **Sorted** array in which we will search the element.\\n     * @param value The value that we want to search for.\\n     * @return The index of the element if found. Else returns -1.\\n     */\\n    @Override\\n    public <T extends Comparable<T>> int find(T[] arr, T value) {\\n        return ternarySearch(arr, value, 0, arr.length - 1);\\n    }\\n\\n    /**\\n     * @param arr The **Sorted** array in which we will search the element.\\n     * @param key The value that we want to search for.\\n     * @param start The starting index from which we will start Searching.\\n     * @param end The ending index till which we will Search.\\n     * @return Returns the index of the Element if found. Else returns -1.\\n     */\\n    private <T extends Comparable<T>> int ternarySearch(T[] arr, T key, int start, int end) {\\n        if (start > end) {\\n            return -1;\\n        }\\n        /* First boundary: add 1/3 of length to start */\\n        int mid1 = start + (end - start) / 3;\\n        /* Second boundary: add 2/3 of length to start */\\n        int mid2 = start + 2 * (end - start) / 3;\\n\\n        if (key.compareTo(arr[mid1]) == 0) {\\n            return mid1;\\n        } else if (key.compareTo(arr[mid2]) == 0) {\\n            return mid2;\\n        } /* Search the first (1/3) rd part of the array.*/ else if (key.compareTo(arr[mid1]) < 0) {\\n            return ternarySearch(arr, key, start, --mid1);\\n        } /* Search 3rd (1/3)rd part of the array */ else if (key.compareTo(arr[mid2]) > 0) {\\n            return ternarySearch(arr, key, ++mid2, end);\\n        } /* Search middle (1/3)rd part of the array */ else {\\n            return ternarySearch(arr, key, mid1, mid2);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        // just generate data\\n        Random r = new Random();\\n        int size = 100;\\n        int maxElement = 100000;\\n        Integer[] integers\\n                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);\\n\\n        // the element that should be found\\n        Integer shouldBeFound = integers[r.nextInt(size - 1)];\\n\\n        TernarySearch search = new TernarySearch();\\n        int atIndex = search.find(integers, shouldBeFound);\\n\\n        System.out.println(\\n                format(\\n                        \\\"Should be found: %d. Found %d at index %d. An array length %d\\\",\\n                        shouldBeFound, integers[atIndex], atIndex, size));\\n\\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\\n        System.out.println(\\n                format(\\n                        \\\"Found by system method at an index: %d. Is equal: %b\\\", toCheck, toCheck == atIndex));\\n    }\\n}\\n\"",
    "union find": "\"package com.thealgorithms.searches;\\n\\nimport java.util.*;\\n\\npublic class UnionFind {\\n\\n    private int[] p;\\n    private int[] r;\\n\\n    public UnionFind(int n) {\\n        p = new int[n];\\n        r = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            p[i] = i;\\n        }\\n    }\\n\\n    public int find(int i) {\\n        int parent = p[i];\\n\\n        if (i == parent) {\\n            return i;\\n        }\\n\\n        return p[i] = find(parent);\\n    }\\n\\n    public void union(int x, int y) {\\n        int r0 = find(x);\\n        int r1 = find(y);\\n\\n        if (r1 == r0) {\\n            return;\\n        }\\n\\n        if (r[r0] > r[r1]) {\\n            p[r1] = r0;\\n        } else if (r[r1] > r[r0]) {\\n            p[r0] = r1;\\n        } else {\\n            p[r1] = r0;\\n            r[r0]++;\\n        }\\n    }\\n\\n    public int count() {\\n        List parents = new ArrayList();\\n        for (int i = 0; i < p.length; i++) {\\n            if (!parents.contains(find(i))) {\\n                parents.add(find(i));\\n            }\\n        }\\n        return parents.size();\\n    }\\n\\n    public String toString() {\\n        return \\\"p \\\" + Arrays.toString(p) + \\\" r \\\" + Arrays.toString(r) + \\\"\\\\n\\\";\\n    }\\n\\n    // Tests\\n    public static void main(String[] args) {\\n        UnionFind uf = new UnionFind(5);\\n        System.out.println(\\\"init /w 5 (should print 'p [0, 1, 2, 3, 4] r [0, 0, 0, 0, 0]'):\\\");\\n        System.out.println(uf);\\n\\n        uf.union(1, 2);\\n        System.out.println(\\\"union 1 2 (should print 'p [0, 1, 1, 3, 4] r [0, 1, 0, 0, 0]'):\\\");\\n        System.out.println(uf);\\n\\n        uf.union(3, 4);\\n        System.out.println(\\\"union 3 4 (should print 'p [0, 1, 1, 3, 3] r [0, 1, 0, 1, 0]'):\\\");\\n        System.out.println(uf);\\n\\n        uf.find(4);\\n        System.out.println(\\\"find 4 (should print 'p [0, 1, 1, 3, 3] r [0, 1, 0, 1, 0]'):\\\");\\n        System.out.println(uf);\\n\\n        System.out.println(\\\"count (should print '3'):\\\");\\n        System.out.println(uf.count());\\n    }\\n}\\n\"",
    "upper bound": "\"package com.thealgorithms.searches;\\n\\nimport static java.lang.String.format;\\n\\nimport java.util.Random;\\nimport java.util.concurrent.ThreadLocalRandom;\\nimport java.util.stream.IntStream;\\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\\n\\n/**\\n * The UpperBound method is used to return an index pointing to the first\\n * element in the range [first, last) which has a value greater than val, or the\\n * last index if no such element exists i.e. the index of the next smallest\\n * number just greater than that number. If there are multiple values that are\\n * equal to val it returns the index of the first such value.\\n *\\n * <p>\\n * This is an extension of BinarySearch.\\n *\\n * <p>\\n * Worst-case performance O(log n) Best-case performance O(1) Average\\n * performance O(log n) Worst-case space complexity O(1)\\n *\\n * @author Pratik Padalia (https://github.com/15pratik)\\n * @see SearchAlgorithm\\n * @see BinarySearch\\n */\\nclass UpperBound implements SearchAlgorithm {\\n\\n    // Driver Program\\n    public static void main(String[] args) {\\n        // Just generate data\\n        Random r = ThreadLocalRandom.current();\\n\\n        int size = 100;\\n        int maxElement = 100000;\\n\\n        Integer[] integers\\n                = IntStream.generate(() -> r.nextInt(maxElement))\\n                        .limit(size)\\n                        .sorted()\\n                        .boxed()\\n                        .toArray(Integer[]::new);\\n\\n        // The element for which the upper bound is to be found\\n        int val = integers[r.nextInt(size - 1)] + 1;\\n\\n        UpperBound search = new UpperBound();\\n        int atIndex = search.find(integers, val);\\n\\n        System.out.println(\\n                format(\\n                        \\\"Val: %d. Upper Bound Found %d at index %d. An array length %d\\\",\\n                        val, integers[atIndex], atIndex, size));\\n\\n        boolean toCheck = integers[atIndex] > val || integers[size - 1] < val;\\n        System.out.println(\\n                format(\\n                        \\\"Upper Bound found at an index: %d. Is greater or max element: %b\\\", atIndex, toCheck));\\n    }\\n\\n    /**\\n     * @param array is an array where the UpperBound value is to be found\\n     * @param key is an element for which the UpperBound is to be found\\n     * @param <T> is any comparable type\\n     * @return index of the UpperBound element\\n     */\\n    @Override\\n    public <T extends Comparable<T>> int find(T[] array, T key) {\\n        return search(array, key, 0, array.length - 1);\\n    }\\n\\n    /**\\n     * This method implements the Generic Binary Search\\n     *\\n     * @param array The array to make the binary search\\n     * @param key The number you are looking for\\n     * @param left The lower bound\\n     * @param right The upper bound\\n     * @return the location of the key\\n     */\\n    private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) {\\n        if (right <= left) {\\n            return left;\\n        }\\n\\n        // find median\\n        int median = (left + right) >>> 1;\\n        int comp = key.compareTo(array[median]);\\n\\n        if (comp < 0) {\\n            // key is smaller, median position can be a possible solution\\n            return search(array, key, left, median);\\n        } else {\\n            // key we are looking is greater, so we must look on the right of median position\\n            return search(array, key, median + 1, right);\\n        }\\n    }\\n}\\n\"",
    "bitonic sort": "\"package com.thealgorithms.sorts;\\n\\n/* Java program for Bitonic Sort. Note that this program\\nworks only when size of input is a power of 2. */\\npublic class BitonicSort {\\n\\n    /* The parameter dir indicates the sorting direction,\\n  ASCENDING or DESCENDING; if (a[i] > a[j]) agrees\\n  with the direction, then a[i] and a[j] are\\n  interchanged. */\\n    void compAndSwap(int a[], int i, int j, int dir) {\\n        if ((a[i] > a[j] && dir == 1) || (a[i] < a[j] && dir == 0)) {\\n            // Swapping elements\\n            int temp = a[i];\\n            a[i] = a[j];\\n            a[j] = temp;\\n        }\\n    }\\n\\n    /* It recursively sorts a bitonic sequence in ascending\\n  order, if dir = 1, and in descending order otherwise\\n  (means dir=0). The sequence to be sorted starts at\\n  index position low, the parameter cnt is the number\\n  of elements to be sorted.*/\\n    void bitonicMerge(int a[], int low, int cnt, int dir) {\\n        if (cnt > 1) {\\n            int k = cnt / 2;\\n            for (int i = low; i < low + k; i++) {\\n                compAndSwap(a, i, i + k, dir);\\n            }\\n            bitonicMerge(a, low, k, dir);\\n            bitonicMerge(a, low + k, k, dir);\\n        }\\n    }\\n\\n    /* This funcion first produces a bitonic sequence by\\n  recursively sorting its two halves in opposite sorting\\n  orders, and then calls bitonicMerge to make them in\\n  the same order */\\n    void bitonicSort(int a[], int low, int cnt, int dir) {\\n        if (cnt > 1) {\\n            int k = cnt / 2;\\n\\n            // sort in ascending order since dir here is 1\\n            bitonicSort(a, low, k, 1);\\n\\n            // sort in descending order since dir here is 0\\n            bitonicSort(a, low + k, k, 0);\\n\\n            // Will merge whole sequence in ascending order\\n            // since dir=1.\\n            bitonicMerge(a, low, cnt, dir);\\n        }\\n    }\\n\\n    /*Caller of bitonicSort for sorting the entire array\\n  of length N in ASCENDING order */\\n    void sort(int a[], int N, int up) {\\n        bitonicSort(a, 0, N, up);\\n    }\\n\\n    /* A utility function to print array of size n */\\n    static void printArray(int arr[]) {\\n        int n = arr.length;\\n        for (int i = 0; i < n; ++i) {\\n            System.out.print(arr[i] + \\\" \\\");\\n        }\\n        System.out.println();\\n    }\\n\\n    public static void main(String args[]) {\\n        int a[] = {3, 7, 4, 8, 6, 2, 1, 5};\\n        int up = 1;\\n        BitonicSort ob = new BitonicSort();\\n        ob.sort(a, a.length, up);\\n        System.out.println(\\\"\\\\nSorted array\\\");\\n        printArray(a);\\n    }\\n}\\n\"",
    "bogo sort": "\"package com.thealgorithms.sorts;\\n\\nimport java.util.Random;\\n\\n/**\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @see SortAlgorithm\\n */\\npublic class BogoSort implements SortAlgorithm {\\n\\n    private static final Random random = new Random();\\n\\n    private static <T extends Comparable<T>> boolean isSorted(T[] array) {\\n        for (int i = 0; i < array.length - 1; i++) {\\n            if (SortUtils.less(array[i + 1], array[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    // Randomly shuffles the array\\n    private static <T> void nextPermutation(T[] array) {\\n        int length = array.length;\\n\\n        for (int i = 0; i < array.length; i++) {\\n            int randomIndex = i + random.nextInt(length - i);\\n            SortUtils.swap(array, randomIndex, i);\\n        }\\n    }\\n\\n    public <T extends Comparable<T>> T[] sort(T[] array) {\\n        while (!isSorted(array)) {\\n            nextPermutation(array);\\n        }\\n        return array;\\n    }\\n\\n    // Driver Program\\n    public static void main(String[] args) {\\n        // Integer Input\\n        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\\n\\n        BogoSort bogoSort = new BogoSort();\\n\\n        // print a sorted array\\n        SortUtils.print(bogoSort.sort(integers));\\n\\n        // String Input\\n        String[] strings = {\\\"c\\\", \\\"a\\\", \\\"e\\\", \\\"b\\\", \\\"d\\\"};\\n\\n        SortUtils.print(bogoSort.sort(strings));\\n    }\\n}\\n\"",
    "bubble sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.*;\\n\\n/**\\n * @author Varun Upadhyay (https://github.com/varunu28)\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @see SortAlgorithm\\n */\\nclass BubbleSort implements SortAlgorithm {\\n\\n    /**\\n     * Implements generic bubble sort algorithm.\\n     *\\n     * @param array the array to be sorted.\\n     * @param <T> the type of elements in the array.\\n     * @return the sorted array.\\n     */\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] array) {\\n        for (int i = 1, size = array.length; i < size; ++i) {\\n            boolean swapped = false;\\n            for (int j = 0; j < size - i; ++j) {\\n                if (greater(array[j], array[j + 1])) {\\n                    swap(array, j, j + 1);\\n                    swapped = true;\\n                }\\n            }\\n            if (!swapped) {\\n                break;\\n            }\\n        }\\n        return array;\\n    }\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n\\n        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\\n        BubbleSort bubbleSort = new BubbleSort();\\n        bubbleSort.sort(integers);\\n\\n        for (int i = 0; i < integers.length - 1; ++i) {\\n            assert integers[i] <= integers[i + 1];\\n        }\\n        print(integers);\\n        /* output: [1, 4, 6, 9, 12, 23, 54, 78, 231] */\\n\\n        String[] strings = {\\\"c\\\", \\\"a\\\", \\\"e\\\", \\\"b\\\", \\\"d\\\"};\\n        bubbleSort.sort(strings);\\n        for (int i = 0; i < strings.length - 1; i++) {\\n            assert strings[i].compareTo(strings[i + 1]) <= 0;\\n        }\\n        print(bubbleSort.sort(strings));\\n        /* output: [a, b, c, d, e] */\\n    }\\n}\\n\"",
    "bubble sort recursion": "\"package com.thealgorithms.sorts;\\n\\nimport java.util.Random;\\n\\n/**\\n * BubbleSort algorithm implements using recursion\\n */\\npublic class BubbleSortRecursion implements SortAlgorithm {\\n\\n    public static void main(String[] args) {\\n        Integer[] array = new Integer[10];\\n\\n        Random random = new Random();\\n        /* generate 10 random numbers from -50 to 49 */\\n        for (int i = 0; i < array.length; ++i) {\\n            array[i] = random.nextInt(100) - 50;\\n        }\\n\\n        BubbleSortRecursion bubbleSortRecursion = new BubbleSortRecursion();\\n        bubbleSortRecursion.sort(array);\\n\\n        /* check array is sorted or not */\\n        for (int i = 0; i < array.length - 1; ++i) {\\n            assert (array[i].compareTo(array[i + 1]) <= 0);\\n        }\\n    }\\n\\n    /**\\n     * @param unsorted - an array should be sorted\\n     * @return sorted array\\n     */\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\\n        bubbleSort(unsorted, unsorted.length);\\n        return unsorted;\\n    }\\n\\n    /**\\n     * BubbleSort algorithm implements using recursion\\n     *\\n     * @param unsorted array contains elements\\n     * @param len length of given array\\n     */\\n    private static <T extends Comparable<T>> void bubbleSort(T[] unsorted, int len) {\\n        boolean swapped = false;\\n        /* flag to check if array is sorted or not */\\n        for (int i = 0; i < len - 1; ++i) {\\n            if (SortUtils.greater(unsorted[i], unsorted[i + 1])) {\\n                SortUtils.swap(unsorted, i, i + 1);\\n                swapped = true;\\n            }\\n        }\\n        if (swapped) {\\n            bubbleSort(unsorted, len - 1);\\n        }\\n    }\\n}\\n\"",
    "bucket sort": "\"package com.thealgorithms.sorts;\\n\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.List;\\nimport java.util.Random;\\n\\n/**\\n * Wikipedia: https://en.wikipedia.org/wiki/Bucket_sort\\n */\\npublic class BucketSort {\\n\\n    public static void main(String[] args) {\\n        int[] arr = new int[10];\\n\\n        /* generate 10 random numbers from -50 to 49 */\\n        Random random = new Random();\\n        for (int i = 0; i < arr.length; ++i) {\\n            arr[i] = random.nextInt(100) - 50;\\n        }\\n\\n        bucketSort(arr);\\n\\n        /* check array is sorted or not */\\n        for (int i = 0, limit = arr.length - 1; i < limit; ++i) {\\n            assert arr[i] <= arr[i + 1];\\n        }\\n    }\\n\\n    /**\\n     * BucketSort algorithms implements\\n     *\\n     * @param arr the array contains elements\\n     */\\n    private static void bucketSort(int[] arr) {\\n        /* get max value of arr */\\n        int max = max(arr);\\n\\n        /* get min value of arr */\\n        int min = min(arr);\\n\\n        /* number of buckets */\\n        int numberOfBuckets = max - min + 1;\\n\\n        List<List<Integer>> buckets = new ArrayList<>(numberOfBuckets);\\n\\n        /* init buckets */\\n        for (int i = 0; i < numberOfBuckets; ++i) {\\n            buckets.add(new ArrayList<>());\\n        }\\n\\n        /* store elements to buckets */\\n        for (int value : arr) {\\n            int hash = hash(value, min, numberOfBuckets);\\n            buckets.get(hash).add(value);\\n        }\\n\\n        /* sort individual bucket */\\n        for (List<Integer> bucket : buckets) {\\n            Collections.sort(bucket);\\n        }\\n\\n        /* concatenate buckets to origin array */\\n        int index = 0;\\n        for (List<Integer> bucket : buckets) {\\n            for (int value : bucket) {\\n                arr[index++] = value;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Get index of bucket which of our elements gets placed into it.\\n     *\\n     * @param elem the element of array to be sorted\\n     * @param min min value of array\\n     * @param numberOfBucket the number of bucket\\n     * @return index of bucket\\n     */\\n    private static int hash(int elem, int min, int numberOfBucket) {\\n        return (elem - min) / numberOfBucket;\\n    }\\n\\n    /**\\n     * Calculate max value of array\\n     *\\n     * @param arr the array contains elements\\n     * @return max value of given array\\n     */\\n    public static int max(int[] arr) {\\n        int max = arr[0];\\n        for (int value : arr) {\\n            if (value > max) {\\n                max = value;\\n            }\\n        }\\n        return max;\\n    }\\n\\n    /**\\n     * Calculate min value of array\\n     *\\n     * @param arr the array contains elements\\n     * @return min value of given array\\n     */\\n    public static int min(int[] arr) {\\n        int min = arr[0];\\n        for (int value : arr) {\\n            if (value < min) {\\n                min = value;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n\"",
    "circle sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.*;\\n\\npublic class CircleSort implements SortAlgorithm {\\n\\n    /* This method implements the circle sort\\n    * @param array The array to be sorted \\n     */\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] array) {\\n        int n = array.length;\\n        while (doSort(array, 0, n - 1));\\n        return array;\\n    }\\n\\n    /* This method implements the cyclic sort recursive version\\n    * @param array The array to be sorted\\n    * @param the left boundary of the part currently being sorted\\n    * @param the right boundary of the part currently being sorted\\n     */\\n    private <T extends Comparable<T>> Boolean doSort(T[] array, int left, int right) {\\n        Boolean swapped = false;\\n\\n        if (left == right) {\\n            return false;\\n        }\\n\\n        int low = left;\\n        int high = right;\\n\\n        while (low < high) {\\n            if (array[low].compareTo(array[high]) > 0) {\\n                swap(array, low, high);\\n                swapped = true;\\n            }\\n            low++;\\n            high--;\\n        }\\n\\n        if (low == high && array[low].compareTo(array[high + 1]) > 0) {\\n            swap(array, low, high + 1);\\n            swapped = true;\\n        }\\n\\n        int mid = left + (right - left) / 2;\\n        Boolean leftHalf = doSort(array, left, mid);\\n        Boolean rightHalf = doSort(array, mid + 1, right);\\n\\n        return swapped || leftHalf || rightHalf;\\n    }\\n\\n    /* Driver code*/\\n    public static void main(String[] args) {\\n        CircleSort CSort = new CircleSort();\\n\\n        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};\\n        CSort.sort(arr);\\n        for (int i = 0; i < arr.length - 1; ++i) {\\n            assert arr[i] <= arr[i + 1];\\n        }\\n\\n        String[] stringArray = {\\\"c\\\", \\\"a\\\", \\\"e\\\", \\\"b\\\", \\\"d\\\"};\\n        CSort.sort(stringArray);\\n        for (int i = 0; i < stringArray.length - 1; ++i) {\\n            assert arr[i].compareTo(arr[i + 1]) <= 0;\\n        }\\n    }\\n}\\n\"",
    "cocktail shaker sort": "\"package com.thealgorithms.sorts;\\n\\n/**\\n * @author Mateus Bizzo (https://github.com/MattBizzo)\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n */\\nclass CocktailShakerSort implements SortAlgorithm {\\n\\n    /**\\n     * This method implements the Generic Cocktail Shaker Sort\\n     *\\n     * @param array The array to be sorted Sorts the array in increasing order\\n     */\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] array) {\\n\\n        int length = array.length;\\n        int left = 0;\\n        int right = length - 1;\\n        int swappedLeft, swappedRight;\\n        while (left < right) {\\n            // front\\n            swappedRight = 0;\\n            for (int i = left; i < right; i++) {\\n                if (SortUtils.less(array[i + 1], array[i])) {\\n                    SortUtils.swap(array, i, i + 1);\\n                    swappedRight = i;\\n                }\\n            }\\n            // back\\n            right = swappedRight;\\n            swappedLeft = length - 1;\\n            for (int j = right; j > left; j--) {\\n                if (SortUtils.less(array[j], array[j - 1])) {\\n                    SortUtils.swap(array, j - 1, j);\\n                    swappedLeft = j;\\n                }\\n            }\\n            left = swappedLeft;\\n        }\\n        return array;\\n    }\\n\\n    // Driver Program\\n    public static void main(String[] args) {\\n        // Integer Input\\n        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\\n        CocktailShakerSort shakerSort = new CocktailShakerSort();\\n\\n        // Output => 1 4 6 9 12 23 54 78 231\\n        SortUtils.print(shakerSort.sort(integers));\\n\\n        // String Input\\n        String[] strings = {\\\"c\\\", \\\"a\\\", \\\"e\\\", \\\"b\\\", \\\"d\\\"};\\n        SortUtils.print(shakerSort.sort(strings));\\n    }\\n}\\n\"",
    "comb sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.*;\\n\\n/**\\n * Comb Sort algorithm implementation\\n *\\n * <p>\\n * Best-case performance O(n * log(n)) Worst-case performance O(n ^ 2)\\n * Worst-case space complexity O(1)\\n *\\n * <p>\\n * Comb sort improves on bubble sort.\\n *\\n * @author Sandeep Roy (https://github.com/sandeeproy99)\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @see BubbleSort\\n * @see SortAlgorithm\\n */\\nclass CombSort implements SortAlgorithm {\\n\\n    // To find gap between elements\\n    private int nextGap(int gap) {\\n        // Shrink gap by Shrink factor\\n        gap = (gap * 10) / 13;\\n        return (gap < 1) ? 1 : gap;\\n    }\\n\\n    /**\\n     * Function to sort arr[] using Comb\\n     *\\n     * @param arr - an array should be sorted\\n     * @return sorted array\\n     */\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] arr) {\\n        int size = arr.length;\\n\\n        // initialize gap\\n        int gap = size;\\n\\n        // Initialize swapped as true to make sure that loop runs\\n        boolean swapped = true;\\n\\n        // Keep running while gap is more than 1 and last iteration caused a swap\\n        while (gap != 1 || swapped) {\\n            // Find next gap\\n            gap = nextGap(gap);\\n\\n            // Initialize swapped as false so that we can check if swap happened or not\\n            swapped = false;\\n\\n            // Compare all elements with current gap\\n            for (int i = 0; i < size - gap; i++) {\\n                if (less(arr[i + gap], arr[i])) {\\n                    // Swap arr[i] and arr[i+gap]\\n                    swapped = swap(arr, i, i + gap);\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    // Driver method\\n    public static void main(String[] args) {\\n        CombSort ob = new CombSort();\\n        Integer[] arr = {8, 4, 1, 56, 3, -44, -1, 0, 36, 34, 8, 12, -66, -78, 23, -6, 28, 0};\\n        ob.sort(arr);\\n\\n        System.out.println(\\\"sorted array\\\");\\n        print(arr);\\n    }\\n}\\n\"",
    "counting sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.print;\\nimport static java.util.stream.Collectors.toList;\\nimport static java.util.stream.Collectors.toMap;\\n\\nimport java.util.*;\\nimport java.util.stream.IntStream;\\nimport java.util.stream.Stream;\\n\\n/**\\n * @author Youssef Ali (https://github.com/youssefAli11997)\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n */\\nclass CountingSort implements SortAlgorithm {\\n\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\\n        return sort(Arrays.asList(unsorted)).toArray(unsorted);\\n    }\\n\\n    /**\\n     * This method implements the Generic Counting Sort\\n     *\\n     * @param list The list to be sorted\\n     * <p>\\n     * Sorts the list in increasing order The method uses list elements as keys\\n     * in the frequency map\\n     */\\n    @Override\\n    public <T extends Comparable<T>> List<T> sort(List<T> list) {\\n\\n        Map<T, Integer> frequency = new TreeMap<>();\\n        // The final output array\\n        List<T> sortedArray = new ArrayList<>(list.size());\\n\\n        // Counting the frequency of @param array elements\\n        list.forEach(v -> frequency.put(v, frequency.getOrDefault(v, 0) + 1));\\n\\n        // Filling the sortedArray\\n        for (Map.Entry<T, Integer> element : frequency.entrySet()) {\\n            for (int j = 0; j < element.getValue(); j++) {\\n                sortedArray.add(element.getKey());\\n            }\\n        }\\n\\n        return sortedArray;\\n    }\\n\\n    /**\\n     * Stream Counting Sort The same as method {@link CountingSort#sort(List)} }\\n     * but this method uses stream API\\n     *\\n     * @param list The list to be sorted\\n     */\\n    private static <T extends Comparable<T>> List<T> streamSort(List<T> list) {\\n        return list.stream()\\n                .collect(toMap(k -> k, v -> 1, (v1, v2) -> v1 + v2, TreeMap::new))\\n                .entrySet()\\n                .stream()\\n                .flatMap(entry -> IntStream.rangeClosed(1, entry.getValue()).mapToObj(t -> entry.getKey()))\\n                .collect(toList());\\n    }\\n\\n    // Driver Program\\n    public static void main(String[] args) {\\n        // Integer Input\\n        List<Integer> unsortedInts\\n                = Stream.of(4, 23, 6, 78, 1, 54, 23, 1, 9, 231, 9, 12).collect(toList());\\n        CountingSort countingSort = new CountingSort();\\n\\n        System.out.println(\\\"Before Sorting:\\\");\\n        print(unsortedInts);\\n\\n        // Output => 1 1 4 6 9 9 12 23 23 54 78 231\\n        System.out.println(\\\"After Sorting:\\\");\\n        print(countingSort.sort(unsortedInts));\\n        System.out.println(\\\"After Sorting By Streams:\\\");\\n        print(streamSort(unsortedInts));\\n\\n        System.out.println(\\\"\\\\n------------------------------\\\\n\\\");\\n\\n        // String Input\\n        List<String> unsortedStrings\\n                = Stream.of(\\\"c\\\", \\\"a\\\", \\\"e\\\", \\\"b\\\", \\\"d\\\", \\\"a\\\", \\\"f\\\", \\\"g\\\", \\\"c\\\").collect(toList());\\n\\n        System.out.println(\\\"Before Sorting:\\\");\\n        print(unsortedStrings);\\n\\n        // Output => a a b c c d e f g\\n        System.out.println(\\\"After Sorting:\\\");\\n        print(countingSort.sort(unsortedStrings));\\n\\n        System.out.println(\\\"After Sorting By Streams:\\\");\\n        print(streamSort(unsortedStrings));\\n    }\\n}\\n\"",
    "cycle sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.less;\\nimport static com.thealgorithms.sorts.SortUtils.print;\\n\\n/**\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n */\\nclass CycleSort implements SortAlgorithm {\\n\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] arr) {\\n        int n = arr.length;\\n\\n        // traverse array elements\\n        for (int j = 0; j <= n - 2; j++) {\\n            // initialize item as starting point\\n            T item = arr[j];\\n\\n            // Find position where we put the item.\\n            int pos = j;\\n            for (int i = j + 1; i < n; i++) {\\n                if (less(arr[i], item)) {\\n                    pos++;\\n                }\\n            }\\n\\n            // If item is already in correct position\\n            if (pos == j) {\\n                continue;\\n            }\\n\\n            // ignore all duplicate elements\\n            while (item.compareTo(arr[pos]) == 0) {\\n                pos += 1;\\n            }\\n\\n            // put the item to it's right position\\n            if (pos != j) {\\n                item = replace(arr, pos, item);\\n            }\\n\\n            // Rotate rest of the cycle\\n            while (pos != j) {\\n                pos = j;\\n\\n                // Find position where we put the element\\n                for (int i = j + 1; i < n; i++) {\\n                    if (less(arr[i], item)) {\\n                        pos += 1;\\n                    }\\n                }\\n\\n                // ignore all duplicate elements\\n                while (item.compareTo(arr[pos]) == 0) {\\n                    pos += 1;\\n                }\\n\\n                // put the item to it's right position\\n                if (item != arr[pos]) {\\n                    item = replace(arr, pos, item);\\n                }\\n            }\\n        }\\n\\n        return arr;\\n    }\\n\\n    private <T extends Comparable<T>> T replace(T[] arr, int pos, T item) {\\n        T temp = item;\\n        item = arr[pos];\\n        arr[pos] = temp;\\n        return item;\\n    }\\n\\n    public static void main(String[] args) {\\n        Integer arr[] = {4, 23, 6, 78, 1, 26, 11, 23, 0, -6, 3, 54, 231, 9, 12};\\n        CycleSort cycleSort = new CycleSort();\\n        cycleSort.sort(arr);\\n\\n        System.out.println(\\\"After sort : \\\");\\n        print(arr);\\n    }\\n}\\n\"",
    "d n f sort": "\"package com.thealgorithms.sorts;\\n\\npublic class DNFSort {\\n\\n    // Sort the input array, the array is assumed to\\n    // have values in {0, 1, 2}\\n    static void sort012(int a[], int arr_size) {\\n        int low = 0;\\n        int high = arr_size - 1;\\n        int mid = 0, temp = 0;\\n        while (mid <= high) {\\n            switch (a[mid]) {\\n                case 0: {\\n                    temp = a[low];\\n                    a[low] = a[mid];\\n                    a[mid] = temp;\\n                    low++;\\n                    mid++;\\n                    break;\\n                }\\n                case 1:\\n                    mid++;\\n                    break;\\n                case 2: {\\n                    temp = a[mid];\\n                    a[mid] = a[high];\\n                    a[high] = temp;\\n                    high--;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    /* Utility function to print array arr[] */\\n    static void printArray(int arr[], int arr_size) {\\n        for (int i = 0; i < arr_size; i++) {\\n            System.out.print(arr[i] + \\\" \\\");\\n        }\\n        System.out.println(\\\"\\\");\\n    }\\n\\n    /*Driver function to check for above functions*/\\n    public static void main(String[] args) {\\n        int arr[] = {0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1};\\n        int arr_size = arr.length;\\n        sort012(arr, arr_size);\\n        System.out.println(\\\"Array after seggregation \\\");\\n        printArray(arr, arr_size);\\n    }\\n}\\n\"",
    "gnome sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.*;\\n\\n/**\\n * Implementation of gnome sort\\n *\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @since 2018-04-10\\n */\\npublic class GnomeSort implements SortAlgorithm {\\n\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] arr) {\\n        int i = 1;\\n        int j = 2;\\n        while (i < arr.length) {\\n            if (less(arr[i - 1], arr[i])) {\\n                i = j++;\\n            } else {\\n                swap(arr, i - 1, i);\\n                if (--i == 0) {\\n                    i = j++;\\n                }\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    public static void main(String[] args) {\\n        Integer[] integers = {4, 23, 6, 78, 1, 26, 11, 23, 0, -6, 3, 54, 231, 9, 12};\\n        String[] strings = {\\\"c\\\", \\\"a\\\", \\\"e\\\", \\\"b\\\", \\\"d\\\", \\\"dd\\\", \\\"da\\\", \\\"zz\\\", \\\"AA\\\", \\\"aa\\\", \\\"aB\\\", \\\"Hb\\\", \\\"Z\\\"};\\n        GnomeSort gnomeSort = new GnomeSort();\\n\\n        gnomeSort.sort(integers);\\n        gnomeSort.sort(strings);\\n\\n        System.out.println(\\\"After sort : \\\");\\n        print(integers);\\n        print(strings);\\n    }\\n}\\n\"",
    "heap sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.*;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\n/**\\n * Heap Sort Algorithm Implements MinHeap\\n *\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n */\\npublic class HeapSort implements SortAlgorithm {\\n\\n    private static class Heap<T extends Comparable<T>> {\\n\\n        /**\\n         * Array to store heap\\n         */\\n        private T[] heap;\\n\\n        /**\\n         * Constructor\\n         *\\n         * @param heap array of unordered integers\\n         */\\n        public Heap(T[] heap) {\\n            this.heap = heap;\\n        }\\n\\n        /**\\n         * Heapifies subtree from top as root to last as last child\\n         *\\n         * @param rootIndex index of root\\n         * @param lastChild index of last child\\n         */\\n        private void heapSubtree(int rootIndex, int lastChild) {\\n            int leftIndex = rootIndex * 2 + 1;\\n            int rightIndex = rootIndex * 2 + 2;\\n            T root = heap[rootIndex];\\n            if (rightIndex <= lastChild) { // if has right and left children\\n                T left = heap[leftIndex];\\n                T right = heap[rightIndex];\\n                if (less(left, right) && less(left, root)) {\\n                    swap(heap, leftIndex, rootIndex);\\n                    heapSubtree(leftIndex, lastChild);\\n                } else if (less(right, root)) {\\n                    swap(heap, rightIndex, rootIndex);\\n                    heapSubtree(rightIndex, lastChild);\\n                }\\n            } else if (leftIndex <= lastChild) { // if no right child, but has left child\\n                T left = heap[leftIndex];\\n                if (less(left, root)) {\\n                    swap(heap, leftIndex, rootIndex);\\n                    heapSubtree(leftIndex, lastChild);\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Makes heap with root as root\\n         *\\n         * @param root index of root of heap\\n         */\\n        private void makeMinHeap(int root) {\\n            int leftIndex = root * 2 + 1;\\n            int rightIndex = root * 2 + 2;\\n            boolean hasLeftChild = leftIndex < heap.length;\\n            boolean hasRightChild = rightIndex < heap.length;\\n            if (hasRightChild) { // if has left and right\\n                makeMinHeap(leftIndex);\\n                makeMinHeap(rightIndex);\\n                heapSubtree(root, heap.length - 1);\\n            } else if (hasLeftChild) {\\n                heapSubtree(root, heap.length - 1);\\n            }\\n        }\\n\\n        /**\\n         * Gets the root of heap\\n         *\\n         * @return root of heap\\n         */\\n        private T getRoot(int size) {\\n            swap(heap, 0, size);\\n            heapSubtree(0, size - 1);\\n            return heap[size]; // return old root\\n        }\\n    }\\n\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\\n        return sort(Arrays.asList(unsorted)).toArray(unsorted);\\n    }\\n\\n    @Override\\n    public <T extends Comparable<T>> List<T> sort(List<T> unsorted) {\\n        int size = unsorted.size();\\n\\n        @SuppressWarnings(\\\"unchecked\\\")\\n        Heap<T> heap = new Heap<>(unsorted.toArray((T[]) new Comparable[unsorted.size()]));\\n\\n        heap.makeMinHeap(0); // make min heap using index 0 as root.\\n        List<T> sorted = new ArrayList<>(size);\\n        while (size > 0) {\\n            T min = heap.getRoot(--size);\\n            sorted.add(min);\\n        }\\n\\n        return sorted;\\n    }\\n\\n    /**\\n     * Main method\\n     *\\n     * @param args the command line arguments\\n     */\\n    public static void main(String[] args) {\\n        Integer[] heap = {4, 23, 6, 78, 1, 54, 231, 9, 12};\\n        HeapSort heapSort = new HeapSort();\\n        print(heapSort.sort(heap));\\n    }\\n}\\n\"",
    "insertion sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.less;\\nimport static com.thealgorithms.sorts.SortUtils.print;\\n\\nclass InsertionSort implements SortAlgorithm {\\n\\n    /**\\n     * Generic insertion sort algorithm in increasing order.\\n     *\\n     * @param array the array to be sorted.\\n     * @param <T> the class of array.\\n     * @return sorted array.\\n     */\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] array) {\\n        for (int i = 1; i < array.length; i++) {\\n            T insertValue = array[i];\\n            int j;\\n            for (j = i - 1; j >= 0 && less(insertValue, array[j]); j--) {\\n                array[j + 1] = array[j];\\n            }\\n            if (j != i - 1) {\\n                array[j + 1] = insertValue;\\n            }\\n        }\\n        return array;\\n    }\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\\n        InsertionSort sort = new InsertionSort();\\n        sort.sort(integers);\\n        print(integers);\\n        /* [1, 4, 6, 9, 12, 23, 54, 78, 231] */\\n\\n        String[] strings = {\\\"c\\\", \\\"a\\\", \\\"e\\\", \\\"b\\\", \\\"d\\\"};\\n        sort.sort(strings);\\n        print(strings);\\n        /* [a, b, c, d, e] */\\n    }\\n}\\n\"",
    "merge sort": "\"package com.thealgorithms.sorts;\\n\\n/**\\n * Generic merge sort algorithm.\\n *\\n * @see SortAlgorithm\\n */\\nclass MergeSort implements SortAlgorithm {\\n\\n    /**\\n     * Generic merge sort algorithm implements.\\n     *\\n     * @param unsorted the array which should be sorted.\\n     * @param <T> Comparable class.\\n     * @return sorted array.\\n     */\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\\n        doSort(unsorted, 0, unsorted.length - 1);\\n        return unsorted;\\n    }\\n\\n    /**\\n     * @param arr the array to be sorted.\\n     * @param left the first index of the array.\\n     * @param right the last index of the array.\\n     */\\n    private static <T extends Comparable<T>> void doSort(T[] arr, int left, int right) {\\n        if (left < right) {\\n            int mid = (left + right) >>> 1;\\n            doSort(arr, left, mid);\\n            doSort(arr, mid + 1, right);\\n            merge(arr, left, mid, right);\\n        }\\n    }\\n\\n    /**\\n     * Merges two parts of an array.\\n     *\\n     * @param arr the array to be merged.\\n     * @param left the first index of the array.\\n     * @param mid the middle index of the array.\\n     * @param right the last index of the array merges two parts of an array in\\n     * increasing order.\\n     */\\n    private static <T extends Comparable<T>> void merge(T[] arr, int left, int mid, int right) {\\n        int length = right - left + 1;\\n        @SuppressWarnings(\\\"unchecked\\\")\\n        T[] temp = (T[]) new Comparable[length];\\n        int i = left;\\n        int j = mid + 1;\\n        int k = 0;\\n\\n        while (i <= mid && j <= right) {\\n            if (arr[i].compareTo(arr[j]) <= 0) {\\n                temp[k++] = arr[i++];\\n            } else {\\n                temp[k++] = arr[j++];\\n            }\\n        }\\n\\n        while (i <= mid) {\\n            temp[k++] = arr[i++];\\n        }\\n\\n        while (j <= right) {\\n            temp[k++] = arr[j++];\\n        }\\n\\n        System.arraycopy(temp, 0, arr, left, length);\\n    }\\n\\n    /**\\n     * Driver code\\n     */\\n    public static void main(String[] args) {\\n        MergeSort mergeSort = new MergeSort();\\n\\n        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};\\n        mergeSort.sort(arr);\\n        for (int i = 0; i < arr.length - 1; ++i) {\\n            assert arr[i] <= arr[i + 1];\\n        }\\n\\n        String[] stringArray = {\\\"c\\\", \\\"a\\\", \\\"e\\\", \\\"b\\\", \\\"d\\\"};\\n        mergeSort.sort(stringArray);\\n        for (int i = 0; i < stringArray.length - 1; ++i) {\\n            assert arr[i].compareTo(arr[i + 1]) <= 0;\\n        }\\n    }\\n}\\n\"",
    "merge sort no extra space": "\"package com.thealgorithms.sorts;\\n\\nimport java.util.Arrays;\\nimport java.util.*;\\n\\n/*This code implements the mergeSort algorithm without extra space\\nFor understanding about mergesort visit :https://www.geeksforgeeks.org/merge-sort/\\n */\\npublic class MergeSortNoExtraSpace {\\n\\n    public static void call_merge_sort(int a[], int n) {\\n        int maxele = Arrays.stream(a).max().getAsInt() + 1;\\n        merge_sort(a, 0, n - 1, maxele);\\n    }\\n\\n    public static void merge_sort(int a[], int start, int end, int maxele) { //this function divides the array into 2 halves\\n\\n        if (start < end) {\\n            int mid = (start + end) / 2;\\n            merge_sort(a, start, mid, maxele);\\n            merge_sort(a, mid + 1, end, maxele);\\n            implement_merge_sort(a, start, mid, end, maxele);\\n\\n        }\\n    }\\n\\n    public static void implement_merge_sort(int a[], int start, int mid, int end, int maxele) {  //implementation of mergesort\\n        int i = start;\\n        int j = mid + 1;\\n        int k = start;\\n        while (i <= mid && j <= end) {\\n            if (a[i] % maxele <= a[j] % maxele) {\\n                a[k] = a[k] + (a[i]\\n                        % maxele) * maxele;\\n                k++;\\n                i++;\\n            } else {\\n                a[k] = a[k] + (a[j]\\n                        % maxele) * maxele;\\n                k++;\\n                j++;\\n            }\\n        }\\n        while (i <= mid) {\\n            a[k] = a[k] + (a[i]\\n                    % maxele) * maxele;\\n            k++;\\n            i++;\\n        }\\n        while (j <= end) {\\n            a[k] = a[k] + (a[j]\\n                    % maxele) * maxele;\\n            k++;\\n            j++;\\n        }\\n        for (i = start; i <= end; i++) {\\n            a[i] = a[i] / maxele;\\n        }\\n\\n    }\\n\\n    public static void main(String args[]) {\\n        Scanner inp = new Scanner(System.in);\\n        System.out.println(\\\"Enter array size\\\");\\n        int n = inp.nextInt();\\n        int a[] = new int[n];\\n        System.out.println(\\\"Enter array elements\\\");\\n        for (int i = 0; i < n; i++) {\\n            a[i] = inp.nextInt();\\n        }\\n        call_merge_sort(a, n);\\n        for (int i = 0; i < a.length; i++) {\\n            System.out.print(a[i] + \\\" \\\");\\n        }\\n    }\\n}\\n\"",
    "merge sort recursive": "\"package com.thealgorithms.sorts;\\n\\nimport java.util.Arrays;\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class MergeSortRecursive {\\n\\n    List<Integer> arr;\\n\\n    public MergeSortRecursive(List<Integer> arr) {\\n        this.arr = arr;\\n    }\\n\\n    public void mergeSort() {\\n        List<Integer> arrSorted = merge(arr);\\n        System.out.println(arrSorted);\\n    }\\n\\n    private static List<Integer> merge(List<Integer> arr) {\\n\\n        // base condition\\n        if (arr.size() <= 1) {\\n            return arr;\\n        }\\n\\n        int arrLength = arr.size();\\n        int half = arrLength / 2;\\n        List<Integer> arrA = arr.subList(0, half);\\n        List<Integer> arrB = arr.subList(half, arr.size());\\n\\n        // recursion\\n        arrA = merge(arrA);\\n        arrB = merge(arrB);\\n\\n        return sort(arrA, arrB);\\n    }\\n\\n    private static List<Integer> sort(List<Integer> unsortedA, List<Integer> unsortedB) {\\n        if (unsortedA.size() <= 0 && unsortedB.size() <= 0) {\\n            return new ArrayList<>();\\n        }\\n        if (unsortedA.size() <= 0) {\\n            return unsortedB;\\n        }\\n        if (unsortedB.size() <= 0) {\\n            return unsortedA;\\n        }\\n        if (unsortedA.get(0) <= unsortedB.get(0)) {\\n            List<Integer> newAl = new ArrayList<Integer>() {\\n                {\\n                    add(unsortedA.get(0));\\n                }\\n            };\\n            newAl.addAll(sort(unsortedA.subList(1, unsortedA.size()), unsortedB));\\n            return newAl;\\n        } else {\\n            List<Integer> newAl = new ArrayList<Integer>() {\\n                {\\n                    add(unsortedB.get(0));\\n                }\\n            };\\n            newAl.addAll(sort(unsortedA, unsortedB.subList(1, unsortedB.size())));\\n            return newAl;\\n        }\\n    }\\n\\n}\\n\\nclass App {\\n\\n    public static void main(String[] args) {\\n        MergeSortRecursive sort = new MergeSortRecursive(new ArrayList<>(Arrays.asList(4, 3, 1, 8, 5, 10, 0, 1, 4, 11, 8, 9)));\\n        sort.mergeSort();\\n    }\\n}\\n\"",
    "odd even sort": "\"package com.thealgorithms.sorts;\\n\\nimport java.util.Random;\\n\\n// https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort\\npublic class OddEvenSort {\\n\\n    public static void main(String[] args) {\\n        int[] arr = new int[100];\\n\\n        Random random = new Random();\\n\\n        // Print out unsorted elements\\n        for (int i = 0; i < arr.length; ++i) {\\n            arr[i] = random.nextInt(100) - 50;\\n            System.out.println(arr[i]);\\n        }\\n        System.out.println(\\\"--------------\\\");\\n\\n        oddEvenSort(arr);\\n\\n        //Print Sorted elements\\n        for (int i = 0; i < arr.length - 1; ++i) {\\n            System.out.println(arr[i]);\\n            assert arr[i] <= arr[i + 1];\\n        }\\n    }\\n\\n    /**\\n     * Odd Even Sort algorithms implements\\n     *\\n     * @param arr the array contains elements\\n     */\\n    public static void oddEvenSort(int[] arr) {\\n        boolean sorted = false;\\n        while (!sorted) {\\n            sorted = true;\\n\\n            for (int i = 1; i < arr.length - 1; i += 2) {\\n                if (arr[i] > arr[i + 1]) {\\n                    swap(arr, i, i + 1);\\n                    sorted = false;\\n                }\\n            }\\n\\n            for (int i = 0; i < arr.length - 1; i += 2) {\\n                if (arr[i] > arr[i + 1]) {\\n                    swap(arr, i, i + 1);\\n                    sorted = false;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Helper function to swap two array values.\\n     *\\n     * @param arr the array contains elements\\n     * @param i the first index to be swapped\\n     * @param j the second index to be swapped\\n     */\\n    private static void swap(int[] arr, int i, int j) {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n\"",
    "pancake sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.*;\\n\\n/**\\n * Implementation of pancake sort\\n *\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @since 2018-04-10\\n */\\npublic class PancakeSort implements SortAlgorithm {\\n\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] array) {\\n        int size = array.length;\\n\\n        for (int i = 0; i < size; i++) {\\n            T max = array[0];\\n            int index = 0;\\n            for (int j = 0; j < size - i; j++) {\\n                if (less(max, array[j])) {\\n                    max = array[j];\\n                    index = j;\\n                }\\n            }\\n            flip(array, index, array.length - 1 - i);\\n        }\\n        return array;\\n    }\\n\\n    public static void main(String[] args) {\\n\\n        Integer[] arr = {\\n            10, 9, 8, 7, 6, 15, 14, 7, 4, 3, 8, 6, 3, 1, 2, -2, -5, -8, -3, -1, 13, 12, 11, 5, 4, 3, 2, 1\\n        };\\n        PancakeSort pancakeSort = new PancakeSort();\\n        System.out.println(\\\"After sorting:\\\");\\n        pancakeSort.sort(arr);\\n        print(arr);\\n    }\\n}\\n\"",
    "quick sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.*;\\n\\n/**\\n * @author Varun Upadhyay (https://github.com/varunu28)\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n * @see SortAlgorithm\\n */\\nclass QuickSort implements SortAlgorithm {\\n\\n    /**\\n     * This method implements the Generic Quick Sort\\n     *\\n     * @param array The array to be sorted Sorts the array in increasing order\\n     */\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] array) {\\n        doSort(array, 0, array.length - 1);\\n        return array;\\n    }\\n\\n    /**\\n     * The sorting process\\n     *\\n     * @param left The first index of an array\\n     * @param right The last index of an array\\n     * @param array The array to be sorted\\n     */\\n    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {\\n        if (left < right) {\\n            int pivot = randomPartition(array, left, right);\\n            doSort(array, left, pivot - 1);\\n            doSort(array, pivot, right);\\n        }\\n    }\\n\\n    /**\\n     * Ramdomize the array to avoid the basically ordered sequences\\n     *\\n     * @param array The array to be sorted\\n     * @param left The first index of an array\\n     * @param right The last index of an array\\n     * @return the partition index of the array\\n     */\\n    private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {\\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\\n        swap(array, randomIndex, right);\\n        return partition(array, left, right);\\n    }\\n\\n    /**\\n     * This method finds the partition index for an array\\n     *\\n     * @param array The array to be sorted\\n     * @param left The first index of an array\\n     * @param right The last index of an array Finds the partition index of an\\n     * array\\n     */\\n    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {\\n        int mid = (left + right) >>> 1;\\n        T pivot = array[mid];\\n\\n        while (left <= right) {\\n            while (less(array[left], pivot)) {\\n                ++left;\\n            }\\n            while (less(pivot, array[right])) {\\n                --right;\\n            }\\n            if (left <= right) {\\n                swap(array, left, right);\\n                ++left;\\n                --right;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    // Driver Program\\n    public static void main(String[] args) {\\n\\n        // For integer input\\n        Integer[] array = {3, 4, 1, 32, 0, 1, 5, 12, 2, 5, 7, 8, 9, 2, 44, 111, 5};\\n\\n        QuickSort quickSort = new QuickSort();\\n        quickSort.sort(array);\\n\\n        // Output => 0 1 1 2 2 3 4 5 5 5 7 8 9 12 32 44 111\\n        print(array);\\n\\n        String[] stringArray = {\\\"c\\\", \\\"a\\\", \\\"e\\\", \\\"b\\\", \\\"d\\\"};\\n        quickSort.sort(stringArray);\\n\\n        // Output => a\\tb\\tc\\td\\te\\n        print(stringArray);\\n    }\\n}\\n\"",
    "radix sort": "\"package com.thealgorithms.sorts;\\n\\nimport java.util.Arrays;\\n\\nclass RadixSort {\\n\\n    private static int getMax(int[] arr, int n) {\\n        int mx = arr[0];\\n        for (int i = 1; i < n; i++) {\\n            if (arr[i] > mx) {\\n                mx = arr[i];\\n            }\\n        }\\n        return mx;\\n    }\\n\\n    private static void countSort(int[] arr, int n, int exp) {\\n        int[] output = new int[n];\\n        int i;\\n        int[] count = new int[10];\\n        Arrays.fill(count, 0);\\n\\n        for (i = 0; i < n; i++) {\\n            count[(arr[i] / exp) % 10]++;\\n        }\\n\\n        for (i = 1; i < 10; i++) {\\n            count[i] += count[i - 1];\\n        }\\n\\n        for (i = n - 1; i >= 0; i--) {\\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\\n            count[(arr[i] / exp) % 10]--;\\n        }\\n\\n        for (i = 0; i < n; i++) {\\n            arr[i] = output[i];\\n        }\\n    }\\n\\n    private static void radixsort(int[] arr, int n) {\\n\\n        int m = getMax(arr, n);\\n\\n        for (int exp = 1; m / exp > 0; exp *= 10) {\\n            countSort(arr, n, exp);\\n        }\\n    }\\n\\n    static void print(int[] arr, int n) {\\n        for (int i = 0; i < n; i++) {\\n            System.out.print(arr[i] + \\\" \\\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};\\n        int n = arr.length;\\n        radixsort(arr, n);\\n        print(arr, n);\\n    }\\n}\\n// Written by James Mc Dermott(theycallmemac)\\n\"",
    "selection sort": "\"package com.thealgorithms.sorts;\\n\\npublic class SelectionSort implements SortAlgorithm {\\n\\n    /**\\n     * Generic selection sort algorithm in increasing order.\\n     *\\n     * @param arr the array to be sorted.\\n     * @param <T> the class of array.\\n     * @return sorted array.\\n     */\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] arr) {\\n        int n = arr.length;\\n        for (int i = 0; i < n - 1; i++) {\\n            int minIndex = i;\\n            for (int j = i + 1; j < n; j++) {\\n                if (arr[minIndex].compareTo(arr[j]) > 0) {\\n                    minIndex = j;\\n                }\\n            }\\n            if (minIndex != i) {\\n                T temp = arr[i];\\n                arr[i] = arr[minIndex];\\n                arr[minIndex] = temp;\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n\\n        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};\\n        SelectionSort selectionSort = new SelectionSort();\\n        Integer[] sorted = selectionSort.sort(arr);\\n        for (int i = 0; i < sorted.length - 1; ++i) {\\n            assert sorted[i] <= sorted[i + 1];\\n        }\\n\\n        String[] strings = {\\\"c\\\", \\\"a\\\", \\\"e\\\", \\\"b\\\", \\\"d\\\"};\\n        String[] sortedStrings = selectionSort.sort(strings);\\n        for (int i = 0; i < sortedStrings.length - 1; ++i) {\\n            assert strings[i].compareTo(strings[i + 1]) <= 0;\\n        }\\n    }\\n}\\n\"",
    "shell sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.*;\\n\\npublic class ShellSort implements SortAlgorithm {\\n\\n    /**\\n     * Implements generic shell sort.\\n     *\\n     * @param array the array to be sorted.\\n     * @param <T> the type of elements in the array.\\n     * @return the sorted array.\\n     */\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] array) {\\n        int length = array.length;\\n        int gap = 1;\\n\\n        /* Calculate gap for optimization purpose */\\n        while (gap < length / 3) {\\n            gap = 3 * gap + 1;\\n        }\\n\\n        for (; gap > 0; gap /= 3) {\\n            for (int i = gap; i < length; i++) {\\n                int j;\\n                T temp = array[i];\\n                for (j = i; j >= gap && less(temp, array[j - gap]); j -= gap) {\\n                    array[j] = array[j - gap];\\n                }\\n                array[j] = temp;\\n            }\\n        }\\n        return array;\\n    }\\n\\n    /* Driver Code */\\n    public static void main(String[] args) {\\n        Integer[] toSort = {4, 23, 6, 78, 1, 54, 231, 9, 12};\\n\\n        ShellSort sort = new ShellSort();\\n        sort.sort(toSort);\\n        for (int i = 0; i < toSort.length - 1; ++i) {\\n            assert toSort[i] <= toSort[i + 1];\\n        }\\n        print(toSort);\\n    }\\n}\\n\"",
    "simple sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.*;\\n\\npublic class SimpleSort implements SortAlgorithm {\\n\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] array) {\\n        final int LENGTH = array.length;\\n\\n        for (int i = 0; i < LENGTH; i++) {\\n            for (int j = i + 1; j < LENGTH; j++) {\\n                if (less(array[j], array[i])) {\\n                    T element = array[j];\\n                    array[j] = array[i];\\n                    array[i] = element;\\n                }\\n            }\\n        }\\n\\n        return array;\\n    }\\n\\n    public static void main(String[] args) {\\n        // ==== Int =======\\n        Integer[] a = {3, 7, 45, 1, 33, 5, 2, 9};\\n        System.out.print(\\\"unsorted: \\\");\\n        print(a);\\n        System.out.println();\\n\\n        new SimpleSort().sort(a);\\n        System.out.print(\\\"sorted: \\\");\\n        print(a);\\n        System.out.println();\\n\\n        // ==== String =======\\n        String[] b = {\\\"banana\\\", \\\"berry\\\", \\\"orange\\\", \\\"grape\\\", \\\"peach\\\", \\\"cherry\\\", \\\"apple\\\", \\\"pineapple\\\"};\\n        System.out.print(\\\"unsorted: \\\");\\n        print(b);\\n        System.out.println();\\n\\n        new SimpleSort().sort(b);\\n        System.out.print(\\\"sorted: \\\");\\n        print(b);\\n    }\\n}\\n\"",
    "slow sort": "\"package com.thealgorithms.sorts;\\n\\n/**\\n * @author Amir Hassan (https://github.com/ahsNT)\\n * @see SortAlgorithm\\n */\\npublic class SlowSort implements SortAlgorithm {\\n\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\\n        sort(unsortedArray, 0, unsortedArray.length - 1);\\n        return unsortedArray;\\n    }\\n\\n    private <T extends Comparable<T>> void sort(T[] array, int i, int j) {\\n        if (SortUtils.greaterOrEqual(i, j)) {\\n            return;\\n        }\\n        int m = (i + j) / 2;\\n        sort(array, i, m);\\n        sort(array, m + 1, j);\\n        if (SortUtils.less(array[j], array[m])) {\\n            T temp = array[j];\\n            array[j] = array[m];\\n            array[m] = temp;\\n        }\\n        sort(array, i, j - 1);\\n    }\\n\\n    public static void main(String[] args) {\\n        SlowSort slowSort = new SlowSort();\\n\\n        Integer[] integerArray = {8, 84, 53, 953, 64, 2, 202, 98};\\n        // Print integerArray unsorted\\n        SortUtils.print(integerArray);\\n\\n        slowSort.sort(integerArray);\\n        // Print integerArray sorted\\n        SortUtils.print(integerArray);\\n\\n        String[] stringArray = {\\\"g\\\", \\\"d\\\", \\\"a\\\", \\\"b\\\", \\\"f\\\", \\\"c\\\", \\\"e\\\"};\\n        // Print stringArray unsorted\\n        SortUtils.print(stringArray);\\n\\n        slowSort.sort(stringArray);\\n        // Print stringArray sorted\\n        SortUtils.print(stringArray);\\n    }\\n}\\n\"",
    "sort algorithm": "\"package com.thealgorithms.sorts;\\n\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\n/**\\n * The common interface of most sorting algorithms\\n *\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n */\\npublic interface SortAlgorithm {\\n\\n    /**\\n     * Main method arrays sorting algorithms\\n     *\\n     * @param unsorted - an array should be sorted\\n     * @return a sorted array\\n     */\\n    <T extends Comparable<T>> T[] sort(T[] unsorted);\\n\\n    /**\\n     * Auxiliary method for algorithms what wanted to work with lists from JCF\\n     *\\n     * @param unsorted - a list should be sorted\\n     * @return a sorted list\\n     */\\n    @SuppressWarnings(\\\"unchecked\\\")\\n    default <T extends Comparable<T>> List<T> sort(List<T> unsorted) {\\n        return Arrays.asList(sort(unsorted.toArray((T[]) new Comparable[unsorted.size()])));\\n    }\\n}\\n\"",
    "sort utils": "\"package com.thealgorithms.sorts;\\n\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\n/**\\n * The class contains util methods\\n *\\n * @author Podshivalov Nikita (https://github.com/nikitap492)\\n */\\nfinal class SortUtils {\\n\\n    /**\\n     * Helper method for swapping places in array\\n     *\\n     * @param array The array which elements we want to swap\\n     * @param idx index of the first element\\n     * @param idy index of the second element\\n     */\\n    static <T> boolean swap(T[] array, int idx, int idy) {\\n        T swap = array[idx];\\n        array[idx] = array[idy];\\n        array[idy] = swap;\\n        return true;\\n    }\\n\\n    /**\\n     * This method checks if first element is less than the other element\\n     *\\n     * @param v first element\\n     * @param w second element\\n     * @return true if the first element is less than the second element\\n     */\\n    static <T extends Comparable<T>> boolean less(T v, T w) {\\n        return v.compareTo(w) < 0;\\n    }\\n\\n    /**\\n     * This method checks if first element is greater than the other element\\n     *\\n     * @param v first element\\n     * @param w second element\\n     * @return true if the first element is greater than the second element\\n     */\\n    static <T extends Comparable<T>> boolean greater(T v, T w) {\\n        return v.compareTo(w) > 0;\\n    }\\n\\n    /**\\n     * This method checks if first element is greater than or equal the other\\n     * element\\n     *\\n     * @param v first element\\n     * @param w second element\\n     * @return true if the first element is greater than or equal the second\\n     * element\\n     */\\n    static <T extends Comparable<T>> boolean greaterOrEqual(T v, T w) {\\n        return v.compareTo(w) >= 0;\\n    }\\n\\n    /**\\n     * Prints a list\\n     *\\n     * @param toPrint - a list which should be printed\\n     */\\n    static void print(List<?> toPrint) {\\n        toPrint.stream().map(Object::toString).map(str -> str + \\\" \\\").forEach(System.out::print);\\n\\n        System.out.println();\\n    }\\n\\n    /**\\n     * Prints an array\\n     *\\n     * @param toPrint - an array which should be printed\\n     */\\n    static void print(Object[] toPrint) {\\n        System.out.println(Arrays.toString(toPrint));\\n    }\\n\\n    /**\\n     * Swaps all position from {\\n     *\\n     * @param left} to @{\\n     * @param right} for {\\n     * @param array}\\n     *\\n     * @param array is an array\\n     * @param left is a left flip border of the array\\n     * @param right is a right flip border of the array\\n     */\\n    static <T extends Comparable<T>> void flip(T[] array, int left, int right) {\\n        while (left <= right) {\\n            swap(array, left++, right--);\\n        }\\n    }\\n}\\n\"",
    "stooge sort": "\"package com.thealgorithms.sorts;\\n\\n/**\\n * @author Amir Hassan (https://github.com/ahsNT)\\n * @see SortAlgorithm\\n */\\npublic class StoogeSort implements SortAlgorithm {\\n\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\\n        sort(unsortedArray, 0, unsortedArray.length);\\n        return unsortedArray;\\n    }\\n\\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray, int start, int end) {\\n        if (SortUtils.less(unsortedArray[end - 1], unsortedArray[start])) {\\n            T temp = unsortedArray[start];\\n            unsortedArray[start] = unsortedArray[end - 1];\\n            unsortedArray[end - 1] = temp;\\n        }\\n\\n        int len = end - start;\\n        if (len > 2) {\\n            int third = len / 3;\\n            sort(unsortedArray, start, end - third);\\n            sort(unsortedArray, start + third, end);\\n            sort(unsortedArray, start, end - third);\\n        }\\n        return unsortedArray;\\n    }\\n\\n    public static void main(String[] args) {\\n        StoogeSort stoogeSort = new StoogeSort();\\n\\n        Integer[] integerArray = {8, 84, 53, 953, 64, 2, 202};\\n        // Print integerArray unsorted\\n        SortUtils.print(integerArray);\\n\\n        stoogeSort.sort(integerArray);\\n        // Print integerArray sorted\\n        SortUtils.print(integerArray);\\n\\n        String[] stringArray = {\\\"g\\\", \\\"d\\\", \\\"a\\\", \\\"b\\\", \\\"f\\\", \\\"c\\\", \\\"e\\\"};\\n        // Print stringArray unsorted\\n        SortUtils.print(stringArray);\\n\\n        stoogeSort.sort(stringArray);\\n        // Print stringArray sorted\\n        SortUtils.print(stringArray);\\n    }\\n}\\n\"",
    "swap sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.*;\\n\\n/**\\n * The idea of Swap-Sort is to count the number m of smaller values (that are in\\n * A) from each element of an array A(1...n) and then swap the element with the\\n * element in A(m+1). This ensures that the exchanged element is already in the\\n * correct, i.e. final, position. The disadvantage of this algorithm is that\\n * each element may only occur once, otherwise there is no termination.\\n */\\npublic class SwapSort implements SortAlgorithm {\\n\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] array) {\\n        int LENGTH = array.length;\\n        int index = 0;\\n\\n        while (index < LENGTH - 1) {\\n            int amountSmallerElements = this.getSmallerElementCount(array, index);\\n\\n            if (amountSmallerElements > 0 && index != amountSmallerElements) {\\n                T element = array[index];\\n                array[index] = array[amountSmallerElements];\\n                array[amountSmallerElements] = element;\\n            } else {\\n                index++;\\n            }\\n        }\\n\\n        return array;\\n    }\\n\\n    private <T extends Comparable<T>> int getSmallerElementCount(T[] array, int index) {\\n        int counter = 0;\\n        for (int i = 0; i < array.length; i++) {\\n            if (less(array[i], array[index])) {\\n                counter++;\\n            }\\n        }\\n\\n        return counter;\\n    }\\n\\n    public static void main(String[] args) {\\n        // ==== Int =======\\n        Integer[] a = {3, 7, 45, 1, 33, 5, 2, 9};\\n        System.out.print(\\\"unsorted: \\\");\\n        print(a);\\n        System.out.println();\\n\\n        new SwapSort().sort(a);\\n        System.out.print(\\\"sorted: \\\");\\n        print(a);\\n        System.out.println();\\n\\n        // ==== String =======\\n        String[] b = {\\\"banana\\\", \\\"berry\\\", \\\"orange\\\", \\\"grape\\\", \\\"peach\\\", \\\"cherry\\\", \\\"apple\\\", \\\"pineapple\\\"};\\n        System.out.print(\\\"unsorted: \\\");\\n        print(b);\\n        System.out.println();\\n\\n        new SwapSort().sort(b);\\n        System.out.print(\\\"sorted: \\\");\\n        print(b);\\n    }\\n}\\n\"",
    "tim sort": "\"package com.thealgorithms.sorts;\\n\\nimport java.util.Random;\\n\\n/**\\n * @author [Hemanth Kotagiri](https://github.com/hemanth-kotagiri)\\n * @see [Tim Sort](https://en.wikipedia.org/wiki/Tim_sort)\\n */\\nclass TimSort {\\n\\n    int array[];\\n    int array_length;\\n    int RUN = 32;\\n\\n    /**\\n     * @brief A constructor which takes in the array specified by the user.\\n     * @param array : Array given by the user.\\n     */\\n    public TimSort(int[] array) {\\n        this.array = array;\\n        this.array_length = array.length;\\n    }\\n\\n    /**\\n     * @brief A constructor which takes in an array length and randomly\\n     * initializes an array.\\n     * @param array_length length given by the user.\\n     */\\n    public TimSort(int array_length) {\\n        Random rand = new Random();\\n\\n        this.array_length = array_length;\\n        this.array = new int[this.array_length];\\n\\n        for (int i = 0; i < this.array_length; i++) {\\n            int random_number = rand.nextInt(1000);\\n            this.array[i] = random_number;\\n        }\\n    }\\n\\n    /**\\n     * @brief A method to change the size of the run.\\n     * @param run : Value specified by the user to change the run.\\n     */\\n    public void change_run(int run) {\\n        this.RUN = run;\\n    }\\n\\n    /**\\n     * @brief A default constructor when no parameters are given. Initializes\\n     * the array length to be 100. Generates a random number array of size 100.\\n     */\\n    public TimSort() {\\n        this.array_length = 100;\\n        this.array = new int[this.array_length];\\n\\n        Random rand = new Random();\\n        for (int i = 0; i < this.array_length; i++) {\\n            int random_number = rand.nextInt(1000);\\n            this.array[i] = random_number;\\n        }\\n    }\\n\\n    /**\\n     * @brief Performs Insertion Sort Algorithm on given array with bounded\\n     * indices.\\n     * @param array: The array on which the algorithm is to be performed.\\n     * @param start_idx: The starting index from which the algorithm is to be\\n     * performed.\\n     * @param end_idx: The ending index at which the algorithm needs to stop\\n     * sorting.\\n     */\\n    public void insertion_sort(int[] array, int start_idx, int end_idx) {\\n        for (int i = 0; i < array.length; i++) {\\n            int current_element = array[i];\\n            int j = i - 1;\\n            while (j >= 0 && array[j] > current_element) {\\n                array[j + 1] = array[j];\\n                j--;\\n            }\\n            array[j + 1] = current_element;\\n        }\\n    }\\n\\n    /**\\n     * @brief A method to merge two runs(chunks of array).\\n     * @param array: The origin array which is to be sorted.\\n     * @param start: Starting index of the first run(chunk).\\n     * @param mid: The ending index of the first run(chunk).\\n     * @param end: Ending index of the second run(chunk).\\n     */\\n    public void merge_runs(int array[], int start, int mid, int end) {\\n\\n        int first_array_size = mid - start + 1, second_array_size = end - mid;\\n        int array1[] = new int[first_array_size], array2[] = new int[second_array_size];\\n        int i = 0, j = 0, k = 0;\\n\\n        // Building the two sub arrays from the array to merge later\\n        for (i = 0; i < first_array_size; i++) {\\n            array1[i] = array[start + i];\\n        }\\n        for (i = 0; i < second_array_size; i++) {\\n            array2[i] = array[mid + 1 + i];\\n        }\\n\\n        i = 0;\\n        j = 0;\\n        k = start;\\n\\n        while (i < first_array_size && j < second_array_size) {\\n            if (array1[i] <= array2[j]) {\\n                array[k] = array1[i];\\n                i++;\\n            } else {\\n                array[k] = array2[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n\\n        while (i < first_array_size) {\\n            array[k] = array1[i];\\n            k++;\\n            i++;\\n        }\\n\\n        while (j < second_array_size) {\\n            array[k] = array2[j];\\n            k++;\\n            j++;\\n        }\\n    }\\n\\n    /**\\n     * @brief Tim Sort Algorithm method.\\n     */\\n    public void algorithm() {\\n        // Before Sorting\\n        System.out.println(\\\"Before sorting the array: \\\");\\n        this.showArrayElements();\\n        System.out.println();\\n\\n        // Applying insertion sort on RUNS.\\n        for (int i = 0; i < this.array_length; i += this.RUN) {\\n            this.insertion_sort(this.array, i, Math.min(i + this.RUN, (this.array_length - 1)));\\n        }\\n\\n        for (int split = this.RUN; split < this.array_length; split = 2 * split) {\\n            for (int start_idx = 0; start_idx < this.array_length; start_idx += 2 * split) {\\n                int mid = start_idx + split - 1;\\n                int end_idx = Math.min((start_idx + 2 * split - 1), (this.array_length - 1));\\n\\n                this.merge_runs(this.array, start_idx, mid, end_idx);\\n            }\\n        }\\n        // After sorting\\n        System.out.println(\\\"After sorting the array: \\\");\\n        this.showArrayElements();\\n        System.out.println();\\n    }\\n\\n    /**\\n     * @brief A method to show the elements inside the array.\\n     */\\n    public void showArrayElements() {\\n        for (int i = 0; i < this.array.length; i++) {\\n            System.out.print(this.array[i] + \\\" \\\");\\n        }\\n        System.out.println();\\n    }\\n\\n    /**\\n     * @brief A method to test the sorting algorithm\\n     */\\n    static void test() {\\n        int[] array = {4, 1, 3, 17, 12, 11, 8};\\n        TimSort sorterObj1 = new TimSort();\\n        TimSort sorterObj2 = new TimSort(50);\\n        TimSort sorterObj3 = new TimSort(array);\\n\\n        sorterObj1.algorithm();\\n        sorterObj2.algorithm();\\n        sorterObj3.algorithm();\\n\\n        // Testing the first array\\n        for (int i = 0; i < sorterObj1.array_length - 1; i++) {\\n            assert ((sorterObj1.array[i] <= sorterObj1.array[i + 1])) : \\\"Array is not sorted\\\";\\n        }\\n\\n        // Testing the second array.\\n        for (int i = 0; i < sorterObj2.array_length - 1; i++) {\\n            assert ((sorterObj2.array[i] <= sorterObj2.array[i + 1])) : \\\"Array is not sorted\\\";\\n        }\\n\\n        // Testing the third array.\\n        for (int i = 0; i < sorterObj3.array_length - 1; i++) {\\n            assert ((sorterObj3.array[i] <= sorterObj3.array[i + 1])) : \\\"Array is not sorted\\\";\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        test();\\n    }\\n}\\n\"",
    "tree sort": "\"package com.thealgorithms.sorts;\\n\\nimport static com.thealgorithms.sorts.SortUtils.print;\\nimport com.thealgorithms.datastructures.trees.BSTRecursiveGeneric;\\n\\nimport java.util.List;\\n\\n/**\\n * <h1> Implementation of the Tree Sort algorithm</h1>\\n *\\n * <p>\\n * Tree Sort: A sorting algorithm which constructs a Binary Search Tree using\\n * the unsorted data and then outputs the data by inorder traversal of the tree.\\n *\\n * Reference: https://en.wikipedia.org/wiki/Tree_sort\\n * </p>\\n *\\n * @author Madhur Panwar (https://github.com/mdrpanwar)\\n */\\npublic class TreeSort implements SortAlgorithm {\\n\\n    @Override\\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\\n        return doTreeSortArray(unsortedArray);\\n    }\\n\\n    @Override\\n    public <T extends Comparable<T>> List<T> sort(List<T> unsortedList) {\\n        return doTreeSortList(unsortedList);\\n    }\\n\\n    private <T extends Comparable<T>> T[] doTreeSortArray(T[] unsortedArray) {\\n        // create a generic BST tree\\n        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();\\n\\n        // add all elements to the tree\\n        for (T element : unsortedArray) {\\n            tree.add(element);\\n        }\\n\\n        // get the sorted list by inorder traversal of the tree\\n        List<T> sortedList = tree.inorderSort();\\n\\n        // add the elements back to the initial array\\n        int i = 0;\\n        for (T element : sortedList) {\\n            unsortedArray[i++] = element;\\n        }\\n\\n        // return the array\\n        return unsortedArray;\\n    }\\n\\n    private <T extends Comparable<T>> List<T> doTreeSortList(List<T> unsortedList) {\\n        // create a generic BST tree\\n        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();\\n\\n        // add all elements to the tree\\n        for (T element : unsortedList) {\\n            tree.add(element);\\n        }\\n\\n        // get the sorted list by inorder traversal of the tree and return it\\n        return tree.inorderSort();\\n    }\\n\\n    public static void main(String[] args) {\\n        TreeSort treeSort = new TreeSort();\\n\\n        // ==== Integer Array =======\\n        System.out.println(\\\"Testing for Integer Array....\\\");\\n        Integer[] a = {3, -7, 45, 1, 343, -5, 2, 9};\\n        System.out.print(String.format(\\\"%-10s\\\", \\\"unsorted: \\\"));\\n        print(a);\\n        a = treeSort.sort(a);\\n        System.out.print(String.format(\\\"%-10s\\\", \\\"sorted: \\\"));\\n        print(a);\\n        System.out.println();\\n\\n        // ==== Integer List =======\\n        System.out.println(\\\"Testing for Integer List....\\\");\\n        List<Integer> intList = List.of(3, -7, 45, 1, 343, -5, 2, 9);\\n        System.out.print(String.format(\\\"%-10s\\\", \\\"unsorted: \\\"));\\n        print(intList);\\n        intList = treeSort.sort(intList);\\n        System.out.print(String.format(\\\"%-10s\\\", \\\"sorted: \\\"));\\n        print(intList);\\n        System.out.println();\\n\\n        // ==== String Array =======\\n        System.out.println(\\\"Testing for String Array....\\\");\\n        String[] b = {\\\"banana\\\", \\\"berry\\\", \\\"orange\\\", \\\"grape\\\", \\\"peach\\\", \\\"cherry\\\", \\\"apple\\\", \\\"pineapple\\\"};\\n        System.out.print(String.format(\\\"%-10s\\\", \\\"unsorted: \\\"));\\n        print(b);\\n        b = treeSort.sort(b);\\n        System.out.print(String.format(\\\"%-10s\\\", \\\"sorted: \\\"));\\n        print(b);\\n        System.out.println();\\n\\n        // ==== String List =======\\n        System.out.println(\\\"Testing for String List....\\\");\\n        List<String> stringList = List.of(\\\"banana\\\", \\\"berry\\\", \\\"orange\\\", \\\"grape\\\", \\\"peach\\\", \\\"cherry\\\", \\\"apple\\\", \\\"pineapple\\\");\\n        System.out.print(String.format(\\\"%-10s\\\", \\\"unsorted: \\\"));\\n        print(stringList);\\n        stringList = treeSort.sort(stringList);\\n        System.out.print(String.format(\\\"%-10s\\\", \\\"sorted: \\\"));\\n        print(stringList);\\n\\n    }\\n\\n}\\n\"",
    "alphabetical": "\"package com.thealgorithms.strings;\\n\\n/**\\n * Alphabetical order is a system whereby character strings are placed in order\\n * based on the position of the characters in the conventional ordering of an\\n * alphabet. Wikipedia: https://en.wikipedia.org/wiki/Alphabetical_order\\n */\\nclass Alphabetical {\\n\\n    public static void main(String[] args) {\\n        assert !isAlphabetical(\\\"123abc\\\");\\n        assert isAlphabetical(\\\"aBC\\\");\\n        assert isAlphabetical(\\\"abc\\\");\\n        assert !isAlphabetical(\\\"xyzabc\\\");\\n        assert isAlphabetical(\\\"abcxyz\\\");\\n    }\\n\\n    /**\\n     * Check if a string is alphabetical order or not\\n     *\\n     * @param s a string\\n     * @return {@code true} if given string is alphabetical order, otherwise\\n     * {@code false}\\n     */\\n    public static boolean isAlphabetical(String s) {\\n        s = s.toLowerCase();\\n        for (int i = 0; i < s.length() - 1; ++i) {\\n            if (!Character.isLetter(s.charAt(i)) || !(s.charAt(i) <= s.charAt(i + 1))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"",
    "anagrams": "\"/** Author : Siddhant Swarup Mallick\\n * Github : https://github.com/siddhant2002\\n */\\n\\n/** PROBLEM DESCRIPTION :\\n * An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.[1] For example, the word anagram itself can be rearranged into nag a ram, also the word binary into brainy and the word adobe into abode. Reference from https://en.wikipedia.org/wiki/Anagram\\n */\\n\\npackage com.thealgorithms.strings;\\nimport java.util.*;\\npublic class Anagrams \\n{\\n    // 4 approaches are provided for anagram checking. approach 2 and approach 3 are similar but differ in running time.\\n    public static void main(String args[]) {\\n        String first = \\\"deal\\\";\\n        String second = \\\"lead\\\";\\n        // All the below methods takes input but doesn't return any output to the main method.\\n        Anagrams nm=new Anagrams();\\n        System.out.println(nm.approach2(first, second));  /* To activate methods for different approaches*/\\n        System.out.println(nm.approach1(first, second));  /* To activate methods for different approaches*/\\n        System.out.println(nm.approach3(first, second));  /* To activate methods for different approaches*/\\n        System.out.println(nm.approach4(first, second));  /* To activate methods for different approaches*/\\n\\n        /**\\n         * OUTPUT :\\n         * first string =\\\"deal\\\" second string =\\\"lead\\\"\\n         * Output: Anagram\\n         * Input and output is constant for all four approaches\\n         * 1st approach Time Complexity : O(n logn)\\n         * Auxiliary Space Complexity : O(1)\\n         * 2nd approach Time Complexity : O(n)\\n         * Auxiliary Space Complexity : O(1)\\n         * 3rd approach Time Complexity : O(n)\\n         * Auxiliary Space Complexity : O(1)\\n         * 4th approach Time Complexity : O(n)\\n         * Auxiliary Space Complexity : O(n)\\n         */\\n    }\\n\\n    boolean approach1(String s, String t) \\n    {\\n        if (s.length() != t.length())\\n        {\\n            return false;\\n        }\\n        else \\n        {\\n            char c[] = s.toCharArray();\\n            char d[] = t.toCharArray();\\n            Arrays.sort(c);\\n            Arrays.sort(d);    /* In this approach the strings are stored in the character arrays and both the arrays are sorted. After that both the arrays are compared for checking anangram */\\n            if (Arrays.equals(c, d)) \\n            {\\n                return true;\\n            } else \\n            {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    boolean approach2(String a, String b)\\n    {\\n        if(a.length()!=b.length())\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            int m[]=new int[26];\\n            int n[]=new int[26];\\n            for(char c: a.toCharArray())\\n            {\\n                m[c-'a']++;\\n            }\\n            // In this approach the frequency of both the strings are stored and after that the frequencies are iterated from 0 to 26(from 'a' to 'z' ). If the frequencies match then anagram message is displayed in the form of boolean format\\n            // Running time and space complexity of this algo is less as compared to others\\n            for(char c:b.toCharArray())\\n            {\\n                n[c-'a']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                if(m[i]!=n[i])\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n\\n    boolean approach3(String s, String t)\\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        // this is similar to approach number 2 but here the string is not converted to character array\\n        else\\n        {\\n            int a[]=new int[26];\\n            int b[]=new int[26];\\n            int k=s.length();\\n            for(int i=0;i<k;i++)\\n            {\\n                a[s.charAt(i)-'a']++;\\n                b[t.charAt(i)-'a']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                if(a[i]!=b[i])\\n                    return false;\\n            }\\n            return true;\\n        }\\n    }\\n\\n    boolean approach4(String s, String t)\\n    {\\n        if(s.length()!=t.length())\\n        {\\n             return false;\\n        }\\n        // This approach is done using hashmap where frequencies are stored and checked iteratively and if all the frequencies of first string match with the second string then anagram message is displayed in boolean format\\n        else\\n        {\\n            HashMap<Character,Integer> nm=new HashMap<>(); \\n            HashMap<Character,Integer> kk=new HashMap<>();\\n            for(char c: s.toCharArray())\\n            {\\n                nm.put(c, nm.getOrDefault(c,0)+1);\\n            }\\n            for(char c: t.toCharArray())\\n            {\\n            \\n                kk.put(c, kk.getOrDefault(c,0)+1);\\n            }\\n            // It checks for equal frequencies\\n            for(char c:nm.keySet())\\n            {\\n                if(!nm.get(c).equals(kk.get(c)))\\n                {\\n                    return false;\\n                }\\n            } \\n            return true;\\n        }\\n    }\\n}\"",
    "characters same": "\"package com.thealgorithms.strings;\\n\\npublic class CharactersSame {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        assert isAllCharactersSame(\\\"\\\");\\n        assert !isAllCharactersSame(\\\"aab\\\");\\n        assert isAllCharactersSame(\\\"aaa\\\");\\n        assert isAllCharactersSame(\\\"11111\\\");\\n    }\\n\\n    /**\\n     * check if all the characters of a string are same\\n     *\\n     * @param s the string to check\\n     * @return {@code true} if all characters of a string are same, otherwise\\n     * {@code false}\\n     */\\n    public static boolean isAllCharactersSame(String s) {\\n        for (int i = 1, length = s.length(); i < length; ++i) {\\n            if (s.charAt(i) != s.charAt(0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"",
    "check anagrams": "\"package com.thealgorithms.strings;\\n\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n/**\\n * Two strings are anagrams if they are made of the same letters arranged\\n * differently (ignoring the case).\\n */\\npublic class CheckAnagrams {\\n\\n    public static void main(String[] args) {\\n        assert isAnagrams(\\\"Silent\\\", \\\"Listen\\\");\\n        assert isAnagrams(\\\"This is a string\\\", \\\"Is this a string\\\");\\n        assert !isAnagrams(\\\"There\\\", \\\"Their\\\");\\n    }\\n\\n    /**\\n     * Check if two strings are anagrams or not\\n     *\\n     * @param s1 the first string\\n     * @param s2 the second string\\n     * @return {@code true} if two string are anagrams, otherwise {@code false}\\n     */\\n    public static boolean isAnagrams(String s1, String s2) {\\n        int l1 = s1.length();\\n        int l2 = s2.length();\\n        s1 = s1.toLowerCase();\\n        s2 = s2.toLowerCase();\\n        Map<Character, Integer> charAppearances = new HashMap<>();\\n\\n        for (int i = 0; i < l1; i++) {\\n            char c = s1.charAt(i);\\n            int numOfAppearances = charAppearances.getOrDefault(c, 0);\\n            charAppearances.put(c, numOfAppearances + 1);\\n        }\\n\\n        for (int i = 0; i < l2; i++) {\\n            char c = s2.charAt(i);\\n            if (!charAppearances.containsKey(c)) {\\n                return false;\\n            }\\n            charAppearances.put(c, charAppearances.get(c) - 1);\\n        }\\n\\n        for (int cnt : charAppearances.values()) {\\n            if (cnt != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"",
    "check vowels": "\"package com.thealgorithms.strings;\\n\\n/**\\n * Vowel Count is a system whereby character strings are placed in order based\\n * on the position of the characters in the conventional ordering of an\\n * alphabet. Wikipedia: https://en.wikipedia.org/wiki/Alphabetical_order\\n */\\nclass CheckVowels {\\n\\n    public static void main(String[] args) {\\n        assert !hasVowels(\\\"This is a strings\\\");\\n        assert hasVowels(\\\"Hello World\\\");\\n        assert hasVowels(\\\"Java is fun\\\");\\n        assert !hasVowels(\\\"123hi\\\");\\n        assert hasVowels(\\\"Coding vs Programming\\\");\\n    }\\n\\n    /**\\n     * Check if a string is has vowels or not\\n     *\\n     * @param input a string\\n     * @return {@code true} if given string has vowels, otherwise {@code false}\\n     */\\n    public static boolean hasVowels(String input) {\\n        if (input.matches(\\\"[AEIOUaeiou]\\\")) {\\n            countVowels(input);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * count the number of vowels\\n     *\\n     * @param input a string prints the count of vowels\\n     */\\n    public static void countVowels(String input) {\\n        input = input.toLowerCase();\\n        int count = 0;\\n        int i = 0;\\n        while (i < input.length()) {\\n            if (input.charAt(i) == 'a'\\n                    || input.charAt(i) == 'e'\\n                    || input.charAt(i) == 'i'\\n                    || input.charAt(i) == 'o'\\n                    || input.charAt(i) == 'u') {\\n                count++;\\n            }\\n            i++;\\n        }\\n        System.out.println(count);\\n    }\\n}\\n\"",
    "horspool search": "\"package com.thealgorithms.strings;\\n\\nimport java.util.HashMap;\\n\\n/**\\n * This class is not thread safe<br>\\n * <br>\\n * (From wikipedia) In computer science, the Boyer–Moore–Horspool algorithm or\\n * Horspool's algorithm is an algorithm for finding substrings in strings. It\\n * was published by Nigel Horspool in 1980.\\n * <br>\\n * <a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm>Wikipedia\\n * page</a><br>\\n * <br>\\n *\\n * <p>\\n * An explanation:<br>\\n *\\n * <p>\\n * The Horspool algorithm is a simplification of the Boyer-Moore algorithm in\\n * that it uses only one of the two heuristic methods for increasing the number\\n * of characters shifted when finding a bad match in the text. This method is\\n * usually called the \\\"bad symbol\\\" or \\\"bad character\\\" shift. The bad symbol\\n * shift method is classified as an input enhancement method in the theory of\\n * algorithms. Input enhancement is (from wikipedia) the principle that\\n * processing a given input to a problem and altering it in a specific way will\\n * increase runtime efficiency or space efficiency, or both. Both algorithms try\\n * to match the pattern and text comparing the pattern symbols to the text's\\n * from right to left.<br>\\n * <br>\\n *\\n * <p>\\n * In the bad symbol shift method, a table is created prior to the search,\\n * called the \\\"bad symbol table\\\". The bad symbol table contains the shift values\\n * for any symbol in the text and pattern. For these symbols, the value is the\\n * length of the pattern, if the symbol is not in the first (length - 1) of the\\n * pattern. Else it is the distance from its rightmost occurrence in the pattern\\n * to the last symbol of the pattern. In practice, we only calculate the values\\n * for the ones that exist in the first (length - 1) of the pattern.<br>\\n * <br>\\n *\\n * <p>\\n * For more details on the algorithm and the more advanced Boyer-Moore I\\n * recommend checking out the wikipedia page and professor Anany Levitin's book:\\n * Introduction To The Design And Analysis Of Algorithms.\\n */\\npublic class HorspoolSearch {\\n\\n    private static HashMap<Character, Integer> shiftValues; // bad symbol table\\n    private static Integer patternLength;\\n    private static int comparisons = 0; // total comparisons in the current/last search\\n\\n    /**\\n     * Case sensitive version version of the algorithm\\n     *\\n     * @param pattern the pattern to be searched for (needle)\\n     * @param text the text being searched in (haystack)\\n     * @return -1 if not found or first index of the pattern in the text\\n     */\\n    public static int findFirst(String pattern, String text) {\\n        return firstOccurrence(pattern, text, true);\\n    }\\n\\n    /**\\n     * Case insensitive version version of the algorithm\\n     *\\n     * @param pattern the pattern to be searched for (needle)\\n     * @param text the text being searched in (haystack)\\n     * @return -1 if not found or first index of the pattern in the text\\n     */\\n    public static int findFirstInsensitive(String pattern, String text) {\\n        return firstOccurrence(pattern, text, false);\\n    }\\n\\n    /**\\n     * Utility method that returns comparisons made by last run (mainly for\\n     * tests)\\n     *\\n     * @return number of character comparisons of the last search\\n     */\\n    public static Integer getLastComparisons() {\\n        return HorspoolSearch.comparisons;\\n    }\\n\\n    /**\\n     * Fairly standard implementation of the Horspool algorithm. Only the index\\n     * of the last character of the pattern on the text is saved and shifted by\\n     * the appropriate amount when a mismatch is found. The algorithm stops at\\n     * the first match or when the entire text has been exhausted.\\n     *\\n     * @param pattern String to be matched in the text\\n     * @param text text String\\n     * @return index of first occurrence of the pattern in the text\\n     */\\n    private static int firstOccurrence(String pattern, String text, boolean caseSensitive) {\\n        shiftValues = calcShiftValues(pattern); // build the bad symbol table\\n        comparisons = 0; // reset comparisons\\n\\n        int textIndex\\n                = pattern.length() - 1; // align pattern with text start and get index of the last character\\n\\n        // while pattern is not out of text bounds\\n        while (textIndex < text.length()) {\\n\\n            // try to match pattern with current part of the text starting from last character\\n            int i = pattern.length() - 1;\\n            while (i >= 0) {\\n                comparisons++;\\n                char patternChar = pattern.charAt(i);\\n                char textChar = text.charAt((textIndex + i) - (pattern.length() - 1));\\n                if (!charEquals(patternChar, textChar, caseSensitive)) { // bad character, shift pattern\\n                    textIndex += getShiftValue(text.charAt(textIndex));\\n                    break;\\n                }\\n                i--;\\n            }\\n\\n            // check for full match\\n            if (i == -1) {\\n                return textIndex - pattern.length() + 1;\\n            }\\n        }\\n\\n        // text exhausted, return failure\\n        return -1;\\n    }\\n\\n    /**\\n     * Compares the argument characters\\n     *\\n     * @param c1 first character\\n     * @param c2 second character\\n     * @param caseSensitive boolean determining case sensitivity of comparison\\n     * @return truth value of the equality comparison\\n     */\\n    private static boolean charEquals(char c1, char c2, boolean caseSensitive) {\\n        if (caseSensitive) {\\n            return c1 == c2;\\n        }\\n        return Character.toLowerCase(c1) == Character.toLowerCase(c2);\\n    }\\n\\n    /**\\n     * Builds the bad symbol table required to run the algorithm. The method\\n     * starts from the second to last character of the pattern and moves to the\\n     * left. When it meets a new character, it is by definition its rightmost\\n     * occurrence and therefore puts the distance from the current index to the\\n     * index of the last character into the table. If the character is already\\n     * in the table, then it is not a rightmost occurrence, so it continues.\\n     *\\n     * @param pattern basis for the bad symbol table\\n     * @return the bad symbol table\\n     */\\n    private static HashMap<Character, Integer> calcShiftValues(String pattern) {\\n        patternLength = pattern.length();\\n        HashMap<Character, Integer> table = new HashMap<>();\\n\\n        for (int i = pattern.length() - 2;\\n                i >= 0;\\n                i--) { // length - 2 is the index of the second to last character\\n            char c = pattern.charAt(i);\\n            int finalI = i;\\n            table.computeIfAbsent(c, k -> pattern.length() - 1 - finalI);\\n        }\\n\\n        return table;\\n    }\\n\\n    /**\\n     * Helper function that uses the bad symbol shift table to return the\\n     * appropriate shift value for a given character\\n     *\\n     * @param c character\\n     * @return shift value that corresponds to the character argument\\n     */\\n    private static Integer getShiftValue(char c) {\\n        if (shiftValues.get(c) != null) {\\n            return shiftValues.get(c);\\n        } else {\\n            return patternLength;\\n        }\\n    }\\n}\\n\"",
    "list all  possible  words  from  phone  digits": "\"package com.thealgorithms.strings;\\n\\nimport java.util.*;\\n\\npublic class List_all_Possible_Words_From_Phone_Digits {\\n\\n    static Character[][] numberToCharMap;\\n\\n    private static List<String> printWords(int[] numbers,\\n            int len,\\n            int numIndex,\\n            String s) {\\n        if (len == numIndex) {\\n            return new ArrayList<>(Collections.singleton(s));\\n        }\\n\\n        List<String> stringList = new ArrayList<>();\\n\\n        for (int i = 0;\\n                i < numberToCharMap[numbers[numIndex]].length; i++) {\\n            String sCopy\\n                    = String.copyValueOf(s.toCharArray());\\n            sCopy = sCopy.concat(\\n                    numberToCharMap[numbers[numIndex]][i].toString());\\n            stringList.addAll(printWords(numbers, len,\\n                    numIndex + 1,\\n                    sCopy));\\n        }\\n        return stringList;\\n    }\\n\\n    private static void printWords(int[] numbers) {\\n        generateNumberToCharMap();\\n        List<String> stringList\\n                = printWords(numbers, numbers.length, 0, \\\"\\\");\\n        stringList.stream().forEach(System.out::println);\\n    }\\n\\n    private static void generateNumberToCharMap() {\\n        numberToCharMap = new Character[10][5];\\n        numberToCharMap[0] = new Character[]{'\\\\0'};\\n        numberToCharMap[1] = new Character[]{'\\\\0'};\\n        numberToCharMap[2] = new Character[]{'a', 'b', 'c'};\\n        numberToCharMap[3] = new Character[]{'d', 'e', 'f'};\\n        numberToCharMap[4] = new Character[]{'g', 'h', 'i'};\\n        numberToCharMap[5] = new Character[]{'j', 'k', 'l'};\\n        numberToCharMap[6] = new Character[]{'m', 'n', 'o'};\\n        numberToCharMap[7] = new Character[]{'p', 'q', 'r', 's'};\\n        numberToCharMap[8] = new Character[]{'t', 'u', 'v'};\\n        numberToCharMap[9] = new Character[]{'w', 'x', 'y', 'z'};\\n    }\\n\\n// Driver code \\n    public static void main(String[] args) {\\n        int number[] = {2, 3, 4};\\n        printWords(number);\\n    }\\n}\\n\"",
    "lower": "\"package com.thealgorithms.strings;\\n\\npublic class Lower {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        String[] strings = {\\\"ABC\\\", \\\"ABC123\\\", \\\"abcABC\\\", \\\"abc123ABC\\\"};\\n        for (String s : strings) {\\n            assert toLowerCase(s).equals(s.toLowerCase());\\n        }\\n    }\\n\\n    /**\\n     * Converts all of the characters in this {@code String} to lower case\\n     *\\n     * @param s the string to convert\\n     * @return the {@code String}, converted to lowercase.\\n     */\\n    public static String toLowerCase(String s) {\\n        char[] values = s.toCharArray();\\n        for (int i = 0; i < values.length; ++i) {\\n            if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\\n                values[i] = Character.toLowerCase(values[i]);\\n            }\\n        }\\n        return new String(values);\\n    }\\n}\\n\"",
    "palindrome": "\"package com.thealgorithms.strings;\\n\\n/**\\n * Wikipedia: https://en.wikipedia.org/wiki/Palindrome\\n */\\nclass Palindrome {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        String[] palindromes = {null, \\\"\\\", \\\"aba\\\", \\\"123321\\\"};\\n        for (String s : palindromes) {\\n            assert isPalindrome(s) && isPalindromeRecursion(s) && isPalindrome1(s);\\n        }\\n\\n        String[] notPalindromes = {\\\"abb\\\", \\\"abc\\\", \\\"abc123\\\"};\\n        for (String s : notPalindromes) {\\n            assert !isPalindrome(s) && !isPalindromeRecursion(s) && !isPalindrome1(s);\\n        }\\n    }\\n\\n    /**\\n     * Check if a string is palindrome string or not\\n     *\\n     * @param s a string to check\\n     * @return {@code true} if given string is palindrome, otherwise\\n     * {@code false}\\n     */\\n    public static boolean isPalindrome(String s) {\\n        return (s == null || s.length() <= 1) || s.equals(new StringBuilder(s).reverse().toString());\\n    }\\n\\n    /**\\n     * Check if a string is palindrome string or not using recursion\\n     *\\n     * @param s a string to check\\n     * @return {@code true} if given string is palindrome, otherwise\\n     * {@code false}\\n     */\\n    public static boolean isPalindromeRecursion(String s) {\\n        if (s == null || s.length() <= 1) {\\n            return true;\\n        }\\n\\n        if (s.charAt(0) != s.charAt(s.length() - 1)) {\\n            return false;\\n        }\\n\\n        return isPalindrome(s.substring(1, s.length() - 1));\\n    }\\n\\n    /**\\n     * Check if a string is palindrome string or not another way\\n     *\\n     * @param s a string to check\\n     * @return {@code true} if given string is palindrome, otherwise\\n     * {@code false}\\n     */\\n    public static boolean isPalindrome1(String s) {\\n        if (s == null || s.length() <= 1) {\\n            return true;\\n        }\\n        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"",
    "pangram": "\"package com.thealgorithms.strings;\\n\\n/**\\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\\n */\\npublic class Pangram {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        assert isPangram(\\\"The quick brown fox jumps over the lazy dog\\\");\\n        assert !isPangram(\\\"The quick brown fox jumps over the azy dog\\\");\\n        /* not exists l character */\\n    }\\n\\n    /**\\n     * Check if a string is a pangram string or not\\n     *\\n     * @param s string to check\\n     * @return {@code true} if given string is pangram, otherwise {@code false}\\n     */\\n    public static boolean isPangram(String s) {\\n        boolean[] marked = new boolean[26];\\n        /* by default all letters don't exists */\\n        char[] values = s.toCharArray();\\n        for (char value : values) {\\n            if (Character.isLetter(value)) {\\n                int index = Character.isUpperCase(value) ? value - 'A' : value - 'a';\\n                marked[index] = true;\\n                /* mark current character exists */\\n            }\\n        }\\n\\n        for (boolean b : marked) {\\n            if (!b) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"",
    "permute string": "\"package com.thealgorithms.strings;\\n\\n/*\\nBacktracking algorithm used in the program:-\\n\\n>>Fix a character in the first position and swap the rest of the character with the first character.\\n  Like in ABC, in the first iteration three strings are formed: ABC, BAC, and CBA by swapping A with\\n  A, B and C respectively.\\n>>Repeat step 1 for the rest of the characters like fixing second character B and so on.\\n>>Now swap again to go back to the previous position. E.g., from ABC, we formed ABC by fixing B again,\\n  and we backtrack to the previous position and swap B with C. So, now we got ABC and ACB.\\n>>Repeat these steps for BAC and CBA, to get all the permutations.\\n */\\npublic class PermuteString {\\n\\n    //Function for swapping the characters at position I with character at position j    \\n    public static String swapString(String a, int i, int j) {\\n        char[] b = a.toCharArray();\\n        char ch;\\n        ch = b[i];\\n        b[i] = b[j];\\n        b[j] = ch;\\n        return String.valueOf(b);\\n    }\\n\\n    public static void main(String[] args) {\\n        String str = \\\"ABC\\\";\\n        int len = str.length();\\n        System.out.println(\\\"All the permutations of the string are: \\\");\\n        generatePermutation(str, 0, len);\\n    }\\n\\n    //Function for generating different permutations of the string    \\n    public static void generatePermutation(String str, int start, int end) {\\n        //Prints the permutations    \\n        if (start == end - 1) {\\n            System.out.println(str);\\n        } else {\\n            for (int i = start; i < end; i++) {\\n                //Swapping the string by fixing a character    \\n                str = swapString(str, start, i);\\n                //Recursively calling function generatePermutation() for rest of the characters     \\n                generatePermutation(str, start + 1, end);\\n                //Backtracking and swapping the characters again.    \\n                str = swapString(str, start, i);\\n            }\\n        }\\n    }\\n}\\n\"",
    "reverse string": "\"package com.thealgorithms.strings;\\n\\n/**\\n * Reverse String using different version\\n */\\npublic class ReverseString {\\n\\n    public static void main(String[] args) {\\n        assert reverse(\\\"abc123\\\").equals(\\\"321cba\\\");\\n        assert reverse2(\\\"abc123\\\").equals(\\\"321cba\\\");\\n    }\\n\\n    /**\\n     * easiest way to reverses the string str and returns it\\n     *\\n     * @param str string to be reversed\\n     * @return reversed string\\n     */\\n    public static String reverse(String str) {\\n        return new StringBuilder(str).reverse().toString();\\n    }\\n\\n    /**\\n     * second way to reverses the string str and returns it\\n     *\\n     * @param str string to be reversed\\n     * @return reversed string\\n     */\\n    public static String reverse2(String str) {\\n\\n        if (str == null || str.isEmpty()) {\\n            return str;\\n        }\\n\\n        char[] value = str.toCharArray();\\n        for (int i = 0, j = str.length() - 1; i < j; i++, j--) {\\n            char temp = value[i];\\n            value[i] = value[j];\\n            value[j] = temp;\\n        }\\n        return new String(value);\\n    }\\n}\\n\"",
    "rotation": "\"package com.thealgorithms.strings;\\n\\n/**\\n * Given a string, moving several characters in front of the string to the end\\n * of the string. For example, move the two characters'a' and 'b' in front of\\n * the string \\\"abcdef\\\" to the end of the string, so that the original string\\n * becomes the string \\\"cdefab\\\"\\n */\\npublic class Rotation {\\n\\n    public static void main(String[] args) {\\n        assert rotation(\\\"abcdef\\\", 2).equals(\\\"cdefab\\\");\\n\\n        char[] values = \\\"abcdef\\\".toCharArray();\\n        rotation(values, 2);\\n        assert new String(values).equals(\\\"cdefab\\\");\\n    }\\n\\n    /**\\n     * Move {@code n} characters in front of given string to the end of string\\n     * time complexity: O(n) space complexity: O(n)\\n     *\\n     * @param s given string\\n     * @param n the total characters to be moved\\n     * @return string after rotation\\n     */\\n    public static String rotation(String s, int n) {\\n        return s.substring(n) + s.substring(0, n);\\n    }\\n\\n    /**\\n     * Move {@code n} characters in front of given character array to the end of\\n     * array time complexity: O(n) space complexity: O(1)\\n     *\\n     * @param values given character array\\n     * @param n the total characters to be moved\\n     */\\n    public static void rotation(char[] values, int n) {\\n        reverse(values, 0, n - 1);\\n        reverse(values, n, values.length - 1);\\n        reverse(values, 0, values.length - 1);\\n    }\\n\\n    /**\\n     * Reverse character array\\n     *\\n     * @param values character array\\n     * @param from begin index of given array\\n     * @param to end index of given array\\n     */\\n    public static void reverse(char[] values, int from, int to) {\\n        while (from < to) {\\n            char temp = values[from];\\n            values[from] = values[to];\\n            values[to] = temp;\\n            from++;\\n            to--;\\n        }\\n    }\\n}\\n\"",
    "upper": "\"package com.thealgorithms.strings;\\n\\npublic class Upper {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n        String[] strings = {\\\"ABC\\\", \\\"ABC123\\\", \\\"abcABC\\\", \\\"abc123ABC\\\"};\\n        for (String s : strings) {\\n            assert toUpperCase(s).equals(s.toUpperCase());\\n        }\\n    }\\n\\n    /**\\n     * Converts all of the characters in this {@code String} to upper case\\n     *\\n     * @param s the string to convert\\n     * @return the {@code String}, converted to uppercase.\\n     */\\n    public static String toUpperCase(String s) {\\n        char[] values = s.toCharArray();\\n        for (int i = 0; i < values.length; ++i) {\\n            if (Character.isLetter(values[i]) && Character.isLowerCase(values[i])) {\\n                values[i] = Character.toUpperCase(values[i]);\\n            }\\n        }\\n        return new String(values);\\n    }\\n}\\n\"",
    "word ladder": "\"package com.thealgorithms.strings;\\n\\nimport java.util.List;\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\nimport java.util.HashSet;\\n\\n/*\\n    **Problem Statement:**\\n    A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\\n\\n    Every adjacent pair of words differs by a single letter.\\n    Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\\n    sk == endWord\\n    Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\n\\n    **Example 1:**\\n    Input: beginWord = \\\"hit\\\", endWord = \\\"cog\\\", wordList = [\\\"hot\\\",\\\"dot\\\",\\\"dog\\\",\\\"lot\\\",\\\"log\\\",\\\"cog\\\"]\\n    Output: 5 \\n    Explanation: One shortest transformation sequence is \\\"hit\\\" -> \\\"hot\\\" -> \\\"dot\\\" -> \\\"dog\\\" -> cog\\\", which is 5 words long.\\n\\n    **Example 2:**\\n    Input: beginWord = \\\"hit\\\", endWord = \\\"cog\\\", wordList = [\\\"hot\\\",\\\"dot\\\",\\\"dog\\\",\\\"lot\\\",\\\"log\\\"]\\n    Output: 0\\n    Explanation: The endWord \\\"cog\\\" is not in wordList, therefore there is no valid transformation sequence.\\n\\n    **Constraints:**\\n    1 <= beginWord.length <= 10\\n    endWord.length == beginWord.length\\n    1 <= wordList.length <= 5000\\n    wordList[i].length == beginWord.length\\n    beginWord, endWord, and wordList[i] consist of lowercase English letters.\\n    beginWord != endWord\\n    All the words in wordList are unique.\\n */\\nclass WordLadder {\\n\\n    /**\\n     * Driver Code\\n     */\\n    public static void main(String[] args) {\\n\\n        String beginWord = \\\"hit\\\";\\n        String endWord = \\\"cog\\\";\\n        String words[] = {\\\"hot\\\", \\\"dot\\\", \\\"dog\\\", \\\"lot\\\", \\\"log\\\", \\\"cog\\\"};\\n        List<String> wordList = Arrays.asList(words);\\n\\n        System.out.println(\\\"Ladder Length: \\\" + ladderLength(beginWord, endWord, wordList));\\n    }\\n\\n    /**\\n     * This function finds the ladderLength\\n     *\\n     * @param beginWord: Starting word of the ladder\\n     * @param endWord: Ending word of the ladder\\n     * @param wordList: This list contains the words which needs to be included\\n     * in ladder.\\n     * @return ladderLength: This function will return the ladderLength(level)\\n     * if the endword is there. Otherwise, will return the length as 0.\\n     */\\n    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        HashSet<String> set = new HashSet();\\n        for (String word : wordList) {\\n            set.add(word);\\n        }\\n\\n        if (!set.contains(endWord)) {\\n            return 0;\\n        }\\n\\n        Queue<String> queue = new LinkedList();\\n        queue.offer(beginWord);\\n        int level = 1;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                String curr = queue.poll();\\n                char[] words_chars = curr.toCharArray();\\n                for (int j = 0; j < words_chars.length; j++) {\\n                    char original_chars = words_chars[j];\\n                    for (char c = 'a'; c <= 'z'; c++) {\\n                        if (words_chars[j] == c) {\\n                            continue;\\n                        }\\n                        words_chars[j] = c;\\n                        String new_word = String.valueOf(words_chars);\\n                        if (new_word.equals(endWord)) {\\n                            return level + 1;\\n                        }\\n                        if (set.contains(new_word)) {\\n                            set.remove(new_word);\\n                            queue.offer(new_word);\\n                        }\\n                    }\\n                    words_chars[j] = original_chars;\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n}\\n\""
  }
}
