{
  "kotlin": {
    "assembly line scheduling": "\"package dynamicProgramming\\n\\nimport kotlin.math.min\\n\\n\\n/*\\n * This is a dynamic programming implementation of assembly line scheduling.\\n * @Params n- number of stations, a- service time at each station, t- line switch time from each station, e- entry time, x- exit time\\n * @Return minimum time to cross n stations\\n * */\\nfun AssemblyLineScheduling(n:Int,a:Array<IntArray>,t:Array<IntArray>,e:IntArray,x:IntArray):Int {\\n\\n    var L1:IntArray =  IntArray(n);\\n    var L2:IntArray = IntArray(n) ;\\n    var i=0;\\n\\n    L1[0] = e[0] + a[0][0];\\n\\n    L2[0] = e[1] + a[1][0];\\n\\n    for(i in 1..n-1)\\n    {\\n        L1[i] = min(L1[i - 1] + a[0][i],\\n                L2[i - 1] + t[1][i] + a[0][i]);\\n        L2[i] = min(L2[i - 1] + a[1][i],\\n                L1[i - 1] + t[0][i] + a[1][i]);\\n    }\\n\\n    return min(L1[n-1] + x[0],\\n            L2[n-1] + x[1]);\\n\\n\\n}\\n\"",
    "edit distance": "\"package dynamicProgramming\\n\\nfun min(x: Int, y: Int, z: Int): Int {\\n    if (x <= y && x <= z) return x\\n    return if (y <= x && y <= z) y else z\\n}\\n\\n/*\\n * This is a dynamic programming implementation of edit distance.\\n * @Params str1,str2 - strings to be compared\\n * @Return minimum number of operations to convert one string to another\\n * */\\nfun editDistance(str1: String, str2: String): Int {\\n    val dp = Array(str1.length + 1) { IntArray(str2.length + 1) }\\n\\n    for (i in 0..str1.length) {\\n        for (j in 0..str2.length) {\\n            if (i == 0) dp[i][j] = j\\n            else if (j == 0) dp[i][j] = i\\n            else if (str1[i - 1]\\n                    == str2[j - 1]) dp[i][j] = dp[i - 1][j - 1] else dp[i][j] = (1\\n                    + min(dp[i][j - 1],\\n                    dp[i - 1][j],\\n                    dp[i - 1][j - 1]))\\n        }\\n    }\\n    return dp[str1.length][str2.length]\\n}\\n\"",
    "factorial": "\"package mathematics\\n\\nimport java.security.InvalidParameterException\\n\\n/**\\n * Calculates the factorial of a natural number greater than or equal to 0 recursively.\\n * @param number The number of which to calculate the factorial.\\n * @return The factorial of the number passed as parameter.\\n */\\nfun getFactorial(number: Long): Long {\\n    if (number < 0L) {\\n        throw InvalidParameterException(\\\"The number of which to calculate the factorial must be greater or equal to zero.\\\")\\n    } else return when (number) {\\n        0L -> 1\\n        1L -> number\\n        else -> number * getFactorial(number - 1)\\n    }\\n}\"",
    "is prime": "\"package dynamicProgramming\\n\\nfun Int.isPrime() = this > 1 && (2..(this / 2)).all { this % it != 0 }\"",
    "lcs": "\"package dynamicProgramming\\n\\nimport kotlin.math.max\\n\\n/* This algorithm is Longest Common Subsequence\\n\\n * @param  s1,s2 - strings to be compared\\n * @return Length of longest common subsequence between two strings.\\n   Eg., for stage and sale it is 3.(sae is the longest common subsequence)\\n */\\n\\nfun lcs(s1: String, s2: String): Int {\\n    val L = Array(s1.length + 1) { IntArray(s2.length + 1) }\\n\\n    for (i in 0..s1.length) {\\n        for (j in 0..s2.length) {\\n            if (i == 0 || j == 0) L[i][j] = 0\\n            else if (s1[i - 1] == s2[j - 1]) L[i][j] = L[i - 1][j - 1] + 1\\n            else L[i][j] = max(L[i - 1][j], L[i][j - 1])\\n        }\\n    }\\n    return L[s1.length][s2.length]\\n}\"",
    "matrix chain multiplication": "\"package dynamicProgramming\\n\\n/*\\n * This is a dynamic programming implementation of matrix chain multiplication.\\n * @Params p- array which represents the chain of matrices such that the ith matrix Ai is of dimension p[i-1] x p[i]\\n * @Return minimum number of multiplications needed to multiply the chain\\n * */\\nfun MatrixChainOrder(p: IntArray): Int {\\n\\n    val m = Array(p.size) { IntArray(p.size) }\\n    var i: Int\\n    var j: Int\\n    var k: Int\\n    var L: Int\\n    var q: Int\\n\\n    i = 1\\n    while (i < p.size) {\\n        m[i][i] = 0\\n        i++\\n    }\\n\\n    L = 2\\n    while (L < p.size) {\\n        i = 1\\n        while (i < p.size - L + 1) {\\n            j = i + L - 1\\n            if (j == p.size) {\\n                i++\\n                continue\\n            }\\n            m[i][j] = Int.MAX_VALUE\\n            k = i\\n            while (k <= j - 1) {\\n\\n                q = (m[i][k] + m[k + 1][j]\\n                        + p[i - 1] * p[k] * p[j])\\n                if (q < m[i][j]) m[i][j] = q\\n                k++\\n            }\\n            i++\\n        }\\n        L++\\n    }\\n    return m[1][p.size - 1]\\n}\"",
    "rod cutting problem": "\"package dynamicProgramming\\n\\nimport kotlin.math.max\\n\\n/*\\n * This is a dynamic programming implementation of rod cutting problem.\\n * @Params price- array of prices of all possible cut sizes of rod of array length\\n * @Return maximum value obtained by cutting rod\\n * */\\nfun rodCutting(price: IntArray): Int {\\n    val value = IntArray(price.size + 1)\\n    value[0] = 0\\n\\n    for (i in 1..price.size) {\\n        var maxVal = Int.MIN_VALUE\\n        for (j in 0 until i) maxVal = max(maxVal,\\n                price[j] + value[i - j - 1])\\n        value[i] = maxVal\\n    }\\n    return value[price.size]\\n}\"",
    "unbounded knapsack": "\"package dynamicProgramming\\n\\nimport kotlin.math.max\\n\\n/* This algorithm is Unbounded Knapsack Problem\\n\\n * @param W- capacity, weight- array of weights, value- array of value, n- size of weight and value array\\n * @return Maximum value with repetition of items that can be obtained\\n */\\n\\nfun unboundedKnapsack(W: Int, wt: IntArray, v: IntArray, n: Int): Int {\\n\\n    if (W < 0) return 0\\n\\n    val dp = IntArray(W + 1)\\n\\n    for (i in 0..W) {\\n        for (j in 0 until n) {\\n            if (wt[j] <= i) {\\n                dp[i] = max(dp[i], dp[i - wt[j]] + v[j])\\n            }\\n        }\\n    }\\n\\n    for (i in 0..W) {\\n        print(dp[i])\\n        print(\\\" \\\")\\n    }\\n    println(dp[W])\\n    return dp[W]\\n}\"",
    "weighted job scheduling": "\"package dynamicProgramming\\n\\nimport java.util.Comparator\\nimport java.util.Collections\\nimport kotlin.math.max\\n\\n/* This algorithm is Weighted Job Scheduling\\n\\n * @param jobs - list of jobs with start time, end time and profit\\n * @return Maximum profit that can be obtained\\n */\\n\\nclass Job(var start: Int, var finish: Int, var profit: Int)\\n\\nfun findLastNonConflictingJob(jobs: List<Job>, n: Int): Int {\\n    for (i in n - 1 downTo 0) {\\n        if (jobs[i].finish <= jobs[n].start) {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n\\nfun findMaxProfit(jobs: List<Job>): Int {\\n    Collections.sort(jobs, Comparator.comparingInt { x: Job -> x.finish })\\n\\n    val n = jobs.size\\n\\n    val maxProfit = IntArray(n)\\n\\n    maxProfit[0] = jobs[0].profit\\n\\n    for (i in 1 until n) {\\n        val index = findLastNonConflictingJob(jobs, i)\\n\\n        var incl = jobs[i].profit\\n        if (index != -1) {\\n            incl += maxProfit[index]\\n        }\\n\\n        maxProfit[i] = max(incl, maxProfit[i - 1])\\n    }\\n    return maxProfit[n - 1]\\n}\"",
    "zero one knapsack problem": "\"package dynamicProgramming\\n\\nimport kotlin.math.max\\n\\n/* This algorithm is Zero One Knapsack Problem\\n\\n * @param W- capacity, weight- array of weights, value- array of value, n- size of weight and value array\\n * @return Maximum value that can be obtained\\n */\\n\\nfun zerooneknapsack(W:Int, weight: IntArray, values:IntArray, n:Int):Int{\\n    if (W<0) return 0\\n    val k = Array(n+1) {IntArray(W+1) {0} }\\n    for (i in 0..n)\\n    {\\n        for (j in 0..W)\\n        {\\n            if (i == 0 || j == 0)\\n                k[i][j] = 0\\n            else if (weight[i - 1] <= j)\\n                k[i][j] = max(values[i - 1]\\n            + k[i - 1][j - weight[i - 1]],\\n            k[i - 1][j])\\n            else\\n            k[i][j] = k[i - 1][j]\\n        }\\n    }\\n    return k[n][W]\\n}\"",
    "palindrome partitioning": "\"package dynamic_programming\\n\\n/**\\n * Palindrome Partitioning Algorithm\\n *\\n * You are given a string as input, and task is to find the minimum number of partitions to be made,\\n * in the string sot that the resulting strings are all palindrome\\n * eg. s = \\\"nitik\\\"\\n * string s can be partitioned as n | iti | k into 3 palindromes, thus the number of partions are 2\\n * Time Complexity = O(n^2)\\n *\\n * */\\n\\n\\n/**\\n * @param String is the string to be checked\\n * @param Int is the starting index of the string in consideration\\n * @param Int is the ending index of the string in consideration\\n * @return whether string is a palindrome or not\\n **/\\nfun isPalindrome(string: String, i: Int, j: Int): Boolean {\\n    for (l in 0..(j - i) / 2) {\\n        if (string[l + i] != string[j - l]) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\n\\n/**\\n * @param String is the string to be checked\\n * @param Int is the starting index of the string in consideration\\n * @param Int is the ending index of the string in consideration\\n * @return minimum number of partitions required\\n **/\\nfun palindromePartition(string: String, i: Int, j: Int): Int {\\n    if (i >= j) {\\n        return 0\\n    }\\n    if (isPalindrome(string, i, j)) {\\n        return 0\\n    }\\n    if (dp[i][j] != -1) {\\n        return dp[i][j]\\n    }\\n    var mn = Int.MAX_VALUE\\n    for (k in i until j) {\\n        val temp: Int = palindromePartition(string, i, k) + palindromePartition(string, k + 1, j) + 1\\n        if (temp < mn) {\\n            mn = temp\\n        }\\n    }\\n    dp[i][j] = mn\\n    return dp[i][j]\\n}\\n\\n\\n/**\\n * memoization table\\n **/\\nlateinit var dp: Array<Array<Int>>\\n\\n\\n/**\\n * @param String the string on which algorithm is to be operated\\n */\\nfun initialize(string: String): Int {\\n    dp = Array(string.length) { Array(string.length) { -1 } }\\n    return palindromePartition(string, 0, string.length - 1)\\n}\\n\"",
    "area": "\"package math\\n\\nimport java.lang.IllegalArgumentException\\nimport kotlin.math.pow\\n\\n/**\\n * Calculate the area of a rectangle\\n *\\n * @param length length of rectangle\\n * @param width width of rectangle\\n * @return area of given rectangle\\n */\\nfun areaOfARectangle(length: Double, width: Double) =  when {\\n    length > 0 && width > 0 -> length * width\\n    else -> throw IllegalArgumentException(\\\"Length and Width must be positive\\\")\\n}\\n\\n/**\\n * Calculate the area of a square\\n *\\n * @param sideLength side length of square\\n * @return area of given square\\n */\\nfun areaOfASquare(sideLength: Double) =\\n    when {\\n        sideLength > 0 -> sideLength * sideLength\\n        else -> throw IllegalArgumentException(\\\"Side Length must be positive\\\")\\n    }\\n\\n/**\\n * Calculate the area of a triangle\\n *\\n * @param base base of triangle\\n * @param height height of triangle\\n * @return area of given triangle\\n */\\nfun areaOfATriangle(base: Double, height: Double) =\\n    when {\\n        base > 0 && height > 0 -> base * height / 2\\n        else -> throw IllegalArgumentException(\\\"Base and Height must be positive\\\")\\n    }\\n\\n/**\\n * Calculate the area of a circle\\n *\\n * @param radius radius of circle\\n * @return area of given circle\\n */\\nfun areaOfACircle(radius: Double) =\\n    when {\\n        radius > 0 -> Math.PI * radius.pow(2.0)\\n        else -> throw IllegalArgumentException(\\\"Radius must be positive\\\")\\n    }\"",
    "average": "\"package math\\n\\n\\n/**\\n * Calculate the average of a list of Double\\n *\\n * @param numbers array to store numbers\\n * @return average of given numbers\\n */\\nfun average(numbers: Array<Double>): Double {\\n    var sum = 0.0\\n    for (number in numbers) {\\n        sum += number\\n    }\\n    return sum / numbers.size\\n}\\n\\n/**\\n * Calculate the average of a list of Int\\n *\\n * @param numbers array to store numbers\\n * @return average of given numbers\\n */\\nfun average(numbers: Array<Int>) : Int {\\n    var sum = 0\\n    for (number in numbers) {\\n        sum += number\\n    }\\n    return sum / numbers.size\\n}\\n\"",
    "median": "\"package math\\n\\nimport java.util.Arrays.sort\\n\\n/**\\n * Calculates the median of an array of Int\\n *\\n * @param values is an array of Int\\n * @return the middle number of the array\\n */\\nfun median(values: IntArray): Double {\\n    sort(values)\\n    return when {\\n        values.size % 2 == 0 -> getHalfwayBetweenMiddleValues(values)\\n        else -> getMiddleValue(values)\\n    }\\n}\\n\\n/**\\n * Calculates the middle number of an array when the size is an even number\\n *\\n * @param values is an array of Int\\n * @return the middle number of the array\\n */\\nprivate fun getHalfwayBetweenMiddleValues(values: IntArray): Double {\\n    val arraySize = values.size\\n    val sumOfMiddleValues = (values[arraySize / 2] + values[(arraySize / 2) - 1 ])\\n    return sumOfMiddleValues / 2.0\\n}\\n\\n/**\\n * Calculates the middle number of an array when the size is an odd number\\n *\\n * @param values is an array of Int\\n * @return the middle number of the array\\n */\\nprivate fun getMiddleValue(values: IntArray): Double {\\n    return values[values.size / 2].toDouble()\\n}\\n\"",
    "two sum": "\"package math\\n/**\\n * Approach 1: Brute Force\\n *\\n * Complexity Analysis:\\n *\\n * Time complexity: O(n^2)\\n * Space complexity: O(1)\\n *\\n * Try all the pairs in the array and see if any of them add up to the target number.\\n * @param nums Array of integers.\\n * @param target Integer target.\\n * @return Indices of the two numbers such that they add up to target.\\n */\\nfun twoSum(nums: IntArray, target: Int): IntArray{\\n    for (index1 in nums.indices) {\\n        val startIndex = index1 + 1\\n        for (index2 in startIndex..nums.lastIndex) {\\n            if (nums[index1] + nums[index2] == target) {\\n                return intArrayOf(index1, index2)\\n            }\\n        }\\n    }\\n    return intArrayOf(0,1)\\n\\n}\\n\"",
    "palindrome": "\"package other\\n\\nimport java.text.Normalizer\\nimport java.util.regex.Pattern\\n\\n/**\\n * A palindrome is a word, number, phrase, or other sequence\\n * of characters which reads the same backward as forward,\\n * such as madam, racecar. There are also numeric palindromes,\\n * particularly date/time stamps using short digits 11/11/11 11:11\\n * and long digits 02/02/2020\\n *\\n * This function\\n * @param text The text to be checked if it is a palindrome\\n * @return return true if the text is a Palindrome\\n */\\nfun isPalindrome(text: String): Boolean {\\n\\n    val normalizedText = text.normalize()\\n    for(i in normalizedText.indices)\\n        if(normalizedText[i] != normalizedText[normalizedText.length - (i + 1)])\\n            return false\\n    return true;\\n}\\n\\n\\nfun String.normalize(): String {\\n    val nfdNormalizedString = Normalizer.normalize(this, Normalizer.Form.NFD)\\n    return Pattern\\n        .compile(\\\"\\\\\\\\p{InCombiningDiacriticalMarks}+\\\")\\n        .matcher(nfdNormalizedString)\\n        .replaceAll(\\\"\\\")\\n        .toLowerCase()\\n        .replace(\\\" \\\", \\\"\\\")\\n\\n}\"",
    "binary search": "\"package search\\n\\n/**\\n * Binary search is an algorithm which finds the position of a target value within an array (Sorted)\\n *\\n * Worst-case performance\\tO(log(n))\\n * Best-case performance\\tO(1)\\n * Average performance\\tO(log(n))\\n * Worst-case space complexity\\tO(1)\\n */\\n\\n/**\\n * @param array is an array where the element should be found\\n * @param key is an element which should be found\\n * @return index of the element\\n */\\nfun <T : Comparable<T>> binarySearch(array: Array<T>, key: T): Int {\\n    return binarySearchHelper(array, key, 0, array.size - 1)\\n}\\n\\n/**\\n * @param array The array to search\\n * @param key The element you are looking for\\n * @return the location of the key or -1 if the element is not found\\n **/\\nfun <T : Comparable<T>> binarySearchHelper(array: Array<T>, key: T, start: Int, end: Int): Int {\\n    if (start > end) {\\n        return -1\\n    }\\n\\n    val mid = start + (end - start) / 2\\n\\n    return when {\\n        array[mid].compareTo(key) == 0 -> mid\\n        array[mid].compareTo(key) > 0 -> binarySearchHelper(array, key, start, mid - 1)\\n        else -> binarySearchHelper(array, key, mid + 1, end)\\n    }\\n}\\n\"",
    "interpolation search": "\"package search\\n\\n/**\\n * Interpolation search is an algorithm which finds the position of a target value within an array (Sorted)\\n *\\n * Worst-case performance\\tO(n)\\n * Best-case performance\\tO(1)\\n * Average performance\\tO(log log n)\\n * Worst-case space complexity\\tO(1)\\n */\\n\\n/**\\n * @param arr is an array where the element should be found\\n * @param lo array starting index\\n * @param hi array ending index\\n * @param x is an element which should be found\\n * @return index of the element\\n */\\n\\nfun interpolationSearch(arr: IntArray, lo: Int,\\n                        hi: Int, x: Int): Int {\\n    val pos: Int\\n\\n    if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {\\n\\n        pos = (lo\\n                + ((hi - lo) / (arr[hi] - arr[lo])\\n                * (x - arr[lo])))\\n\\n        if (arr[pos] == x) return pos\\n\\n        if (arr[pos] < x) return interpolationSearch(arr, pos + 1, hi,\\n                x)\\n\\n        if (arr[pos] > x) return interpolationSearch(arr, lo, pos - 1,\\n                x)\\n    }\\n    return -1\\n}\"",
    "linear search": "\"package search\\n\\n/**\\n * Linear search is an algorithm which finds the position of a target value within an array (Usually unsorted)\\n *\\n * Worst-case performance\\tO(n)\\n * Best-case performance\\tO(1)\\n * Average performance\\tO(n)\\n * Worst-case space complexity\\tO(1)\\n */\\n\\n/**\\n * @param array is an array where the element should be found\\n * @param key is an element which should be found\\n * @return index of the element\\n */\\nfun <T : Comparable<T>> linearSearch(array: Array<T>, key: T): Int {\\n    return linearSearchImpl(array, key)\\n}\\n\\n/**\\n * @param array The array to search\\n * @param key The element you are looking for\\n * @return the location of the key or -1 if the element is not found\\n **/\\nfun <T : Comparable<T>> linearSearchImpl(array: Array<T>, key: T): Int {\\n    for (i in array.indices) {\\n        if (array[i].compareTo(key) == 0) {\\n            return i\\n        }\\n    }\\n\\n    return -1\\n}\\n\"",
    "ternary search": "\"package search\\r\\n\\r\\n/**\\r\\n * Complexity Analysis:\\r\\n * \\r\\n * Time Complexity: O(log3 n)\\r\\n * Space Complexity: O(1)\\r\\n * \\r\\n */\\r\\n\\r\\nfun ternarySearch(l: Double, r: Double, func: (Double) -> Double, eps: Double = 1e-3): Double {\\r\\n    var left = l\\r\\n    var right = r\\r\\n    while (right - left > eps) {\\r\\n        val midFirst = left + (right - left) / 3\\r\\n        val midSecond = right - (right - left) / 3\\r\\n        if (func(midFirst) < func(midSecond)) {\\r\\n            left = midFirst\\r\\n        } else {\\r\\n            right = midSecond\\r\\n        }\\r\\n    }\\r\\n    return left\\r\\n}\\r\\n\"",
    "brick sort": "\"package sort\\n\\n/**\\n * This method implements the Generic Brick Sort\\n *\\n * @param array The array to be sorted\\n * Sorts the array in increasing order\\n *\\n * Worst-case performance\\tO(n^2)\\n * Best-case performance\\tO(n)\\n * Average performance\\tO(n^2)\\n * Worst-case space complexity\\tO(1)\\n **/\\n\\nfun <T : Comparable<T>>  oddEvenSort(array: Array<T>) {\\n    var isSorted = false\\n    while (!isSorted) {\\n        isSorted = true\\n        var temp : Comparable<T>\\n\\n\\n        var i = 1\\n        while (i <= array.size - 2) {\\n            if (array[i] > array[i + 1]) {\\n                temp = array[i]\\n                array[i] = array[i + 1]\\n                array[i + 1] = temp\\n                isSorted = false\\n            }\\n            i += 2\\n        }\\n        var j = 0\\n        while (j <= array.size - 2) {\\n            if (array[j] > array[j + 1]) {\\n                temp = array[j]\\n                array[j] = array[j + 1]\\n                array[j + 1] = temp\\n                isSorted = false\\n            }\\n            j += 2\\n        }\\n    }\\n    return\\n}\"",
    "bubble sort": "\"package sort\\n\\n/**\\n * This method implements the Generic Bubble Sort\\n *\\n * @param array The array to be sorted\\n * Sorts the array in increasing order\\n *\\n * Worst-case performance\\tO(n^2)\\n * Best-case performance\\tO(n)\\n * Average performance\\tO(n^2)\\n * Worst-case space complexity\\tO(1)\\n **/\\nfun <T : Comparable<T>> bubbleSort(array: Array<T>) {\\n    val length = array.size - 1\\n\\n    for (i in 0..length) {\\n        var isSwapped = false\\n        for (j in 1..length) {\\n            if (array[j] < array[j - 1]) {\\n                isSwapped = true\\n                swapElements(array, j, j - 1)\\n            }\\n        }\\n\\n        if (!isSwapped) break\\n    }\\n}\\n\\n/**\\n * This method swaps the element at two indexes\\n *\\n * @param array The array containing the elements\\n * @param idx1 Index of first element\\n * @param idx2 Index of second element\\n * Swaps the element at two indexes\\n **/\\nfun <T : Comparable<T>> swapElements(array: Array<T>, idx1: Int, idx2: Int) {\\n    array[idx1] = array[idx2].also {\\n        array[idx2] = array[idx1]\\n    }\\n}\\n\"",
    "heap sort": "\"package sort\\n\\n/**\\n * This function implements the Heap Sort.\\n *\\n * @param array The array to be sorted\\n * Sorts the array in increasing order\\n *\\n * Worst-case performance       O(n*log(n))\\n * Best-case performance        O(n*log(n))\\n * Average-case performance     O(n*log(n))\\n * Worst-case space complexity  O(1) (auxiliary)\\n */\\nfun <T : Comparable<T>> heapSort(array: Array<T>) {\\n    buildMaxHeap(array)\\n    transformMaxHeapToSortedArray(array)\\n}\\n\\n/**\\n * This function changes the element order of the array to represent a max\\n * binary tree.\\n *\\n * @param array The array containing the elements\\n * @param index Index of the currently largest element\\n */\\nfun <T : Comparable<T>> maxheapify(array: Array<T>, heapSize: Int, index: Int) {\\n    val left = 2 * index + 1\\n    val right = 2 * index + 2\\n    var largest = index\\n\\n    if (left < heapSize && array[left] > array[largest])\\n        largest = left\\n    if (right < heapSize && array[right] > array[largest])\\n        largest = right\\n    if (largest != index) {\\n        swapElements(array, index, largest)\\n        maxheapify(array, heapSize, largest)\\n    }\\n}\\n\\n/**\\n * Arrange the elements of the array to represent a max heap.\\n *\\n * @param array The array containing the elements\\n */\\nprivate fun <T : Comparable<T>> buildMaxHeap(array: Array<T>) {\\n    val n = array.size\\n    for (i in (n / 2 - 1) downTo 0)\\n        maxheapify(array, n, i)\\n}\\n\\n/**\\n * Arrange the elements of the array, which should be in order to represent a\\n * max heap, into ascending order.\\n *\\n * @param array The array containing the elements (max heap representation)\\n */\\nprivate fun <T : Comparable<T>> transformMaxHeapToSortedArray(array: Array<T>) {\\n    for (i in (array.size - 1) downTo 0) {\\n        swapElements(array, i, 0)\\n        maxheapify(array, i, 0)\\n    }\\n}\\n\\n\"",
    "insertion sort": "\"package sort\\n\\n/**\\n * This method implements the Generic Insertion Sort\\n *\\n * @param array The array to be sorted\\n * Sorts the array in increasing order\\n *\\n * Worst-case performance\\tO(n^2)\\n * Best-case performance\\tO(n)\\n * Average performance\\tO(n^2)\\n * Worst-case space complexity\\tO(1)\\n **/\\nfun <T : Comparable<T>> insertionSort(array: Array<T>) {\\n    val size = array.size - 1\\n\\n    for (i in 1..size) {\\n        val key = array[i]\\n        var idx = i\\n\\n        for (j in i - 1 downTo 0) {\\n            if (array[j].compareTo(key) > 0) {\\n                array[j + 1] = array[j]\\n                idx = j\\n            } else {\\n                break\\n            }\\n        }\\n\\n        array[idx] = key\\n    }\\n}\"",
    "merge sort": "\"package sort\\n\\n/**\\n * This function implements Merge Sort\\n *\\n * @param array The array to be sorted\\n * It is a Divide and Conquer algorithm. It sorts the array by dividing it into two halves and comparing the elements.\\n *\\n * Worst-case performance\\t    O(n log n)\\n * Best-case performance\\t    O(n log n)\\n * Average performance      \\tO(n log n)\\n * Worst-case space complexity\\tO(n)\\n */\\nfun <T : Comparable<T>> mergeSort(array: Array<T>, start: Int, end: Int) {\\n\\n    val temp = arrayOfNulls<Comparable<*>>(array.size) as Array<T>\\n\\n    if (start < end) {\\n        val mid = start + (end - start) / 2\\n        mergeSort(array, start, mid)\\n        mergeSort(array, mid + 1, end)\\n        merge(array, temp, start, mid, end)\\n    }\\n}\\n\\n/**\\n * This function merges the two halves after comparing them\\n * @param array The array to be sorted\\n * @param temp The temp array containing the values\\n * @param start Starting index of the array\\n * @param mid Middle index of the array\\n * @param end Ending index of the array\\n */\\nfun <T : Comparable<T>> merge(array: Array<T>, temp: Array<T>, start: Int, mid: Int, end: Int) {\\n\\n    System.arraycopy(array, start, temp, start, end - start + 1)\\n\\n    var i = start\\n    var j = mid + 1\\n    var k = start\\n\\n    while (i <= mid && j <= end) {\\n        if (temp[i] < temp[j]) {\\n            array[k++] = temp[i++]\\n        } else {\\n            array[k++] = temp[j++]\\n        }\\n    }\\n\\n    while (i <= mid) {\\n        array[k++] = temp[i++]\\n    }\\n\\n    while (j <= end) {\\n        array[k++] = temp[j++]\\n    }\\n}\"",
    "quick sort": "\"package sort\\n\\n/**\\n * This method implements the Quick Sort\\n *\\n * @param array The array to be sorted\\n * It is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot.\\n *\\n * Worst-case performance\\t    O(n^2)\\n * Best-case performance\\t    O(nLogn)\\n * Average performance      \\tO(nLogn)\\n * Worst-case space complexity\\tO(1)\\n **/\\nfun <T : Comparable<T>> quickSort(array: Array<T>, low: Int, high: Int) {\\n    if (low < high) {\\n        val pivot = partition(array, low, high)\\n        quickSort(array, low, pivot - 1)\\n        quickSort(array, pivot, high)\\n    }\\n}\\n\\n/**\\n * This method finds the pivot index for an array\\n *\\n * @param array The array to be sorted\\n * @param low The first index of the array\\n * @param high The last index of the array\\n *\\n * */\\nfun <T : Comparable<T>> partition(array: Array<T>, low: Int, high: Int): Int {\\n\\n    var left = low\\n    var right = high\\n    val mid = (left + right) / 2\\n    val pivot = array[mid]\\n\\n    while (left <= right) {\\n        while (array[left] < pivot) {\\n            left++\\n        }\\n\\n        while (array[right] > pivot) {\\n            right--\\n        }\\n\\n        if (left <= right) {\\n            swapElements(array, left, right)\\n            left++\\n            right--\\n        }\\n    }\\n    return left\\n}\"",
    "selection sort": "\"package sort\\n\\n/**\\n * This method implements the Generic Selection Sort\\n *\\n * @param array The array to be sorted\\n * Sorts the array by repeatedly finding the minimum element from unsorted part and putting in the beginning\\n *\\n * Worst-case performance\\tO(n^2)\\n * Best-case performance\\tO(n^2)\\n * Average performance\\tO(n^2)\\n * Worst-case space complexity\\tO(1)\\n **/\\nfun <T : Comparable<T>> selectionSort(array: Array<T>) {\\n    val length = array.size - 1\\n\\n    for (i in 0..length) {\\n        var idx = i\\n        for (j in i + 1..length) {\\n            if (array[j] < array[idx]) {\\n                idx = j\\n            }\\n        }\\n\\n        swapElements(array, i, idx)\\n    }\\n}\\n\""
  }
}
