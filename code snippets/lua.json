{
  "lua": {
    "heap": "\"local heap = {}\\n\\nlocal metatable = { __index = heap }\\n\\nfunction heap.less_than(a, b)\\n\\treturn a < b\\nend\\n\\nfunction heap.new(less_than)\\n\\t-- empty min heap\\n\\treturn setmetatable({ less_than = less_than }, metatable)\\nend\\n\\nfunction heap:push(value)\\n\\ttable.insert(self, value)\\n\\tlocal function heapify(index)\\n\\t\\tif index == 1 then\\n\\t\\t\\treturn\\n\\t\\tend\\n\\t\\tlocal parent = math.floor(index / 2)\\n\\t\\tif self.less_than(self[index], self[parent]) then\\n\\t\\t\\tself[parent], self[index] = self[index], self[parent]\\n\\t\\t\\theapify(parent)\\n\\t\\tend\\n\\tend\\n\\theapify(#self)\\nend\\n\\nfunction heap:top()\\n\\treturn self[1]\\nend\\n\\nfunction heap:pop()\\n\\tlocal value = self[1]\\n\\tlocal last = #self\\n\\tif last == 1 then\\n\\t\\tself[1] = nil\\n\\t\\treturn value\\n\\tend\\n\\tself[1], self[last] = self[last], nil\\n\\tlast = last - 1\\n\\tlocal function heapify(index)\\n\\t\\tlocal left_child = index * 2\\n\\t\\tif left_child > last then\\n\\t\\t\\treturn\\n\\t\\tend\\n\\t\\tlocal smallest_child = left_child + 1\\n\\t\\tif smallest_child > last or self.less_than(self[left_child], self[smallest_child]) then\\n\\t\\t\\tsmallest_child = left_child\\n\\t\\tend\\n\\t\\tif self.less_than(self[smallest_child], self[index]) then\\n\\t\\t\\tself[index], self[smallest_child] = self[smallest_child], self[index]\\n\\t\\t\\theapify(smallest_child)\\n\\t\\tend\\n\\tend\\n\\theapify(1)\\n\\treturn value\\nend\\n\\nreturn require(\\\"class\\\")(heap)\\n\"",
    "linked queue": "\"local linked_queue = {}\\n\\nfunction linked_queue.new()\\n\\treturn {}\\nend\\n\\nfunction linked_queue:empty()\\n\\treturn not self._top\\nend\\n\\nfunction linked_queue:push(value)\\n\\tif self:empty() then\\n\\t\\tself._top = { value = value }\\n\\t\\tself._bottom = self._top\\n\\telse\\n\\t\\tself._bottom.below = { value = value }\\n\\t\\tself._bottom = self._bottom.below\\n\\tend\\nend\\n\\nfunction linked_queue:top()\\n\\tif self:empty() then\\n\\t\\treturn\\n\\tend\\n\\treturn self._top.value\\nend\\n\\nfunction linked_queue:pop()\\n\\tif self:empty() then\\n\\t\\treturn\\n\\tend\\n\\tlocal top_element = self:top()\\n\\tself._top = self._top.below\\n\\tif self:empty() then -- List became empty through popping\\n\\t\\tself._bottom = nil\\n\\tend\\n\\treturn top_element\\nend\\n\\nreturn require(\\\"class\\\")(linked_queue)\\n\"",
    "linked stack": "\"local linked_stack = {}\\n\\nfunction linked_stack.new()\\n\\treturn {}\\nend\\n\\nfunction linked_stack:empty()\\n\\treturn not self._top\\nend\\n\\nfunction linked_stack:push(value)\\n\\tself._top = { value = value, below = self._top }\\nend\\n\\nfunction linked_stack:top()\\n\\tif self:empty() then\\n\\t\\treturn\\n\\tend\\n\\treturn self._top.value\\nend\\n\\nfunction linked_stack:pop()\\n\\tif self:empty() then\\n\\t\\treturn\\n\\tend\\n\\tlocal top_element = self:top()\\n\\tself._top = self._top.below\\n\\treturn top_element\\nend\\n\\nreturn require(\\\"class\\\")(linked_stack)\\n\"",
    "table stack": "\"-- Table (implementation-dependant, in practice array list) based stack\\n-- Worst-case linear time for basic operations, in practice amortized constant time and significantly less overhead\\n-- Merely a OOP wrapper for Lua's table library\\nlocal table_stack = {}\\n\\nfunction table_stack.new()\\n\\treturn {}\\nend\\n\\nfunction table_stack:empty()\\n\\treturn self[1] == nil\\nend\\n\\nfunction table_stack:push(value)\\n\\ttable.insert(self, value)\\nend\\n\\nfunction table_stack:top()\\n\\treturn self[#self]\\nend\\n\\nfunction table_stack:pop()\\n\\treturn table.remove(self)\\nend\\n\\nreturn require(\\\"class\\\")(table_stack)\\n\"",
    "coin change": "\"return function(\\n\\t-- value to be achieved as a coin sum\\n\\ttarget_value,\\n\\t-- list of available coin values\\n\\tcoin_values\\n)\\n\\tlocal values = { [0] = { count = 0 } }\\n\\tfor value = 1, target_value do\\n\\t\\tfor _, coin_value in ipairs(coin_values) do\\n\\t\\t\\tif coin_value <= value then\\n\\t\\t\\t\\tlocal count_using_coin = values[value - coin_value].count + 1\\n\\t\\t\\t\\tif not values[value] or count_using_coin < values[value].count then\\n\\t\\t\\t\\t\\tvalues[value] = { count = count_using_coin, used_coin_value = coin_value }\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\t\\tend\\n\\tend\\n\\tlocal used_coin_values = {}\\n\\twhile target_value > 0 do\\n\\t\\tlocal used_coin_value = values[target_value].used_coin_value\\n\\t\\ttable.insert(used_coin_values, used_coin_value)\\n\\t\\ttarget_value = target_value - used_coin_value\\n\\tend\\n\\t-- values may appear multiple times in the list if a coin is used multiple times\\n\\treturn used_coin_values\\nend\\n\"",
    "binary search": "\"return function(\\n\\tlist,\\n\\t-- Value to be searched\\n\\tvalue\\n)\\n\\tlocal min, max = 1, #list\\n\\twhile min <= max do\\n\\t\\tlocal pivot = min + math.floor((max - min) / 2)\\n\\t\\tlocal element = list[pivot]\\n\\t\\tif value == element then\\n\\t\\t\\t-- Index if found\\n\\t\\t\\treturn pivot\\n\\t\\telseif value > element then\\n\\t\\t\\tmin = pivot + 1\\n\\t\\telse\\n\\t\\t\\tassert(value < element, \\\"invalid order operators for binary search\\\")\\n\\t\\t\\tmax = pivot - 1\\n\\t\\tend\\n\\tend\\n\\t-- Negative insertion index if not found\\n\\treturn -min\\nend\\n\"",
    "linear search": "\"return function(\\n\\tlist,\\n\\t-- Value to be searched\\n\\tvalue,\\n\\t-- Whether the list is sorted\\n\\tsorted\\n)\\n\\tfor index, element in ipairs(list) do\\n\\t\\tif element == value then\\n\\t\\t\\t-- Index if found\\n\\t\\t\\treturn index\\n\\t\\telseif element > value and sorted then\\n\\t\\t\\t-- Negative insertion index if the list is sorted and the value was not found\\n\\t\\t\\treturn -index\\n\\t\\tend\\n\\tend\\n\\t-- Negative insertion index after the last element\\n\\t-- Returned if the list is unsorted or the value is bigger than all values in the sorted list\\n\\treturn -#list - 1\\nend\\n\"",
    "heapsort": "\"local heap = require(\\\"data_structures.heap\\\")\\nreturn function(\\n\\t-- list to be sorted in-place\\n\\tlist,\\n\\t-- function(a, b) -> truthy value if a < b\\n\\tless_than\\n)\\n\\tlocal elements = heap.new(less_than)\\n\\tfor _, value in ipairs(list) do\\n\\t\\telements:push(value)\\n\\tend\\n\\tfor index = 1, #list do\\n\\t\\tlist[index] = elements:pop()\\n\\tend\\nend\\n\"",
    "insertionsort": "\"--! Insertionsort has quadratic time complexity and should not be used in practice\\nreturn function(\\n\\t-- list to be sorted in-place\\n\\tlist,\\n\\t-- function(a, b) -> truthy value if a < b\\n\\tless_than\\n)\\n\\tless_than = less_than or function(a, b)\\n\\t\\treturn a < b\\n\\tend\\n\\tfor index = 2, #list do\\n\\t\\tlocal value = list[index]\\n\\t\\t-- Even if a binary search was used to determine the insertion index,\\n\\t\\t-- time complexity would remain quadratic due to the series of swaps required for insertion\\n\\t\\tlocal insertion_index = 0\\n\\t\\trepeat\\n\\t\\t\\tinsertion_index = insertion_index + 1\\n\\t\\tuntil less_than(value, list[insertion_index]) or insertion_index >= #list\\n\\t\\t-- Shift all elements - starting at the insertion index - up by one\\n\\t\\tfor shift_index = index - 1, insertion_index, -1 do\\n\\t\\t\\tlist[shift_index + 1] = list[shift_index]\\n\\t\\tend\\n\\t\\tlist[insertion_index] = value\\n\\tend\\nend\\n\"",
    "is sorted": "\"return function(\\n\\tlist,\\n\\t-- function(a, b) -> truthy value if a < b\\n\\tless_than\\n)\\n\\tless_than = less_than or function(a, b)\\n\\t\\treturn a < b\\n\\tend\\n\\tfor i = 2, #list do\\n\\t\\t-- Check whether an element is smaller than it's predecessor;\\n\\t\\t-- If all elements are less than or equal to their predecessor, the list must be sorted\\n\\t\\t-- due to the transitivity of the comparison operator\\n\\t\\tif less_than(list[i], list[i - 1]) then\\n\\t\\t\\t-- list is not sorted ascendingly\\n\\t\\t\\treturn false\\n\\t\\tend\\n\\tend\\n\\t-- list is sorted ascendingly\\n\\treturn true\\nend\\n\"",
    "mergesort": "\"return function(\\n\\t-- list to be sorted in-place\\n\\tlist,\\n\\t-- function(a, b) -> truthy value if a < b\\n\\tless_than\\n)\\n\\tless_than = less_than or function(a, b)\\n\\t\\treturn a < b\\n\\tend\\n\\t-- Merges two sorted lists; elements of a come before those of b\\n\\tlocal function merge(result, list_1, list_2)\\n\\t\\tlocal result_index = 1\\n\\t\\tlocal index_1 = 1\\n\\t\\tlocal index_2 = 1\\n\\t\\twhile index_1 <= #list_1 and index_2 <= #list_2 do\\n\\t\\t\\t-- Compare \\\"head\\\" element, insert \\\"winner\\\"\\n\\t\\t\\tif less_than(list_2[index_2], list_1[index_1]) then\\n\\t\\t\\t\\tresult[result_index] = list_2[index_2]\\n\\t\\t\\t\\tindex_2 = index_2 + 1\\n\\t\\t\\telse\\n\\t\\t\\t\\tresult[result_index] = list_1[index_1]\\n\\t\\t\\t\\tindex_1 = index_1 + 1\\n\\t\\t\\tend\\n\\t\\t\\tresult_index = result_index + 1\\n\\t\\tend\\n\\t\\t-- Add remaining elements of either list or other_list\\n\\t\\tfor offset = 0, #list_1 - index_1 do\\n\\t\\t\\tresult[result_index + offset] = list_1[index_1 + offset]\\n\\t\\tend\\n\\t\\tfor offset = 0, #list_2 - index_2 do\\n\\t\\t\\tresult[result_index + offset] = list_2[index_2 + offset]\\n\\t\\tend\\n\\tend\\n\\n\\tlocal function mergesort(list_to_sort, lower_index, upper_index)\\n\\t\\tif lower_index == upper_index then\\n\\t\\t\\tlist_to_sort[1] = list[lower_index]\\n\\t\\tend\\n\\t\\tif lower_index >= upper_index then\\n\\t\\t\\treturn\\n\\t\\tend\\n\\t\\tlocal middle_index = math.floor((upper_index + lower_index) / 2)\\n\\n\\t\\tlocal left = {}\\n\\t\\tmergesort(left, lower_index, middle_index)\\n\\t\\tlocal right = {}\\n\\t\\tmergesort(right, middle_index + 1, upper_index)\\n\\n\\t\\tmerge(list_to_sort, left, right)\\n\\tend\\n\\tmergesort(list, 1, #list)\\nend\\n\"",
    "quicksort": "\"return function(\\n\\t-- function(lower_index, upper_index) -> pivot index\\n\\tchoose_pivot\\n)\\n\\tchoose_pivot = choose_pivot or math.random\\n\\treturn function(\\n\\t\\t-- list to be sorted in-place\\n\\t\\tlist,\\n\\t\\t-- function(a, b) -> truthy value if a < b\\n\\t\\tless_than\\n\\t)\\n\\t\\tless_than = less_than or function(a, b)\\n\\t\\t\\treturn a < b\\n\\t\\tend\\n\\t\\tlocal function quicksort(lower_index, upper_index)\\n\\t\\t\\tif lower_index >= upper_index then\\n\\t\\t\\t\\treturn\\n\\t\\t\\tend\\n\\t\\t\\tlocal pivot_index = choose_pivot(lower_index, upper_index)\\n\\t\\t\\tlocal pivot_value = list[pivot_index]\\n\\t\\t\\t-- Place pivot at last position in range\\n\\t\\t\\tlist[pivot_index], list[upper_index] = list[upper_index], pivot_value\\n\\t\\t\\t-- Index to place the pivot at\\n\\t\\t\\tpivot_index = lower_index\\n\\t\\t\\t-- Partition\\n\\t\\t\\tfor j = lower_index, upper_index - 1 do\\n\\t\\t\\t\\tif not less_than(pivot_value, list[j]) then\\n\\t\\t\\t\\t\\tlist[pivot_index], list[j] = list[j], list[pivot_index]\\n\\t\\t\\t\\t\\tpivot_index = pivot_index + 1\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\t\\t\\t-- Place pivot between numbers <= pivot (from lower_index to pivot_index - 1)\\n\\t\\t\\t-- and numbers >= pivot (from pivot_index to upper_index)\\n\\t\\t\\tlist[pivot_index], list[upper_index] = list[upper_index], list[pivot_index]\\n\\t\\t\\tquicksort(lower_index, pivot_index - 1)\\n\\t\\t\\tquicksort(pivot_index + 1, upper_index)\\n\\t\\tend\\n\\t\\tquicksort(1, #list)\\n\\tend\\nend\\n\"",
    "selectionsort": "\"--! selection sort has quadratic time complexity and should not be used in practice\\nreturn function(\\n\\t-- list to be sorted in-place\\n\\tlist,\\n\\t-- function(a, b) -> truthy value if a < b\\n\\tless_than\\n)\\n\\tless_than = less_than or function(a, b)\\n\\t\\treturn a < b\\n\\tend\\n\\tfor index = 1, #list do\\n\\t\\tlocal min_index = index\\n\\t\\tfor min_candidate_index = index + 1, #list do\\n\\t\\t\\tif less_than(list[min_candidate_index], list[min_index]) then\\n\\t\\t\\t\\tmin_index = min_candidate_index\\n\\t\\t\\tend\\n\\t\\tend\\n\\t\\tlist[index], list[min_index] = list[min_index], list[index]\\n\\tend\\nend\\n\""
  }
}
