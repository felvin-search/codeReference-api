{
  "javascript": {
    "all combinations of size k": "\"/*\\n  Problem: Given two numbers, n and k, make all unique combinations of k numbers from 1 to n and in sorted order\\n\\n  What is combinations?\\n  - Combinations is selecting items from a collections without considering order of selection\\n\\n  Example:\\n  - We have an apple, a banana, and a jackfruit\\n  - We have three objects, and need to choose two items, then combinations will be\\n\\n  1. Apple & Banana\\n  2. Apple & Jackfruit\\n  3. Banana & Jackfruit\\n\\n  To read more about combinations, you can visit the following link:\\n  - https://betterexplained.com/articles/easy-permutations-and-combinations/\\n\\n  Solution:\\n  - We will be using backtracking to solve this questions\\n  - Take one element, and make all them combinations for k-1 elements\\n  - Once we get all combinations of that element, pop it and do same for next element\\n*/\\n\\nclass Combinations {\\n  constructor (n, k) {\\n    this.n = n\\n    this.k = k\\n    this.current = [] // will be used for storing current combination\\n    this.combinations = []\\n  }\\n\\n  findCombinations (high = this.n, total = this.k, low = 1) {\\n    if (total === 0) {\\n      this.combinations.push([...this.current])\\n      return this.combinations\\n    }\\n    for (let i = low; i <= high; i++) {\\n      this.current.push(i)\\n      this.findCombinations(high, total - 1, i + 1)\\n      this.current.pop()\\n    }\\n    return this.combinations\\n  }\\n}\\n\\nexport { Combinations }\\n\"",
    "generate permutations": "\"/*\\n * Problem Statement: Generate all distinct permutations of a an array (all permutations should be in sorted order);\\n *\\n * What is permutations?\\n * - Permutation means possible arrangements in a set (here it is an array);\\n *\\n * Reference to know more about permutations:\\n * - https://www.britannica.com/science/permutation\\n *\\n */\\n\\nconst swap = (arr, i, j) => {\\n  const newArray = [...arr];\\n\\n  [newArray[i], newArray[j]] = [newArray[j], newArray[i]] // Swapping elements ES6 way\\n\\n  return newArray\\n}\\n\\nconst permutations = arr => {\\n  const P = []\\n  const permute = (arr, low, high) => {\\n    if (low === high) {\\n      P.push([...arr])\\n      return P\\n    }\\n    for (let i = low; i <= high; i++) {\\n      arr = swap(arr, low, i)\\n      permute(arr, low + 1, high)\\n    }\\n    return P\\n  }\\n  return permute(arr, 0, arr.length - 1)\\n}\\n\\nexport { permutations }\\n\"",
    "knight tour": "\"// Wikipedia: https://en.wikipedia.org/wiki/Knight%27s_tour\\n\\nclass OpenKnightTour {\\n  constructor (size) {\\n    this.board = new Array(size).fill(0).map(() => new Array(size).fill(0))\\n    this.size = size\\n  }\\n\\n  getMoves ([i, j]) {\\n    // helper function to get the valid moves of the knight from the current position\\n    const moves = [\\n      [i + 2, j - 1],\\n      [i + 2, j + 1],\\n      [i - 2, j - 1],\\n      [i - 2, j + 1],\\n      [i + 1, j - 2],\\n      [i + 1, j + 2],\\n      [i - 1, j - 2],\\n      [i - 1, j + 2]\\n    ]\\n\\n    return moves.filter(([y, x]) => y >= 0 && y < this.size && x >= 0 && x < this.size)\\n  }\\n\\n  isComplete () {\\n    // helper function to check if the board is complete\\n    return !this.board.map(row => row.includes(0)).includes(true)\\n  }\\n\\n  solve () {\\n    // function to find the solution for the given board\\n    for (let i = 0; i < this.size; i++) {\\n      for (let j = 0; j < this.size; j++) {\\n        if (this.solveHelper([i, j], 0)) return true\\n      }\\n    }\\n    return false\\n  }\\n\\n  solveHelper ([i, j], curr) {\\n    // helper function for the main computation\\n    if (this.isComplete()) return true\\n\\n    for (const [y, x] of this.getMoves([i, j])) {\\n      if (this.board[y][x] === 0) {\\n        this.board[y][x] = curr + 1\\n        if (this.solveHelper([y, x], curr + 1)) return true\\n        // backtracking\\n        this.board[y][x] = 0\\n      }\\n    }\\n    return false\\n  }\\n\\n  printBoard (output = value => console.log(value)) {\\n    // utility function to display the board\\n    for (const row of this.board) {\\n      let string = ''\\n      for (const elem of row) {\\n        string += elem + '\\\\t'\\n      }\\n      output(string)\\n    }\\n  }\\n}\\n\\nexport { OpenKnightTour }\\n\"",
    "n queen": "\"class NQueen {\\n  constructor (size) {\\n    this.board = new Array(size).fill('.').map(() => new Array(size).fill('.'))\\n    this.size = size\\n    this.solutionCount = 0\\n  }\\n\\n  isValid ([row, col]) {\\n    // function to check if the placement of the queen in the given location is valid\\n\\n    // checking the left of the current row\\n    for (let i = 0; i < col; i++) {\\n      if (this.board[row][i] === 'Q') return false\\n    }\\n\\n    // checking the upper left diagonal\\n    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {\\n      if (this.board[i][j] === 'Q') return false\\n    }\\n\\n    // checking the lower left diagonal\\n    for (let i = row, j = col; j >= 0 && i < this.size; i++, j--) {\\n      if (this.board[i][j] === 'Q') return false\\n    }\\n\\n    return true\\n  }\\n\\n  placeQueen (row, col) {\\n    this.board[row][col] = 'Q'\\n  }\\n\\n  removeQueen (row, col) {\\n    this.board[row][col] = '.'\\n  }\\n\\n  solve (col = 0) {\\n    if (col >= this.size) {\\n      this.solutionCount++\\n      return true\\n    }\\n\\n    for (let i = 0; i < this.size; i++) {\\n      if (this.isValid([i, col])) {\\n        this.placeQueen(i, col)\\n        this.solve(col + 1)\\n        this.removeQueen(i, col)\\n      }\\n    }\\n\\n    return false\\n  }\\n\\n  printBoard (output = value => console.log(value)) {\\n    if (!output._isMockFunction) {\\n      output('\\\\n')\\n    }\\n    for (const row of this.board) {\\n      output(row)\\n    }\\n  }\\n}\\n\\nexport { NQueen }\\n\"",
    "rat in a maze": "\"/*\\n * Problem Statement:\\n * - Given a NxN grid, find whether rat in cell [0, 0] can reach the target in cell [N-1, N-1]\\n * - The grid is represented as an array of rows. Each row is represented as an array of 0 or 1 values.\\n * - A cell with value 0 can not be moved through. Value 1 means the rat can move here.\\n * - The rat can not move diagonally.\\n *\\n * Reference for this problem: https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/\\n *\\n * Based on the original implementation contributed by Chiranjeev Thapliyal (https://github.com/chiranjeev-thapliyal).\\n */\\n\\n/**\\n * Checks if the given grid is valid.\\n *\\n * A grid needs to satisfy these conditions:\\n * - must not be empty\\n * - must be a square\\n * - must not contain values other than {@code 0} and {@code 1}\\n *\\n * @param grid The grid to check.\\n * @throws TypeError When the given grid is invalid.\\n */\\nfunction validateGrid (grid) {\\n  if (!Array.isArray(grid) || grid.length === 0) throw new TypeError('Grid must be a non-empty array')\\n\\n  const allRowsHaveCorrectLength = grid.every(row => row.length === grid.length)\\n  if (!allRowsHaveCorrectLength) throw new TypeError('Grid must be a square')\\n\\n  const allCellsHaveValidValues = grid.every(row => {\\n    return row.every(cell => cell === 0 || cell === 1)\\n  })\\n  if (!allCellsHaveValidValues) throw new TypeError('Grid must only contain 0s and 1s')\\n}\\n\\nfunction isSafe (grid, x, y) {\\n  const n = grid.length\\n  return x >= 0 && x < n && y >= 0 && y < n && grid[y][x] === 1\\n}\\n\\n/**\\n * Attempts to calculate the remaining path to the target.\\n *\\n * @param grid The full grid.\\n * @param x The current X coordinate.\\n * @param y The current Y coordinate.\\n * @param solution The current solution matrix.\\n * @param path The path we took to get from the source cell to the current location.\\n * @returns {string|boolean} Either the path to the target cell or false.\\n */\\nfunction getPathPart (grid, x, y, solution, path) {\\n  const n = grid.length\\n\\n  // are we there yet?\\n  if (x === n - 1 && y === n - 1 && grid[y][x] === 1) {\\n    solution[y][x] = 1\\n    return path\\n  }\\n\\n  // did we step on a 0 cell or outside the grid?\\n  if (!isSafe(grid, x, y)) return false\\n\\n  // are we walking onto an already-marked solution coordinate?\\n  if (solution[y][x] === 1) return false\\n\\n  // none of the above? let's dig deeper!\\n\\n  // mark the current coordinates on the solution matrix\\n  solution[y][x] = 1\\n\\n  // attempt to move right\\n  const right = getPathPart(grid, x + 1, y, solution, path + 'R')\\n  if (right) return right\\n\\n  // right didn't work: attempt to move down\\n  const down = getPathPart(grid, x, y + 1, solution, path + 'D')\\n  if (down) return down\\n\\n  // down didn't work: attempt to move up\\n  const up = getPathPart(grid, x, y - 1, solution, path + 'U')\\n  if (up) return up\\n\\n  // up didn't work: attempt to move left\\n  const left = getPathPart(grid, x - 1, y, solution, path + 'L')\\n  if (left) return left\\n\\n  // no direction was successful: remove this cell from the solution matrix and backtrack\\n  solution[y][x] = 0\\n  return false\\n}\\n\\nfunction getPath (grid) {\\n  // grid dimensions\\n  const n = grid.length\\n\\n  // prepare solution matrix\\n  const solution = []\\n  for (let i = 0; i < n; i++) {\\n    const row = Array(n)\\n    row.fill(0)\\n    solution[i] = row\\n  }\\n\\n  return getPathPart(grid, 0, 0, solution, '')\\n}\\n\\n/**\\n * Creates an instance of the \\\"rat in a maze\\\" based on a given grid (maze).\\n */\\nexport class RatInAMaze {\\n  constructor (grid) {\\n    // first, let's do some error checking on the input\\n    validateGrid(grid)\\n\\n    // attempt to solve the maze now - all public methods only query the result state later\\n    const solution = getPath(grid)\\n\\n    if (solution !== false) {\\n      this.path = solution\\n      this.solved = true\\n    } else {\\n      this.path = ''\\n      this.solved = false\\n    }\\n  }\\n}\\n\"",
    "sudoku": "\"class Sudoku {\\n  // Sudoku Class to hold the board and related functions\\n  constructor (board) {\\n    this.board = board\\n  }\\n\\n  findEmptyCell () {\\n    // Find a empty cell in the board (returns [-1, -1] if all cells are filled)\\n    for (let i = 0; i < 9; i++) {\\n      for (let j = 0; j < 9; j++) {\\n        if (this.board[i][j] === 0) return [i, j]\\n      }\\n    }\\n    return [-1, -1]\\n  }\\n\\n  check ([y, x], value) {\\n    // checks if the value to be added in the board is an acceptable value for the cell\\n\\n    // checking through the row\\n    for (let i = 0; i < 9; i++) {\\n      if (this.board[i][x] === value) return false\\n    }\\n    // checking through the column\\n    for (let i = 0; i < 9; i++) {\\n      if (this.board[y][i] === value) return false\\n    }\\n\\n    // checking through the 3x3 block of the cell\\n    const secRow = Math.floor(y / 3)\\n    const secCol = Math.floor(x / 3)\\n    for (let i = (secRow * 3); i < ((secRow * 3) + 3); i++) {\\n      for (let j = (secCol * 3); j < ((secCol * 3) + 3); j++) {\\n        if (y !== i && x !== j && this.board[i][j] === value) return false\\n      }\\n    }\\n\\n    return true\\n  }\\n\\n  solve () {\\n    const [y, x] = this.findEmptyCell()\\n\\n    // checking if the board is complete\\n    if (y === -1 && x === -1) return true\\n\\n    for (let val = 1; val < 10; val++) {\\n      if (this.check([y, x], val)) {\\n        this.board[y][x] = val\\n        if (this.solve()) return true\\n        // backtracking if the board cannot be solved using current configuration\\n        this.board[y][x] = 0\\n      }\\n    }\\n    // returning false the board cannot be solved using current configuration\\n    return false\\n  }\\n\\n  getSection (row, [start, end]) {\\n    return this.board[row].slice(start, end)\\n  }\\n\\n  printBoard (output = (...v) => console.log(...v)) {\\n    // helper function to display board\\n    for (let i = 0; i < 9; i++) {\\n      if (i % 3 === 0 && i !== 0) {\\n        output('- - - - - - - - - - - -')\\n      }\\n      output(\\n        ...this.getSection(i, [0, 3]), ' | ',\\n        ...this.getSection(i, [3, 6]), ' | ',\\n        ...this.getSection(i, [6, 9]))\\n    }\\n  }\\n}\\n\\nexport { Sudoku }\\n\"",
    "sum of subset": "\"/*\\n *\\n *  Sum of Subset problem\\n *\\n *  Given an ordered set W of non-negative integers and a value K,\\n *  determine all possible subsets from the given set W whose sum\\n *  of its elements equals to the given value K.\\n *\\n *  More info: https://www.geeksforgeeks.org/subset-sum-backtracking-4/\\n */\\n\\n/*\\n * @param {number[]} set Original set of numbers\\n * @param {number[]} subset Subset being evaluated\\n * @param {number} setIndex Index from set of last element in subset\\n * @param {number} Sum of elements from subset\\n * @param {targetSum} The target sum on which the subset sum is compared to\\n * @returns {number[][]} Subsets whose elements add up to targetSum\\n */\\nconst sumOfSubset = (set, subset, setindex, sum, targetSum) => {\\n  // Base case where the subset sum is equal to target sum\\n  // Evaluation of following subsets on this path will always add up to\\n  // greater than targetSum, so no need to continue\\n  if (sum === targetSum) return [subset]\\n\\n  // This and following subsets on this path will always add up to\\n  // greater than targetSum, so no need to continue\\n  if (sum > targetSum) return []\\n\\n  // Initialize results array. Will contain only valid subsets\\n  let results = []\\n\\n  // Slice gets from the set all the elements at the right of the last element\\n  // to be evaluated (last element of subset)\\n  // forEach iterated on the resulting array\\n  set.slice(setindex).forEach((num, index) => {\\n    // The next subset to be evaluated, current subset plus next element\\n    const nextSubset = [...subset, num]\\n\\n    // Next index from the set. Current set index plus iteration index\\n    // index starts at 0, so a + 1 is required\\n    const nextSetIndex = setindex + index + 1\\n\\n    // Sum of elements from the next subset to be evaluated\\n    const nextSum = sum + num\\n\\n    // Call recursively the sumOfSubset for the nextSubset\\n    const subsetResult = sumOfSubset(\\n      set,\\n      nextSubset,\\n      nextSetIndex,\\n      nextSum,\\n      targetSum\\n    )\\n\\n    // Concat the recursive result with current result array\\n    results = [...results, ...subsetResult]\\n  })\\n\\n  // Return results\\n  return results\\n}\\n\\nexport { sumOfSubset }\\n\"",
    "binary count set bits": "\"/*\\n    author: vivek9patel\\n    license: GPL-3.0 or later\\n\\n    This script will find number of 1's\\n    in binary representation of given number\\n\\n*/\\n\\nfunction BinaryCountSetBits (a) {\\n  'use strict'\\n  // convert number into binary representation and return number of set bits in binary representation\\n  return a.toString(2).split('1').length - 1\\n}\\n\\nexport { BinaryCountSetBits }\\n\"",
    "is power of two": "\"/*\\n    author: @Aayushi-Mittal\\n\\n    This script will check whether the given\\n    number is a power of two or not.\\n\\n    A number will be a power of two if only one bit is set and rest are unset.\\n    This is true for all the cases except 01 because (2^0 = 1) which is not a power of 2.\\n    For eg: 10 (2^1 = 2), 100 (2^2 = 4), 10000 (2^4 = 16)\\n\\n    Reference Link: https://www.hackerearth.com/practice/notes/round-a-number-to-the-next-power-of-2/\\n\\n    If we will subtract 1 from a number that is a power of 2 we will get it's 1's complement.\\n    And we know that 1's complement is just opp. of that number.\\n    So, (n & (n-1)) will be 0.\\n\\n    For eg:    (1000 & (1000-1))\\n                1 0 0 0     // Original Number (8)\\n                0 1 1 1     // After Subtracting 1 (8-1 = 7)\\n                _______\\n                0 0 0 0     // will become 0\\n\\n*/\\n\\nexport const IsPowerOfTwo = (n) => {\\n  if (n > 0 && (n & (n - 1)) === 0) {\\n    return true\\n  }\\n  return false\\n}\\n\"",
    "next power of two": "\"/**\\n *\\n *  This script will find next power of two\\n *    of given number.\\n *  More about it:\\n *   https://www.techiedelight.com/round-next-highest-power-2/\\n *\\n */\\n\\nexport const nextPowerOfTwo = (n) => {\\n  if (n > 0 && (n & (n - 1)) === 0) return n\\n  let result = 1\\n  while (n > 0) {\\n    result = result << 1\\n    n = n >> 1\\n  }\\n  return result\\n}\\n\"",
    "set bit": "\"/*\\n * Setting Bit: https://www.geeksforgeeks.org/set-k-th-bit-given-number/\\n *\\n * To set any bit we use bitwise OR (|) operator.\\n *\\n * Bitwise OR (|) compares the bits of the 32\\n * bit binary representations of the number and\\n * returns a number after comparing each bit.\\n *\\n * 0 | 0 -> 0\\n * 0 | 1 -> 1\\n * 1 | 0 -> 1\\n * 1 | 1 -> 1\\n *\\n * In-order to set kth bit of a number (where k is the position where bit is to be changed)\\n * we need to shift 1 k times to its left and then perform bitwise OR operation with the\\n * number and result of left shift performed just before.\\n *\\n * References:\\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR\\n */\\n\\n/**\\n * @param {number} number\\n * @param {number} bitPosition - zero based.\\n * @return {number}\\n */\\n\\nexport const setBit = (number, bitPosition) => {\\n  return number | (1 << bitPosition)\\n}\\n\"",
    "l f u cache": "\"class DoubleLinkedListNode {\\n  // Double Linked List Node built specifically for LFU Cache\\n  constructor (key, val) {\\n    this.key = key\\n    this.val = val\\n    this.freq = 0\\n    this.next = null\\n    this.prev = null\\n  }\\n}\\n\\nclass DoubleLinkedList {\\n  // Double Linked List built specifically for LFU Cache\\n  constructor () {\\n    this.head = new DoubleLinkedListNode(null, null)\\n    this.rear = new DoubleLinkedListNode(null, null)\\n    this.head.next = this.rear\\n    this.rear.prev = this.head\\n  }\\n\\n  _positionNode (node) {\\n    // Helper function to position a node based on the frequency of the key\\n    while (node.prev.key && node.prev.freq > node.freq) {\\n      const node1 = node\\n      const node2 = node.prev\\n      node1.prev = node2.prev\\n      node2.next = node1.prev\\n      node1.next = node2\\n      node2.prev = node1\\n    }\\n  }\\n\\n  add (node) {\\n    // Adds the given node to the end of the list (before rear) and positions it based on frequency\\n    const temp = this.rear.prev\\n    temp.next = node\\n    node.prev = temp\\n    this.rear.prev = node\\n    node.next = this.rear\\n    this._positionNode(node)\\n  }\\n\\n  remove (node) {\\n    // Removes and returns the given node from the list\\n    const tempLast = node.prev\\n    const tempNext = node.next\\n    node.prev = null\\n    node.next = null\\n    tempLast.next = tempNext\\n    tempNext.prev = tempLast\\n\\n    return node\\n  }\\n}\\n\\nclass LFUCache {\\n  // LFU Cache to store a given capacity of data\\n  // The Double Linked List is used to store the order of deletion from the cache\\n  // The rear.prev holds the most frequently used key and the head.next holds the least used key\\n  // When the number of elements reaches the capacity, the least frequently used item is removed before adding the next key\\n  constructor (capacity) {\\n    this.list = new DoubleLinkedList()\\n    this.capacity = capacity\\n    this.numKeys = 0\\n    this.hits = 0\\n    this.miss = 0\\n    this.cache = {}\\n  }\\n\\n  cacheInfo () {\\n    // Return the details for the cache instance [hits, misses, capacity, current_size]\\n    return `CacheInfo(hits=${this.hits}, misses=${this.miss}, capacity=${this.capacity}, current size=${this.numKeys})`\\n  }\\n\\n  set (key, value) {\\n    // Sets the value for the input key and updates the Double Linked List\\n    if (!(key in this.cache)) {\\n      if (this.numKeys >= this.capacity) {\\n        const keyToDelete = this.list.head.next.key\\n        this.list.remove(this.cache[keyToDelete])\\n        delete this.cache[keyToDelete]\\n        this.numKeys -= 1\\n      }\\n      this.cache[key] = new DoubleLinkedListNode(key, value)\\n      this.list.add(this.cache[key])\\n      this.numKeys += 1\\n    } else {\\n      const node = this.list.remove(this.cache[key])\\n      node.val = value\\n      this.list.add(node)\\n    }\\n  }\\n\\n  get (key) {\\n    // Returns the value for the input key and updates the Double Linked List. Returns null if key is not present in cache\\n    if (key in this.cache) {\\n      this.hits += 1\\n      this.list.add(this.list.remove(this.cache[key]))\\n      return this.cache[key].val\\n    }\\n    this.miss += 1\\n    return null\\n  }\\n}\\n\\nexport { LFUCache }\\n\"",
    "l r u cache": "\"class LRUCache {\\n  // LRU Cache to store a given capacity of data\\n  constructor (capacity) {\\n    this.cache = new Map()\\n    this.capacity = capacity\\n    this.hits = 0\\n    this.miss = 0\\n  }\\n\\n  cacheInfo () {\\n    // Return the details for the cache instance [hits, misses, capacity, current_size]\\n    return `CacheInfo(hits=${this.hits}, misses=${this.miss}, capacity=${this.capacity}, current size=${this.cache.size})`\\n  }\\n\\n  set (key, value) {\\n    // Sets the value for the input key and if the key exists it updates the existing key\\n    if (this.cache.size === this.capacity) {\\n      // delete oldest key existing in map\\n      this.cache.delete(this.cache.keys().next().value)\\n    }\\n    this.cache.set(key, value)\\n  }\\n\\n  get (key) {\\n    // Returns the value for the input key. Returns null if key is not present in cache\\n    if (this.cache.has(key)) {\\n      const value = this.cache.get(key)\\n      // refresh the cache to update the order of key\\n      this.cache.delete(key)\\n      this.cache.set(key, value)\\n      this.hits += 1\\n      return value\\n    } else {\\n      this.miss += 1\\n      return null\\n    }\\n  }\\n}\\n\\nexport { LRUCache }\\n\"",
    "memoize": "\"/**\\n * Memoize\\n *\\n * From [Wikipedia](https://en.wikipedia.org/wiki/Memoization),\\n * memoization is an optimization technique\\n * used primarily to speed up computer programs,\\n * by storing the results of expensive function calls\\n * and returning the cached result when the same inputs occur again\\n *\\n * This function is a first class objects,\\n * which lets us use it as [Higher-Order Function](https://eloquentjavascript.net/05_higher_order.html)\\n * and return another function\\n *\\n * @param {Function} func Original function\\n * @returns {Function} Memoized function\\n */\\nexport const memoize = (func) => {\\n  // Initialization of a slot to store the function result\\n  const cache = {}\\n\\n  return (...args) => {\\n    // Retrieving the first argument of the function\\n    const [arg] = args\\n\\n    /**\\n     * Checks if the argument is already present in the cache,\\n     * then return the associated value / result\\n     */\\n    if (arg in cache) {\\n      return cache[arg]\\n    }\\n\\n    /**\\n     * If the argument is not yet present in the cache,\\n     * execute original function and save its value / result in cache,\\n     * finally return it\\n     */\\n    const result = func(arg)\\n    cache[arg] = result\\n    return result\\n  }\\n}\\n\"",
    "conways game of life": "\"/*\\nConway's Game of Life\\nThe Game of Life is a cellular automaton devised by the British mathematician John Horton Conway in 1970. The universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead, (or populated and unpopulated, respectively). Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:\\n  1. Any live cell with two or three live neighbours survives.\\n  2. Any dead cell with three live neighbours becomes a live cell.\\n  3. All other live cells die in the next generation. Similarly, all other dead cells stay dead.\\n(description adapted from https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life )\\n(example adapted from https://github.com/TheAlgorithms/Python/blob/master/cellular_automata/conways_game_of_life.py )\\n*/\\n\\n/**\\n * Generates the next generation for a given state of Conway's Game of Life.\\n */\\nexport function newGeneration (cells) {\\n  const nextGeneration = []\\n  for (let i = 0; i < cells.length; i++) {\\n    const nextGenerationRow = []\\n    for (let j = 0; j < cells[i].length; j++) {\\n      // Get the number of living neighbours\\n      let neighbourCount = 0\\n      if (i > 0 && j > 0) neighbourCount += cells[i - 1][j - 1]\\n      if (i > 0) neighbourCount += cells[i - 1][j]\\n      if (i > 0 && j < cells[i].length - 1) neighbourCount += cells[i - 1][j + 1]\\n      if (j > 0) neighbourCount += cells[i][j - 1]\\n      if (j < cells[i].length - 1) neighbourCount += cells[i][j + 1]\\n      if (i < cells.length - 1 && j > 0) neighbourCount += cells[i + 1][j - 1]\\n      if (i < cells.length - 1) neighbourCount += cells[i + 1][j]\\n      if (i < cells.length - 1 && j < cells[i].length - 1) neighbourCount += cells[i + 1][j + 1]\\n\\n      // Decide whether the cell is alive or dead\\n      const alive = cells[i][j] === 1\\n      if ((alive && neighbourCount >= 2 && neighbourCount <= 3) || (!alive && neighbourCount === 3)) {\\n        nextGenerationRow.push(1)\\n      } else {\\n        nextGenerationRow.push(0)\\n      }\\n    }\\n    nextGeneration.push(nextGenerationRow)\\n  }\\n  return nextGeneration\\n}\\n\"",
    "atbash": "\"/*\\nThe Atbash cipher is a particular type of monoalphabetic cipher\\nformed by taking the alphabet and mapping it to its reverse,\\nso that the first letter becomes the last letter,\\nthe second letter becomes the second to last letter, and so on.\\n*/\\n\\n/**\\n * Decrypt a Atbash cipher\\n * @param {String} str - string to be decrypted/encrypt\\n * @return {String} decrypted/encrypted string\\n */\\nfunction Atbash (message) {\\n  let decodedString = ''\\n  for (let i = 0; i < message.length; i++) {\\n    if (/[^a-zA-Z]/.test(message[i])) {\\n      decodedString += message[i]\\n    } else if (message[i] === message[i].toUpperCase()) {\\n      decodedString += String.fromCharCode(90 + 65 - message.charCodeAt(i))\\n    } else {\\n      decodedString += String.fromCharCode(122 + 97 - message.charCodeAt(i))\\n    }\\n  }\\n  return decodedString\\n}\\n\\nexport { Atbash }\\n\\n// > Atbash('HELLO WORLD')\\n// 'SVOOL DLIOW'\\n\"",
    "caesars cipher": "\"/**\\n * Caesar's Cipher - also known as the ROT13 Cipher is when\\n * a letter is replaced by the one that is 13 spaces away\\n * from it in the alphabet. If the letter is in the first half\\n * of the alphabet we add 13, if it's in the latter half we\\n * subtract 13 from the character code value.\\n */\\n\\n/**\\n * Decrypt a ROT13 cipher\\n * @param {String} str - string to be decrypted\\n * @return {String} decrypted string\\n */\\nfunction rot13 (str) {\\n  const response = []\\n  const strLength = str.length\\n\\n  for (let i = 0; i < strLength; i++) {\\n    const char = str.charCodeAt(i)\\n\\n    if (char < 65 || (char > 90 && char < 97) || char > 122) {\\n      response.push(str.charAt(i))\\n    } else if ((char > 77 && char <= 90) || (char > 109 && char <= 122)) {\\n      response.push(String.fromCharCode(str.charCodeAt(i) - 13))\\n    } else {\\n      response.push(String.fromCharCode(str.charCodeAt(i) + 13))\\n    }\\n  }\\n  return response.join('')\\n}\\n\\nexport { rot13 }\\n\\n// > rot13('Uryyb Jbeyq')\\n// 'Hello World'\\n\"",
    "key finder": "\"/******************************************************\\n Find and retrieve the encryption key automatically\\n Note: This is a draft version, please help to modify, Thanks!\\n ******************************************************/\\nfunction keyFinder (str) { // str is used to get the input of encrypted string\\n  const wordBank = [\\n    'I ',\\n    'You ',\\n    'We ',\\n    'They ',\\n    'He ',\\n    'She ',\\n    'It ',\\n    ' the ',\\n    'The ',\\n    ' of ',\\n    ' is ',\\n    'Is ',\\n    ' am ',\\n    'Am ',\\n    ' are ',\\n    'Are ',\\n    ' have ',\\n    'Have ',\\n    ' has ',\\n    'Has ',\\n    ' may ',\\n    'May ',\\n    ' be ',\\n    'Be ']\\n  // let wordbankelementCounter = 0;\\n  // let key = 0; // return zero means the key can not be found\\n  const inStr = str.toString() // convert the input to String\\n  let outStr = '' // store the output value\\n  let outStrElement = '' // temporary store the word inside the outStr, it is used for comparison\\n  for (let k = 0; k < 26; k++) { // try the number of key shifted, the sum of character from a-z or A-Z is 26\\n    outStr = caesarCipherEncodeAndDecodeEngine(inStr, k) // use the encryption engine to decrypt the input string\\n\\n    // loop through the whole input string\\n    for (let s = 0; s < outStr.length; s++) {\\n      for (let i = 0; i < wordBank.length; i++) {\\n        // initialize the outStrElement which is a temp output string for comparison,\\n        // use a loop to find the next digit of wordBank element and compare with outStr's digit\\n        for (let w = 0; w < wordBank[i].length; w++) {\\n          outStrElement += outStr[s + w]\\n        }\\n        // this part need to be optimize with the calculation of the number of occurrence of word's probabilities\\n        // linked list will be used in the next stage of development to calculate the number of occurrence of the key\\n        if (wordBank[i] === outStrElement) {\\n          return k // return the key number if founded\\n        }\\n        outStrElement = '' // reset the temp word\\n      } // end for ( let i=0; i < wordBank.length; i++)\\n    }\\n  }\\n  return 0 // return 0 if found nothing\\n}\\n\\n/* this sub-function is used to assist the keyFinder to find the key */\\nfunction caesarCipherEncodeAndDecodeEngine (inStr, numShifted) {\\n  const shiftNum = numShifted\\n  let charCode = 0\\n  let outStr = ''\\n  let shiftedCharCode = 0\\n  let result = 0\\n\\n  for (let i = 0; i < inStr.length; i++) {\\n    charCode = inStr[i].charCodeAt()\\n    shiftedCharCode = charCode + shiftNum\\n    result = charCode\\n\\n    if ((charCode >= 48 && charCode <= 57)) {\\n      if (shiftedCharCode < 48) {\\n        let diff = Math.abs(48 - 1 - shiftedCharCode) % 10\\n\\n        while (diff >= 10) {\\n          diff = diff % 10\\n        }\\n        document.getElementById('diffID').innerHTML = diff\\n\\n        shiftedCharCode = 57 - diff\\n\\n        result = shiftedCharCode\\n      } else if (shiftedCharCode >= 48 && shiftedCharCode <= 57) {\\n        result = shiftedCharCode\\n      } else if (shiftedCharCode > 57) {\\n        let diff = Math.abs(57 + 1 - shiftedCharCode) % 10\\n\\n        while (diff >= 10) {\\n          diff = diff % 10\\n        }\\n        document.getElementById('diffID').innerHTML = diff\\n\\n        shiftedCharCode = 48 + diff\\n\\n        result = shiftedCharCode\\n      }\\n    } else if ((charCode >= 65 && charCode <= 90)) {\\n      if (shiftedCharCode <= 64) {\\n        let diff = Math.abs(65 - 1 - shiftedCharCode) % 26\\n\\n        while ((diff % 26) >= 26) {\\n          diff = diff % 26\\n        }\\n        shiftedCharCode = 90 - diff\\n        result = shiftedCharCode\\n      } else if (shiftedCharCode >= 65 && shiftedCharCode <= 90) {\\n        result = shiftedCharCode\\n      } else if (shiftedCharCode > 90) {\\n        let diff = Math.abs(shiftedCharCode - 1 - 90) % 26\\n\\n        while ((diff % 26) >= 26) {\\n          diff = diff % 26\\n        }\\n        shiftedCharCode = 65 + diff\\n        result = shiftedCharCode\\n      }\\n    } else if ((charCode >= 97 && charCode <= 122)) {\\n      if (shiftedCharCode <= 96) {\\n        let diff = Math.abs(97 - 1 - shiftedCharCode) % 26\\n\\n        while ((diff % 26) >= 26) {\\n          diff = diff % 26\\n        }\\n        shiftedCharCode = 122 - diff\\n        result = shiftedCharCode\\n      } else if (shiftedCharCode >= 97 && shiftedCharCode <= 122) {\\n        result = shiftedCharCode\\n      } else if (shiftedCharCode > 122) {\\n        let diff = Math.abs(shiftedCharCode - 1 - 122) % 26\\n\\n        while ((diff % 26) >= 26) {\\n          diff = diff % 26\\n        }\\n        shiftedCharCode = 97 + diff\\n        result = shiftedCharCode\\n      }\\n    }\\n    outStr = outStr + String.fromCharCode(parseInt(result))\\n  }\\n  return outStr\\n}\\n\\nexport { keyFinder }\\n\\n// > keyFinder('test')\\n// 0\\n\"",
    "keyword shifted alphabet": "\"/**\\n * Keyword shifted alphabet is a simple cipher using a translation table created with a help of a keyword.\\n * Keyword must be a word where each character can occur only once.\\n * To create the translation table, we write all the alphabet characters to the first.\\n * Second row start with the keyword, then we continue with the rest of the characters that are missing in alphabetical order.\\n *\\n * |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|\\n * |K|E|Y|W|O|R|D|A|B|C|F|G|H|I|J|L|M|N|P|Q|S|T|U|V|W|Z|\\n *\\n * Encryption is then just a matter of writing the matching (same index) letter from the second row instead of the first row:\\n * 'Hello world' -> 'Aoggj ujngw'\\n *\\n * Decryption is then just the reverse process of writing the matching (same index) letter from the first row instead of the second row\\n * 'Aogg ujngw' -> 'Hello world'\\n *\\n * Non alphabetical characters (space, exclamation mark, ...) are kept as they are\\n */\\n\\nconst alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\\n\\nfunction checkKeywordValidity (keyword) {\\n  keyword.split('').forEach((char, index) => {\\n    const rest = keyword.slice(0, index) + keyword.slice(index + 1)\\n    if (rest.indexOf(char) !== -1) {\\n      return false\\n    }\\n  })\\n  return true\\n}\\n\\nfunction getEncryptedAlphabet (keyword) {\\n  const encryptedAlphabet = keyword.split('')\\n  alphabet.forEach((char) => {\\n    if (encryptedAlphabet.indexOf(char) === -1) {\\n      encryptedAlphabet.push(char)\\n    }\\n  })\\n  return encryptedAlphabet\\n}\\n\\nfunction translate (sourceAlphabet, targetAlphabet, message) {\\n  return message.split('').reduce((encryptedMessage, char) => {\\n    const isUpperCase = char === char.toUpperCase()\\n    const encryptedCharIndex = sourceAlphabet.indexOf(char.toLowerCase())\\n    const encryptedChar = encryptedCharIndex !== -1 ? targetAlphabet[encryptedCharIndex] : char\\n    encryptedMessage += isUpperCase ? encryptedChar.toUpperCase() : encryptedChar\\n    return encryptedMessage\\n  }, '')\\n}\\n\\nfunction checkInputs (keyword, message) {\\n  if (!keyword || !message) {\\n    throw new Error('Both keyword and message must be specified')\\n  }\\n\\n  if (!checkKeywordValidity(keyword)) {\\n    throw new Error('Invalid keyword!')\\n  }\\n}\\n\\nfunction encrypt (keyword, message) {\\n  checkInputs(keyword, message)\\n  return translate(alphabet, getEncryptedAlphabet(keyword.toLowerCase()), message)\\n}\\n\\nfunction decrypt (keyword, message) {\\n  checkInputs(keyword, message)\\n  return translate(getEncryptedAlphabet(keyword.toLowerCase()), alphabet, message)\\n}\\n\\nexport { encrypt, decrypt }\\n\\n// encrypt('keyword', 'Hello world!') // Prints 'Aoggj ujngw!'\\n// decrypt('keyword', 'Aoggj ujngw!') // Prints 'Hello world!\\n\"",
    "r o t13": "\"/**\\n * Transcipher a ROT13 cipher\\n * @param  {String} text - string to be encrypted\\n * @return {String} - decrypted string\\n */\\nconst ROT13 = (text) => {\\n  const originalCharacterList = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\\n  const toBeMappedCharaterList = 'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'\\n  const index = x => originalCharacterList.indexOf(x)\\n  const replace = x => index(x) > -1 ? toBeMappedCharaterList[index(x)] : x\\n  return text.split('').map(replace).join('')\\n}\\n\\nexport { ROT13 }\\n\\n// > ROT13('The quick brown fox jumps over the lazy dog')\\n// 'Gur dhvpx oebja sbk whzcf bire gur ynml qbt'\\n\"",
    "vigenere cipher": "\"/**\\n * Check if the Character is letter or not\\n * @param {String} str - character to check\\n * @return {object} An array with the character or null if isn't a letter\\n */\\nfunction isLetter (str) {\\n  return str.length === 1 && str.match(/[a-zA-Z]/i)\\n}\\n\\n/**\\n * Check if is Uppercase or Lowercase\\n * @param {String} character - character to check\\n * @return {Boolean} result of the checking\\n */\\nfunction isUpperCase (character) {\\n  if (character === character.toUpperCase()) {\\n    return true\\n  }\\n  if (character === character.toLowerCase()) {\\n    return false\\n  }\\n}\\n\\n/**\\n * Encrypt a Vigenere cipher\\n * @param {String} message - string to be encrypted\\n * @param {String} key - key for encrypt\\n * @return {String} result - encrypted string\\n */\\nfunction encrypt (message, key) {\\n  let result = ''\\n\\n  for (let i = 0, j = 0; i < message.length; i++) {\\n    const c = message.charAt(i)\\n    if (isLetter(c)) {\\n      if (isUpperCase(c)) {\\n        result += String.fromCharCode((c.charCodeAt(0) + key.toUpperCase().charCodeAt(j) - 2 * 65) % 26 + 65) // A: 65\\n      } else {\\n        result += String.fromCharCode((c.charCodeAt(0) + key.toLowerCase().charCodeAt(j) - 2 * 97) % 26 + 97) // a: 97\\n      }\\n    } else {\\n      result += c\\n    }\\n    j = ++j % key.length\\n  }\\n  return result\\n}\\n\\n/**\\n * Decrypt a Vigenere cipher\\n * @param {String} message - string to be decrypted\\n * @param {String} key - key for decrypt\\n * @return {String} result - decrypted string\\n */\\nfunction decrypt (message, key) {\\n  let result = ''\\n\\n  for (let i = 0, j = 0; i < message.length; i++) {\\n    const c = message.charAt(i)\\n    if (isLetter(c)) {\\n      if (isUpperCase(c)) {\\n        result += String.fromCharCode(90 - (25 - (c.charCodeAt(0) - key.toUpperCase().charCodeAt(j))) % 26)\\n      } else {\\n        result += String.fromCharCode(122 - (25 - (c.charCodeAt(0) - key.toLowerCase().charCodeAt(j))) % 26)\\n      }\\n    } else {\\n      result += c\\n    }\\n    j = ++j % key.length\\n  }\\n  return result\\n}\\n\\nexport { encrypt, decrypt }\\n\\n// > encrypt('Hello World!', 'code')\\n// 'Jsopq Zstzg!'\\n\\n// > decrypt('Jsopq Zstzg!', 'code')\\n// 'Hello World!'\\n\"",
    "x o r cipher": "\"/**\\n * The XOR cipher is a type of additive cipher.\\n * Each character is bitwise XORed with the key.\\n * We loop through the input string, XORing each\\n * character with the key.\\n */\\n\\n/**\\n * Encrypt using an XOR cipher\\n * @param {String} str - String to be encrypted\\n * @param {Number} key - key for encryption\\n * @return {String} encrypted string\\n */\\n\\nfunction XOR (str, key) {\\n  let result = ''\\n  for (const elem of str) {\\n    result += String.fromCharCode(elem.charCodeAt(0) ^ key)\\n  }\\n  return result\\n}\\n\\nexport { XOR }\\n\\n// Nb: Node REPL might not output the null char '\\\\x00' (charcode 0)\\n\\n// > XOR('test string', 32)\\n// 'TEST\\\\x00STRING'\\n\\n// > XOR('TEST\\\\x00STRING', 32)\\n// 'test string'\\n\"",
    "arbitrary base": "\"/**\\n* Converts a string from one base to other\\n* @param {string} stringInBaseOne String in input base\\n* @param {string} baseOneCharacters Character set for the input base\\n* @param {string} baseTwoCharacters Character set for the output base\\n* @returns {string}\\n*/\\nconst convertArbitraryBase = (stringInBaseOne, baseOneCharacters, baseTwoCharacters) => {\\n  if ([stringInBaseOne, baseOneCharacters, baseTwoCharacters].map(arg => typeof arg).some(type => type !== 'string')) {\\n    throw new TypeError('Only string arguments are allowed')\\n  }\\n  [baseOneCharacters, baseTwoCharacters].forEach(baseString => {\\n    const charactersInBase = [...baseString]\\n    if (charactersInBase.length !== new Set(charactersInBase).size) {\\n      throw new TypeError('Duplicate characters in character set are not allowed')\\n    }\\n  })\\n  const reversedStringOneChars = [...stringInBaseOne].reverse()\\n  const stringOneBase = baseOneCharacters.length\\n  let value = 0\\n  let placeValue = 1\\n  for (const digit of reversedStringOneChars) {\\n    const digitNumber = baseOneCharacters.indexOf(digit)\\n    if (digitNumber === -1) {\\n      throw new TypeError(`Not a valid character: ${digit}`)\\n    }\\n    value += (digitNumber * placeValue)\\n    placeValue *= stringOneBase\\n  }\\n  let stringInBaseTwo = ''\\n  const stringTwoBase = baseTwoCharacters.length\\n  while (value > 0) {\\n    const remainder = value % stringTwoBase\\n    stringInBaseTwo = baseTwoCharacters.charAt(remainder) + stringInBaseTwo\\n    value /= stringTwoBase\\n  }\\n  const baseTwoZero = baseTwoCharacters.charAt(0)\\n  return stringInBaseTwo.replace(new RegExp(`^${baseTwoZero}+`), '')\\n}\\n\\nexport { convertArbitraryBase }\\n\\n// > convertArbitraryBase('98', '0123456789', '01234567')\\n// '142'\\n\\n// > convertArbitraryBase('98', '0123456789', 'abcdefgh')\\n// 'bec'\\n\\n// > convertArbitraryBase('129', '0123456789', '01234567')\\n// '201'\\n\"",
    "array buffer to base64": "\"// About base64: https://en.wikipedia.org/wiki/Base64\\n\\n/**\\n * Converts an array of bytes to base64 encoding\\n * @param {ArrayBuffer} binaryData An ArrayBuffer which represents an array of bytes\\n * @returns {string} A string containing the base64 encoding of `binaryData`\\n */\\nfunction bufferToBase64 (binaryData) {\\n  // The base64 encoding uses the following set of characters to encode any binary data as text\\n  const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\n  // Every 3 bytes translates to 4 base64 characters, if we have less than 3 bytes we must append '=' chars as padding\\n  const padding = 3 - (binaryData.byteLength % 3)\\n  // Create an instance of Uint8Array, to read from the binaryData array buffer\\n  const byteView = new Uint8Array(binaryData)\\n  let result = ''\\n\\n  // Loop through all bytes in the buffer, in increments of 3 bytes\\n  for (let i = 0; i < byteView.byteLength; i += 3) {\\n    // Get the index for the next 4 base64 chars\\n    const char1 = (byteView[i] & 252) >> 2\\n    const char2 = ((byteView[i] & 3) << 4) + ((byteView[i + 1] & 240) >> 4)\\n    const char3 = ((byteView[i + 1] & 15) << 2) + ((byteView[i + 2] & 192) >> 6)\\n    const char4 = byteView[i + 2] & 63\\n\\n    result +=\\n        base64Table[char1] +\\n        base64Table[char2] +\\n        base64Table[char3] +\\n        base64Table[char4]\\n  }\\n\\n  // Add padding '=' chars if needed\\n  if (padding !== 3) {\\n    const paddedResult = result.slice(0, result.length - padding) + '='.repeat(padding)\\n    return paddedResult\\n  }\\n\\n  return result\\n}\\n\\nexport { bufferToBase64 }\\n\"",
    "base64 to array buffer": "\"// About base64: https://en.wikipedia.org/wiki/Base64\\n\\n/**\\n * Converts a base64 string to an array of bytes\\n * @param {string} b64 A base64 string\\n * @returns {ArrayBuffer} An ArrayBuffer representing the bytes encoded by the base64 string\\n */\\nfunction base64ToBuffer (b64) {\\n  // The base64 encoding uses the following set of characters to encode any binary data as text\\n  const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\n  // Find the index of char '=' first occurrence\\n  const paddingIdx = b64.indexOf('=')\\n  // Remove padding chars from base64 string, if there are any\\n  const b64NoPadding = paddingIdx !== -1 ? b64.slice(0, paddingIdx) : b64\\n  // Calculate the length of the result buffer\\n  const bufferLength = Math.floor((b64NoPadding.length * 6) / 8)\\n  // Create the result buffer\\n  const result = new ArrayBuffer(bufferLength)\\n  // Create an instance of Uint8Array, to write to the `result` buffer\\n  const byteView = new Uint8Array(result)\\n\\n  // Loop through all chars in the base64 string, in increments of 4 chars, and in increments of 3 bytes\\n  for (let i = 0, j = 0; i < b64NoPadding.length; i += 4, j += 3) {\\n    // Get the index of the next 4 base64 chars\\n    const b64Char1 = base64Table.indexOf(b64NoPadding[i])\\n    const b64Char2 = base64Table.indexOf(b64NoPadding[i + 1])\\n    let b64Char3 = base64Table.indexOf(b64NoPadding[i + 2])\\n    let b64Char4 = base64Table.indexOf(b64NoPadding[i + 3])\\n\\n    // If base64 chars 3 and 4 don't exit, then set them to 0\\n    if (b64Char3 === -1) b64Char3 = 0\\n    if (b64Char4 === -1) b64Char4 = 0\\n\\n    // Calculate the next 3 bytes\\n    const byte1 = (b64Char1 << 2) + ((b64Char2 & 48) >> 4)\\n    const byte2 = ((b64Char2 & 15) << 4) + ((b64Char3 & 60) >> 2)\\n    const byte3 = ((b64Char3 & 3) << 6) + b64Char4\\n\\n    byteView[j] = byte1\\n    byteView[j + 1] = byte2\\n    byteView[j + 2] = byte3\\n  }\\n\\n  return result\\n}\\n\\nexport { base64ToBuffer }\\n\"",
    "binary to decimal": "\"export default function binaryToDecimal (binaryString) {\\n  let decimalNumber = 0\\n  const binaryDigits = binaryString.split('').reverse() // Splits the binary number into reversed single digits\\n  binaryDigits.forEach((binaryDigit, index) => {\\n    decimalNumber += binaryDigit * (Math.pow(2, index)) // Summation of all the decimal converted digits\\n  })\\n  return decimalNumber\\n}\\n\"",
    "binary to hex": "\"const pad = (num, padlen) => {\\n  const pad = new Array(1 + padlen).join(0)\\n  return (pad + num).slice(-pad.length)\\n}\\n\\nconst hexLookup = (bin) => {\\n  let binary = bin\\n  if (binary.length < 4) {\\n    binary = pad(binary, 4)\\n  }\\n  switch (binary) {\\n    case '0000': return '0'\\n    case '0001': return '1'\\n    case '0010': return '2'\\n    case '0011': return '3'\\n    case '0100': return '4'\\n    case '0101': return '5'\\n    case '0110': return '6'\\n    case '0111': return '7'\\n    case '1000': return '8'\\n    case '1001': return '9'\\n    case '1010': return 'A'\\n    case '1011': return 'B'\\n    case '1100': return 'C'\\n    case '1101': return 'D'\\n    case '1110': return 'E'\\n    case '1111': return 'F'\\n  }\\n}\\nconst binaryToHex = (binaryString) => {\\n  /*\\n  Function for convertung Binary to Hex\\n\\n  1. The conversion will start from Least Significant Digit (LSB) to the Most Significant Bit (MSB).\\n  2. We divide the bits into sections of 4-bits starting from LSB to MSB.\\n  3. If the MSB get less than 4 bits, then we pad 0s to the front of it.\\n\\n  For Example:\\n  Binary String = '1001101'\\n\\n  1. Divide it to 2 parts => ['100', '1101']\\n  2. Pad 0s the MSB so it'll be => ['0100', '1101']\\n  3. Use the lookup table and merge them, therefore the result is 4D.\\n\\n  */\\n\\n  let result = ''\\n  binaryString = binaryString.split('')\\n  for (let i = binaryString.length - 1; i >= 0; i = i - 4) {\\n    if (i >= 3) {\\n      result += hexLookup(binaryString.slice(i - 3, i + 1).join(''))\\n    } else {\\n      result += hexLookup(binaryString.slice(0, i + 1).join(''))\\n    }\\n  }\\n  return result.split('').reverse().join('')\\n}\\n\\nexport default binaryToHex\\n\"",
    "date day difference": "\"/*\\n    DateDayDifference Method\\n    ------------------------\\n    DateDayDifference method calculates the number of days between two dates.\\n\\n    Algorithm & Explanation : https://ncalculators.com/time-date/date-difference-calculator.htm\\n*/\\n\\n// Internal method for make calculations easier\\nconst isLeap = (year) => {\\n  if (year % 400 === 0) return true\\n  else if (year % 100 === 0) return false\\n  else if (year % 4 === 0) return true\\n  else return false\\n}\\nconst DateToDay = (dd, mm, yyyy) => {\\n  return Math.floor((365 * (yyyy - 1)) + ((yyyy - 1) / 4) - ((yyyy - 1) / 100) + ((yyyy - 1) / 400) + dd + (((367 * mm) - 362) / 12) + (mm <= 2 ? 0 : isLeap(yyyy) ? -1 : -2))\\n}\\n\\nconst DateDayDifference = (date1, date2) => {\\n  // firstly, check that both input are string or not.\\n  if (typeof date1 !== 'string' && typeof date2 !== 'string') {\\n    return new TypeError('Argument is not a string.')\\n  }\\n  // extract the first date\\n  const [firstDateDay, firstDateMonth, firstDateYear] = date1.split('/').map((ele) => Number(ele))\\n  // extract the second date\\n  const [secondDateDay, secondDateMonth, secondDateYear] = date2.split('/').map((ele) => Number(ele))\\n  // check the both data are valid or not.\\n  if (firstDateDay < 0 || firstDateDay > 31 ||\\n        firstDateMonth > 12 || firstDateMonth < 0 ||\\n        secondDateDay < 0 || secondDateDay > 31 ||\\n        secondDateMonth > 12 || secondDateMonth < 0) {\\n    return new TypeError('Date is not valid.')\\n  }\\n  return Math.abs(DateToDay(secondDateDay, secondDateMonth, secondDateYear) - DateToDay(firstDateDay, firstDateMonth, firstDateYear))\\n}\\n\\n// Example : DateDayDifference('17/08/2002', '10/10/2020') => 6630\\n\\nexport { DateDayDifference }\\n\"",
    "date to day": "\"/*\\n                    DateToDay Method\\n                    ----------------\\n    The DateToDay method takes a date in string format and\\n    returns the name of a day. The approach behind this method\\n    is very simple, we first take a string date and check\\n    whether their date is valid or not, if the date is valid\\n    then we do this But apply the algorithm shown below. The\\n    algorithm shown below gives us the number of the day and\\n    finally converts it to the name of the day.\\n\\n    Algorithm & Explanation : https://cs.uwaterloo.ca/~alopez-o/math-faq/node73.html\\n*/\\n\\n// March is taken as the first month of the year.\\nconst calcMonthList = {\\n  1: 11,\\n  2: 12,\\n  3: 1,\\n  4: 2,\\n  5: 3,\\n  6: 4,\\n  7: 5,\\n  8: 6,\\n  9: 7,\\n  10: 8,\\n  11: 9,\\n  12: 10\\n}\\n\\n// show the week day in a number : Sunday - Saturday => 0 - 6\\nconst daysNameList = { // weeks-day\\n  0: 'Sunday',\\n  1: 'Monday',\\n  2: 'Tuesday',\\n  3: 'Wednesday',\\n  4: 'Thursday',\\n  5: 'Friday',\\n  6: 'Saturday'\\n}\\n\\nconst DateToDay = (date) => {\\n  // firstly, check that input is a string or not.\\n  if (typeof date !== 'string') {\\n    return new TypeError('Argument is not a string.')\\n  }\\n  // extract the date\\n  const [day, month, year] = date.split('/').map((x) => Number(x))\\n  // check the data are valid or not.\\n  if (day < 0 || day > 31 || month > 12 || month < 0) {\\n    return new TypeError('Date is not valid.')\\n  }\\n  // divide year to century and yearDigit value.\\n  const yearDigit = (year % 100)\\n  const century = Math.floor(year / 100)\\n  // Apply the algorithm shown above\\n  const weekDay = Math.abs((day + Math.floor((2.6 * calcMonthList[month]) - 0.2) - (2 * century) + yearDigit + Math.floor(yearDigit / 4) + Math.floor(century / 4)) % 7)\\n  // return the weekDay name.\\n  return daysNameList[weekDay]\\n}\\n\\n// Example : DateToDay(\\\"18/12/2020\\\") => Friday\\n\\nexport { DateToDay }\\n\"",
    "decimal to binary": "\"function decimalToBinary (num) {\\n  const bin = []\\n  while (num > 0) {\\n    bin.unshift(num % 2)\\n    num >>= 1 // basically /= 2 without remainder if any\\n  }\\n  return bin.join('')\\n}\\n\\nexport { decimalToBinary }\\n\\n// > decimalToBinary(2)\\n// '10'\\n\\n// > decimalToBinary(7)\\n// '111'\\n\\n// > decimalToBinary(35)\\n// '100011'\\n\"",
    "decimal to hex": "\"function intToHex (num) {\\n  switch (num) {\\n    case 10: return 'A'\\n    case 11: return 'B'\\n    case 12: return 'C'\\n    case 13: return 'D'\\n    case 14: return 'E'\\n    case 15: return 'F'\\n  }\\n  return num\\n}\\n\\nfunction decimalToHex (num) {\\n  const hexOut = []\\n  while (num > 15) {\\n    hexOut.unshift(intToHex(num % 16))\\n    num = Math.floor(num / 16)\\n  }\\n  return intToHex(num) + hexOut.join('')\\n}\\n\\nexport { decimalToHex }\\n\"",
    "decimal to octal": "\"function decimalToOctal (num) {\\n  let oct = 0\\n  let c = 0\\n  while (num > 0) {\\n    const r = num % 8\\n    oct = oct + (r * Math.pow(10, c++))\\n    num = Math.floor(num / 8) // basically /= 8 without remainder if any\\n  }\\n  return oct\\n}\\n\\nexport { decimalToOctal }\\n\\n// > decimalToOctal(2)\\n// 2\\n\\n// > decimalToOctal(8)\\n// 10\\n\\n// > decimalToOctal(65)\\n// 101\\n\\n// > decimalToOctal(216)\\n// 330\\n\\n// > decimalToOctal(512)\\n// 1000\\n\"",
    "decimal to roman": "\"/*\\n    Decimal To Roman\\n\\n    This algorithm take decimal number and convert to roman numeral according to standard form (https://en.wikipedia.org/wiki/Roman_numerals#Description)\\n\\n    Algorithm & Explanation : https://www.rapidtables.com/convert/number/how-number-to-roman-numerals.html\\n*/\\n\\nconst values = {\\n  M: 1000,\\n  CM: 900,\\n  D: 500,\\n  CD: 400,\\n  C: 100,\\n  XC: 90,\\n  L: 50,\\n  XL: 40,\\n  X: 10,\\n  IX: 9,\\n  V: 5,\\n  IV: 4,\\n  I: 1\\n}\\n\\nconst orders = [\\n  'M',\\n  'CM',\\n  'D',\\n  'CD',\\n  'C',\\n  'XC',\\n  'L',\\n  'XL',\\n  'X',\\n  'IX',\\n  'V',\\n  'IV',\\n  'I'\\n]\\n\\nfunction decimalToRoman (num) {\\n  let roman = ''\\n  for (const symbol of orders) {\\n    while (num >= values[symbol]) {\\n      roman += symbol\\n      num -= values[symbol]\\n    }\\n  }\\n  return roman\\n}\\n\\nexport { decimalToRoman }\\n\"",
    "hex to binary": "\"const binLookup = (c) => {\\n  switch (c.toLowerCase()) {\\n    case '0': return '0000'\\n    case '1': return '0001'\\n    case '2': return '0010'\\n    case '3': return '0011'\\n    case '4': return '0100'\\n    case '5': return '0101'\\n    case '6': return '0110'\\n    case '7': return '0111'\\n    case '8': return '1000'\\n    case '9': return '1001'\\n    case 'a': return '1010'\\n    case 'b': return '1011'\\n    case 'c': return '1100'\\n    case 'd': return '1101'\\n    case 'e': return '1110'\\n    case 'f': return '1111'\\n    default: return ''\\n  }\\n}\\nconst hexToBinary = (hexString) => {\\n  /*\\n    Function for converting Hex to Binary\\n\\n    1. We convert every hexadecimal bit to 4 binary bits\\n    2. Conversion goes by searching in the lookup table\\n\\n    */\\n  const hexLexemes = hexString.split('')\\n  return hexLexemes.map(lexeme => binLookup(lexeme)).join('')\\n}\\n\\nexport default hexToBinary\\n\"",
    "hex to decimal": "\"function hexToInt (hexNum) {\\n  const numArr = hexNum.split('') // converts number to array\\n  return numArr.map((item, index) => {\\n    switch (item) {\\n      case 'A': return 10\\n      case 'B': return 11\\n      case 'C': return 12\\n      case 'D': return 13\\n      case 'E': return 14\\n      case 'F': return 15\\n      default: return parseInt(item)\\n    }\\n  })\\n}\\n\\nfunction hexToDecimal (hexNum) {\\n  const intItemsArr = hexToInt(hexNum)\\n  return intItemsArr.reduce((accumulator, current, index) => {\\n    return accumulator + (current * Math.pow(16, (intItemsArr.length - (1 + index))))\\n  }, 0)\\n}\\n\\nexport { hexToInt, hexToDecimal }\\n\"",
    "hex to r g b": "\"function hexStringToRGB (hexString) {\\n  let r = hexString.substring(0, 2)\\n  let g = hexString.substring(2, 4)\\n  let b = hexString.substring(4, 6)\\n\\n  r = parseInt(r, 16)\\n  g = parseInt(g, 16)\\n  b = parseInt(b, 16)\\n  const obj = { r, g, b }\\n\\n  return obj\\n}\\n\\nexport { hexStringToRGB }\\n\\n// > hexStringToRGB('ffffff')\\n// { r: 255, g: 255, b: 255 }\\n\"",
    "lower case conversion": "\"/*\\n    Explanation :- a user gives a String (it can be incomplete uppercase or\\n        partial uppercase) and then the program would convert it into a\\n        complete(all characters in lower case) lower case string. The\\n        logic we have used in the following program is: All the upper case\\n        characters (A-Z) has ASCII value ranging from 65 to 90 and their\\n        corresponding lower case characters (a-z) have ASCII values 32\\n        greater than them. For example ‘A‘ has an ASCII value of 65\\n        and ‘a‘ has an ASCII value of 97 (65+32). The same applies to other\\n        characters.\\n*/\\n\\n/**\\n * LowerCaseConversion takes any case-style string and converts it to the lower case-style string.\\n * @param {String} inputString any case style string\\n * @returns {String} lower case string\\n */\\nconst LowerCaseConversion = (inputString) => {\\n  // Take a string and split it into characters.\\n  const newString = inputString.split('').map(char => {\\n    // Get a character code by the use charCodeAt method.\\n    const presentCharCode = char.charCodeAt()\\n    // If the character code lies between 65 to 90 it means they are in the upper case so convert it.\\n    if (presentCharCode >= 65 && presentCharCode <= 90) {\\n      // Convert the case by use of the above explanation.\\n      return String.fromCharCode(presentCharCode + 32)\\n    }\\n    // Else return the characters without any modification.\\n    return char\\n  })\\n  // After modification, with the help of the join method, join all the characters and return them.\\n  return newString.join('')\\n}\\n\\nexport { LowerCaseConversion }\\n\"",
    "meter to feet conversion": "\"// Foot: https://en.wikipedia.org/wiki/Foot_(unit)\\nconst feetToMeter = (feet) => {\\n  return feet * 0.3048\\n}\\n\\nconst meterToFeet = (meter) => {\\n  return meter / 0.3048\\n}\\n\\nexport { feetToMeter, meterToFeet }\\n\"",
    "oct to decimal": "\"function octalToDecimal (num) {\\n  let dec = 0\\n  let base = 1\\n  while (num > 0) {\\n    const r = num % 10\\n    num = Math.floor(num / 10)\\n    dec = dec + (r * base)\\n    base = base * 8\\n  }\\n  return dec\\n}\\n\\nexport { octalToDecimal }\\n\\n// > octalToDecimal(56)\\n// 46\\n\\n// > octalToDecimal(2365)\\n// 1269\\n\"",
    "railway time conversion": "\"/*\\n    The time conversion of normalized time to the railway is a simple algorithm\\n    because we know that if the time is in 'AM' value it means they only want\\n    some changes on hours and minutes and if the time in 'PM' it means the only\\n    want some changes in hour value.\\n\\n    Input Format -> 07:05:45PM\\n    Output Format -> 19:05:45\\n\\n    Problem & Explanation Source : https://www.mathsisfun.com/time.html\\n*/\\n\\n/**\\n * RailwayTimeConversion method converts normalized time string to Railway time string.\\n * @param {String} timeString Normalized time string.\\n * @returns {String} Railway time string.\\n */\\nconst RailwayTimeConversion = (timeString) => {\\n  // firstly, check that input is a string or not.\\n  if (typeof timeString !== 'string') {\\n    return new TypeError('Argument is not a string.')\\n  }\\n  // split the string by ':' character.\\n  const [hour, minute, scondWithShift] = timeString.split(':')\\n  // split second and shift value.\\n  const [second, shift] = [scondWithShift.substr(0, 2), scondWithShift.substr(2)]\\n  // convert shifted time to not-shift time(Railway time) by using the above explanation.\\n  if (shift === 'PM') {\\n    if (parseInt(hour) === 12) { return `${hour}:${minute}:${second}` } else { return `${parseInt(hour) + 12}:${minute}:${second}` }\\n  } else {\\n    if (parseInt(hour) === 12) { return `00:${minute}:${second}` } else { return `${hour}:${minute}:${second}` }\\n  }\\n}\\n\\nexport { RailwayTimeConversion }\\n\"",
    "rgb hsv conversion": "\"/*\\n * The RGB color model is an additive color model in which red, green, and blue light are added\\n * together in various ways to reproduce a broad array of colors. The name of the model comes from\\n * the initials of the three additive primary colors, red, green, and blue. Meanwhile, the HSV\\n * representation models how colors appear under light. In it, colors are represented using three\\n * components: hue, saturation and (brightness-)value. This file provides functions for converting\\n * colors from one representation to the other. (description adapted from\\n * https://en.wikipedia.org/wiki/RGB_color_model and https://en.wikipedia.org/wiki/HSL_and_HSV).\\n */\\n\\n/**\\n * Conversion from the HSV-representation to the RGB-representation.\\n *\\n * @param hue Hue of the color.\\n * @param saturation Saturation of the color.\\n * @param value Brightness-value of the color.\\n * @return The tuple of RGB-components.\\n */\\nexport function hsvToRgb (hue, saturation, value) {\\n  if (hue < 0 || hue > 360) {\\n    throw new Error('hue should be between 0 and 360')\\n  }\\n\\n  if (saturation < 0 || saturation > 1) {\\n    throw new Error('saturation should be between 0 and 1')\\n  }\\n\\n  if (value < 0 || value > 1) {\\n    throw new Error('value should be between 0 and 1')\\n  }\\n\\n  const chroma = value * saturation\\n  const hueSection = hue / 60\\n  const secondLargestComponent = chroma * (1 - Math.abs(hueSection % 2 - 1))\\n  const matchValue = value - chroma\\n\\n  return getRgbBySection(hueSection, chroma, matchValue, secondLargestComponent)\\n}\\n\\n/**\\n * Conversion from the RGB-representation to the HSV-representation.\\n *\\n * @param red Red-component of the color.\\n * @param green Green-component of the color.\\n * @param blue Blue-component of the color.\\n * @return The tuple of HSV-components.\\n */\\nexport function rgbToHsv (red, green, blue) {\\n  if (red < 0 || red > 255) {\\n    throw new Error('red should be between 0 and 255')\\n  }\\n\\n  if (green < 0 || green > 255) {\\n    throw new Error('green should be between 0 and 255')\\n  }\\n\\n  if (blue < 0 || blue > 255) {\\n    throw new Error('blue should be between 0 and 255')\\n  }\\n\\n  const dRed = red / 255\\n  const dGreen = green / 255\\n  const dBlue = blue / 255\\n  const value = Math.max(Math.max(dRed, dGreen), dBlue)\\n  const chroma = value - Math.min(Math.min(dRed, dGreen), dBlue)\\n  const saturation = value === 0 ? 0 : chroma / value\\n  let hue\\n\\n  if (chroma === 0) {\\n    hue = 0\\n  } else if (value === dRed) {\\n    hue = 60 * ((dGreen - dBlue) / chroma)\\n  } else if (value === dGreen) {\\n    hue = 60 * (2 + (dBlue - dRed) / chroma)\\n  } else {\\n    hue = 60 * (4 + (dRed - dGreen) / chroma)\\n  }\\n\\n  hue = (hue + 360) % 360\\n\\n  return [hue, saturation, value]\\n}\\n\\nexport function approximatelyEqualHsv (hsv1, hsv2) {\\n  const bHue = Math.abs(hsv1[0] - hsv2[0]) < 0.2\\n  const bSaturation = Math.abs(hsv1[1] - hsv2[1]) < 0.002\\n  const bValue = Math.abs(hsv1[2] - hsv2[2]) < 0.002\\n\\n  return bHue && bSaturation && bValue\\n}\\n\\nfunction getRgbBySection (hueSection, chroma, matchValue, secondLargestComponent) {\\n  function convertToInt (input) {\\n    return Math.round(255 * input)\\n  }\\n\\n  let red\\n  let green\\n  let blue\\n\\n  if (hueSection >= 0 && hueSection <= 1) {\\n    red = convertToInt(chroma + matchValue)\\n    green = convertToInt(secondLargestComponent + matchValue)\\n    blue = convertToInt(matchValue)\\n  } else if (hueSection > 1 && hueSection <= 2) {\\n    red = convertToInt(secondLargestComponent + matchValue)\\n    green = convertToInt(chroma + matchValue)\\n    blue = convertToInt(matchValue)\\n  } else if (hueSection > 2 && hueSection <= 3) {\\n    red = convertToInt(matchValue)\\n    green = convertToInt(chroma + matchValue)\\n    blue = convertToInt(secondLargestComponent + matchValue)\\n  } else if (hueSection > 3 && hueSection <= 4) {\\n    red = convertToInt(matchValue)\\n    green = convertToInt(secondLargestComponent + matchValue)\\n    blue = convertToInt(chroma + matchValue)\\n  } else if (hueSection > 4 && hueSection <= 5) {\\n    red = convertToInt(secondLargestComponent + matchValue)\\n    green = convertToInt(matchValue)\\n    blue = convertToInt(chroma + matchValue)\\n  } else {\\n    red = convertToInt(chroma + matchValue)\\n    green = convertToInt(matchValue)\\n    blue = convertToInt(secondLargestComponent + matchValue)\\n  }\\n\\n  return [red, green, blue]\\n}\\n\"",
    "r g b to hex": "\"function RGBToHex (r, g, b) {\\n  if (\\n    typeof r !== 'number' ||\\n    typeof g !== 'number' ||\\n    typeof b !== 'number'\\n  ) {\\n    throw new TypeError('argument is not a Number')\\n  }\\n\\n  const toHex = n => (n || '0').toString(16).padStart(2, '0')\\n\\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`\\n}\\n\\nexport { RGBToHex }\\n\\n// > RGBToHex(255, 255, 255)\\n// '#ffffff'\\n\\n// > RGBToHex(255, 99, 71)\\n// '#ff6347'\\n\"",
    "roman to decimal": "\"const values = {\\n  I: 1,\\n  V: 5,\\n  X: 10,\\n  L: 50,\\n  C: 100,\\n  D: 500,\\n  M: 1000\\n}\\n\\nexport function romanToDecimal (romanNumber) {\\n  let prev = ' '\\n\\n  let sum = 0\\n\\n  let newPrev = 0\\n  for (let i = romanNumber.length - 1; i >= 0; i--) {\\n    const c = romanNumber.charAt(i)\\n\\n    if (prev !== ' ') {\\n      newPrev = values[prev] > newPrev ? values[prev] : newPrev\\n    }\\n\\n    const currentNum = values[c]\\n    if (currentNum >= newPrev) {\\n      sum += currentNum\\n    } else {\\n      sum -= currentNum\\n    }\\n\\n    prev = c\\n  }\\n  return sum\\n}\\n\"",
    "temperature conversion": "\"// This files has functions to convert different temperature units\\r\\n// Functions take temperature value as a argument and returns corresponding converted value\\r\\n\\r\\nconst celsiusToFahrenheit = (celsius) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\r\\n  return Math.round(((celsius) * 9 / 5) + 32)\\r\\n}\\r\\n\\r\\nconst celsiusToKelvin = (celsius) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\r\\n  return Math.round((celsius) + 273.15)\\r\\n}\\r\\n\\r\\nconst celsiusToRankine = (celsius) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\r\\n  return Math.round(((celsius) * 9 / 5) + 491.67)\\r\\n}\\r\\n\\r\\nconst fahrenheitToCelsius = (fahrenheit) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\r\\n  return Math.round(((fahrenheit) - 32) * 5 / 9)\\r\\n}\\r\\n\\r\\nconst fahrenheitToKelvin = (fahrenheit) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\r\\n  return Math.round((((fahrenheit) - 32) * 5 / 9) + 273.15)\\r\\n}\\r\\n\\r\\nconst fahrenheitToRankine = (fahrenheit) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\r\\n  return Math.round((fahrenheit) + 459.67)\\r\\n}\\r\\n\\r\\nconst kelvinToCelsius = (kelvin) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\r\\n  return Math.round((kelvin) - 273.15)\\r\\n}\\r\\n\\r\\nconst kelvinToFahrenheit = (kelvin) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\r\\n  return Math.round((((kelvin) - 273.15) * 9 / 5) + 32)\\r\\n}\\r\\n\\r\\nconst kelvinToRankine = (kelvin) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\r\\n  return Math.round(((kelvin) * 9 / 5))\\r\\n}\\r\\n\\r\\nconst rankineToCelsius = (rankine) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\r\\n  return Math.round(((rankine) - 491.67) * 5 / 9)\\r\\n}\\r\\n\\r\\nconst rankineToFahrenheit = (rankine) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\r\\n  return Math.round((rankine) - 459.67)\\r\\n}\\r\\n\\r\\nconst rankineToKelvin = (rankine) => {\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\r\\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\r\\n  return Math.round(((rankine) * 5 / 9))\\r\\n}\\r\\n\\r\\nconst reaumurToKelvin = (reaumur) => {\\r\\n  // Reference:- http://www.csgnetwork.com/temp2conv.html\\r\\n  return Math.round(((reaumur) * 1.25 + 273.15))\\r\\n}\\r\\n\\r\\nconst reaumurToFahrenheit = (reaumur) => {\\r\\n  // Reference:- http://www.csgnetwork.com/temp2conv.html\\r\\n  return Math.round(((reaumur) * 2.25 + 32))\\r\\n}\\r\\n\\r\\nconst reaumurToCelsius = (reaumur) => {\\r\\n  // Reference:- http://www.csgnetwork.com/temp2conv.html\\r\\n  return Math.round(((reaumur) * 1.25))\\r\\n}\\r\\n\\r\\nconst reaumurToRankine = (reaumur) => {\\r\\n  // Reference:- http://www.csgnetwork.com/temp2conv.html\\r\\n  return Math.round(((reaumur) * 2.25 + 32 + 459.67))\\r\\n}\\r\\n\\r\\nexport {\\r\\n  celsiusToFahrenheit, celsiusToKelvin, celsiusToRankine,\\r\\n  fahrenheitToCelsius, fahrenheitToKelvin, fahrenheitToRankine,\\r\\n  kelvinToCelsius, kelvinToFahrenheit, kelvinToRankine,\\r\\n  rankineToCelsius, rankineToFahrenheit, rankineToKelvin,\\r\\n  reaumurToCelsius, reaumurToFahrenheit, reaumurToKelvin, reaumurToRankine\\r\\n}\\r\\n\"",
    "title case conversion": "\"/*\\n    Problem statement and Explanation : https://www.codeproject.com/Tips/162540/Letter-Case-Conversion-Algorithms-Title-Case-Toggl.\\n    [Title case](https://en.wikipedia.org/wiki/Title_case) is a style where all words are capitalized. Officially, title case\\n    does not capitalize some words, such as very short words like \\\"a\\\" or \\\"is\\\", but for the purposes of this function, a general approach\\n    is taken where all words are capitalized regardless of length.\\n*/\\n\\n/**\\n * The titleCaseConversion function converts a string into a title case string.\\n * @param {string} inputString The input string which can have any types of letter casing.\\n * @returns {string} A string that is in title case.\\n */\\nconst titleCaseConversion = (inputString) => {\\n  if (inputString === '') return ''\\n  // Extract all space separated string.\\n  const stringCollections = inputString.split(' ').map(word => {\\n    let firstChar = ''\\n    // Get the [ASCII](https://en.wikipedia.org/wiki/ASCII) character code by the use charCodeAt method.\\n    const firstCharCode = word[0].charCodeAt()\\n    // If the ASCII character code lies between 97 to 122 it means they are in the lowercase so convert it.\\n    if (firstCharCode >= 97 && firstCharCode <= 122) {\\n      // Convert the case by use of the above explanation.\\n      firstChar += String.fromCharCode(firstCharCode - 32)\\n    } else {\\n      // Else store the characters without any modification.\\n      firstChar += word[0]\\n    }\\n    const newWordChar = word.slice(1).split('').map(char => {\\n      // Get the ASCII character code by the use charCodeAt method.\\n      const presentCharCode = char.charCodeAt()\\n      // If the ASCII character code lies between 65 to 90, it means they are in the uppercase so convert it.\\n      if (presentCharCode >= 65 && presentCharCode <= 90) {\\n        // Convert the case by use of the above explanation.\\n        return String.fromCharCode(presentCharCode + 32)\\n      }\\n      // Else return the characters without any modification.\\n      return char\\n    })\\n    // Return the first converted character and remaining character string.\\n    return firstChar + newWordChar.join('')\\n  })\\n  // Convert all words in a string and return it.\\n  return stringCollections.join(' ')\\n}\\n\\nexport { titleCaseConversion }\\n\"",
    "upper case conversion": "\"/*\\n    Explanation :- A user gives a string (it can be incomplete lowercase or\\n        partially in lowercase) and then the program converts it into a\\n        completely (all characters in uppercase) uppercase string. The\\n        logic we have used in the following program is: All the lowercase\\n        characters (a-z) has [ASCII](https://en.wikipedia.org/wiki/ASCII) value ranging from 97 to 122 and their\\n        corresponding uppercase characters (A-Z) have ASCII values 32\\n        lesser than them. For example ‘a‘ has an ASCII value of 97\\n        and ‘A‘ has an ASCII value of 65 (97 - 32). The same applies to other\\n        characters.\\n*/\\n\\n/**\\n * upperCaseConversion takes any case-style string and converts it to the uppercase-style string.\\n * @param {string} inputString Any case style string\\n * @returns {string} Uppercase string\\n */\\nconst upperCaseConversion = (inputString) => {\\n  // Take a string and split it into characters.\\n  const newString = inputString.split('').map(char => {\\n    // Get a character code by the use charCodeAt method.\\n    const presentCharCode = char.charCodeAt()\\n    // If the character code lies between 97 to 122, it means they are in the lowercase so convert it.\\n    if (presentCharCode >= 97 && presentCharCode <= 122) {\\n      // Convert the case by use of the above explanation.\\n      return String.fromCharCode(presentCharCode - 32)\\n    }\\n    // Else return the characters without any modification.\\n    return char\\n  })\\n  // After modification, with the help of the join method, join all the characters and return them.\\n  return newString.join('')\\n}\\n\\nexport { upperCaseConversion }\\n\"",
    "climbing stairs": "\"/**\\n * @function ClimbStairs\\n * @description You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\\n * @param {Integer} n - The input integer\\n * @return {Integer} distinct ways can you climb to the top.\\n * @see [Climb_Stairs](https://www.geeksforgeeks.org/count-ways-reach-nth-stair/)\\n */\\n\\nconst climbStairs = (n) => {\\n  let prev = 0\\n  let cur = 1\\n  let temp\\n\\n  for (let i = 0; i < n; i++) {\\n    temp = prev\\n    prev = cur\\n    cur += temp\\n  }\\n  return cur\\n}\\n\\nexport { climbStairs }\\n\"",
    "coin change": "\"/**\\n * @params {Array} coins\\n * @params {Number} amount\\n */\\nexport const change = (coins, amount) => {\\n  // Create and initialize the storage\\n  const combinations = new Array(amount + 1).fill(0)\\n  combinations[0] = 1\\n  // Determine the direction of smallest sub-problem\\n  for (let i = 0; i < coins.length; i++) {\\n    // Travel and fill the combinations array\\n    for (let j = coins[i]; j < combinations.length; j++) {\\n      combinations[j] += combinations[j - coins[i]]\\n    }\\n  }\\n  return combinations[amount]\\n}\\n/**\\n * @params {Array} coins\\n * @params {Number} amount\\n */\\nexport const coinChangeMin = (coins, amount) => {\\n  const map = { 0: 1 }\\n  for (let i = 1; i <= amount; i++) {\\n    let min = Infinity\\n    for (const coin of coins) {\\n      if (i < coin) continue\\n      min = Math.min(min, 1 + map[i - coin])\\n    }\\n    map[i] = min\\n  }\\n  return map[amount] === Infinity ? -1 : map[amount] - 1\\n}\\n\"",
    "edit distance": "\"/*\\nWikipedia -> https://en.wikipedia.org/wiki/Edit_distance\\n\\nQ. -> Given two strings `word1` and `word2`. You can perform these operations on any of the string to make both strings similar.\\n    - Insert\\n    - Remove\\n    - Replace\\nFind the minimum operation cost required to make both same. Each operation cost is 1.\\n\\nAlgorithm details ->\\ntime complexity - O(n*m)\\nspace complexity - O(n*m)\\n*/\\n\\nconst minimumEditDistance = (word1, word2) => {\\n  const n = word1.length\\n  const m = word2.length\\n  const dp = new Array(m + 1).fill(0).map(item => [])\\n\\n  /*\\n    fill dp matrix with default values -\\n        - first row is filled considering no elements in word2.\\n        - first column filled considering no elements in word1.\\n    */\\n\\n  for (let i = 0; i < n + 1; i++) {\\n    dp[0][i] = i\\n  }\\n\\n  for (let i = 0; i < m + 1; i++) {\\n    dp[i][0] = i\\n  }\\n\\n  /*\\n        indexing is 1 based for dp matrix as we defined some known values at first row and first column/\\n    */\\n\\n  for (let i = 1; i < m + 1; i++) {\\n    for (let j = 1; j < n + 1; j++) {\\n      const letter1 = word1[j - 1]\\n      const letter2 = word2[i - 1]\\n\\n      if (letter1 === letter2) {\\n        dp[i][j] = dp[i - 1][j - 1]\\n      } else {\\n        dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1\\n      }\\n    }\\n  }\\n\\n  return dp[m][n]\\n}\\n\\nexport { minimumEditDistance }\\n\"",
    "fibonacci number": "\"/**\\n * @function Fibonacci\\n * @description Fibonacci is the sum of previous two fibonacci numbers.\\n * @param {Integer} N - The input integer\\n * @return {Integer} fibonacci of N.\\n * @see [Fibonacci_Numbers](https://en.wikipedia.org/wiki/Fibonacci_number)\\n */\\nconst fibonacci = (N) => {\\n  // creating array to store values\\n  const memo = new Array(N + 1)\\n  memo[0] = 0\\n  memo[1] = 1\\n  for (let i = 2; i <= N; i++) {\\n    memo[i] = memo[i - 1] + memo[i - 2]\\n  }\\n  return memo[N]\\n}\\n\\nexport { fibonacci }\\n\"",
    "find month calendar": "\"/*\\n*  This algorithm accepts a month in the format mm/yyyy.\\n*  And prints out the month's calendar.\\n*  It uses an epoch of 1/1/1900, Monday.\\n*/\\n\\nclass Month {\\n  constructor () {\\n    this.Days = ['M', 'T', 'W', 'Th', 'F', 'S', 'Su']\\n    this.BDays = ['M', 'Su', 'S', 'F', 'Th', 'W', 'T']\\n    this.epoch = { month: 1, year: 1900 }\\n    this.monthDays = [31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    this.monthDaysLeap = [31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n  }\\n\\n  printCal (days, startDay, output = value => console.log(value)) {\\n    output('M   T   W   Th  F   S   Su')\\n    const dates = []; let i\\n    for (i = 1; i <= days; i++) {\\n      dates.push(i)\\n    }\\n    for (i = 0; i < this.Days.indexOf(startDay); i++) {\\n      dates.unshift(' ')\\n    }\\n    while (true) {\\n      let row = ''\\n      for (i = 0; (i < 7) && (dates.length !== 0); i++) {\\n        row += dates.shift()\\n        while ((row.length % 4) !== 0) {\\n          row += ' '\\n        }\\n      }\\n      output(row)\\n      if (dates.length === 0) break\\n    }\\n  }\\n\\n  parseDate (date) {\\n    const dateAr = []; let block = ''; let i\\n    for (i = 0; i < date.length; i++) {\\n      if (date[i] === '/') {\\n        dateAr.push(parseInt(block))\\n        block = ''\\n        continue\\n      }\\n      block += date[i]\\n    }\\n    dateAr.push(parseInt(block))\\n    if (dateAr.length !== 2) throw new Error('Improper string encoding')\\n    const dateOb = { month: dateAr[0], year: dateAr[1] }\\n    return dateOb\\n  }\\n\\n  isLeapYear (year) {\\n    if (((year % 400) === 0) || (((year % 100) !== 0) && ((year % 4) === 0))) return true\\n    return false\\n  }\\n\\n  isGreater (startDate, endDate) {\\n    if (startDate.year > endDate.year) {\\n      return true\\n    } else if (startDate.year < endDate.year) {\\n      return false\\n    } else if (startDate.month > endDate.month) {\\n      return true\\n    } else if (startDate.month < endDate.month) {\\n      return false\\n    }\\n    return true\\n  }\\n\\n  getDayDiff (startDate, endDate) {\\n    if (this.isGreater(startDate, endDate) === null) {\\n      return 0\\n    } else if ((this.isGreater(startDate, endDate) === true)) {\\n      const midDate = startDate\\n      startDate = endDate\\n      endDate = midDate\\n    }\\n    let diff = 0\\n    while (startDate.year !== endDate.year) {\\n      diff += (this.isLeapYear(startDate.year)) ? 366 : 365\\n      startDate.year = startDate.year + 1\\n    }\\n    while (startDate.month !== endDate.month) {\\n      if (startDate.month < endDate.month) {\\n        if (this.isLeapYear(startDate.year)) diff += this.monthDaysLeap[startDate.month]\\n        else diff += this.monthDays[startDate.month]\\n        startDate.month = startDate.month + 1\\n      } else {\\n        if (this.isLeapYear(startDate.year)) diff -= this.monthDaysLeap[startDate.month - 1]\\n        else diff -= this.monthDays[startDate.month - 1]\\n        startDate.month = startDate.month - 1\\n      }\\n    }\\n    return diff\\n  }\\n\\n  generateMonthCal (date) {\\n    const Month = this.parseDate(date); let day = ''\\n    let difference = this.getDayDiff(this.epoch, Month)\\n    difference = difference % 7\\n    let Month2 = this.parseDate(date)\\n    day = (this.isGreater(Month2, this.epoch)) ? this.Days[difference] : this.BDays[difference]\\n    Month2 = this.parseDate(date)\\n    if (this.isLeapYear(Month2.year)) this.printCal(this.monthDaysLeap[Month2.month], day)\\n    else this.printCal(this.monthDays[Month2.month], day)\\n  }\\n}\\n\\nexport { Month }\\n\\n// const x = new Month()\\n// x.generateMonthCal('1/2021')\\n\"",
    "kadane algo": "\"/* Kadane's algorithm is one of the most efficient ways to\\n * calculate the maximum contiguous subarray sum for a given array.\\n * Below is the implementation of kadanes's algorithm along with\\n * some sample test cases.\\n * There might be a special case in this problem if al the elements\\n * of the given array are negative. In such a case, the maximum negative\\n * value present in the array is the answer.\\n *\\n * Reference article :- https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/\\n */\\n\\nexport function kadaneAlgo (array) {\\n  let cummulativeSum = 0\\n  let maxSum = Number.NEGATIVE_INFINITY // maxSum has the least possible value\\n  for (let i = 0; i < array.length; i++) {\\n    cummulativeSum = cummulativeSum + array[i]\\n    if (maxSum < cummulativeSum) {\\n      maxSum = cummulativeSum\\n    } else if (cummulativeSum < 0) {\\n      cummulativeSum = 0\\n    }\\n  }\\n  return maxSum\\n  // This function returns largest sum contiguous sum in a array\\n}\\n\"",
    "levenshtein distance": "\"/* The Levenshtein distance (a.k.a edit distance) is a\\nmeasure of similarity between two strings. It is\\ndefined as the minimum number of changes required to\\nconvert string a into string b (this is done by\\ninserting, deleting or replacing a character in\\nstring a).\\nThe smaller the Levenshtein distance,\\nthe more similar the strings are. This is a very\\ncommon problem in the application of Dynamic Programming.\\n*/\\n\\nconst levenshteinDistance = (a, b) => {\\n  // Declaring array 'D' with rows = len(a) + 1 and columns = len(b) + 1:\\n  const distanceMatrix = Array(b.length + 1)\\n    .fill(null)\\n    .map(() => Array(a.length + 1).fill(null))\\n\\n  // Initializing first column:\\n  for (let i = 0; i <= a.length; i += 1) {\\n    distanceMatrix[0][i] = i\\n  }\\n\\n  // Initializing first row:\\n  for (let j = 0; j <= b.length; j += 1) {\\n    distanceMatrix[j][0] = j\\n  }\\n\\n  for (let j = 1; j <= b.length; j += 1) {\\n    for (let i = 1; i <= a.length; i += 1) {\\n      const indicator = a[i - 1] === b[j - 1] ? 0 : 1\\n      // choosing the minimum of all three, vis-a-vis:\\n      distanceMatrix[j][i] = Math.min(\\n        distanceMatrix[j][i - 1] + 1, // deletion\\n        distanceMatrix[j - 1][i] + 1, // insertion\\n        distanceMatrix[j - 1][i - 1] + indicator // substitution\\n      )\\n    }\\n  }\\n\\n  return distanceMatrix[b.length][a.length]\\n}\\n\\nexport { levenshteinDistance }\\n\"",
    "longest common subsequence": "\"/*\\nProblem:\\nGiven two sequences, find the length of longest subsequence present in both of them.\\nA subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.\\nFor example, “abc”, “abg”, “bdf”, “aeg”, ‘”acefg”, .. etc are subsequences of “abcdefg”\\n\\nOur Solution:\\nWe use recursion with tabular memoization.\\nTime complexity: O(M x N)\\nSolving each subproblem has a cost of O(1). Again, there are MxN subproblems,\\nand so we get a total time complexity of O(MxN).\\nSpace complexity: O(M x N)\\nWe need to store the answer for each of the MxN subproblems.\\n\\nImprovement:\\nIt's possible to optimize space complexity to O(min(M, N)) or time to O((N + r)log(N))\\nwhere r is the number of matches between the two sequences. Try to figure out how.\\n\\nReferences:\\n[wikipedia](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem)\\n[leetcode](https://leetcode.com/problems/longest-common-subsequence/)\\n*/\\n\\n/**\\n * Finds length of the longest common subsequence among the two input string\\n * @param {string} str1 Input string #1\\n * @param {string} str2 Input string #2\\n * @returns {number} Length of the longest common subsequence\\n */\\nfunction longestCommonSubsequence (str1, str2) {\\n  const memo = new Array(str1.length + 1).fill(null)\\n    .map(() => new Array(str2.length + 1).fill(null))\\n\\n  function recursive (end1, end2) {\\n    if (end1 === -1 || end2 === -1) {\\n      return 0\\n    }\\n\\n    if (memo[end1][end2] !== null) {\\n      return memo[end1][end2]\\n    }\\n\\n    if (str1[end1] === str2[end2]) {\\n      memo[end1][end2] = 1 + recursive(end1 - 1, end2 - 1)\\n      return memo[end1][end2]\\n    } else {\\n      memo[end1][end2] = Math.max(\\n        recursive(end1 - 1, end2),\\n        recursive(end1, end2 - 1)\\n      )\\n      return memo[end1][end2]\\n    }\\n  }\\n\\n  return recursive(str1.length - 1, str2.length - 1)\\n}\\n\\nexport { longestCommonSubsequence }\\n\"",
    "longest increasing subsequence": "\"/**\\n * A Dynamic Programming based solution for calculating Longest Increasing Subsequence\\n * https://en.wikipedia.org/wiki/Longest_increasing_subsequence\\n */\\n\\n// Return the length of the Longest Increasing Subsequence, given array x\\nfunction longestIncreasingSubsequence (x) {\\n  const length = x.length\\n  const dp = Array(length).fill(1)\\n\\n  let res = 1\\n\\n  for (let i = 0; i < length; i++) {\\n    for (let j = 0; j < i; j++) {\\n      if (x[i] > x[j]) {\\n        dp[i] = Math.max(dp[i], 1 + dp[j])\\n        if (dp[i] > res) {\\n          res = dp[i]\\n        }\\n      }\\n    }\\n  }\\n\\n  return res\\n}\\n\\nexport { longestIncreasingSubsequence }\\n\"",
    "longest palindromic subsequence": "\"/*\\n  LeetCode -> https://leetcode.com/problems/longest-palindromic-subsequence/\\n\\n  Given a string s, find the longest palindromic subsequence's length in s.\\n  You may assume that the maximum length of s is 1000.\\n\\n*/\\n\\nexport const longestPalindromeSubsequence = function (s) {\\n  const n = s.length\\n\\n  const dp = new Array(n).fill(0).map(item => new Array(n).fill(0).map(item => 0))\\n\\n  // fill predefined for single character\\n  for (let i = 0; i < n; i++) {\\n    dp[i][i] = 1\\n  }\\n\\n  for (let i = 1; i < n; i++) {\\n    for (let j = 0; j < n - i; j++) {\\n      const col = j + i\\n      if (s[j] === s[col]) {\\n        dp[j][col] = 2 + dp[j + 1][col - 1]\\n      } else {\\n        dp[j][col] = Math.max(dp[j][col - 1], dp[j + 1][col])\\n      }\\n    }\\n  }\\n\\n  return dp[0][n - 1]\\n}\\n\"",
    "longest valid parentheses": "\"/*\\n  LeetCode -> https://leetcode.com/problems/longest-valid-parentheses/\\n\\n  Given a string containing just the characters '(' and ')',\\n  find the length of the longest valid (well-formed) parentheses substring.\\n*/\\n\\nexport const longestValidParentheses = (s) => {\\n  const n = s.length\\n  const stack = []\\n\\n  // storing results\\n  const res = new Array(n).fill(-Infinity)\\n\\n  for (let i = 0; i < n; i++) {\\n    const bracket = s[i]\\n\\n    if (bracket === ')' && s[stack[stack.length - 1]] === '(') {\\n      res[i] = 1\\n      res[stack[stack.length - 1]] = 1\\n      stack.pop()\\n    } else {\\n      stack.push(i)\\n    }\\n  }\\n\\n  // summing all adjacent valid\\n  for (let i = 1; i < n; i++) {\\n    res[i] = Math.max(res[i], res[i] + res[i - 1])\\n  }\\n\\n  // adding 0 if there are none so it will return 0 instead of -Infinity\\n  res.push(0)\\n  return Math.max(...res)\\n}\\n\"",
    "max non adjacent sum": "\"function maximumNonAdjacentSum (nums) {\\n  /*\\n         * Find the maximum non-adjacent sum of the integers in the nums input list\\n         * :param nums: Array of Numbers\\n         * :return: The maximum non-adjacent sum\\n    */\\n\\n  if (nums.length < 0) return 0\\n\\n  let maxIncluding = nums[0]\\n  let maxExcluding = 0\\n\\n  for (const num of nums.slice(1)) {\\n    const temp = maxIncluding\\n    maxIncluding = maxExcluding + num\\n    maxExcluding = Math.max(temp, maxExcluding)\\n  }\\n\\n  return Math.max(maxExcluding, maxIncluding)\\n}\\n\\n// Example\\n\\n// maximumNonAdjacentSum([1, 2, 3]))\\n// maximumNonAdjacentSum([1, 5, 3, 7, 2, 2, 6]))\\n// maximumNonAdjacentSum([-1, -5, -3, -7, -2, -2, -6]))\\n// maximumNonAdjacentSum([499, 500, -3, -7, -2, -2, -6]))\\n\\nexport { maximumNonAdjacentSum }\\n\"",
    "max product of three": "\"/**\\n *  Given an array of numbers, return the maximum product\\n *  of 3 numbers from the array\\n *  https://wsvincent.com/javascript-three-sum-highest-product-of-three-numbers/\\n * @param {number[]} arrayItems\\n * @returns number\\n */\\nexport function maxProductOfThree (arrayItems) {\\n  // if size is less than 3, no triplet exists\\n  const n = arrayItems.length\\n  if (n < 3) throw new Error('Triplet cannot exist with the given array')\\n  let max1 = arrayItems[0]\\n  let max2 = -1\\n  let max3 = -1\\n  let min1 = arrayItems[0]\\n  let min2 = -1\\n  for (let i = 1; i < n; i++) {\\n    if (arrayItems[i] > max1) {\\n      max3 = max2\\n      max2 = max1\\n      max1 = arrayItems[i]\\n    } else if (max2 === -1 || arrayItems[i] > max2) {\\n      max3 = max2\\n      max2 = arrayItems[i]\\n    } else if (max3 === -1 || arrayItems[i] > max3) {\\n      max3 = arrayItems[i]\\n    }\\n    if (arrayItems[i] < min1) {\\n      min2 = min1\\n      min1 = arrayItems[i]\\n    } else if (min2 === -1 || arrayItems[i] < min2) {\\n      min2 = arrayItems[i]\\n    }\\n  }\\n  const prod1 = max1 * max2 * max3\\n  const prod2 = max1 * min1 * min2\\n  return Math.max(prod1, prod2)\\n}\\n\"",
    "minimum cost path": "\"// Problem Statement => https://www.youtube.com/watch?v=lBRtnuxg-gU\\n\\nconst minCostPath = (matrix) => {\\n  /*\\n        Find the min cost path from top-left to bottom-right in matrix\\n        >>> minCostPath([[2, 1], [3, 1], [4, 2]])\\n        >>> 6\\n    */\\n\\n  const n = matrix.length\\n  const m = matrix[0].length\\n\\n  // moves[i][j] => minimum number of moves to reach cell i, j\\n  const moves = new Array(n)\\n  for (let i = 0; i < moves.length; i++) moves[i] = new Array(m)\\n\\n  // base conditions\\n  moves[0][0] = matrix[0][0] // to reach cell (0, 0) from (0, 0) is of no moves\\n  for (let i = 1; i < m; i++) moves[0][i] = moves[0][i - 1] + matrix[0][i]\\n  for (let i = 1; i < n; i++) moves[i][0] = moves[i - 1][0] + matrix[i][0]\\n\\n  for (let i = 1; i < n; i++) {\\n    for (let j = 1; j < m; j++) { moves[i][j] = Math.min(moves[i - 1][j], moves[i][j - 1]) + matrix[i][j] }\\n  }\\n\\n  return moves[n - 1][m - 1]\\n}\\n\\nexport { minCostPath }\\n\\n// Example\\n\\n// minCostPath([\\n//   [2, 1],\\n//   [3, 1],\\n//   [4, 2]\\n// ])\\n\\n// minCostPath([\\n//   [2, 1, 4],\\n//   [2, 1, 3],\\n//   [3, 2, 1]\\n// ])\\n\"",
    "number of subset equal to given sum": "\"/*\\nGiven an array of non-negative integers and a value sum,\\ndetermine the total number of the subset with sum\\nequal to the given sum.\\n*/\\n/*\\n Given solution is O(n*sum) Time complexity and O(sum) Space complexity\\n*/\\nfunction NumberOfSubsetSum (array, sum) {\\n  const dp = [] // create an dp array where dp[i] denote number of subset with sum equal to i\\n  for (let i = 1; i <= sum; i++) {\\n    dp[i] = 0\\n  }\\n  dp[0] = 1 // since sum equal to 0 is always possible with no element in subset\\n\\n  for (let i = 0; i < array.length; i++) {\\n    for (let j = sum; j >= array[i]; j--) {\\n      if (j - array[i] >= 0) {\\n        dp[j] += dp[j - array[i]]\\n      }\\n    }\\n  }\\n  return dp[sum]\\n}\\n\\n// example\\n\\n// const array = [1, 1, 2, 2, 3, 1, 1]\\n// const sum = 4\\n// const result = NumberOfSubsetSum(array, sum)\\n\\nexport { NumberOfSubsetSum }\\n\"",
    "rod cutting": "\"/*\\n  * You are given a rod of 'n' length and an array of prices associated with all the lengths less than 'n'.\\n  * Find the maximum profit possible by cutting the rod and selling the pieces.\\n*/\\n\\nexport function rodCut (prices, n) {\\n  const memo = new Array(n + 1)\\n  memo[0] = 0\\n\\n  for (let i = 1; i <= n; i++) {\\n    let maxVal = Number.MIN_VALUE\\n    for (let j = 0; j < i; j++) { maxVal = Math.max(maxVal, prices[j] + memo[i - j - 1]) }\\n    memo[i] = maxVal\\n  }\\n\\n  return memo[n]\\n}\\n\"",
    "shuf": "\"/*\\nGiven a data set of an unknown size,\\nGet a random sample in a random order\\nIt's used in data analytics, often as a way to get a small random sample from a data lake or warehouse, or from a large CSV file\\n*/\\nfunction shuf (datasetSource, sampleSize) {\\n  const output = fillBaseSample(datasetSource, sampleSize)\\n\\n  return randomizeOutputFromDataset(datasetSource, output)\\n}\\n\\n/**\\n * Fills the output if possible, with the minimum number of values\\n * @param {Iterable.<T>} datasetSource The iterable source of data\\n * @param {number} sampleSize The size of the sample to extract from the dataset\\n * @returns {Array.<T>} The random sample, as an array\\n * @template T\\n */\\nfunction fillBaseSample (datasetSource, sampleSize) {\\n  let filledIndexes = []\\n  let output = new Array(sampleSize)\\n\\n  // Spread data out filling the array\\n  while (true) {\\n    const iterator = datasetSource.next()\\n    if (iterator.done) break\\n\\n    let insertTo = Math.floor(Math.random() * output.length)\\n    while (filledIndexes.includes(insertTo)) {\\n      insertTo++\\n      if (insertTo === output.length) {\\n        insertTo = 0\\n      }\\n    }\\n    output[insertTo] = {\\n      value: iterator.value\\n    }\\n\\n    filledIndexes = [...filledIndexes, insertTo]\\n\\n    if (filledIndexes.length === sampleSize) {\\n      break\\n    }\\n  }\\n\\n  if (filledIndexes.length < output.length) {\\n    // Not a large enough dataset to fill the sample - trim empty values\\n    output = output.filter((_, i) => filledIndexes.includes(i))\\n  }\\n\\n  return output.map((o) => o.value)\\n}\\n\\n/**\\n * Replaces values in the output randomly with new ones from the dataset\\n * @param {Iterable.<T>} datasetSource The iterable source of data\\n * @param {Array.<T>} output The output so far, filled with data\\n * @returns {Array.<T>} The random sample, as an array\\n * @template T\\n */\\nfunction randomizeOutputFromDataset (datasetSource, output) {\\n  const newOutput = [...output]\\n  let readSoFar = output.length\\n\\n  while (true) {\\n    const iterator = datasetSource.next()\\n    if (iterator.done) break\\n    readSoFar++\\n\\n    const insertTo = Math.floor(Math.random() * readSoFar)\\n    if (insertTo < newOutput.length) {\\n      newOutput[insertTo] = iterator.value\\n    }\\n  }\\n\\n  return newOutput\\n}\\n\\n// Example\\n\\n/**\\n * Generates a random range of data, with values between 0 and 2^31 - 1\\n * @param {number} length The number of data items to generate\\n * @returns {Iterable<number>} Random iterable data\\n*/\\nfunction * generateRandomData (length) {\\n  const maxValue = Math.pow(2, 31) - 1\\n  for (let i = 0; i < length; i++) {\\n    yield Math.floor(Math.random() * maxValue)\\n  }\\n}\\n\\n// const source = generateRandomData(1000)\\n// const result = shuf(source, 10)\\n\\nexport { shuf, generateRandomData }\\n\"",
    "sieve of eratosthenes": "\"const sieveOfEratosthenes = (n) => {\\n  /*\\n   * Calculates prime numbers till a number n\\n   * :param n: Number up to which to calculate primes\\n   * :return: A boolean list containing only primes\\n   */\\n  const primes = new Array(n + 1)\\n  primes.fill(true) // set all as true initially\\n  primes[0] = primes[1] = false // Handling case for 0 and 1\\n  const sqrtn = Math.ceil(Math.sqrt(n))\\n  for (let i = 2; i <= sqrtn; i++) {\\n    if (primes[i]) {\\n      for (let j = i * i; j <= n; j += i) {\\n        /*\\n        Optimization.\\n        Let j start from i * i, not 2 * i, because smaller multiples of i have been marked false.\\n\\n        For example, let i = 4.\\n        We do not have to check from 8(4 * 2) to 12(4 * 3)\\n        because they have been already marked false when i=2 and i=3.\\n        */\\n        primes[j] = false\\n      }\\n    }\\n  }\\n  return primes\\n}\\n\\nexport { sieveOfEratosthenes }\\n\"",
    "sudoku solver": "\"\\nconst isValid = (board, row, col, k) => {\\n  for (let i = 0; i < 9; i++) {\\n    const m = 3 * Math.floor(row / 3) + Math.floor(i / 3)\\n    const n = 3 * Math.floor(col / 3) + i % 3\\n    if (board[row][i] === k || board[i][col] === k || board[m][n] === k) {\\n      return false\\n    }\\n  }\\n  return true\\n}\\n\\nconst sudokuSolver = (data) => {\\n  for (let i = 0; i < 9; i++) {\\n    for (let j = 0; j < 9; j++) {\\n      if (data[i][j] === '.') {\\n        for (let k = 1; k <= 9; k++) {\\n          if (isValid(data, i, j, `${k}`)) {\\n            data[i][j] = `${k}`\\n            if (sudokuSolver(data)) {\\n              return true\\n            } else {\\n              data[i][j] = '.'\\n            }\\n          }\\n        }\\n        return false\\n      }\\n    }\\n  }\\n  return true\\n}\\n\\n// testing\\n\\n// const board = [\\n//   ['.', '9', '.', '.', '4', '2', '1', '3', '6'],\\n//   ['.', '.', '.', '9', '6', '.', '4', '8', '5'],\\n//   ['.', '.', '.', '5', '8', '1', '.', '.', '.'],\\n//   ['.', '.', '4', '.', '.', '.', '.', '.', '.'],\\n//   ['5', '1', '7', '2', '.', '.', '9', '.', '.'],\\n//   ['6', '.', '2', '.', '.', '.', '3', '7', '.'],\\n//   ['1', '.', '.', '8', '.', '4', '.', '2', '.'],\\n//   ['7', '.', '6', '.', '.', '.', '8', '1', '.'],\\n//   ['3', '.', '.', '.', '9', '.', '.', '.', '.']\\n// ]\\n// sudokuSolver(board) // -> board updated by reference\\n\\nexport { sudokuSolver }\\n\"",
    "trapping rain water": "\"/**\\n * @param {number[]} height\\n * @return {number}\\n */\\n\\n/* 42. Trapping Rain Water\\nhttps://leetcode.com/problems/trapping-rain-water/\\n\\nHelpful animation of this prompt: https://youtu.be/HmBbcDiJapY?t=51\\n\\nGiven n non-negative integers representing an elevation map where\\nthe width of each bar is 1, compute how much water it is able to trap\\nafter raining.\\n\\nVIEW ELEVATION MAP ON LEETCODE\\n\\nExample:\\n\\nInput:            [0,1,0,2,1,0,1,3,2,1,2,1]\\nOutput: 6\\n\\nPlan:\\niterate through and find left maxes\\niterate through and find right maxes\\ncreate minheight and assign it to the min(leftmax, rightmax)\\nif current height(element) < minheight\\n  push minheight - height into water array\\nelse\\n  push 0 onto water array\\n\\nsum up water array and return\\n\\nleft maxes =      [0,0,1,1,2,2,2,2,3,3,3,3]\\nright maxes =     [3,3,3,3,3,3,3,2,2,2,1,0]\\nwater contained = [0,0,1,0,1,2,1,0,0,1,0,0] -> sum = 6\\n*/\\n\\nexport const trap = (heights) => {\\n  const maxes = new Array(heights.length).fill(0)\\n\\n  let leftMax = 0\\n  for (let i = 0; i < heights.length; i++) {\\n    const height = heights[i]\\n    maxes[i] = leftMax\\n    leftMax = Math.max(leftMax, height)\\n  }\\n\\n  let rightMax = 0\\n  for (let i = heights.length - 1; i >= 0; i -= 1) {\\n    const height = heights[i]\\n    const minHeight = Math.min(rightMax, maxes[i])\\n\\n    if (height < minHeight) {\\n      maxes[i] = minHeight - height\\n    } else {\\n      maxes[i] = 0\\n    }\\n    rightMax = Math.max(rightMax, height)\\n  }\\n  return maxes.reduce((a, b) => a + b, 0)\\n}\\n\"",
    "tribonacci number": "\"/**\\n * @function Tribonacci\\n * @description Tribonacci is the sum of previous three tribonacci numbers.\\n * @param {Integer} n - The input integer\\n * @return {Integer} tribonacci of n.\\n * @see [Tribonacci_Numbers](https://www.geeksforgeeks.org/tribonacci-numbers/)\\n */\\nconst tribonacci = (n) => {\\n  // creating array to store previous tribonacci numbers\\n  const dp = new Array(n + 1)\\n  dp[0] = 0\\n  dp[1] = 1\\n  dp[2] = 1\\n  for (let i = 3; i <= n; i++) {\\n    dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\\n  }\\n  return dp[n]\\n}\\n\\nexport { tribonacci }\\n\"",
    "zero one knapsack": "\"/**\\n * A Dynamic Programming based solution for calculating Zero One Knapsack\\n * https://en.wikipedia.org/wiki/Knapsack_problem\\n */\\n\\nconst zeroOneKnapsack = (arr, n, cap, cache) => {\\n  if (cap === 0 || n === 0) {\\n    cache[n][cap] = 0\\n    return cache[n][cap]\\n  }\\n  if (cache[n][cap] !== -1) {\\n    return cache[n][cap]\\n  }\\n  if (arr[n - 1][0] <= cap) {\\n    cache[n][cap] = Math.max(arr[n - 1][1] + zeroOneKnapsack(arr, n - 1, cap - arr[n - 1][0], cache), zeroOneKnapsack(arr, n - 1, cap, cache))\\n    return cache[n][cap]\\n  } else {\\n    cache[n][cap] = zeroOneKnapsack(arr, n - 1, cap, cache)\\n    return cache[n][cap]\\n  }\\n}\\n\\nconst example = () => {\\n  /*\\n  Problem Statement:\\n  You are a thief carrying a single bag with limited capacity S. The museum you stole had N artifact that you could steal. Unfortunately you might not be able to steal all the artifact because of your limited bag capacity.\\n  You have to cherry pick the artifact in order to maximize the total value of the artifacts you stole.\\n\\n  Link for the Problem: https://www.hackerrank.com/contests/srin-aadc03/challenges/classic-01-knapsack\\n  */\\n  let input = `1\\n    4 5\\n    1 8\\n    2 4\\n    3 0\\n    2 5\\n    2 3`\\n\\n  input = input.trim().split('\\\\n')\\n  input.shift()\\n  const length = input.length\\n\\n  const output = []\\n\\n  let i = 0\\n  while (i < length) {\\n    const cap = Number(input[i].trim().split(' ')[0])\\n    const currlen = Number(input[i].trim().split(' ')[1])\\n    let j = i + 1\\n    const arr = []\\n    while (j <= i + currlen) {\\n      arr.push(input[j])\\n      j++\\n    }\\n    const newArr = arr.map(e =>\\n      e.trim().split(' ').map(Number)\\n    )\\n    const cache = []\\n    for (let i = 0; i <= currlen; i++) {\\n      const temp = []\\n      for (let j = 0; j <= cap; j++) {\\n        temp.push(-1)\\n      }\\n      cache.push(temp)\\n    }\\n    const result = zeroOneKnapsack(newArr, currlen, cap, cache)\\n    output.push(result)\\n    i += currlen + 1\\n  }\\n\\n  return output\\n}\\n\\nexport { zeroOneKnapsack, example }\\n\"",
    "convex hull graham": "\"/**\\n * Author: Arnab Ray\\n * ConvexHull using Graham Scan\\n * Wikipedia: https://en.wikipedia.org/wiki/Graham_scan\\n * Given a set of points in the plane. The Convex hull of the set is the smallest\\n * convex polygon that contains all the points of it.\\n */\\n\\nfunction compare (a, b) {\\n  // Compare Function to Sort the points, a and b are points to compare\\n  if (a.x < b.x) return -1\\n  if (a.x === b.x && a.y < b.y) return -1\\n  return 1\\n}\\nfunction orientation (a, b, c) {\\n  // Check orientation of Line(a,b) and Line(b,c)\\n  const alpha = (b.y - a.y) / (b.x - a.x)\\n  const beta = (c.y - b.y) / (c.x - b.x)\\n\\n  // Clockwise\\n  if (alpha > beta) return 1\\n  // Anticlockwise\\n  else if (beta > alpha) return -1\\n  // Colinear\\n  return 0\\n}\\n\\nfunction convexHull (points) {\\n  const pointsLen = points.length\\n  if (pointsLen <= 2) {\\n    throw new Error('Minimum of 3 points is required to form closed polygon!')\\n  }\\n\\n  points.sort(compare)\\n  const p1 = points[0]; const p2 = points[pointsLen - 1]\\n\\n  // Divide Hull in two halves\\n  const upperPoints = []; const lowerPoints = []\\n\\n  upperPoints.push(p1)\\n  lowerPoints.push(p1)\\n\\n  for (let i = 1; i < pointsLen; i++) {\\n    if (i === pointsLen - 1 || orientation(p1, points[i], p2) !== -1) {\\n      let upLen = upperPoints.length\\n\\n      while (upLen >= 2 && orientation(upperPoints[upLen - 2], upperPoints[upLen - 1], points[i]) === -1) {\\n        upperPoints.pop()\\n        upLen = upperPoints.length\\n      }\\n      upperPoints.push(points[i])\\n    }\\n    if (i === pointsLen - 1 || orientation(p1, points[i], p2) !== 1) {\\n      let lowLen = lowerPoints.length\\n      while (lowLen >= 2 && orientation(lowerPoints[lowLen - 2], lowerPoints[lowLen - 1], points[i]) === 1) {\\n        lowerPoints.pop()\\n        lowLen = lowerPoints.length\\n      }\\n      lowerPoints.push(points[i])\\n    }\\n  }\\n  const hull = []\\n  for (let i = 1; i < upperPoints.length - 1; i++) {\\n    hull.push(upperPoints[i])\\n  }\\n  for (let i = lowerPoints.length - 1; i >= 0; i--) {\\n    hull.push(lowerPoints[i])\\n  }\\n\\n  return hull\\n}\\n\\nexport { convexHull }\\n\\n// Example\\n\\n// const points = [\\n//   { x: 0, y: 3 },\\n//   { x: 1, y: 1 },\\n//   { x: 2, y: 2 },\\n//   { x: 4, y: 4 },\\n//   { x: 0, y: 0 },\\n//   { x: 1, y: 2 },\\n//   { x: 3, y: 1 },\\n//   { x: 3, y: 3 }]\\n\\n// convexHull(points)\\n\"",
    "bellman ford": "\"/*\\nThe Bellman–Ford algorithm is an algorithm that computes shortest paths\\nfrom a single source vertex to all of the other vertices in a weighted digraph.\\nIt also detects negative weight cycle.\\n\\nComplexity:\\n    Worst-case performance O(VE)\\n    Best-case performance O(E)\\n    Worst-case space complexity O(V)\\n\\nReference:\\n    https://en.wikipedia.org/wiki/Bellman–Ford_algorithm\\n    https://cp-algorithms.com/graph/bellman_ford.html\\n\\n*/\\n\\n/**\\n *\\n * @param graph Graph in the format (u, v, w) where\\n *  the edge is from vertex u to v. And weight\\n *  of the edge is w.\\n * @param V Number of vertices in graph\\n * @param E Number of edges in graph\\n * @param src Starting node\\n * @param dest Destination node\\n * @returns Shortest distance from source to destination\\n */\\nfunction BellmanFord (graph, V, E, src, dest) {\\n  // Initialize distance of all vertices as infinite.\\n  const dis = Array(V).fill(Infinity)\\n  // initialize distance of source as 0\\n  dis[src] = 0\\n\\n  // Relax all edges |V| - 1 times. A simple\\n  // shortest path from src to any other\\n  // vertex can have at-most |V| - 1 edges\\n  for (let i = 0; i < V - 1; i++) {\\n    for (let j = 0; j < E; j++) {\\n      if ((dis[graph[j][0]] + graph[j][2]) < dis[graph[j][1]]) { dis[graph[j][1]] = dis[graph[j][0]] + graph[j][2] }\\n    }\\n  }\\n  // check for negative-weight cycles.\\n  for (let i = 0; i < E; i++) {\\n    const x = graph[i][0]\\n    const y = graph[i][1]\\n    const weight = graph[i][2]\\n    if ((dis[x] !== Infinity) && (dis[x] + weight < dis[y])) {\\n      return null\\n    }\\n  }\\n  for (let i = 0; i < V; i++) {\\n    if (i === dest) return dis[i]\\n  }\\n}\\n\\nexport { BellmanFord }\\n\"",
    "breadth first search": "\"/**\\r\\n * Breadth-first search is an algorithm for traversing a graph.\\r\\n *\\r\\n * It discovers all nodes reachable from the starting position by exploring all of the neighbor nodes at the present\\r\\n * depth prior to moving on to the nodes at the next depth level.\\r\\n *\\r\\n * (description adapted from https://en.wikipedia.org/wiki/Breadth-first_search)\\r\\n * @see https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core\\r\\n */\\r\\nexport function breadthFirstSearch (graph, startingNode) {\\r\\n  // visited keeps track of all nodes visited\\r\\n  const visited = new Set()\\r\\n\\r\\n  // queue contains the nodes to be explored in the future\\r\\n  const queue = [startingNode]\\r\\n\\r\\n  while (queue.length > 0) {\\r\\n    // start with the queue's first node\\r\\n    const node = queue.shift()\\r\\n\\r\\n    if (!visited.has(node)) {\\r\\n      // mark the node as visited\\r\\n      visited.add(node)\\r\\n      const neighbors = graph[node]\\r\\n\\r\\n      // put all its neighbors into the queue\\r\\n      for (let i = 0; i < neighbors.length; i++) {\\r\\n        queue.push(neighbors[i])\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return visited\\r\\n}\\r\\n\"",
    "breadth first shortest path": "\"/**\\r\\n * Breadth-first approach can be applied to determine the shortest path between two nodes in an equi-weighted graph.\\r\\n *\\r\\n * It searches the target node among all neighbors of the starting node, then the process is repeated on the level of\\r\\n * the neighbors of the neighbors and so on.\\r\\n *\\r\\n * @see https://en.wikipedia.org/wiki/Breadth-first_search\\r\\n * @see https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core\\r\\n */\\r\\nexport function breadthFirstShortestPath (graph, startNode, targetNode) {\\r\\n  // check if startNode & targetNode are identical\\r\\n  if (startNode === targetNode) {\\r\\n    return [startNode]\\r\\n  }\\r\\n\\r\\n  // visited keeps track of all nodes visited\\r\\n  const visited = new Set()\\r\\n\\r\\n  // queue contains the paths to be explored in the future\\r\\n  const initialPath = [startNode]\\r\\n  const queue = [initialPath]\\r\\n\\r\\n  while (queue.length > 0) {\\r\\n    // start with the queue's first path\\r\\n    const path = queue.shift()\\r\\n    const node = path[path.length - 1]\\r\\n\\r\\n    // explore this node if it hasn't been visited yet\\r\\n    if (!visited.has(node)) {\\r\\n      // mark the node as visited\\r\\n      visited.add(node)\\r\\n\\r\\n      const neighbors = graph[node]\\r\\n\\r\\n      // create a new path in the queue for each neighbor\\r\\n      for (let i = 0; i < neighbors.length; i++) {\\r\\n        const newPath = path.concat([neighbors[i]])\\r\\n\\r\\n        // the first path to contain the target node is the shortest path\\r\\n        if (neighbors[i] === targetNode) {\\r\\n          return newPath\\r\\n        }\\r\\n\\r\\n        // queue the new path\\r\\n        queue.push(newPath)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // the target node was not reachable\\r\\n  return []\\r\\n}\\r\\n\"",
    "connected components": "\"class GraphUnweightedUndirectedAdjacencyList {\\n  // Unweighted Undirected Graph class\\n  constructor () {\\n    this.connections = {}\\n  }\\n\\n  addNode (node) {\\n    // Function to add a node to the graph (connection represented by set)\\n    this.connections[node] = new Set()\\n  }\\n\\n  addEdge (node1, node2) {\\n    // Function to add an edge (adds the node too if they are not present in the graph)\\n    if (!(node1 in this.connections)) { this.addNode(node1) }\\n    if (!(node2 in this.connections)) { this.addNode(node2) }\\n    this.connections[node1].add(node2)\\n    this.connections[node2].add(node1)\\n  }\\n\\n  DFSComponent (components, node, visited) {\\n    // Helper function to populate the visited set with the nodes in each component\\n\\n    // adding the first visited node in the component to the array\\n    components.push(node)\\n    const stack = [node]\\n    // populating the visited set using DFS (Iterative)\\n    while (stack.length > 0) {\\n      const curr = stack.pop()\\n      visited.add(curr.toString())\\n      for (const neighbour of this.connections[curr].keys()) {\\n        if (!visited.has(neighbour.toString())) { stack.push(neighbour) }\\n      }\\n    }\\n  }\\n\\n  connectedComponents () {\\n    // Function to generate the Connected Components\\n    // Result is an array containing 1 node from each component\\n    const visited = new Set()\\n    const components = []\\n    for (const node of Object.keys(this.connections)) {\\n      if (!visited.has(node.toString())) { this.DFSComponent(components, node, visited) }\\n    }\\n    return components\\n  }\\n}\\n\\nexport { GraphUnweightedUndirectedAdjacencyList }\\n\\n// Example\\n\\n// const graph = new GraphUnweightedUndirectedAdjacencyList()\\n// graph.addEdge(1, 2) // Component 1\\n// graph.addEdge(3, 4) // Component 2\\n// graph.addEdge(3, 5) // Component 2\\n// const components = graph.connectedComponents()\\n\"",
    "density": "\"/*\\nThe density of a network is a measure of how many edges exist proportional to\\nhow many edges would exist in a complete network (where all possible edges).\\nhttps://networkx.org/documentation/networkx-1.9/reference/generated/networkx.classes.function.density.html\\n*/\\nfunction density (numberOfNodes, numberOfEdges, isDirected = false) {\\n  const multi = isDirected ? 1 : 2\\n  return (multi * numberOfEdges) / (numberOfNodes * (numberOfNodes - 1))\\n}\\n\\nexport { density }\\n\"",
    "depth first search iterative": "\"class GraphUnweightedUndirected {\\n  // Unweighted Undirected Graph class\\n  constructor () {\\n    this.connections = {}\\n  }\\n\\n  addNode (node) {\\n    // Function to add a node to the graph (connection represented by set)\\n    this.connections[node] = new Set()\\n  }\\n\\n  addEdge (node1, node2) {\\n    // Function to add an edge (adds the node too if they are not present in the graph)\\n    if (!(node1 in this.connections)) { this.addNode(node1) }\\n    if (!(node2 in this.connections)) { this.addNode(node2) }\\n    this.connections[node1].add(node2)\\n    this.connections[node2].add(node1)\\n  }\\n\\n  DFSIterative (node, value) {\\n    // DFS Function to search if a node with the given value is present in the graph\\n    const stack = [node]\\n    const visited = new Set()\\n    while (stack.length > 0) {\\n      const currNode = stack.pop()\\n      // if the current node contains the value being searched for, true is returned\\n      if (currNode === value) { return true }\\n      // adding the current node to the visited set\\n      visited.add(currNode)\\n      // adding neighbours in the stack\\n      for (const neighbour of this.connections[currNode]) {\\n        if (!visited.has(neighbour)) {\\n          stack.push(neighbour)\\n        }\\n      }\\n    }\\n    return false\\n  }\\n}\\n\\nexport { GraphUnweightedUndirected }\\n\\n// Example\\n\\n// const graph = new GraphUnweightedUndirected()\\n// graph.addEdge(1, 2)\\n// graph.addEdge(2, 3)\\n// graph.addEdge(2, 4)\\n// graph.addEdge(3, 5)\\n// graph.DFSIterative(5, 1)\\n// graph.DFSIterative(5, 100)\\n\"",
    "depth first search recursive": "\"class GraphUnweightedUndirected {\\n  // Unweighted Undirected Graph class\\n  constructor () {\\n    this.connections = {}\\n  }\\n\\n  addNode (node) {\\n    // Function to add a node to the graph (connection represented by set)\\n    this.connections[node] = new Set()\\n  }\\n\\n  addEdge (node1, node2) {\\n    // Function to add an edge (adds the node too if they are not present in the graph)\\n    if (!(node1 in this.connections)) { this.addNode(node1) }\\n    if (!(node2 in this.connections)) { this.addNode(node2) }\\n    this.connections[node1].add(node2)\\n    this.connections[node2].add(node1)\\n  }\\n\\n  DFSRecursive (node, value, visited = new Set()) {\\n    // DFS Function to search if a node with the given value is present in the graph\\n    // checking if the searching node has been found\\n    if (node === value) { return true }\\n    // adding the current node to the visited set\\n    visited.add(node)\\n    // calling the helper function recursively for all unvisited nodes\\n    for (const neighbour of this.connections[node]) {\\n      if (!visited.has(neighbour)) {\\n        if (this.DFSRecursive(neighbour, value, visited)) { return true }\\n      }\\n    }\\n    return false\\n  }\\n}\\n\\nexport { GraphUnweightedUndirected }\\n\\n// const graph = new GraphUnweightedUndirected()\\n// graph.addEdge(1, 2)\\n// graph.addEdge(2, 3)\\n// graph.addEdge(2, 4)\\n// graph.addEdge(3, 5)\\n// graph.DFSRecursive(5, 1)\\n// graph.DFSRecursive(5, 100)\\n\"",
    "dijkstra": "\"/**\\n * Author: Samarth Jain\\n * Dijkstra's Algorithm implementation in JavaScript\\n * Dijkstra's Algorithm calculates the minimum distance between two nodes.\\n * It is used to find the shortest path.\\n * It uses graph data structure.\\n */\\n\\nfunction createGraph (V, E) {\\n  // V - Number of vertices in graph\\n  // E - Number of edges in graph (u,v,w)\\n  const adjList = [] // Adjacency list\\n  for (let i = 0; i < V; i++) {\\n    adjList.push([])\\n  }\\n  for (let i = 0; i < E.length; i++) {\\n    adjList[E[i][0]].push([E[i][1], E[i][2]])\\n    adjList[E[i][1]].push([E[i][0], E[i][2]])\\n  }\\n  return adjList\\n}\\n\\nfunction djikstra (graph, V, src) {\\n  const vis = Array(V).fill(0)\\n  const dist = []\\n  for (let i = 0; i < V; i++) dist.push([10000, -1])\\n  dist[src][0] = 0\\n\\n  for (let i = 0; i < V - 1; i++) {\\n    let mn = -1\\n    for (let j = 0; j < V; j++) {\\n      if (vis[j] === 0) {\\n        if (mn === -1 || dist[j][0] < dist[mn][0]) mn = j\\n      }\\n    }\\n\\n    vis[mn] = 1\\n    for (let j = 0; j < graph[mn].length; j++) {\\n      const edge = graph[mn][j]\\n      if (vis[edge[0]] === 0 && dist[edge[0]][0] > dist[mn][0] + edge[1]) {\\n        dist[edge[0]][0] = dist[mn][0] + edge[1]\\n        dist[edge[0]][1] = mn\\n      }\\n    }\\n  }\\n\\n  return dist\\n}\\n\\nexport { createGraph, djikstra }\\n\\n// const V = 9\\n// const E = [\\n//   [0, 1, 4],\\n//   [0, 7, 8],\\n//   [1, 7, 11],\\n//   [1, 2, 8],\\n//   [7, 8, 7],\\n//   [6, 7, 1],\\n//   [2, 8, 2],\\n//   [6, 8, 6],\\n//   [5, 6, 2],\\n//   [2, 5, 4],\\n//   [2, 3, 7],\\n//   [3, 5, 14],\\n//   [3, 4, 9],\\n//   [4, 5, 10]\\n// ]\\n\\n// const graph = createGraph(V, E)\\n// const distances = djikstra(graph, V, 0)\\n\\n/**\\n * The first value in the array determines the minimum distance and the\\n * second value represents the parent node from which the minimum distance has been calculated\\n */\\n\"",
    "dijkstra smallest path": "\"// starting at s\\nfunction solve (graph, s) {\\n  const solutions = {}\\n  solutions[s] = []\\n  solutions[s].dist = 0\\n\\n  while (true) {\\n    let p = null\\n    let neighbor = null\\n    let dist = Infinity\\n\\n    for (const n in solutions) {\\n      if (!solutions[n]) { continue }\\n      const ndist = solutions[n].dist\\n      const adj = graph[n]\\n\\n      for (const a in adj) {\\n        if (solutions[a]) { continue }\\n\\n        const d = adj[a] + ndist\\n        if (d < dist) {\\n          p = solutions[n]\\n          neighbor = a\\n          dist = d\\n        }\\n      }\\n    }\\n\\n    // no more solutions\\n    if (dist === Infinity) {\\n      break\\n    }\\n\\n    // extend parent's solution path\\n    solutions[neighbor] = p.concat(neighbor)\\n    // extend parent's cost\\n    solutions[neighbor].dist = dist\\n  }\\n\\n  return solutions\\n}\\n\\nexport { solve }\\n\\n// // create graph\\n// const graph = {}\\n\\n// const layout = {\\n//   R: ['2'],\\n//   2: ['3', '4'],\\n//   3: ['4', '6', '13'],\\n//   4: ['5', '8'],\\n//   5: ['7', '11'],\\n//   6: ['13', '15'],\\n//   7: ['10'],\\n//   8: ['11', '13'],\\n//   9: ['14'],\\n//   10: [],\\n//   11: ['12'],\\n//   12: [],\\n//   13: ['14'],\\n//   14: [],\\n//   15: []\\n// }\\n\\n// // convert uni-directional to bi-directional graph\\n// let  graph = {\\n//     a: {e:1, b:1, g:3},\\n//     b: {a:1, c:1},\\n//     c: {b:1, d:1},\\n//     d: {c:1, e:1},\\n//     e: {d:1, a:1},\\n//     f: {g:1, h:1},\\n//     g: {a:3, f:1},\\n//     h: {f:1}\\n// };\\n\\n// for (const id in layout) {\\n//   if (!graph[id]) { graph[id] = {} }\\n//   layout[id].forEach(function (aid) {\\n//     graph[id][aid] = 1\\n//     if (!graph[aid]) { graph[aid] = {} }\\n//     graph[aid][id] = 1\\n//   })\\n// }\\n\\n// // choose start node\\n// const start = '10'\\n// // get all solutions\\n// const solutions = solve(graph, start)\\n\\n// // for s in solutions..\\n// ' -> ' + s + ': [' + solutions[s].join(', ') + ']   (dist:' + solutions[s].dist + ')'\\n\\n// From '10' to\\n//  -> 2: [7, 5, 4, 2]   (dist:4)\\n//  -> 3: [7, 5, 4, 3]   (dist:4)\\n//  -> 4: [7, 5, 4]   (dist:3)\\n//  -> 5: [7, 5]   (dist:2)\\n//  -> 6: [7, 5, 4, 3, 6]   (dist:5)\\n//  -> 7: [7]   (dist:1)\\n//  -> 8: [7, 5, 4, 8]   (dist:4)\\n//  -> 9: [7, 5, 4, 3, 13, 14, 9]   (dist:7)\\n//  -> 10: []   (dist:0)\\n//  -> 11: [7, 5, 11]   (dist:3)\\n//  -> 12: [7, 5, 11, 12]   (dist:4)\\n//  -> 13: [7, 5, 4, 3, 13]   (dist:5)\\n//  -> 14: [7, 5, 4, 3, 13, 14]   (dist:6)\\n//  -> 15: [7, 5, 4, 3, 6, 15]   (dist:6)\\n//  -> R: [7, 5, 4, 2, R]   (dist:5)\\n\"",
    "floyd warshall": "\"/*\\n  Source:\\n    https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\n  Complexity:\\n    O(|V|^3) where V is the set of vertices\\n*/\\n\\nconst FloydWarshall = (dist) => {\\n  // Input:- dist: 2D Array where dist[i][j] = edge weight b/w i and j\\n  // Output:- dist: 2D Array where dist[i][j] = shortest dist b/w i and j\\n  const n = dist.length\\n  for (let k = 0; k < n; k++) {\\n    for (let i = 0; i < n; i++) {\\n      for (let j = 0; j < n; j++) {\\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\\n          // dist from i to j via k is lesser than the current distance\\n          dist[i][j] = dist[i][k] + dist[k][j]\\n        }\\n      }\\n    }\\n  }\\n  return dist\\n}\\n\\nexport { FloydWarshall }\\n\\n// For the following graph (edge weights are shown in brackets)\\n//  4       1       dist[1][2] = dist[2][1] = 1\\n//   \\\\  (2)/ \\\\      dist[1][3] = dist[3][1] = 2\\n//    \\\\   /   \\\\(1)  dist[1][4] = dist[4][1] = Infinity\\n//  (1)\\\\ /     \\\\    dist[3][4] = dist[4][3] = 1\\n//      3       2   dist[2][4] = dist[4][2] = Infinity\\n//                  dist[2][3] = dist[3][2] = Infinity\\n// Output should be:\\n// [ [0, 1, 2, 3],\\n//   [1, 0, 3, 4],\\n//   [2, 3, 0, 1],\\n//   [3, 4, 1, 0] ]\\n\\n// FloydWarshall(\\n//     [[0, 1, 2, Infinity],\\n//       [1, 0, Infinity, Infinity],\\n//       [2, Infinity, 0, 1],\\n//       [Infinity, Infinity, 1, 0]\\n//     ]\\n//   )\\n\"",
    "kruskal m s t": "\"class DisjointSetTreeNode {\\n  // Disjoint Set Node to store the parent and rank\\n  constructor (key) {\\n    this.key = key\\n    this.parent = this\\n    this.rank = 0\\n  }\\n}\\n\\nclass DisjointSetTree {\\n  // Disjoint Set DataStructure\\n  constructor () {\\n    // map to from node name to the node object\\n    this.map = {}\\n  }\\n\\n  makeSet (x) {\\n    // Function to create a new set with x as its member\\n    this.map[x] = new DisjointSetTreeNode(x)\\n  }\\n\\n  findSet (x) {\\n    // Function to find the set x belongs to (with path-compression)\\n    if (this.map[x] !== this.map[x].parent) {\\n      this.map[x].parent = this.findSet(this.map[x].parent.key)\\n    }\\n    return this.map[x].parent\\n  }\\n\\n  union (x, y) {\\n    // Function to merge 2 disjoint sets\\n    this.link(this.findSet(x), this.findSet(y))\\n  }\\n\\n  link (x, y) {\\n    // Helper function for union operation\\n    if (x.rank > y.rank) {\\n      y.parent = x\\n    } else {\\n      x.parent = y\\n      if (x.rank === y.rank) {\\n        y.rank += 1\\n      }\\n    }\\n  }\\n}\\n\\nclass GraphWeightedUndirectedAdjacencyList {\\n  // Weighted Undirected Graph class\\n  constructor () {\\n    this.connections = {}\\n    this.nodes = 0\\n  }\\n\\n  addNode (node) {\\n    // Function to add a node to the graph (connection represented by set)\\n    this.connections[node] = {}\\n    this.nodes += 1\\n  }\\n\\n  addEdge (node1, node2, weight) {\\n    // Function to add an edge (adds the node too if they are not present in the graph)\\n    if (!(node1 in this.connections)) { this.addNode(node1) }\\n    if (!(node2 in this.connections)) { this.addNode(node2) }\\n    this.connections[node1][node2] = weight\\n    this.connections[node2][node1] = weight\\n  }\\n\\n  KruskalMST () {\\n    // Kruskal's Algorithm to generate a Minimum Spanning Tree (MST) of a graph\\n    // Details: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\\n    // getting the edges in ascending order of weights\\n    const edges = []\\n    const seen = new Set()\\n    for (const start of Object.keys(this.connections)) {\\n      for (const end of Object.keys(this.connections[start])) {\\n        if (!seen.has(`${start} ${end}`)) {\\n          seen.add(`${end} ${start}`)\\n          edges.push([start, end, this.connections[start][end]])\\n        }\\n      }\\n    }\\n    edges.sort((a, b) => a[2] - b[2])\\n    // creating the disjoint set\\n    const disjointSet = new DisjointSetTree()\\n    Object.keys(this.connections).forEach(node => disjointSet.makeSet(node))\\n    // MST generation\\n    const graph = new GraphWeightedUndirectedAdjacencyList()\\n    let numEdges = 0\\n    let index = 0\\n    while (numEdges < this.nodes - 1) {\\n      const [u, v, w] = edges[index]\\n      index += 1\\n      if (disjointSet.findSet(u) !== disjointSet.findSet(v)) {\\n        numEdges += 1\\n        graph.addEdge(u, v, w)\\n        disjointSet.union(u, v)\\n      }\\n    }\\n    return graph\\n  }\\n}\\n\\nexport { GraphWeightedUndirectedAdjacencyList }\\n\\n// const graph = new GraphWeightedUndirectedAdjacencyList()\\n// graph.addEdge(1, 2, 1)\\n// graph.addEdge(2, 3, 2)\\n// graph.addEdge(3, 4, 1)\\n// graph.addEdge(3, 5, 100) // Removed in MST\\n// graph.addEdge(4, 5, 5)\\n// graph.KruskalMST()\\n\"",
    "node neighbors": "\"// https://en.wikipedia.org/wiki/Neighbourhood_(graph_theory)\\n\\nclass Graph {\\n  // Generic graph: the algorithm works regardless of direction or weight\\n  constructor () {\\n    this.edges = []\\n  }\\n\\n  addEdge (node1, node2) {\\n    // Adding edges to the graph\\n    this.edges.push({\\n      node1,\\n      node2\\n    })\\n  }\\n\\n  nodeNeighbors (node) {\\n    // Returns an array with all of the node neighbors\\n    const neighbors = new Set()\\n    for (const edge of this.edges) {\\n      // Checks if they have an edge between them and if the neighbor is not\\n      // already in the neighbors array\\n      if (edge.node1 === node && !(neighbors.has(edge.node2))) {\\n        neighbors.add(edge.node2)\\n      } else if (edge.node2 === node && !(neighbors.has(edge.node1))) {\\n        neighbors.add(edge.node1)\\n      }\\n    }\\n    return neighbors\\n  }\\n}\\n\\nexport { Graph }\\n\\n// const graph = new Graph()\\n// graph.addEdge(1, 2)\\n// graph.addEdge(2, 3)\\n// graph.addEdge(3, 5)\\n// graph.addEdge(1, 5)\\n// graph.nodeNeighbors(1)\\n\"",
    "number of islands": "\"/* Number of Islands\\nhttps://dev.to/rattanakchea/amazons-interview-question-count-island-21h6\\nGiven a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\n\\na two dimensional grid map\\neach element is going to represent a piece of land\\n1 is land,\\n0 is water\\noutput a number which is the number of islands\\n\\nExample 1:\\n  Input:\\n  11110\\n  11010\\n  11000\\n  00000\\n\\n  Output: 1\\n\\nExample 2:\\n  Input:\\n  11000\\n  11000\\n  00100\\n  00011\\n\\n  Output: 3\\n\\nI: two dimensional array\\nO: a single integer; total number of islands\\n\\nPseudocode:\\n  OUTER FUNCTION\\n    set count to 0\\n\\n    INNER FUNCTION - flood (col, row)\\n      if the tile is water\\n        return\\n      make tile water(flood tile)\\n      invoke flood on the neighbor coordinates\\n\\n    iterate over the matrix (col, row)\\n      if the current element is a 1\\n        increment count\\n        invoke flood (coordinates for col and row)\\n\\n    Return the count\\n*/\\n\\nconst islands = (matrixGrid) => {\\n  const matrix = matrixGrid\\n  let counter = 0\\n\\n  const flood = (row, col) => {\\n    if (row < 0 || col < 0) return // Off the map above or left\\n    if (row >= matrix.length || col >= matrix[row].length) return // Off the map below or right\\n\\n    const tile = matrix[row][col]\\n    if (tile !== '1') return\\n\\n    matrix[row][col] = '0'\\n\\n    flood(row + 1, col) // Down\\n    flood(row - 1, col) // Up\\n    flood(row, col + 1) // Right\\n    flood(row, col - 1) // Left\\n  }\\n\\n  for (let row = 0; row < matrix.length; row += 1) {\\n    for (let col = 0; col < matrix[row].length; col += 1) {\\n      const current = matrix[row][col]\\n      if (current === '1') {\\n        flood(row, col)\\n        counter += 1\\n      }\\n    }\\n  }\\n  return counter\\n}\\n\\nexport { islands }\\n\\n// islands(\\n//   ['1', '1', '0', '0', '0'],\\n//   ['1', '1', '0', '0', '0'],\\n//   ['0', '0', '1', '0', '0'],\\n//   ['0', '0', '0', '1', '1']\\n// )\\n\"",
    "prim m s t": "\"// Priority Queue Helper functions\\nfunction getParentPosition (position) {\\n  // Get the parent node of the current node\\n  return Math.floor((position - 1) / 2)\\n}\\nfunction getChildrenPosition (position) {\\n  // Get the children nodes of the current node\\n  return [2 * position + 1, 2 * position + 2]\\n}\\n\\nclass PriorityQueue {\\n  // Priority Queue class using Minimum Binary Heap\\n  constructor () {\\n    this._heap = []\\n    this.keys = {}\\n  }\\n\\n  isEmpty () {\\n    // Checking if the heap is empty\\n    return this._heap.length === 0\\n  }\\n\\n  push (key, priority) {\\n    // Adding element to the queue (equivalent to add)\\n    this._heap.push([key, priority])\\n    this.keys[key] = this._heap.length - 1\\n    this._shiftUp(this.keys[key])\\n  }\\n\\n  pop () {\\n    // Removing the element with least priority (equivalent to extractMin)\\n    this._swap(0, this._heap.length - 1)\\n    const [key] = this._heap.pop()\\n    delete this.keys[key]\\n    this._shiftDown(0)\\n    return key\\n  }\\n\\n  contains (key) {\\n    // Check if a given key is present in the queue\\n    return (key in this.keys)\\n  }\\n\\n  update (key, priority) {\\n    // Update the priority of the given element (equivalent to decreaseKey)\\n    const currPos = this.keys[key]\\n    this._heap[currPos][1] = priority\\n    const parentPos = getParentPosition(currPos)\\n    const currPriority = this._heap[currPos][1]\\n    let parentPriority = Infinity\\n    if (parentPos >= 0) {\\n      parentPriority = this._heap[parentPos][1]\\n    }\\n    const [child1Pos, child2Pos] = getChildrenPosition(currPos)\\n    let [child1Priority, child2Priority] = [Infinity, Infinity]\\n    if (child1Pos < this._heap.length) {\\n      child1Priority = this._heap[child1Pos][1]\\n    }\\n    if (child2Pos < this._heap.length) {\\n      child2Priority = this._heap[child2Pos][1]\\n    }\\n\\n    if (parentPos >= 0 && parentPriority > currPriority) {\\n      this._shiftUp(currPos)\\n    } else if (child2Pos < this._heap.length &&\\n      (child1Priority < currPriority || child2Priority < currPriority)) {\\n      this._shiftDown(currPos)\\n    }\\n  }\\n\\n  _shiftUp (position) {\\n    // Helper function to shift up a node to proper position (equivalent to bubbleUp)\\n    let currPos = position\\n    let parentPos = getParentPosition(currPos)\\n    let currPriority = this._heap[currPos][1]\\n    let parentPriority = Infinity\\n    if (parentPos >= 0) {\\n      parentPriority = this._heap[parentPos][1]\\n    }\\n\\n    while (parentPos >= 0 && parentPriority > currPriority) {\\n      this._swap(currPos, parentPos)\\n      currPos = parentPos\\n      parentPos = getParentPosition(currPos)\\n      currPriority = this._heap[currPos][1]\\n      try {\\n        parentPriority = this._heap[parentPos][1]\\n      } catch (error) {\\n        parentPriority = Infinity\\n      }\\n    }\\n    this.keys[this._heap[currPos][0]] = currPos\\n  }\\n\\n  _shiftDown (position) {\\n    // Helper function to shift down a node to proper position (equivalent to bubbleDown)\\n    let currPos = position\\n    let [child1Pos, child2Pos] = getChildrenPosition(currPos)\\n    let [child1Priority, child2Priority] = [Infinity, Infinity]\\n    if (child1Pos < this._heap.length) {\\n      child1Priority = this._heap[child1Pos][1]\\n    }\\n    if (child2Pos < this._heap.length) {\\n      child2Priority = this._heap[child2Pos][1]\\n    }\\n    let currPriority\\n    try {\\n      currPriority = this._heap[currPos][1]\\n    } catch {\\n      return\\n    }\\n\\n    while (child2Pos < this._heap.length &&\\n      (child1Priority < currPriority || child2Priority < currPriority)) {\\n      if (child1Priority < currPriority && child1Priority < child2Priority) {\\n        this._swap(child1Pos, currPos)\\n        currPos = child1Pos\\n      } else {\\n        this._swap(child2Pos, currPos)\\n        currPos = child2Pos\\n      }\\n      [child1Pos, child2Pos] = getChildrenPosition(currPos)\\n      try {\\n        [child1Priority, child2Priority] = [this._heap[child1Pos][1], this._heap[child2Pos][1]]\\n      } catch (error) {\\n        [child1Priority, child2Priority] = [Infinity, Infinity]\\n      }\\n\\n      currPriority = this._heap[currPos][1]\\n    }\\n    this.keys[this._heap[currPos][0]] = currPos\\n    if (child1Pos < this._heap.length && child1Priority < currPriority) {\\n      this._swap(child1Pos, currPos)\\n      this.keys[this._heap[child1Pos][0]] = child1Pos\\n    }\\n  }\\n\\n  _swap (position1, position2) {\\n    // Helper function to swap 2 nodes\\n    [this._heap[position1], this._heap[position2]] = [this._heap[position2], this._heap[position1]]\\n    this.keys[this._heap[position1][0]] = position1\\n    this.keys[this._heap[position2][0]] = position2\\n  }\\n}\\n\\nclass GraphWeightedUndirectedAdjacencyList {\\n  // Weighted Undirected Graph class\\n  constructor () {\\n    this.connections = {}\\n  }\\n\\n  addNode (node) {\\n    // Function to add a node to the graph (connection represented by set)\\n    this.connections[node] = {}\\n  }\\n\\n  addEdge (node1, node2, weight) {\\n    // Function to add an edge (adds the node too if they are not present in the graph)\\n    if (!(node1 in this.connections)) { this.addNode(node1) }\\n    if (!(node2 in this.connections)) { this.addNode(node2) }\\n    this.connections[node1][node2] = weight\\n    this.connections[node2][node1] = weight\\n  }\\n\\n  PrimMST (start) {\\n    // Prim's Algorithm to generate a Minimum Spanning Tree (MST) of a graph\\n    // Details: https://en.wikipedia.org/wiki/Prim%27s_algorithm\\n    const distance = {}\\n    const parent = {}\\n    const priorityQueue = new PriorityQueue()\\n    // Initialization\\n    for (const node in this.connections) {\\n      distance[node] = (node === start.toString() ? 0 : Infinity)\\n      parent[node] = null\\n      priorityQueue.push(node, distance[node])\\n    }\\n    // Updating 'distance' object\\n    while (!priorityQueue.isEmpty()) {\\n      const node = priorityQueue.pop()\\n      Object.keys(this.connections[node]).forEach(neighbour => {\\n        if (priorityQueue.contains(neighbour) && distance[node] + this.connections[node][neighbour] < distance[neighbour]) {\\n          distance[neighbour] = distance[node] + this.connections[node][neighbour]\\n          parent[neighbour] = node\\n          priorityQueue.update(neighbour, distance[neighbour])\\n        }\\n      })\\n    }\\n\\n    // MST Generation from the 'parent' object\\n    const graph = new GraphWeightedUndirectedAdjacencyList()\\n    Object.keys(parent).forEach(node => {\\n      if (node && parent[node]) {\\n        graph.addEdge(node, parent[node], this.connections[node][parent[node]])\\n      }\\n    })\\n    return graph\\n  }\\n}\\n\\nexport { GraphWeightedUndirectedAdjacencyList }\\n\\n// const graph = new GraphWeightedUndirectedAdjacencyList()\\n// graph.addEdge(1, 2, 1)\\n// graph.addEdge(2, 3, 2)\\n// graph.addEdge(3, 4, 1)\\n// graph.addEdge(3, 5, 100) // Removed in MST\\n// graph.addEdge(4, 5, 5)\\n// graph.PrimMST(1)\\n\"",
    "s h a1": "\"//= ===============================================================\\n// SHA1.js\\n//\\n// Module that replicates the SHA-1 Cryptographic Hash\\n// function in Javascript.\\n//= ===============================================================\\n\\n// main variables\\nconst CHAR_SIZE = 8\\n\\n/**\\n * Adds padding to binary/hex string representation\\n *\\n * @param {string} str - string representation (binary/hex)\\n * @param {int} bits - total number of bits wanted\\n * @return {string} - string representation padding with empty (0) bits\\n *\\n * @example\\n *      pad(\\\"10011\\\", 8); // \\\"00010011\\\"\\n */\\nfunction pad (str, bits) {\\n  let res = str\\n  while (res.length % bits !== 0) {\\n    res = '0' + res\\n  }\\n  return res\\n}\\n\\n/**\\n * Separates string into chunks of the same size\\n *\\n * @param {string} str - string to separate into chunks\\n * @param {int} size - number of characters wanted in each chunk\\n * @return {array} - array of original string split into chunks\\n *\\n * @example\\n *      chunkify(\\\"this is a test\\\", 2)\\n */\\nfunction chunkify (str, size) {\\n  const chunks = []\\n  for (let i = 0; i < str.length; i += size) {\\n    chunks.push(str.slice(i, i + size))\\n  }\\n  return chunks\\n}\\n\\n/**\\n * Rotates string representation of bits to the left\\n *\\n * @param {string} bits - string representation of bits\\n * @param {int} turns - number of rotations to make\\n * @return {string} - string representation of bits after rotation\\n *\\n * @example\\n *      rotateLeft(\\\"1011\\\", 3); // \\\"1101\\\"\\n */\\nfunction rotateLeft (bits, turns) {\\n  return bits.substr(turns) + bits.substr(0, turns)\\n}\\n\\n/**\\n * Pre-processes message to feed the algorithm loop\\n *\\n * @param {string} message - message to pre-process\\n * @return {string} - processed message\\n */\\nfunction preProcess (message) {\\n  // convert message to binary representation padded to\\n  // 8 bits, and add 1\\n  let m = message.split('')\\n    .map(e => e.charCodeAt(0))\\n    .map(e => e.toString(2))\\n    .map(e => pad(e, 8))\\n    .join('') + '1'\\n\\n  // extend message by adding empty bits (0)\\n  while (m.length % 512 !== 448) {\\n    m += '0'\\n  }\\n\\n  // length of message in binary, padded, and extended\\n  // to a 64 bit representation\\n  let ml = (message.length * CHAR_SIZE).toString(2)\\n  ml = pad(ml, 8)\\n  ml = '0'.repeat(64 - ml.length) + ml\\n\\n  return m + ml\\n}\\n\\n/**\\n * Hashes message using SHA-1 Cryptographic Hash Function\\n *\\n * @param {string} message - message to hash\\n * @return {string} - message digest (hash value)\\n */\\nfunction SHA1 (message) {\\n  // main variables\\n  let H0 = 0x67452301\\n  let H1 = 0xEFCDAB89\\n  let H2 = 0x98BADCFE\\n  let H3 = 0x10325476\\n  let H4 = 0xC3D2E1F0\\n\\n  // pre-process message and split into 512 bit chunks\\n  const bits = preProcess(message)\\n  const chunks = chunkify(bits, 512)\\n\\n  chunks.forEach(function (chunk, i) {\\n    // break each chunk into 16 32-bit words\\n    const words = chunkify(chunk, 32)\\n\\n    // extend 16 32-bit words to 80 32-bit words\\n    for (let i = 16; i < 80; i++) {\\n      const val = [words[i - 3], words[i - 8], words[i - 14], words[i - 16]]\\n        .map(e => parseInt(e, 2))\\n        .reduce((acc, curr) => curr ^ acc, 0)\\n      const bin = (val >>> 0).toString(2)\\n      const paddedBin = pad(bin, 32)\\n      const word = rotateLeft(paddedBin, 1)\\n      words.push(word)\\n    }\\n\\n    // initialize variables for this chunk\\n    let [a, b, c, d, e] = [H0, H1, H2, H3, H4]\\n\\n    for (let i = 0; i < 80; i++) {\\n      let f, k\\n      if (i < 20) {\\n        f = (b & c) | (~b & d)\\n        k = 0x5A827999\\n      } else if (i < 40) {\\n        f = b ^ c ^ d\\n        k = 0x6ED9EBA1\\n      } else if (i < 60) {\\n        f = (b & c) | (b & d) | (c & d)\\n        k = 0x8F1BBCDC\\n      } else {\\n        f = b ^ c ^ d\\n        k = 0xCA62C1D6\\n      }\\n      // make sure f is unsigned\\n      f >>>= 0\\n\\n      const aRot = rotateLeft(pad(a.toString(2), 32), 5)\\n      const aInt = parseInt(aRot, 2) >>> 0\\n      const wordInt = parseInt(words[i], 2) >>> 0\\n      const t = aInt + f + e + k + wordInt\\n      e = d >>> 0\\n      d = c >>> 0\\n      const bRot = rotateLeft(pad(b.toString(2), 32), 30)\\n      c = parseInt(bRot, 2) >>> 0\\n      b = a >>> 0\\n      a = t >>> 0\\n    }\\n\\n    // add values for this chunk to main hash variables (unsigned)\\n    H0 = (H0 + a) >>> 0\\n    H1 = (H1 + b) >>> 0\\n    H2 = (H2 + c) >>> 0\\n    H3 = (H3 + d) >>> 0\\n    H4 = (H4 + e) >>> 0\\n  })\\n\\n  // combine hash values of main hash variables and return\\n  const HH = [H0, H1, H2, H3, H4]\\n    .map(e => e.toString(16))\\n    .map(e => pad(e, 8))\\n    .join('')\\n\\n  return HH\\n}\\n\\n// export SHA1 function\\nexport { SHA1 }\\n\"",
    "s h a256": "\"//= ===============================================================\\n// SHA256.js\\n//\\n// Module that replicates the SHA-256 Cryptographic Hash\\n// function in Javascript.\\n//= ===============================================================\\n\\n// main variables\\nconst CHAR_SIZE = 8\\n\\nconst K = [\\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\\n]\\n\\n/**\\n * Adds padding to binary/hex string representation\\n *\\n * @param {string} str - string representation (binary/hex)\\n * @param {int} bits - total number of bits wanted\\n * @return {string} - string representation padding with empty (0) bits\\n *\\n * @example\\n *      pad(\\\"10011\\\", 8); // \\\"00010011\\\"\\n */\\nfunction pad (str, bits) {\\n  let res = str\\n  while (res.length % bits !== 0) {\\n    res = '0' + res\\n  }\\n  return res\\n}\\n\\n/**\\n * Separates string into chunks of the same size\\n *\\n * @param {string} str - string to separate into chunks\\n * @param {int} size - number of characters wanted in each chunk\\n * @return {array} - array of original string split into chunks\\n *\\n * @example\\n *      chunkify(\\\"this is a test\\\", 2)\\n */\\nfunction chunkify (str, size) {\\n  const chunks = []\\n  for (let i = 0; i < str.length; i += size) {\\n    chunks.push(str.slice(i, i + size))\\n  }\\n  return chunks\\n}\\n\\n/**\\n * Rotates string representation of bits to th left\\n *\\n * @param {string} bits - string representation of bits\\n * @param {int} turns - number of rotations to make\\n * @return {string} - string representation of bits after rotation\\n *\\n * @example\\n *      rotateLeft(\\\"1011\\\", 3); // \\\"1101\\\"\\n */\\nfunction rotateRight (bits, turns) {\\n  return bits.substr(bits.length - turns) + bits.substr(0, bits.length - turns)\\n}\\n\\n/**\\n * Pre-processes message to feed the algorithm loop\\n *\\n * @param {string} message - message to pre-process\\n * @return {string} - processed message\\n */\\nfunction preProcess (message) {\\n  // convert message to binary representation padded to\\n  // 8 bits, and add 1\\n  let m = message.split('')\\n    .map(e => e.charCodeAt(0))\\n    .map(e => e.toString(2))\\n    .map(e => pad(e, 8))\\n    .join('') + '1'\\n\\n  // extend message by adding empty bits (0)\\n  while (m.length % 512 !== 448) {\\n    m += '0'\\n  }\\n\\n  // length of message in binary, padded, and extended\\n  // to a 64 bit representation\\n  let ml = (message.length * CHAR_SIZE).toString(2)\\n  ml = pad(ml, 8)\\n  ml = '0'.repeat(64 - ml.length) + ml\\n\\n  return m + ml\\n}\\n\\n/**\\n * Hashes message using SHA-256 Cryptographic Hash Function\\n *\\n * @param {string} message - message to hash\\n * @return {string} - message digest (hash value)\\n */\\nfunction SHA256 (message) {\\n  // initial hash variables\\n  let H0 = 0x6a09e667\\n  let H1 = 0xbb67ae85\\n  let H2 = 0x3c6ef372\\n  let H3 = 0xa54ff53a\\n  let H4 = 0x510e527f\\n  let H5 = 0x9b05688c\\n  let H6 = 0x1f83d9ab\\n  let H7 = 0x5be0cd19\\n\\n  // pre-process message and split into 512 bit chunks\\n  const bits = preProcess(message)\\n  const chunks = chunkify(bits, 512)\\n\\n  chunks.forEach(function (chunk, i) {\\n    // break each chunk into 16 32-bit words\\n    const words = chunkify(chunk, 32)\\n\\n    // extend 16 32-bit words to 80 32-bit words\\n    for (let i = 16; i < 64; i++) {\\n      const W1 = words[i - 15]\\n      const W2 = words[i - 2]\\n      const R1 = rotateRight(W1, 7)\\n      const R2 = rotateRight(W1, 18)\\n      const R3 = rotateRight(W2, 17)\\n      const R4 = rotateRight(W2, 19)\\n      const S0 = parseInt(R1, 2) ^ parseInt(R2, 2) ^ (parseInt(W1, 2) >>> 3)\\n      const S1 = parseInt(R3, 2) ^ parseInt(R4, 2) ^ (parseInt(W2, 2) >>> 10)\\n      const val = parseInt(words[i - 16], 2) + S0 + parseInt(words[i - 7], 2) + S1\\n      words[i] = pad((val >>> 0).toString(2), 32)\\n    }\\n\\n    // initialize variables for this chunk\\n    let [a, b, c, d, e, f, g, h] = [H0, H1, H2, H3, H4, H5, H6, H7]\\n\\n    for (let i = 0; i < 64; i++) {\\n      const S1 = [6, 11, 25]\\n        .map(turns => rotateRight(pad(e.toString(2), 32), turns))\\n        .map(bitstring => parseInt(bitstring, 2))\\n        .reduce((acc, curr) => acc ^ curr, 0) >>> 0\\n      const CH = ((e & f) ^ (~e & g)) >>> 0\\n      const temp1 = (h + S1 + CH + K[i] + parseInt(words[i], 2)) >>> 0\\n      const S0 = [2, 13, 22]\\n        .map(turns => rotateRight(pad(a.toString(2), 32), turns))\\n        .map(bitstring => parseInt(bitstring, 2))\\n        .reduce((acc, curr) => acc ^ curr, 0) >>> 0\\n      const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0\\n      const temp2 = (S0 + maj) >>> 0\\n\\n      h = g\\n      g = f\\n      f = e\\n      e = (d + temp1) >>> 0\\n      d = c\\n      c = b\\n      b = a\\n      a = (temp1 + temp2) >>> 0\\n    }\\n\\n    // add values for this chunk to main hash variables (unsigned)\\n    H0 = (H0 + a) >>> 0\\n    H1 = (H1 + b) >>> 0\\n    H2 = (H2 + c) >>> 0\\n    H3 = (H3 + d) >>> 0\\n    H4 = (H4 + e) >>> 0\\n    H5 = (H5 + f) >>> 0\\n    H6 = (H6 + g) >>> 0\\n    H7 = (H7 + h) >>> 0\\n  })\\n\\n  // combine hash values of main hash variables and return\\n  const HH = [H0, H1, H2, H3, H4, H5, H6, H7]\\n    .map(e => e.toString(16))\\n    .map(e => pad(e, 8))\\n    .join('')\\n\\n  return HH\\n}\\n\\n// export SHA256 function\\nexport { SHA256 }\\n\"",
    "abs": "\"/**\\n * @function absVal\\n * @description This script will find the absolute value of a number.\\n * @param {Integer} num - The input integer\\n * @return {Integer} - Absolute number of num.\\n * @see [Absolute_value](https://en.wikipedia.org/wiki/Absolute_value)\\n * @example absVal(-10) = 10\\n * @example absVal(50) = 50\\n * @example absVal(0) = 0\\n */\\n\\nconst absVal = (num) => {\\n  // Find absolute value of `num`.\\n  'use strict'\\n  if (num < 0) {\\n    return -num\\n  }\\n  // Executes if condition is not met.\\n  return num\\n}\\n\\nexport { absVal }\\n\"",
    "aliquot sum": "\"/*\\n  A program to calculate the Aliquot Sum of a number.\\n  The aliquot sum of a number n, is the sum of all the proper divisors of n apart from n itself\\n  For example, for the number 6\\n  The divisors are 1, 2, 3 (we don't consider 6), so its aliquot sum is 1 + 2 + 3 = 6\\n  1 is the only number whose aliquot sum is 0 (since its only divisor is 1 and aliquot sum of a number couldn't have itself)\\n  For all prime numbers, the aliquot sum is 1, since their only divisor apart from themselves is 1\\n  Article on Aliquot Sum: https://en.wikipedia.org/wiki/Aliquot_sum\\n */\\n\\n/**\\n * @param {Number} input The number whose aliquot sum you want to calculate\\n */\\nfunction aliquotSum (input) {\\n  // input can't be negative\\n  if (input < 0) throw new TypeError('Input cannot be Negative')\\n\\n  // input can't be a decimal\\n  if (Math.floor(input) !== input) throw new TypeError('Input cannot be a Decimal')\\n\\n  // Dealing with 1, which isn't a prime\\n  if (input === 1) return 0\\n\\n  let sum = 0\\n  for (let i = 1; i <= (input / 2); i++) {\\n    if (input % i === 0) sum += i\\n  }\\n\\n  return sum\\n}\\n\\nexport { aliquotSum }\\n\"",
    "area": "\"/*\\n  Calculate the area of various shapes\\n\\n  Calculate the Surface Area of a Cube.\\n  Example: surfaceAreaCube(1) will return 6\\n  More about: https://en.wikipedia.org/wiki/Area#Surface_area\\n */\\nconst surfaceAreaCube = (sideLength) => {\\n  validateNumericParam(sideLength, 'sideLength')\\n  return (6.0 * sideLength ** 2.0)\\n}\\n\\n/*\\n  Calculate the Surface Area of a Sphere.\\n  Wikipedia reference: https://en.wikipedia.org/wiki/Sphere\\n  return 4 * pi * r^2\\n*/\\nconst surfaceAreaSphere = (radius) => {\\n  validateNumericParam(radius, 'radius')\\n  return (4.0 * Math.PI * radius ** 2.0)\\n}\\n\\n/*\\n  Calculate the area of a rectangle\\n  Wikipedia reference: https://en.wikipedia.org/wiki/Area#Quadrilateral_area\\n  return width * length\\n*/\\nconst areaRectangle = (length, width) => {\\n  validateNumericParam(length, 'Length')\\n  validateNumericParam(width, 'Width')\\n  return (width * length)\\n}\\n\\n/*\\n  Calculate the area of a square\\n*/\\nconst areaSquare = (sideLength) => {\\n  validateNumericParam(sideLength, 'side length')\\n  return (sideLength ** 2)\\n}\\n\\n/*\\n  Calculate the area of a triangle\\n  Wikipedia reference: https://en.wikipedia.org/wiki/Area#Triangle_area\\n  return base * height / 2\\n*/\\nconst areaTriangle = (base, height) => {\\n  validateNumericParam(base, 'Base')\\n  validateNumericParam(height, 'Height')\\n  return (base * height) / 2.0\\n}\\n\\n/*\\n  Calculate the area of a parallelogram\\n  Wikipedia reference: https://en.wikipedia.org/wiki/Area#Dissection,_parallelograms,_and_triangles\\n*/\\nconst areaParallelogram = (base, height) => {\\n  validateNumericParam(base, 'Base')\\n  validateNumericParam(height, 'Height')\\n  return (base * height)\\n}\\n\\n/*\\n  Calculate the area of a trapezium\\n*/\\nconst areaTrapezium = (base1, base2, height) => {\\n  validateNumericParam(base1, 'Base One')\\n  validateNumericParam(base2, 'Base Two')\\n  validateNumericParam(height, 'Height')\\n  return 1.0 / 2.0 * (base1 + base2) * height\\n}\\n\\n/*\\n  Calculate the area of a circle\\n*/\\nconst areaCircle = (radius) => {\\n  validateNumericParam(radius, 'Radius')\\n  return (Math.PI * radius ** 2)\\n}\\n\\n/*\\n  Calculate the area of a rhombus\\n  Wikipedia reference: https://en.wikipedia.org/wiki/Rhombus\\n*/\\nconst areaRhombus = (diagonal1, diagonal2) => {\\n  validateNumericParam(diagonal1, 'diagonal one')\\n  validateNumericParam(diagonal2, 'diagonal two')\\n  return (1 / 2 * diagonal1 * diagonal2)\\n}\\n\\nconst validateNumericParam = (param, paramName = 'param') => {\\n  if (typeof param !== 'number') {\\n    throw new TypeError('The ' + paramName + ' should be type Number')\\n  } else if (param < 0) {\\n    throw new Error('The ' + paramName + ' only accepts non-negative values')\\n  }\\n}\\n\\nexport { surfaceAreaCube, surfaceAreaSphere, areaRectangle, areaSquare, areaTriangle, areaParallelogram, areaTrapezium, areaCircle, areaRhombus }\\n\"",
    "armstrong number": "\"/**\\n * Author: dephraiim\\n * License: GPL-3.0 or later\\n *\\n * An Armstrong number is equal to the sum of its own digits each raised to the power of the number of digits.\\n * For example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370.\\n * An Armstrong number is often called Narcissistic number.\\n *\\n */\\n\\nconst armstrongNumber = (num) => {\\n  if (num < 0 || typeof num !== 'number') return false\\n\\n  let newSum = 0\\n\\n  const numArr = num.toString().split('')\\n  numArr.forEach((num) => {\\n    newSum += parseInt(num) ** numArr.length\\n  })\\n\\n  return newSum === num\\n}\\n\\nexport { armstrongNumber }\\n\"",
    "average mean": "\"'use strict'\\n/*\\n    author: PatOnTheBack\\n    license: GPL-3.0 or later\\n\\n    Modified from:\\n        https://github.com/TheAlgorithms/Python/blob/master/maths/average.py\\n\\n    This script will find the average (mean) of an array of numbers.\\n\\n    More about mean:\\n        https://en.wikipedia.org/wiki/Mean\\n*/\\n\\nconst mean = (nums) => {\\n  // This is a function returns average/mean of array\\n  let sum = 0\\n\\n  // This loop sums all values in the 'nums' array using forEach loop\\n  nums.forEach(function (current) {\\n    sum += current\\n  })\\n\\n  // Divide sum by the length of the 'nums' array.\\n  const avg = sum / nums.length\\n  return avg\\n}\\n\\nexport { mean }\\n\"",
    "average median": "\"/*\\n * Median: https://en.wikipedia.org/wiki/Median\\n *\\n * function averageMedian\\n * to find the median value of an array of numbers\\n * the numbers in an array will be sorted in ascending order by the function sortNumbers\\n * if the length of the array is even number, the median value will be the average of the two middle numbers\\n * else if the length of the array is odd number, the median value will be the middle number in the array\\n */\\n\\nconst averageMedian = (numbers) => {\\n  let median = 0\\n  const numLength = numbers.length\\n  numbers = numbers.sort(sortNumbers)\\n\\n  if (numLength % 2 === 0) {\\n    median = (numbers[numLength / 2 - 1] + numbers[numLength / 2]) / 2\\n  } else {\\n    median = numbers[(numLength - 1) / 2]\\n  }\\n\\n  return median\\n}\\n\\nconst sortNumbers = (num1, num2) => {\\n  return num1 - num2\\n}\\n\\nexport { averageMedian }\\n\"",
    "binary convert": "\"const BinaryConvert = (number) => {\\n  const result = []\\n  let i\\n  for (i = number; i > 0; i = parseInt(i / 2)) {\\n    result.push(i % 2) // push the value (remainder)to array\\n  } return Number(result.reverse().join(''))\\n  // reverse index of array as string ,join and change the type of value to become Number\\n}\\n// call function and value as parameter to passing the value\\nexport { BinaryConvert }\\n\"",
    "binary exponentiation iterative": "\"// To calculate x^n i.e. exponent(x, n) in O(log n) time in iterative way\\n// n is an integer and n >= 0\\n\\n// Explanation: https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n\\n// Examples:\\n// 2^3 = 8\\n// 5^0 = 1\\n\\n// Uses the fact that\\n// exponent(x, n)\\n//          = exponent(x*x, floor(n/2))   ; if n is odd\\n//          = x*exponent(x*x, floor(n/2)) ; if n is even\\nconst exponent = (x, n) => {\\n  let answer = 1\\n  while (n > 0) {\\n    if (n % 2 !== 0) answer *= x\\n    n = Math.floor(n / 2)\\n    if (n > 0) x *= x\\n  }\\n  return answer\\n}\\n\\nexport { exponent }\\n\"",
    "binary exponentiation recursive": "\"/*\\r\\n  Modified from:\\r\\n    https://github.com/TheAlgorithms/Python/blob/master/maths/binary_exponentiation.py\\r\\n\\r\\n  Explanation:\\r\\n    https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\r\\n*/\\r\\n\\r\\nexport const binaryExponentiation = (a, n) => {\\r\\n  // input: a: int, n: int\\r\\n  // returns: a^n: int\\r\\n  if (n === 0) {\\r\\n    return 1\\r\\n  } else if (n % 2 === 1) {\\r\\n    return binaryExponentiation(a, n - 1) * a\\r\\n  } else {\\r\\n    const b = binaryExponentiation(a, n / 2)\\r\\n    return b * b\\r\\n  }\\r\\n}\\r\\n\"",
    "bisection method": "\"/**\\n *\\n * @file\\n * @brief Find real roots of a function in a specified interval [a, b], where f(a)*f(b) < 0\\n *\\n * @details Given a function f(x) and an interval [a, b], where f(a) * f(b) < 0, find an approximation of the root\\n * by calculating the middle m = (a + b) / 2, checking f(m) * f(a) and f(m) * f(b) and then by choosing the\\n * negative product that means Bolzano's theorem is applied,, define the new interval with these points. Repeat until\\n * we get the precision we want [Wikipedia](https://en.wikipedia.org/wiki/Bisection_method)\\n *\\n * @author [ggkogkou](https://github.com/ggkogkou)\\n *\\n */\\n\\nconst findRoot = (a, b, func, numberOfIterations) => {\\n  // Check if a given  real value belongs to the function's domain\\n  const belongsToDomain = (x, f) => {\\n    const res = f(x)\\n    return !Number.isNaN(res)\\n  }\\n  if (!belongsToDomain(a, func) || !belongsToDomain(b, func)) throw Error(\\\"Given interval is not a valid subset of function's domain\\\")\\n\\n  // Bolzano theorem\\n  const hasRoot = (a, b, func) => {\\n    return func(a) * func(b) < 0\\n  }\\n  if (hasRoot(a, b, func) === false) { throw Error('Product f(a)*f(b) has to be negative so that Bolzano theorem is applied') }\\n\\n  // Declare m\\n  const m = (a + b) / 2\\n\\n  // Recursion terminal condition\\n  if (numberOfIterations === 0) { return m }\\n\\n  // Find the products of f(m) and f(a), f(b)\\n  const fm = func(m)\\n  const prod1 = fm * func(a)\\n  const prod2 = fm * func(b)\\n\\n  // Depending on the sign of the products above, decide which position will m fill (a's or b's)\\n  if (prod1 > 0 && prod2 < 0) return findRoot(m, b, func, --numberOfIterations)\\n  else if (prod1 < 0 && prod2 > 0) return findRoot(a, m, func, --numberOfIterations)\\n  else throw Error('Unexpected behavior')\\n}\\n\\nexport { findRoot }\\n\"",
    "check kishnamurthy number": "\"/*\\n    Problem statement and Explanation : https://www.geeksforgeeks.org/check-if-a-number-is-a-krishnamurthy-number-or-not-2/\\n\\n    krishnamurthy number is a number the sum of the all factorial of the all dights is equal to the number itself.\\n    145 => 1! + 4! + 5! = 1  + 24 + 120 = 145\\n*/\\n\\n// factorial utility method.\\nconst factorial = (n) => {\\n  let fact = 1\\n  while (n !== 0) {\\n    fact = fact * n\\n    n--\\n  }\\n  return fact\\n}\\n\\n/**\\n * krishnamurthy number is a number the sum of the factorial of the all dights is equal to the number itself.\\n * @param {Number} number a number for checking is krishnamurthy number or not.\\n * @returns return correspond boolean value, if the number is krishnamurthy number return `true` else return `false`.\\n * @example 145 => 1! + 4! + 5! = 1  + 24 + 120 = 145\\n */\\nconst CheckKishnamurthyNumber = (number) => {\\n  // firstly, check that input is a number or not.\\n  if (typeof number !== 'number') {\\n    return new TypeError('Argument is not a number.')\\n  }\\n  // create a variable to store the sum of all digits factorial.\\n  let sumOfAllDigitFactorial = 0\\n  // convert the number to string for convenience.\\n  let newNumber = number\\n  // Extract number digits using the remainder method.\\n  while (newNumber > 0) {\\n    const lastDigit = newNumber % 10\\n    // calculate each digit factorial.\\n    sumOfAllDigitFactorial += factorial(lastDigit)\\n    newNumber = Math.floor(newNumber / 10)\\n  }\\n  // if the sumOftheFactorial is equal to the given number it means the number is a Krishnamurthy number.\\n  return sumOfAllDigitFactorial === number\\n}\\n\\nexport { CheckKishnamurthyNumber }\\n\"",
    "coordinate": "\"/*\\n Calculate the mathematical properties involving coordinates\\n Calculate the Distance Between 2 Points on a 2 Dimensional Plane\\n Example: coorDistance(2,2,14,11) will return 15\\n Wikipedia reference: https://en.wikipedia.org/wiki/Geographical_distance#Flat-surface_formulae\\n*/\\nconst euclideanDistance = (longitude1, latitude1, longitude2, latitude2) => {\\n  const width = longitude2 - longitude1\\n  const height = latitude2 - latitude1\\n  return (Math.sqrt(width * width + height * height))\\n}\\n\\nconst manhattanDistance = (longitude1, latitude1, longitude2, latitude2) => {\\n  const width = Math.abs(longitude2 - longitude1)\\n  const height = Math.abs(latitude2 - latitude1)\\n  return width + height\\n}\\n\\nexport { euclideanDistance, manhattanDistance }\\n\"",
    "co prime check": "\"/*\\n    Problem statement and Explanation : https://en.wikipedia.org/wiki/Coprime_integers\\n\\n    In number theory, two integers a and b are coprime, relatively prime or\\n    mutually prime if the only positive integer that is a divisor of both\\n    of them is Consequently, any prime number that divides one of a\\n    or b does not divide the other. This is equivalent to their greatest\\n    common divisor (gcd) being. One says also a is prime to b or a\\n    is coprime with b.\\n*/\\n\\n// Here we use a GetEuclidGCD method as a utility.\\nconst GetEuclidGCD = (arg1, arg2) => {\\n  let less = arg1 > arg2 ? arg2 : arg1\\n  for (less; less >= 2; less--) {\\n    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)\\n  }\\n  return (less)\\n}\\n\\n// CoPrimeCheck function return the boolean in respect of the given number is co-prime or not.\\n/**\\n * CoPrimeCheck function return the boolean in respect of the given number is co-prime or not.\\n * @param {Number} firstNumber first number for checking is prime or not.\\n * @param {Number} secondNumber second number for checking is prime or not.\\n * @returns return correspond boolean value, if both number are co-prime return `true`, else return `false`.\\n */\\nconst CoPrimeCheck = (firstNumber, secondNumber) => {\\n  // firstly, check that input is a number or not.\\n  if (typeof firstNumber !== 'number' || typeof secondNumber !== 'number') {\\n    return new TypeError('Argument is not a number.')\\n  }\\n  /*\\n    This is the most efficient algorithm for checking co-primes\\n    if the GCD of both the numbers is 1 that means they are co-primes.\\n    */\\n  return GetEuclidGCD(firstNumber, secondNumber) === 1\\n}\\n\\nexport { CoPrimeCheck }\\n\"",
    "decimal isolate": "\"/*\\n * function isolates the decimal part of a number.\\n * Take the number and subtract it from the floored number.\\n * Return the result.\\n */\\n\\nexport const decimalIsolate = (number) => {\\n  const answer = parseFloat((number + '').replace(/^[-\\\\d]+./, '.'))\\n  return isNaN(answer) === true ? 0 : answer\\n}\\n\"",
    "degree to radian": "\"/*\\n * Radian : https://en.wikipedia.org/wiki/Radian\\n * Degree : https://en.wikipedia.org/wiki/Degree_(angle)\\n *\\n * Angle in Radian = ( Angle in Degree ) x ( pi / 180 )\\n *\\n * Example :\\n * Question : Convert 90 degree to radian\\n * So, Angle in Degree = 90\\n *\\n * Solution :\\n * Angle in Radian = ( 90 ) x ( pi / 180 ) = pi / 2\\n *\\n * So, 90 degree is equal to pi / 2 radian\\n */\\n\\n/**\\n * @param {number} degree\\n * @return {number}\\n */\\nexport const degreeToRadian = (degree) => {\\n  return degree * (Math.PI / 180)\\n}\\n\"",
    "euler method": "\"/**\\r\\n * In mathematics and computational science, the Euler method (also called forward Euler method) is a first-order\\r\\n * numerical procedure for solving ordinary differential equations (ODEs) with a given initial value. It is the most\\r\\n * basic explicit method for numerical integration of ordinary differential equations. The method proceeds in a series\\r\\n * of steps. At each step the y-value is calculated by evaluating the differential equation at the previous step,\\r\\n * multiplying the result with the step-size and adding it to the last y-value: y_n+1 = y_n + stepSize * f(x_n, y_n).\\r\\n *\\r\\n * (description adapted from https://en.wikipedia.org/wiki/Euler_method)\\r\\n * @see https://www.geeksforgeeks.org/euler-method-solving-differential-equation/\\r\\n */\\r\\nexport function eulerStep (xCurrent, stepSize, yCurrent, differentialEquation) {\\r\\n  // calculates the next y-value based on the current value of x, y and the stepSize\\r\\n  return yCurrent + stepSize * differentialEquation(xCurrent, yCurrent)\\r\\n}\\r\\n\\r\\nexport function eulerFull (xStart, xEnd, stepSize, yStart, differentialEquation) {\\r\\n  // loops through all the steps until xEnd is reached, adds a point for each step and then returns all the points\\r\\n  const points = [{ x: xStart, y: yStart }]\\r\\n  let yCurrent = yStart\\r\\n  let xCurrent = xStart\\r\\n\\r\\n  while (xCurrent < xEnd) {\\r\\n    // Euler method for next step\\r\\n    yCurrent = eulerStep(xCurrent, stepSize, yCurrent, differentialEquation)\\r\\n    xCurrent += stepSize\\r\\n    points.push({ x: xCurrent, y: yCurrent })\\r\\n  }\\r\\n\\r\\n  return points\\r\\n}\\r\\n\"",
    "eulers totient": "\"/*\\n  Source:\\n    https://en.wikipedia.org/wiki/Euler%27s_totient_function\\n\\n  EulersTotient(n) = n * product(1 - 1/p for all prime p dividing n)\\n\\n  Complexity:\\n    O(sqrt(n))\\n*/\\n\\nexport const EulersTotient = (n) => {\\n  // input: n: int\\n  // output: phi(n): count of numbers b/w 1 and n that are coprime to n\\n  let res = n\\n  for (let i = 2; i * i <= n; i++) {\\n    if (n % i === 0) {\\n      while (n % i === 0) {\\n        n = Math.floor(n / i)\\n      }\\n      // i is a prime diving n, multiply res by 1 - 1/i\\n      // res = res * (1 - 1/i) = res - (res / i)\\n      res = res - Math.floor(res / i)\\n    }\\n  }\\n  if (n > 1) {\\n    res = res - Math.floor(res / n)\\n  }\\n  return res\\n}\\n\"",
    "eulers totient function": "\"/*\\n    author sandyboypraper\\n\\n    Here is the EulerTotientFunction.\\n    it is also represented by phi\\n\\n    so EulersTotientFunction(n) (or phi(n)) is the count of numbers in {1,2,3,....,n} that are relatively\\n    prime to n, i.e., the numbers whose GCD (Greatest Common Divisor) with n is 1.\\n*/\\n\\nconst gcdOfTwoNumbers = (x, y) => {\\n  // x is smaller than y\\n  // let gcd of x and y is gcdXY\\n  // so it divides x and y completely\\n  // so gcdXY should also divide y%x (y = gcdXY*a and x = gcdXY*b and y%x = y - x*k so y%x = gcdXY(a - b*k))\\n  // and gcd(x,y) is equal to gcd(y%x , x)\\n  return x === 0 ? y : gcdOfTwoNumbers(y % x, x)\\n}\\n\\nconst eulersTotientFunction = (n) => {\\n  let countOfRelativelyPrimeNumbers = 1\\n  for (let iterator = 2; iterator <= n; iterator++) {\\n    if (gcdOfTwoNumbers(iterator, n) === 1) countOfRelativelyPrimeNumbers++\\n  }\\n  return countOfRelativelyPrimeNumbers\\n}\\n\\nexport { eulersTotientFunction }\\n\"",
    "extended euclidean g c d": "\"/**\\n * Problem statement and explanation: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\\n *\\n * This algorithm plays an important role for modular arithmetic, and by extension for cyptography algorithms\\n *\\n * Basic explanation:\\n * The Extended Euclidean algorithm is a modification of the standard Euclidean GCD algorithm.\\n * It allows to calculate coefficients x and y for the equation:\\n *          ax + by = gcd(a,b)\\n *\\n * This is called Bézout's identity and the coefficients are called Bézout coefficients\\n *\\n * The algorithm uses the Euclidean method of getting remainder:\\n * r_i+1 = r_i-1 - qi*ri\\n * and applies it to series s and t (with same quotient q at each stage)\\n * When r_n reaches 0, the value r_n-1 gives the gcd, and s_n-1 and t_n-1 give the coefficients\\n *\\n * This implementation uses an iterative approach to calculate the values\\n */\\n\\n/**\\n *\\n * @param {Number} arg1 first argument\\n * @param {Number} arg2 second argument\\n * @returns Array with GCD and first and second Bézout coefficients\\n */\\nconst extendedEuclideanGCD = (arg1, arg2) => {\\n  if (typeof arg1 !== 'number' || typeof arg2 !== 'number') throw new TypeError('Not a Number')\\n  if (arg1 < 1 || arg2 < 1) throw new TypeError('Must be positive numbers')\\n\\n  // Make the order of coefficients correct, as the algorithm assumes r0 > r1\\n  if (arg1 < arg2) {\\n    const res = extendedEuclideanGCD(arg2, arg1)\\n    const temp = res[1]\\n    res[1] = res[2]\\n    res[2] = temp\\n    return res\\n  }\\n\\n  // At this point arg1 > arg2\\n\\n  // Remainder values\\n  let r0 = arg1\\n  let r1 = arg2\\n\\n  // Coefficient1 values\\n  let s0 = 1\\n  let s1 = 0\\n\\n  // Coefficient 2 values\\n  let t0 = 0\\n  let t1 = 1\\n\\n  while (r1 !== 0) {\\n    const q = Math.floor(r0 / r1)\\n\\n    const r2 = r0 - r1 * q\\n    const s2 = s0 - s1 * q\\n    const t2 = t0 - t1 * q\\n\\n    r0 = r1\\n    r1 = r2\\n    s0 = s1\\n    s1 = s2\\n    t0 = t1\\n    t1 = t2\\n  }\\n  return [r0, s0, t0]\\n}\\n\\nexport { extendedEuclideanGCD }\\n\"",
    "factorial": "\"/**\\n * @function Factorial\\n * @description function to find factorial using recursion.\\n * @param {Integer} n - The input integer\\n * @return {Integer} - Factorial of n.\\n * @see [Factorial](https://en.wikipedia.org/wiki/Factorial)\\n * @example 5! = 1*2*3*4*5 = 120\\n * @example 2! = 1*2 = 2\\n */\\n\\nconst factorial = (n) => {\\n  if (n === 0) {\\n    return 1\\n  }\\n  return n * factorial(n - 1)\\n}\\n\\nexport { factorial }\\n\"",
    "factors": "\"/**\\n * Author: dephraiim\\n * License: GPL-3.0 or later\\n *\\n * More on Factors:\\n *      https://www.mathsisfun.com/definitions/factor.html\\n *\\n */\\n\\nconst factorsOfANumber = (number = 0) => {\\n  return Array.from(Array(number + 1).keys()).filter(\\n    (num) => number % num === 0\\n  )\\n}\\n\\nexport { factorsOfANumber }\\n\"",
    "farey approximation": "\"/*\\n* Reference: https://en.wikipedia.org/wiki/Farey_sequence\\n* Inspiration: https://www.youtube.com/watch?v=7LKy3lrkTRA\\n*\\n* Farey Approximation algorithm is an algorithm to\\n* approximate a reduced fraction value for a certain\\n* decimal number x where 0 < x < 1.\\n*\\n* The algorithm works by keeping two fractional upper and\\n* lower bounds which start at 0 / 1 and 1 / 1. These values\\n* are then used to find the \\\"mediate\\\" which is a value between\\n* the two fractions.\\n*\\n* For any two fractions a / b and c / d,\\n* mediate = a + c / b + d\\n*\\n* Then it is checked if the decimal is greater than or less\\n* than the mediate and then the lower or the upper value is\\n* set to be the mediate respectively.\\n*\\n* This is repeated for n times and then the mediate is\\n* returned.\\n*\\n* This is explained in a greater detail in the \\\"Inspiration\\\"\\n* link.\\n*/\\n\\nfunction fareyApproximation (decimal, repeat = 20) {\\n  let a = 0; let b = 1; let c = 1; let d = 1; let numerator; let denominator\\n\\n  for (let i = 0; i < repeat; i++) {\\n    numerator = a + c\\n    denominator = b + d\\n\\n    if (decimal > numerator / denominator) {\\n      [a, b] = [numerator, denominator]\\n    } else {\\n      [c, d] = [numerator, denominator]\\n    }\\n  }\\n\\n  return { numerator, denominator }\\n}\\n\\nexport { fareyApproximation }\\n\"",
    "fermat primality test": "\"/*\\n * The Fermat primality test is a probabilistic test to determine whether a number\\n * is a probable prime.\\n *\\n * It relies on Fermat's Little Theorem, which states that if p is prime and a\\n * is not divisible by p, then\\n *\\n *     a^(p - 1) % p = 1\\n *\\n * However, there are certain numbers (so called Fermat Liars) that screw things up;\\n * if a is one of these liars the equation will hold even though p is composite.\\n *\\n * But not everything is lost! It's been proven that at least half of all integers\\n * aren't Fermat Liars (these ones called Fermat Witnesses). Thus, if we keep\\n * testing the primality with random integers, we can achieve higher reliability.\\n *\\n * The interesting about all of this is that since half of all integers are\\n * Fermat Witnesses, the precision gets really high really fast! Suppose that we\\n *  make the test 50 times: the chance of getting only Fermat Liars in all runs is\\n *\\n *     1 / 2^50 = 8.8 * 10^-16 (a pretty small number)\\n *\\n * For comparison, the probability of a cosmic ray causing an error to your\\n * infalible program is around 1.4 * 10^-15. An order of magnitude below!\\n *\\n * But because nothing is perfect, there's a major flaw to this algorithm, and\\n * the cause are the so called Carmichael Numbers. These are composite numbers n\\n * that hold the equality from Fermat's Little Theorem for every a < n (excluding\\n * is factors). In other words, if we are trying to determine if a Carmichael Number\\n * is prime or not, the chances of getting a wrong answer are pretty high! Because\\n * of that, the Fermat Primality Test is not used is serious applications. :(\\n *\\n * You can find more about the Fermat primality test and its flaws here:\\n * https://en.wikipedia.org/wiki/Fermat_primality_test\\n *\\n * And about Carmichael Numbers here:\\n * https://primes.utm.edu/glossary/xpage/CarmichaelNumber.html\\n */\\n\\n/**\\n * Faster exponentiation that capitalize on the fact that we are only interested\\n * in the modulus of the exponentiation.\\n *\\n * Find out more about it here: https://en.wikipedia.org/wiki/Modular_exponentiation\\n *\\n * @param {number} base\\n * @param {number} exponent\\n * @param {number} modulus\\n */\\nconst modularExponentiation = (base, exponent, modulus) => {\\n  if (modulus === 1) return 0 // after all, any x % 1 = 0\\n\\n  let result = 1\\n  base %= modulus // make sure that base < modulus\\n\\n  while (exponent > 0) {\\n    // if exponent is odd, multiply the result by the base\\n    if (exponent % 2 === 1) {\\n      result = (result * base) % modulus\\n      exponent--\\n    } else {\\n      exponent = exponent / 2 // exponent is even for sure\\n      base = (base * base) % modulus\\n    }\\n  }\\n\\n  return result\\n}\\n\\n/**\\n * Test if a given number n is prime or not.\\n *\\n * @param {number} n The number to check for primality\\n * @param {number} numberOfIterations The number of times to apply Fermat's Little Theorem\\n * @returns True if prime, false otherwise\\n */\\nconst fermatPrimeCheck = (n, numberOfIterations = 50) => {\\n  // first check for edge cases\\n  if (n <= 1 || n === 4) return false\\n  if (n <= 3) return true // 2 and 3 are included here\\n\\n  for (let i = 0; i < numberOfIterations; i++) {\\n    // pick a random number a, with 2 <= a < n - 2\\n    const randomNumber = Math.floor(Math.random() * (n - 2) + 2)\\n\\n    // if a^(n - 1) % n is different than 1, n is composite\\n    if (modularExponentiation(randomNumber, n - 1, n) !== 1) {\\n      return false\\n    }\\n  }\\n\\n  // if we arrived here without finding a Fermat Witness, this is almost guaranteed\\n  // to be a prime number (or a Carmichael number, if you are unlucky)\\n  return true\\n}\\n\\nexport { modularExponentiation, fermatPrimeCheck }\\n\"",
    "fibonacci": "\"const list = []\\n\\nconst FibonacciIterative = (nth) => {\\n  const sequence = []\\n\\n  if (nth >= 1) sequence.push(1)\\n  if (nth >= 2) sequence.push(1)\\n\\n  for (let i = 2; i < nth; i++) {\\n    sequence.push(sequence[i - 1] + sequence[i - 2])\\n  }\\n\\n  return sequence\\n}\\n\\nconst FibonacciRecursive = (number) => {\\n  return (() => {\\n    switch (list.length) {\\n      case 0:\\n        list.push(1)\\n        return FibonacciRecursive(number)\\n      case 1:\\n        list.push(1)\\n        return FibonacciRecursive(number)\\n      case number:\\n        return list\\n      default:\\n        list.push(list[list.length - 1] + list[list.length - 2])\\n        return FibonacciRecursive(number)\\n    }\\n  })()\\n}\\n\\nconst dict = new Map()\\n\\nconst FibonacciRecursiveDP = (stairs) => {\\n  if (stairs <= 0) return 0\\n  if (stairs === 1) return 1\\n\\n  // Memoize stair count\\n  if (dict.has(stairs)) return dict.get(stairs)\\n\\n  const res =\\n    FibonacciRecursiveDP(stairs - 1) + FibonacciRecursiveDP(stairs - 2)\\n\\n  dict.set(stairs, res)\\n\\n  return res\\n}\\n\\n// Algorithms\\n// Calculates Fibonacci(n) such that Fibonacci(n) = Fibonacci(n - 1) + Fibonacci(n - 2)\\n// Fibonacci(0) = Fibonacci(1) = 1\\n// Uses a bottom up dynamic programming approach\\n// Solve each sub-problem once, using results of previous sub-problems\\n// which are n-1 and n-2 for Fibonacci numbers\\n// Although this algorithm is linear in space and time as a function\\n// of the input value n, it is exponential in the size of n as\\n// a function of the number of input bits\\n// @Satzyakiz\\n\\nconst FibonacciDpWithoutRecursion = (number) => {\\n  const table = []\\n  table.push(1)\\n  table.push(1)\\n  for (let i = 2; i < number; ++i) {\\n    table.push(table[i - 1] + table[i - 2])\\n  }\\n  return table\\n}\\n\\n// Using Matrix exponentiation to find n-th fibonacci in O(log n) time\\n\\nconst copyMatrix = (A) => {\\n  return A.map(row => row.map(cell => cell))\\n}\\n\\nconst Identity = (size) => {\\n  const I = Array(size).fill(null).map(() => Array(size).fill())\\n  return I.map((row, rowIdx) => row.map((_col, colIdx) => {\\n    return rowIdx === colIdx ? 1 : 0\\n  }))\\n}\\n\\n// A of size (l x m) and B of size (m x n)\\n// product C will be of size (l x n)\\nconst matrixMultiply = (A, B) => {\\n  A = copyMatrix(A)\\n  B = copyMatrix(B)\\n  const l = A.length\\n  const m = B.length\\n  const n = B[0].length // Assuming non-empty matrices\\n  const C = Array(l).fill(null).map(() => Array(n).fill())\\n  for (let i = 0; i < l; i++) {\\n    for (let j = 0; j < n; j++) {\\n      C[i][j] = 0\\n      for (let k = 0; k < m; k++) {\\n        C[i][j] += A[i][k] * B[k][j]\\n      }\\n    }\\n  }\\n  return C\\n}\\n\\n/**\\n * Computes A raised to the power n i.e. pow(A, n) where A is a square matrix\\n * @param {*} A the square matrix\\n * @param {*} n the exponent\\n */\\n// A is a square matrix\\nconst matrixExpo = (A, n) => {\\n  A = copyMatrix(A)\\n\\n  // Just like Binary exponentiation mentioned in ./BinaryExponentiationIterative.js\\n  let result = Identity(A.length) // Identity matrix\\n  while (n > 0) {\\n    if (n % 2 !== 0) result = matrixMultiply(result, A)\\n    n = Math.floor(n / 2)\\n    if (n > 0) A = matrixMultiply(A, A)\\n  }\\n  return result\\n}\\n\\nconst FibonacciMatrixExpo = (n) => {\\n  // F(0) = 0, F(1) = 1\\n  // F(n) = F(n-1) + F(n-2)\\n  // Consider below matrix multiplication:\\n\\n  // | F(n) |   |1  1|   |F(n-1)|\\n  // |      | = |    | * |      |\\n  // |F(n-1)|   |1  0|   |F(n-2)|\\n\\n  // Let's rewrite it as F(n, n-1) = A * F(n-1, n-2)\\n  // or                  F(n, n-1) = A * A * F(n-2, n-3)\\n  // or                  F(n, n-1) = pow(A, n-1) * F(1, 0)\\n\\n  if (n === 0) return 0\\n\\n  const A = [\\n    [1, 1],\\n    [1, 0]\\n  ]\\n  const poweredA = matrixExpo(A, n - 1) // A raised to the power n-1\\n  let F = [\\n    [1],\\n    [0]\\n  ]\\n  F = matrixMultiply(poweredA, F)\\n  return F[0][0]\\n}\\n\\nexport { FibonacciDpWithoutRecursion }\\nexport { FibonacciIterative }\\nexport { FibonacciRecursive }\\nexport { FibonacciRecursiveDP }\\nexport { FibonacciMatrixExpo }\\n\"",
    "figurate number": "\"/**\\n Problem Statement and Explanation :\\n Triangular  => https://en.wikipedia.org/wiki/Triangular_number\\n Tetrahedral => https://en.wikipedia.org/wiki/Tetrahedral_number\\n Pentatope   => https://en.wikipedia.org/wiki/Pentatope_number\\n\\n Example:\\n Triangular  => (0, 1, 3, 6, 10, 15, 21, 28, 36, 45)\\n Tetrahedral => (1, 4, 10, 20, 35, 56, 84, 120, 165,)\\n Pentatope   => (1, 5, 15, 35, 70, 126, 210, 330, 495)\\n */\\n\\n/**\\n *\\n * @param {*} number\\n * @returns\\n */\\nconst isTriangular = (number) => {\\n  for (let i = 0; i <= number; i++) {\\n    if ((i * (i + 1)) / 2 === number) {\\n      return true\\n    } else if ((i * (i + 1)) / 2 > number) {\\n      return false\\n    }\\n  }\\n  return false\\n}\\n\\n/**\\n *\\n * @param {*} number\\n * @returns\\n */\\nconst isTetrahedral = (number) => {\\n  for (let i = 1; i <= number; i++) {\\n    if ((i * (i + 1) * (i + 2)) / 6 === number) {\\n      return true\\n    } else if ((i * (i + 1) * (i + 2)) / 6 > number) {\\n      return false\\n    }\\n  }\\n  return false\\n}\\n/**\\n *\\n * @param {*} number\\n * @returns\\n */\\nconst isPentatope = (number) => {\\n  for (let i = 1; i <= number; i++) {\\n    if ((i * (i + 1) * (i + 2) * (i + 3)) / 24 === number) {\\n      return true\\n    } else if ((i * (i + 1) * (i + 2) * (i + 3)) / 24 > number) {\\n      return false\\n    }\\n  }\\n  return false\\n}\\n\\n/**\\n *\\n * @param {*} number\\n * @returns\\n */\\nconst checkAll = (number) => {\\n  return {\\n    isTriangular: isTriangular(number),\\n    isTetrahedral: isTetrahedral(number),\\n    isPentatope: isPentatope(number)\\n  }\\n}\\nexport { isTriangular }\\nexport { isTetrahedral }\\nexport { isPentatope }\\nexport { checkAll }\\n\"",
    "find hcf": "\"/*\\n    author: redfly1\\n    More about HCF:\\n        https://en.wikipedia.org/wiki/Greatest_common_divisor\\n */\\n\\nconst findHCF = (x, y) => {\\n  // If the input numbers are less than 1 return an error message.\\n  if (x < 1 || y < 1) {\\n    return 'Please enter values greater than zero.'\\n  }\\n\\n  // If the input numbers are not integers return an error message.\\n  if (x !== Math.round(x) || y !== Math.round(y)) {\\n    return 'Please enter whole numbers.'\\n  }\\n\\n  // Now apply Euclid's algorithm to the two numbers.\\n  while (Math.max(x, y) % Math.min(x, y) !== 0) {\\n    if (x > y) {\\n      x %= y\\n    } else {\\n      y %= x\\n    }\\n  }\\n\\n  // When the while loop finishes the minimum of x and y is the HCF.\\n  return Math.min(x, y)\\n}\\n\\nexport { findHCF }\\n\"",
    "find lcm": "\"/*\\n    author: PatOnTheBack\\n    license: GPL-3.0 or later\\n\\n    Modified from:\\n        https://github.com/TheAlgorithms/Python/blob/master/maths/findLcm.py\\n\\n    More about LCM:\\n        https://en.wikipedia.org/wiki/Least_common_multiple\\n*/\\n\\n'use strict'\\n\\n// Find the LCM of two numbers.\\nconst findLcm = (num1, num2) => {\\n  // If the input numbers are less than 1 return an error message.\\n  if (num1 < 1 || num2 < 1) {\\n    return 'Please enter values greater than zero.'\\n  }\\n\\n  // If the input numbers are not integers return an error message.\\n  if (num1 !== Math.round(num1) || num2 !== Math.round(num2)) {\\n    return 'Please enter whole numbers.'\\n  }\\n\\n  let maxNum\\n  let lcm\\n  // Check to see whether num1 or num2 is larger.\\n  if (num1 > num2) {\\n    maxNum = num1\\n  } else {\\n    maxNum = num2\\n  }\\n  lcm = maxNum\\n\\n  while (true) {\\n    if (lcm % num1 === 0 && lcm % num2 === 0) break\\n    lcm += maxNum\\n  }\\n  return lcm\\n}\\n\\nexport { findLcm }\\n\"",
    "find min": "\"/**\\n * @function FindMin\\n * @description Function to find the minimum number given in an array of integers.\\n * @param {Integer[]} nums - Array of Integers\\n * @return {Integer} - The minimum number of the array.\\n */\\n\\nconst findMin = (...nums) => {\\n  if (nums.length === 0) {\\n    throw new TypeError('Array is empty')\\n  }\\n\\n  let min = nums[0]\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] < min) {\\n      min = nums[i]\\n    }\\n  }\\n\\n  return min\\n}\\n\\nexport { findMin }\\n\"",
    "get euclid g c d": "\"/*\\n    Problem statement and Explanation : https://en.wikipedia.org/wiki/Euclidean_algorithm\\n\\n    In this method, we have followed the iterative approach to first\\n    find a minimum of both numbers and go to the next step.\\n*/\\n\\n/**\\n * GetEuclidGCD return the gcd of two numbers using Euclidean algorithm.\\n * @param {Number} arg1 first argument for gcd\\n * @param {Number} arg2 second argument for gcd\\n * @returns return a `gcd` value of both number.\\n */\\nconst GetEuclidGCD = (arg1, arg2) => {\\n  // firstly, check that input is a number or not.\\n  if (typeof arg1 !== 'number' || typeof arg2 !== 'number') {\\n    return new TypeError('Argument is not a number.')\\n  }\\n  // check that the input number is not a negative value.\\n  if (arg1 < 1 || arg2 < 1) {\\n    return new TypeError('Argument is a negative number.')\\n  }\\n  // Find a minimum of both numbers.\\n  let less = arg1 > arg2 ? arg2 : arg1\\n  // Iterate the number and find the gcd of the number using the above explanation.\\n  for (less; less >= 2; less--) {\\n    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)\\n  }\\n  return (less)\\n}\\n\\nexport { GetEuclidGCD }\\n\"",
    "grid get": "\"/*\\n    author: TangibleDream\\n    license: GPL-3.0 or later\\n\\n    These methods will find x or y given the element and columns for a 2 dimensional array.\\n\\n    If your array is a perfect square, you can find columns by getting the square\\n    root of the length of the array.\\n\\n    Let's say for instance you had an array of 10 by 10 or 100, elements and you wanted to\\n    find the shortest distance between element 3, and element 49. In this case coding out\\n    a function to return the distance without finding x and y for both elements I found to\\n    be painful. If you first find x and y, where 3 becomes 4,1 and 49 becomes 10,5, you can\\n    find distance by first subtracting x from x and y from y this returns 6,4 or -6,-4.\\n    Next apply absolute value to assure the results are positive,\\n    last choose the maximum value of the set, or 6.\\n\\n    +--+--+--+--+--+--+--+--+--+--+\\n    |  |  |  | 3|  |  |  |  |  |  |\\n    +--+--+--+--+--+--+--+--+--+--+\\n    |  |  |  |  |  |  |  |  |  |  |\\n    +--+--+--+--+--+--+--+--+--+--+\\n    |  |  |  |  |  |  |  |  |  |  |\\n    +--+--+--+--+--+--+--+--+--+--+\\n    |  |  |  |  |  |  |  |  |  |49|\\n    +--+--+--+--+--+--+--+--+--+--+\\n    |  |  |  |  |  |  |  |  |  |  |\\n\\n    +--+--+--+--+--+--+--+--+--+--+\\n    |  |  |  | 3|  |  |  |  |  |  |\\n    +--+--+--+--+--+--+--+--+--+--+\\n    |  |  |  |  | 1|  |  |  |  |  |\\n    +--+--+--+--+--+--+--+--+--+--+\\n    |  |  |  |  |  | 2|  |  |  |  |\\n    +--+--+--+--+--+--+--+--+--+--+\\n    |  |  |  |  |  |  | 3| 4| 5|6!|\\n    +--+--+--+--+--+--+--+--+--+--+\\n    |  |  |  |  |  |  |  |  |  |  |\\n\\n*/\\n\\nconst gridGetX = (columns, index) => {\\n  while (index + 1 > columns) {\\n    index = index - columns\\n  }\\n  return index + 1\\n}\\n\\nconst gridGetY = (columns, index) => {\\n  return Math.floor(index / columns) + 1\\n}\\n\\nexport { gridGetX, gridGetY }\\n\"",
    "is divisible": "\"// Checks if a number is divisible by another number.\\n\\nexport const isDivisible = (num1, num2) => {\\n  if (!Number.isFinite(num1) || !Number.isFinite(num2)) {\\n    throw new TypeError('Expected a number')\\n  }\\n  if (num2 === 0) {\\n    return false\\n  }\\n  return num1 % num2 === 0\\n}\\n\\n// isDivisible(10, 5) // returns true\\n// isDivisible(123498175, 5) // returns true\\n// isDivisible(99, 5) // returns false\\n\"",
    "is even": "\"/*\\n * Even Number: https://simple.wikipedia.org/wiki/Even_number\\n *\\n * function to check if number is even\\n * return true if number is even\\n * else false\\n */\\n\\n/**\\n * @param {number} number\\n * @return {boolean}\\n */\\n\\n/*\\n * Checking if number is even using divisibility by 2\\n *\\n * If number is divisible by 2 i.e remainder = 0, then it is even\\n * therefore, the function will return true\\n *\\n * If number is not divisible by 2 i.e remainder != 0, then it is not even i.e odd\\n * therefore, the function will return false\\n */\\n\\nexport const isEven = (number) => {\\n  return number % 2 === 0\\n}\\n\\n/*\\n * Checking if number is even using bitwise operator\\n *\\n * Bitwise AND (&) compares the bits of the 32\\n * bit binary representations of the number and\\n * returns a number after comparing each bit:\\n *\\n * 0 & 0 -> 0\\n * 0 & 1 -> 0\\n * 1 & 0 -> 0\\n * 1 & 1 -> 1\\n *\\n * For odd numbers, the last binary bit will be 1\\n * and for even numbers, the last binary bit will\\n * be 0.\\n *\\n * As the number is compared with one, all the\\n * other bits except the last will become 0. The\\n * last bit will be 0 for even numbers and 1 for\\n * odd numbers, which is checked with the use\\n * of the equality operator.\\n *\\n * References:\\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND\\n */\\n\\nexport const isEvenBitwise = (number) => {\\n  return (number & 1) === 0\\n}\\n\"",
    "is odd": "\"/*\\n * function to check if number is odd\\n * return true if number is odd\\n * else false\\n */\\n\\nexport const isOdd = (value) => {\\n  return !!((value & 1))\\n}\\n\"",
    "leap year": "\"/**\\n * isLeapYear :: Number -> Boolean\\n *\\n * Check if a year is a leap year or not. A leap year is a year which has 366 days.\\n * For the extra +1 day the February month contains 29 days instead of 28 days.\\n *\\n * The logic behind the leap year is-\\n * 1. If the year is divisible by 400 then it is a leap year.\\n * 2. If it is not divisible by 400 but divisible by 100 then it is not a leap year.\\n * 3. If the year is not divisible by 400 but not divisible by 100 and divisible by 4 then a leap year.\\n * 4. Other cases except the describing ones are not a leap year.\\n *\\n * @param {number} year\\n * @returns {boolean} true if this is a leap year, false otherwise.\\n */\\nexport const isLeapYear = (year) => {\\n  if (year % 400 === 0) return true\\n  if (year % 100 === 0) return false\\n  if (year % 4 === 0) return true\\n\\n  return false\\n}\\n\"",
    "linear sieve": "\"const LinearSieve = (n) => {\\n  /*\\n   * Calculates prime numbers till a number n\\n   * Time Complexity: O(n)\\n   * Explanation: https://cp-algorithms.com/algebra/prime-sieve-linear.html\\n   * :param n: Number up to which to calculate primes\\n   * :return: A list containing only primes\\n   */\\n  const isnPrime = new Array(n + 1)\\n  isnPrime[0] = isnPrime[1] = true\\n  const primes = []\\n  for (let i = 2; i <= n; i++) {\\n    if (!isnPrime[i]) primes.push(i)\\n    for (const p of primes) {\\n      const k = i * p\\n      if (k > n) break\\n      isnPrime[k] = true\\n      if (i % p === 0) break\\n    }\\n  }\\n  return primes\\n}\\n\\nexport { LinearSieve }\\n\"",
    "lucas series": "\"/*\\n  Program to get the Nth Lucas Number\\n  Article on Lucas Number: https://en.wikipedia.org/wiki/Lucas_number\\n  Examples:\\n    > loopLucas(1)\\n    1\\n    > loopLucas(20)\\n    15127\\n    > loopLucas(100)\\n    792070839848372100000\\n*/\\n\\n/**\\n * @param {Number} index The position of the number you want to get from the Lucas Series\\n */\\nfunction lucas (index) {\\n  // index can't be negative\\n  if (index < 0) throw new TypeError('Index cannot be Negative')\\n\\n  // index can't be a decimal\\n  if (Math.floor(index) !== index) throw new TypeError('Index cannot be a Decimal')\\n\\n  let a = 2\\n  let b = 1\\n  for (let i = 0; i < index; i++) {\\n    const temp = a + b\\n    a = b\\n    b = temp\\n  }\\n  return a\\n}\\n\\nexport { lucas }\\n\"",
    "mandelbrot": "\"/**\\n * Method to generate the image of the Mandelbrot set.\\n *\\n * Two types of coordinates are used: image-coordinates that refer to the pixels and figure-coordinates that refer to\\n * the complex numbers inside and outside the Mandelbrot set. The figure-coordinates in the arguments of this method\\n * determine which section of the Mandelbrot set is viewed. The main area of the Mandelbrot set is roughly between\\n * \\\"-1.5 < x < 0.5\\\" and \\\"-1 < y < 1\\\" in the figure-coordinates.\\n *\\n * The Mandelbrot set is the set of complex numbers \\\"c\\\" for which the series \\\"z_(n+1) = z_n * z_n + c\\\" does not diverge,\\n * i.e. remains bounded. Thus, a complex number \\\"c\\\" is a member of the Mandelbrot set if, when starting with \\\"z_0 = 0\\\"\\n * and applying the iteration repeatedly, the absolute value of \\\"z_n\\\" remains bounded for all \\\"n > 0\\\". Complex numbers\\n * can be written as \\\"a + b*i\\\": \\\"a\\\" is the real component, usually drawn on the x-axis, and \\\"b*i\\\" is the imaginary\\n * component, usually drawn on the y-axis. Most visualizations of the Mandelbrot set use a color-coding to indicate\\n * after how many steps in the series the numbers outside the set cross the divergence threshold. Images of the\\n * Mandelbrot set exhibit an elaborate and infinitely complicated boundary that reveals progressively ever-finer\\n * recursive detail at increasing magnifications, making the boundary of the Mandelbrot set a fractal curve.\\n *\\n * (description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set)\\n * @see https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set\\n *\\n * @param {number} imageWidth The width of the rendered image.\\n * @param {number} imageHeight The height of the rendered image.\\n * @param {number} figureCenterX The x-coordinate of the center of the figure.\\n * @param {number} figureCenterY The y-coordinate of the center of the figure.\\n * @param {number} figureWidth The width of the figure.\\n * @param {number} maxStep Maximum number of steps to check for divergent behavior.\\n * @param {boolean} useDistanceColorCoding Render in color or black and white.\\n * @return {object} The RGB-data of the rendered Mandelbrot set.\\n */\\nexport function getRGBData (\\n  imageWidth = 800,\\n  imageHeight = 600,\\n  figureCenterX = -0.6,\\n  figureCenterY = 0,\\n  figureWidth = 3.2,\\n  maxStep = 50,\\n  useDistanceColorCoding = true) {\\n  if (imageWidth <= 0) {\\n    throw new Error('imageWidth should be greater than zero')\\n  }\\n\\n  if (imageHeight <= 0) {\\n    throw new Error('imageHeight should be greater than zero')\\n  }\\n\\n  if (maxStep <= 0) {\\n    throw new Error('maxStep should be greater than zero')\\n  }\\n\\n  const rgbData = []\\n  const figureHeight = figureWidth / imageWidth * imageHeight\\n\\n  // loop through the image-coordinates\\n  for (let imageX = 0; imageX < imageWidth; imageX++) {\\n    rgbData[imageX] = []\\n    for (let imageY = 0; imageY < imageHeight; imageY++) {\\n      // determine the figure-coordinates based on the image-coordinates\\n      const figureX = figureCenterX + (imageX / imageWidth - 0.5) * figureWidth\\n      const figureY = figureCenterY + (imageY / imageHeight - 0.5) * figureHeight\\n\\n      const distance = getDistance(figureX, figureY, maxStep)\\n\\n      // color the corresponding pixel based on the selected coloring-function\\n      rgbData[imageX][imageY] =\\n        useDistanceColorCoding\\n          ? colorCodedColorMap(distance)\\n          : blackAndWhiteColorMap(distance)\\n    }\\n  }\\n\\n  return rgbData\\n}\\n\\n/**\\n * Black and white color-coding that ignores the relative distance.\\n *\\n * The Mandelbrot set is black, everything else is white.\\n *\\n * @param {number} distance Distance until divergence threshold\\n * @return {object} The RGB-value corresponding to the distance.\\n */\\nfunction blackAndWhiteColorMap (distance) {\\n  return distance >= 1 ? [0, 0, 0] : [255, 255, 255]\\n}\\n\\n/**\\n * Color-coding taking the relative distance into account.\\n *\\n * The Mandelbrot set is black.\\n *\\n * @param {number} distance Distance until divergence threshold\\n * @return {object} The RGB-value corresponding to the distance.\\n */\\nfunction colorCodedColorMap (distance) {\\n  if (distance >= 1) {\\n    return [0, 0, 0]\\n  } else {\\n    // simplified transformation of HSV to RGB\\n    // distance determines hue\\n    const hue = 360 * distance\\n    const saturation = 1\\n    const val = 255\\n    const hi = (Math.floor(hue / 60)) % 6\\n    const f = hue / 60 - Math.floor(hue / 60)\\n\\n    const v = val\\n    const p = 0\\n    const q = Math.floor(val * (1 - f * saturation))\\n    const t = Math.floor(val * (1 - (1 - f) * saturation))\\n\\n    switch (hi) {\\n      case 0:\\n        return [v, t, p]\\n      case 1:\\n        return [q, v, p]\\n      case 2:\\n        return [p, v, t]\\n      case 3:\\n        return [p, q, v]\\n      case 4:\\n        return [t, p, v]\\n      default:\\n        return [v, p, q]\\n    }\\n  }\\n}\\n\\n/**\\n * Return the relative distance (ratio of steps taken to maxStep) after which the complex number\\n * constituted by this x-y-pair diverges.\\n *\\n * Members of the Mandelbrot set do not diverge so their distance is 1.\\n *\\n * @param {number} figureX The x-coordinate within the figure.\\n * @param {number} figureY The y-coordinate within the figure.\\n * @param {number} maxStep Maximum number of steps to check for divergent behavior.\\n * @return {number} The relative distance as the ratio of steps taken to maxStep.\\n */\\nfunction getDistance (figureX, figureY, maxStep) {\\n  let a = figureX\\n  let b = figureY\\n  let currentStep = 0\\n  for (let step = 0; step < maxStep; step++) {\\n    currentStep = step\\n    const aNew = a * a - b * b + figureX\\n    b = 2 * a * b + figureY\\n    a = aNew\\n\\n    // divergence happens for all complex number with an absolute value\\n    // greater than 4 (= divergence threshold)\\n    if (a * a + b * b > 4) {\\n      break\\n    }\\n  }\\n  return currentStep / (maxStep - 1)\\n}\\n\"",
    "matrix exponentiation recursive": "\"/*\\n  Source:\\n    https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n\\n  Complexity:\\n    O(d^3 log n)\\n    where: d is the dimension of the square matrix\\n           n is the power the matrix is raised to\\n*/\\n\\nconst Identity = (n) => {\\n  // Input: n: int\\n  // Output: res: Identity matrix of size n x n\\n  // Complexity: O(n^2)\\n  const res = []\\n  for (let i = 0; i < n; i++) {\\n    res[i] = []\\n    for (let j = 0; j < n; j++) {\\n      res[i][j] = i === j ? 1 : 0\\n    }\\n  }\\n  return res\\n}\\n\\nconst MatMult = (matrixA, matrixB) => {\\n  // Input: matrixA: 2D Array of Numbers of size n x n\\n  //        matrixB: 2D Array of Numbers of size n x n\\n  // Output: matrixA x matrixB: 2D Array of Numbers of size n x n\\n  // Complexity: O(n^3)\\n  const n = matrixA.length\\n  const matrixC = []\\n  for (let i = 0; i < n; i++) {\\n    matrixC[i] = []\\n    for (let j = 0; j < n; j++) {\\n      matrixC[i][j] = 0\\n    }\\n  }\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < n; j++) {\\n      for (let k = 0; k < n; k++) {\\n        matrixC[i][j] += matrixA[i][k] * matrixB[k][j]\\n      }\\n    }\\n  }\\n  return matrixC\\n}\\n\\nexport const MatrixExponentiationRecursive = (mat, m) => {\\n  // Input: mat: 2D Array of Numbers of size n x n\\n  // Output: mat^n: 2D Array of Numbers of size n x n\\n  // Complexity: O(n^3 log m)\\n  if (m === 0) {\\n    // return identity matrix of size n x n\\n    return Identity(mat.length)\\n  } else if (m % 2 === 1) {\\n    // tmp = mat ^ m-1\\n    const tmp = MatrixExponentiationRecursive(mat, m - 1)\\n    /// return tmp * mat = (mat ^ m-1) * mat = mat ^ m\\n    return MatMult(tmp, mat)\\n  } else {\\n    // tmp = mat ^ m/2\\n    const tmp = MatrixExponentiationRecursive(mat, m >> 1)\\n    // return tmp * tmp = (mat ^ m/2) ^ 2 = mat ^ m\\n    return MatMult(tmp, tmp)\\n  }\\n}\\n\\n// const mat = [[1, 0, 2], [2, 1, 0], [0, 2, 1]]\\n\\n// // mat ^ 0 = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]\\n// MatrixExponentiationRecursive(mat, 0)\\n\\n// // mat ^ 1 = [ [ 1, 0, 2 ], [ 2, 1, 0 ], [ 0, 2, 1 ] ]\\n// MatrixExponentiationRecursive(mat, 1)\\n\\n// // mat ^ 2 = [ [ 1, 4, 4 ], [ 4, 1, 4 ], [ 4, 4, 1 ] ]\\n// MatrixExponentiationRecursive(mat, 2)\\n\\n// // mat ^ 5 = [ [ 1, 4, 4 ], [ 4, 1, 4 ], [ 4, 4, 1 ] ]\\n// MatrixExponentiationRecursive(mat, 5)\\n\"",
    "matrix multiplication": "\"// Wikipedia URL for General Matrix Multiplication Concepts: https://en.wikipedia.org/wiki/Matrix_multiplication\\n\\n// This algorithm has multiple functions that ultimately check if the inputs are actually matrices and if two Matrices (that can be different sizes) can be multiplied together.\\n// matrices that are of the same size [2x2]x[2x2], and the second is the multiplication of two matrices that are not the same size [2x3]x[3x2].\\n\\n// MatrixCheck tests to see if all of the rows of the matrix inputted have similar size columns\\nconst matrixCheck = (matrix) => {\\n  let columnNumb\\n  for (let index = 0; index < matrix.length; index++) {\\n    if (index === 0) {\\n      columnNumb = matrix[index].length\\n    } else if (matrix[index].length !== columnNumb) {\\n      // The columns in this array are not equal\\n    } else {\\n      return columnNumb\\n    }\\n  }\\n}\\n\\n// tests to see if the matrices have a like side, i.e. the row length on the first matrix matches the column length on the second matrix, or vice versa.\\nconst twoMatricesCheck = (first, second) => {\\n  const [firstRowLength, secondRowLength, firstColLength, secondColLength] = [first.length, second.length, matrixCheck(first), matrixCheck(second)]\\n  if (firstRowLength !== secondColLength || secondRowLength !== firstColLength) {\\n    // These matrices do not have a common side\\n    return false\\n  } else {\\n    return true\\n  }\\n}\\n\\n// returns an empty array that has the same number of rows as the left matrix being multiplied.\\n// Uses Array.prototype.map() to loop over the first (or left) matrix and returns an empty array on each iteration.\\nconst initiateEmptyArray = (first, second) => {\\n  if (twoMatricesCheck(first, second)) {\\n    const emptyArray = first.map(() => {\\n      return ['']\\n    })\\n    return emptyArray\\n  } else {\\n    return false\\n  }\\n}\\n\\n// Finally, `matrixMult` uses `Array.prototype.push()`, multiple layers of nested `for` loops, the addition assignment `+=` operator and multiplication operator `*` to perform the dot product between two matrices of differing sizes.\\n// Dot product, takes the row of the first matrix and multiplies it by the column of the second matrix, the `twoMatricesCheck` tested to see if they were the same size already.\\n// The dot product for each iteration is then saved to its respective index into `multMatrix`.\\nexport const matrixMult = (firstArray, secondArray) => {\\n  const multMatrix = initiateEmptyArray(firstArray, secondArray)\\n  for (let rm = 0; rm < firstArray.length; rm++) {\\n    const rowMult = []\\n    for (let col = 0; col < firstArray[0].length; col++) {\\n      rowMult.push(firstArray[rm][col])\\n    }\\n    for (let cm = 0; cm < firstArray.length; cm++) {\\n      const colMult = []\\n      for (let row = 0; row < secondArray.length; row++) {\\n        colMult.push(secondArray[row][cm])\\n      }\\n      let newNumb = 0\\n      for (let index = 0; index < rowMult.length; index++) {\\n        newNumb += rowMult[index] * colMult[index]\\n      }\\n      multMatrix[rm][cm] = newNumb\\n    }\\n  }\\n  return multMatrix\\n}\\n\\n// const firstMatrix = [\\n//   [1, 2],\\n//   [3, 4]\\n// ]\\n\\n// const secondMatrix = [\\n//   [5, 6],\\n//   [7, 8]\\n// ]\\n\\n// matrixMult(firstMatrix, secondMatrix) // [ [ 19, 22 ], [ 43, 50 ] ]\\n\\n// const thirdMatrix = [\\n//   [-1, 4, 1],\\n//   [7, -6, 2]\\n// ]\\n// const fourthMatrix = [\\n//   [2, -2],\\n//   [5, 3],\\n//   [3, 2]\\n// ]\\n\\n// matrixMult(thirdMatrix, fourthMatrix) // [ [ 21, 16 ], [ -10, -28 ] ]\\n\"",
    "mean square error": "\"// Wikipedia: https://en.wikipedia.org/wiki/Mean_squared_error\\n\\nconst meanSquaredError = (predicted, expected) => {\\n  if (!Array.isArray(predicted) || !Array.isArray(expected)) {\\n    throw new TypeError('Argument must be an Array')\\n  }\\n\\n  if (predicted.length !== expected.length) {\\n    throw new TypeError('The two lists must be of equal length')\\n  }\\n\\n  let err = 0\\n\\n  for (let i = 0; i < expected.length; i++) {\\n    err += (expected[i] - predicted[i]) ** 2\\n  }\\n\\n  return err / expected.length\\n}\\n\\nexport { meanSquaredError }\\n\"",
    "midpoint integration": "\"/**\\n*\\n* @title Midpoint rule for definite integral evaluation\\n* @author [ggkogkou](https://github.com/ggkogkou)\\n* @brief Calculate definite integrals with midpoint method\\n*\\n* @details The idea is to split the interval in a number N of intervals and use as interpolation points the xi\\n* for which it applies that xi = x0 + i*h, where h is a step defined as h = (b-a)/N where a and b are the\\n* first and last points of the interval of the integration [a, b].\\n*\\n* We create a table of the xi and their corresponding f(xi) values and we evaluate the integral by the formula:\\n* I = h * {f(x0+h/2) + f(x1+h/2) + ... + f(xN-1+h/2)}\\n*\\n* N must be > 0 and a<b. By increasing N, we also increase precision\\n*\\n* [More info link](https://tutorial.math.lamar.edu/classes/calcii/approximatingdefintegrals.aspx)\\n*\\n*/\\n\\nfunction integralEvaluation (N, a, b, func) {\\n  // Check if all restrictions are satisfied for the given N, a, b\\n  if (!Number.isInteger(N) || Number.isNaN(a) || Number.isNaN(b)) { throw new TypeError('Expected integer N and finite a, b') }\\n  if (N <= 0) { throw Error('N has to be >= 2') } // check if N > 0\\n  if (a > b) { throw Error('a must be less or equal than b') } // Check if a < b\\n  if (a === b) return 0 // If a === b integral is zero\\n\\n  // Calculate the step h\\n  const h = (b - a) / N\\n\\n  // Find interpolation points\\n  let xi = a // initialize xi = x0\\n  const pointsArray = []\\n\\n  // Find the sum {f(x0+h/2) + f(x1+h/2) + ... + f(xN-1+h/2)}\\n  let temp\\n  for (let i = 0; i < N; i++) {\\n    temp = func(xi + h / 2)\\n    pointsArray.push(temp)\\n    xi += h\\n  }\\n\\n  // Calculate the integral\\n  let result = h\\n  temp = 0\\n  for (let i = 0; i < pointsArray.length; i++) temp += pointsArray[i]\\n\\n  result *= temp\\n\\n  if (Number.isNaN(result)) { throw Error('Result is NaN. The input interval does not belong to the functions domain') }\\n\\n  return result\\n}\\n\\nexport { integralEvaluation }\\n\"",
    "modular binary exponentiation recursive": "\"/*\\r\\n  Modified from:\\r\\n    https://github.com/TheAlgorithms/Python/blob/master/maths/binary_exp_mod.py\\r\\n\\r\\n  Explanation:\\r\\n    https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\r\\n*/\\r\\n\\r\\nconst modularBinaryExponentiation = (a, n, m) => {\\r\\n  // input: a: int, n: int, m: int\\r\\n  // returns: (a^n) % m: int\\r\\n  if (n === 0) {\\r\\n    return 1\\r\\n  } else if (n % 2 === 1) {\\r\\n    return (modularBinaryExponentiation(a, n - 1, m) * a) % m\\r\\n  } else {\\r\\n    const b = modularBinaryExponentiation(a, n / 2, m)\\r\\n    return (b * b) % m\\r\\n  }\\r\\n}\\r\\n\\r\\nexport { modularBinaryExponentiation }\\r\\n\"",
    "number of digits": "\"/**\\n *\\n * Author: dephraiim\\n * License: GPL-3.0 or later\\n *\\n * Returns the number of digits of a given integer\\n *\\n */\\n\\nconst numberOfDigit = (n) => Math.abs(n).toString().length\\n\\nexport { numberOfDigit }\\n\"",
    "palindrome": "\"/**\\n * @function Palindrome\\n * @description Check whether the given string is Palindrome or not.\\n * @param {String} str - The input string\\n * @return {Boolean}.\\n * @see [Palindrome](https://en.wikipedia.org/wiki/Palindrome)\\n */\\n\\nconst palindrome = (str) => {\\n  if (typeof str !== 'string') {\\n    throw new TypeError('Invalid Input')\\n  }\\n\\n  if (str.length <= 1) {\\n    return true\\n  }\\n\\n  if (str[0] !== str[str.length - 1]) {\\n    return false\\n  } else {\\n    return palindrome(str.slice(1, str.length - 1))\\n  }\\n}\\n\\nexport { palindrome }\\n\"",
    "pascal triangle": "\"const addRow = (triangle) => {\\n  const previous = triangle[triangle.length - 1]\\n  const newRow = [1]\\n  for (let i = 0; i < previous.length - 1; i++) {\\n    const current = previous[i]\\n    const next = previous[i + 1]\\n    newRow.push(current + next)\\n  }\\n  newRow.push(1)\\n  return triangle.push(newRow)\\n}\\n\\nconst generate = (numRows) => {\\n  const triangle = [[1], [1, 1]]\\n\\n  if (numRows === 0) {\\n    return []\\n  } else if (numRows === 1) {\\n    return [[1]]\\n  } else if (numRows === 2) {\\n    return [[1], [1, 1]]\\n  } else {\\n    for (let i = 2; i < numRows; i++) {\\n      addRow(triangle)\\n    }\\n  }\\n  return triangle\\n}\\n\\nexport { generate }\\n\"",
    "perfect cube": "\"/**\\n * Author: dephraiim\\n * License: GPL-3.0 or later\\n *\\n */\\n\\nconst perfectCube = (num) => Math.round(num ** (1 / 3)) ** 3 === num\\n\\nexport { perfectCube }\\n\"",
    "perfect number": "\"/**\\n * Author: dephraiim\\n * License: GPL-3.0 or later\\n *\\n * == Perfect Number ==\\n * In number theory, a perfect number is a positive integer that is equal to the sum of\\n * its positive divisors(factors), excluding the number itself.\\n * For example: 6 ==> divisors[1, 2, 3, 6]\\n *      Excluding 6, the sum(divisors) is 1 + 2 + 3 = 6\\n *      So, 6 is a Perfect Number\\n * Other examples of Perfect Numbers: 28, 486, ...\\n *\\n * More on Perfect Number:\\n *      https://en.wikipedia.org/wiki/Perfect_number\\n *\\n */\\n\\nconst factorsExcludingNumber = (n) => {\\n  return [...Array(n).keys()].filter((num) => n % num === 0)\\n}\\n\\nconst perfectNumber = (n) => {\\n  const factorSum = factorsExcludingNumber(n).reduce((num, initialValue) => {\\n    return num + initialValue\\n  }, 0)\\n\\n  return factorSum === n\\n}\\n\\nexport { perfectNumber }\\n\"",
    "perfect square": "\"/**\\n * Author: dephraiim\\n * License: GPL-3.0 or later\\n *\\n */\\n\\nconst perfectSquare = (num) => Math.sqrt(num) ** 2 === num\\n\\nexport { perfectSquare }\\n\"",
    "permutation and combination": "\"/**\\n * @details Calculates the number of permutations and combinations.\\n * @external_link (Permutation And Combinations)[https://www.geeksforgeeks.org/permutation-and-combination/]\\n */\\n\\n/**\\n * @brief Calculates the factorial of the given number.\\n * @param num: integer\\n * @details Factorial of n = n * (n - 1) * (n - 2) * ... * 1\\n * @returns integer: Factorial of the number.\\n            NaN: if negative number is provided.\\n */\\nconst factorial = (n) => {\\n  if (n >= 0) {\\n    if (n === 0) {\\n      return 1\\n    } else {\\n      return n * factorial(n - 1)\\n    }\\n  } else {\\n    return NaN\\n  }\\n}\\n\\n/**\\n * @brief Calculates the number of Permutations from the given data.\\n * @param\\n * n: integer -> number of items.\\n * r: integer -> number of times n is taken.\\n * @returns integer: The number of permutations.\\n            NaN: if negative number is provided.\\n */\\nconst permutation = (n, r) => {\\n  return factorial(n) / factorial(n - r)\\n}\\n\\n/**\\n * @brief Calculates the number of Combinations from the given data.\\n * @param\\n * n -> number of items.\\n * r -> number of times n is taken.\\n * @returns integer: The number of combinations.\\n            NaN: if negative number is provided.\\n */\\nconst combination = (n, r) => {\\n  return factorial(n) / (factorial(r) * factorial(n - r))\\n}\\n\\n// Exports the functions to be used in other files.\\nexport { factorial, permutation, combination }\\n\"",
    "pi approximation monte carlo": "\"// Wikipedia: https://en.wikipedia.org/wiki/Monte_Carlo_method\\n// Video Explanation: https://www.youtube.com/watch?v=ELetCV_wX_c\\n\\nconst piEstimation = (iterations = 100000) => {\\n  let circleCounter = 0\\n\\n  for (let i = 0; i < iterations; i++) {\\n    // generating random points and checking if it lies within a circle of radius 1\\n    const x = Math.random()\\n    const y = Math.random()\\n    const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))\\n\\n    if (radius < 1) circleCounter += 1\\n  }\\n\\n  // fomula for pi = (ratio of number inside circle and total iteration) x 4\\n  const pi = (circleCounter / iterations) * 4\\n  return pi\\n}\\n\\nexport { piEstimation }\\n\"",
    "polynomial": "\"/**\\n * Polynomials are algebraic expressions consisting of two or more algebraic terms.\\n * Terms of a polynomial are:\\n * 1. Coefficients e.g. 5, 4 in 5x^0, 4x^3 respectively\\n * 2. Variables e.g. y in 3y^2\\n * 3. Exponents e.g. 5 in y^5\\n *\\n * Class Polynomial constructs the polynomial using Array as an argument.\\n * The members of array are coefficients and their indexes as exponents.\\n */\\nclass Polynomial {\\n  constructor (array) {\\n    this.coefficientArray = array // array of coefficients\\n    this.polynomial = '' // in terms of x e.g. (2x) + (1)\\n    this.construct()\\n  }\\n\\n  /**\\n   * Function to construct the polynomial in terms of x using the coefficientArray\\n   */\\n  construct () {\\n    this.polynomial = this.coefficientArray\\n      .map((coefficient, exponent) => {\\n        if (coefficient === 0) {\\n          return '0'\\n        }\\n        if (exponent === 0) {\\n          return `(${coefficient})`\\n        } else if (exponent === 1) {\\n          return `(${coefficient}x)`\\n        } else {\\n          return `(${coefficient}x^${exponent})`\\n        }\\n      })\\n      .filter((x) =>\\n        x !== '0'\\n      )\\n      .reverse()\\n      .join(' + ')\\n  }\\n\\n  /**\\n   * Function to display polynomial in terms of x\\n   * @returns {String} of polynomial representation in terms of x\\n   */\\n  display () {\\n    return this.polynomial\\n  }\\n\\n  /**\\n   * Function to calculate the value of the polynomial by substituting variable x\\n   * @param {Number} value\\n   */\\n  evaluate (value) {\\n    return this.coefficientArray.reduce((result, coefficient, exponent) => {\\n      return result + coefficient * Math.pow(value, exponent)\\n    }, 0)\\n  }\\n}\\n\\nexport { Polynomial }\\n\"",
    "pow": "\"// Returns the value of x to the power of y\\n\\nconst pow = (x, y) => {\\n  let result = 1\\n  for (let i = 1; i <= y; i++) {\\n    result *= x\\n  }\\n  return result\\n}\\n\\nexport { pow }\\n\"",
    "pow logarithmic": "\"import { isEven } from './IsEven'\\n\\n/**\\n * This algorithm is divide the n by 2 every time and pass this to recursive call to find the result of smaller result.\\n * why? Because\\n *      x^n => [if n is even] x^(n / 2) *  x^(n / 2)     (example : 7^4 => 7^2 * 7^2)\\n *             [if n is odd]  x^(n / 2) *  x^(n / 2) * x (example : 7^5 => 7^2 * 7^2 * 7)\\n * and repeat the above step until we reach to the base case.\\n *\\n * @function PowLogarithmic\\n * @description Given two integers x and n, return x^n in logarithmic complexity.\\n * @param {Integer} x - The input integer\\n * @param {Integer} n - The input integer\\n * @return {Integer} - Returns x^n.\\n * @see [Pow-Logarithmic](https://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/)\\n */\\nconst powLogarithmic = (x, n) => {\\n  if (n === 0) return 1\\n  const result = powLogarithmic(x, Math.floor(n / 2))\\n  if (isEven(n)) {\\n    return result * result\\n  }\\n  return result * result * x\\n}\\n\\nexport { powLogarithmic }\\n\"",
    "prime check": "\"/*\\r\\n  Modified from:\\r\\n    https://github.com/TheAlgorithms/Python/blob/master/maths/prime_check.py\\r\\n\\r\\n  Complexity:\\r\\n    O(sqrt(n))\\r\\n*/\\r\\n\\r\\nconst PrimeCheck = (n) => {\\r\\n  // input: n: int\\r\\n  // output: boolean\\r\\n  if (n === 1) return false\\r\\n  if (n === 0) return false\\r\\n  if (n === 2) return true\\r\\n  if (n % 2 === 0) return false\\r\\n\\r\\n  for (let i = 3; i * i <= n; i += 2) {\\r\\n    if (n % i === 0) {\\r\\n      return false\\r\\n    }\\r\\n  }\\r\\n  return true\\r\\n}\\r\\n\\r\\nexport { PrimeCheck }\\r\\n\"",
    "prime factors": "\"/*\\r\\n  Modified from:\\r\\n    https://github.com/TheAlgorithms/Python/blob/master/maths/prime_factors.py\\r\\n*/\\r\\n\\r\\nexport const PrimeFactors = (n) => {\\r\\n  // input: n: int\\r\\n  // output: primeFactors: Array of all prime factors of n\\r\\n  const primeFactors = []\\r\\n  for (let i = 2; i * i <= n; i++) {\\r\\n    while (n % i === 0) {\\r\\n      primeFactors.push(i)\\r\\n      n = Math.floor(n / i)\\r\\n    }\\r\\n  }\\r\\n  if (n > 1) {\\r\\n    primeFactors.push(n)\\r\\n  }\\r\\n  return primeFactors\\r\\n}\\r\\n\"",
    "radian to degree": "\"/*\\n * Radian : https://en.wikipedia.org/wiki/Radian\\n * Degree : https://en.wikipedia.org/wiki/Degree_(angle)\\n *\\n * Angle in Degree = ( Angle in Radian ) x ( 180 / pi )\\n *\\n * Example :\\n * Question : Convert pi / 2 degree to radian\\n * So, Angle in Radian = pi / 2\\n *\\n * Solution :\\n * Angle in Degree = ( pi / 2 ) x ( 180 / pi ) = 90\\n *\\n * So, pi / 2 radian is equal to 90 degree\\n */\\n\\n/**\\n * @param {number} radian\\n * @return {number}\\n */\\nexport const radianToDegree = (radian) => {\\n  return radian * (180 / Math.PI)\\n}\\n\"",
    "reverse number": "\"/*\\n    Problem statement and Explanation : https://medium.com/@ManBearPigCode/how-to-reverse-a-number-mathematically-97c556626ec6\\n*/\\n\\n/**\\n * ReverseNumber return the reversed value of the given number.\\n * @param {Number} n any digit number.\\n * @returns `Number` n reverse in reverse.\\n */\\nconst ReverseNumber = (number) => {\\n  // firstly, check that input is a number or not.\\n  if (typeof number !== 'number') {\\n    return new TypeError('Argument is not a number.')\\n  }\\n  // A variable for storing the reversed number.\\n  let reverseNumber = 0\\n  // Iterate the process until getting the number is 0.\\n  while (number > 0) {\\n    // get the last digit of the number\\n    const lastDigit = number % 10\\n    // add to the last digit to in reverseNumber\\n    reverseNumber = reverseNumber * 10 + lastDigit\\n    // reduce the actual number.\\n    number = Math.floor(number / 10)\\n  }\\n  return reverseNumber\\n}\\n\\nexport { ReverseNumber }\\n\"",
    "reverse polish notation": "\"// Wikipedia: https://en.wikipedia.org/wiki/Reverse_Polish_notation\\n\\nconst calcRPN = (expression) => {\\n  const operators = {\\n    '+': (a, b) => a + b,\\n    '-': (a, b) => a - b,\\n    '*': (a, b) => a * b,\\n    '/': (a, b) => b / a\\n  }\\n\\n  const tokens = expression.split(' ')\\n\\n  const stack = []\\n\\n  tokens.forEach((token) => {\\n    const operator = operators[token]\\n\\n    if (typeof operator === 'function') {\\n      const a = stack.pop()\\n      const b = stack.pop()\\n\\n      const result = operator(a, b)\\n\\n      stack.push(result)\\n    } else {\\n      stack.push(parseFloat(token))\\n    }\\n  })\\n\\n  return stack.pop()\\n}\\n\\nexport { calcRPN }\\n\"",
    "simpson integration": "\"/*\\n*\\n* @file\\n* @title Composite Simpson's rule for definite integral evaluation\\n* @author: [ggkogkou](https://github.com/ggkogkou)\\n* @brief Calculate definite integrals using composite Simpson's numerical method\\n*\\n* @details The idea is to split the interval in an EVEN number N of intervals and use as interpolation points the xi\\n* for which it applies that xi = x0 + i*h, where h is a step defined as h = (b-a)/N where a and b are the\\n* first and last points of the interval of the integration [a, b].\\n*\\n* We create a table of the xi and their corresponding f(xi) values and we evaluate the integral by the formula:\\n* I = h/3 * {f(x0) + 4*f(x1) + 2*f(x2) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}\\n*\\n* That means that the first and last indexed i f(xi) are multiplied by 1,\\n* the odd indexed f(xi) by 4 and the even by 2.\\n*\\n* N must be even number and a<b. By increasing N, we also increase precision\\n*\\n* More info: [Wikipedia link](https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule)\\n*\\n*/\\n\\nfunction integralEvaluation (N, a, b, func) {\\n  // Check if N is an even integer\\n  let isNEven = true\\n  if (N % 2 !== 0) isNEven = false\\n\\n  if (!Number.isInteger(N) || Number.isNaN(a) || Number.isNaN(b)) { throw new TypeError('Expected integer N and finite a, b') }\\n  if (!isNEven) { throw Error('N is not an even number') }\\n  if (N <= 0) { throw Error('N has to be >= 2') }\\n\\n  // Check if a < b\\n  if (a > b) { throw Error('a must be less or equal than b') }\\n  if (a === b) return 0\\n\\n  // Calculate the step h\\n  const h = (b - a) / N\\n\\n  // Find interpolation points\\n  let xi = a // initialize xi = x0\\n  const pointsArray = []\\n\\n  // Find the sum {f(x0) + 4*f(x1) + 2*f(x2) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}\\n  let temp\\n  for (let i = 0; i < N + 1; i++) {\\n    if (i === 0 || i === N) temp = func(xi)\\n    else if (i % 2 === 0) temp = 2 * func(xi)\\n    else temp = 4 * func(xi)\\n\\n    pointsArray.push(temp)\\n    xi += h\\n  }\\n\\n  // Calculate the integral\\n  let result = h / 3\\n  temp = 0\\n  for (let i = 0; i < pointsArray.length; i++) temp += pointsArray[i]\\n\\n  result *= temp\\n\\n  if (Number.isNaN(result)) { throw Error(\\\"Result is NaN. The input interval doesn't belong to the functions domain\\\") }\\n\\n  return result\\n}\\n\\nexport { integralEvaluation }\\n\"",
    "softmax": "\"// Wikipedia: https://en.wikipedia.org/wiki/Softmax_function\\n\\nconst Softmax = (inputs) => {\\n  const eulerExpOfAllInputs = inputs.map(input => Math.exp(input))\\n  const sumOfEulerExpOfAllInputs = eulerExpOfAllInputs.reduce((a, b) => a + b)\\n\\n  return inputs.map((input) => {\\n    const eulerExpInputs = Math.exp(input)\\n    return eulerExpInputs / sumOfEulerExpOfAllInputs\\n  })\\n}\\n\\nexport { Softmax }\\n\"",
    "square root": "\"/*\\n* Author: Rak Laptudirm\\n*\\n* https://en.wikipedia.org/wiki/Newton%27s_method\\n*\\n* Finding the square root of a number using Newton's method.\\n*/\\n\\nfunction sqrt (num, precision = 4) {\\n  if (!Number.isFinite(num)) { throw new TypeError(`Expected a number, received ${typeof num}`) }\\n  if (!Number.isFinite(precision)) { throw new TypeError(`Expected a number, received ${typeof precision}`) }\\n  let sqrt = 1\\n  for (let i = 0; i < precision; i++) {\\n    sqrt -= (sqrt * sqrt - num) / (2 * sqrt)\\n  }\\n  return sqrt\\n}\\n\\nexport { sqrt }\\n\"",
    "sum of digits": "\"/*\\n  Gets the sum of the digits of the numbers inputted\\n  sumOfDigits(10) will return 1 + 0 = 1\\n  sumOfDigits(255) will return 2 + 5 + 5 = 12\\n  Wikipedia: https://en.wikipedia.org/wiki/Digit_sum\\n*/\\n\\n/*\\n  The given input is converted to a string, split into an array of characters.\\n  This array is reduced to a number using the method <Array>.reduce\\n  NOTE: The final parseInt is just there in cases where 1 digit numbers are given, since without that it would result in a String output.\\n*/\\nfunction sumOfDigitsUsingString (number) {\\n  if (number < 0) number = -number\\n\\n  return Number.parseInt(number.toString().split('').reduce((a, b) => Number(a) + Number(b)))\\n}\\n\\n/*\\n  The input is divided by 10 in each iteration, till the input is equal to 0\\n  The sum of all the digits is returned (The res variable acts as a collector, taking the remainders on each iteration)\\n*/\\nfunction sumOfDigitsUsingLoop (number) {\\n  if (number < 0) number = -number\\n  let res = 0\\n\\n  while (number > 0) {\\n    res += number % 10\\n    number = Math.floor(number / 10)\\n  }\\n\\n  return res\\n}\\n\\n/*\\n  We use the fact that the sum of the digits of a one digit number is itself, and check whether the number is less than 10. If so, then we return the number. Else, we take the number divided by 10 and floored, and recursively call the function, while adding it with the number mod 10\\n*/\\nfunction sumOfDigitsUsingRecursion (number) {\\n  if (number < 0) number = -number\\n\\n  if (number < 10) return number\\n\\n  return (number % 10) + sumOfDigitsUsingRecursion(Math.floor(number / 10))\\n}\\n\\nexport { sumOfDigitsUsingRecursion, sumOfDigitsUsingLoop, sumOfDigitsUsingString }\\n\"",
    "sum of geometric progression": "\"/*\\n  Returns the sum of a geometric progression\\n  Article on Geometric Progression: https://en.wikipedia.org/wiki/Geometric_series\\n  Examples:\\n  > sumOfGeometricProgression(2, 0.5, 6)\\n  3.9375\\n  > sumOfGeometricProgression(0.5, 10, 3)\\n  55.5\\n  > sumOfGeometricProgression(0.5, 10, Infinity)\\n  Error: The geometric progression is diverging, and its sum cannot be calculated\\n*/\\n\\n/**\\n *\\n * @param {Number} firstTerm The first term of the geometric progression\\n * @param {Number} commonRatio The common ratio of the geometric progression\\n * @param {Number} numOfTerms The number of terms in the progression\\n */\\nfunction sumOfGeometricProgression (firstTerm, commonRatio, numOfTerms) {\\n  if (!Number.isFinite(numOfTerms)) {\\n    /*\\n      If the number of Terms is Infinity, the common ratio needs to be less than 1 to be a convergent geometric progression\\n      Article on Convergent Series: https://en.wikipedia.org/wiki/Convergent_series\\n    */\\n    if (Math.abs(commonRatio) < 1) return firstTerm / (1 - commonRatio)\\n    throw new Error('The geometric progression is diverging, and its sum cannot be calculated')\\n  }\\n\\n  if (commonRatio === 1) return firstTerm * numOfTerms\\n\\n  return (firstTerm * (Math.pow(commonRatio, numOfTerms) - 1)) / (commonRatio - 1)\\n}\\n\\nexport { sumOfGeometricProgression }\\n\"",
    "volume": "\"/*\\nCalculate the volume of the shapes\\n\\nVolume for Cuboid\\nVolume for Cube\\nVolume for Cone\\nVolume for Pyramid\\nVolume for Cylinder\\nVolume for Triangular Prism\\nVolume for Pentagonal Prism\\nVolume for Sphere\\nVolume for Hemisphere\\n*/\\n\\n/*\\n  Calculate the volume for a Cuboid\\n  Reference: https://www.cuemath.com/measurement/volume-of-cuboid/\\n  return width * length * height\\n*/\\nconst volCuboid = (width, length, height) => {\\n  isNumber(width, 'Width')\\n  isNumber(length, 'Length')\\n  isNumber(height, 'Height')\\n  return (width * length * height)\\n}\\n\\n/*\\n  Calculate the volume for a Cube\\n  Reference: https://www.cuemath.com/measurement/volume-of-cube/\\n  return length * length * length\\n*/\\nconst volCube = (length) => {\\n  isNumber(length, 'Length')\\n  return (length ** 3)\\n}\\n\\n/*\\n  Calculate the volume for a Cone\\n  Reference: https://www.cuemath.com/measurement/volume-of-cone/\\n  return PI * radius^2 * height/3\\n*/\\nconst volCone = (radius, height) => {\\n  isNumber(radius, 'Radius')\\n  isNumber(height, 'Height')\\n  return (Math.PI * radius ** 2 * height / 3.0)\\n}\\n\\n/*\\n  Calculate the volume for a Pyramid\\n  Reference: https://www.cuemath.com/measurement/volume-of-pyramid/\\n  return (baseLength * baseWidth * height) / 3\\n*/\\nconst volPyramid = (baseLength, baseWidth, height) => {\\n  isNumber(baseLength, 'BaseLength')\\n  isNumber(baseWidth, 'BaseWidth')\\n  isNumber(height, 'Height')\\n  return (baseLength * baseWidth * height) / 3.0\\n}\\n\\n/*\\n  Calculate the volume for a Cylinder\\n  Reference: https://www.cuemath.com/measurement/volume-of-cylinder/\\n  return PI * radius^2 * height\\n*/\\nconst volCylinder = (radius, height) => {\\n  isNumber(radius, 'Radius')\\n  isNumber(height, 'Height')\\n  return (Math.PI * radius ** 2 * height)\\n}\\n\\n/*\\n  Calculate the volume for a Triangular Prism\\n  Reference: http://lrd.kangan.edu.au/numbers/content/03_volume/04_page.htm\\n  return 1 / 2 * baseLengthTriangle * heightTriangle * height\\n*/\\nconst volTriangularPrism = (baseLengthTriangle, heightTriangle, height) => {\\n  isNumber(baseLengthTriangle, 'BaseLengthTriangle')\\n  isNumber(heightTriangle, 'HeightTriangle')\\n  isNumber(height, 'Height')\\n  return (1 / 2 * baseLengthTriangle * heightTriangle * height)\\n}\\n\\n/*\\n  Calculate the volume for a Pentagonal Prism\\n  Reference: https://www.cuemath.com/measurement/volume-of-pentagonal-prism/\\n  return 5/2 * pentagonalLength * pentagonalBaseLength * height\\n*/\\nconst volPentagonalPrism = (pentagonalLength, pentagonalBaseLength, height) => {\\n  isNumber(pentagonalLength, 'PentagonalLength')\\n  isNumber(pentagonalBaseLength, 'PentagonalBaseLength')\\n  isNumber(height, 'Height')\\n  return (5 / 2 * pentagonalLength * pentagonalBaseLength * height)\\n}\\n\\n/*\\n  Calculate the volume for a Sphere\\n  Reference: https://www.cuemath.com/measurement/volume-of-sphere/\\n  return 4/3 * PI * radius^3\\n*/\\nconst volSphere = (radius) => {\\n  isNumber(radius, 'Radius')\\n  return (4 / 3 * Math.PI * radius ** 3)\\n}\\n\\n/*\\n  Calculate the volume for a Hemisphere\\n  Reference: https://www.cuemath.com/measurement/volume-of-hemisphere/\\n  return (2 * PI * radius^3)/3\\n*/\\nconst volHemisphere = (radius) => {\\n  isNumber(radius, 'Radius')\\n  return (2.0 * Math.PI * radius ** 3) / 3.0\\n}\\n\\nconst isNumber = (number, noName = 'number') => {\\n  if (typeof number !== 'number') {\\n    throw new TypeError('The ' + noName + ' should be Number type')\\n  } else if (number < 0 || (!Number.isFinite(number))) {\\n    throw new Error('The ' + noName + ' only accepts positive values')\\n  }\\n}\\n\\nexport { volCuboid, volCube, volCone, volPyramid, volCylinder, volTriangularPrism, volPentagonalPrism, volSphere, volHemisphere }\\n\"",
    "while loop factorial": "\"/*\\n    author: Theepag\\n */\\nexport const factorialize = (num) => {\\n  // Step 1. variable result to store num\\n  let result = num\\n  // If num = 0 OR 1, the factorial will return 1\\n  if (num === 0 || num === 1) { return 1 }\\n  // Step 2. WHILE loop\\n  while (num > 1) {\\n    num-- // decrement 1 at each iteration\\n    result = result * num // or result = result * num;\\n  }\\n  // Step 3. Return the factorial\\n  return result\\n}\\n\"",
    "haversine": "\"/**\\n * @function HaversineDistance\\n * @description Calculate the distance between two coordinates using the haversine formula\\n * @param {Integer} latitude1 - The input integer\\n * @param {Integer} latitude2 - The input integer\\n * @param {Integer} longitude1 - The input integer\\n * @param {Integer} longitude2 - The input integer\\n * @return {Integer} Haversine Distance.\\n * @see [Haversine_Distance](https://pt.wikipedia.org/wiki/F%C3%B3rmula_de_Haversine)\\n */\\nconst haversineDistance = (latitude1 = 0, longitude1 = 0, latitude2 = 0, longitude2 = 0) => {\\n  validateLatOrLong(latitude1)\\n  validateLatOrLong(latitude2)\\n  validateLatOrLong(longitude1)\\n  validateLatOrLong(longitude2)\\n  const earthRadius = 6371e3 // 6,371km\\n  const pi = Math.PI\\n  const cos1 = latitude1 * pi / 180.0\\n  const cos2 = latitude2 * pi / 180.0\\n  const deltaLatitude = (latitude2 - latitude1) * pi / 180.0\\n  const deltaLongitude = (longitude2 - longitude1) * pi / 180.0\\n\\n  const alpha = Math.sin(deltaLatitude / 2) * Math.sin(deltaLatitude / 2) + Math.cos(cos1) * Math.cos(cos2) * Math.sin(deltaLongitude / 2) * Math.sin(deltaLongitude / 2)\\n  const constant = 2 * Math.atan2(Math.sqrt(alpha), Math.sqrt(1 - alpha))\\n  return earthRadius * constant\\n}\\n\\nconst validateLatOrLong = value => {\\n  if (typeof value !== 'number') {\\n    throw new TypeError('The value of latitude or longitude should be a number')\\n  }\\n}\\n\\nexport { haversineDistance }\\n\"",
    "problem001": "\"// https://projecteuler.net/problem=1\\n/*    Multiples of 3 and 5\\n    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\\nFind the sum of all the multiples of 3 or 5 below the provided parameter value number.\\n*/\\n\\nconst multiplesThreeAndFive = (num) => {\\n  let total = 0\\n  // total for calculating the sum\\n  for (let i = 0; i < num; i++) {\\n    if (i % 3 === 0 || i % 5 === 0) {\\n      total += i\\n    }\\n  }\\n  return total\\n}\\n\\nexport { multiplesThreeAndFive }\\n\"",
    "problem002": "\"// https://projecteuler.net/problem=2\\nconst SQ5 = 5 ** 0.5 // Square root of 5\\nconst PHI = (1 + SQ5) / 2 // definition of PHI\\n\\n// theoretically it should take O(1) constant amount of time as long\\n// arithmetic calculations are considered to be in constant amount of time\\nexport const EvenFibonacci = (limit) => {\\n  const highestIndex = Math.floor(Math.log(limit * SQ5) / Math.log(PHI))\\n  const n = Math.floor(highestIndex / 3)\\n  return ((PHI ** (3 * n + 3) - 1) / (PHI ** 3 - 1) -\\n    ((1 - PHI) ** (3 * n + 3) - 1) / ((1 - PHI) ** 3 - 1)) / SQ5\\n}\\n\"",
    "problem003": "\"// https://projecteuler.net/problem=3\\n\\nexport const largestPrime = (num = 600851475143) => {\\n  let newnumm = num\\n  let largestFact = 0\\n  let counter = 2\\n  while (counter * counter <= newnumm) {\\n    if (newnumm % counter === 0) {\\n      newnumm = newnumm / counter\\n    } else {\\n      counter++\\n    }\\n  }\\n  if (newnumm > largestFact) {\\n    largestFact = newnumm\\n  }\\n  return largestFact\\n}\\n\"",
    "problem004": "\"// https://projecteuler.net/problem=4\\n/* A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.\\n   Find the largest palindrome made from the product of two 3-digit numbers.\\n*/\\nexport const largestPalindromic = (digits) => {\\n  let i\\n  let n\\n  let m\\n  let d\\n  let limit\\n  let number = 0\\n\\n  for (i = 1; i < digits; i++) {\\n    number = 10 * number + 9\\n  }\\n  const inf = number // highest (digits - 1) number, in this example highest 2 digit number\\n  const sup = 10 * number + 9 // highest (digits) number, in this example highest 3 digit number\\n\\n  const isPalindromic = (n) => {\\n    let p = 0\\n    const q = n\\n    let r\\n    while (n > 0) {\\n      r = n % 10\\n      p = 10 * p + r\\n      n = Math.floor(n / 10)\\n    }\\n    return p === q // returning whether the number is palindromic or not\\n  }\\n\\n  for (n = sup * sup, m = inf * inf; n > m; n--) {\\n    if (isPalindromic(n)) {\\n      limit = Math.ceil(Math.sqrt(n))\\n      d = sup\\n      while (d >= limit) {\\n        if (n % d === 0 && n / d > inf) {\\n          return n\\n        }\\n        d -= 1\\n      }\\n    }\\n  }\\n  return NaN // returning not a number, if any such case arise\\n}\\n\"",
    "problem005": "\"/*\\nSmallest multiple\\n\\n2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.\\nWhat is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?\\n*/\\n\\nexport const findSmallestMultiple = () => {\\n  const divisors = [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\\n  let num = 21\\n  let result\\n\\n  while (!result) {\\n    const isDivisibleByAll = divisors.every((divisor) => num % divisor === 0)\\n    if (isDivisibleByAll) result = num\\n    else num++\\n  }\\n\\n  return result\\n}\\n\"",
    "problem006": "\"// https://projecteuler.net/problem=6\\n\\nexport const squareDifference = (num = 100) => {\\n  let sumOfSquares = 0\\n  let sums = 0\\n  for (let i = 1; i <= num; i++) {\\n    sumOfSquares += i ** 2 // add squares to the sum of squares\\n    sums += i // add number to sum to square later\\n  }\\n  return (sums ** 2) - sumOfSquares // difference of square of the total sum and sum of squares\\n}\\n\"",
    "problem008": "\"// Problem: https://projecteuler.net/problem=8\\n\\nconst largestAdjacentNumber = (grid, consecutive) => {\\n  grid = grid.split('\\\\n').join('')\\n  const splitedGrid = grid.split('\\\\n')\\n  let largestProd = 0\\n\\n  for (const row in splitedGrid) {\\n    const currentRow = splitedGrid[row].split('').map(x => Number(x))\\n\\n    for (let i = 0; i < currentRow.length - consecutive; i++) {\\n      const combine = currentRow.slice(i, i + consecutive)\\n\\n      if (!combine.includes(0)) {\\n        const product = combine.reduce(function (a, b) {\\n          return a * b\\n        })\\n\\n        if (largestProd < product) largestProd = product\\n      }\\n    }\\n  }\\n  return largestProd\\n}\\n\\nexport { largestAdjacentNumber }\\n\"",
    "problem009": "\"/*\\nSpecial Pythagorean triplet\\n\\nA Pythagorean triplet is a set of three natural numbers, a < b < c, for which,\\n\\na^2 + b^2 = c^2\\nFor example, 32 + 42 = 9 + 16 = 25 = 52.\\n\\nThere exists exactly one Pythagorean triplet for which a + b + c = 1000.\\nFind the product abc.\\n*/\\n\\nconst isPythagoreanTriplet = (a, b, c) => Math.pow(a, 2) + Math.pow(b, 2) === Math.pow(c, 2)\\n\\nexport const findSpecialPythagoreanTriplet = () => {\\n  for (let a = 0; a < 1000; a++) {\\n    for (let b = a + 1; b < 1000; b++) {\\n      for (let c = b + 1; c < 1000; c++) {\\n        if (isPythagoreanTriplet(a, b, c) && a + b + c === 1000) {\\n          return a * b * c\\n        }\\n      }\\n    }\\n  }\\n}\\n\"",
    "problem010": "\"// https://projecteuler.net/problem=10\\n\\nconst isPrime = (number) => {\\n  if (number === 2) return true\\n  if (number % 2 === 0) return false\\n\\n  for (let j = 3; j * j <= number; j += 2) {\\n    if (number % j === 0) {\\n      return false\\n    }\\n  }\\n  return true\\n}\\n\\nconst calculateSumOfPrimeNumbers = (maxNumber) => {\\n  let sum = 0\\n  for (let i = maxNumber - 1; i >= 2; i--) {\\n    if (isPrime(parseInt(i)) === true) {\\n      sum += i\\n    }\\n  }\\n  return sum\\n}\\nexport { calculateSumOfPrimeNumbers }\\n\"",
    "problem012": "\"/**\\n * Problem 12 - Highly divisible triangular number\\n *\\n * https://projecteuler.net/problem=11\\n *\\n * The sequence of triangle numbers is generated by adding the natural numbers.\\n * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.\\n *\\n * The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\\n * Let us list the factors of the first seven triangle numbers:\\n *\\n * 1: 1\\n * 3: 1,3\\n * 6: 1,2,3,6\\n * 10: 1,2,5,10\\n * 15: 1,3,5,15\\n * 21: 1,3,7,21\\n * 28: 1,2,4,7,14,28\\n *\\n * We can see that 28 is the first triangle number to have over five divisors.\\n *\\n * What is the value of the first triangle number to have over five hundred divisors?\\n*/\\n\\n/**\\n * Gets number of divisors of a given number\\n * @params num The number whose divisors to find\\n */\\nconst getNumOfDivisors = (num) => {\\n  // initialize numberOfDivisors\\n  let numberOfDivisors = 0\\n\\n  // if one divisor less than sqrt(num) exists\\n  // then another divisor greater than sqrt(n) exists and its value is num/i\\n  const sqrtNum = Math.sqrt(num)\\n  for (let i = 0; i <= sqrtNum; i++) {\\n    // check if i divides num\\n    if (num % i === 0) {\\n      if (i === sqrtNum) {\\n        // if both divisors are equal, i.e., num is perfect square, then only 1 divisor\\n        numberOfDivisors++\\n      } else {\\n        // 2 divisors, one of them is less than sqrt(n), other greater than sqrt(n)\\n        numberOfDivisors += 2\\n      }\\n    }\\n  }\\n  return numberOfDivisors\\n}\\n\\n/**\\n * Loops till first triangular number with 500 divisors is found\\n */\\nconst firstTriangularWith500Divisors = () => {\\n  let triangularNum\\n  // loop forever until numOfDivisors becomes greater than or equal to 500\\n  for (let n = 1; ; n++) {\\n    // nth triangular number is (1/2)*n*(n+1) by Arithmetic Progression\\n    triangularNum = (1 / 2) * n * (n + 1)\\n    if (getNumOfDivisors(triangularNum) >= 500) return triangularNum\\n  }\\n}\\n\\nexport { firstTriangularWith500Divisors }\\n\"",
    "problem014": "\"/*\\nLongest Collatz sequence\\n\\nThe following iterative sequence is defined for the set of positive integers:\\n\\nn → n/2 (n is even)\\nn → 3n + 1 (n is odd)\\n\\nUsing the rule above and starting with 13, we generate the following sequence:\\n\\n13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1\\nIt can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.\\n\\nWhich starting number, under one million, produces the longest chain?\\n\\nNOTE: Once the chain starts the terms are allowed to go above one million.\\n*/\\n\\nconst getCollatzSequenceLength = (num, seqLength) => {\\n  if (num === 1) {\\n    return seqLength\\n  } else {\\n    let newElement\\n    if (num % 2 === 0) {\\n      newElement = num / 2\\n    } else {\\n      newElement = (3 * num) + 1\\n    }\\n    seqLength++\\n    return getCollatzSequenceLength(newElement, seqLength)\\n  }\\n}\\n\\nexport const findLongestCollatzSequence = (limit = 1000000) => {\\n  let startingPointForLargestSequence = 1\\n  let largestSequenceLength = 1\\n  for (let i = 2; i < limit; i++) {\\n    const currentSequenceLength = getCollatzSequenceLength(i, 1)\\n    if (currentSequenceLength > largestSequenceLength) {\\n      startingPointForLargestSequence = i\\n      largestSequenceLength = currentSequenceLength\\n    }\\n  }\\n  return startingPointForLargestSequence\\n}\\n\"",
    "problem015": "\"// https://projecteuler.net/problem=15\\n/* Starting in the top left corner of a 2×2 grid, and only being able to move to\\nthe right and down, there are exactly 6 routes to the bottom right corner.\\nHow many such routes are there through a 20×20 grid?\\n*/\\n\\n// A lattice path is composed of horizontal and vertical lines that pass through lattice points.\\n\\nexport const latticePath = (gridSize) => {\\n  let paths\\n  for (let i = 1, paths = 1; i <= gridSize; i++) {\\n    paths = paths * (gridSize + i) / i\\n  }\\n  // The total number of paths can be found using the binomial coefficient (b+a)/a.\\n  return paths\\n}\\n\\n// > latticePath(20))\\n// 137846528820\\n\"",
    "problem016": "\"/**\\n * Problem 16 - Power digit sum\\n *\\n * @see {@link https://projecteuler.net/problem=16}\\n *\\n * 2¹⁵ = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.\\n *\\n * What is the sum of the digits of the number 2¹⁰⁰⁰ ?\\n */\\n\\n/**\\n * Returns the power digit sum of n^pow.\\n *\\n * @param {number} [n=2]\\n * @param {number} [pow=1000]\\n * @returns {number}\\n */\\nconst powerDigitSum = function (n = 2, pow = 1000) {\\n  // The idea is to consider each digit (d*10^exp) separately, right-to-left.\\n  // digits = [units, tens, ...]\\n\\n  const digits = [n]\\n  let p = 1\\n\\n  while (++p <= pow) {\\n    let carry = 0\\n    for (let exp = 0; exp < digits.length; exp++) {\\n      const prod = digits[exp] * n + carry\\n      carry = Math.floor(prod / 10)\\n      digits[exp] = prod % 10\\n    }\\n    while (carry > 0) {\\n      digits.push(carry % 10)\\n      carry = Math.floor(carry / 10)\\n    }\\n  }\\n\\n  // (digits are reversed but we only want the sum so it doesn't matter)\\n\\n  return digits.reduce((prev, current) => prev + current, 0)\\n}\\n\\nexport { powerDigitSum }\\n\"",
    "problem018": "\"/**\\n * @file Provides solution for Project Euler Problem 18 - Maximum path sum I\\n * @author Eric Lavault {@link https://github.com/lvlte}\\n * @license MIT\\n */\\n\\n/**\\n * Problem 18 - Maximum path sum I\\n *\\n * @see {@link https://projecteuler.net/problem=18}\\n *\\n * By starting at the top of the triangle below and moving to adjacent numbers\\n * on the row below, the maximum total from top to bottom is 23 :\\n *\\n *                            3\\n *                           7 4\\n *                          2 4 6\\n *                         8 5 9 3\\n *\\n * That is, 3 + 7 + 4 + 9 = 23.\\n *\\n * Find the maximum total from top to bottom of the triangle below :\\n *\\n *                            75\\n *                           95 64\\n *                         17 47 82\\n *                        18 35 87 10\\n *                      20 04 82 47 65\\n *                     19 01 23 75 03 34\\n *                   88 02 77 73 07 63 67\\n *                  99 65 04 28 06 16 70 92\\n *                41 41 26 56 83 40 80 70 33\\n *               41 48 72 33 47 32 37 16 94 29\\n *             53 71 44 65 25 43 91 52 97 51 14\\n *            70 11 33 28 77 73 17 78 39 68 17 57\\n *          91 71 52 38 17 14 91 43 58 50 27 29 48\\n *         63 66 04 68 89 53 67 30 73 16 69 87 40 31\\n *       04 62 98 27 23 09 70 98 73 93 38 53 60 04 23\\n *\\n * NOTE: As there are only 16384 routes, it is possible to solve this problem\\n * by trying every route. However, Problem 67, is the same challenge with a\\n * triangle containing one-hundred rows; it cannot be solved by brute force,\\n * and requires a clever method! ;o)\\n */\\n\\nconst triangle = `\\n75\\n95 64\\n17 47 82\\n18 35 87 10\\n20 04 82 47 65\\n19 01 23 75 03 34\\n88 02 77 73 07 63 67\\n99 65 04 28 06 16 70 92\\n41 41 26 56 83 40 80 70 33\\n41 48 72 33 47 32 37 16 94 29\\n53 71 44 65 25 43 91 52 97 51 14\\n70 11 33 28 77 73 17 78 39 68 17 57\\n91 71 52 38 17 14 91 43 58 50 27 29 48\\n63 66 04 68 89 53 67 30 73 16 69 87 40 31\\n04 62 98 27 23 09 70 98 73 93 38 53 60 04 23\\n`\\n\\nexport const maxPathSum = function (grid = triangle) {\\n  /**\\n   * If we reduce the problem to its simplest form, considering :\\n   *\\n   *         7      -> The max sum depends on the two adjacent numbers below 7,\\n   *        2 4        not 7 itself.\\n   *\\n   *    obviously 4 > 2 therefore the max sum is 7 + 4 = 11\\n   *\\n   *                       6\\n   * Likewise, with :     4 6     6 > 4 therefore the max sum is 6 + 6 = 12\\n   *\\n   * Now, let's say we are given :\\n   *\\n   *         3\\n   *        7 6\\n   *       2 4 6\\n   *\\n   *    and we decompose it into sub-problems such that each one fits the simple\\n   *    case above, we got :\\n   *\\n   *         .           .           3\\n   *        7 .         . 6         ? ?\\n   *       2 4 .       . 4 6       . . .\\n   *\\n   *    Again, considering any number, the best path depends on the two adjacent\\n   *    numbers below it, not the number itself. That's why we have to compute\\n   *    the max sum from bottom to top, replacing each number with the sum of\\n   *    that number plus the greatest of the two adjacent numbers computed from\\n   *    the previous row.\\n   *\\n   *          .          .              3              15\\n   *        11 .        . 12    ->    11 12    ->    x   x\\n   *       x  x .      . x  x        x  x  x        x  x  x\\n   *\\n   * We are simplifying a complicated problem by breaking it down into simpler\\n   * sub-problems in a recursive manner, this is called Dynamic Programming.\\n   */\\n\\n  grid = grid.split(/\\\\r\\\\n|\\\\n/).filter(l => l).map(r => r.split(' ').map(n => +n))\\n\\n  for (let i = grid.length - 2; i >= 0; i--) {\\n    for (let j = 0; j < grid[i].length; j++) {\\n      grid[i][j] += Math.max(grid[i + 1][j], grid[i + 1][j + 1])\\n    }\\n  }\\n\\n  return grid[0][0]\\n}\\n\"",
    "problem020": "\"/**\\n * Problem 20 - Factorial digit sum\\n *\\n * @see {@link https://projecteuler.net/problem=20}\\n *\\n * n! means n × (n − 1) × ... × 3 × 2 × 1\\n *\\n * For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,\\n * and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27\\n *\\n * Find the sum of the digits in the number 100!\\n */\\n\\nconst factorialDigitSum = (n = 100) => {\\n  // Consider each digit*10^exp separately, right-to-left ([units, tens, ...]).\\n  const digits = [1]\\n\\n  for (let x = 2; x <= n; x++) {\\n    let carry = 0\\n    for (let exp = 0; exp < digits.length; exp++) {\\n      const prod = digits[exp] * x + carry\\n      carry = Math.floor(prod / 10)\\n      digits[exp] = prod % 10\\n    }\\n    while (carry > 0) {\\n      digits.push(carry % 10)\\n      carry = Math.floor(carry / 10)\\n    }\\n  }\\n\\n  // (digits are reversed but we only want the sum so it doesn't matter)\\n\\n  return digits.reduce((prev, current) => prev + current, 0)\\n}\\n\\nexport { factorialDigitSum }\\n\"",
    "problem023": "\"/**\\r\\n * Problem 23 - Non-Abundant Sums\\r\\n *\\r\\n * @see {@link https://projecteuler.net/problem=23}\\r\\n *\\r\\n * A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.\\r\\n *\\r\\n * A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.\\r\\n *\\r\\n * As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.\\r\\n *\\r\\n * Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.\\r\\n *\\r\\n */\\r\\n\\r\\n/**\\r\\n * collect the abundant numbers, generate and store their sums with each other, and check for numbers not in the llst of sums, adds them and returns their sum.\\r\\n * @param {number} [n = 28123]\\r\\n * @returns {number}\\r\\n */\\r\\n\\r\\nfunction sumOfNonAbundantNumbers (n = 28123) {\\r\\n  const abundantNumbers = [] // array to store the abundant numbers\\r\\n  const sumOfAbundantNumbers = {} // instead of an array, checking an object takes way less time. sets may be used as well.\\r\\n  let sum = 0\\r\\n\\r\\n  for (let i = 1; i <= n; i++) {\\r\\n    if (isAbundant(i)) {\\r\\n      abundantNumbers.push(i) // collect the abundant numbers\\r\\n      abundantNumbers.forEach(num => { // collect their sums\\r\\n        const sum = num + i\\r\\n        sumOfAbundantNumbers[sum] = true\\r\\n      })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  for (let i = 1; i <= n; i++) {\\r\\n    if (!sumOfAbundantNumbers[i]) { // if the number is not found in the list of sums, then it is added\\r\\n      sum += i\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return sum\\r\\n}\\r\\n\\r\\n/**\\r\\n * generates the divisors of the number and checks if it is abundant\\r\\n * @param {number} number\\r\\n * @returns {bool}\\r\\n */\\r\\n\\r\\nfunction isAbundant (number) {\\r\\n  let sum = 0\\r\\n  for (let i = 1; i <= number / 2; i++) {\\r\\n    if (number % i === 0) { // generate divisors\\r\\n      sum += i // calculate their sums\\r\\n    }\\r\\n  }\\r\\n  return sum > number\\r\\n}\\r\\n\\r\\nexport { sumOfNonAbundantNumbers }\\r\\n\"",
    "problem025": "\"/**\\r\\n* Problem 25 - 1000-digit Fibonacci number\\r\\n*\\r\\n* @see {@link https://projecteuler.net/problem=25}\\r\\n*\\r\\n* The Fibonacci sequence is defined by the recurrence relation:\\r\\n*\\r\\n* Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.\\r\\n*\\r\\n* Hence the first 12 terms will be:\\r\\n*\\r\\n* F1 = 1\\r\\n* F2 = 1\\r\\n* F3 = 2\\r\\n* F4 = 3\\r\\n* F5 = 5\\r\\n* F6 = 8\\r\\n* F7 = 13\\r\\n* F8 = 21\\r\\n* F9 = 34\\r\\n* F10 = 55\\r\\n* F11 = 89\\r\\n* F12 = 144\\r\\n* The 12th term, F12, is the first term to contain three digits.\\r\\n\\r\\n* What is the index of the first term in the Fibonacci sequence to contain 1000 digits?\\r\\n*/\\r\\n\\r\\n// brute force method\\r\\n\\r\\nfunction fibonacciIndex (t = 1000) {\\r\\n  const digits = 10n ** BigInt(t - 1)\\r\\n  let fib0 = BigInt(0)\\r\\n  let fib1 = BigInt(1)\\r\\n  let index = 1\\r\\n  while (fib1 < digits) { // using this to compare number of digits instead of .toString() significantly improved run time\\r\\n    const tempfib = fib1\\r\\n    fib1 = fib1 + fib0\\r\\n    fib0 = tempfib\\r\\n    index += 1\\r\\n  }\\r\\n  return (index)\\r\\n}\\r\\n\\r\\nexport { fibonacciIndex }\\r\\n\"",
    "binary equivalent": "\"/*\\n * Problem Statement: Given a positive number `num`, find it's binary equivalent using recursion\\n *\\n * What is Binary Equivalent?\\n * - In binary number system, a number is represented in terms of 0s and 1s,\\n *   for example:\\n *    - Binary Of 2 = 10\\n *    - Binary of 3 = 11\\n *    - Binary of 4 = 100\\n *\\n * Reference on how to find Binary Equivalent\\n * - https://byjus.com/maths/decimal-to-binary/\\n *\\n */\\n\\nexport const binaryEquivalent = (num) => {\\n  if (num === 0 || num === 1) {\\n    return String(num)\\n  }\\n  return binaryEquivalent(Math.floor(num / 2)) + String(num % 2)\\n}\\n\"",
    "binary search": "\"/* Binary Search: https://en.wikipedia.org/wiki/Binary_search_algorithm\\n *\\n * Search a sorted array by repeatedly dividing the search interval\\n * in half. Begin with an interval covering the whole array. If the value of the\\n * search key is less than the item in the middle of the interval, narrow the interval\\n * to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the\\n * value is found or the interval is empty.\\n */\\n\\nfunction binarySearchRecursive (arr, x, low = 0, high = arr.length - 1) {\\n  const mid = Math.floor(low + (high - low) / 2)\\n\\n  if (high >= low) {\\n    if (arr[mid] === x) {\\n      // item found => return its index\\n      return mid\\n    }\\n\\n    if (x < arr[mid]) {\\n      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid\\n      return binarySearchRecursive(arr, x, low, mid - 1)\\n    } else {\\n      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high\\n      return binarySearchRecursive(arr, x, mid + 1, high)\\n    }\\n  } else {\\n    // if low > high => we have searched the whole array without finding the item\\n    return -1\\n  }\\n}\\nfunction binarySearchIterative (arr, x, low = 0, high = arr.length - 1) {\\n  while (high >= low) {\\n    const mid = Math.floor(low + (high - low) / 2)\\n\\n    if (arr[mid] === x) {\\n      // item found => return its index\\n      return mid\\n    }\\n\\n    if (x < arr[mid]) {\\n      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid\\n      high = mid - 1\\n    } else {\\n      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high\\n      low = mid + 1\\n    }\\n  }\\n  // if low > high => we have searched the whole array without finding the item\\n  return -1\\n}\\n\\nexport { binarySearchIterative, binarySearchRecursive }\\n\\n/* ---------------------------------- Test ---------------------------------- */\\n\\n// const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\\n// const stringArr = [\\n//   'Alpha',\\n//   'Bravo',\\n//   'Charlie',\\n//   'Delta',\\n//   'Echo',\\n//   'Foxtrot',\\n//   'Golf',\\n//   'Hotel',\\n//   'India',\\n//   'Juliet',\\n//   'Kilo',\\n//   'Lima',\\n//   'Mike',\\n//   'November',\\n//   'Oscar',\\n//   'Papa',\\n//   'Quebec',\\n//   'Romeo',\\n//   'Sierra',\\n//   'Tango',\\n//   'Uniform',\\n//   'Victor',\\n//   'Whiskey',\\n//   'X-Ray',\\n//   'Yankee',\\n//   'Zulu'\\n// ]\\n\\n// binarySearchRecursive(arr, 3)\\n// binarySearchIterative(arr, 7)\\n// binarySearchRecursive(arr, 13)\\n// binarySearchIterative(stringArr, 'Charlie')\\n// binarySearchRecursive(stringArr, 'Zulu')\\n// binarySearchIterative(stringArr, 'Sierra')\\n\"",
    "eucledian g c d": "\"function euclideanGCDRecursive (first, second) {\\n  /*\\n    Calculates GCD of two numbers using Euclidean Recursive Algorithm\\n    :param first: First number\\n    :param second: Second number\\n    :return: GCD of the numbers\\n    */\\n  if (second === 0) {\\n    return first\\n  } else {\\n    return euclideanGCDRecursive(second, (first % second))\\n  }\\n}\\n\\nfunction euclideanGCDIterative (first, second) {\\n  /*\\n    Calculates GCD of two numbers using Euclidean Iterative Algorithm\\n    :param first: First number\\n    :param second: Second number\\n    :return: GCD of the numbers\\n    */\\n  while (second !== 0) {\\n    const temp = second\\n    second = first % second\\n    first = temp\\n  }\\n  return first\\n}\\n\\nexport { euclideanGCDIterative, euclideanGCDRecursive }\\n\"",
    "fibonacci number recursive": "\"\\n/**\\n * @function Fibonacci\\n * @description Function to return the N-th Fibonacci number.\\n * @param {Integer} n - The input integer\\n * @return {Integer} - Return the N-th Fibonacci number\\n * @see [Fibonacci](https://en.wikipedia.org/wiki/Fibonacci_number)\\n */\\n\\nconst fibonacci = (n) => {\\n  if (n < 2) {\\n    return n\\n  }\\n  return fibonacci(n - 2) + fibonacci(n - 1)\\n}\\n\\nexport { fibonacci }\\n\"",
    "flood fill": "\"/**\\r\\n * Flood fill.\\r\\n *\\r\\n * Flood fill, also called seed fill, is an algorithm that determines and alters the area connected to a given node in a\\r\\n * multi-dimensional array with some matching attribute. It is used in the \\\"bucket\\\" fill tool of paint programs to fill\\r\\n * connected, similarly-colored areas with a different color.\\r\\n *\\r\\n * (description adapted from https://en.wikipedia.org/wiki/Flood_fill)\\r\\n * @see https://www.techiedelight.com/flood-fill-algorithm/\\r\\n */\\r\\n\\r\\nconst neighbors = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\\r\\n\\r\\n/**\\r\\n * Implements the flood fill algorithm through a breadth-first approach using a queue.\\r\\n *\\r\\n * @param rgbData The image to which the algorithm is applied.\\r\\n * @param location The start location on the image.\\r\\n * @param targetColor The old color to be replaced.\\r\\n * @param replacementColor The new color to replace the old one.\\r\\n */\\r\\nexport function breadthFirstSearch (rgbData, location, targetColor, replacementColor) {\\r\\n  if (location[0] < 0 ||\\r\\n    location[0] >= rgbData.length ||\\r\\n    location[1] < 0 ||\\r\\n    location[1] >= rgbData[0].length) {\\r\\n    throw new Error('location should point to a pixel within the rgbData')\\r\\n  }\\r\\n\\r\\n  const queue = []\\r\\n  queue.push(location)\\r\\n\\r\\n  while (queue.length > 0) {\\r\\n    breadthFirstFill(rgbData, location, targetColor, replacementColor, queue)\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Implements the flood fill algorithm through a depth-first approach using recursion.\\r\\n *\\r\\n * @param rgbData The image to which the algorithm is applied.\\r\\n * @param location The start location on the image.\\r\\n * @param targetColor The old color to be replaced.\\r\\n * @param replacementColor The new color to replace the old one.\\r\\n */\\r\\nexport function depthFirstSearch (rgbData, location, targetColor, replacementColor) {\\r\\n  if (location[0] < 0 ||\\r\\n    location[0] >= rgbData.length ||\\r\\n    location[1] < 0 ||\\r\\n    location[1] >= rgbData[0].length) {\\r\\n    throw new Error('location should point to a pixel within the rgbData')\\r\\n  }\\r\\n\\r\\n  depthFirstFill(rgbData, location, targetColor, replacementColor)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Utility-function to implement the breadth-first loop.\\r\\n *\\r\\n * @param rgbData The image to which the algorithm is applied.\\r\\n * @param location The start location on the image.\\r\\n * @param targetColor The old color to be replaced.\\r\\n * @param replacementColor The new color to replace the old one.\\r\\n * @param queue The locations that still need to be visited.\\r\\n */\\r\\nfunction breadthFirstFill (rgbData, location, targetColor, replacementColor, queue) {\\r\\n  const currentLocation = queue[0]\\r\\n  queue.shift()\\r\\n\\r\\n  if (rgbData[currentLocation[0]][currentLocation[1]] === targetColor) {\\r\\n    rgbData[currentLocation[0]][currentLocation[1]] = replacementColor\\r\\n\\r\\n    for (let i = 0; i < neighbors.length; i++) {\\r\\n      const x = currentLocation[0] + neighbors[i][0]\\r\\n      const y = currentLocation[1] + neighbors[i][1]\\r\\n      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {\\r\\n        queue.push([x, y])\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Utility-function to implement the depth-first loop.\\r\\n *\\r\\n * @param rgbData The image to which the algorithm is applied.\\r\\n * @param location The start location on the image.\\r\\n * @param targetColor The old color to be replaced.\\r\\n * @param replacementColor The new color to replace the old one.\\r\\n */\\r\\nfunction depthFirstFill (rgbData, location, targetColor, replacementColor) {\\r\\n  if (rgbData[location[0]][location[1]] === targetColor) {\\r\\n    rgbData[location[0]][location[1]] = replacementColor\\r\\n\\r\\n    for (let i = 0; i < neighbors.length; i++) {\\r\\n      const x = location[0] + neighbors[i][0]\\r\\n      const y = location[1] + neighbors[i][1]\\r\\n      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {\\r\\n        depthFirstFill(rgbData, [x, y], targetColor, replacementColor)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"",
    "koch snowflake": "\"/**\\n * The Koch snowflake is a fractal curve and one of the earliest fractals to have been described.\\n *\\n * The Koch snowflake can be built up iteratively, in a sequence of stages. The first stage is an equilateral triangle,\\n * and each successive stage is formed by adding outward bends to each side of the previous stage, making smaller\\n * equilateral triangles. This can be achieved through the following steps for each line:\\n * 1. divide the line segment into three segments of equal length.\\n * 2. draw an equilateral triangle that has the middle segment from step 1 as its base and points outward.\\n * 3. remove the line segment that is the base of the triangle from step 2.\\n *\\n * (description adapted from https://en.wikipedia.org/wiki/Koch_snowflake)\\n * (for a more detailed explanation and an implementation in the Processing language, see\\n * https://natureofcode.com/book/chapter-8-fractals/ #84-the-koch-curve-and-the-arraylist-technique).\\n */\\n\\n/** Class to handle the vector calculations. */\\nexport class Vector2 {\\n  constructor (x, y) {\\n    this.x = x\\n    this.y = y\\n  }\\n\\n  /**\\n   * Vector addition\\n   *\\n   * @param vector The vector to be added.\\n   * @returns The sum-vector.\\n   */\\n  add (vector) {\\n    const x = this.x + vector.x\\n    const y = this.y + vector.y\\n    return new Vector2(x, y)\\n  }\\n\\n  /**\\n   * Vector subtraction\\n   *\\n   * @param vector The vector to be subtracted.\\n   * @returns The difference-vector.\\n   */\\n  subtract (vector) {\\n    const x = this.x - vector.x\\n    const y = this.y - vector.y\\n    return new Vector2(x, y)\\n  }\\n\\n  /**\\n   * Vector scalar multiplication\\n   *\\n   * @param scalar The factor by which to multiply the vector.\\n   * @returns The scaled vector.\\n   */\\n  multiply (scalar) {\\n    const x = this.x * scalar\\n    const y = this.y * scalar\\n    return new Vector2(x, y)\\n  }\\n\\n  /**\\n   * Vector rotation (see https://en.wikipedia.org/wiki/Rotation_matrix)\\n   *\\n   * @param angleInDegrees The angle by which to rotate the vector.\\n   * @returns The rotated vector.\\n   */\\n  rotate (angleInDegrees) {\\n    const radians = angleInDegrees * Math.PI / 180\\n    const ca = Math.cos(radians)\\n    const sa = Math.sin(radians)\\n    const x = ca * this.x - sa * this.y\\n    const y = sa * this.x + ca * this.y\\n    return new Vector2(x, y)\\n  }\\n}\\n\\n/**\\n * Go through the number of iterations determined by the argument \\\"steps\\\".\\n *\\n * Be careful with high values (above 5) since the time to calculate increases exponentially.\\n *\\n * @param initialVectors The vectors composing the shape to which the algorithm is applied.\\n * @param steps The number of iterations.\\n * @returns The transformed vectors after the iteration-steps.\\n */\\nexport function iterate (initialVectors, steps) {\\n  let vectors = initialVectors\\n  for (let i = 0; i < steps; i++) {\\n    vectors = iterationStep(vectors)\\n  }\\n\\n  return vectors\\n}\\n\\n/**\\n * Loops through each pair of adjacent vectors.\\n *\\n * Each line between two adjacent vectors is divided into 4 segments by adding 3 additional vectors in-between the\\n * original two vectors. The vector in the middle is constructed through a 60 degree rotation so it is bent outwards.\\n *\\n * @param vectors The vectors composing the shape to which the algorithm is applied.\\n * @returns The transformed vectors after the iteration-step.\\n */\\nfunction iterationStep (vectors) {\\n  const newVectors = []\\n  for (let i = 0; i < vectors.length - 1; i++) {\\n    const startVector = vectors[i]\\n    const endVector = vectors[i + 1]\\n    newVectors.push(startVector)\\n    const differenceVector = endVector.subtract(startVector).multiply(1 / 3)\\n    newVectors.push(startVector.add(differenceVector))\\n    newVectors.push(startVector.add(differenceVector).add(differenceVector.rotate(60)))\\n    newVectors.push(startVector.add(differenceVector.multiply(2)))\\n  }\\n\\n  newVectors.push(vectors[vectors.length - 1])\\n  return newVectors\\n}\\n\"",
    "koch snowflake.manual-test": "\"import { Vector2, iterate } from './KochSnowflake'\\n\\n/**\\n * Method to render the Koch snowflake to a canvas.\\n *\\n * @param canvasWidth The width of the canvas.\\n * @param steps The number of iterations.\\n * @returns The canvas of the rendered Koch snowflake.\\n */\\nfunction getKochSnowflake (canvasWidth = 600, steps = 5) {\\n  if (canvasWidth <= 0) {\\n    throw new Error('canvasWidth should be greater than zero')\\n  }\\n\\n  const offsetX = canvasWidth / 10.0\\n  const offsetY = canvasWidth / 3.7\\n  const vector1 = new Vector2(offsetX, offsetY)\\n  const vector2 = new Vector2(canvasWidth / 2, Math.sin(Math.PI / 3) * canvasWidth * 0.8 + offsetY)\\n  const vector3 = new Vector2(canvasWidth - offsetX, offsetY)\\n  const initialVectors = []\\n  initialVectors.push(vector1)\\n  initialVectors.push(vector2)\\n  initialVectors.push(vector3)\\n  initialVectors.push(vector1)\\n  const vectors = iterate(initialVectors, steps)\\n  return drawToCanvas(vectors, canvasWidth, canvasWidth)\\n}\\n\\n/**\\n * Utility-method to render the Koch snowflake to a canvas.\\n *\\n * @param vectors The vectors defining the edges to be rendered.\\n * @param canvasWidth The width of the canvas.\\n * @param canvasHeight The height of the canvas.\\n * @returns The canvas of the rendered edges.\\n */\\nfunction drawToCanvas (vectors, canvasWidth, canvasHeight) {\\n  const canvas = document.createElement('canvas')\\n  canvas.width = canvasWidth\\n  canvas.height = canvasHeight\\n\\n  // Draw the edges\\n  const ctx = canvas.getContext('2d')\\n  ctx.beginPath()\\n  ctx.moveTo(vectors[0].x, vectors[0].y)\\n  for (let i = 1; i < vectors.length; i++) {\\n    ctx.lineTo(vectors[i].x, vectors[i].y)\\n  }\\n  ctx.stroke()\\n\\n  return canvas\\n}\\n\\n// plot the results if the script is executed in a browser with a window-object\\nif (typeof window !== 'undefined') {\\n  const canvas = getKochSnowflake()\\n  document.body.append(canvas)\\n}\\n\"",
    "subsequence recursive": "\"/*\\n * Problem Statement: Find all distinct, non-empty subsequence of given string in lexicographical order using recursive approach.\\n *\\n * What is subsequence?\\n * A Subsequence is sequence obtained by deleting some or no elements without changing the order of elements\\n * Example: Given a string = \\\"abcd\\\"\\n * 1. \\\"abc\\\" is a subsequence\\n * 2. \\\"abd\\\" is a subsequence\\n * 3. But \\\"ba\\\" is not a subsequence (because order is changed)\\n *\\n * What is lexicographical order?\\n * In simple terms, lexicographical order is dictionary order.\\n * Example: Given a string = \\\"abcd\\\"\\n * 1. \\\"abc\\\" will come before \\\"abcd\\\".\\n * 2. \\\"abd\\\" will come before \\\"ac\\\".\\n *\\n * References for meaning of subsequence & lexicographical:\\n * https://en.wikipedia.org/wiki/Subsequence\\n * https://en.wikipedia.org/wiki/Lexicographic_order\\n */\\n\\nexport const subsequence = (str, seq, low, output = []) => {\\n  if (low <= str.length && str.length !== 0) {\\n    output.push(seq)\\n  }\\n  for (let i = low; i < str.length; i++) {\\n    subsequence(str, seq + str[i], i + 1, output)\\n  }\\n  return output\\n}\\n\"",
    "tower of hanoi": "\"// wiki - https://en.wikipedia.org/wiki/Tower_of_Hanoi\\n// Recursive Javascript function to solve tower of hanoi\\n\\nexport function TowerOfHanoi (n, from, to, aux, output = []) {\\n  if (n === 1) {\\n    output.push(`Move disk 1 from rod ${from} to rod ${to}`)\\n    return output\\n  }\\n  TowerOfHanoi(n - 1, from, aux, to, output)\\n  output.push(`Move disk ${n} from rod ${from} to rod ${to}`)\\n  TowerOfHanoi(n - 1, aux, to, from, output)\\n  return output\\n}\\n\\n// Driver code (A, C, B are the name of rods)\\n\\n// const n = 4\\n// TowerOfHanoi(n, 'A', 'C', 'B')\\n\"",
    "exponential search": "\"/**\\n * Exponential Search\\n *\\n * The algorithm consists of two stages. The first stage determines a\\n * range in which the search key would reside if it were in the list.\\n * In the second stage, a binary search is performed on this range.\\n *\\n *\\n *\\n */\\n\\nfunction binarySearch (arr, value, floor, ceiling) {\\n  // Middle index\\n  const mid = Math.floor((floor + ceiling) / 2)\\n\\n  // If value is at the mid position return this position\\n  if (arr[mid] === value) {\\n    return mid\\n  }\\n\\n  if (floor > ceiling) return -1\\n\\n  // If the middle element is great than the value\\n  // search the left part of the array\\n  if (arr[mid] > value) {\\n    return binarySearch(arr, value, floor, mid - 1)\\n    // If the middle element is lower than the value\\n    // search the right part of the array\\n  } else {\\n    return binarySearch(arr, value, mid + 1, ceiling)\\n  }\\n}\\n\\nfunction exponentialSearch (arr, length, value) {\\n  // If value is the first element of the array return this position\\n  if (arr[0] === value) {\\n    return 0\\n  }\\n\\n  // Find range for binary search\\n  let i = 1\\n  while (i < length && arr[i] <= value) {\\n    i = i * 2\\n  }\\n\\n  // Call binary search for the range found above\\n  return binarySearch(arr, value, i / 2, Math.min(i, length))\\n}\\n\\nexport { binarySearch, exponentialSearch }\\n\\n// const arr = [2, 3, 4, 10, 40, 65, 78, 100]\\n// const value = 78\\n// const result = exponentialSearch(arr, arr.length, value)\\n\"",
    "fibonacci search": "\"/****************************************************************************\\n * Fibonacci Search JavaScript Implementation\\n * Author   Alhassan Atama Isiaka\\n * Version v1.0.0\\n * Copyright 2020\\n * https://github.com/komputarist\\n *\\n * This implementation is based on Generalizing the Fibonacci search we\\n * define the Fibonacci search of degree K. Like the Fibonacci search,\\n * which it reduces to for K = 2, the Fibonacci search of degree K\\n * involves only addition and subtraction.\\n *  Capocelli R.M. (1991) A Generalization of the Fibonacci Search. In:\\n * Bergum G.E., Philippou A.N., Horadam A.F. (eds) Applications of Fibonacci\\n * Numbers. Springer, Dordrecht. https://doi.org/10.1007/978-94-011-3586-3_9\\n *\\n * This snippet is free. Feel free to improve on it\\n *\\n * We define a function fibonacciSearch() that takes an array of numbers,\\n * the item (number) to be searched for and the length of the items in the array\\n ****************************************************************************/\\n\\nexport const fibonacciSearch = (arr, x, n) => {\\n  let fib2 = 0 // (K-2)'th Fibonacci Number\\n  let fib1 = 1 // (K-1)'th Fibonacci Number.\\n  let fibK = fib2 + fib1 // Kth Fibonacci\\n\\n  /* We want to store the smallest fibonacci number smaller such that\\n    number is greater than or equal to n, we use fibK for this */\\n  while (fibK < n) {\\n    fib2 = fib1\\n    fib1 = fibK\\n    fibK = fib2 + fib1\\n  }\\n  //  This marks the eliminated range from front\\n  let offset = -1\\n\\n  /* while there are elements to be checked. We compare arr[fib2] with x.\\n    When fibM becomes 1, fib2 becomes 0 */\\n\\n  while (fibK > 1) {\\n    // Check if fibK is a valid location\\n    const i = Math.min(offset + fib2, n - 1)\\n\\n    /*  If x is greater than the value at\\n      index fib2, Partition the subarray array\\n      from offset to i */\\n    if (arr[i] < x) {\\n      fibK = fib1\\n      fib1 = fib2\\n      fib2 = fibK - fib1\\n      offset = i\\n      /* If x is greater than the value at\\n            index fib2, cut the subarray array\\n            from offset to i */\\n    } else if (arr[i] > x) {\\n      fibK = fib2\\n      fib1 = fib1 - fib2\\n      fib2 = fibK - fib1\\n    } else {\\n    //  return index for found element\\n      return i\\n    }\\n  }\\n\\n  //    comparing the last element with x */\\n  if (fib1 && arr[offset + 1] === x) {\\n    return offset + 1\\n  }\\n  //    element not found. return -1\\n  return -1\\n}\\n\\n// Example\\n// const myArray = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]\\n// const n = myArray.length\\n// const x = 90\\n// const fibFinder = fibonacciSearch(myArray, x, n)\\n\"",
    "interpolation search": "\"/**\\n * Interpolation Search\\n *\\n * Time Complexity:\\n * -Best case: O(1)\\n * -Worst case: O(n)\\n * -O((log(log(n))) If the data are uniformly distributed\\n *\\n *\\n */\\n\\nexport function interpolationSearch (arr, key) {\\n  const length = arr.length - 1\\n  let low = 0\\n  let high = length\\n  let position = -1\\n  let delta = -1\\n\\n  // Because the array is sorted the key must be between low and high\\n  while (low <= high && key >= arr[low] && key <= arr[high]) {\\n    delta = (key - arr[low]) / (arr[high] - arr[low])\\n    position = low + Math.floor((high - low) * delta)\\n\\n    // Target found return its position\\n    if (arr[position] === key) {\\n      return position\\n    }\\n\\n    // If the key is larger then it is in the upper part of the array\\n    if (arr[position] < key) {\\n      low = position + 1\\n      // If the key is smaller then it is in the lower part of the array\\n    } else {\\n      high = position - 1\\n    }\\n  }\\n\\n  return -1\\n}\\n\\n// const arr = [2, 6, 8, 10, 12, 14, 16, 18, 20, 22, 26, 34, 39]\\n\\n// interpolationSearch(arr, 2)\\n// interpolationSearch(arr, 12)\\n// interpolationSearch(arr, 1000)\\n// interpolationSearch(arr, 39)\\n\"",
    "jump search": "\"/* The Jump Search algorithm allows to combine a linear search with a speed optimization.\\n  * This means that instead of going 1 by 1, we will increase the step of √n and increase that\\n  * step of √n which make the step getting bigger and bigger.\\n  * The asymptotic analysis of Jump Search is o(√n). Like the binary search, it needs to be sorted.\\n  * The advantage against binary search is that Jump Search traversed back only once.\\n */\\n\\nconst jumpSearch = (arr, value) => {\\n  const length = arr.length\\n  let step = Math.floor(Math.sqrt(length))\\n  let lowerBound = 0\\n  while (arr[Math.min(step, length) - 1] < value) {\\n    lowerBound = step\\n    step += step\\n    if (lowerBound >= length) {\\n      return -1\\n    }\\n  }\\n\\n  const upperBound = Math.min(step, length)\\n  while (arr[lowerBound] < value) {\\n    lowerBound++\\n    if (lowerBound === upperBound) {\\n      return -1\\n    }\\n  }\\n  if (arr[lowerBound] === value) {\\n    return lowerBound\\n  }\\n  return -1\\n}\\nconst arr = [0, 0, 4, 7, 10, 23, 34, 40, 55, 68, 77, 90]\\njumpSearch(arr, 4)\\njumpSearch(arr, 34)\\njumpSearch(arr, 77)\\n\"",
    "linear search": "\"/*\\n * Linear search or sequential search is a method for finding a target\\n * value within a list. It sequentially checks each element of the list\\n * for the target value until a match is found or until all the elements\\n * have been searched.\\n */\\nfunction SearchArray (searchNum, ar, output = v => console.log(v)) {\\n  const position = Search(ar, searchNum)\\n  if (position !== -1) {\\n    output('The element was found at ' + (position + 1))\\n  } else {\\n    output('The element not found')\\n  }\\n}\\n\\n// Search “theArray” for the specified “key” value\\nfunction Search (theArray, key) {\\n  for (let n = 0; n < theArray.length; n++) {\\n    if (theArray[n] === key) { return n }\\n  }\\n  return -1\\n}\\n\\nexport { SearchArray, Search }\\n\\n// const ar = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n// SearchArray(3, ar)\\n// SearchArray(4, ar)\\n// SearchArray(11, ar)\\n\"",
    "quick select search": "\"/*\\n * Places the `k` smallest elements in `array` in the first `k` indices: `[0..k-1]`\\n * Modifies the passed in array *in place*\\n * Returns a slice of the wanted elements for convenience\\n * Efficient mainly because it never performs a full sort.\\n *\\n * The only guarantees are that:\\n *\\n * - The `k`th element is in its final sort index (if the array were to be sorted)\\n * - All elements before index `k` are smaller than the `k`th element\\n *\\n * [Reference](http://en.wikipedia.org/wiki/Quickselect)\\n */\\nexport function quickSelectSearch (array, k) {\\n  if (!array || array.length <= k) {\\n    throw new Error('Invalid arguments')\\n  }\\n\\n  let from = 0\\n  let to = array.length - 1\\n  while (from < to) {\\n    let left = from\\n    let right = to\\n    const pivot = array[Math.ceil((left + right) * 0.5)]\\n\\n    while (left < right) {\\n      if (array[left] >= pivot) {\\n        const tmp = array[left]\\n        array[left] = array[right]\\n        array[right] = tmp\\n        --right\\n      } else {\\n        ++left\\n      }\\n    }\\n\\n    if (array[left] > pivot) {\\n      --left\\n    }\\n\\n    if (k <= left) {\\n      to = left\\n    } else {\\n      from = left + 1\\n    }\\n  }\\n  return array\\n}\\n\\n/* ---------------------------------- Test ---------------------------------- */\\n\\n// const arr = [1121111, 21, 333, 41, 5, 66, 7777, 28, 19, 11110]\\n// quickSelectSearch(arr, 5) // [ 19, 21, 28, 41, 5, 66, 333, 11110, 1121111, 7777 ]\\n// quickSelectSearch(arr, 2) // [ 19, 5, 21, 41, 28, 333, 11110, 1121111, 7777, 66 ]\\n// quickSelectSearch(arr, 7) // [ 19, 5, 21, 41, 28, 66, 333, 7777, 11110, 1121111 ]\\n\"",
    "sliding window": "\"/**\\n* Sliding Window:\\n* This pattern involve creating a window which can either be\\n* an array or numbers from one position to another.\\n*\\n* Depending on a certain condition, the window either increases\\n* or closes (and a new window is created).\\n*\\n* Very useful for keeping track of a subset of data in an\\n* array/string etc.\\n*\\n* Time Complexity: Best - O(n);\\n*\\n* Examples:\\n* maxSubarraySum([1,2,5,2,8,1,5],2) // returns 10\\n* maxSubarraySum([1,2,5,2,8,1,5],15) // returns null\\n* maxSubarraySum([5,2,6,9],3) // returns 17\\n * @param {[Int]} arr - An array of integers on which we will perform the test.\\n * @param {Int} num - An integer that displays the size of the window you want to check.\\n * @returns {Int / Null} - Returns a total of N consecutive numbers or null\\n */\\n\\nfunction slidingWindow (arr, num) {\\n  // Edge Case:\\n  // If the length of the array shorter than the window size (num) return null.\\n  if (arr.length < num) return null\\n  // The highest amount of consecutive numbers\\n  let maxSum = 0\\n  // Temp amount of consecutive numbers - For comparative purposes\\n  let tempSum = 0\\n  // loop over the array {num} times and save their total amount in {maxSum}\\n  for (let i = 0; i < num; i++) {\\n    maxSum += arr[i]\\n  }\\n  // initialize {tempSum} to {maxSum}.\\n  tempSum = maxSum\\n  // loop over the array n times\\n  for (let i = num; i < arr.length; i++) {\\n    // Add the next num in the array and remove the first one\\n    tempSum = tempSum - arr[i - num] + arr[i]\\n    // save the largest number between {maxNum} and {tempNum} in maxSum.\\n    maxSum = Math.max(maxSum, tempSum)\\n  }\\n  return maxSum\\n}\\n\\nexport { slidingWindow }\\n\"",
    "string search": "\"/*\\n * String Search\\n */\\n\\nfunction makeTable (str) {\\n  // create a table of size equal to the length of `str`\\n  // table[i] will store the prefix of the longest prefix of the substring str[0..i]\\n  const table = new Array(str.length)\\n  let maxPrefix = 0\\n  // the longest prefix of the substring str[0] has length\\n  table[0] = 0\\n\\n  // for the substrings the following substrings, we have two cases\\n  for (let i = 1; i < str.length; i++) {\\n    // case 1. the current character doesn't match the last character of the longest prefix\\n    while (maxPrefix > 0 && str.charAt(i) !== str.charAt(maxPrefix)) {\\n      // if that is the case, we have to backtrack, and try find a character  that will be equal to the current character\\n      // if we reach 0, then we couldn't find a character\\n      maxPrefix = table[maxPrefix - 1]\\n    }\\n    // case 2. The last character of the longest prefix matches the current character in `str`\\n    if (str.charAt(maxPrefix) === str.charAt(i)) {\\n      // if that is the case, we know that the longest prefix at position i has one more character.\\n      // for example consider `.` be any character not contained in the set [a.c]\\n      // str = abc....abc\\n      // consider `i` to be the last character `c` in `str`\\n      // maxPrefix = will be 2 (the first `c` in `str`)\\n      // maxPrefix now will be 3\\n      maxPrefix++\\n      // so the max prefix for table[9] is 3\\n    }\\n    table[i] = maxPrefix\\n  }\\n  return table\\n}\\n\\n// Find all the words that matches in a given string `str`\\nexport function stringSearch (str, word) {\\n  // find the prefix table in O(n)\\n  const prefixes = makeTable(word)\\n  const matches = []\\n\\n  // `j` is the index in `P`\\n  let j = 0\\n  // `i` is the index in `S`\\n  let i = 0\\n  while (i < str.length) {\\n    // Case 1.  S[i] == P[j] so we move to the next index in `S` and `P`\\n    if (str.charAt(i) === word.charAt(j)) {\\n      i++\\n      j++\\n    }\\n    // Case 2.  `j` is equal to the length of `P`\\n    // that means that we reached the end of `P` and thus we found a match\\n    // Next we have to update `j` because we want to save some time\\n    // instead of updating to j = 0 , we can jump to the last character of the longest prefix well known so far.\\n    // j-1 means the last character of `P` because j is actually `P.length`\\n    // e.g.\\n    // S =  a b a b d e\\n    // P = `a b`a b\\n    // we will jump to `a b` and we will compare d and a in the next iteration\\n    // a b a b `d` e\\n    //     a b `a` b\\n    if (j === word.length) {\\n      matches.push(i - j)\\n      j = prefixes[j - 1]\\n      // Case 3.\\n      // S[i] != P[j] There's a mismatch!\\n    } else if (str.charAt(i) !== word.charAt(j)) {\\n      // if we  found at least a character in common, do the same thing as in case 2\\n      if (j !== 0) {\\n        j = prefixes[j - 1]\\n      } else {\\n        // else j = 0, and we can move to the next character S[i+1]\\n        i++\\n      }\\n    }\\n  }\\n\\n  return matches\\n}\\n\\n// stringSearch('Hello search the position of me', 'pos')\\n\"",
    "ternary search": "\"/* Ternary search is similar to binary search but it divide the sorted array\\n * into three parts and determine which part the key lies in. The array will\\n * be divided into three intervals by using two middle points, mid1 and mid2.\\n * The value of the key will first compared with the two mid points, the value\\n * will be returned if there is a match. Then, if the value of the key is less\\n * than mid1, narrow the interval to the first part. Else, if the value of the\\n * key is greater than mid2, narrow the interval to the third part. Otherwise,\\n * narrow the interval to the middle part. Repeat the steps until the value is\\n * found or the interval is empty(value not found after checking all elements).\\n *\\n * Reference: https://www.geeksforgeeks.org/ternary-search/\\n */\\n\\nfunction ternarySearchRecursive (arr, key, low = 0, high = arr.length - 1) {\\n  if (high >= low) {\\n    // find the mid1 and mid2\\n    const mid1 = Math.floor(low + (high - low) / 3)\\n    const mid2 = Math.floor(high - (high - low) / 3)\\n\\n    // check if key is found at any mid\\n    if (arr[mid1] === key) {\\n      // return index of key if found\\n      return mid1\\n    }\\n    if (arr[mid2] === key) {\\n      // return index of key if found\\n      return mid2\\n    }\\n\\n    // since the key is not found at mid,\\n    // check in which region it is present\\n    // and repeat the Search operation\\n    // in that region\\n    if (key < arr[mid1]) {\\n      // the key lies in between low and mid1\\n      return ternarySearchRecursive(arr, key, low, mid1 - 1)\\n    } else if (key > arr[mid2]) {\\n      // the key lies in between mid2 and high\\n      return ternarySearchRecursive(arr, key, mid2 + 1, high)\\n    } else {\\n      // the key lies in between mid1 and mid2\\n      return ternarySearchRecursive(arr, key, mid1 + 1, mid2 - 1)\\n    }\\n  } else {\\n    // if low > high => we have searched the whole array without finding the item\\n    return -1\\n  }\\n}\\n\\nfunction ternarySearchIterative (arr, key, low = 0, high = arr.length - 1) {\\n  while (high >= low) {\\n    // find the mid1 and mid2\\n    const mid1 = Math.floor(low + (high - low) / 3)\\n    const mid2 = Math.floor(high - (high - low) / 3)\\n\\n    // check if key is found at any mid\\n    if (arr[mid1] === key) {\\n      // return index of key if found\\n      return mid1\\n    }\\n    if (arr[mid2] === key) {\\n      // return index of key if found\\n      return mid2\\n    }\\n\\n    // since the key is not found at mid,\\n    // check in which region it is present\\n    // and repeat the Search operation\\n    // in that region\\n    if (key < arr[mid1]) {\\n      // the key lies in between low and mid1\\n      high = mid1 - 1\\n    } else if (key > arr[mid2]) {\\n      // the key lies in between mid2 and high\\n      low = mid2 + 1\\n    } else {\\n      // the key lies in between mid1 and mid2\\n      low = mid1 + 1\\n      high = mid2 - 1\\n    }\\n  }\\n  // the key was not found\\n  return -1\\n}\\n\\nexport { ternarySearchRecursive, ternarySearchIterative }\\n\"",
    "union find": "\"/**\\n * union find data structure for javascript\\n *\\n * In computer science, a disjoint-set data structure, also called a union–find data structure or merge–find set,\\n * is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition\\n * of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union),\\n * and finding a representative member of a set.\\n * The last operation allows to find out efficiently if any two elements are in the same or different sets.\\n *\\n * Disjoint-set data structures play a key role in Kruskal's algorithm for finding the minimum spanning tree of a graph.\\n * The importance of minimum spanning trees means that disjoint-set data structures underlie a wide variety of algorithms.\\n * In addition, disjoint-set data structures also have applications to symbolic computation, as well in compilers,\\n * especially for register allocation problems.\\n *\\n * you can learn more on disjoint-set / union–find data structure at https://en.wikipedia.org/wiki/Disjoint-set_data_structure\\n */\\nfunction UnionFind (n, key) {\\n  if (!(this instanceof UnionFind)) return new UnionFind(n)\\n  if (key && typeof key !== 'function') {\\n    throw new Error('key has to be a function or else left undefined')\\n  }\\n  let cnt, length\\n  // init Union Find with number of distinct groups. Each group will be referred to as index of the array of size 'size' starting at 0.\\n  // Provide an optional key function that maps these indices. I.e. for the groups starting with 1 provide function(a){return a-1;}. The default value is function(a){return a;}.\\n  key = key || function (a) { return a }\\n  cnt = length = n\\n  const id = new Array(n)\\n  const sz = new Array(n)\\n  for (let i = 0; i < n; i++) {\\n    id[i] = i\\n    sz[i] = 1\\n  }\\n  // Returns the number of elements of uf object.\\n  this.size = function () {\\n    return length\\n  }\\n  // Returns the number of distinct groups left inside the object.\\n  this.count = function () {\\n    return cnt\\n  }\\n  // Return the root (value) of the group in which p is.\\n  this.find = function (p) {\\n    p = key(p)\\n    while (p !== id[p]) {\\n      id[p] = id[id[p]]\\n      p = id[p]\\n    }\\n    return p\\n  }\\n  // Returns true if p and p are both in same group, false otherwise.\\n  this.connected = function (p, q) {\\n    p = key(p)\\n    q = key(q)\\n    ensureIndexWithinBounds(p, q)\\n    return this.find(p) === this.find(q)\\n  }\\n  // Combine elements in groups p and q into a single group. In other words connect the two groups.\\n  this.union = function (p, q) {\\n    p = key(p)\\n    q = key(q)\\n    ensureIndexWithinBounds(p, q)\\n    const i = this.find(p)\\n    const j = this.find(q)\\n    if (i === j) return\\n    if (sz[i] < sz[j]) {\\n      id[i] = j; sz[j] += sz[i]\\n    } else {\\n      id[j] = i; sz[i] += sz[j]\\n    }\\n    cnt--\\n  }\\n  function ensureIndexWithinBounds (args) {\\n    for (let i = arguments.length - 1; i >= 0; i--) {\\n      const p = arguments[i]\\n      if (p >= length) throw new Error('Index out of bounds. The maximum index can be length-1')\\n    }\\n  }\\n}\\n\\nexport { UnionFind }\\n\"",
    "bead sort": "\"/**\\n * Bead Sort, also known as Gravity sort.\\n *\\n * This algorithm was inspired from natural phenomena and was designed keeping in mind objects (or beads) falling under\\n * the influence of gravity.\\n *\\n * NOTE: It only works for arrays of positive integers.\\n *\\n * Wikipedia: https://en.wikipedia.org/wiki/Bead_sort\\n */\\nexport function beadSort (sequence) {\\n  /* Let's ensure our sequence has only Positive Integers */\\n  if (sequence.some((integer) => integer < 0)) {\\n    throw RangeError('Sequence must be a list of Positive integers Only!')\\n  }\\n\\n  const sequenceLength = sequence.length\\n  const max = Math.max(...sequence)\\n\\n  // Set initial Grid\\n  const grid = sequence.map(number => {\\n    const maxArr = new Array(max)\\n\\n    for (let i = 0; i < number; i++) {\\n      maxArr[i] = '*'\\n    }\\n\\n    return maxArr\\n  })\\n\\n  // Drop the Beads!\\n  for (let col = 0; col < max; col++) {\\n    let beadsCount = 0\\n\\n    for (let row = 0; row < sequenceLength; row++) {\\n      if (grid[row][col] === '*') {\\n        beadsCount++\\n      }\\n    }\\n\\n    for (let row = sequenceLength - 1; row > -1; row--) {\\n      if (beadsCount) {\\n        grid[row][col] = '*'\\n        beadsCount--\\n      } else {\\n        grid[row][col] = undefined\\n      }\\n    }\\n  }\\n\\n  /* Finally, let's turn our Bead rows into their Respective Numbers */\\n  return grid.map((beadArray) => {\\n    const beadsArray = beadArray.filter(bead => bead === '*')\\n    return beadsArray.length\\n  })\\n}\\n\"",
    "bogo sort": "\"/**\\n * Checks whether the given array is sorted in ascending order.\\n */\\nexport function isSorted (array) {\\n  const length = array.length\\n  for (let i = 0; i < length - 1; i++) {\\n    if (array[i] > array[i + 1]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\\n\\n/**\\n * Shuffles the given array randomly in place.\\n */\\nfunction shuffle (array) {\\n  for (let i = array.length - 1; i; i--) {\\n    const m = Math.floor(Math.random() * i)\\n    const n = array[i - 1]\\n    array[i - 1] = array[m]\\n    array[m] = n\\n  }\\n}\\n\\n/**\\n * Implementation of the bogosort algorithm.\\n *\\n * This sorting algorithm randomly rearranges the array until it is sorted.\\n *\\n * For more information see: https://en.wikipedia.org/wiki/Bogosort\\n */\\nexport function bogoSort (items) {\\n  while (!isSorted(items)) {\\n    shuffle(items)\\n  }\\n  return items\\n}\\n\"",
    "bubble sort": "\"/* Bubble Sort is an algorithm to sort an array. It\\n*  compares adjacent element and swaps their position\\n*  The big O on bubble sort in worst and best case is O(N^2).\\n*  Not efficient.\\n*\\n*  In bubble sort, we keep iterating while something was swapped in\\n*  the previous inner-loop iteration. By swapped I mean, in the\\n*  inner loop iteration, we check each number if the number proceeding\\n*  it is greater than itself, if so we swap them.\\n*\\n*  Wikipedia: https://en.wikipedia.org/wiki/Bubble_sort\\n*  Animated Visual: https://www.toptal.com/developers/sorting-algorithms/bubble-sort\\n*/\\n\\n/**\\n * Using 2 for loops.\\n */\\nexport function bubbleSort (items) {\\n  const length = items.length\\n\\n  for (let i = (length - 1); i > 0; i--) {\\n    // Number of passes\\n    for (let j = (length - i); j > 0; j--) {\\n      // Compare the adjacent positions\\n      if (items[j] < items[j - 1]) {\\n        // Swap the numbers\\n        [items[j], items[j - 1]] = [items[j - 1], items[j]]\\n      }\\n    }\\n  }\\n\\n  return items\\n}\\n\\n/**\\n * Using a while loop and a for loop.\\n */\\nexport function alternativeBubbleSort (arr) {\\n  let swapped = true\\n\\n  while (swapped) {\\n    swapped = false\\n    for (let i = 0; i < arr.length - 1; i++) {\\n      if (arr[i] > arr[i + 1]) {\\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]\\n        swapped = true\\n      }\\n    }\\n  }\\n\\n  return arr\\n}\\n\"",
    "bucket sort": "\"/**\\n * BucketSort implementation.\\n *\\n * Wikipedia says: Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array\\n * into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by\\n * recursively applying the bucket sorting algorithm. It is a distribution sort, and is a cousin of radix sort in the\\n * most to least significant digit flavour. Bucket sort is a generalization of pigeonhole sort. Bucket sort can be\\n * implemented with comparisons and therefore can also be considered a comparison sort algorithm. The computational\\n * complexity estimates involve the number of buckets.\\n *\\n * @see https://en.wikipedia.org/wiki/Bucket_sort#:~:text=Bucket%20sort%2C%20or%20bin%20sort,applying%20the%20bucket%20sorting%20algorithm.&text=Sort%20each%20non%2Dempty%20bucket.\\n *\\n * Time Complexity of Solution:\\n * Best Case O(n); Average Case O(n); Worst Case O(n)\\n *\\n * @param {number[]} list The array of numbers to be sorted.\\n * @param {number} size The size of the buckets used. If not provided, size will be 5.\\n * @return {number[]} An array of numbers sorted in increasing order.\\n */\\nexport function bucketSort (list, size) {\\n  if (undefined === size) {\\n    size = 5\\n  }\\n  if (list.length === 0) {\\n    return list\\n  }\\n  let min = list[0]\\n  let max = list[0]\\n  // find min and max\\n  for (let iList = 0; iList < list.length; iList++) {\\n    if (list[iList] < min) {\\n      min = list[iList]\\n    } else if (list[iList] > max) {\\n      max = list[iList]\\n    }\\n  }\\n  // how many buckets we need\\n  const count = Math.floor((max - min) / size) + 1\\n\\n  // create buckets\\n  const buckets = []\\n  for (let iCount = 0; iCount < count; iCount++) {\\n    buckets.push([])\\n  }\\n\\n  // bucket fill\\n  for (let iBucket = 0; iBucket < list.length; iBucket++) {\\n    const key = Math.floor((list[iBucket] - min) / size)\\n    buckets[key].push(list[iBucket])\\n  }\\n  const sorted = []\\n  // now sort every bucket and merge it to the sorted list\\n  for (let iBucket = 0; iBucket < buckets.length; iBucket++) {\\n    const arr = buckets[iBucket].sort((a, b) => a - b)\\n    for (let iSorted = 0; iSorted < arr.length; iSorted++) {\\n      sorted.push(arr[iSorted])\\n    }\\n  }\\n  return sorted\\n}\\n\"",
    "cocktail shaker sort": "\"/**\\n * Cocktail Shaker Sort is an algorithm that is a Bidirectional Bubble Sort.\\n *\\n * The algorithm extends bubble sort by operating in two directions.\\n * While it improves on bubble sort by more quickly moving items to the beginning of the list, it provides only marginal\\n * performance improvements.\\n *\\n * Wikipedia (Cocktail Shaker Sort): https://en.wikipedia.org/wiki/Cocktail_shaker_sort\\n * Wikipedia (Bubble Sort): https://en.wikipedia.org/wiki/Bubble_sort\\n */\\nexport function cocktailShakerSort (items) {\\n  for (let i = items.length - 1; i > 0; i--) {\\n    let j\\n\\n    // Backwards\\n    for (j = items.length - 1; j > i; j--) {\\n      if (items[j] < items[j - 1]) {\\n        [items[j], items[j - 1]] = [items[j - 1], items[j]]\\n      }\\n    }\\n\\n    // Forwards\\n    for (j = 0; j < i; j++) {\\n      if (items[j] > items[j + 1]) {\\n        [items[j], items[j + 1]] = [items[j + 1], items[j]]\\n      }\\n    }\\n  }\\n\\n  return items\\n}\\n\"",
    "comb sort": "\"/**\\n * Comb sort improves on bubble sort.\\n *\\n * The basic idea is to eliminate turtles, or small values\\n * near the end of the list, since in a bubble sort these slow the sorting\\n * down tremendously. Rabbits, large values around the beginning of the list,\\n * do not pose a problem in bubble sort.\\n *\\n * In bubble sort, when any two elements are compared, they always have a\\n * gap (distance from each other) of 1. The basic idea of comb sort is\\n * that the gap can be much more than 1. The inner loop of bubble sort,\\n * which does the actual swap, is modified such that gap between swapped\\n * elements goes down (for each iteration of outer loop) in steps of\\n * a \\\"shrink factor\\\" k: [ n/k, n/k2, n/k3, ..., 1 ].\\n *\\n * Wikipedia: https://en.wikipedia.org/wiki/Comb_sort\\n */\\n\\n/**\\n * combSort returns an array of numbers sorted in increasing order.\\n *\\n * @param {number[]} list The array of numbers to sort.\\n * @return {number[]} The array of numbers sorted in increasing order.\\n */\\nfunction combSort (list) {\\n  if (list.length === 0) {\\n    return list\\n  }\\n  const shrink = 1.3\\n  let gap = list.length\\n  let isSwapped = true\\n  let i = 0\\n\\n  while (gap > 1 || isSwapped) {\\n    // Update the gap value for a next comb\\n    gap = parseInt(parseFloat(gap) / shrink, 10)\\n\\n    isSwapped = false\\n    i = 0\\n\\n    while (gap + i < list.length) {\\n      if (list[i] > list[i + gap]) {\\n        [list[i], list[i + gap]] = [list[i + gap], list[i]]\\n        isSwapped = true\\n      }\\n      i += 1\\n    }\\n  }\\n  return list\\n}\\n\\nexport { combSort }\\n\"",
    "counting sort": "\"/**\\n * Counting sort is an algorithm for sorting a collection\\n * of objects according to keys that are small integers.\\n *\\n * It is an integer sorting algorithm.\\n *\\n * Wikipedia: https://en.wikipedia.org/wiki/Counting_sort\\n * Animated Visual: https://www.cs.usfca.edu/~galles/visualization/CountingSort.html\\n */\\n\\nexport const countingSort = (arr, min, max) => {\\n  // Create an auxiliary resultant array\\n  const res = []\\n  // Create and initialize the frequency[count] array\\n  const count = new Array(max - min + 1).fill(0)\\n  // Populate the freq array\\n  for (let i = 0; i < arr.length; i++) {\\n    count[arr[i] - min]++\\n  }\\n  // Create a prefix sum array out of the frequency[count] array\\n  count[0] -= 1\\n  for (let i = 1; i < count.length; i++) {\\n    count[i] += count[i - 1]\\n  }\\n  // Populate the result array using the prefix sum array\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    res[count[arr[i] - min]] = arr[i]\\n    count[arr[i] - min]--\\n  }\\n  return res\\n}\\n\\n/**\\n * Implementation of Counting Sort\\n */\\n// const array = [3, 0, 2, 5, 4, 1]\\n// countingSort(array, 0, 5)\\n\"",
    "cycle sort": "\"/**\\n * Cycle sort is an in-place, unstable sorting algorithm,\\n * a comparison sort that is theoretically optimal in terms of the total\\n * number of writes to the original array, unlike any other in-place sorting\\n * algorithm. It is based on the idea that the permutation to be sorted can\\n * be factored into cycles, which can individually be rotated to give a sorted result.\\n *\\n * Wikipedia: https://en.wikipedia.org/wiki/Cycle_sort\\n */\\n\\n/**\\n * cycleSort takes an input array of numbers and returns the array sorted in increasing order.\\n *\\n * @param {number[]} list An array of numbers to be sorted.\\n * @return {number[]} An array of numbers sorted in increasing order.\\n */\\nfunction cycleSort (list) {\\n  for (let cycleStart = 0; cycleStart < list.length; cycleStart++) {\\n    let value = list[cycleStart]\\n    let position = cycleStart\\n\\n    // search position\\n    for (let i = cycleStart + 1; i < list.length; i++) {\\n      if (list[i] < value) {\\n        position++\\n      }\\n    }\\n    // if it is the same, continue\\n    if (position === cycleStart) {\\n      continue\\n    }\\n    while (value === list[position]) {\\n      position++\\n    }\\n\\n    const oldValue = list[position]\\n    list[position] = value\\n    value = oldValue\\n\\n    // rotate the rest\\n    while (position !== cycleStart) {\\n      position = cycleStart\\n      for (let i = cycleStart + 1; i < list.length; i++) {\\n        if (list[i] < value) {\\n          position++\\n        }\\n      }\\n      while (value === list[position]) {\\n        position++\\n      }\\n      const oldValueCycle = list[position]\\n      list[position] = value\\n      value = oldValueCycle\\n    }\\n  }\\n  return list\\n}\\n\\nexport { cycleSort }\\n\"",
    "find second largest element": "\"/*\\n* Find Second Largest is a real technical interview question.\\n* Chances are you will be asked to find the second largest value\\n* inside of an array of numbers. You must also be able to filter\\n* out duplicate values.  It's important to know how to do this with\\n* clean code that is also easy to explain.\\n*\\n* Resources:\\n* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\\n*/\\n\\nconst secondLargestElement = (array) => {\\n  const largestElement = Math.max(...array)\\n  let element = 0\\n\\n  for (let i = 0; i < array.length; i++) {\\n    if (element < array[i] && array[i] !== largestElement) {\\n      element = array[i]\\n    }\\n  }\\n\\n  return element\\n}\\n\\nexport { secondLargestElement }\\n\"",
    "fisher yates shuffle": "\"export const shuffle = (array) => {\\n  let maxLength = array.length\\n  let temp\\n  let idx\\n\\n  // While there remain elements to shuffle...\\n  while (maxLength) {\\n    // Pick a remaining element...\\n    idx = Math.floor(Math.random() * maxLength--)\\n\\n    // And swap it with the current element\\n    temp = array[maxLength]\\n    array[maxLength] = array[idx]\\n    array[idx] = temp\\n  }\\n\\n  return array\\n}\\n\"",
    "flash sort": "\"/**\\n * Flashsort is a distribution sorting algorithm showing linear\\n * computational complexity O(n) for uniformly distributed\\n * data sets and relatively little additional memory requirement.\\n *\\n * Wikipedia: https://en.wikipedia.org/wiki/Flashsort\\n */\\n\\nexport function flashSort (arr) {\\n  let max = 0; let min = arr[0]\\n  const n = arr.length\\n  const m = ~~(0.45 * n)\\n  const l = new Array(m)\\n\\n  for (let i = 1; i < n; ++i) {\\n    if (arr[i] < min) {\\n      min = arr[i]\\n    }\\n    if (arr[i] > arr[max]) {\\n      max = i\\n    }\\n  }\\n\\n  if (min === arr[max]) {\\n    return arr\\n  }\\n\\n  const c1 = (m - 1) / (arr[max] - min)\\n\\n  for (let k = 0; k < m; k++) {\\n    l[k] = 0\\n  }\\n\\n  for (let j = 0; j < n; ++j) {\\n    const k = ~~(c1 * (arr[j] - min))\\n    ++l[k]\\n  }\\n\\n  for (let p = 1; p < m; ++p) {\\n    l[p] = l[p] + l[p - 1]\\n  }\\n\\n  let hold = arr[max]\\n  arr[max] = arr[0]\\n  arr[0] = hold\\n\\n  // permutation\\n  let move = 0; let t; let flash\\n  let j = 0\\n  let k = m - 1\\n\\n  while (move < (n - 1)) {\\n    while (j > (l[k] - 1)) {\\n      ++j\\n      k = ~~(c1 * (arr[j] - min))\\n    }\\n    if (k < 0) break\\n    flash = arr[j]\\n    while (j !== l[k]) {\\n      k = ~~(c1 * (flash - min))\\n      hold = arr[t = --l[k]]\\n      arr[t] = flash\\n      flash = hold\\n      ++move\\n    }\\n  }\\n\\n  // insertion\\n  for (j = 1; j < n; j++) {\\n    hold = arr[j]\\n    let i = j - 1\\n    while (i >= 0 && arr[i] > hold) {\\n      arr[i + 1] = arr[i--]\\n    }\\n    arr[i + 1] = hold\\n  }\\n  return arr\\n}\\n\\n/**\\n* Implementation of Flash Sort\\n*/\\n// const array = [3, 0, 2, 5, -1, 4, 1, -2]\\n// flashSort(array)\\n\"",
    "gnome sort": "\"/*\\n * Gnome sort is a sort algorithm that moving an element to its proper place is accomplished by a series of swap\\n * more information: https://en.wikipedia.org/wiki/Gnome_sort\\n *\\n */\\nexport function gnomeSort (items) {\\n  if (items.length <= 1) {\\n    return\\n  }\\n\\n  let i = 1\\n\\n  while (i < items.length) {\\n    if (items[i - 1] <= items[i]) {\\n      i++\\n    } else {\\n      [items[i], items[i - 1]] = [items[i - 1], items[i]]\\n\\n      i = Math.max(1, i - 1)\\n    }\\n  }\\n}\\n\\n// Implementation of gnomeSort\\n\\n// const ar = [5, 6, 7, 8, 1, 2, 12, 14]\\n// gnomeSort(ar)\\n\"",
    "heap sort": "\"/*\\n * Build a max heap out of the array. A heap is a specialized tree like\\n * data structure that satisfies the heap property. The heap property\\n * for max heap is the following: \\\"if P is a parent node of C, then the\\n * key (the value) of node P is greater than the key of node C\\\"\\n * Source: https://en.wikipedia.org/wiki/Heap_(data_structure)\\n */\\n/* eslint no-extend-native: [\\\"off\\\", { \\\"exceptions\\\": [\\\"Object\\\"] }] */\\nArray.prototype.heapify = function (index, heapSize) {\\n  let largest = index\\n  const leftIndex = 2 * index + 1\\n  const rightIndex = 2 * index + 2\\n\\n  if (leftIndex < heapSize && this[leftIndex] > this[largest]) {\\n    largest = leftIndex\\n  }\\n\\n  if (rightIndex < heapSize && this[rightIndex] > this[largest]) {\\n    largest = rightIndex\\n  }\\n\\n  if (largest !== index) {\\n    const temp = this[largest]\\n    this[largest] = this[index]\\n    this[index] = temp\\n\\n    this.heapify(largest, heapSize)\\n  }\\n}\\n\\n/*\\n * Heap sort sorts an array by building a heap from the array and\\n * utilizing the heap property.\\n * For more information see: https://en.wikipedia.org/wiki/Heapsort\\n */\\nexport function heapSort (items) {\\n  const length = items.length\\n\\n  for (let i = Math.floor(length / 2) - 1; i > -1; i--) {\\n    items.heapify(i, length)\\n  }\\n  for (let j = length - 1; j > 0; j--) {\\n    const tmp = items[0]\\n    items[0] = items[j]\\n    items[j] = tmp\\n    items.heapify(0, j)\\n  }\\n  return items\\n}\\n\\n// Implementation of heapSort\\n\\n// const ar = [5, 6, 7, 8, 1, 2, 12, 14]\\n// heapSort(ar)\\n\"",
    "heap sort v2": "\"let arrayLength = 0\\n\\n/* to create MAX  array */\\n\\nfunction heapRoot (input, i) {\\n  const left = 2 * i + 1\\n  const right = 2 * i + 2\\n  let max = i\\n\\n  if (left < arrayLength && input[left] > input[max]) {\\n    max = left\\n  }\\n\\n  if (right < arrayLength && input[right] > input[max]) {\\n    max = right\\n  }\\n\\n  if (max !== i) {\\n    swap(input, i, max)\\n    heapRoot(input, max)\\n  }\\n}\\n\\nfunction swap (input, indexA, indexB) {\\n  [input[indexA], input[indexB]] = [input[indexB], input[indexA]]\\n}\\n\\nexport function heapSort (input) {\\n  arrayLength = input.length\\n\\n  for (let i = Math.floor(arrayLength / 2); i >= 0; i -= 1) {\\n    heapRoot(input, i)\\n  }\\n\\n  for (let i = input.length - 1; i > 0; i--) {\\n    swap(input, 0, i)\\n    arrayLength--\\n\\n    heapRoot(input, 0)\\n  }\\n}\\n\"",
    "insertion sort": "\"/* In insertion sort, we divide the initial unsorted array into two parts;\\n* sorted part and unsorted part. Initially the sorted part just has one\\n* element (Array of only 1 element is a sorted array). We then pick up\\n* element one by one from unsorted part; insert into the sorted part at\\n* the correct position and expand sorted part one element at a time.\\n*/\\nexport function insertionSort (unsortedList) {\\n  const len = unsortedList.length\\n  for (let i = 1; i < len; i++) {\\n    let j\\n    const tmp = unsortedList[i] // Copy of the current element.\\n    /* Check through the sorted part and compare with the number in tmp. If large, shift the number */\\n    for (j = i - 1; j >= 0 && (unsortedList[j] > tmp); j--) {\\n      // Shift the number\\n      unsortedList[j + 1] = unsortedList[j]\\n    }\\n    // Insert the copied number at the correct position\\n    // in sorted part.\\n    unsortedList[j + 1] = tmp\\n  }\\n}\\n\"",
    "intro sort": "\"/**\\n * @function Intosort (As implemented in STD C++ Lib)\\n * The function performs introsort which is used in\\n * C++ Standard LIbrary, the implementation is inspired from]\\n * library routine itself.\\n * ALGORITHM:\\n * 1) It performs quicksort on array until the recursion depth\\n *    exceeds a pre determined limit.\\n * 2) If the limit is reached it switches to heapsort\\n * 3) For array size less than a threshold(16) directly\\n *    does insertion sort on array\\n * @param {Array} array the array to be sorted\\n * @param {Function} compare the comparison function\\n *\\n * @see [Introsort](https://en.wikipedia.org/wiki/Introsort)\\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\\n */\\nfunction introsort (array, compare) {\\n  /**\\n   * @function Default Comparison Function\\n   * This function is same as implemented by\\n   * Array.sort method\\n   * @see [StackOverflow](https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function)\\n   * @param {*} a variable 1\\n   * @param {*} b variable 2\\n   * @returns {Number}\\n   * -1 if a is less than b\\n   *  0 if a is equal to b\\n   *  1 if a greater than b\\n   */\\n  const defaultComparator = function (x, y) {\\n    if (x === undefined && y === undefined) return 0\\n    if (x === undefined) return 1\\n    if (y === undefined) return -1\\n    const xString = toString(x)\\n    const yString = toString(y)\\n    if (xString < yString) return -1\\n    if (xString > yString) return 1\\n    return 0\\n  }\\n  /**\\n   * @function helper function for defaultComparator\\n   * Converts a given object to String\\n   * @throws TypeError()\\n   * @param {Object} obj\\n   * @returns {String} String representation of given object\\n   */\\n  const toString = function (obj) {\\n    if (obj === null) return 'null'\\n    if (typeof obj === 'boolean' || typeof obj === 'number') {\\n      return obj.toString()\\n    }\\n    if (typeof obj === 'string') return obj\\n    if (typeof obj === 'symbol') throw new TypeError()\\n    return obj.toString()\\n  }\\n  /**\\n   * Checks if the value passed is an array\\n   * or not\\n   */\\n  if (Array.isArray(array) === false) {\\n    return\\n  }\\n  /**\\n   * If the compare parameter is not a function\\n   * or not passed at all use default comparator\\n   * function\\n   */\\n  if (typeof compare !== 'function') {\\n    compare = defaultComparator // If compare is not a comparator function\\n  }\\n  /**\\n   * Use a closure to define the whole sort\\n   * implementation this is done through\\n   * [IIFE](https://en.wikipedia.org/wiki/Immediately_invoked_function_expression)\\n   */\\n  return (function (array, comparator) {\\n    const swap = function (index1, index2) {\\n      const temp = array[index1]\\n      array[index1] = array[index2]\\n      array[index2] = temp\\n    }\\n    /**\\n     * @constant THRESHOLD\\n     * If the length of array is less than\\n     * this then we simply perform insertion sort\\n     */\\n    const THRESHOLD = 16\\n    /**\\n     * @constant TUNEMAXDEPTH\\n     * Constant usec to increase or decrease value\\n     * of maxDepth\\n     */\\n    const TUNEMAXDEPTH = 1\\n    const len = array.length\\n    /**\\n     * Return if array is only of length 1\\n     * Array of size 1 is always sorted\\n     */\\n    if (len === 1) {\\n      return\\n    }\\n    /**\\n     * Calculate maxDepth = log2(len)\\n     * Taken from implementation in stdc++\\n     */\\n    const maxDepth = Math.floor(Math.log2(len)) * TUNEMAXDEPTH\\n    /**\\n     * The very first call to quicksort\\n     * this initiates sort routine\\n     */\\n    quickSort(0, len, maxDepth)\\n    /**\\n     * A final check call to insertion sort\\n     * on sorted array\\n     */\\n    insertionSort(0, len)\\n    /** *********************  Implementation of various routines  **************************/\\n    /**\\n     * @function\\n     * This is recursive quicksort implementation in array\\n     * of segment [start,last-1]\\n     * [QuickSort](https://en.wikipedia.org/wiki/Quicksort)\\n     * @param {Number} start the start index of array segment to be sorted\\n     * @param {Number} last  one more than the last index of array segment\\n     * @param {Number} depth this measures how many recursive calls are done\\n     */\\n    function quickSort (start, last, depth) {\\n      if (last - start <= THRESHOLD) {\\n        insertionSort(start, last)\\n        return\\n      } else if (depth <= 0) {\\n        heapSort(start, last)\\n        return\\n      }\\n      let pivot = (last + start) >> 1\\n      pivot = partition(start, last, pivot)\\n      quickSort(start, pivot, depth - 1)\\n      quickSort(pivot + 1, last, depth - 1)\\n    }\\n    /**\\n     * @function Helper function to quicksort\\n     * @param {Number} start the start of array segment to partition\\n     * @param {Number} last  one more than last index of the array segment\\n     * @param {Number} pivot the index of pivot to be used\\n     * @returns {Number} the index of pivot after partition\\n     */\\n    function partition (start, last, pivot) {\\n      swap(start, pivot)\\n      pivot = start\\n      let lo = start\\n      let hi = last\\n      while (true) {\\n        lo++\\n        while (comparator(array[lo], array[pivot]) <= 0 && lo !== last) {\\n          lo++\\n        }\\n        hi--\\n        while (comparator(array[hi], array[pivot]) > 0 && hi !== start) {\\n          hi--\\n        }\\n        if (lo >= hi) {\\n          break\\n        }\\n        swap(lo, hi)\\n      }\\n      swap(start, hi)\\n      return hi\\n    }\\n    /**\\n     * @function\\n     * Performs insertion sort on array of range\\n     * [start, last-1]\\n     * @param {Number} start the first index of array segment to be sorted\\n     * @param {Number} last  one more than last index of array to be sorted\\n     */\\n    function insertionSort (start, last) {\\n      let i, j\\n      for (i = start + 1; i < last; i++) {\\n        j = i - 1\\n        while (j >= 0 && comparator(array[j], array[j + 1]) > 0) {\\n          swap(j, j + 1)\\n          j--\\n        }\\n      }\\n    }\\n    /**\\n     * @function\\n     * Performs heapsort in array segment of range [start, last-1]\\n     * [HeapSort](https://en.wikipedia.org/wiki/Heapsort)\\n     * @param {Number} start the first index of array segment to be sorted\\n     * @param {Number} last  one more than last index of array to be sorted\\n     */\\n    function heapSort (start, last) {\\n      let x = (last + start) >> 1\\n      while (x - start >= 0) {\\n        heapify(x, start, last)\\n        x--\\n      }\\n      x = last - 1\\n      while (x - start > 0) {\\n        swap(start, x)\\n        heapify(start, start, x)\\n        x--\\n      }\\n    }\\n    /**\\n     * @function Helper function to heapsort routine\\n     * @param {Number} cur the index we need to heapify\\n     * @param {Number} start the start index of array segment that cur belongs to\\n     * @param {Number} last  one more than last index of segment that cur belongs to\\n     */\\n    function heapify (cur, start, last) {\\n      const size = last - start\\n      let max, lt, rt\\n      cur = cur - start\\n      while (true) {\\n        max = cur\\n        lt = 2 * max + 1\\n        rt = 2 * max + 2\\n        if (\\n          lt < size &&\\n          comparator(array[start + max], array[start + lt]) < 0\\n        ) {\\n          max = lt\\n        }\\n        if (\\n          rt < size &&\\n          comparator(array[start + max], array[start + rt]) < 0\\n        ) {\\n          max = rt\\n        }\\n        if (max !== cur) {\\n          swap(start + cur, start + max)\\n          cur = max\\n        } else {\\n          break\\n        }\\n      }\\n    }\\n  })(array, compare)\\n}\\n\\n/**\\n * @example Demo run of the sort routine\\n * The data is randomly generated\\n * Returns 'RIGHT:)' if the sort routine worked as expected,\\n *         'WRONG!!' otherwise\\n */\\nfunction demo1 () {\\n  const data = []\\n  const size = 1000000\\n  let i = 0\\n  let temp\\n  const c = function (a, b) {\\n    return a - b\\n  }\\n  for (i = 0; i < size; i++) {\\n    temp = Math.random() * Number.MAX_SAFE_INTEGER\\n    data.push(temp)\\n  }\\n  introsort(data, c)\\n  let faulty = false\\n  for (i = 1; i < size; i++) {\\n    if (data[i] < data[i - 1]) {\\n      faulty = true\\n      break\\n    }\\n  }\\n  if (faulty) {\\n    return 'WRONG!!'\\n  } else {\\n    return 'RIGHT:)'\\n  }\\n}\\n\\n/**\\n * @example Demo run of the sort routine\\n * using the default compare function and\\n * comparing the results with Array.sort\\n */\\nfunction demo2 () {\\n  const data = []\\n  const data2 = []\\n  const size = 1000000\\n  let i = 0\\n  let temp\\n  for (i = 0; i < size; i++) {\\n    temp = Math.random() * Number.MAX_SAFE_INTEGER\\n    data.push(temp)\\n    data2.push(temp)\\n  }\\n  introsort(data)\\n  data2.sort()\\n  let faulty = false\\n  for (i = 1; i < size; i++) {\\n    if (data[i] !== data2[i]) {\\n      faulty = true\\n      break\\n    }\\n  }\\n  if (faulty) {\\n    return 'WRONG Implemented Comparator!!'\\n  } else {\\n    return 'Comparator Works Fine:)'\\n  }\\n}\\n\\nexport { introsort, demo1, demo2 }\\n\"",
    "merge sort": "\"/*\\n * MergeSort implementation.\\n *\\n * Merge Sort is an algorithm where the main list is divided down into two half sized lists, which then have merge sort\\n * called on these two smaller lists recursively until there is only a sorted list of one.\\n *\\n * On the way up the recursive calls, the lists will be merged together inserting\\n * the smaller value first, creating a larger sorted list.\\n */\\n\\n/**\\n * Sort and merge two given arrays.\\n *\\n * @param {Array} list1 Sublist to break down.\\n * @param {Array} list2 Sublist to break down.\\n * @return {Array} The merged list.\\n */\\nexport function merge (list1, list2) {\\n  const results = []\\n  let i = 0\\n  let j = 0\\n\\n  while (i < list1.length && j < list2.length) {\\n    if (list1[i] < list2[j]) {\\n      results.push(list1[i++])\\n    } else {\\n      results.push(list2[j++])\\n    }\\n  }\\n\\n  return results.concat(list1.slice(i), list2.slice(j))\\n}\\n\\n/**\\n * Break down the lists into smaller pieces to be merged.\\n *\\n * @param {Array} list List to be sorted.\\n * @return {Array} The sorted list.\\n */\\nexport function mergeSort (list) {\\n  if (list.length < 2) return list\\n\\n  const listHalf = Math.floor(list.length / 2)\\n  const subList1 = list.slice(0, listHalf)\\n  const subList2 = list.slice(listHalf, list.length)\\n\\n  return merge(mergeSort(subList1), mergeSort(subList2))\\n}\\n\"",
    "odd even sort": "\"/*\\n  odd–even sort or odd–even transposition sort\\n  is a relatively simple sorting algorithm, developed originally for use on parallel processors with local interconnections.\\n  It is a comparison sort related to bubble sort, with which it shares many characteristics.\\n\\n   for more information : https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort\\n*/\\n\\n// Helper function to swap array items\\nfunction swap (arr, i, j) {\\n  const tmp = arr[i]\\n  arr[i] = arr[j]\\n  arr[j] = tmp\\n}\\n\\nexport function oddEvenSort (arr) {\\n  let sorted = false\\n  while (!sorted) {\\n    sorted = true\\n    for (let i = 1; i < arr.length - 1; i += 2) {\\n      if (arr[i] > arr[i + 1]) {\\n        swap(arr, i, i + 1)\\n        sorted = false\\n      }\\n    }\\n    for (let i = 0; i < arr.length - 1; i += 2) {\\n      if (arr[i] > arr[i + 1]) {\\n        swap(arr, i, i + 1)\\n        sorted = false\\n      }\\n    }\\n  }\\n}\\n\"",
    "pancake sort": "\"/*\\n * Unlike a traditional sorting algorithm, which attempts to sort with the fewest\\n * comparisons possible, the goal of pancake sort is to sort the sequence in as few reversals as\\n * possible. The idea is to do something similar to Selection Sort. We one by one place\\n * maximum element at the end and reduce the size of current array by one.\\n *\\n * Source: https://www.geeksforgeeks.org/pancake-sorting/\\n *\\n * This sorting algorithm is inspired by the pancake problem (hence the name),\\n * where a spatula can be placed anywhere between two pancakes and flip all pancakes\\n * above.\\n *\\n * The interesting about this algorithm (besides its name) is that instead of comparisons,\\n * the algorithm relies on flipping an array.\\n *\\n * Source: https://en.wikipedia.org/wiki/Pancake_sorting#The_original_pancake_problem\\n *\\n */\\n\\n/**\\n * Unlike Array.prototype.reverse, flipArray reverses only a subarray of the given\\n * array, determined by the parameters startIndex and endIndex\\n *\\n * @param {number[]} array The array to flip\\n * @param {number} startIndex The start of the subarray\\n * @param {number} endIndex The end of the subarray\\n * @returns The flipped array\\n */\\nexport function flipArray (array, startIndex, endIndex) {\\n  while (startIndex < endIndex) {\\n    // swap front and back of the subarray\\n    const temp = array[startIndex]\\n    array[startIndex] = array[endIndex]\\n    array[endIndex] = temp\\n\\n    // essentially reducing the problem to a smaller subarray\\n    startIndex++\\n    endIndex--\\n  }\\n\\n  return array\\n}\\n\\n/**\\n * Returns the index of the maximum number of a subarray in a given array\\n *\\n * @param {number[]} array The array to found the maximum number's index\\n * @param {*} startIndex The start of the subarray\\n * @param {*} endIndex The end of the subarray\\n * @returns The index of the maximum number\\n */\\nexport function findMax (array, startIndex, endIndex) {\\n  let maxIndex = 0\\n  for (let i = startIndex; i <= endIndex; i++) {\\n    if (array[i] > array[maxIndex]) maxIndex = i\\n  }\\n\\n  return maxIndex\\n}\\n\\n/**\\n * The Pancake Sort algorithm.\\n *\\n * Note that even though it's a completely different concept of sorting an\\n * array, it's rather simple!\\n *\\n * @param {number[]} array The array to sort\\n * @returns The sorted array\\n */\\nexport function pancakeSort (array) {\\n  for (let subarraySize = array.length; subarraySize > 1; subarraySize--) {\\n    const maximumIndex = findMax(array, 0, subarraySize - 1)\\n\\n    if (maximumIndex !== subarraySize - 1) {\\n      flipArray(array, 0, maximumIndex)\\n      flipArray(array, 0, subarraySize - 1)\\n    }\\n  }\\n\\n  return array\\n}\\n\"",
    "pigeon hole sort": "\"/*\\nhttps://en.wikipedia.org/wiki/Pigeonhole_sort\\n\\n*Pigeonhole sorting is a sorting algorithm that is suitable\\n* for sorting lists of elements where the number of elements\\n* (n) and the length of the range of possible key values (N)\\n* are approximately the same.\\n */\\nexport function pigeonHoleSort (arr) {\\n  let min = arr[0]\\n  let max = arr[0]\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    if (arr[i] > max) { max = arr[i] }\\n    if (arr[i] < min) { min = arr[i] }\\n  }\\n\\n  const range = max - min + 1\\n  const pigeonhole = Array(range).fill(0)\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    pigeonhole[arr[i] - min]++\\n  }\\n\\n  let index = 0\\n\\n  for (let j = 0; j < range; j++) {\\n    while (pigeonhole[j]-- > 0) {\\n      arr[index++] = j + min\\n    }\\n  }\\n}\\n\"",
    "quick sort": "\"/**\\n * @function QuickSort\\n * @description Quick sort is a comparison sorting algorithm that uses a divide and conquer strategy.\\n * @param {Integer[]} items - Array of integers\\n * @return {Integer[]} - Sorted array.\\n * @see [QuickSort](https://en.wikipedia.org/wiki/Quicksort)\\n */\\nfunction quickSort (items) {\\n  const length = items.length\\n\\n  if (length <= 1) {\\n    return items\\n  }\\n  const PIVOT = items[0]\\n  const GREATER = []\\n  const LESSER = []\\n\\n  for (let i = 1; i < length; i++) {\\n    if (items[i] > PIVOT) {\\n      GREATER.push(items[i])\\n    } else {\\n      LESSER.push(items[i])\\n    }\\n  }\\n\\n  const sorted = [...quickSort(LESSER), PIVOT, ...quickSort(GREATER)]\\n  return sorted\\n}\\n\\nexport { quickSort }\\n\"",
    "quick sort recursive": "\"/*\\n    Quicksort is the most popular sorting algorithm and there have\\n    lots of different implementations but the \\\"recursive\\\" or \\\"Partition in place\\\"\\n    is one of the most efficient implementations below we have discussed how to\\n    implement it.\\n\\n    Partition in place => \\\"in place\\\" Partition in place indicates that we\\n    do not need any other space to store the auxiliary array and the term\\n    \\\"partition\\\" denotes that we split the list into two parts one is less\\n    than the pivot and the other is greater than the pivot and repeats this\\n    process recursively and breaks the problem into sub-problems and makes\\n    it singular so that the behavior or \\\"divide and conquer\\\" get involved\\n    too.\\n\\n    Problem & Source of Explanation => https://www.cs.auckland.ac.nz/software/AlgAnim/qsort1a.html\\n*/\\n\\n/**\\n * Partition in place QuickSort.\\n * @param {number[]} inputList list of values.\\n * @param {number} low lower index for partition.\\n * @param {number} high higher index for partition.\\n */\\nconst quickSort = (inputList, low, high) => {\\n  if (!Array.isArray(inputList)) {\\n    throw new TypeError('Please input a valid list or array.')\\n  }\\n  if (low < high) {\\n    // get the partition index.\\n    const pIndex = partition(inputList, low, high)\\n    // recursively call the quickSort method again.\\n    quickSort(inputList, low, pIndex - 1)\\n    quickSort(inputList, pIndex + 1, high)\\n  }\\n  return inputList\\n}\\n\\n/**\\n * Partition In Place method.\\n * @param {number[]} partitionList list for partitioning.\\n * @param {number} low lower index for partition.\\n * @param {number} high higher index for partition.\\n * @returns {number} `pIndex` pivot index value.\\n */\\nconst partition = (partitionList, low, high) => {\\n  const pivot = partitionList[high]\\n  let pIndex = low\\n  for (let index = low; index <= high - 1; index++) {\\n    if (partitionList[index] < pivot) {\\n      // swap variables using array destructuring\\n      [partitionList[index], partitionList[pIndex]] = [partitionList[pIndex], partitionList[index]]\\n      pIndex += 1\\n    }\\n  }\\n  [partitionList[pIndex], partitionList[high]] = [partitionList[high], partitionList[pIndex]]\\n  return pIndex\\n}\\n\\nexport { quickSort }\\n\"",
    "radix sort": "\"/*\\n* Radix sorts an integer array without comparing the integers.\\n* It groups the integers by their digits which share the same\\n* significant position.\\n* For more information see: https://en.wikipedia.org/wiki/Radix_sort\\n*/\\nexport function radixSort (items, RADIX) {\\n  // default radix is then because we usually count to base 10\\n  if (RADIX === undefined || RADIX < 1) {\\n    RADIX = 10\\n  }\\n\\n  let maxLength = false\\n  let placement = 1\\n\\n  while (!maxLength) {\\n    maxLength = true\\n    const buckets = []\\n\\n    for (let i = 0; i < RADIX; i++) {\\n      buckets.push([])\\n    }\\n\\n    for (let j = 0; j < items.length; j++) {\\n      const tmp = items[j] / placement\\n      buckets[Math.floor(tmp % RADIX)].push(items[j])\\n      if (maxLength && tmp > 0) {\\n        maxLength = false\\n      }\\n    }\\n\\n    let a = 0\\n    for (let b = 0; b < RADIX; b++) {\\n      const buck = buckets[b]\\n      for (let k = 0; k < buck.length; k++) {\\n        items[a] = buck[k]\\n        a++\\n      }\\n    }\\n    placement *= RADIX\\n  }\\n  return items\\n}\\n\"",
    "selection sort": "\"/* The selection sort algorithm sorts an array by repeatedly finding the minimum element\\n *(considering ascending order) from unsorted part and putting it at the beginning. The\\n *algorithm maintains two subarrays in a given array.\\n *1) The subarray which is already sorted.\\n *2) Remaining subarray which is unsorted.\\n *\\n *In every iteration of selection sort, the minimum element (considering ascending order)\\n *from the unsorted subarray is picked and moved to the sorted subarray.\\n */\\n\\nexport const selectionSort = (list) => {\\n  if (!Array.isArray(list)) {\\n    throw new TypeError('Given input is not an array')\\n  }\\n  const items = [...list] // We don't want to modify the original array\\n  const length = items.length\\n  for (let i = 0; i < length - 1; i++) {\\n    if (typeof items[i] !== 'number') {\\n      throw new TypeError('One of the items in your array is not a number')\\n    }\\n    // Number of passes\\n    let min = i // min holds the current minimum number position for each pass; i holds the Initial min number\\n    for (let j = i + 1; j < length; j++) { // Note that j = i + 1 as we only need to go through unsorted array\\n      if (items[j] < items[min]) { // Compare the numbers\\n        min = j // Change the current min number position if a smaller num is found\\n      }\\n    }\\n    if (min !== i) {\\n      // After each pass, if the current min num != initial min num, exchange the position.\\n      // Swap the numbers\\n      [items[i], items[min]] = [items[min], items[i]]\\n    }\\n  }\\n  return items\\n}\\n\"",
    "shell sort": "\"/*\\n * Shell Sort sorts an array based on  insertion sort algorithm\\n * more information: https://en.wikipedia.org/wiki/Shellsort\\n *\\n */\\nexport function shellSort (items) {\\n  let interval = 1\\n\\n  while (interval < items.length / 3) {\\n    interval = interval * 3 + 1\\n  }\\n\\n  while (interval > 0) {\\n    for (let outer = interval; outer < items.length; outer++) {\\n      const value = items[outer]\\n      let inner = outer\\n\\n      while (inner > interval - 1 && items[inner - interval] >= value) {\\n        items[inner] = items[inner - interval]\\n        inner = inner - interval\\n      }\\n      items[inner] = value\\n    }\\n    interval = (interval - 1) / 3\\n  }\\n  return items\\n}\\n\"",
    "tim sort": "\"/**\\n  *  @function Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort,\\n  *  designed to perform well on many kinds of real-world data.\\n  *  It was implemented by Tim Peters in 2002 for use in the Python programming language.\\n  *  It is also used to sort arrays of non-primitive type in Java SE 7,\\n  *  on the Android platform, in GNU Octave, on V8, Swift and Rust.\\n  *  1) It sorts small partitions using Insertion Sort.\\n  *  2) Merges the partition using Merge Sort.\\n  *  @see [Timsort](https://en.wikipedia.org/wiki/Timsort)\\n  *  @param {Array} array\\n  */\\n\\nconst Timsort = (array) => {\\n  // Default size of a partition\\n  const RUN = 32\\n  const n = array.length\\n  // Sorting the partitions using Insertion Sort\\n  for (let i = 0; i < n; i += RUN) {\\n    InsertionSort(array, i, Math.min(i + RUN - 1, n - 1))\\n  }\\n  for (let size = RUN; size < n; size *= 2) {\\n    for (let left = 0; left < n; left += 2 * size) {\\n      const mid = left + size - 1\\n      const right = Math.min(left + 2 * size - 1, n - 1)\\n      Merge(array, left, mid, right)\\n    }\\n  }\\n}\\n\\n/**\\n * @function performs insertion sort on the partition\\n * @param {Array} array array to be sorted\\n * @param {Number} left left index of partition\\n * @param {Number} right right index of partition\\n */\\n\\nconst InsertionSort = (array, left, right) => {\\n  for (let i = left + 1; i <= right; i++) {\\n    const key = array[i]\\n    let j = i - 1\\n    while (j >= left && array[j] > key) {\\n      array[j + 1] = array[j]\\n      j--\\n    }\\n    array[j + 1] = key\\n  }\\n}\\n\\n/**\\n * @function merges two sorted partitions\\n * @param {Array} array array to be sorted\\n * @param {Number} left left index of partition\\n * @param {Number} mid mid index of partition\\n * @param {Number} right right index of partition\\n */\\n\\nconst Merge = (array, left, mid, right) => {\\n  if (mid >= right) return\\n  const len1 = mid - left + 1\\n  const len2 = right - mid\\n  const larr = Array(len1)\\n  const rarr = Array(len2)\\n  for (let i = 0; i < len1; i++) {\\n    larr[i] = array[left + i]\\n  }\\n  for (let i = 0; i < len2; i++) {\\n    rarr[i] = array[mid + 1 + i]\\n  }\\n  let i = 0; let j = 0; let k = left\\n  while (i < larr.length && j < rarr.length) {\\n    if (larr[i] < rarr[j]) {\\n      array[k++] = larr[i++]\\n    } else {\\n      array[k++] = rarr[j++]\\n    }\\n  }\\n  while (i < larr.length) {\\n    array[k++] = larr[i++]\\n  }\\n  while (j < rarr.length) {\\n    array[k++] = rarr[j++]\\n  }\\n}\\n\\n/**\\n * @example Test of Timsort functions.\\n * Data is randomly generated.\\n * Return \\\"RIGHT\\\" if it works as expected,\\n * otherwise \\\"FAULTY\\\"\\n */\\nconst demo = () => {\\n  const size = 1000000\\n  const data = Array(size)\\n  for (let i = 0; i < size; i++) {\\n    data[i] = Math.random() * Number.MAX_SAFE_INTEGER\\n  }\\n  const isSorted = function (array) {\\n    const n = array.length\\n    for (let i = 0; i < n - 1; i++) {\\n      if (array[i] > array[i + 1]) return false\\n    }\\n    return true\\n  }\\n  Timsort(data)\\n  if (isSorted(data)) {\\n    return 'RIGHT'\\n  } else {\\n    return 'FAULTY'\\n  }\\n}\\n\\nexport { Timsort, demo }\\n\"",
    "topological sort": "\"\\nexport function TopologicalSorter () {\\n  const graph = {}\\n  let isVisitedNode\\n  let finishTimeCount\\n  let finishingTimeList\\n  let nextNode\\n\\n  this.addOrder = function (nodeA, nodeB) {\\n    nodeA = String(nodeA)\\n    nodeB = String(nodeB)\\n    graph[nodeA] = graph[nodeA] || []\\n    graph[nodeA].push(nodeB)\\n  }\\n\\n  this.sortAndGetOrderedItems = function () {\\n    isVisitedNode = Object.create(null)\\n    finishTimeCount = 0\\n    finishingTimeList = []\\n\\n    for (const node in graph) {\\n      if (Object.prototype.hasOwnProperty.call(graph, node) && !isVisitedNode[node]) {\\n        dfsTraverse(node)\\n      }\\n    }\\n\\n    finishingTimeList.sort(function (item1, item2) {\\n      return item1.finishTime > item2.finishTime ? -1 : 1\\n    })\\n\\n    return finishingTimeList.map(function (value) { return value.node })\\n  }\\n\\n  function dfsTraverse (node) {\\n    isVisitedNode[node] = true\\n    if (graph[node]) {\\n      for (let i = 0; i < graph[node].length; i++) {\\n        nextNode = graph[node][i]\\n        if (isVisitedNode[nextNode]) continue\\n        dfsTraverse(nextNode)\\n      }\\n    }\\n\\n    finishingTimeList.push({\\n      node: node,\\n      finishTime: ++finishTimeCount\\n    })\\n  }\\n}\\n\\n/* TEST */\\n// const topoSorter = new TopologicalSorter()\\n// topoSorter.addOrder(5, 2)\\n// topoSorter.addOrder(5, 0)\\n// topoSorter.addOrder(4, 0)\\n// topoSorter.addOrder(4, 1)\\n// topoSorter.addOrder(2, 3)\\n// topoSorter.addOrder(3, 1)\\n// topoSorter.sortAndGetOrderedItems()\\n\"",
    "wiggle sort": "\"/*\\n * Wiggle sort sorts the array into a wave like array.\\n * An array ‘arr[0..n-1]’ is sorted in wave form if arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= …..\\n *\\n */\\n\\nexport const wiggleSort = function (arr) {\\n  for (let i = 0; i < arr.length; ++i) {\\n    const shouldNotBeLessThan = i % 2\\n    const isLessThan = arr[i] < arr[i + 1]\\n    if (shouldNotBeLessThan && isLessThan) {\\n      [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]\\n    }\\n  }\\n  return arr\\n}\\n\\n// Implementation of wiggle sort\\n\\n// > wiggleSort([3, 5, 2, 1, 6, 4])\\n// [ 3, 5, 2, 6, 1, 4 ]\\n\"",
    "alpha numeric palindrome": "\"/*****************************************************************************\\n * @function alphaNumericPlaindrome\\n * @description alphaNumericPlaindrome should return true if the string has alphanumeric characters that are palindrome irrespective of special characters and the letter case.\\n * @param {string} str the string to check\\n * @returns {Boolean}\\n * @see [Factorial](https://en.wikipedia.org/wiki/Palindrome)\\n * @example\\n * The function alphaNumericPlaindrome() receives a string with varying formats\\n * like \\\"racecar\\\", \\\"RaceCar\\\", and \\\"race CAR\\\"\\n * The string can also have special characters\\n * like \\\"2A3*3a2\\\", \\\"2A3 3a2\\\", and \\\"2_A3*3#A2\\\"\\n *\\n * But the catch is, we have to check only if the alphanumeric characters\\n * are palindrome i.e remove spaces, symbols, punctuations etc\\n * and the case of the characters doesn't matter\\n *\\n ****************************************************************************/\\n\\nconst alphaNumericPlaindrome = (str) => {\\n  // removing all the special characters and turning everything to lowercase\\n  const newStr = str.replace(/[^a-zA-Z0-9]*/g, '').toLowerCase()\\n\\n  for (let i = 0; i < newStr.length; i++) {\\n    if (newStr[i] !== newStr[newStr.length - 1 - i]) {\\n      return false\\n    }\\n  }\\n\\n  return true\\n}\\n\\nexport { alphaNumericPlaindrome }\\n\"",
    "alternative string arrange": "\"// Alternative arrange the two given strings in one string in O(n) time complexity.\\n\\n// Problem Source & Explanation: https://www.geeksforgeeks.org/alternatively-merge-two-strings-in-java/\\n\\n/**\\n * Alternative arrange the two given strings in one string in O(n) time complexity.\\n * @param {String} str1 first input string\\n * @param {String} str2 second input string\\n * @returns `String` return one alternative arrange string.\\n */\\nconst AlternativeStringArrange = (str1, str2) => {\\n  // firstly, check that both inputs are strings.\\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\\n    return 'Not string(s)'\\n  }\\n\\n  // output string value.\\n  let outStr = ''\\n\\n  // get first string length.\\n  const firstStringLength = str1.length\\n  // get second string length.\\n  const secondStringLength = str2.length\\n  // absolute length for operation.\\n  const absLength = firstStringLength > secondStringLength ? firstStringLength : secondStringLength\\n\\n  // Iterate the character count until the absolute count is reached.\\n  for (let charCount = 0; charCount < absLength; charCount++) {\\n    // If firstStringLength is lesser than the charCount it means they are able to re-arrange.\\n    if (charCount < firstStringLength) {\\n      outStr += str1[charCount]\\n    }\\n\\n    // If secondStringLength is lesser than the charCount it means they are able to re-arrange.\\n    if (charCount < secondStringLength) {\\n      outStr += str2[charCount]\\n    }\\n  }\\n\\n  // return the output string.\\n  return outStr\\n}\\n\\nexport { AlternativeStringArrange }\\n\"",
    "check anagram": "\"// An [Anagram](https://en.wikipedia.org/wiki/Anagram) is a string that is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\\n// Anagram check is case sensitive; i.e. Aba and aba is not a anagram.\\n// inputs are strings i.e. str1 and str2\\nconst checkAnagram = (str1, str2) => {\\n  // check that inputs are strings.\\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\\n    return 'Not string(s)'\\n  }\\n\\n  // If both strings have not same lengths then they can not be anagram.\\n  if (str1.length !== str2.length) {\\n    return false\\n  }\\n\\n  // Use hashmap to keep count of characters in str1\\n\\n  const str1CharCount = new Map()\\n\\n  for (let i = 0; i < str1.length; i++) {\\n    let previousCount = 0\\n    if (str1CharCount.has(str1[i])) {\\n      previousCount = str1CharCount.get(str1[i])\\n    }\\n    str1CharCount.set(str1[i], previousCount + 1)\\n  }\\n\\n  // Now check if second string has same characters?\\n\\n  for (let i = 0; i < str2.length; i++) {\\n    let previousCount = 0\\n    // if str1CharCount has no key for str2[i] then not anagram.\\n    if (!str1CharCount.has(str2[i])) return false\\n\\n    previousCount = str1CharCount.get(str2[i])\\n    str1CharCount.set(str2[i], previousCount - 1)\\n  }\\n\\n  // Now check if all entries in hashmap has zeros.\\n\\n  for (const key in str1CharCount) {\\n    if (str1CharCount[key] !== 0) return false\\n  }\\n\\n  return true\\n}\\n\\nexport { checkAnagram }\\n\"",
    "check camel case": "\"// CheckCamelCase method checks the given string is in camelCase or not.\\n\\n// Problem Source & Explanation: https://en.wikipedia.org/wiki/Camel_case\\n\\n/**\\n * checkCamelCase method returns true if the string in camelCase, else return the false.\\n * @param {String} varName the name of the variable to check.\\n * @returns `Boolean` return true if the string is in camelCase, else return false.\\n */\\nconst checkCamelCase = (varName) => {\\n  // firstly, check that input is a string or not.\\n  if (typeof varName !== 'string') {\\n    throw new TypeError('Argument is not a string.')\\n  }\\n\\n  const pat = /^[a-z][A-Za-z]*$/\\n  return pat.test(varName)\\n}\\n\\nexport { checkCamelCase }\\n\"",
    "check flat case": "\"// checkFlatCase method checks if the given string is in flatcase or not. Flatcase is a convention\\n// where all letters are in lowercase, and there are no spaces between words.\\n// thisvariable is an example of flatcase. In camelCase it would be thisVariable, snake_case this_variable and so on.\\n\\n// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)\\n\\n/**\\n * checkFlatCase method returns true if the string in flatcase, else return the false.\\n * @param {string} varname the name of the variable to check.\\n * @returns {boolean} return true if the string is in flatcase, else return false.\\n */\\nconst checkFlatCase = (varname) => {\\n  // firstly, check that input is a string or not.\\n  if (typeof varname !== 'string') {\\n    return new TypeError('Argument is not a string.')\\n  }\\n\\n  const pat = /^[a-z]*$/\\n  return pat.test(varname)\\n}\\n\\nexport { checkFlatCase }\\n\"",
    "check kebab case": "\"// CheckKebabCase method checks the given string is in kebab-case or not.\\n\\n// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)\\n\\n/**\\n * CheckKebabCase method returns true if the string in kebab-case, else return the false.\\n * @param {String} varName the name of the variable to check.\\n * @returns `Boolean` return true if the string is in kebab-case, else return false.\\n */\\nconst CheckKebabCase = (varName) => {\\n  // firstly, check that input is a string or not.\\n  if (typeof varName !== 'string') {\\n    return new TypeError('Argument is not a string.')\\n  }\\n\\n  const pat = /(\\\\w+)-(\\\\w)([\\\\w-]*)/\\n  return pat.test(varName) && !varName.includes('_')\\n}\\n\\nexport { CheckKebabCase }\\n\"",
    "check palindrome": "\"// Palindrome check is case sensitive; i.e. Aba is not a palindrome\\n// input is a string\\nconst checkPalindrome = (str) => {\\n  // check that input is a string\\n  if (typeof str !== 'string') {\\n    return 'Not a string'\\n  }\\n  if (str.length === 0) {\\n    return 'Empty string'\\n  }\\n  // Reverse only works with array, thus convert the string to array, reverse it and convert back to string\\n  // return as palindrome if the reversed string is equal to the input string\\n  const reversed = [...str].reverse().join('')\\n  return str === reversed ? 'Palindrome' : 'Not a Palindrome'\\n}\\n\\nexport { checkPalindrome }\\n\"",
    "check pangram": "\"/*\\n  Pangram is a sentence that contains all the letters in the alphabet\\n  https://en.wikipedia.org/wiki/Pangram\\n */\\n\\nconst checkPangram = (string) => {\\n  if (typeof string !== 'string') {\\n    throw new TypeError('The given value is not a string')\\n  }\\n\\n  const frequency = new Set()\\n\\n  for (const letter of string.toLowerCase()) {\\n    if (letter >= 'a' && letter <= 'z') {\\n      frequency.add(letter)\\n    }\\n  }\\n\\n  return frequency.size === 26\\n}\\n\\nexport { checkPangram }\\n\"",
    "check pascal case": "\"// CheckPascalCase method checks the given string is in PascalCase or not.\\n\\n// Problem Source & Explanation: https://www.theserverside.com/definition/Pascal-case\\n\\n/**\\n * CheckPascalCase method returns true if the string in PascalCase, else return the false.\\n * @param {String} VarName the name of the variable to check.\\n * @returns `Boolean` return true if the string is in PascalCase, else return false.\\n */\\nconst CheckPascalCase = (VarName) => {\\n  // firstly, check that input is a string or not.\\n  if (typeof VarName !== 'string') {\\n    return new TypeError('Argument is not a string.')\\n  }\\n\\n  const pat = /^[A-Z][A-Za-z]*$/\\n  return pat.test(VarName)\\n}\\n\\nexport { CheckPascalCase }\\n\"",
    "check rearrange palindrome": "\"/**\\n  * What is a palindrome? https://en.wikipedia.org/wiki/Palindrome\\n  * Receives a string and returns whether it can be rearranged to become a palindrome or not\\n  * The string can only be a palindrome if the count of ALL characters is even or if the ONLY ONE character count is odd\\n  * Input is a string\\n  *\\n  **/\\n\\nexport const palindromeRearranging = (str) => {\\n  // check that input is a string\\n  if (typeof str !== 'string') {\\n    return 'Not a string'\\n  }\\n  // Check if is a empty string\\n  if (str.length === 0) {\\n    return 'Empty string'\\n  }\\n\\n  // First obtain the character count for each character in the string and store it in an object.\\n  // Filter the object's values to only the odd character counts.\\n  const charCounts = [...str].reduce((counts, char) => {\\n    counts[char] = counts[char] ? counts[char] + 1 : 1\\n    return counts\\n  }, {})\\n  // If the length of the resulting array is 0 or 1, the string can be a palindrome.\\n  return Object.values(charCounts).filter(count => count % 2 !== 0).length <= 1\\n}\\n\\n// testing\\n\\n// > palindromeRearranging('aaeccrr')\\n// true\\n\\n// > palindromeRearranging('leve')\\n// false\\n\"",
    "check snake case": "\"// CheckSnakeCase method checks the given string is in snake_case or not.\\n\\n// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)\\n\\n/**\\n * checkSnakeCase method returns true if the string in snake_case, else return the false.\\n * @param {String} varName the name of the variable to check.\\n * @returns `Boolean` return true if the string is in snake_case, else return false.\\n */\\nconst checkSnakeCase = (varName) => {\\n  // firstly, check that input is a string or not.\\n  if (typeof varName !== 'string') {\\n    throw new TypeError('Argument is not a string.')\\n  }\\n\\n  const pat = /(.*?)_([a-zA-Z])*/\\n  return pat.test(varName)\\n}\\n\\nexport { checkSnakeCase }\\n\"",
    "check word occurrence": "\"/**\\n  * Check and count occurrence of each word in a string\\n  * Inputs a String eg. Madonna and Boolean\\n  **/\\n\\nconst checkWordOccurrence = (str, isCaseSensitive = false) => {\\n  if (typeof str !== 'string') {\\n    throw new TypeError('The first param should be a string')\\n  }\\n  if (typeof isCaseSensitive !== 'boolean') {\\n    throw new TypeError('The second param should be a boolean')\\n  }\\n\\n  const result = {}\\n  if (str.length > 0) {\\n    for (let i = 0; i < str.length; i++) {\\n      const word = isCaseSensitive ? str[i] : str[i].toUpperCase()\\n      if (/\\\\s/.test(word)) continue\\n      result[word] = (!result[word]) ? 1 : result[word] + 1\\n    }\\n  }\\n\\n  return result\\n}\\nexport { checkWordOccurrence }\\n\"",
    "count vowels": "\"/**\\n * @function countVowels\\n * @description Given a string of words or phrases, count the number of vowels.\\n * @param {String} url - The input string\\n * @return {Number} count\\n * @example countVowels(\\\"ABCDE\\\") => 2\\n * @example countVowels(\\\"Hello\\\") => 2\\n */\\n\\nconst countVowels = (str) => {\\n  if (typeof str !== 'string') {\\n    throw new TypeError('Input should be a string')\\n  }\\n  const vowels = new Set(['a', 'e', 'i', 'o', 'u'])\\n  let count = 0\\n  for (let i = 0; i < str.length; i++) {\\n    const char = str[i].toLowerCase()\\n    if (vowels.has(char)) {\\n      count++\\n    }\\n  }\\n  return count\\n}\\n\\nexport { countVowels }\\n\"",
    "create permutations": "\"/*\\na permutation of a set is, loosely speaking, an arrangement of its members into a sequence or linear order, or if the set is already ordered, a rearrangement of its elements.\\nThe word \\\"permutation\\\" also refers to the act or process of changing the linear order of an ordered set\\nMore at : https://en.wikipedia.org/wiki/Permutation\\n*/\\n\\nconst createPermutations = (str) => {\\n// convert string to array\\n  const arr = str.split('')\\n\\n  // get array length\\n  const strLen = arr.length\\n  // this will hold all the permutations\\n  const perms = []\\n  let rest\\n  let picked\\n  let restPerms\\n  let next\\n\\n  // if strLen is zero, return the same string\\n  if (strLen === 0) { return [str] }\\n  // loop to the length to get all permutations\\n  for (let i = 0; i < strLen; i++) {\\n    rest = Object.create(arr)\\n    picked = rest.splice(i, 1)\\n\\n    restPerms = createPermutations(rest.join(''))\\n\\n    for (let j = 0, jLen = restPerms.length; j < jLen; j++) {\\n      next = picked.concat(restPerms[j])\\n      perms.push(next.join(''))\\n    }\\n  }\\n  return perms\\n}\\nexport { createPermutations }\\n\"",
    "dice coefficient": "\"/* The Sørensen–Dice coefficient is a statistic used to gauge the similarity of two samples.\\n * Applied to strings, it can give you a value between 0 and 1 (included) which tells you how similar they are.\\n * Dice coefficient is calculated by comparing the bigrams of both strings,\\n * a bigram is a substring of the string of length 2.\\n * read more: https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient\\n */\\n\\n// Time complexity: O(m + n), m and n being the sizes of string A and string B\\n\\n// Find the bistrings of a string and return a hashmap (key => bistring, value => count)\\nfunction mapBigrams (string) {\\n  const bigrams = new Map()\\n  for (let i = 0; i < string.length - 1; i++) {\\n    const bigram = string.substring(i, i + 2)\\n    const count = bigrams.get(bigram)\\n    bigrams.set(bigram, (count || 0) + 1)\\n  }\\n  return bigrams\\n}\\n\\n// Calculate the number of common bigrams between a map of bigrams and a string\\n\\nfunction countCommonBigrams (bigrams, string) {\\n  let count = 0\\n  for (let i = 0; i < string.length - 1; i++) {\\n    const bigram = string.substring(i, i + 2)\\n    if (bigrams.has(bigram)) count++\\n  }\\n  return count\\n}\\n\\n// Calculate Dice coeff of 2 strings\\nfunction diceCoefficient (stringA, stringB) {\\n  if (stringA === stringB) return 1\\n  else if (stringA.length < 2 || stringB.length < 2) return 0\\n\\n  const bigramsA = mapBigrams(stringA)\\n\\n  const lengthA = stringA.length - 1\\n  const lengthB = stringB.length - 1\\n\\n  let dice = (2 * countCommonBigrams(bigramsA, stringB)) / (lengthA + lengthB)\\n\\n  // cut 0.xxxxxx to 0.xx for simplicity\\n  dice = Math.floor(dice * 100) / 100\\n\\n  return dice\\n}\\n\\nexport { diceCoefficient }\\n\"",
    "format phone number": "\"// function that takes 10 digits and returns a string of the formatted phone number\\n// e.g.: 1234567890 -> (123) 456-7890\\n\\nconst formatPhoneNumber = (numbers) => {\\n  const numbersString = numbers.toString()\\n  if ((numbersString.length !== 10) || isNaN(numbersString)) {\\n    // return \\\"Invalid phone number.\\\"\\n    throw new TypeError('Invalid phone number.')\\n  }\\n  const arr = '(XXX) XXX-XXXX'.split('')\\n  Array.from(numbersString).forEach(n => {\\n    arr[arr.indexOf('X')] = n\\n  })\\n  return arr.join('')\\n}\\n\\nexport { formatPhoneNumber }\\n\"",
    "generate g u i d": "\"/*\\nGenerates a UUID/GUID in Node.Js.\\nThe script uses `Math.random` in combination with the timestamp for better randomness.\\nThe function generate an RFC4122 (https://www.ietf.org/rfc/rfc4122.txt) version 4 UUID/GUID\\n*/\\n\\nexport const Guid = () => {\\n  const pattern = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\\n  let currentDateMilliseconds = new Date().getTime()\\n  return pattern.replace(/[xy]/g, currentChar => {\\n    const randomChar = (currentDateMilliseconds + Math.random() * 16) % 16 | 0\\n    currentDateMilliseconds = Math.floor(currentDateMilliseconds / 16)\\n    return (currentChar === 'x' ? randomChar : (randomChar & 0x7 | 0x8)).toString(16)\\n  })\\n}\\n\\n// > Guid()\\n// 'edc848db-3478-1760-8b55-7986003d895f'\\n\"",
    "hamming distance": "\"/**\\n * Hamming Distance: https://en.wikipedia.org/wiki/Hamming_distance\\n *\\n *\\n * Hamming distance is a metric for comparing two binary data strings.\\n *\\n * While comparing two binary strings of equal length, Hamming distance\\n * is the number of bit positions in which the two bits are different.\\n * The Hamming distance between two strings, a and b is denoted as d(a,b)\\n */\\n\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {number}\\n */\\n\\nexport const hammingDistance = (a, b) => {\\n  if (a.length !== b.length) {\\n    throw new Error('Strings must be of the same length')\\n  }\\n\\n  let distance = 0\\n\\n  for (let i = 0; i < a.length; i += 1) {\\n    if (a[i] !== b[i]) {\\n      distance += 1\\n    }\\n  }\\n\\n  return distance\\n}\\n\"",
    "k m p pattern searching": "\"// Implementing KMP Search Algorithm to search all the instances of pattern in\\n// given text\\n// Reference Book: Introduction to Algorithms, CLRS\\n\\n// Explanation: https://www.topcoder.com/community/competitive-programming/tutorials/introduction-to-string-searching-algorithms/\\n\\nconst computeLPS = (pattern) => {\\n  const lps = Array(pattern.length)\\n  lps[0] = 0\\n  for (let i = 1; i < pattern.length; i++) {\\n    let matched = lps[i - 1]\\n    while (matched > 0 && pattern[i] !== pattern[matched]) {\\n      matched = lps[matched - 1]\\n    }\\n    if (pattern[i] === pattern[matched]) {\\n      matched++\\n    }\\n    lps[i] = matched\\n  }\\n  return lps\\n}\\n\\n/**\\n * Returns all indices where pattern starts in text\\n * @param {*} text a big text in which pattern string is to find\\n * @param {*} pattern the string to find\\n */\\nconst KMPSearch = (text, pattern) => {\\n  if (!pattern || !text) {\\n    return [] // no results\\n  }\\n\\n  // lps[i] = length of proper prefix of pattern[0]...pattern[i-1]\\n  //          which is also proper suffix of it\\n  const lps = computeLPS(pattern)\\n  const result = []\\n\\n  let matched = 0\\n  for (let i = 0; i < text.length; i++) {\\n    while (matched > 0 && text[i] !== pattern[matched]) {\\n      matched = lps[matched - 1]\\n    }\\n    if (text[i] === pattern[matched]) {\\n      matched++\\n    }\\n    if (matched === pattern.length) {\\n      result.push(i - pattern.length + 1)\\n      matched = lps[matched - 1]\\n    }\\n  }\\n\\n  return result\\n}\\n\\nexport { KMPSearch }\\n\"",
    "lower": "\"/**\\n * @function lower\\n * @description Will convert the entire string to lowercase letters.\\n * @param {String} url - The input URL string\\n * @return {String} Lowercase string\\n * @example lower(\\\"HELLO\\\") => hello\\n * @example lower(\\\"He_llo\\\") => he_llo\\n */\\n\\nconst lower = (str) => {\\n  if (typeof str !== 'string') {\\n    throw new TypeError('Invalid Input Type')\\n  }\\n\\n  let lowerString = ''\\n\\n  for (const char of str) {\\n    let asciiCode = char.charCodeAt(0)\\n    if (asciiCode >= 65 && asciiCode <= 90) {\\n      asciiCode += 32\\n    }\\n    lowerString += String.fromCharCode(asciiCode)\\n  }\\n\\n  return lowerString\\n}\\n\\nexport { lower }\\n\"",
    "max character": "\"/*\\n  Given a string of characters, return the character that appears the most often.\\n  Example: input = \\\"Hello World!\\\" return \\\"l\\\"\\n*/\\nconst maxCharacter = (value) => {\\n  if (typeof value !== 'string') {\\n    throw new TypeError('The param should be a string')\\n  } else if (!value) {\\n    throw new Error('The param should be a valid string')\\n  }\\n\\n  const occurrences = {}\\n  for (let i = 0; i < value.length; i++) {\\n    const char = value[i]\\n    if (/\\\\s/.test(char)) continue\\n    occurrences[char] = occurrences[char] + 1 || 1\\n  }\\n  let maxCharacter = null\\n  let maxCount = 0\\n  Object.keys(occurrences).forEach(char => {\\n    if (occurrences[char] > maxCount) {\\n      maxCount = occurrences[char]\\n      maxCharacter = char\\n    }\\n  })\\n  return maxCharacter\\n}\\n\\nexport { maxCharacter }\\n\"",
    "max word": "\"// Given a sentence, return the most occurring word\\n\\n/**\\n * @param {string} sentence - the sentence you want to find the most occurring word\\n * @returns {string} - the most occurring word\\n *\\n * @example\\n *     -  maxWord('lala lili lala'); // lala\\n */\\nconst maxWord = (sentence = '') => {\\n  if (typeof sentence !== 'string') {\\n    throw new TypeError('the param should be string')\\n  }\\n\\n  if (!sentence) {\\n    return null\\n  }\\n\\n  const words = sentence.split(' ')\\n  if (words.length < 2) {\\n    return words[0]\\n  }\\n\\n  const occurrences = {}\\n  words.forEach(word => {\\n    occurrences[word.toLocaleLowerCase()] = occurrences[word.toLocaleLowerCase()] + 1 || 1\\n  })\\n\\n  const max = Object.keys(occurrences).reduce((n, word) => {\\n    if (occurrences[word] > n.count) { return { word, count: occurrences[word] } } else { return n }\\n  }, { word: '', count: 0 })\\n\\n  return max.word\\n}\\n\\nexport { maxWord }\\n\"",
    "pattern matching": "\"/*\\nPattern matching is case insensitive as\\nthe inputs are converted to lower case before the\\nalgorithm is run.\\n\\nThe algorithm will run through the entire text and\\nreturn the starting index if the given pattern is\\navailable in the text\\n*/\\nconst checkIfPatternExists = (text, pattern) => {\\n  if (typeof text !== 'string' || typeof pattern !== 'string') {\\n    throw new TypeError('Given input is not a string')\\n  }\\n  const textLength = text.length // Store the length of the text in a variable\\n  const patternLength = pattern.length // Store the length of the pattern in a variable\\n\\n  // Iterate through the text until the textlength - patternlength index\\n  for (let i = 0; i <= textLength - patternLength; i++) {\\n    // For each character in the text check if the subsequent character\\n    // are matching the given pattern; if not break from the condition\\n    for (let j = 0; j < textLength; j++) {\\n      if (text[i + j] !== pattern[j]) break\\n\\n      // For each iteration of j check if the value of\\n      // j + 1 is equal to the length of the pattern\\n      if (j + 1 === patternLength) {\\n        return `Given pattern is found at index ${i}`\\n      }\\n    }\\n  }\\n}\\n\\nexport { checkIfPatternExists }\\n\"",
    "permutate string": "\"'use strict'\\n\\nconst permutate = (aString) => {\\n  if (typeof aString !== 'string' || !aString) {\\n    throw new Error('The arg must be a valid, non empty string')\\n  }\\n  const characters = aString.split('')\\n  let permutations = [[characters.shift()]]\\n  while (characters.length) {\\n    const currentCharacter = characters.shift()\\n    permutations = calculateCurrentCharacterPermutation(permutations, currentCharacter)\\n  }\\n  return permutations\\n    .map(character => character.join(''))\\n    .filter((item, index, self) => (self.indexOf(item) === index))\\n    .sort()\\n}\\n\\nconst calculateCurrentCharacterPermutation = (allPermutations, currentCharacter) => {\\n  const currentPermutations = []\\n  allPermutations.forEach(permutation => {\\n    let index = 0\\n    while (index <= permutation.length) {\\n      const tmp = [...permutation]\\n      tmp.splice(index, 0, currentCharacter)\\n      currentPermutations.push(tmp)\\n      index++\\n    }\\n  })\\n  return currentPermutations\\n}\\n\\nexport { permutate }\\n\"",
    "reverse string": "\"/**\\n * A short example showing how to reverse a string.\\n */\\nfunction ReverseStringIterative (string) {\\n  if (typeof string !== 'string') {\\n    throw new TypeError('The given value is not a string')\\n  }\\n  let reversedString = ''\\n  let index\\n\\n  for (index = string.length - 1; index >= 0; index--) {\\n    reversedString += string[index]\\n  }\\n\\n  return reversedString\\n}\\n\\n/**\\n * JS disallows string mutation so we're actually a bit slower.\\n *\\n * @complexity O(n)\\n */\\nfunction ReverseStringIterativeInplace (string) {\\n  if (typeof string !== 'string') {\\n    throw new TypeError('The given value is not a string')\\n  }\\n\\n  const _string = string.split('')\\n\\n  for (let i = 0; i < Math.floor(_string.length / 2); i++) {\\n    const first = _string[i]\\n    _string[i] = _string[_string.length - 1 - i]\\n    _string[_string.length - 1 - i] = first\\n  }\\n\\n  return _string.join('')\\n}\\n\\nexport { ReverseStringIterative, ReverseStringIterativeInplace }\\n\"",
    "reverse words": "\"const reverseWords = (str) => {\\n  if (typeof str !== 'string') {\\n    throw new TypeError('The given value is not a string')\\n  }\\n  // Split string into words\\n  // Ex. \\\"I Love JS\\\" => [\\\"I\\\", \\\"Love\\\", \\\"JS\\\"]\\n  const words = str.split(' ')\\n  // reverse words\\n  // [\\\"I\\\", \\\"Love\\\", \\\"JS\\\"] => [\\\"JS\\\", \\\"Love\\\", \\\"I\\\"]\\n  const reversedWords = words.reverse()\\n  // join reversed words with space and return\\n  // [\\\"JS\\\", \\\"Love\\\", \\\"I\\\"] => \\\"JS Love I\\\"\\n  return reversedWords.join(' ')\\n}\\n\\nexport { reverseWords }\\n\"",
    "scramble strings": "\"// Problem Statement and Explanation: https://leetcode.com/problems/scramble-string/\\n\\n/**\\n * Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\n\\nconst isScramble = (s1, s2) => {\\n  return helper({}, s1, s2)\\n}\\n\\nconst helper = function (dp, s1, s2) {\\n  const map = {}\\n\\n  if (dp[s1 + s2] !== undefined) return dp[s1 + s2]\\n  if (s1 === s2) return true\\n\\n  for (let j = 0; j < s1.length; j++) {\\n    if (map[s1[j]] === undefined) map[s1[j]] = 0\\n    if (map[s2[j]] === undefined) map[s2[j]] = 0\\n    map[s1[j]]++\\n    map[s2[j]]--\\n  }\\n\\n  for (const key in map) {\\n    if (map[key] !== 0) {\\n      dp[s1 + s2] = false\\n      return false\\n    }\\n  }\\n\\n  for (let i = 1; i < s1.length; i++) {\\n    if (\\n      (helper(dp, s1.substr(0, i), s2.substr(0, i)) &&\\n        helper(dp, s1.substr(i), s2.substr(i))) ||\\n      (helper(dp, s1.substr(0, i), s2.substr(s2.length - i)) &&\\n        helper(dp, s1.substr(i), s2.substr(0, s2.length - i)))\\n    ) {\\n      dp[s1 + s2] = true\\n      return true\\n    }\\n  }\\n\\n  dp[s1 + s2] = false\\n  return false\\n}\\n\\nexport { isScramble }\\n\"",
    "upper": "\"/**\\n * @function upper\\n * @description Will convert the entire string to uppercase letters.\\n * @param {String} url - The input URL string\\n * @return {String} Uppercase string\\n * @example upper(\\\"hello\\\") => HELLO\\n * @example upper(\\\"He_llo\\\") => HE_LLO\\n */\\n\\nconst upper = (str) => {\\n  if (typeof str !== 'string') {\\n    throw new TypeError('Invalid Input Type')\\n  }\\n\\n  let upperString = ''\\n\\n  for (const char of str) {\\n    let asciiCode = char.charCodeAt(0)\\n    if (asciiCode >= 97 && asciiCode <= 122) {\\n      asciiCode -= 32\\n    }\\n    upperString += String.fromCharCode(asciiCode)\\n  }\\n\\n  return upperString\\n}\\n\\nexport { upper }\\n\"",
    "validate credit card": "\"/**\\n * Validate a given credit card number\\n *\\n * The core of the validation of credit card numbers is the Luhn algorithm.\\n *\\n * The validation sum should be completely divisible by 10 which is calculated as follows,\\n * every first digit is added directly to the validation sum.\\n * For every second digit in the credit card number, the digit is multiplied by 2.\\n * If the product is greater than 10 the digits of the product are added.\\n * This resultant digit is considered for the validation sum rather than the digit itself.\\n *\\n * Ref: https://www.geeksforgeeks.org/luhn-algorithm/\\n */\\n\\nconst luhnValidation = (creditCardNumber) => {\\n  let validationSum = 0\\n  creditCardNumber.split('').forEach((digit, index) => {\\n    let currentDigit = parseInt(digit)\\n    if (index % 2 === 0) {\\n      // Multiply every 2nd digit from the left by 2\\n      currentDigit *= 2\\n      // if product is greater than 10 add the individual digits of the product to get a single digit\\n      if (currentDigit > 9) {\\n        currentDigit %= 10\\n        currentDigit += 1\\n      }\\n    }\\n    validationSum += currentDigit\\n  })\\n\\n  return validationSum % 10 === 0\\n}\\n\\nconst validateCreditCard = (creditCardString) => {\\n  const validStartSubString = ['4', '5', '6', '37', '34', '35'] // Valid credit card numbers start with these numbers\\n\\n  if (typeof creditCardString !== 'string') {\\n    throw new TypeError('The given value is not a string')\\n  }\\n\\n  const errorMessage = `${creditCardString} is an invalid credit card number because `\\n  if (isNaN(creditCardString)) {\\n    throw new TypeError(errorMessage + 'it has nonnumerical characters.')\\n  }\\n  const creditCardStringLength = creditCardString.length\\n  if (!((creditCardStringLength >= 13) && (creditCardStringLength <= 16))) {\\n    throw new Error(errorMessage + 'of its length.')\\n  }\\n  if (!validStartSubString.some(subString => creditCardString.startsWith(subString))) {\\n    throw new Error(errorMessage + 'of its first two digits.')\\n  }\\n  if (!luhnValidation(creditCardString)) {\\n    throw new Error(errorMessage + 'it fails the Luhn check.')\\n  }\\n\\n  return true\\n}\\n\\nexport { validateCreditCard }\\n\"",
    "validate email": "\"/**\\n * Returns whether the given string is a valid email address or not.\\n */\\nconst validateEmail = (str) => {\\n  if (str === '' || str === null) {\\n    throw new TypeError('Email Address String Null or Empty.')\\n  }\\n\\n  return /^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$/.test(str)\\n}\\n\\nexport { validateEmail }\\n\"",
    "validate url": "\"/**\\n * @function ValidateURL\\n * @description validate the URL.\\n * @param {String} url - The input URL string\\n * @return {Boolean}\\n */\\nconst validateURL = (url) => {\\n  const URL_PATTERN = /^(https?:\\\\/\\\\/(?:www\\\\.|(?!www))[^\\\\s.]+\\\\.[^\\\\s]{2,}|www\\\\.[^\\\\s]+\\\\.[^\\\\s]{2,})$/gi\\n\\n  return URL_PATTERN.test(url)\\n}\\n\\nexport { validateURL }\\n\"",
    "get month days": "\"/**\\n  function that takes month number and its year and returns the number of days within it\\n  * @param monthNumber.\\n  * @param year.\\n  e.g.: mahfoudh.arous@gmail.com -> true\\n  e.g.: mahfoudh.arous.com ->false\\n*/\\n\\nconst getMonthDays = (monthNumber, year) => {\\n  const the31DaysMonths = [1, 3, 5, 7, 8, 10, 12]\\n  const the30DaysMonths = [4, 6, 9, 11]\\n\\n  if (!the31DaysMonths.includes(monthNumber) && !the30DaysMonths.includes(monthNumber) &&\\n    (monthNumber !== 2)\\n  ) {\\n    throw new TypeError('Invalid Month Number.')\\n  }\\n\\n  if (the31DaysMonths.includes(monthNumber)) { return 31 }\\n\\n  if (the30DaysMonths.includes(monthNumber)) { return 30 }\\n\\n  // Check for Leap year\\n  if (year % 4 === 0) {\\n    if ((year % 100 !== 0) || (year % 100 === 0 && year % 400 === 0)) {\\n      return 29\\n    }\\n  }\\n\\n  return 28\\n}\\n\\nexport { getMonthDays }\\n\"",
    "interval timer": "\"/**\\n * @author Nandan V\\n * Sunday, 26 July 2020 8:33 AM\\n * @description Singleton class that handles the <b>timing of tests</b> and\\n *   specs. <br/> The class is singleton as <u>javascript does not support\\n *   multiple timer instances<u/>.\\n */\\nclass IntervalTimer {\\n  /**\\n   * @description Constructor for Timer.\\n   * @param interval Sets the interval for running the timer.\\n   * @param callBack The callback function to be executed.\\n   * @return {IntervalTimer} If exists, the existing object.\\n   */\\n  constructor (interval = 10,\\n    callBack = () => {}) {\\n    this.prevInterval = 0\\n    if (this.instance == null) {\\n      this.interval = interval\\n      this.callBack = callBack\\n      this.instance = this\\n    } else {\\n      return this.instance\\n    }\\n  }\\n\\n  /**\\n   * @description Starts the timer.\\n   */\\n  startTimer () {\\n    this.timer = setInterval(this.callBack, this.interval)\\n  }\\n\\n  /**\\n   * @description Resets the timer.\\n   * @return {number} Elapsed time in milliseconds.\\n   */\\n  resetTimer () {\\n    clearInterval(this.timer)\\n    this.callBack = () => {}\\n    return this.getElapsedTime()\\n  }\\n\\n  /**\\n   * @return {number} Elapsed time in milliseconds since reset.\\n   */\\n  getElapsedTime (offset = 0) {\\n    this.timeElapsed = this.timer - this.prevInterval\\n    this.prevInterval = this.timer\\n    return this.timeElapsed - offset\\n  }\\n\\n  /**\\n   * @return {number} Elapsed time since start.\\n   */\\n  getRunTime () {\\n    return this.timer\\n  }\\n}\\n\\n/**\\n * @author Nandan V\\n * Saturday, 01 August 2020 8:33 AM\\n * @description Example usage\\n */\\nconst ExampleIntervalTimer = function (output = v => console.log(v)) {\\n  /**\\n   * Create am object with default settings.\\n   * @type {IntervalTimer} Used to get timing information.\\n   */\\n  const timer = new IntervalTimer()\\n  timer.startTimer()\\n\\n  // ... Initialization code ...\\n  // I generally use it for timing tests in Jasmine JS.\\n\\n  /**\\n   * Gets the runtime till this point.\\n   * Can be subtracted from ElapsedTime to offset timing of initialization code.\\n   */\\n  const initOffset = timer.getRunTime()\\n\\n  // ... A test ...\\n  // The time taken to run the test.\\n  output(timer.getElapsedTime(initOffset))\\n\\n  /**\\n   * Returns the elapsed time and resets the timer to 0.\\n   */\\n  output(timer.resetTimer())\\n}\\n\\nexport { IntervalTimer, ExampleIntervalTimer }\\n\"",
    "breadth first tree traversal": "\"/*\\n  Breadth First Tree Traversal or level order traversal implementation in javascript\\n  Author: @GerardUbuntu\\n*/\\n\\nclass Node {\\n  constructor (data) {\\n    this.data = data\\n    this.left = null\\n    this.right = null\\n  }\\n}\\n\\nclass BinaryTree {\\n  constructor () {\\n    this.root = null\\n    this.traversal = []\\n  }\\n\\n  breadthFirst () {\\n    const h = this.getHeight(this.root)\\n    for (let i = 1; i <= h; i++) {\\n      this.traverseLevel(this.root, i)\\n    }\\n    return this.traversal\\n  }\\n\\n  // Computing the height of the tree\\n  getHeight (node) {\\n    if (node == null) {\\n      return 0\\n    } else {\\n      const lheight = this.getHeight(node.left)\\n      const rheight = this.getHeight(node.right)\\n      return lheight > rheight ? lheight + 1 : rheight + 1\\n    }\\n  }\\n\\n  traverseLevel (node, level) {\\n    if (level === 1 && node !== null) {\\n      this.traversal.push(node.data)\\n    } else {\\n      if (node !== null) {\\n        this.traverseLevel(node.left, level - 1)\\n        this.traverseLevel(node.right, level - 1)\\n      }\\n    }\\n  }\\n}\\n\\nexport { BinaryTree, Node }\\n\"",
    "depth first search": "\"/*\\n * Author: Surendra Kumar\\n * DFS Algorithm implementation in JavaScript\\n * DFS Algorithm for traversing or searching graph data structures.\\n*/\\n\\nfunction traverseDFS (root) {\\n  const stack = [root]\\n  const res = []\\n\\n  while (stack.length) {\\n    const curr = stack.pop()\\n    res.push(curr.key)\\n\\n    if (curr.right) {\\n      stack.push(curr.right)\\n    }\\n\\n    if (curr.left) {\\n      stack.push(curr.left)\\n    }\\n  }\\n\\n  return res.reverse()\\n}\\n\\nfunction searchDFS (tree, value) {\\n  const stack = []\\n\\n  stack.push(tree[0])\\n\\n  while (stack.length !== 0) {\\n    for (let i = 0; i < stack.length; i++) {\\n      const node = stack.pop()\\n\\n      if (node.value === value) {\\n        return node\\n      }\\n      if (node.right) {\\n        stack.push(tree[node.right])\\n      }\\n      if (node.left) {\\n        stack.push(tree[node.left])\\n      }\\n    }\\n  }\\n  return null\\n}\\n\\nconst tree = [\\n  { value: 6, left: 1, right: 2 },\\n  { value: 5, left: 3, right: 4 },\\n  { value: 7, left: null, right: 5 },\\n  { value: 3, left: 6, right: null },\\n  { value: 4, left: null, right: null },\\n  { value: 9, left: 7, right: 8 },\\n  { value: 2, left: 9, right: null },\\n  { value: 8, left: null, right: null },\\n  { value: 10, left: null, right: null },\\n  { value: 1, left: null, right: null }\\n]\\n\\nsearchDFS(tree, 9)\\nsearchDFS(tree, 10)\\n\\ntraverseDFS(6)\\n\\n//            6\\n//           / \\\\\\n//          5   7\\n//         / \\\\   \\\\\\n//        3   4   9\\n//       /       / \\\\\\n//      2       8   10\\n//     /\\n//    1\\n\"",
    "fenwick tree": "\"/*\\n * Author: Mohit Kumar\\n * Fedwick Tree Implementation in JavaScript\\n * Fedwick Tree Implementation for finding prefix sum.\\n*/\\n\\nclass FenwickTree {\\n  constructor (feneickArray, array, n) {\\n    for (let i = 1; i <= n; i++) {\\n      feneickArray[i] = 0\\n    }\\n    for (let i = 0; i < n; i++) {\\n      this.update(feneickArray, n, i, array[i])\\n    }\\n  }\\n\\n  update (feneickArray, n, index, value) {\\n    index = index + 1\\n    while (index <= n) {\\n      feneickArray[index] += value\\n      index += index & (-index)\\n    }\\n  }\\n\\n  getPrefixSum (feneickArray, index) {\\n    let currSum = 0\\n    index = index + 1\\n    while (index > 0) {\\n      currSum += feneickArray[index]\\n      index -= index & (-index)\\n    }\\n\\n    return currSum\\n  }\\n}\\nexport { FenwickTree }\\n\""
  }
}
