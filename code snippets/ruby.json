{
  "ruby": {
    "generate paranthesis": "\"# Given n pairs of parentheses, write a function to generate all combinations\\n# of well-formed parentheses.\\n#\\n# Example 1:\\n#\\n# Input: n = 3\\n# Output: [\\\"((()))\\\",\\\"(()())\\\",\\\"(())()\\\",\\\"()(())\\\",\\\"()()()\\\"]\\n# Example 2:\\n#\\n# Input: n = 1\\n# Output: [\\\"()\\\"]\\n#\\n#\\n# Constraints:\\n#\\n# 1 <= n <= 8\\n\\n# Approach:\\n#\\n# Let's only add '(' or ')' when we know it will remain a valid sequence.\\n# We can do this by keeping track of the number of opening and closing brackets\\n# we have placed so far.\\n#\\n# We can start an opening bracket if we still have one (of n) left to place.\\n# And we could start a closing bracket if it'd not exceed the number of opening\\n# brackets.\\n\\n# Complexity Analysis\\n#\\n# Time Complexity: O(4^n/sqrt(n)). Each valid sequence has at most n steps during the backtracking procedure.\\n# Space Complexity: O(4^n/sqrt(n)), as described above, and using O(n) space to store the sequence.\\n\\n# Refer to the attached diagram for recursion,\\n# The numbers next to each node are the counts of left and right parantheses\\n\\n# @param {Integer} n\\n# @return {String[]}\\ndef generate_parenthesis(n)\\n  parenthesis = []\\n  backtrack(parenthesis, '', 0, 0, n)\\n  parenthesis\\nend\\n\\ndef backtrack(parenthesis, curr, open, close, max)\\n  if curr.length == max * 2\\n    parenthesis.push(curr)\\n    return\\n  end\\n\\n  backtrack(parenthesis, curr + '(', open + 1, close, max) if open < max\\n\\n  backtrack(parenthesis, curr + ')', open, close + 1, max) if close < open\\nend\\n\\nn = 3\\nprint(generate_parenthesis(n))\\n# Output: [\\\"((()))\\\",\\\"(()())\\\",\\\"(())()\\\",\\\"()(())\\\",\\\"()()()\\\"]\\n\\n# *** Example: n = 3 *** Space after each DFS instance\\n# backtrack called with  0 0 []\\n#   backtrack called with ( 1 0 []\\n#     backtrack called with (( 2 0 []\\n#       backtrack called with ((( 3 0 []\\n#         backtrack called with ((() 3 1 []\\n#           backtrack called with ((()) 3 2 []\\n#             backtrack called with ((())) 3 3 []\\n#           backtrack return with ((()) 3 2 [\\\"((()))\\\"]\\n#         backtrack return with ((() 3 1 [\\\"((()))\\\"]\\n#       backtrack return with ((( 3 0 [\\\"((()))\\\"]\\n#       backtrack called with (() 2 1 [\\\"((()))\\\"]\\n#         backtrack called with (()( 3 1 [\\\"((()))\\\"]\\n#           backtrack called with (()() 3 2 [\\\"((()))\\\"]\\n#             backtrack called with (()()) 3 3 [\\\"((()))\\\"]\\n#           backtrack return with (()() 3 2 [\\\"((()))\\\", \\\"(()())\\\"]\\n#         backtrack return with (()( 3 1 [\\\"((()))\\\", \\\"(()())\\\"]\\n#         backtrack called with (()) 2 2 [\\\"((()))\\\", \\\"(()())\\\"]\\n#           backtrack called with (())( 3 2 [\\\"((()))\\\", \\\"(()())\\\"]\\n#             backtrack called with (())() 3 3 [\\\"((()))\\\", \\\"(()())\\\"]\\n#           backtrack return with (())( 3 2 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\"]\\n#         backtrack return with (()) 2 2 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\"]\\n#       backtrack return with (() 2 1 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\"]\\n#     backtrack return with (( 2 0 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\"]\\n#     backtrack called with () 1 1 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\"]\\n#       backtrack called with ()( 2 1 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\"]\\n#         backtrack called with ()(( 3 1 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\"]\\n#           backtrack called with ()(() 3 2 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\"]\\n#             backtrack called with ()(()) 3 3 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\"]\\n#           backtrack return with ()(() 3 2 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\"]\\n#         backtrack return with ()(( 3 1 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\"]\\n#         backtrack called with ()() 2 2 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\"]\\n#           backtrack called with ()()( 3 2 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\"]\\n#             backtrack called with ()()() 3 3 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\"]\\n#           backtrack return with ()()( 3 2 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\", \\\"()()()\\\"]\\n#         backtrack return with ()() 2 2 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\", \\\"()()()\\\"]\\n#       backtrack return with ()( 2 1 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\", \\\"()()()\\\"]\\n#     backtrack return with () 1 1 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\", \\\"()()()\\\"]\\n#   backtrack return with ( 1 0 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\", \\\"()()()\\\"]\\n# backtrack return with  0 0 [\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\", \\\"()()()\\\"]\\n\\nn = 1\\nprint(generate_parenthesis(n))\\n# Output: [\\\"()\\\"]\\n\"",
    "binary and operator": "\"def binary_and(x, y)\\n  raise 'Input must only contain positive integers' if (x < 0) || (y < 0)\\n\\n  '0b' + (x & y).to_s(2)\\nend\\n\\nbegin\\n  binary_and(-1, 0)\\nrescue StandardError => e\\n  puts e.message\\nend\\n# Input must only contain positive integers\\n\\nputs binary_and(1, 1)\\n# 0b1\\nputs binary_and(0, 1)\\n# 0b0\\nputs binary_and(1024, 1024)\\n# 0b10000000000\\nputs binary_and(0, 1023)\\n# 0b0000000000\\nputs binary_and(16, 58)\\n# 0b010000\\n\"",
    "binary count setbits": "\"def binary_count_setbits(x)\\n  raise 'Input must be a positive integer' if x < 0\\n\\n  binary = x.to_s(2)\\n\\n  binary.chars.map { |c| c.to_i }.reduce(:+)\\nend\\n\\nbegin\\n  binary_count_setbits(-1)\\nrescue StandardError => e\\n  puts e.message\\nend\\n# Input must be a positive integer\\n\\nputs binary_count_setbits(0)\\n# 0\\n\\nputs binary_count_setbits(1)\\n# 1\\n\\nputs binary_count_setbits(1024)\\n# 1\\n\\nputs binary_count_setbits(1023)\\n# 10\\n\"",
    "binary count trailing zeroes": "\"def binary_count_trailing_zeroes(x)\\n  raise 'Input must be a positive integer' if x < 0\\n\\n  binary = x.to_s(2)\\n\\n  count = 0\\n  binary.chars.reverse_each do |char|\\n    break if char == '1'\\n\\n    count += 1\\n  end\\n\\n  count\\nend\\n\\nbegin\\n  binary_count_trailing_zeroes(-1)\\nrescue StandardError => e\\n  puts e.message\\nend\\n# Input must be a positive integer\\n\\nputs binary_count_trailing_zeroes(0)\\n# 1\\n\\nputs binary_count_trailing_zeroes(1023)\\n# 0\\n\\nputs binary_count_trailing_zeroes(1024)\\n# 10\\n\\nputs binary_count_trailing_zeroes(54)\\n# 1\\n\\nputs binary_count_trailing_zeroes(121_024)\\n# 6\\n\"",
    "binary or operator": "\"def binary_or(x, y)\\n  raise 'Input must only contain positive integers' if (x < 0) || (y < 0)\\n\\n  '0b' + (x | y).to_s(2)\\nend\\n\\nbegin\\n  binary_or(-1, 0)\\nrescue StandardError => e\\n  puts e.message\\nend\\n# Input must only contain positive integers\\n\\nputs binary_or(1, 1)\\n# 0b1\\nputs binary_or(0, 1)\\n# 0b1\\nputs binary_or(1024, 1024)\\n# 0b10000000000\\nputs binary_or(0, 1023)\\n# 0b1111111111\\nputs binary_or(16, 58)\\n# 0b110010\\n\"",
    "binary xor operator": "\"def binary_xor(x, y)\\n  raise 'Input must only contain positive integers' if (x < 0) || (y < 0)\\n\\n  binary_x = x.to_s(2)\\n  binary_y = y.to_s(2)\\n\\n  if binary_x.length > binary_y.length\\n    prefix = '0' * (binary_x.length - binary_y.length)\\n    binary_y = prefix + binary_y\\n  elsif binary_y.length > binary_x.length\\n    prefix = '0' * (binary_y.length - binary_x.length)\\n    binary_x = prefix + binary_x\\n  end\\n  result = '0b'\\n  binary_x.each_char.with_index do |x_char, i|\\n    y_char = binary_y[i]\\n\\n    result += if (x_char == '1' && y_char != '1') || (x_char != '1' && y_char == '1')\\n                '1'\\n              else\\n                '0'\\n              end\\n  end\\n\\n  result\\nend\\n\\nbegin\\n  binary_xor(-1, 0)\\nrescue StandardError => e\\n  puts e.message\\nend\\n# Input must only contain positive integers\\n\\nputs binary_xor(1, 1)\\n# 0b0\\nputs binary_xor(0, 1)\\n# 0b1\\nputs binary_xor(1024, 1024)\\n# 0b00000000000\\nputs binary_xor(0, 1023)\\n# 0b1111111111\\nputs binary_xor(16, 58)\\n# 0b101010\\n\"",
    "power of two": "\"# Power of 2\\n#\\n# Given an integer n, return true if it is a power of two. Otherwise, return false.\\n#\\n# An integer n is a power of two, if there exists an integer x such that n == 2^x.\\n#\\n# Example 1:\\n# Input: n = 1\\n# Output: true\\n# Explanation: 2^0 = 1\\n#\\n# Example 2:\\n# Input: n = 16\\n# Output: true\\n# Explanation: 2^4 = 16\\n#\\n# Example 3:\\n# Input: n = 3\\n# Output: false\\n#\\n# Example 4:\\n# Input: n = 4\\n# Output: true\\n#\\n# Example 5:\\n# Input: n = 5\\n# Output: false\\n#\\n# Constraints: -231 <= n <= 231 - 1\\n# @param {Integer} n\\n# @return {Boolean}\\n#\\n\\n# Approach 1: Recursion\\n#\\n# Time Complexity: O(logn)\\n#\\ndef is_power_of_two(n)\\n  if n == 1\\n    true\\n  elsif n.even?\\n    is_power_of_two(n / 2)\\n  else\\n    false\\n  end\\nend\\n\\nn = 1\\n# Output: true\\nputs is_power_of_two(n)\\nn = 16\\n# Output: true\\nputs is_power_of_two(n)\\nn = 3\\n# Output: false\\nputs is_power_of_two(n)\\nn = 4\\n# Output: true\\nputs is_power_of_two(n)\\nn = 5\\n# Output: false\\nputs is_power_of_two(n)\\n\\n#\\n# Approach 2: Without recursion\\n#\\n# Time Complexity: O(n)\\n#\\ndef is_power_of_two(n)\\n  n /= 2 while n.even? && n != 0\\n  n == 1\\nend\\n\\nn = 1\\n# Output: true\\nputs is_power_of_two(n)\\nn = 16\\n# Output: true\\nputs is_power_of_two(n)\\nn = 3\\n# Output: false\\nputs is_power_of_two(n)\\nn = 4\\n# Output: true\\nputs is_power_of_two(n)\\nn = 5\\n# Output: false\\nputs is_power_of_two(n)\\n\\n#\\n# Approach 3: Using Math library\\n#\\n# Time Complexity: O(1)\\n#\\ndef is_power_of_two(n)\\n  result_exponent = Math.log(n) / Math.log(2)\\n  result_exponent % 1 == 0\\nend\\n\\nn = 1\\n# Output: true\\nputs is_power_of_two(n)\\nn = 16\\n# Output: true\\nputs is_power_of_two(n)\\nn = 3\\n# Output: false\\nputs is_power_of_two(n)\\nn = 4\\n# Output: true\\nputs is_power_of_two(n)\\nn = 5\\n# Output: false\\nputs is_power_of_two(n)\\n\"",
    "single bit binary operations": "\"def set_bit(x, position)\\n  raise 'position must be >= 0' if position < 0\\n\\n  x | (1 << position)\\nend\\n\\nputs set_bit(0, 0)\\n# 1\\n\\nputs set_bit(0, 4)\\n# 16\\n\\nputs set_bit(8, 3)\\n# 8\\n\\nputs set_bit(8, 4)\\n# 24\\n\\nbegin\\n  puts set_bit(8, -4)\\nrescue StandardError => e\\n  puts e.message\\nend\\n# position must be >= 0\\n\\ndef clear_bit(x, position)\\n  raise 'position must be > 0' if position < 0\\n\\n  x & ~(1 << position)\\nend\\n\\nputs clear_bit(0, 0)\\n# 0\\n\\nputs clear_bit(0, 4)\\n# 0\\n\\nputs clear_bit(8, 3)\\n# 0\\n\\nputs clear_bit(24, 4)\\n# 8\\n\\nbegin\\n  puts clear_bit(0, -4)\\nrescue StandardError => e\\n  puts e.message\\nend\\n# position must be > 0\\n\\ndef flip_bit(x, position)\\n  raise 'position must be > 0' if position < 0\\n\\n  x ^ (1 << position)\\nend\\n\\nputs flip_bit(0, 0)\\n# 1\\n\\nputs flip_bit(0, 4)\\n# 16\\n\\nputs flip_bit(8, 3)\\n# 0\\n\\nputs flip_bit(24, 4)\\n# 8\\n\\nbegin\\n  puts flip_bit(0, -4)\\nrescue StandardError => e\\n  puts e.message\\nend\\n# position must be > 0\\n\\ndef is_bit_set(x, position)\\n  raise 'position must be > 0' if position < 0\\n\\n  ((x >> position) & 1) == 1\\nend\\n\\nputs is_bit_set(0, 0)\\n# false\\n\\nputs is_bit_set(1, 0)\\n# true\\n\\nputs is_bit_set(8, 3)\\n# true\\n\\nputs is_bit_set(24, 4)\\n# true\\n\\nbegin\\n  puts is_bit_set(0, -4)\\nrescue StandardError => e\\n  puts e.message\\nend\\n# position must be > 0\\n\"",
    "caesar": "\"# Caesar Cipher replaces characters rotating X number of positions to the left or to the right.\\n#\\n# Alphabet\\n# a b c d e f g h i j k l m n o p q r s t u v w x y z\\n#\\n# shift 4 >> it means to rotate 4 places\\n#\\n# After shifting\\n# e f g h i j k l m n o p q r s t u v w x y z a b c d\\n#\\n# plaintext -> apple\\n# ciphertext -> ettpi\\n\\nclass CaesarCipher\\n  ALPHABET = ('a'..'z').to_a\\n\\n  def self.encrypt(plaintext, shift)\\n    plaintext.chars.map do |letter|\\n      temp = letter.ord + shift\\n      temp -= ALPHABET.length while temp > 'z'.ord\\n      temp.chr\\n    end.join\\n  end\\n\\n  def self.decrypt(ciphertext, shift)\\n    ciphertext.chars.map do |letter|\\n      temp = letter.ord - shift\\n      temp += ALPHABET.length while temp < 'a'.ord\\n      temp.chr\\n    end.join\\n  end\\nend\\n\"",
    "caesar test": "\"require 'minitest/autorun'\\nrequire_relative 'caesar'\\n\\nclass CaesarCipherTest < Minitest::Test\\n  def test_shift4\\n    run_tests('apple', 'ettpi', 4)\\n  end\\n\\n  def test_shift27\\n    run_tests('amateur', 'bnbufvs', 27)\\n  end\\n\\n  private\\n\\n  def run_tests(plaintext, expected_cipher, shift)\\n    encrypted = CaesarCipher.encrypt(plaintext, shift)\\n    assert_equal encrypted, expected_cipher\\n    decrypted = CaesarCipher.decrypt(encrypted, shift)\\n    assert_equal decrypted, plaintext\\n  end\\nend\\n\"",
    "merkle hellman cryptosystem": "\"require 'openssl'\\n\\nclass MerkleHellman\\n  SMALLEST_KNAPSACK_ITEM = 2**32\\n  STEP = 2**32\\n\\n  def initialize(size)\\n    @size = size\\n    sum = SMALLEST_KNAPSACK_ITEM\\n    @easy_knapsack = size.times.map do |_k|\\n      x = sum + rand(STEP)\\n      sum += x\\n      x\\n    end\\n    @n = sum + rand(STEP)\\n\\n    loop do\\n      @a = rand(0..@n)\\n      break if @a.gcd(@n) == 1\\n    end\\n\\n    @hard_knapsack = @easy_knapsack.map do |x|\\n      (@a * x) % @n\\n    end\\n  end\\n\\n  def encrypt(msg)\\n    raise ArgumentError, \\\"max length is #{@size / 8} characters\\\" if msg.length * 8 > @size\\n\\n    c = 0\\n    msg.each_codepoint.reverse_each.with_index do |ch, i|\\n      7.downto(0) do |j|\\n        wj = ch.>>(j).& 1\\n        c += wj * @hard_knapsack[i * 8 + 7 - j]\\n      end\\n    end\\n    c\\n  end\\n\\n  def decrypt(c)\\n    p = @a.to_bn.mod_inverse(@n).mod_mul(c, @n).to_i\\n    byte = 0\\n    msg = []\\n    @easy_knapsack.reverse_each.with_index do |x, i|\\n      bit = 0\\n      if p >= x\\n        p -= x\\n        bit = 1\\n      end\\n      byte |= (bit << (i % 8))\\n      if i % 8 == 7\\n        msg << byte.chr\\n        byte = 0\\n      end\\n    end\\n    msg.join\\n  end\\n  attr_accessor :hard_knapsack\\nend\\n\\nstr = 'Hello there, this is my plaintext'\\nmh = MerkleHellman.new(str.length * 8)\\nputs \\\"[*] Encrypting \\\\\\\"#{str}\\\\\\\"\\\"\\n\\nc = mh.encrypt(str)\\n\\nputs \\\"[*] Ciphertext : #{c}\\\"\\n\\ndecrypted = mh.decrypt(c)\\n\\nputs \\\"[*] after decryption : \\\\\\\"#{decrypted}\\\\\\\"\\\"\\n\"",
    "rsa": "\"require 'prime'\\n\\ndef initialize(keys = {})\\n  @e ||= keys[:e]\\n  @n ||= keys[:n]\\nend\\n\\ndef cipher(message)\\n  message.bytes.map do |byte|\\n    cbyte = ((byte.to_i**e) % n).to_s\\n    missing_chars = n.to_s.size - cbyte.size\\n    '0' * missing_chars + cbyte\\n  end.join\\nend\\n\\ndef decipher(ciphed_message)\\n  ciphed_message.chars.each_slice(n.to_s.size).map do |arr|\\n    (arr.join.to_i**d) % n\\n  end.pack('c*')\\nend\\n\\ndef public_keys\\n  { n: n, e: e }\\nend\\n\\nprivate\\n\\ndef p\\n  @p ||= random_prime_number\\nend\\n\\ndef q\\n  @q ||= random_prime_number\\nend\\n\\ndef n\\n  @n ||= p * q\\nend\\n\\ndef totient\\n  @totient ||= (p - 1) * (q - 1)\\nend\\n\\ndef e\\n  @e ||= totient.downto(2).find do |i|\\n    Prime.prime?(i) && totient % i != 0\\n  end\\nend\\n\\ndef d\\n  @d ||= invmod(e, totient)\\nend\\n\\ndef extended_gcd(a, b)\\n  last_remainder = a.abs\\n  remainder = b.abs\\n  x = 0\\n  last_x = 1\\n  y = 1\\n  last_y = 0\\n  while remainder != 0\\n    (quotient, remainder) = last_remainder.divmod(remainder)\\n    last_remainder = remainder\\n    x, last_x = last_x - quotient * x, x\\n    y, last_y = last_y - quotient * y, y\\n  end\\n\\n  [last_remainder, last_x * (a < 0 ? -1 : 1)]\\nend\\n\\ndef invmod(e, et)\\n  g, x = extended_gcd(e, et)\\n  raise 'The maths are broken!' if g != 1\\n\\n  x % et\\nend\\n\\ndef random_prime_number\\n  number = Random.rand(1..1000)\\n  number = Random.rand(1..1000) until Prime.prime?(number) || number == p || number == q\\n  number\\nend\\n\\ndef main\\n  puts 'Enter the message you want to encrypt and decrypt with RSA algorithm: '\\n  message = gets.chomp.to_s\\n  puts 'Encoded Text:'\\n  puts cipher(message)\\n  puts 'Decoded Text:'\\n  puts decipher(cipher(message))\\n  puts \\\"p: #{p}\\\"\\n  puts \\\"q: #{q}\\\"\\n  puts \\\"e: #{e}\\\"\\n  puts \\\"d: #{d}\\\"\\n  puts \\\"totient: #{totient}\\\"\\nend\\n\\nmain\\n\"",
    "temperature conversions": "\"# A ruby program for temperature conversions\\n\\nmodule TemperatureConversion\\n  # celsius -> kelvin = value of celsius + 273.15 => K\\n  def self.celsius_to_kelvin(celsius_input)\\n    kelvin_output = (celsius_input + 273.15).round(2)\\n    puts \\\"#{celsius_input}°C = #{kelvin_output}K\\\"\\n  rescue StandardError\\n    puts 'Error: Please provide number only!'\\n  end\\n\\n  # kelvin -> celsius = vale of kelvin - 273.15 => °C\\n  def self.kelvin_to_celsius(kelvin_input)\\n    celsius_output = (kelvin_input - 273.15).round(2)\\n    puts \\\"#{kelvin_input}K = #{celsius_output}°C\\\"\\n  rescue StandardError\\n    puts 'Error: Please provide number only!'\\n  end\\n\\n  # celsius -> fahrenheit = (value of celsius * 9 / 5) + 32 => °F\\n  def self.celsius_to_fahrenheit(celsius_input)\\n    fahrenheit_output = ((celsius_input * 9 / 5) + 32).round(2)\\n    puts \\\"#{celsius_input}°C = #{fahrenheit_output}°F\\\"\\n  rescue StandardError\\n    puts 'Error: Please provide number only!'\\n  end\\n\\n  # fahrenheit -> celsius = (value of fahrenheit - 32) * 5 / 9 => °C\\n  def self.fahrenheit_to_celsius(fahrenheit_input)\\n    celsius_output = ((fahrenheit_input - 32) * 5 / 9).round(2)\\n    puts \\\"#{fahrenheit_input}°F = #{celsius_output}°C\\\"\\n  rescue StandardError\\n    puts 'Error: Please provide number only!'\\n  end\\n\\n  # fahrenheit -> kelvin = [(value of fahrenheit - 32) * 5 / 9] + 273.15 => K\\n  def self.fahrenheit_to_kelvin(fahrenheit_input)\\n    kelvin_output = ((fahrenheit_input - 32) * 5 / 9).round(2).round(2)\\n    puts \\\"#{fahrenheit_input}°F = #{kelvin_output}K\\\"\\n  rescue StandardError\\n    puts 'Error: Please provide number only!'\\n  end\\n\\n  # kelvin -> fahrenheit = [(value of kelvin - 32) * 5 / 9] + 273.15 => K\\n  def self.kelvin_to_fahrenheit(kelvin_input)\\n    fahrenheit_output = (((kelvin_input - 273.15) * 9 / 5) + 32).round(2).round(2)\\n    puts \\\"#{kelvin_input}K = #{fahrenheit_output}°F\\\"\\n  rescue StandardError\\n    puts 'Error: Please provide number only!'\\n  end\\nend\\n\\n# celsius <-> kelvin\\nTemperatureConversion.celsius_to_kelvin(20)\\nTemperatureConversion.kelvin_to_celsius(20)\\n\\n# Invalid input\\nTemperatureConversion.kelvin_to_celsius('a')\\n\\n# celsius <-> fahrenheit\\nTemperatureConversion.celsius_to_fahrenheit(-20)\\nTemperatureConversion.fahrenheit_to_celsius(68)\\n\\n# Invalid input\\nTemperatureConversion.celsius_to_fahrenheit('abc')\\n\\n# fahrenheit <-> kelvin\\nTemperatureConversion.fahrenheit_to_kelvin(60)\\nTemperatureConversion.kelvin_to_fahrenheit(-60)\\n\\n# Invalid input\\nTemperatureConversion.fahrenheit_to_kelvin('60')\\n\"",
    "weight conversions": "\"# A ruby program for weight conversions\\n\\nmodule WeightConversion\\n  # Kilogram -> Gram = (kilogram_value * 1000) grams\\n  def self.kilogram_to_gram(kilogram_input)\\n    raise StandardError unless kilogram_input.is_a?(Integer)\\n\\n    gram = kilogram_input * 1000\\n\\n    \\\"#{kilogram_input} kg = #{gram} g\\\"\\n  end\\n\\n  # Gram -> Kilogram = (gram_value / 1000) kilograms\\n  def self.gram_to_kilogram(gram_input)\\n    kilogram = gram_input / 1000\\n\\n    \\\"#{gram_input} g = #{kilogram} kg\\\"\\n  end\\n\\n  # Pound -> Ounce = (pound_value * 16) oz\\n  def self.pound_to_ounce(pound_input)\\n    ounce = pound_input * 16\\n\\n    \\\"#{pound_input} lb = #{ounce} oz\\\"\\n  end\\n\\n  # Ounce -> Pound = (ounce_value / 16) lb\\n  def self.ounce_to_pound(ounce_input)\\n    pound = ounce_input / 16\\n\\n    \\\"#{ounce_input} oz = #{pound} lb\\\"\\n  end\\n\\n  # Kilogram -> Pound = (kilogram_input * 2.205) lb\\n  def self.kilogram_to_pound(kilogram_input)\\n    pound = (kilogram_input * 2.205).round(2)\\n\\n    \\\"#{kilogram_input} kg = #{pound} lb\\\"\\n  end\\n\\n  # Pound -> Kilogram = (pound_input / 2.205) kg\\n  def self.pound_to_kilogram(pound_input)\\n    raise StandardError unless pound_input.is_a?(Integer)\\n\\n    kilogram = (pound_input / 2.205).round(2)\\n\\n    \\\"#{pound_input} lb = #{kilogram} kg\\\"\\n  end\\nend\\n\\n#\\n# Valid inputs\\n#\\n\\nputs WeightConversion.kilogram_to_gram(2)\\n# 2 kg = 2000 g\\nputs WeightConversion.gram_to_kilogram(3000)\\n# 3000 g = 3 kg\\nputs WeightConversion.pound_to_ounce(16)\\n# 16 lb = 256 oz\\nputs WeightConversion.ounce_to_pound(16)\\n# 16 oz = 1 lb\\nputs WeightConversion.kilogram_to_pound(1)\\n# 1 kg = 2.21 lb\\nputs WeightConversion.pound_to_kilogram(100)\\n# 100 lb = 45.35 kg\\n\\n#\\n# Invalid inputs\\n#\\n\\nbegin\\n  puts WeightConversion.kilogram_to_gram('a')\\nrescue StandardError\\n  puts 'Error: Please provide number only!'\\nend\\n\\nbegin\\n  puts WeightConversion.kilogram_to_gram('3000')\\nrescue StandardError\\n  puts 'Error: Please provide number only!'\\nend\\n\\nbegin\\n  puts WeightConversion.kilogram_to_gram('16')\\nrescue StandardError\\n  puts 'Error: Please provide number only!'\\nend\\n\\nbegin\\n  puts WeightConversion.kilogram_to_gram('x ')\\nrescue StandardError\\n  puts 'Error: Please provide number only!'\\nend\\n\\nbegin\\n  puts WeightConversion.kilogram_to_gram('weight')\\nrescue StandardError\\n  puts 'Error: Please provide number only!'\\nend\\n\\nbegin\\n  puts WeightConversion.kilogram_to_gram('100')\\nrescue StandardError\\n  puts 'Error: Please provide number only!'\\nend\\n\"",
    "euclidean gcd": "\"# https://en.wikipedia.org/wiki/Euclidean_algorithm\\n\\ndef euclidean_gcd(a, b)\\n  while b != 0\\n    t = b\\n    b = a % b\\n    a = t\\n  end\\n  a\\nend\\n\\nputs 'GCD(3, 5) = ' + euclidean_gcd(3, 5).to_s\\nputs 'GCD(3, 6) = ' + euclidean_gcd(3, 6).to_s\\nputs 'GCD(6, 3) = ' + euclidean_gcd(6, 3).to_s\\n\"",
    "exteded euclidean algorithm": "\"# https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\\n\\ndef extended_euclidean_gcd(a, b)\\n  x0 = a\\n  x1 = b\\n  s = 1\\n  t = 0\\n  until x1.zero?\\n    q, x2 = x0.divmod(x1)\\n    x0 = x1\\n    x1 = x2\\n    s, t = t, s - q * t\\n  end\\n  x0\\nend\\n\\nputs 'GCD(3, 5) = ' + extended_euclidean_gcd(3, 5).to_s\\n# GCD(3, 5) = 1\\nputs 'GCD(3, 6) = ' + extended_euclidean_gcd(3, 6).to_s\\n# GCD(3, 6) = 3\\nputs 'GCD(6, 3) = ' + extended_euclidean_gcd(6, 3).to_s\\n# GCD(6, 3) = 3\\n\\n#\\n# Dynamic driver code:\\n#\\n# a = gets.to_i\\n# b = gets.to_i\\n# puts \\\"GCD (#{a}, #{b} ) = #{extended_euclidean_gcd(a, b)}\\\"\\n#\\n\"",
    "lcm": "\"# LCM (Least Common Multiple) of two numbers is the smallest number which can be divided by both numbers.\\n\\np 'Least Common Multiple'\\n\\np 'Enter first number'\\nvalue_one = gets.chomp.to_i\\n\\np 'Enter second number'\\nvalue_two = gets.chomp.to_i\\n\\ndef gcd(first, second)\\n  if second != 0\\n    gcd(second, first % second)\\n  else\\n    first\\n  end\\nend\\n\\ndef lcm(first, second)\\n  (first * second) / gcd(first, second)\\nend\\n\\np \\\"Least Common Multiple is: #{lcm(value_one, value_two)}\\\"\\n\"",
    "climbing stairs": "\"# You are climbing a staircase. It takes n steps to reach the top.\\n# Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\\n\\n# Example 1:\\n# Input: n = 2\\n# Output: 2\\n# Explanation: There are two ways to climb to the top.\\n# 1. 1 step + 1 step\\n# 2. 2 steps\\n\\n# Example 2:\\n# Input: n = 3\\n# Output: 3\\n# Explanation: There are three ways to climb to the top.\\n# 1. 1 step + 1 step + 1 step\\n# 2. 1 step + 2 steps\\n# 3. 2 steps + 1 step\\n\\n# Constraints:\\n# 1 <= n <= 45\\n\\n# Dynamic Programming, Recursive Bottom Up Approach - O(n) Time / O(n) Space\\n# Init memoization hash (only 1 parameter)\\n# Set base cases which are memo[0] = 1 and memo[1] = 1, since there are only 1 way to get to each stair\\n# Iterate from 2..n and call recurse(n, memo) for each value n.\\n# Return memo[n].\\n\\n# recurse(n, memo) - Recurrence Relation is n = (n - 1) + (n - 2)\\n# return memo[n] if memo[n] exists.\\n# otherwise, memo[n] = recurse(n - 1, memo) + recurse(n - 2, memo)\\n\\n# @param {Integer} n\\n# @return {Integer}\\ndef climb_stairs(n)\\n  memo = {}\\n\\n  memo[0] = 1\\n  memo[1] = 1\\n\\n  return memo[n] if [0, 1].include?(n)\\n\\n  (2..n).each do |n|\\n    recurse(n, memo)\\n  end\\n\\n  memo[n]\\nend\\n\\ndef recurse(n, memo)\\n  return memo[n] if memo[n]\\n\\n  memo[n] = recurse(n - 1, memo) + recurse(n - 2, memo)\\nend\\n\\nputs climb_stairs(2)\\n# => 2\\n\\nputs climb_stairs(4)\\n# => 5\\n\\nputs climb_stairs(10)\\n# => 89\\n\\nputs climb_stairs(45)\\n# => 1836311903\\n\"",
    "coin change": "\"def coin_change_minimum(coins, amount)\\n  dp = Array.new(amount + 1, -1)\\n  dp[0] = 0\\n\\n  coins.each do |coin|\\n    (coin..amount).each do |i|\\n      if dp[i - coin] != -1\\n        dp[i] = -1 == dp[i] ? dp[i - coin] + 1 : [dp[i], dp[i - coin] + 1].min\\n      end\\n    end\\n  end\\n\\n  dp[amount]\\nend\\n\\ndef coin_change_combinations(coins, amount)\\n  dp = Array.new(coins.length + 1) { Array.new(amount + 1, 0) }\\n  dp[0][0] = 1\\n  (1..coins.length).each do |i|\\n    (0..amount).each do |j|\\n      dp[i][j] = dp[i - 1][j] + (j < coins[i - 1] ? 0 : dp[i][j - coins[i - 1]])\\n    end\\n  end\\n  dp[coins.length][amount]\\nend\\n\\ncoins = Array[2, 4, 5]\\namount = 12\\nputs 'Number of combinations of getting change for ' + amount.to_s + ' is ' + coin_change_combinations(coins,\\n                                                                                                       amount).to_s + '.'\\nputs 'Minimum number of coins required for ' + amount.to_s + ' is ' + coin_change_minimum(coins, amount).to_s + '.'\\n\"",
    "count sorted vowel strings": "\"# Challenge name: Count Sorted Vowel Strings\\n#\\n# Given an integer n, return the number of strings of length n that consist only\\n# of vowels (a, e, i, o, u) and are lexicographically sorted.\\n#\\n# A string s is lexicographically sorted if for all valid i, s[i] is the same as\\n# or comes before s[i+1] in the alphabet.\\n#\\n#\\n# Example 1:\\n#\\n# Input: n = 1\\n# Output: 5\\n# Explanation: The 5 sorted strings that consist of vowels only are [\\\"a\\\",\\\"e\\\",\\\"i\\\",\\\"o\\\",\\\"u\\\"].\\n#\\n# Example 2:\\n#\\n# Input: n = 2\\n# Output: 15\\n# Explanation: The 15 sorted strings that consist of vowels only are\\n# [\\\"aa\\\",\\\"ae\\\",\\\"ai\\\",\\\"ao\\\",\\\"au\\\",\\\"ee\\\",\\\"ei\\\",\\\"eo\\\",\\\"eu\\\",\\\"ii\\\",\\\"io\\\",\\\"iu\\\",\\\"oo\\\",\\\"ou\\\",\\\"uu\\\"].\\n# Note that \\\"ea\\\" is not a valid string since 'e' comes after 'a' in the alphabet.\\n#\\n# Example 3:\\n#\\n# Input: n = 33\\n# Output: 66045\\n\\n#\\n# Approach: Math\\n#\\n\\n#\\n# Intuition and Algorithm\\n#\\n# The problem is a variant of finding Combinations.\\n# Mathematically, the problem can be described as,\\n# given 5 vowels (let k = 5), we want to find the\\n# number of combinations using only n vowels. Also,\\n# we can repeat each of those vowels multiple times.\\n#\\n\\n# Complexity Analysis\\n#\\n# Time Complexity: O(1), as the approach runs in constant time.\\n# Space Complexity: O(1), as the approach uses constant extra space.\\n\\n# @param {Integer} n\\n# @return {Integer}\\ndef count_vowel_strings(n)\\n  (n + 4) * (n + 3) * (n + 2) * (n + 1) / 24\\nend\\n\\nn = 33\\nputs count_vowel_strings(n)\\n# Output: 66045\\n\\nn = 2\\nputs count_vowel_strings(n)\\n# Output: 15\\n\\nn = 1\\nputs count_vowel_strings(n)\\n# Output: 5\\n\"",
    "editdistance": "\"require \\\"test/unit\\\"\\r\\n\\r\\ndef editDistDP(str1, str2, m, n) \\r\\n    rows, cols = m+1,n+1  \\r\\n\\r\\n    # Create a 2D array to store results of subproblems\\r\\n    dp = Array.new(rows) { Array.new(cols) }\\r\\n\\r\\n    #using bottom up approach\\r\\n    for i in (0..m + 1-1) do\\r\\n        for j in (0..n + 1-1) do\\r\\n\\r\\n            #If the first string is empty, insert all the characters of the second string\\r\\n            if i == 0 \\r\\n                dp[i][j] = j   \\r\\n        \\r\\n            #If the second string is empty, insert all the characters of the first string\\r\\n            elsif j == 0 \\r\\n                dp[i][j]  = i \\r\\n            \\r\\n            #If the last character in both the strings are same, we can ignore the character and move to the next character in both the strings\\r\\n            elsif str1[i-1] == str2[j-1] \\r\\n                dp[i][j] =  dp[i-1][j-1] \\r\\n            \\r\\n            #If the last character of both the strings are different, find out the minimum value of the three operations(insert, delete, replace)\\r\\n            else\\r\\n                dp[i][j] = 1 +[dp[i][j-1],dp[i-1][j],dp[i-1][j-1]].min()\\r\\n                \\r\\n            end\\r\\n        \\r\\n        end\\r\\n        \\r\\n    end\\r\\n    \\r\\n    return dp[m][n]\\r\\nend\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass Editdistancetest < Test::Unit::TestCase\\r\\n    \\r\\n    #Test1\\r\\n    #Replace 'n' with 'r'\\r\\n    #insert 'a'\\r\\n    #insert 't'\\r\\n    #No of total operations : 3\\r\\n    def test_distance1\\r\\n      assert_equal 3, editDistDP( \\\"sunday\\\",\\\"saturday\\\",6,8), \\\"Should return 3\\\" \\r\\n    end\\r\\n  \\r\\n    #Test2\\r\\n    #Replace 'a' with 'u'\\r\\n    #No of total operations : 1\\r\\n    def test_distance2\\r\\n      assert_equal 1, editDistDP(\\\"cat\\\",\\\"cut\\\",3,3), \\\"editDistDpShould return 1\\\"\\r\\n    end\\r\\n\\r\\n    #Test3\\r\\n    #Insert 'a','p', 'p','l','e','p','i','e' into string 1\\r\\n    #No of total operations : 8\\r\\n    def test_distance3\\r\\n       assert_equal 8, editDistDP(\\\"\\\",\\\"applepie\\\",0,8), \\\"editDistDpShould return 1\\\"\\r\\n    end\\r\\n\\r\\n    #Test4\\r\\n    #Both the strings are equal, thus no operation needed\\r\\n    #No of total operations : 0\\r\\n    def test_distance4\\r\\n       assert_equal 0, editDistDP(\\\"Hello\\\",\\\"Hello\\\",5,5), \\\"editDistDpShould return 1\\\" \\r\\n    end\\r\\n\\r\\n  end\\r\\n    \\r\\n\"",
    "fibonacci": "\"# The Fibonacci numbers, commonly denoted F(n) form a sequence,\\n# called the Fibonacci sequence, such that each number is the sum\\n# of the two preceding ones, starting from 0 and 1. That is,\\n#\\n# F(0) = 0, F(1) = 1\\n# F(n) = F(n - 1) + F(n - 2), for n > 1.\\n#\\n# Given n, calculate F(n).\\n\\n#\\n# Approach: Math\\n#\\n\\n# Intuition: Using the golden ratio, a.k.a Binet's formula\\n\\n# Algorithm: Use the golden ratio formula to calculate the Nth Fibonacci number.\\n# https://demonstrations.wolfram.com/GeneralizedFibonacciSequenceAndTheGoldenRatio/\\n\\n# Complexity Analysis\\n\\n# Time complexity: O(1). Constant time complexity since we are using no loops or recursion\\n# and the time is based on the result of performing the calculation using Binet's formula.\\n#\\n# Space complexity: O(1). The space used is the space needed to create the variable\\n# to store the golden ratio formula.\\n\\ndef fibonacci(n)\\n  golden_ratio = (1 + 5**0.5) / 2\\n  ((golden_ratio**n + 1) / 5**0.5).to_i\\nend\\n\\nn = 2\\nputs(fibonacci(n))\\n# Output: 1\\n# Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\\n\\nn = 3\\nputs(fibonacci(n))\\n# Output: 2\\n# Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\\n\\nn = 4\\nputs(fibonacci(n))\\n# Output: 3\\n# Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\\n\"",
    "house robber": "\"# You are a professional robber planning to rob houses along a street.\\n# Each house has a certain amount of money stashed, the only constraint stopping you\\n# from robbing each of them is that adjacent houses have security systems connected\\n# and it will automatically contact the police if two adjacent houses\\n# were broken into on the same night.\\n#\\n# Given an integer array nums representing the amount of money of each house,\\n# return the maximum amount of money you can rob tonight without alerting the police.\\n#\\n# Example 1:\\n#\\n# Input: nums = [1,2,3,1]\\n# Output: 4\\n# Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\\n# Total amount you can rob = 1 + 3 = 4.\\n#\\n# Example 2:\\n#\\n# Input: nums = [2,7,9,3,1]\\n# Output: 12\\n# Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\n# Total amount you can rob = 2 + 9 + 1 = 12.\\n\\n#\\n# Approach 1: Dynamic Programming\\n#\\n\\n# Complexity Analysis\\n#\\n# Time Complexity: O(N) since we process at most N recursive calls, thanks to\\n# caching, and during each of these calls, we make an O(1) computation which is\\n# simply making two other recursive calls, finding their maximum, and populating\\n# the cache based on that.\\n#\\n# Space Complexity: O(N) which is occupied by the cache and also by the recursion stack\\n\\ndef rob(nums, i = nums.length - 1)\\n  return 0 if i < 0\\n\\n  [rob(nums, i - 2) + nums[i], rob(nums, i - 1)].max\\nend\\n\\nnums = [1, 2, 3, 1]\\nputs rob(nums)\\n# Output: 4\\n\\nnums = [2, 7, 9, 3, 1]\\nputs rob(nums)\\n# Output: 12\\n\\n#\\n# Approach 2: Optimized Dynamic Programming\\n#\\n\\n# Time Complexity\\n#\\n# Time Complexity: O(N) since we have a loop from N−2 and we use the precalculated\\n# values of our dynamic programming table to calculate the current value in the table\\n# which is a constant time operation.\\n#\\n# Space Complexity: O(1) since we are not using a table to store our values.\\n# Simply using two variables will suffice for our calculations.\\n#\\n\\ndef rob(nums)\\n  dp = Array.new(nums.size + 1)\\n\\n  (nums.size + 1).times do |i|\\n    dp[i] = if i == 0\\n              0\\n            elsif i == 1\\n              nums[0]\\n            else\\n              [dp[i - 2] + nums[i - 1], dp[i - 1]].max\\n            end\\n  end\\n\\n  dp[-1]\\nend\\n\\nnums = [1, 2, 3, 1]\\nputs rob(nums)\\n# Output: 4\\n\\nnums = [2, 7, 9, 3, 1]\\nputs rob(nums)\\n# Output: 12\\n\"",
    "knapsack": "\"require \\\"test/unit\\\"\\r\\n\\r\\n# 0-1 Knapsack problem\\r\\n# The function returns the maximum value that can be put in a knapsack of a given capacity\\r\\n \\r\\ndef knapSack(weight, wt, val, n)\\r\\n    \\r\\n    rows, cols = n+1,weight+1  \\r\\n    # Create a 2D array to store results of subproblems\\r\\n    dp = Array.new(rows) { Array.new(cols) }\\r\\n    \\r\\n    for i in (0..n + 1-1) \\r\\n        for w in (0..weight + 1-1) \\r\\n            # if the weight is 0 or value is zero, the corresponding cell in the 2D array is set to 0\\r\\n            if i == 0 || w == 0 \\r\\n                dp[i][w] = 0\\r\\n            \\r\\n            #If the weight of an element is less than the capacity of the bag, the maximum value of the two cases is taken(Either the element is taken into consideration\\r\\n            #or is ignored)\\r\\n            elsif wt[i-1] <= w \\r\\n                dp[i][w] = [ val[i-1] + dp[i-1][w-wt[i-1]],dp[i-1][w]].max()\\r\\n           \\r\\n            #If the weight of the element is greater than the capacity of the bag, the cell is set to the value of the previous cell\\r\\n            else\\r\\n                dp[i][w] = dp[i-1][w]\\r\\n            end\\r\\n        end\\r\\n    end\\r\\n    \\r\\n    return dp[n][weight]\\r\\nend\\r\\n    \\r\\n  \\r\\n\\r\\n\\r\\n\\r\\nclass Knapsacktest < Test::Unit::TestCase\\r\\n    \\r\\n    #Test1\\r\\n    def test_knapsack1\\r\\n      assert_equal 220, knapSack(50,[10,20,30],[60,100,120],3), \\\"Should return 220\\\" \\r\\n    end\\r\\n\\r\\n\\r\\n    #Test2\\r\\n    def test_knapsack2\\r\\n      assert_equal 500, knapSack(50,[50, 20, 30],[100, 200, 300],3), \\\"Should return 500\\\" \\r\\n    end\\r\\n\\r\\n    #Test3\\r\\n    def test_knapsack3\\r\\n        assert_equal 17, knapSack(10,[3,4,5, 2, 1],[10,2,3,4,0],5), \\\"Should return 17\\\" \\r\\n    end\\r\\n\\r\\n    #Test4\\r\\n    def test_knapsack4\\r\\n        assert_equal 0, knapSack(0,[23, 17, 12, 8, 20],[199,200,30,41,10],5), \\\"Should return 0\\\" \\r\\n    end\\r\\n\\r\\n\\r\\nend\\r\\n\\r\\n\\r\\n    \"",
    "ones and zeros": "\"# You are given an array of binary strings strs and two integers m and n.\\n#\\n# Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\\n#\\n# A set x is a subset of a set y if all elements of x are also elements of y.\\n#\\n# Example 1:\\n#\\n# Input: strs = [\\\"10\\\",\\\"0001\\\",\\\"111001\\\",\\\"1\\\",\\\"0\\\"], m = 5, n = 3\\n# Output: 4\\n# Explanation: The largest subset with at most 5 0's and 3 1's is {\\\"10\\\", \\\"0001\\\", \\\"1\\\", \\\"0\\\"}, so the answer is 4.\\n# Other valid but smaller subsets include {\\\"0001\\\", \\\"1\\\"} and {\\\"10\\\", \\\"1\\\", \\\"0\\\"}.\\n# {\\\"111001\\\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\\n#\\n# Example 2:\\n#\\n# Input: strs = [\\\"10\\\",\\\"0\\\",\\\"1\\\"], m = 1, n = 1\\n# Output: 2\\n# Explanation: The largest subset is {\\\"0\\\", \\\"1\\\"}, so the answer is 2.\\n\\n#\\n# Approach #1 Dynamic Programming\\n#\\n\\n# @param {String[]} strs\\n# @param {Integer} m\\n# @param {Integer} n\\n# @return {Integer}\\ndef find_max_form(strs, m, n)\\n  dp = (m + 1).times.map { [0] * (n + 1) }\\n\\n  strs.each do |str|\\n    zeros = str.count('0')\\n    ones = str.count('1')\\n\\n    m.downto(zeros) do |i|\\n      n.downto(ones) do |j|\\n        dp[i][j] = [dp[i][j], dp[i - zeros][j - ones] + 1].max\\n      end\\n    end\\n  end\\n\\n  dp[m][n]\\nend\\n\\nstrs = %w[10 0001 111001 1 0]\\nm = 5\\nn = 3\\nputs find_max_form(strs, m, n)\\n# Output: 4\\n\\nstrs = %w[10 0 1]\\nm = 1\\nn = 1\\nputs find_max_form(strs, m, n)\\n# Output: 2\\n\"",
    "pascal triangle ii": "\"# Given an integer row_index, return the rowIndexth (0-indexed) row of the Pascal's triangle.\\n\\n# Example 1:\\n#\\n# Input: row_index = 3\\n# Output: [1,3,3,1]\\n#\\n# Example 2:\\n#\\n# Input: row_index = 0\\n# Output: [1]\\n#\\n# Example 3:\\n#\\n# Input: row_index = 1\\n# Output: [1,1]\\n\\n# Complexity Analysis\\n#\\n# Time complexity: O(k).\\n# Space complexity: O(k).\\n\\ndef get_row(row_index)\\n  (0..row_index).map { |num| combination(row_index, num) }\\nend\\n\\ndef combination(num1, num2)\\n  factorial(num1) / (factorial(num2) * factorial(num1 - num2))\\nend\\n\\ndef factorial(num)\\n  (1..num).inject(1) { |res, i| res * i }\\nend\\n\\nrow_index = 3\\nprint(get_row(row_index))\\n# => [1,3,3,1]\\n\\nrow_index = 0\\nprint(get_row(row_index))\\n# => [1]\\n\\nrow_index = 1\\nprint(get_row(row_index))\\n# => [1,1]\\n\"",
    "ohms law": "\"# A ruby program for Ohms Law, which is used to calculate Voltage for the given Resistance and Current.\\n# Ohms Law -> V = I * R\\n# Reference: https://en.wikipedia.org/wiki/Ohm's_law\\n\\ndef ohms_law(i, r)\\n  if i > 0 && r > 0\\n    \\\"The voltage for given #{i} ampheres current and #{r} ohms resistance is #{r * i} volts.\\\"\\n  else\\n    raise\\n  end\\nrescue StandardError\\n  'Error: Please provide valid inputs only!'\\nend\\n\\n# Valid inputs\\nputs(ohms_law(5, 10))\\n# The voltage for given 5 ampheres current and 10 ohms resistance is 50 volts.\\nputs(ohms_law(2.5, 6.9))\\n# The voltage for given 2.5 ampheres current and 6.9 ohms resistance is 17.25 volts.\\nputs(ohms_law(0.15, 0.84))\\n# The voltage for given 0.15 ampheres current and 0.84 ohms resistance is 0.126 volts.\\n\\n# Invalid inputs\\nputs(ohms_law(5, -10))\\n# Error: Please provide valid inputs only!\\nputs(ohms_law(-5, -10))\\n# Error: Please provide valid inputs only!\\nputs(ohms_law(5, '10'))\\n# Error: Please provide valid inputs only!\\nputs(ohms_law('a', 10))\\n# Error: Please provide valid inputs only!\\n\"",
    "3nplus1": "\"# A ruby program for 3N plus 1\\n# 3N plus 1 is also called as Collatz Conjecture\\n#\\n# f(n) => n / 2 (if n = 0 (mod 2))\\n# f(n) => (3n + 1) (if n = 1 (mod 2))\\n#\\n# Wiki: https://en.wikipedia.org/wiki/Collatz_conjecture\\n\\ndef collatz_conjecture(number)\\n  n = number\\n  nums = []\\n  nums.push(number)\\n\\n  while number > 1\\n    if number.even?\\n      number /= 2\\n      nums.push(number)\\n    else\\n      number = 3 * number + 1\\n      nums.push(number)\\n    end\\n  end\\n\\n  \\\"The 3N + 1 series of #{n} is #{nums}.\\\"\\nrescue StandardError\\n  'Error: Please provide number only!'\\nend\\n\\n# Valid inputs\\nputs collatz_conjecture(12)\\n# The 3N + 1 series of 12 is [12, 6, 3, 10, 5, 16, 8, 4, 2, 1].\\n\\nputs collatz_conjecture(6)\\n# The 3N + 1 series of 6 is [6, 3, 10, 5, 16, 8, 4, 2, 1].\\n\\nputs collatz_conjecture(100)\\n# The 3N + 1 series of 100 is [100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1].\\n\\n# Invalid inputs\\nputs collatz_conjecture('12')\\n# Error: Please provide number only!\\n\\nputs collatz_conjecture('a')\\n# Error: Please provide number only!\\n\"",
    "abs": "\"# frozen_string_literal: true\\n\\n# Calculates the absolute value of a number\\nclass Abs\\n  def self.call(number)\\n    return -number if number.negative?\\n\\n    number\\n  end\\nend\\n\"",
    "abs max": "\"# A ruby program to find absolute maximum\\n# Mathematical representation of abs max = ((a + b + absoulte(a - b)) / 2)\\n\\ndef abs_max(x, y)\\n  num = x - y\\n  max_value = ((x + y + num.abs) / 2)\\n  \\\"The Abs Max of #{x} and #{y} is #{max_value}.\\\"\\nrescue StandardError\\n  'Error: Provide number only!'\\nend\\n\\n# Valid inputs\\nputs abs_max(10, 20)\\n# The Abs Max of 10 and 20 is 20.\\n\\nputs abs_max(-10, -1)\\n# The Abs Max of -10 and -1 is -1.\\n\\nputs abs_max(9, -121)\\n# The Abs Max of 9 and -121 is 9.\\n\\n# Invalid inputs\\nputs abs_max(2, '-1')\\n# Error: Provide number only!\\n\\nputs abs_max('3', '5')\\n# Error: Provide number only!\\n\\nputs abs_max('a', '5')\\n# Error: Provide number only!\\n\"",
    "abs min": "\"# A ruby program to find absolute minimum\\n# Mathematical representation of abs min = ((a + b - absoulte(a - b)) / 2)\\n\\ndef abs_min(x, y)\\n  num = x - y\\n  min_value = ((x + y - num.abs) / 2)\\n  \\\"The Abs Min of #{x} and #{y} is #{min_value}.\\\"\\nrescue StandardError\\n  'Error: Provide number only!'\\nend\\n\\n#\\n# Valid inputs\\n#\\nputs abs_min(10, 20)\\n# The Abs Min of 10 and 20 is 10.\\n\\nputs abs_min(-10, -1)\\n# The Abs Min of -10 and -1 is -10.\\n\\nputs abs_min(9, -121)\\n# The Abs Min of 9 and -121 is -121.\\n\\n#\\n# Invalid inputs\\n#\\nputs abs_min(2, '-1')\\n# Error: Provide number only!\\n\\nputs abs_min('3', '5')\\n# Error: Provide number only!\\n\\nputs abs_min('a', '5')\\n# Error: Provide number only!\\n\"",
    "abs test": "\"# frozen_string_literal: true\\n\\nrequire 'minitest/autorun'\\nrequire_relative './abs'\\n\\nclass AbsTest < Minitest::Test\\n  def test_positive_number\\n    assert_equal Abs.call(4), 4\\n  end\\n\\n  def test_zero\\n    assert_equal Abs.call(0), 0\\n  end\\n\\n  def test_negative_number\\n    assert_equal Abs.call(-9), 9\\n  end\\nend\\n\"",
    "add": "\"# A ruby program to add numbers\\n# Addition or sum of numbers means adding each and every element of the inputs\\n# Sum or addition of 1 and 3 is 1 + 3 = 4\\n\\ndef add(*array)\\n  sum = 0\\n  array.each { |a| sum += a }\\n  puts \\\"The sum of following elements #{array} is #{sum}\\\"\\nrescue StandardError\\n  puts 'Error: Please provide number only!'\\nend\\n\\n#\\n# Valid inputs\\n#\\n\\nputs add(1)\\n# The sum of following elements [1] is 1\\n\\nputs add(2, 5, -4)\\n# The sum of following elements [2, 5, -4] is 3\\n\\nputs add(25, 45)\\n# The sum of following elements [25, 45] is 70\\n\\n#\\n# Invalid inputs\\n#\\n\\nputs add('1', 2, 3)\\n# Error: Please provide number only!\\n\\nputs add('a', 1)\\n# Error: Please provide number only!\\n\"",
    "add digits": "\"# Challenge name: Add Digits\\n#\\n# Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\\n#\\n# Example:\\n#\\n# Input: 38\\n# Output: 2\\n# Explanation: 3 + 8 = 11, 1 + 1 = 2.\\n\\n#\\n# Approach: Mathematical: Digital Root\\n#\\n# https://en.wikipedia.org/wiki/Digital_root\\n# https://brilliant.org/wiki/digital-root/\\n#\\n\\n#\\n# Complexity Analysis\\n#\\n# Time Complexity: O(1).\\n# Space Complexity: O(1).\\n\\ndef add_digits(num)\\n  return 0 if num == 0\\n  return 9 if num % 9 == 0\\n\\n  num % 9\\nend\\n\\nputs(add_digits(38))\\n# # => 2\\n\\nputs(add_digits(284))\\n# # => 5\\n\"",
    "aliquot sum": "\"# frozen_string_literal: true\\n\\nrequire_relative './square_root'\\nrequire_relative './ceil'\\n\\n# Calculates the aliquot sum of a number (the sum of all proper divisors of a number)\\nclass AliquotSum\\n  class << self\\n    def call(number)\\n      divisors(number).sum\\n    end\\n\\n    private\\n\\n    def divisors(number)\\n      low_divisors = (1..Ceil.call(SquareRoot.call(number))).select { |num| (number % num).zero? }\\n      high_divisors = low_divisors.map { |div| number / div }\\n      (low_divisors + high_divisors).uniq - [number]\\n    end\\n  end\\nend\\n\"",
    "aliquot sum test": "\"# frozen_string_literal: true\\n\\nrequire 'minitest/autorun'\\nrequire_relative './aliquot_sum'\\n\\nclass AliquotSumTest < Minitest::Test\\n  def test_zero\\n    assert_equal AliquotSum.call(0), 0\\n  end\\n\\n  def test_one\\n    assert_equal Abs.call(1), 1\\n  end\\n\\n  def test_many\\n    (2..100).each do |number|\\n      expected_aliquot_sum = (1...number).select { |num| (number % num).zero? }.sum\\n      assert_equal AliquotSum.call(number), expected_aliquot_sum\\n    end\\n  end\\nend\\n\"",
    "armstrong number": "\"# A ruby program to determine whether a given number is an Armstrong number\\n# Wiki url: https://en.wikipedia.org/wiki/Narcissistic_number\\n# other resources: https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap04/arms.html\\n\\n#\\n# Examples: -> 153 = (1 * 1 * 1) + (5 * 5 * 5) + (3 * 3 * 3) [Armstrong number] and -> 125 != (1 * 1 * 1) + (2 * 2 * 2) + (5 * 5 * 5)\\n# -> 1634 = (1 * 1 * 1 * 1) + (6 * 6 * 6 * 6) + (3 * 3 * 3 * 3) + (4 * 4 * 4 * 4)\\n#\\n\\ndef armstrong_number(number)\\n  num = number\\n  sum = 0\\n  len = number.digits.count\\n  while number != 0\\n    remainder = number % 10\\n    sum += remainder**len\\n    number /= 10\\n  end\\n\\n  if num == sum\\n    \\\"The number #{num} is an Armstrong number.\\\"\\n  else\\n    \\\"The number #{num} is not an Armstrong number.\\\"\\n  end\\nrescue StandardError\\n  'Error: Please provide number only!'\\nend\\n\\n#\\n# Valid inputs\\n#\\nputs armstrong_number(153)\\n# The number 153 is an Armstrong number.\\n\\nputs armstrong_number(0)\\n# The number 0 is an Armstrong number.\\n\\nputs armstrong_number(370)\\n# The number 370 is an Armstrong number.\\n\\nputs armstrong_number(10)\\n# The number 10 is not an Armstrong number.\\n\\nputs armstrong_number(1634)\\n# The number 1634 is an Armstrong number.\\n\\nputs armstrong_number(123)\\n# The number 123 is not an Armstrong number.\\n\\n#\\n# Invalid inputs\\n#\\nputs armstrong_number('153')\\n# Error: Please provide number only!\\n\\nputs armstrong_number('a')\\n# Error: Please provide number only!\\n\"",
    "average mean": "\"# A ruby program for finding average mean\\n\\nmodule AverageMean\\n  # Average mean = sum of elements / total number of elements\\n  def self.average_mean(n, *array)\\n    if n.instance_of? Integer\\n      if n == array.size\\n        puts \\\"The average mean of the following elements #{array} is #{array.sum / array.size}.\\\"\\n      else\\n        puts \\\"Provide the required #{n} elements properly!\\\"\\n      end\\n    else\\n      raise\\n    end\\n  rescue StandardError\\n    puts 'Error: Please provide number only!'\\n  end\\nend\\n\\n# Valid inputs\\nAverageMean.average_mean(2, 3, 1)\\nAverageMean.average_mean(5, 1, 2, 3, 4, 5)\\nAverageMean.average_mean(3, 2, 2, 2)\\n\\n# Invalid inputs\\nAverageMean.average_mean(2, 3, 1, 5)\\nAverageMean.average_mean(2, 3, 'a')\\nAverageMean.average_mean('a', 1, 2)\\n\"",
    "average median": "\"# A ruby program to find average median\\n# Reference: https://dev.to/colerau/how-to-find-the-median-and-mean-of-an-array-in-ruby-4f04\\n\\nmodule AverageMedian\\n  def self.average_median(n, *array)\\n    if n.instance_of? Integer\\n      if n == array.size\\n        array.sort\\n        if array.size.even?\\n          mid_element_1 = array.size / 2\\n          mid_element_2 = mid_element_1 + 1\\n          puts \\\"The average median of the following elements #{array} is #{(array[mid_element_1 - 1] + array[mid_element_2 - 1]) / 2}.\\\"\\n        else\\n          mid_element = (array.size + 1) / 2\\n          puts \\\"The average median of the following elements #{array} is #{array[mid_element - 1]}.\\\"\\n        end\\n      else\\n        puts \\\"Provide the required #{n} elements properly!\\\"\\n      end\\n    else\\n      raise\\n    end\\n  rescue StandardError\\n    puts 'Error: Please provide number only!'\\n  end\\nend\\n\\n#\\n# Valid inputs\\n#\\n\\nputs AverageMedian.average_median(2, 3, 1)\\n# The average median of the following elements [3, 1] is 2.\\n\\nputs AverageMedian.average_median(5, 1, 2, 3, 4, 5)\\n# The average median of the following elements [1, 2, 3, 4, 5] is 3.\\n\\nputs AverageMedian.average_median(3, 2, 2, 2)\\n# The average median of the following elements [2, 2, 2] is 2.\\n\\nputs AverageMedian.average_median(1, 5)\\n# The average median of the following elements [5] is 5.\\n\\n#\\n# Invalid inputs\\n#\\n\\nputs AverageMedian.average_median(2, 3, 1, 5)\\n# Provide the required 2 elements properly!\\n\\nputs AverageMedian.average_median(2, 3, 'a')\\n# Traceback (most recent call last):\\n#         4: from /Users/voliveira/.rvm/rubies/ruby-2.7.0/bin/irb:23:in `<main>'\\n#         3: from /Users/voliveira/.rvm/rubies/ruby-2.7.0/bin/irb:23:in `load'\\n#         2: from /Users/voliveira/.rvm/rubies/ruby-2.7.0/lib/ruby/gems/2.7.0/gems/irb-1.2.1/exe/irb:11:in `<top (required)>'\\n#         1: from (irb):30\\n# NameError (undefined local variable or method `verageMedian' for main:Object)\\n\\nputs AverageMedian.average_median('a', 1, 2)\\n# Error: Please provide number only!\\n\"",
    "binary to decimal": "\"#\\n# For any binary number of n digits i.e dn-1 ... d3 d2 d1 d0\\n# The equivalent decimal number is equal to the sum of binary digits (dn) times their power of 2 (2n):\\n# decimal = d0×2^0 + d1×2^1 + d2×2^2 + ...\\n#\\n\\ndef binary_to_decimal(n)\\n  decimal = 0\\n  base = 1\\n  until n.zero?\\n    x = n % 10\\n    n /= 10\\n    decimal += x * base\\n    base *= 2\\n  end\\n  decimal\\nend\\n\\nputs 'Decimal value of 110011 is ' + binary_to_decimal(110_011).to_s\\n# Decimal value of 110011 is 51\\nputs 'Decimal value of 11110 is ' + binary_to_decimal(11_110).to_s\\n# Decimal value of 11110 is 30\\nputs 'Decimal value of 101 is ' + binary_to_decimal(101).to_s\\n# Decimal value of 101 is 5\\n\"",
    "ceil": "\"# frozen_string_literal: true\\n\\nclass Ceil\\n  class << self\\n    def call(number)\\n      return number if number.is_a?(Integer) || number == number.to_i\\n\\n      number.to_i + 1\\n    end\\n  end\\nend\\n\"",
    "ceil test": "\"# frozen_string_literal: true\\n\\nrequire 'minitest/autorun'\\nrequire_relative './ceil'\\n\\nclass CeilTest < Minitest::Test\\n  def test_integer\\n    assert_equal Ceil.call(4), 4\\n  end\\n\\n  def test_float_at_integer\\n    assert_equal Ceil.call(4.0), 4\\n  end\\n\\n  def test_float_not_at_integer\\n    assert_equal Ceil.call(4.01), 5\\n  end\\nend\\n\"",
    "decimal to binary": "\"# Convert a given decimal number into binary.\\n\\n#\\n# Approach 1: Iterative\\n#\\n\\ndef decimal_to_binary(n)\\n  bin = []\\n\\n  until n.zero?\\n    bin << n % 2\\n    n /= 2\\n  end\\n\\n  bin.reverse.join\\nend\\n\\nputs 'Binary value of 4 is ' + decimal_to_binary(4).to_s\\n# Binary value of 4 is 100\\n\\nputs 'Binary value of 31 is ' + decimal_to_binary(31).to_s\\n# Binary value of 31 is 11111\\n\\nputs 'Binary value of 64 is ' + decimal_to_binary(64).to_s\\n# Binary value of 64 is 1000000\\n\\n#\\n# Approach 2: Recursive\\n#\\n\\ndef decimal_to_binary(d)\\n  binary = (d % 2).to_s\\n\\n  return binary if d == 0\\n  return 1.to_s if d == 1\\n\\n  decimal_to_binary(d / 2).to_s + binary\\nend\\n\\nputs 'Binary value of 4 is ' + decimal_to_binary(4).to_s\\n# Binary value of 4 is 100\\n\\nputs 'Binary value of 31 is ' + decimal_to_binary(31).to_s\\n# Binary value of 31 is 11111\\n\\nputs 'Binary value of 64 is ' + decimal_to_binary(64).to_s\\n# Binary value of 64 is 1000000\\n\"",
    "factorial": "\"# A ruby program calculate factorial of a given number.\\n# Mathematical Explanation: The factorial of a number is the product of all the integers from 1 to that number.\\n# i.e: n! = n*(n-1)*(n-2)......*2*1\\n\\n#\\n# Approach: Interative\\n#\\n\\ndef factorial(n)\\n  return nil if n < 0\\n\\n  fac = 1\\n\\n  while n > 0\\n    fac *= n\\n    n -= 1\\n  end\\n\\n  fac\\nend\\n\\nputs '4! = ' + factorial(4).to_s\\n# 4! = 24\\n\\nputs '0! = ' + factorial(0).to_s\\n# 0! = 1\\n\\nputs '10! = ' + factorial(10).to_s\\n# 10! = 3628800\\n\"",
    "factorial non recursive non iterative": "\"# A ruby program to find factorial of a given integer\\n# Factorial of a given integer is defined as the product of all the positive integers less than or equal to the given integer\\n# Mathematical representation: n! = n * (n - 1) * (n - 2) * ... * 1\\n\\n#\\n# Non-recursive and non-iterative approach\\n#\\n\\ndef factorial(number)\\n  if number < 0\\n    'Please check your input number! The given number is a negative number.'\\n  elsif number == 0\\n    \\\"The factorial of #{number} is 1.\\\"\\n  else\\n    result = (1..number).inject(:*)\\n    \\\"The factorial of #{number} is #{result}.\\\"\\n  end\\nrescue StandardError\\n  'Error: Please provide integer only!'\\nend\\n\\n# Valid inputs\\nputs factorial(0)\\n# The factorial of 0 is 1.\\n\\nputs factorial(4)\\n# The factorial of 4 is 24.\\n\\nputs factorial(10)\\n# The factorial of 10 is 3628800.\\n\\nputs factorial(1)\\n# The factorial of 1 is 1.\\n\\nputs factorial(-5)\\n# Please check your input number! The given number is a negative number.\\n\\n# Invalid inputs\\nputs factorial('a')\\n# Error: Please provide integer only!\\n\\nputs factorial('2')\\n# Error: Please provide integer only!\\n\"",
    "find max": "\"# A ruby program to find max from a set of elements\\n\\n# This find_max method will return the max element out of the array\\ndef find_max(*array)\\n  max = array[0]\\n  array.each do |a|\\n    max = a if a >= max\\n  end\\n  \\\"The Max of the following elements #{array} is #{max}.\\\"\\nrescue StandardError\\n  'Error: Please provide number only!'\\nend\\n\\n# Max method will return the maximum element from the set of input elements provided\\ndef predefined_max(*array)\\n  \\\"The Max of the following elements #{array} is #{array.max}.\\\"\\nrescue StandardError\\n  'Error: Please provide number only!'\\nend\\n\\n# Sort method will sort the elements in ascending order. Last method will return the end element out of the array\\ndef predefined_sort_last_max(*array)\\n  \\\"The Max of the following elements #{array} is #{array.max}.\\\"\\nrescue StandardError\\n  'Error: Please provide number only!'\\nend\\n\\n# Using find_max\\n# Valid inputs\\nputs find_max(11, 29, 33)\\n# The Max of the following elements [11, 29, 33] is 33.\\n\\nputs find_max(-221, -852, -1100, -10)\\n# The Max of the following elements [-221, -852, -1100, -10] is -10.\\n\\n# Invalid inputs\\nputs find_max(5, '95', 2)\\n# Error: Please provide number only!\\n\\n# Using predefined_max\\n# Valid inputs\\nputs predefined_max(51, 82, 39)\\n# The Max of the following elements [51, 82, 39] is 82.\\n\\nputs predefined_max(-11, -51, -10, -10)\\n# The Max of the following elements [-11, -51, -10, -10] is -10.\\n\\n# Invalid inputs\\nputs predefined_max('x', 5, 95, 2)\\n# Error: Please provide number only!\\n\\n# Using predefined_sort_last_max\\n# Valid inputs\\nputs predefined_sort_last_max(1, 2, 3)\\n# The Max of the following elements [1, 2, 3] is 3.\\n\\nputs predefined_sort_last_max(-21, -52, -100, -1)\\n# The Max of the following elements [-21, -52, -100, -1] is -1.\\n\\n# Invalid inputs\\nputs predefined_sort_last_max(5, 95, 2, 'a')\\n# Error: Please provide number only!\\n\"",
    "find min": "\"# A ruby program to find min from a set of elements\\n\\n# This find_min method will return the min element out of the array\\ndef find_min(*array)\\n  min = array[0]\\n  array.each do |a|\\n    min = a if a <= min\\n  end\\n  \\\"The Min of the following elements #{array} is #{min}.\\\"\\nrescue StandardError\\n  'Error: Please provide number only!'\\nend\\n\\n# Min method will return the minimum element from the set of input elements provided\\ndef predefined_min(*array)\\n  \\\"The Min of the following elements #{array} is #{array.min}.\\\"\\nrescue StandardError\\n  'Error: Please provide number only!'\\nend\\n\\n# Sort method will sort the elements in ascending order. First method will return the beginning element out of the array\\ndef predefined_sort_first_min(*array)\\n  \\\"The Min of the following elements #{array} is #{array.min}.\\\"\\nrescue StandardError\\n  'Error: Please provide number only!'\\nend\\n\\n# Using find_min\\n# Valid inputs\\nputs find_min(11, 29, 33)\\n# The Min of the following elements [11, 29, 33] is 33.\\n\\nputs find_min(-221, -852, -1100, -10)\\n# The Min of the following elements [-221, -852, -1100, -10] is -10.\\n\\n# Invalid inputs\\nputs find_min(5, '95', 2)\\n# Error: Please provide number only!\\n\\n# Using predefined_min\\n# Valid inputs\\nputs predefined_min(51, 82, 39)\\n# The Min of the following elements [51, 82, 39] is 82.\\n\\nputs predefined_min(-11, -51, -10, -10)\\n# The Min of the following elements [-11, -51, -10, -10] is -10.\\n\\n# Invalid inputs\\nputs predefined_min('x', 5, 95, 2)\\n# Error: Please provide number only!\\n\\n# Using predefined_sort_first_min\\n# Valid inputs\\nputs predefined_sort_first_min(1, 2, 3)\\n# The Min of the following elements [1, 2, 3] is 3.\\n\\nputs predefined_sort_first_min(-21, -52, -100, -1)\\n# The Min of the following elements [-21, -52, -100, -1] is -1.\\n\\n# Invalid inputs\\nputs predefined_sort_first_min(5, 95, 2, 'a')\\n# Error: Please provide number only!\\n\"",
    "lucas series": "\"# A ruby program for Lucas series\\n#\\n# The Lucas numbers, commonly denoted L(n) form a sequence,\\n# called the Lucas series, such that each number is the sum\\n# of the two preceding ones, starting from 2 and 1. That is,\\n#\\n# L(0) = 2, L(1) = 1\\n# L(n) = L(n - 1) + L(n - 2), for n > 1.\\n#\\n# Given n, calculate L(n).\\n# Example: 2 1 3 4 7 11 18...\\n# Resource: https://en.wikipedia.org/wiki/Lucas_number\\n\\ndef lucas(number)\\n  golden_ratio = (1 + 5**0.5) / 2\\n  (golden_ratio**number).round.to_i\\nrescue StandardError\\n  'Error: Provide number only!'\\nend\\n\\nputs lucas(4)\\n# 7\\n\\nputs lucas(3)\\n# 4\\n\\nputs lucas('3')\\n# Error: Provide number only!\\n\\nputs lucas(2)\\n# 3\\n\"",
    "number of digits": "\"# Given a number, find number of digits in it.\\n\\ndef count_digits(n)\\n  count = 0\\n  temp = n\\n\\n  return 1 if n == 0\\n\\n  until temp.zero?\\n    count += 1\\n    temp /= 10\\n  end\\n\\n  count\\nend\\n\\nputs 'Number of digits in 8732 is ' + count_digits(8732).to_s\\n# Number of digits in 8732 is 4\\nputs 'Number of digits in 112233 is ' + count_digits(112_233).to_s\\n# Number of digits in 112233 is 6\\nputs 'Number of digits in 0 is ' + count_digits(0).to_s\\n# Number of digits in 0 is 1\\n\"",
    "prime number": "\"# A ruby program to check a given number is prime or not\\n# Mathematical explanation: A number which has only 2 factors i.e., 1 (one) and itself\\n\\n# Prime number check function\\ndef prime_number(number)\\n  non_prime_flag = if number <= 1\\n                     true\\n                   elsif number == 2\\n                     false\\n                   elsif number.even?\\n                     true\\n                   else\\n                     (2..Math.sqrt(number)).any? { |i| number % i == 0 }\\n                   end\\n\\n  if !non_prime_flag\\n    puts \\\"The given number #{number} is a Prime.\\\"\\n  else\\n    puts \\\"The given number #{number} is not a Prime.\\\"\\n  end\\nend\\n\\n# Non-prime input\\nprime_number(1)\\n\\n# prime input\\n# Number 2 is an even prime number\\nprime_number(2)\\n\\n# Non-prime input\\nprime_number(20)\\n\\n# Negative input\\nprime_number(-21)\\n\"",
    "roman to integer": "\"# Challenge name: Roman to Integer\\n#\\n# Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\\n#\\n# Symbol       Value\\n# I             1\\n# V             5\\n# X             10\\n# L             50\\n# C             100\\n# D             500\\n# M             1000\\n#\\n# For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\\n#\\n# Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\\n#\\n# I can be placed before V (5) and X (10) to make 4 and 9.\\n# X can be placed before L (50) and C (100) to make 40 and 90.\\n# C can be placed before D (500) and M (1000) to make 400 and 900.\\n# Given a roman numeral, convert it to an integer.\\n#\\n#\\n\\n# Approach 1: Left-to-Right Pass\\n#\\n\\n# Complexity Analysis\\n#\\n# Let n be the length of the input string (the total number of symbols in it).\\n#\\n# Time complexity: O(1).\\n# As there is a finite set of roman numerals.\\n#\\n# Space complexity: O(1).\\n# Because only a constant number of single-value variables are used, the space complexity is O(1).\\n\\nROM_NUMS = {\\n  'I' => 1,\\n  'V' => 5,\\n  'X' => 10,\\n  'L' => 50,\\n  'C' => 100,\\n  'D' => 500,\\n  'M' => 1000\\n}\\n\\n# Now, recall that each symbol adds its own value, except for when a smaller\\n# valued symbol is before a larger valued symbol. In those cases, instead of\\n# adding both symbols to the total, we need to subtract the large from the\\n# small, adding that instead.\\n\\n# Therefore, the simplest algorithm is to use a pointer to scan through the\\n# string, at each step deciding whether to add the current symbol and\\n# go forward 1 place, or add the difference of the next 2 symbols and\\n# go forward 2 places.\\n\\ndef roman_to_int(s)\\n  res = 0\\n  temp = 0\\n\\n  s.chars.each_with_index do |el, i|\\n    # subtractive case: if at least 2 symbols remaining AND value of s[i] < value of s[i + 1]\\n    if ROM_NUMS[s[i + 1]] && ROM_NUMS[el] < ROM_NUMS[s[i + 1]]\\n      temp = ROM_NUMS[el]\\n    else\\n      # Else this is NOT the subtractive case.\\n      res += (ROM_NUMS[el] - temp)\\n      temp = 0\\n    end\\n  end\\n\\n  res\\nend\\n\\ns = 'III'\\nputs roman_to_int(s)\\n# Output: 3\\n\\ns = 'IV'\\nputs roman_to_int(s)\\n# Output: 4\\n\\ns = 'IX'\\nputs roman_to_int(s)\\n# Output: 9\\n\\ns = 'LVIII'\\nputs roman_to_int(s)\\n# Output: 58\\n# Explanation: L = 50, V= 5, III = 3.\\n\\ns = 'MCMXCIV'\\nputs roman_to_int(s)\\n# Output: 1994\\n# Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\\n\"",
    "square root": "\"# frozen_string_literal: true\\n\\n# Calculates the square root of a number\\nclass SquareRoot\\n  class << self\\n    EPSILON = 1E-10\\n\\n    def call(number)\\n      raise DomainError, 'Cannot find square root of negative number' if number.negative?\\n      return 0 if number.zero?\\n\\n      find_root(number)\\n    end\\n\\n    private\\n\\n    def find_root(x0, xn = x0)\\n      xn1 = xn - ((xn * xn - x0) / (2.0 * xn))\\n      return xn1 if (xn1 - xn).abs <= EPSILON\\n\\n      find_root(x0, xn1)\\n    end\\n  end\\nend\\n\\nclass DomainError < StandardError; end\\n\"",
    "square root test": "\"# frozen_string_literal: true\\n\\nrequire 'minitest/autorun'\\nrequire_relative './square_root'\\n\\nclass SquareRootTest < Minitest::Test\\n  def test_negative_number\\n    assert_raises DomainError do\\n      SquareRoot.call(-1)\\n    end\\n  end\\n\\n  def test_zero\\n    assert_equal 0, SquareRoot.call(0)\\n  end\\n\\n  def test_all_numbers_below_1024\\n    (1...1024).each do |num|\\n      assert_in_delta SquareRoot.call(num), Math.sqrt(num), 1E-12\\n    end\\n  end\\nend\\n\"",
    "sum of digits": "\"# Given a number, find sum of its digits.\\n\\ndef digits_sum(n)\\n  a = 0\\n  sum = 0\\n  until n.zero?\\n    a = n % 10\\n    sum += a\\n    n /= 10\\n  end\\n  sum\\nend\\n\\nputs 'Sum of digits of 3456 is ' + digits_sum(3456).to_s\\n# Sum of digits of 3456 is 18\\nputs 'Sum of digits of 1234 is ' + digits_sum(1234).to_s\\n# Sum of digits of 1234 is 10\\nputs 'Sum of digits of 9251321 is ' + digits_sum(9_251_321).to_s\\n# Sum of digits of 9251321 is 23\\n\"",
    "fisher yates": "\"# Fisher and Yates Shuffle is one of the simplest and most popular shuffling algorithm\\ndef fisher_yates_shuffle(array)\\n  n = array.length\\n  while n > 0\\n    i = rand(n -= 1)\\n    array[i], array[n] = array[n], array[i]\\n  end\\n  array\\nend\\n\\narr = [1, 2, 40, 30, 20, 15, 323, 12, 3, 4]\\nputs fisher_yates_shuffle(arr)\\n\"",
    "number of days": "\"# Challenge name: Number of Days Between Two Dates\\n#\\n# Write a program to count the number of days between two dates.\\n#\\n# The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples.\\n# Example 1:\\n# Input: date1 = \\\"2019-06-29\\\", date2 = \\\"2019-06-30\\\"\\n# Output: 1\\n#\\n# Example 2:\\n# Input: date1 = \\\"2020-01-15\\\", date2 = \\\"2019-12-31\\\"\\n# Output: 15\\n#\\n# Constraints: The given dates are valid dates between the years 1971 and 2100.\\n\\n#\\n# Approach 1: Using Ruby built-in feature Date.parse\\n# Time complexity: O(1)\\n# Space complexity: O(1)\\n#\\n\\nrequire 'date'\\n\\ndef number_of_days(date1, date2)\\n  beginning_date = Date.parse(date1)\\n  end_date = Date.parse(date2)\\n  (end_date - beginning_date).to_i.abs\\nend\\n\\nputs number_of_days('2019-06-29', '2019-06-30')\\n# => 1\\n\\nputs number_of_days('2020-01-15', '2019-12-31')\\n# => 15\\n\"",
    "binary search": "\"# Searches through a list for a value in O(log(n)) time.\\n# The list must be sorted.\\ndef binary_search(array, key)\\n  front = 0\\n  back = array.length - 1\\n  while front <= back\\n    middle = (front + back) / 2\\n    return middle if array[middle] == key\\n\\n    if key < array[middle]\\n      back = middle - 1\\n    else\\n      front = middle + 1\\n    end\\n  end\\n  \\n  nil\\nend\\n\\nputs \\\"Enter a sorted space-separated list:\\\"\\narr = gets.chomp.split(' ').map(&:to_i)\\n\\nputs \\\"Enter the value to be searched:\\\"\\nvalue = gets.chomp.to_i\\n\\nputs if binary_search(arr, value) != nil\\n  \\\"Found at index #{binary_search(arr, value)}\\\"\\nelse\\n  \\\"Not found\\\"\\nend\\n\"",
    "depth first search": "\"# @param [Integer] start\\n# @param [Integer] target\\n# @param [Array] adjacency_list\\n# @return [Array] routes\\ndef dfs(start, target, adjacency_list)\\n  is_visited = Hash.new(false)\\n  parent = {}\\n  stack = [start]\\n  loop do\\n    break if stack.empty?\\n\\n    current_node = stack.pop\\n    is_visited[current_node] = true\\n\\n    return get_path(parent, target) if current_node == target\\n\\n    adjacency_list[current_node].each do |neighbor|\\n      next if is_visited[neighbor]\\n\\n      stack << neighbor\\n      is_visited[neighbor] = true\\n      parent[neighbor] = current_node\\n    end\\n  end\\n  []\\nend\\n\\n# @param [Hash] parent\\n# @param [Integer] dest\\n# @return [Array] path\\ndef get_path(parent, dest)\\n  iterator = dest\\n  path = [dest]\\n  while parent.has_key?(iterator)\\n    path << parent[iterator]\\n    iterator = parent[iterator]\\n  end\\n  path.reverse\\nend\\n\\ndef main\\n  adjacency_list = [\\n    [1, 2], # 0\\n    [0, 3], # 1\\n    [0, 3], # 2\\n    [1, 2, 4], # 3\\n    [3, 5], # 4\\n    [4] # 5\\n  ]\\n  p dfs(0, 5, adjacency_list)\\nend\\n\\nmain\\n\"",
    "double linear search": "\"# Iterate through the array from both sides to find the index of search_item.\\n\\ndef double_linear_search(array, search_item)\\n  start_ind = 0\\n  end_ind = array.length - 1\\n\\n  while start_ind <= end_ind\\n    return start_ind if array[start_ind] == search_item\\n    return end_ind if array[end_ind] == search_item\\n\\n    start_ind += 1\\n    end_ind -= 1\\n  end\\n\\n  # returns -1 if search_item is not found in array\\n  -1\\nend\\n\\nputs(double_linear_search([1, 5, 5, 10], 1))\\n# => 0\\n\\nputs(double_linear_search([1, 5, 5, 10], 5))\\n# => 1\\n\\nputs(double_linear_search([1, 5, 5, 10], 100))\\n# => -1\\n\\nputs(double_linear_search([1, 5, 5, 10], 10))\\n# => 3\\n\"",
    "fibonacci search": "\"def fibonacci_search int arr, int element\\n    n = n.size\\n    f2 = 0\\n    f1 = 1\\n    f  = f2 + f1\\n    offset = -1\\n\\n    while f < n do\\n\\tf2 = f1;\\n\\tf1 = f;\\n\\tf  = f2 + f1;\\n    end\\n\\n    while f > 1 do\\n\\ti = [offset+f2, n-1].min\\n\\n\\tif arr[i] < element\\n\\t    f  = f1\\n\\t    f1 = f2\\n\\t    f2 = f - f1\\n\\t    offset = i\\n\\telsif arr[i] > element\\n\\t    f  = f2\\n\\t    f1 = f1 - f2\\n\\t    f2 = f - f1\\t\\n\\telse\\n\\t    return i\\n        end\\n    end\\n\\n    return offset + 1 if f1 && arr[offset + 1] == element\\n\\n    -1\\nend\\n\"",
    "jump search": "\"# Works only on sorted arrays.\\n# Finding element by creating step in array and jump ahead by fixed steps and finding element using linear search inside that steped array.\\n# Time Complexity: O(√n)\\n\\ndef jump_search(arr, x)\\n  n = arr.length\\n\\n  # Finding block size to be jumped\\n  step = Math.sqrt(n)\\n  prev = 0\\n\\n  # Finding the block where element is\\n  # present (if it is present)\\n  while arr[[step, n].min - 1] < x\\n    prev = step\\n    step += Math.sqrt(n)\\n    return -1 if prev >= n\\n  end\\n\\n  # Doing a linear search for x in block\\n  # beginning with prev.\\n  while arr[prev] < x\\n    prev += 1\\n    # If we reached next block or end of\\n    # array, element is not present.\\n    return -1 if prev == [step, n].min\\n  end\\n\\n  # If element is found\\n  return prev if arr[prev] == x\\n\\n  -1\\nend\\n\\nputs 'Enter a sorted space-separated list:'\\narr = gets.chomp.split(' ').map(&:to_i)\\nputs 'Enter the value to be searched:'\\nvalue = gets.chomp.to_i\\n\\nindex = jump_search(arr, value)\\n\\nputs index == -1 ? 'Element not found' : \\\"Number #{value} is at #{index}\\\"\\n\"",
    "linear search": "\"# Looks through array for a value in O(n) time.\\n# Array does not need to be sorted.\\ndef linear_search(array, key)\\n  array.each_with_index do |current, index|\\n    return index if current == key\\n  end\\n  nil\\nend\\n\\nputs \\\"Enter a space-separated list:\\\"\\narr = gets.chomp.split(' ').map(&:to_i)\\nputs \\\"Enter a value to be searched:\\\"\\nkey = gets.chomp.to_i\\nputs if linear_search(arr, key) != nil\\n  \\\"Found at index #{linear_search(arr, key)}\\\"\\nelse\\n  \\\"Not found\\\"\\nend\\n\"",
    "number of islands": "\"# Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\n# An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\n\\n# Example 1:\\n# Input: grid = [\\n#  [\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"0\\\"],\\n#  [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"1\\\",\\\"0\\\"],\\n#  [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"],\\n#  [\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"]\\n# ]\\n# Output: 1\\n\\n# Example 2:\\n# Input: grid = [\\n#  [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"],\\n#  [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"],\\n#  [\\\"0\\\",\\\"0\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\"],\\n#  [\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"1\\\",\\\"1\\\"]\\n# ]\\n# Output: 3\\n\\n# Constraints:\\n# m == grid.length\\n# n == grid[i].length\\n# 1 <= m, n <= 300\\n# grid[i][j] is '0' or '1'.\\n\\n# DFS, Recursive Bottom Up Approach - O(n*m) Time / O(1) Space\\n# Init num_of_islands = 0, return if the grid is empty\\n# Start a double loop with index to iterate through each plot (each value is a plot of either water or land in this case)\\n# if the plot is land, dfs(grid, x, y)\\n# num_of_islands += 1\\n# Return num_of_islands\\n\\n# dfs(grid, x, y)\\n# Return if x or y are out of bounds, or if the plot is water\\n# Make the current plot water\\n# Call dfs again for up, down, left, and right\\n\\n# @param {Character[][]} grid\\n# @return {Integer}\\ndef num_islands(grid)\\n  return 0 if grid.empty?\\n\\n  # init num of islands\\n  islands = 0\\n\\n  # loop through each element (plot) in the 2d array\\n  grid.each_with_index do |row, x|\\n    row.each_with_index do |plot, y|\\n      # if the plot is water, start a dfs\\n      next unless plot == '1'\\n\\n      dfs(grid, x, y)\\n      # add 1 to islands once all connected land plots are searched\\n      islands += 1\\n    end\\n  end\\n\\n  # return ans\\n  islands\\nend\\n\\ndef dfs(grid, x, y)\\n  # don't search if out of bounds, or if it's already water\\n  return if x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == '0'\\n\\n  # set the plot to water\\n  grid[x][y] = '0'\\n\\n  # search each adjacent plot\\n  dfs(grid, x - 1, y) # up\\n  dfs(grid, x + 1, y) # down\\n  dfs(grid, x, y - 1) # left\\n  dfs(grid, x, y + 1) # right\\nend\\n\"",
    "recursive double linear search": "\"# Iterate through the array to find the index of key using recursion.\\n\\ndef recursive_double_linear_search(data, key, left = 0, right = 0)\\n  right &&= data.length - 1\\n\\n  return -1 if left > right\\n\\n  return left if data[left] == key\\n  return right if data[right] == key\\n\\n  recursive_double_linear_search(data, key, left + 1, right - 1)\\nend\\n\\nputs(recursive_double_linear_search([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 5))\\n# => 5\\n\\nputs(recursive_double_linear_search([1, 2, 4, 5, 3], 4))\\n# => 2\\n\\nputs(recursive_double_linear_search([1, 2, 4, 5, 3], 6))\\n# => -1\\n\\nputs(recursive_double_linear_search([5], 5))\\n# => 0\\n\\nputs(recursive_double_linear_search([], 1))\\n# => -1\\n\"",
    "recursive linear search": "\"# A pure Ruby implementation of a recursive linear search algorithm\\n\\ndef rec_linear_search(sequence, low, high, target)\\n  raise Exception('Invalid upper or lower bound!') unless high < sequence.length && low < sequence.length\\n\\n  return -1 if high < low\\n\\n  return low if sequence[low] == target\\n\\n  return high if sequence[high] == target\\n\\n  rec_linear_search(sequence, low + 1, high - 1, target)\\nend\\n\\nputs(rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0))\\n# => 0\\n\\nputs(rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700))\\n# => 4\\n\\nputs(rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30))\\n# => 1\\n\\nputs(rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6))\\n# => -1\\n\"",
    "ternary search": "\"#         Ternary Search\\n# -------------------------------\\n# Ternary search is a searching technique that is used to search the position of a specific value in an array.\\n# Ternary search is a divide-and-conquer algorithm.\\n# It is mandatory for the array to be sorted (in which you will search for an element).\\n# The array is divided into three parts and then we determine in which part the element exists.\\n# In this search, after each iteration it neglects 1/3 part of the array and repeats the same operations on the remaining ⅔.\\n# Time Complexity: O(log3 n)\\n# Space Complexity: O(1)\\n\\ndef ternary_search(l, r, key, arr)\\n    # l is the starting index and r is the ending index of the array/sub-array.\\n  if r >= l\\n      # find mid1 and mid2\\n      mid1 = l + (r - l) / 3\\n      mid2 = r - (r - l) / 3\\n      # check if key is equal to mid1\\n      if arr[mid1] == key\\n          mid1\\n      # check if key is equal to mid2\\n      elsif arr[mid2] == key\\n          mid2\\n      # Since key is not present at mid, check in which region it is present\\n      # then repeat the Search operation in that region\\n      elsif key < arr[mid1]\\n          ternary_search(l, mid1 - 1, key, arr)\\n      elsif key > arr[mid2]\\n          ternary_search(mid2 + 1, r, key, arr)\\n      else\\n          ternary_search(mid1 + 1, mid2 - 1, key, arr)\\n      end\\n  end\\nend\\n\\nputs \\\"Enter a space-separated list:\\\"\\narr = gets.chomp.split(' ').map(&:to_i)\\nputs \\\"Enter a value to be searched:\\\"\\nkey = gets.chomp.to_i\\nputs if ternary_search(0, arr.length - 1, key, arr) != nil\\n  \\\"Found at index #{ternary_search(0, arr.length - 1, key, arr)}\\\"\\nelse\\n  \\\"Not found\\\"\\nend\\n\"",
    "bead sort": "\"class Array\\n  def columns\\n    x = map(&:length).max\\n    Array.new(x) do |row|\\n      Array.new(length) { |column| self[column][row] }.compact\\n    end\\n  end\\nend\\n\\ndef bead_sort(array)\\n  array\\n    .map { |element| [1] * element }\\n    .columns\\n    .columns\\n    .map(&:length)\\n    .reverse\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets.split.map(&:to_i)\\n  p bead_sort(list)\\nend\\n\"",
    "bead sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './bead_sort'\\n\\nclass TestInsertionSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    bead_sort(input)\\n  end\\nend\\n\"",
    "bogo sort": "\"class Array\\n  def sorted?\\n    ### goes thru array and checks if all elements are in order\\n    (1...length).each do |i|\\n      return false if self[i - 1] > self[i]\\n    end\\n    true\\n  end\\n\\n  def bogosort\\n    ### randomly shuffles until sorted\\n    shuffle! until sorted?\\n    self # return sorted array\\n  end\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n  str = gets.chomp.split('')\\n  puts str.bogosort.join('')\\nend\\n\"",
    "bogo sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './bogo_sort'\\n\\nclass TestBogoSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    input.bogosort\\n  end\\nend\\n\"",
    "bubble sort": "\"def bubble_sort(array)\\n  n = array.length\\n  loop do\\n    swapped = false\\n\\n    (n - 1).times do |i|\\n      if array[i] > array[i + 1]\\n        array[i], array[i + 1] = array[i + 1], array[i]\\n        swapped = true\\n      end\\n    end\\n\\n    break unless swapped\\n  end\\n\\n  array\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets\\n  bubble_sort(list)\\n  print list\\nend\\n\"",
    "bubble sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './bubble_sort'\\n\\nclass TestBubbleSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    bubble_sort(input)\\n  end\\nend\\n\"",
    "bucket sort": "\"DEFAULT_BUCKET_SIZE = 5\\n\\ndef bucket_sort(array, bucket_size = DEFAULT_BUCKET_SIZE)\\n  bucket_count = ((array.max - array.min) / bucket_size).floor + 1\\n\\n  # create buckets\\n  buckets = []\\n  bucket_count.times { buckets.push [] }\\n\\n  # fill buckets\\n  array.each do |item|\\n    buckets[((item - array.min) / bucket_size).floor].push(item)\\n  end\\n\\n  # sort buckets\\n  buckets.each do |bucket|\\n    bucket.sort!\\n  end\\n\\n  buckets.flatten\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets.split.map(&:to_i)\\n  p bucket_sort(list)\\nend\\n\"",
    "bucket sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './bucket_sort'\\n\\nclass TestBucketSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    bucket_sort(input)\\n  end\\nend\\n\"",
    "cocktail sort": "\"def cocktail_sort(array)\\n  start = 0\\n  finish = array.length - 1\\n  way = 1\\n  loop do\\n    swapped = false\\n    start.step(finish - way, way) do |i|\\n      if (array[i] <=> array[i + way]) == way\\n        array[i], array[i + way] = array[i + way], array[i]\\n        swapped = i\\n      end\\n    end\\n    break unless swapped\\n\\n    finish = start\\n    start = swapped\\n    way = -way\\n  end\\n  array\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets.split.map(&:to_i)\\n  p cocktail_sort(list)\\nend\\n\"",
    "cocktail sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './cocktail_sort'\\n\\nclass TestInsertionSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    cocktail_sort(input)\\n  end\\nend\\n\"",
    "comb sort": "\"def comb_sort(array)\\n  gap = array.length\\n  swaps = true\\n  while (gap > 1) || swaps\\n    gap = [1, (gap / 1.25).to_i].max\\n    swaps = false\\n    0.upto(array.length - gap - 1) do |i|\\n      if array[i] > array[i + gap]\\n        array[i], array[i + gap] = array[i + gap], array[i]\\n        swaps = true\\n      end\\n    end\\n  end\\n  array\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets.split.map(&:to_i)\\n  p insertion_sort(list)\\nend\\n\"",
    "comb sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './comb_sort'\\n\\nclass TestInsertionSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    comb_sort(input)\\n  end\\nend\\n\"",
    "heap sort": "\"# Algorithm: Heap-Sort\\n# Time-Complexity: O(nlogn)\\ndef heap_sort(array)\\n  array_size = array.size\\n  adjusted_array = [nil] + array\\n  (array_size / 2).downto(1) do |i|\\n    adjusted_down(adjusted_array, i, array_size)\\n  end\\n  while array_size > 1\\n    adjusted_array[1], adjusted_array[array_size] = adjusted_array[array_size], adjusted_array[1]\\n    array_size -= 1\\n    adjusted_down(adjusted_array, 1, array_size)\\n  end\\n  adjusted_array.drop(1)\\nend\\n\\n# Method to adjust heap in downward manner\\ndef adjusted_down(adjusted_array, parent, limit)\\n  top = adjusted_array[parent]\\n  while (child = 2 * parent) <= limit\\n    child += 1 if (child < limit) && (adjusted_array[child] < adjusted_array[child + 1])\\n    break if top >= adjusted_array[child]\\n\\n    adjusted_array[parent] = adjusted_array[child]\\n    parent = child\\n  end\\n  adjusted_array[parent] = top\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets.split.map(&:to_i)\\n  p heap_sort(list)\\nend\\n\"",
    "heap sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './heap_sort'\\n\\nclass TestHeapSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    heap_sort(input)\\n  end\\nend\\n\"",
    "insertion sort": "\"def insertion_sort(array)\\n  0.upto(array.length - 1).each do |index|\\n    element = array[index]\\n    position = index\\n    while element < array[position - 1] && position > 0\\n      array[position] = array[position - 1]\\n      array[position - 1] = element\\n      position -= 1\\n    end\\n  end\\n  array\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets.split.map(&:to_i)\\n  p insertion_sort(list)\\nend\\n\"",
    "insertion sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './insertion_sort'\\n\\nclass TestInsertionSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    insertion_sort(input)\\n  end\\nend\\n\"",
    "merge sort": "\"def merge_sort(array)\\n  return array if array.length <= 1\\n\\n  mid = array.length / 2\\n  first_array = array.slice(0..mid - 1)\\n  second_array = array.slice(mid..-1)\\n\\n  first_array = merge_sort first_array\\n  second_array = merge_sort second_array\\n\\n  # merge\\n  result = []\\n  until first_array.empty? && second_array.empty?\\n    if first_array.empty?\\n      result.concat(second_array)\\n      second_array.clear\\n    elsif second_array.empty?\\n      result.concat(first_array)\\n      first_array.clear\\n    else\\n      result << if first_array.first < second_array.first\\n                  first_array.shift\\n                else\\n                  second_array.shift\\n                end\\n    end\\n  end\\n  result\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets.split.map(&:to_i)\\n  p merge_sort(list)\\nend\\n\"",
    "merge sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './merge_sort'\\n\\nclass TestMergeSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    merge_sort(input)\\n  end\\nend\\n\"",
    "pancake sort": "\"def pancake_sort(array)\\n  return array if array.length <= 1\\n\\n  (array.length - 1).downto(1) do |index|\\n    max_index = array[0..index].index(array[0..index].max)\\n    next if max_index == index\\n\\n    array[0..max_index] = array[0..max_index].reverse if max_index > 0\\n    array[0..index] = array[0..index].reverse\\n  end\\n  array\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets.split.map(&:to_i)\\n  p pancake_sort(list)\\nend\\n\"",
    "pancake sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './pancake_sort'\\n\\nclass TestInsertionSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    pancake_sort(input)\\n  end\\nend\\n\"",
    "quicksort": "\"def quicksort(arr)\\n  return [] if arr.empty?\\n\\n  # chose a random pivot value\\n  pivot = arr.delete_at(rand(arr.size))\\n  # partition array into 2 arrays and comparing them to each other and eventually returning\\n  # array with the pivot value sorted\\n  left, right = arr.partition(&pivot.method(:>))\\n\\n  # recursively calling the quicksort method on itself\\n  [*quicksort(left), pivot, *quicksort(right)]\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets.split.map(&:to_i)\\n  p quicksort(list)\\nend\\n\"",
    "quicksort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './quicksort'\\n\\nclass TestQuicksort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    quicksort(input)\\n  end\\nend\\n\"",
    "radix sort": "\"# This is a pure ruby implementation of the radix sort algorithm\\n# the function returns collection ordered by ascending\\n# Example:\\n# pry(main)> radix_sort([6, 22, 43, 16, 0, 15, 9])\\n# => [0, 6, 9, 15, 16, 22, 43]\\n\\ndef radix_sort(array, base = 10)\\n  # passes count equals to the number of digits in the longest number\\n  passes = (Math.log(array.minmax.map(&:abs).max) / Math.log(base)).floor + 1\\n  passes.times do |i|\\n    buckets = Array.new(2 * base) { [] }\\n    base_i = base**i\\n\\n    # elements are added to buckets\\n    # according to the current place-value digit\\n    array.each do |j|\\n      n = (j / base_i) % base\\n      n += base if j >= 0\\n      buckets[n] << j\\n    end\\n    array = buckets.flatten\\n  end\\n\\n  array\\nend\\n\"",
    "radix sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './radix_sort'\\n\\nclass TestRadixSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    radix_sort(input)\\n  end\\nend\\n\"",
    "selection sort": "\"def selection_sort(array)\\n  n = array.length - 1\\n  i = 0\\n  while i <= n - 1\\n    smallest = i\\n    j = i + 1\\n    while j <= n\\n      smallest = j if array[j] < array[smallest]\\n      j += 1\\n    end\\n    array[i], array[smallest] = array[smallest], array[i] if i != smallest\\n    i += 1\\n  end\\n  array\\nend\\n\\nif $0 == __FILE__\\n  puts 'Enter a list of numbers separated by space'\\n\\n  list = gets.split.map(&:to_i)\\n  p selection_sort(list)\\nend\\n\"",
    "selection sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './selection_sort'\\n\\nclass TestSelectionSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    selection_sort(input)\\n  end\\nend\\n\"",
    "shell sort": "\"def shell_sort(a)\\n  n = a.length\\n  h = 1\\n\\n  h = (3 * h) + 1 while h < n / 3\\n\\n  while h >= 1\\n    # Logic of insertion sort with inrement steps of \\\"h\\\"\\n    (h...n).each do |i|\\n      j = i\\n      while j >= h\\n        if a[j - h] > a[j]\\n          temp = a[j]\\n          a[j] = a[j - h]\\n          a[j - h] = temp\\n        end\\n        j -= h\\n      end\\n    end\\n    h /= 3\\n  end\\n\\n  a\\nend\\n\"",
    "shell sort test": "\"require 'minitest/autorun'\\nrequire_relative './sort_tests'\\nrequire_relative './shell_sort'\\n\\nclass TestShellSort < Minitest::Test\\n  include SortTests\\n\\n  def sort(input)\\n    shell_sort(input)\\n  end\\nend\\n\"",
    "sort color": "\"# Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\\n#\\n# We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\\n#\\n# Example 1:\\n#\\n# Input: nums = [2,0,2,1,1,0]\\n# Output: [0,0,1,1,2,2]\\n#\\n# Example 2:\\n#\\n# Input: nums = [2,0,1]\\n# Output: [0,1,2]\\n#\\n# Example 3:\\n#\\n# Input: nums = [0]\\n# Output: [0]\\n#\\n# Example 4:\\n#\\n# Input: nums = [1]\\n# Output: [1]\\n\\n# @param {Integer[]} nums\\n# @return {Void} Do not return anything, modify nums in-place instead.\\ndef sort_colors(nums)\\n  bubble_sort(nums)\\nend\\n\\ndef bubble_sort(array)\\n  array_length = array.size\\n  return array if array_length <= 1\\n\\n  loop do\\n    swapped = false\\n\\n    (array_length - 1).times do |i|\\n      if array[i] > array[i + 1]\\n        array[i], array[i + 1] = array[i + 1], array[i]\\n        swapped = true\\n      end\\n    end\\n\\n    break unless swapped\\n  end\\n\\n  array\\nend\\n\\nnums = [2, 0, 2, 1, 1, 0]\\nputs sort_colors(nums)\\n# Output: [0,0,1,1,2,2]\\n\\nnums = [2, 0, 1]\\nputs sort_colors(nums)\\n# Output: [0,1,2]\\n\\nnums = [0]\\nputs sort_colors(nums)\\n# Output: [0]\\n\\nnums = [1]\\nputs sort_colors(nums)\\n# Output: [1]\\n\"",
    "sort tests": "\"# SortTests provides general test cases for sorting function.\\n# By using this module, tests can be implemented like this:\\n#\\n#   class TestBuiltinSort < Minitest::Test\\n#     # SortTests adds some test_* methods.\\n#     include SortTests\\n#\\n#     # SortTests requires sort method which receives an array of integers\\n#     # and returns a sorted one.\\n#     def sort(input)\\n#       input.sort\\n#     end\\n#   end\\n\\nmodule SortTests\\n  def sort(input)\\n    raise NotImplementedError\\n  end\\n\\n  def test_sorted_array\\n    input = [1, 2, 3, 4, 5]\\n    expected = input.dup\\n    assert_equal expected, sort(input)\\n  end\\n\\n  def test_reversed_array\\n    input = [5, 4, 3, 2, 1]\\n    expected = [1, 2, 3, 4, 5]\\n    assert_equal expected, sort(input)\\n  end\\nend\\n\"",
    "3sum": "\"# Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] ..\\n# .. such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\n# Notice that the solution set must not contain duplicate triplets.\\n\\n# Example 1:\\n# Input: nums = [-1,0,1,2,-1,-4]\\n# Output: [[-1,-1,2],[-1,0,1]]\\n\\n# Example 2:\\n# Input: nums = []\\n# Output: []\\n\\n# Example 3:\\n# Input: nums = [0]\\n# Output: []\\n\\n# Constraints:\\n# 0 <= nums.length <= 3000\\n#-105 <= nums[i] <= 105\\n\\n# Two Pointer Approach - O(n) Time / O(1) Space\\n# Return edge cases.\\n# Sort nums, and init ans array\\n# For each |val, index| in nums:\\n# if the current value is the same as last, then go to next iteration\\n# init left and right pointers for two pointer search of the two sum in remaining elements of array\\n# while left < right:\\n# find current sum\\n# if sum > 0, right -= 1\\n# if sum < 0, left += 1\\n# if it's 0, then add the values to the answer array, and set the left pointer to the next valid value ..\\n# .. (left += 1 while nums[left] == nums[left - 1] && left < right)\\n# Return ans[]\\n\\n# @param {Integer[]} nums\\n# @return {Integer[][]}\\ndef three_sum(nums)\\n  # return if length too short\\n  return [] if nums.length < 3\\n\\n  # sort nums, init ans array\\n  nums = nums.sort\\n  ans = []\\n\\n  # loop through nums\\n  nums.each_with_index do |val, ind|\\n    # if the previous value is the same as current, then skip this iteration as it would create duplicates\\n    next if ind > 0 && nums[ind] == nums[ind - 1]\\n\\n    # init & run two pointer search\\n    left = ind + 1\\n    right = nums.length - 1\\n\\n    while left < right\\n      # find current sum\\n      sum = val + nums[left] + nums[right]\\n\\n      # decrease sum if it's too great, increase sum if it's too low\\n      if sum > 0\\n        right -= 1\\n      elsif sum < 0\\n        left += 1\\n      # if it's zero, then add the answer to array and set left pointer to next valid value\\n      else\\n        ans << [val, nums[left], nums[right]]\\n\\n        left += 1\\n\\n        left += 1 while nums[left] == nums[left - 1] && left < right\\n      end\\n    end\\n  end\\n\\n  # return answer\\n  ans\\nend\\n\\nnums = [-1, 0, 1, 2, -1, -4]\\nprint three_sum(nums)\\n# Output: [[-1,-1,2],[-1,0,1]]\\n\\nnums = []\\nprint three_sum(nums)\\n# Output: []\\n\\nnums = [0]\\nprint three_sum(nums)\\n# Output: []\\n\"",
    "add digits": "\"# Challenge name: Add Digits\\n#\\n# Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\\n#\\n# Example:\\n#\\n# Input: 38\\n# Output: 2\\n# Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.\\n#              Since 2 has only one digit, return it.\\n#\\n# Follow up:\\n# Could you do it without any loop/recursion in O(1) runtime?\\n# @param {Integer} num\\n# @return {Integer}\\n\\n#\\n# Approach 1: Recursion\\n#\\n# Time complexity: O(n)\\n#\\ndef add_digits(num)\\n  return num if num.to_s.length < 2\\n\\n  digits_to_sum = num.to_s.split('')\\n  sum = 0\\n  digits_to_sum.each do |num|\\n    sum += num.to_i\\n  end\\n\\n  add_digits(sum)\\nend\\n\\nputs(add_digits(38))\\n# # => 2\\n\\nputs(add_digits(284))\\n# # => 5\\n\\n#\\n# Approach 2: Without recursion\\n#\\ndef add_digits(num)\\n  until num.to_s.length < 2\\n    digits_to_sum = num.to_s.split('')\\n    num = 0\\n\\n    digits_to_sum.each do |number|\\n      num += number.to_i\\n    end\\n  end\\n  num\\nend\\n\\nputs(add_digits(38))\\n# => 2\\n\\nputs(add_digits(284))\\n# => 5\\n\"",
    "find all duplicates in an array": "\"# Find All Duplicates in an Array\\n#\\n# Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array),\\n# some elements appear twice and others appear once.\\n#\\n# Find all the elements that appear twice in this array.\\n#\\n# Could you do it without extra space and in O(n) runtime?\\n#\\n# Example:\\n# Input:\\n# [4,3,2,7,8,2,3,1]\\n#\\n# Output:\\n# [2,3]\\n\\nrequire 'benchmark'\\n\\narray = [4, 3, 2, 7, 8, 2, 3, 1]\\nlong_array = [4, 3, 2, 7, 8, 2, 3, 1] * 100\\n\\n#\\n# Approach: Hash table\\n#\\n\\n#\\n# Complexity Analysis\\n#\\n# Time complexity: O(n) average case.\\n#\\n\\ndef find_duplicates(array)\\n  result_hash = {}\\n  result_array = []\\n\\n  # loop through array and build a hash with counters\\n  # where the key is the array element and the counter is the value\\n  # increase counter when duplicate is found\\n  array.each do |num|\\n    if result_hash[num].nil?\\n      result_hash[num] = 1\\n    else\\n      result_hash[num] += 1\\n    end\\n  end\\n\\n  # loop through hash and look for values > 1\\n  result_hash.each do |k, v|\\n    result_array.push(k) if v > 1\\n  end\\n\\n  # return keys\\n  result_array\\nend\\n\\nBenchmark.bmbm do |x|\\n  x.report('execute algorithm 3') do\\n    print(find_duplicates(array))\\n    print(find_duplicates(long_array))\\n  end\\nend\\n\"",
    "find the highest altitude": "\"# Find the Highest Altitude\\n\\n# There is a biker going on a road trip. The road trip\\n# consists of n + 1 points at different altitudes. The\\n# biker starts his trip on point 0 with altitude equal 0.\\n\\n# You are given an integer array gain of length n where\\n# gain[i] is the net gain in altitude between points i​​​​​​\\n# and i + 1 for all (0 <= i < n).\\n\\n# Return the highest altitude of a point.\\n\\n# Example 1:\\n#\\n# Input: gain = [-5,1,5,0,-7]\\n# Output: 1\\n# Explanation: The altitudes are [0,-5,-4,1,1,-6].\\n# The highest is 1.\\n#\\n\\n#\\n# Approach 1: Creating an additional array\\n#\\n\\n# @param {Integer[]} gain\\n# @return {Integer}\\ndef largest_altitude(gain)\\n  arr = [0]\\n\\n  # calculate altitude array\\n  (1..gain.count).each do |pointer|\\n    sum = arr[pointer - 1] + gain[pointer - 1]\\n    arr.push(sum)\\n  end\\n\\n  # find maximum altitude\\n  max = 0\\n  arr.each { |i| max = i if max < i }\\n  max\\nend\\n\\ngain = [-5, 1, 5, 0, -7]\\nlargest_altitude(gain)\\n# Output: 1\\n\\ngain = [-4, -3, -2, -1, 4, 3, 2]\\nlargest_altitude(gain)\\n# Output: 0\\n\\n#\\n# Approach 2: Without creating an additional array\\n#\\n\\n# @param {Integer[]} gain\\n# @return {Integer}\\ndef largest_altitude(gain)\\n  max_alt = alt = 0\\n\\n  (0...gain.count).each do |i|\\n    alt += gain[i]\\n\\n    max_alt = alt if max_alt < alt\\n  end\\n\\n  max_alt\\nend\\n\\ngain = [-5, 1, 5, 0, -7]\\nlargest_altitude(gain)\\n# Output: 1\\n\\ngain = [-4, -3, -2, -1, 4, 3, 2]\\nlargest_altitude(gain)\\n# Output: 0\\n\"",
    "fizz buzz": "\"# Write a program that outputs the string representation of numbers\\n# from 1 to n. But for multiples of three it should output “Fizz”\\n# instead of the number and for the multiples of five output “Buzz”.\\n# For numbers which are multiples of both three and five output\\n# “FizzBuzz”.\\n\\n#\\n# Approach 1: Hash it!\\n#\\n\\n# Complexity Analysis\\n\\n# Time Complexity: O(N)\\n# Space Complexity: O(1)\\n\\n# @param {Integer} n\\n# @return {String[]}\\ndef fizz_buzz(n, fizz_buzz = { 3 => 'Fizz', 5 => 'Buzz' })\\n  n.times.map do |i|\\n    i += 1\\n    num_str = ''\\n\\n    fizz_buzz.each do |key, value|\\n      num_str += value if i % key == 0\\n    end\\n\\n    num_str.empty? ? i.to_s : num_str\\n  end\\nend\\n\\nn = 15\\nputs(fizz_buzz(n))\\n\"",
    "get products of all other elements": "\"# Arrays - Get Products of all other elements in Ruby\\n\\n# Algorithm challenge description:\\n# Given an array of integers, return a new array such that\\n# each element at index `i` of the new array is the product of\\n# all the numbers in the original array except the one at `i`.\\n\\n#\\n# This file solves the algorithm in 3 approaches:\\n#\\n# 1. Brute force\\n# 2. Left and Right product lists\\n# 3. O(1) space approach\\n#\\n\\n#\\n# 1. Brute force solution\\n#\\ndef calculate_products_of_all_other_elements(nums)\\n  product_of_other_elements = Array.new(nums.count, 1)\\n\\n  nums.count.times do |i|\\n    nums.count.times do |j|\\n      next if i == j\\n\\n      product_of_other_elements[i] = product_of_other_elements[i] * nums[j]\\n    end\\n  end\\n\\n  product_of_other_elements\\nend\\n\\nputs(calculate_products_of_all_other_elements([1, 2, 3]))\\n\\n#\\n# Approach 2: Left and Right product lists\\n#\\n\\n# Complexity analysis\\n#\\n# Time complexity: O(N) where N represents the number of elements in the input\\n# array. We use one iteration to construct the array prefix_products, one to construct\\n# the array suffix_products and one last to construct the answeranswer array using L and R.\\n# Space complexity: O(N) used up by the two intermediate arrays that\\n# we constructed to keep track of product of elements to the left and right.\\n\\n# Generates prefix products\\n# prefix_products[i] contains the product of all the elements to the left\\n# Note: for the element at index '0', there are no elements to the left,\\n# so the prefix_products[0] would be 1\\ndef build_prefix_products(nums)\\n  prefix_products = []\\n\\n  nums.each do |num|\\n    prefix_products << if prefix_products.count > 0\\n                         prefix_products.last * num\\n                       else\\n                         num\\n                       end\\n  end\\n\\n  prefix_products\\nend\\n\\n# Generates suffix products\\n# suffix_products[i] contains the product of all the elements to the right\\n# Note: for the element at index 'length - 1', there are no elements to the right,\\n# so the suffix_products[length - 1] would be 1\\ndef build_suffix_products(nums)\\n  suffix_products = []\\n\\n  nums.reverse.each do |num|\\n    suffix_products << if suffix_products.count > 0\\n                         suffix_products.last * num\\n                       else\\n                         num\\n                       end\\n  end\\n\\n  suffix_products\\nend\\n\\n# Builds output\\n# For the first element, suffix_products[i] would be product except self\\n# For the last element of the array, product except self would be prefix_products[i]\\n# Else, multiple product of all elements to the left and to the right\\ndef output(prefix_products, suffix_products, nums)\\n  result = []\\n\\n  nums.count.times do |index|\\n    result << if index == 0\\n                suffix_products[index + 1]\\n              elsif index == nums.count - 1\\n                prefix_products[index - 1]\\n              else\\n                (prefix_products[index - 1] * suffix_products[index + 1])\\n              end\\n  end\\n\\n  result\\nend\\n\\n# Generate result from the product of prefixes and suffixes\\ndef products(nums)\\n  prefix_products = build_prefix_products(nums)\\n  suffix_products = build_suffix_products(nums)\\n  suffix_products = suffix_products.reverse\\n\\n  output(prefix_products, suffix_products, nums)\\nend\\n\\nputs(products([1, 2, 3]))\\n# => [6, 3, 2]\\n\\n#\\n# Approach 3: O(1) space approach\\n#\\n\\n# This approach is essentially an extension of the approach 2.\\n# Basically, we will be using the output array as one of L or R and we will\\n# be constructing the other one on the fly.\\n\\n# Complexity analysis\\n#\\n# Time complexity: O(N) where N represents the number of elements in the input\\n# array. We use one iteration to construct the array L, one to update the array\\n# answer.\\n\\n# Space complexity: O(1) since don't use any additional array for our\\n# computations. The problem statement mentions that using the answer\\n# array doesn't add to the space complexity.\\n\\ndef products(nums)\\n  return [] if nums.count < 2\\n\\n  res = [1]\\n\\n  # res[i] contains the product of all the elements to the left\\n  # Note: for the element at index '0', there are no elements to the left,\\n  # so the res[0] would be 1\\n  (0..(nums.count - 2)).each do |i|\\n    num = nums[i]\\n    res << num * res[i]\\n  end\\n\\n  # product contains the product of all the elements to the right\\n  # Note: for the element at index 'length - 1', there are no elements to the right,\\n  # so the product would be 1\\n  product = 1\\n\\n  (nums.count - 1).downto(1) do |i|\\n    num = nums[i]\\n    # For the index 'i', product would contain the\\n    # product of all elements to the right. We update product accordingly.\\n    res[i - 1] *= (product * num)\\n    product *= num\\n  end\\n\\n  res\\nend\\n\\nputs(products([1, 2, 3]))\\n# => [6, 3, 2]\\n\"",
    "good pairs": "\"# Challenge name: Number of good pairs\\n#\\n# Given an array of integers nums.\\n# A pair (i,j) is called good if nums[i] == nums[j] and i < j.\\n# Return the number of good pairs.\\n#\\n# @param {Integer[]} nums\\n# @return {Integer}\\n#\\n\\n#\\n# Approach 1: Hash\\n#\\n# Time Complexity: O(n)\\ndef num_identical_pairs(nums)\\n  hash = Hash.new(0)\\n\\n  nums.each do |num|\\n    hash[num] = hash[num] + 1\\n  end\\n\\n  counter = 0\\n  # Count how many times each number appears.\\n  # If a number appears n times, then n * (n – 1) / 2 good pairs\\n  # can be made with this number.\\n  hash.values.each do |val|\\n    counter += (val * (val - 1) / 2)\\n  end\\n\\n  counter\\nend\\n\\nnums = [1, 2, 3, 1, 1, 3]\\nputs(num_identical_pairs(nums))\\n# Output: 4\\n\\nnums = [1, 1, 1, 1]\\nputs(num_identical_pairs(nums))\\n# Output: 6\\n\\nnums = [1, 2, 3]\\nputs(num_identical_pairs(nums))\\n# Output: 0\\n\"",
    "intersection": "\"# Challenge name: Intersection of two arrays ii\\n#\\n# Given two arrays, write a function to compute their intersection.\\n#\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @return {Integer[]}\\n\\n#\\n# Approach 1: Brute Force\\n#\\n# Time Complexity: O(n^2)\\n#\\ndef intersect(arr1, arr2)\\n  result = []\\n\\n  if arr1.length < arr2.length\\n    shorter = arr1\\n    longer = arr2\\n  else\\n    shorter = arr2\\n    longer = arr1\\n  end\\n\\n  shorter.each do |matcher|\\n    longer.each do |number|\\n      next if number != matcher\\n\\n      result.push(number)\\n      break\\n    end\\n  end\\n\\n  result\\nend\\n\\nnums1 = [1, 2, 2, 1]\\nnums2 = [2, 2]\\nputs intersect(nums1, nums2)\\n# => [2,2]\\n\\nnums1 = [4, 9, 5]\\nnums2 = [9, 4, 9, 8, 4]\\nputs intersect(nums1, nums2)\\n# => [4,9]\\n\\n#\\n# Approach 2: Hash\\n#\\n# Complexity Analysis\\n#\\n# Time Complexity: O(n+m), where n and m are the lengths of the arrays.\\n# We iterate through the first, and then through the second array; insert\\n# and lookup operations in the hash map take a constant time.\\n#\\n# Space Complexity: O(min(n,m)). We use hash map to store numbers (and their\\n# counts) from the smaller array.\\n#\\ndef intersect(arr1, arr2)\\n  result = []\\n\\n  hash = Hash.new(0)\\n\\n  arr2.each { |num| hash[num] += 1 }\\n\\n  arr1.each do |num|\\n    if hash.has_key?(num)\\n      result << num if hash[num] >= 1\\n      hash[num] -= 1\\n    end\\n  end\\n\\n  result\\nend\\n\\nnums1 = [1, 2, 2, 1]\\nnums2 = [2, 2]\\nputs intersect(nums1, nums2)\\n# => [2,2]\\n\\nnums1 = [4, 9, 5]\\nnums2 = [9, 4, 9, 8, 4]\\nputs intersect(nums1, nums2)\\n# => [4,9]\\n\\n#\\n# Approach 3: Two Pointers\\n#\\n# Complexity analysis:\\n\\n# Time Complexity: O(nlogn + mlogm), where n and m are the lengths of the arrays. We sort two arrays independently and then do a linear scan.\\n# Space Complexity: from O(logn+logm) to O(n+m), depending on the implementation of the sorting algorithm.\\n#\\ndef intersect(nums1, nums2)\\n  result = []\\n  p1 = 0\\n  p2 = 0\\n  nums1 = nums1.sort\\n  nums2 = nums2.sort\\n  while p1 < nums1.length && p2 < nums2.length\\n    if nums1[p1] < nums2[p2]\\n      p1 += 1\\n    elsif nums1[p1] > nums2[p2]\\n      p2 += 1\\n    elsif nums1[p1] == nums2[p2]\\n      result << nums1[p1]\\n      p1 += 1\\n      p2 += 1\\n    end\\n  end\\n\\n  result\\nend\\nnums1 = [1, 2, 2, 1]\\nnums2 = [2, 2]\\nintersect(nums1, nums2)\\n\\nnums1 = [1, 2, 2, 1]\\nnums2 = [2, 2]\\nputs intersect(nums1, nums2)\\n# => [2,2]\\n\\nnums1 = [4, 9, 5]\\nnums2 = [9, 4, 9, 8, 4]\\nputs intersect(nums1, nums2)\\n# => [4,9]\\n\"",
    "maximum product subarray": "\"# Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.\\n# It is guaranteed that the answer will fit in a 32-bit integer.\\n# A subarray is a contiguous subsequence of the array.\\n\\n# Example 1:\\n# Input: nums = [2,3,-2,4]\\n# Output: 6\\n# Explanation: [2,3] has the largest product 6.\\n\\n# Example 2:\\n# Input: nums = [-2,0,-1]\\n# Output: 0\\n# Explanation: The result cannot be 2, because [-2,-1] is not a subarray.\\n\\n# Constraints:\\n# 1 <= nums.length <= 2 * 104\\n#-10 <= nums[i] <= 10\\n# The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\n\\n# Dynamic Programming Approach (Kadane's Algorithm) - O(n) Time / O(1) Space\\n# Track both current minimum and current maximum (Due to possibility of multiple negative numbers)\\n# Answer is the highest value of current maximum\\n\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef max_product(nums)\\n  return nums[0] if nums.length == 1\\n\\n  cur_min = 1\\n  cur_max = 1\\n  max = -11\\n\\n  nums.each do |val|\\n    tmp_cur_max = cur_max\\n    cur_max = [val, val * cur_max, val * cur_min].max\\n    cur_min = [val, val * tmp_cur_max, val * cur_min].min\\n\\n    max = [max, cur_max].max\\n  end\\n\\n  max\\nend\\n\\nnums = [2, 3, -2, 4]\\nputs max_product(nums)\\n# Output: 6\\n\\nnums = [-2, 0, -1]\\nputs max_product(nums)\\n# Output: 0\\n\"",
    "maximum subarray": "\"# Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\\n# A subarray is a contiguous part of an array.\\n\\n# Example 1:\\n# Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\\n# Output: 6\\n# Explanation: [4,-1,2,1] has the largest sum = 6.\\n\\n# Example 2:\\n# Input: nums = [1]\\n# Output: 1\\n\\n# Example 3:\\n# Input: nums = [5,4,-1,7,8]\\n# Output: 23\\n\\n# Constraints:\\n# 1 <= nums.length <= 3 * 104\\n# -105 <= nums[i] <= 105\\n\\n# Dynamic Programming Approach (Kadane's Algorithm) - O(n) Time / O(1) Space\\n#\\n# Init max_sum as first element\\n# Return first element if the array length is 1\\n# Init current_sum as 0\\n# Iterate through the array:\\n# if current_sum < 0, then reset it to 0 (to eliminate any negative prefixes)\\n# current_sum += num\\n# max_sum = current_sum if current_sum is greater than max_sum\\n# Return max_sum\\n\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef max_sub_array(nums)\\n  # initialize max sum to first number\\n  max_sum = nums[0]\\n\\n  # return first number if array length is 1\\n  return max_sum if nums.length == 1\\n\\n  # init current sum to 0\\n  current_sum = 0\\n\\n  # iterate through array, reset current_sum to 0 if it ever goes below 0, track max_sum with highest current_sum\\n  nums.each do |num|\\n    current_sum = 0 if current_sum < 0\\n\\n    current_sum += num\\n\\n    max_sum = [max_sum, current_sum].max\\n  end\\n\\n  max_sum\\nend\\n\\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\\nprint max_sub_array(nums)\\n# Output: 6\\n\\nnums = [1]\\nprint max_sub_array(nums)\\n# Output: 1\\n\\nnums = [5, 4, -1, 7, 8]\\nprint max_sub_array(nums)\\n# Output: 23\\n\"",
    "max 69 number": "\"# Challenge name: Maximum 69 number\\n#\\n# Given a positive integer num consisting only of digits 6 and 9.\\n# Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).\\n#\\n# Example 1:\\n# Input: num = 9669\\n# Output: 9969\\n# Explanation:\\n# Changing the first digit results in 6669.\\n# Changing the second digit results in 9969.\\n# Changing the third digit results in 9699.\\n# Changing the fourth digit results in 9666.\\n# The maximum number is 9969.\\n#\\n# Example 2:\\n# Input: num = 9996\\n# Output: 9999\\n# Explanation: Changing the last digit 6 to 9 results in the maximum number.\\n\\n#\\n# Approach 1: Logical Approach\\n# Explanation: Changing the first available 6 to a 9 will give the max number\\n#\\ndef max_number(num)\\n  arr = num.to_s.split('')\\n\\n  arr.each_with_index do |num, i|\\n    if num == '6'\\n      arr[i] = '9'\\n      return arr.join.to_i\\n    end\\n  end\\nend\\n\\nputs max_number(9669)\\n# => 9969\\n\\nputs max_number(9996)\\n# => 9999\\n\"",
    "next greater element": "\"# You are given two integer arrays nums1 and nums2 both of unique elements, where nums1 is a subset of nums2.\\n#\\n# Find all the next greater numbers for nums1's elements in the corresponding places of nums2.\\n#\\n# The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, return -1 for this number.\\n\\n# Example 1:\\n#\\n# Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\\n# Output: [-1,3,-1]\\n#\\n# Explanation:\\n# For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.\\n# For number 1 in the first array, the next greater number for it in the second array is 3.\\n# For number 2 in the first array, there is no next greater number for it in the second array, so output -1.\\n#\\n# Example 2:\\n#\\n# Input: nums1 = [2,4], nums2 = [1,2,3,4]\\n# Output: [3,-1]\\n#\\n# Explanation:\\n# For number 2 in the first array, the next greater number for it in the second array is 3.\\n# For number 4 in the first array, there is no next greater number for it in the second array, so output -1.\\n\\n#\\n# Approach: Brute Force\\n#\\n\\n# Complexity Analysis\\n#\\n# Time complexity: O(m*n). The complete nums1 array (of size n) needs to be scanned for all the m elements of nums2 in the worst case.\\n# Space complexity: O(1). No additional space since we're swapping elements in nums1 and returning the input array.\\n\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @return {Integer[]}\\ndef next_greater_element(nums1, nums2)\\n  nums1.each_with_index do |nums1_value, pointer1|\\n    max = 0\\n    pos_nums2 = nums2.find_index(nums1_value)\\n\\n    nums2[pos_nums2..nums2.count].each do |nums2_value|\\n      if nums2_value > nums1_value\\n        max = nums2_value\\n        break\\n      end\\n    end\\n\\n    nums1[pointer1] = (nums1_value < max ? max : -1)\\n  end\\n\\n  nums1\\nend\\n\\nnums1 = [4, 1, 2]\\nnums2 = [1, 3, 4, 2]\\nprint next_greater_element(nums1, nums2)\\n# Output: [-1,3,-1]\\n\\nnums1 = [2, 4]\\nnums2 = [1, 2, 3, 4]\\nprint next_greater_element(nums1, nums2)\\n# Output: [3,-1]\\n\"",
    "remove elements": "\"# Arrays - Remove Elements\\n#\\n# Given an array nums and a value val, remove all instances of that value in-place and return the new length.\\n# Do not allocate extra space for another array,\\n# you must do this by modifying the input array in-place with O(1) extra memory.\\n# The order of elements can be changed. It doesn't matter what you leave beyond the new length.\\n#\\n# Example\\n#\\n# Input: nums = [3,2,2,3], val = 3\\n# Output: 2, nums = [2,2]\\n#\\n# Input: nums = [0,1,2,2,3,0,4,2], val = 2\\n# Output: 5, nums = [0,1,4,0,3]\\n\\n#\\n# Approach 1: Use `delete_if` Ruby method\\n#\\n# Time complexity: O(n)\\n#\\ndef remove_elements(nums, val)\\n  nums.delete_if { |num| num == val }\\n  nums.length\\nend\\n\\nputs remove_elements([3, 2, 2, 3], 3)\\n# => 2\\nputs remove_elements([0, 1, 2, 2, 3, 0, 4, 2], 2)\\n# => 5\\n\\n#\\n# Approach 2: Use `delete_at`, `unshift`, and `shift` Ruby method\\n#\\n# Time complexity: O(n)\\n#\\ndef remove_elements(nums, val)\\n  result_length = nums.length\\n  shift_length = 0\\n  nums.each_with_index do |num, i|\\n    next unless num == val\\n\\n    nums.delete_at(i)\\n    nums.unshift('removed')\\n    result_length -= 1\\n    shift_length += 1\\n  end\\n  nums.shift(shift_length)\\n  result_length\\nend\\n\\nputs remove_elements([3, 2, 2, 3], 3)\\n# => 2\\nputs remove_elements([0, 1, 2, 2, 3, 0, 4, 2], 2)\\n# => 5\\n\\n#\\n# Approach 3: Two-pointers\\n#\\n\\n# Complexity analysis\\n#\\n# Time complexity: O(n).\\n# Assume the array has a total of n elements,\\n# both pointer1 and pointer2 traverse at most 2n steps.\\n#\\n# Space complexity: O(1).\\n\\ndef remove_element(nums, val)\\n  pointer1 = 0\\n\\n  nums.each_with_index do |num, pointer2|\\n    if val != num\\n      nums[pointer1] = nums[pointer2]\\n      pointer1 += 1\\n    end\\n  end\\n\\n  pointer1\\nend\\n\\nputs remove_elements([3, 2, 2, 3], 3)\\n# => 2\\nputs remove_elements([0, 1, 2, 2, 3, 0, 4, 2], 2)\\n# => 5\\n\\n#\\n# Approach 4: Two-pointers (Optimized)\\n#\\n\\n# Complexity analysis\\n#\\n# Time complexity: O(n). Both pointer1 and pointer2 traverse at most n steps.\\n# In this approach, the number of assignment operations is equal to the\\n# number of elements to remove.\\n#\\n# Space complexity: O(1)\\n\\ndef remove_element(nums, val)\\n  pointer1 = 0\\n  pointer2 = nums.length\\n\\n  while pointer1 < pointer2\\n    if nums[pointer1] == val\\n      pointer2 -= 1\\n      nums[pointer1] = nums[pointer2]\\n    else\\n      pointer1 += 1\\n    end\\n  end\\n\\n  pointer1\\nend\\n\\nputs remove_elements([3, 2, 2, 3], 3)\\n# => 2\\nputs remove_elements([0, 1, 2, 2, 3, 0, 4, 2], 2)\\n# => 5\\n\"",
    "richest customer wealth": "\"# Challenge name: Richest Customer Wealth\\n#\\n# You are given an m x n integer grid accounts where accounts[i][j]\\n# is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank.\\n#\\n# Return the wealth that the richest customer has.\\n# A customer's wealth is the amount of money they have in all\\n# their bank accounts. The richest customer is the customer that\\n# has the maximum wealth.\\n#\\n# Example 1:\\n# Input: accounts = [[1,2,3],[3,2,1]]\\n# Output: 6\\n# Explanation:\\n# 1st customer has wealth = 1 + 2 + 3 = 6\\n# 2nd customer has wealth = 3 + 2 + 1 = 6\\n# Both customers are considered the richest with a wealth of 6\\n# each, so return 6.\\n#\\n# Example 2:\\n# Input: accounts = [[1,5],[7,3],[3,5]]\\n# Output: 10\\n# Explanation:\\n# 1st customer has wealth = 6\\n# 2nd customer has wealth = 10\\n# 3rd customer has wealth = 8\\n# The 2nd customer is the richest with a wealth of 10.\\n#\\n# Example 3:\\n# Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]\\n# Output: 17\\n\\n#\\n# Approach: Hash\\n#\\n# Time Complexity: O(n)\\n#\\ndef find_richest_customer_wealth(accounts)\\n  result_hash = {}\\n  accounts.each_with_index do |customer, i|\\n    result_hash[i] = customer.sum\\n  end\\n\\n  highest_value = 0\\n  result_hash.each do |_k, v|\\n    highest_value = v if v > highest_value\\n  end\\n\\n  highest_value\\nend\\n\\nputs find_richest_customer_wealth([[1, 2, 3], [3, 2, 1]])\\n# => 6\\nputs find_richest_customer_wealth([[1, 5], [7, 3], [3, 5]])\\n# => 10\\nputs find_richest_customer_wealth([[2, 8, 7], [7, 1, 3], [1, 9, 5]])\\n# => 17\\n\"",
    "shortest word distance": "\"# Shortest Word Distance\\n# Given a list of words and two words word1 and word2,\\n# return the shortest distance between these two words in the list.\\n# @param {String[]} words\\n# @param {String} word1\\n# @param {String} word2\\n# @return {Integer}\\n\\ndef shortest_distance(words, word1, word2)\\n  return 0 if word1 == word2\\n  return 0 unless words.include?(word1) && words.include?(word2)\\n\\n  minimum_distance = words.length\\n  words.each_with_index do |outer_value, outer_index|\\n    words.each_with_index do |inner_value, inner_index|\\n      if ((inner_value == word1 && outer_value == word2) || (inner_value == word2 && outer_value == word1)) && (minimum_distance > (outer_index - inner_index).abs)\\n        minimum_distance = (outer_index - inner_index).abs\\n      end\\n    end\\n  end\\n  minimum_distance\\nend\\n\\nwords = %w[practice makes perfect coding makes]\\nword1 = 'coding'\\nword2 = 'practice'\\nputs(shortest_distance(words, word1, word2))\\n# Output: 3\\nwords = %w[practice makes perfect coding makes]\\nword1 = 'makes'\\nword2 = 'coding'\\nputs(shortest_distance(words, word1, word2))\\n# Output: 1\\n\"",
    "shuffle array": "\"# Challenge name: Shuffle the array\\n#\\n# Given the array nums consisting of 2n elements\\n# in the form [x1,x2,...,xn,y1,y2,...,yn].\\n# Return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n#\\n# Example 1:\\n# Input: nums = [2,5,1,3,4,7], n = 3\\n# Output: [2,3,5,4,1,7]\\n# Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].\\n#\\n# Example 2:\\n# Input: nums = [1,2,3,4,4,3,2,1], n = 4\\n# Output: [1,4,2,3,3,2,4,1]\\n#\\n# Example 3:\\n# Input: nums = [1,1,2,2], n = 2\\n# Output: [1,2,1,2]\\n#\\n# @param {Integer[]} nums\\n# @param {Integer} n\\n# @return {Integer[]}\\n\\n#\\n# Approach 1: New Array\\n#\\n# Time Complexity: O(N)\\n#\\ndef shuffle(nums, n)\\n  result = []\\n  (0..n - 1).count do |i|\\n    result.push(nums[i], nums[i + n])\\n  end\\n  result\\nend\\n\\nnums = [2, 5, 1, 3, 4, 7]\\nn = 3\\nprint(shuffle(nums, n))\\n# Output: [2,3,5,4,1,7]\\nnums = [1, 2, 3, 4, 4, 3, 2, 1]\\nn = 4\\nprint(shuffle(nums, n))\\n# Output: [1,4,2,3,3,2,4,1]\\nnums = [1, 1, 2, 2]\\nn = 2\\nprint(shuffle(nums, n))\\n# Output: [1,2,1,2]\\n\\n#\\n# Approach 2: Use Ruby methods .insert() and .delete_at()\\n#\\n# Time Complexity: O(N)\\n#\\n\\ndef shuffle(nums, n)\\n  current_index = 1\\n  (0..n - 1).each do |i|\\n    nums.insert(current_index, nums.delete_at(i + n))\\n    current_index += 2\\n  end\\n  nums\\nend\\n\\nnums = [2, 5, 1, 3, 4, 7]\\nn = 3\\nprint(shuffle(nums, n))\\n# Output: [2,3,5,4,1,7]\\nnums = [1, 2, 3, 4, 4, 3, 2, 1]\\nn = 4\\nprint(shuffle(nums, n))\\n# Output: [1,4,2,3,3,2,4,1]\\nnums = [1, 1, 2, 2]\\nn = 2\\nprint(shuffle(nums, n))\\n# Output: [1,2,1,2]\\n\\n#\\n# Approach 3: Two Pointers\\n#\\n# Time Complexity: O(N)\\n#\\n\\ndef shuffle(nums, n)\\n  result = []\\n  p1 = 0\\n  p2 = n\\n\\n  while p1 < n\\n    result.push(nums[p1], nums[p2])\\n    p1 += 1\\n    p2 += 1\\n  end\\n\\n  result\\nend\\n\\nnums = [2, 5, 1, 3, 4, 7]\\nn = 3\\nprint(shuffle(nums, n))\\n# Output: [2,3,5,4,1,7]\\nnums = [1, 2, 3, 4, 4, 3, 2, 1]\\nn = 4\\nprint(shuffle(nums, n))\\n# Output: [1,4,2,3,3,2,4,1]\\nnums = [1, 1, 2, 2]\\nn = 2\\nprint(shuffle(nums, n))\\n# Output: [1,2,1,2]\\n\"",
    "single number": "\"# Challenge name: Single Number\\n#\\n# Given a non-empty array of integers nums, every element appears twice\\n# except for one. Find that single one.\\n#\\n# Follow up: Could you implement a solution with a linear runtime\\n# complexity and without using extra memory?\\n#\\n# @param {Integer[]} nums\\n# @return {Integer}\\n\\n#\\n# Approach 1: Hash map\\n#\\n# Time Complexity: O(n)\\n#\\ndef single_number(nums)\\n  result_hash = {}\\n  nums.each do |num|\\n    if result_hash[num]\\n      result_hash[num] += 1\\n    else\\n      result_hash[num] = 1\\n    end\\n  end\\n\\n  result_hash.each do |k, v|\\n    return k if v == 1\\n  end\\nend\\n\\nnums = [2, 2, 1]\\nputs(single_number(nums))\\n# Output: 1\\nnums = [4, 1, 2, 1, 2]\\nputs(single_number(nums))\\n# Output: 4\\nnums = [1]\\nputs(single_number(nums))\\n# Output: 1\\n\\n#\\n# Approach 2: Use Ruby .count()\\n#\\n# Time Complexity: O(n^2)\\n#\\ndef single_number(nums)\\n  nums.find do |num|\\n    nums.count(num) == 1\\n  end\\nend\\n\\nnums = [2, 2, 1]\\nputs(single_number(nums))\\n# Output: 1\\nnums = [4, 1, 2, 1, 2]\\nputs(single_number(nums))\\n# Output: 4\\nnums = [1]\\nputs(single_number(nums))\\n# Output: 1\\n\"",
    "sorted arrays intersection": "\"# Given three integer arrays arr1, arr2 and arr3 sorted in strictly increasing order, return a sorted array of only the integers that appeared in all three arrays.\\n#\\n# Example 1:\\n#\\n# Input: arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8]\\n# Output: [1,5]\\n# Explanation: Only 1 and 5 appeared in the three arrays.\\n#\\n# Example 2:\\n#\\n# Input: arr1 = [197,418,523,876,1356], arr2 = [501,880,1593,1710,1870], arr3 = [521,682,1337,1395,1764]\\n# Output: []\\n#\\n#\\n\\n#\\n# Approach: Two-pointers\\n#\\n\\n# Complexity Analysis\\n#\\n# Time Complexity: O(n), where n is the total length of all of the\\n# input arrays.\\n# Space Complexity: O(1), as we only initiate three integer variables\\n# using constant space.\\n\\n# @param {Integer[]} arr1\\n# @param {Integer[]} arr2\\n# @param {Integer[]} arr3\\n# @return {Integer[]}\\ndef sorted_arrays_intersection(arr1, arr2, arr3)\\n  result = []\\n\\n  # prepare three pointers to iterate through three arrays\\n  # p1, p2, and p3 point to the beginning of arr1, arr2, and arr3 accordingly\\n  p1 = p2 = p3 = 0\\n\\n  while (p1 < arr1.count) && (p2 < arr2.count) && (p3 < arr3.count)\\n    if arr1[p1] == arr2[p2] && arr1[p1] == arr3[p3]\\n      result.push(arr1[p1])\\n\\n      p1 += 1\\n      p2 += 1\\n      p3 += 1\\n    elsif arr1[p1] < arr2[p2]\\n      p1 += 1\\n    elsif arr2[p2] < arr3[p3]\\n      p2 += 1\\n    else\\n      p3 += 1\\n    end\\n  end\\n\\n  result\\nend\\n\\narr1 = [1, 2, 3, 4, 5]\\narr2 = [1, 2, 5, 7, 9]\\narr3 = [1, 3, 4, 5, 8]\\nprint(sorted_arrays_intersection(arr1, arr2, arr3))\\n# Output: [1,5]\\n\\narr1 = [197, 418, 523, 876, 1356]\\narr2 = [501, 880, 1593, 1710, 1870]\\narr3 = [521, 682, 1337, 1395, 1764]\\nprint(sorted_arrays_intersection(arr1, arr2, arr3))\\n# Output: []\\n\"",
    "sort squares of an array": "\"# Arrays - Sorted Squares\\n\\n# Algorithm challenge description:\\n# Given an integer array nums sorted in non-decreasing order\\n# return an array of the squares of each number sorted in non-decreasing order.\\n# Input: [4, -1, -9, 2]\\n# Output: [1, 4, 16, 81]\\n\\n#\\n# Approach 1: is using Ruby function (for sure)!\\n#\\n\\ndef sorted_squares(nums)\\n  nums.map! { |num| num**2 }.sort\\nend\\nprint(sorted_squares([4, -1, -9, 2]))\\n\\n#\\n# Approach 2: is using bubble sort\\n#\\n\\ndef bubble_sort(array)\\n  array_length = array.size\\n  return array if array_length <= 1\\n\\n  loop do\\n    swapped = false\\n    (array_length - 1).times do |i|\\n      if array[i] > array[i + 1]\\n        array[i], array[i + 1] = array[i + 1], array[i]\\n        swapped = true\\n      end\\n    end\\n    break unless swapped\\n  end\\n  array\\nend\\n\\n#\\n# Time complexity: O(n logn), where n is the length of the array.\\n# Space complexity: O(n) or O(logn)\\n#\\n\\ndef sorted_squares(nums)\\n  # This takes O(n)\\n  nums.map! { |num| num**2 }\\n  # This can take Ο(n logn)\\n  bubble_sort(nums)\\nend\\nprint(sorted_squares([4, -1, -9, 2]))\\n\\n#\\n# Approach 3: solving without ruby sort method. Using two-pointers\\n#\\n# Time complexity: O(n), where n is the length of the array.\\n# Space complexity: O(n), if you take output into account and O(1) otherwise.\\n#\\ndef sorted_squares(nums)\\n  p1 = 0\\n  p2 = nums.length - 1\\n  # since we're returing the result in ascending order,\\n  # we'll fill in the array from the end\\n  max_index = p2\\n  output = []\\n  while p1 < p2\\n    nums1_square = nums[p1] * nums[p1]\\n    nums2_square = nums[p2] * nums[p2]\\n    if nums1_square < nums2_square\\n      output[max_index] = nums2_square\\n      p2 -= 1\\n    elsif nums1_square > nums2_square\\n      output[max_index] = nums1_square\\n      p1 += 1\\n    else\\n      output[max_index] = nums1_square\\n      max_index -= 1\\n      output[max_index] = nums2_square\\n      p1 += 1\\n      p2 -= 1\\n    end\\n    max_index -= 1\\n  end\\n  # to account for any remaining value left in the input array\\n  output[max_index] = nums[p1] * nums[p2] if p1 == p2\\n  output\\nend\\n\\nprint(sorted_squares([4, -1, -9, 2]))\\n\"",
    "sudoku": "\"# Challenge name: Valid Sudoku\\n\\n# Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\\n# Each row must contain the digits 1-9 without repetition.\\n# Each column must contain the digits 1-9 without repetition.\\n# Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\\n\\n# @param {Character[][]} board\\n# @return {Boolean}\\n\\n#\\n# Approach 1: Hash & Brute Force\\n#\\ndef is_valid_sudoku(board)\\n  rows = []\\n  columns = []\\n  grids = []\\n\\n  # make each row into a hash to track for duplicated values\\n  board.each do |row|\\n    row_hash = Hash.new(0)\\n    row.each do |num|\\n      next if num == '.'\\n\\n      row_hash[num] += 1\\n    end\\n    rows << row_hash\\n  end\\n\\n  # check each row hash for duplicated value\\n  rows.each do |row|\\n    row.each do |_k, v|\\n      return false if v > 1\\n    end\\n  end\\n\\n  # make each column into a hash to track for duplicated values\\n  (0..8).each do |i|\\n    column_hash = Hash.new(0)\\n    board.each do |row|\\n      next if row[i] == '.'\\n\\n      column_hash[row[i]] += 1\\n      columns << column_hash\\n    end\\n  end\\n\\n  # check each column hash for duplicated value\\n  columns.each do |column|\\n    column.each do |_k, v|\\n      return false if v > 1\\n    end\\n  end\\n\\n  # make each 3x3 grid into a hash to track for duplicated values\\n  (0..2).each do |i|\\n    grid_hash = Hash.new(0)\\n    board.first(3).each do |row|\\n      next if row[i] == '.'\\n\\n      grid_hash[row[i]] += 1\\n      grids << grid_hash\\n    end\\n    board[3..5].each do |row|\\n      next if row[i] == '.'\\n\\n      grid_hash[row[i]] += 1\\n      grids << grid_hash\\n    end\\n    board.each do |row|\\n      next if row[i] == '.'\\n\\n      grid_hash[row[i]] += 1\\n      grids << grid_hash\\n    end\\n  end\\n  (3..5).each do |i|\\n    grid_hash = Hash.new(0)\\n    board.first(3).each do |row|\\n      next if row[i] == '.'\\n\\n      grid_hash[row[i]] += 1\\n      grids << grid_hash\\n    end\\n    board[3..5].each do |row|\\n      next if row[i] == '.'\\n\\n      grid_hash[row[i]] += 1\\n      grids << grid_hash\\n    end\\n    board.each do |row|\\n      next if row[i] == '.'\\n\\n      grid_hash[row[i]] += 1\\n      grids << grid_hash\\n    end\\n  end\\n  (6..8).last(3).each do |i|\\n    grid_hash = Hash.new(0)\\n    board.first(3).each do |row|\\n      next if row[i] == '.'\\n\\n      grid_hash[row[i]] += 1\\n      grids << grid_hash\\n    end\\n    board[3..5].each do |row|\\n      next if row[i] == '.'\\n\\n      grid_hash[row[i]] += 1\\n      grids << grid_hash\\n    end\\n    board.each do |row|\\n      next if row[i] == '.'\\n\\n      grid_hash[row[i]] += 1\\n      grids << grid_hash\\n    end\\n  end\\n\\n  # check each grid hash for duplicated value\\n  grids.each do |grid|\\n    grid.each do |_k, v|\\n      return false if v > 1\\n    end\\n  end\\n\\n  true\\nend\\n\\nboard = [['5', '3', '.', '.', '7', '.', '.', '.', '.'],\\n         ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\\n         ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\\n         ['8', '.', '.', '.', '6', '.', '.', '.', '3'],\\n         ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\\n         ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\\n         ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\\n         ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\\n         ['.', '.', '.', '.', '8', '.', '.', '7', '9']]\\nprint(is_valid_sudoku(board))\\n# => true\\n\\nboard = [['8', '3', '.', '.', '7', '.', '.', '.', '.'],\\n         ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\\n         ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\\n         ['8', '.', '.', '.', '6', '.', '.', '.', '3'],\\n         ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\\n         ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\\n         ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\\n         ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\\n         ['.', '.', '.', '.', '8', '.', '.', '7', '9']]\\nprint(is_valid_sudoku(board))\\n# => false\\n# explanation: duplicated value in column\\n\\nboard = [['8', '3', '.', '.', '7', '.', '3', '.', '.'],\\n         ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\\n         ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\\n         ['8', '.', '.', '.', '6', '.', '.', '.', '3'],\\n         ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\\n         ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\\n         ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\\n         ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\\n         ['.', '.', '.', '.', '8', '.', '.', '7', '9']]\\nprint(is_valid_sudoku(board))\\n# => false\\n# explanation: duplicated value in row\\n\\nboard = [['8', '3', '.', '.', '7', '.', '.', '.', '.'],\\n         ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\\n         ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\\n         ['.', '.', '.', '.', '6', '.', '.', '.', '3'],\\n         ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\\n         ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\\n         ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\\n         ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\\n         ['.', '.', '.', '.', '8', '.', '.', '7', '9']]\\nprint(is_valid_sudoku(board))\\n# => false\\n# explanation: duplicated value in 3x3 grid\\n\\n#\\n# Approach 2: Sets\\n#\\nrequire 'set'\\n\\ndef is_valid_sudoku(board)\\n  return false unless check_rows(board)\\n  return false unless check_cols(board)\\n\\n  row = -3\\n  while (row += 3) < 9\\n    col = - 3\\n    while (col += 3) < 9\\n      start_point = [row, col]\\n      return false unless check_grid(board, start_point)\\n    end\\n  end\\n  true\\nend\\n\\ndef check_grid(board, start_point)\\n  row = start_point[0]\\n  col = start_point[1]\\n  ss = Set.new\\n  (row..(row + 2)).each do |cur_row|\\n    (col..(col + 2)).each do |cur_col|\\n      next if board[cur_row][cur_col] == '.'\\n      return false if ss.member?(board[cur_row][cur_col])\\n\\n      ss.add board[cur_row][cur_col]\\n    end\\n  end\\n  true\\nend\\n\\ndef check_col(board, col)\\n  ss = Set.new\\n  (0..8).each do |row|\\n    next if board[row][col] == '.'\\n    return false if ss.member?(board[row][col])\\n\\n    ss.add board[row][col]\\n  end\\n  true\\nend\\n\\ndef check_row(board, row)\\n  ss = Set.new\\n  (0..8).each do |col|\\n    next if board[row][col] == '.'\\n    return false if ss.member?(board[row][col])\\n\\n    ss.add board[row][col]\\n  end\\n  true\\nend\\n\\ndef check_rows(board)\\n  (0..8).each do |row|\\n    return false unless check_row(board, row)\\n  end\\n  true\\nend\\n\\ndef check_cols(board)\\n  (0..8).each do |col|\\n    return false unless check_col(board, col)\\n  end\\n  true\\nend\\n\\nboard = [['5', '3', '.', '.', '7', '.', '.', '.', '.'],\\n         ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\\n         ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\\n         ['8', '.', '.', '.', '6', '.', '.', '.', '3'],\\n         ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\\n         ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\\n         ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\\n         ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\\n         ['.', '.', '.', '.', '8', '.', '.', '7', '9']]\\nprint(is_valid_sudoku(board))\\n# => true\\n\\nboard = [['8', '3', '.', '.', '7', '.', '.', '.', '.'],\\n         ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\\n         ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\\n         ['8', '.', '.', '.', '6', '.', '.', '.', '3'],\\n         ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\\n         ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\\n         ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\\n         ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\\n         ['.', '.', '.', '.', '8', '.', '.', '7', '9']]\\nprint(is_valid_sudoku(board))\\n# => false\\n# explanation: duplicated value in column\\n\\nboard = [['8', '3', '.', '.', '7', '.', '3', '.', '.'],\\n         ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\\n         ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\\n         ['8', '.', '.', '.', '6', '.', '.', '.', '3'],\\n         ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\\n         ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\\n         ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\\n         ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\\n         ['.', '.', '.', '.', '8', '.', '.', '7', '9']]\\nprint(is_valid_sudoku(board))\\n# => false\\n# explanation: duplicated value in row\\n\\nboard = [['8', '3', '.', '.', '7', '.', '.', '.', '.'],\\n         ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\\n         ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\\n         ['.', '.', '.', '.', '6', '.', '.', '.', '3'],\\n         ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\\n         ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\\n         ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\\n         ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\\n         ['.', '.', '.', '.', '8', '.', '.', '7', '9']]\\nprint(is_valid_sudoku(board))\\n# => false\\n# explanation: duplicated value in 3x3 grid\\n\"",
    "two sum": "\"# Challenge name: Two Sum\\n#\\n# Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\\n#\\n# You may assume that each input would have exactly one solution, and you may not use the same element twice.\\n#\\n# You can return the answer in any order.\\n#\\n#\\n# Examples\\n#\\n# Input: nums = [2, 7, 11, 15], target = 9\\n# Output: [0,1]\\n# Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\\n#\\n# Input: nums = [3, 2, 4], target = 6\\n# Output: [1,2]\\n#\\n# Input: nums = [3, 3], target = 6\\n# Output: [0,1]\\n# Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\\n#\\n# @param {Integer[]} nums\\n# @param {Integer} target\\n# @return {Integer[]}\\n\\n#\\n# Approach: Using Hash table\\n#\\n\\n# Complexity analysis\\n\\n# Time complexity: O(n). We traverse the list containing n elements exactly twice.\\n# Since the hash table reduces the lookup time to O(1), the time complexity is O(n).\\n\\n# Space complexity: O(n). The extra space required depends on the number of items\\n# stored in the hash table, which stores exactly n elements.\\n\\ndef two_sum(nums, target)\\n  hash = {}\\n\\n  # create a hash to store values and their indices\\n  nums.each_with_index do |num, i|\\n    hash[num] = i\\n  end\\n\\n  # iterate over nums array to find the target (difference between sum target and num)\\n  nums.each_with_index do |num, i|\\n    difference_target = target - num\\n\\n    return [i, hash[difference_target]] if hash[difference_target] && hash[difference_target] != i\\n  end\\nend\\n\\nnums = [2, 7, 11, 15]\\ntarget = 9\\nprint(two_sum(nums, target))\\n# => [0,1]\\n\\nnums = [3, 2, 4]\\ntarget = 6\\nprint(two_sum(nums, target))\\n# => [1,2]\\n\\nnums = [3, 3]\\ntarget = 6\\nprint(two_sum(nums, target))\\n# => [0,1]\\n\"",
    "two sum ii": "\"# Given an array of integers numbers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\\n\\n# Return the indices of the two numbers (1-indexed) as an integer array answer of size 2, where 1 <= answer[0] < answer[1] <= numbers.length.\\n\\n# You may assume that each input would have exactly one solution and you may not use the same element twice.\\n\\n#\\n# Approach 1: Two pointers\\n#\\n\\n# Complexity analysis\\n\\n# Time complexity: O(n). Each of the n elements is visited at\\n# most once, thus the time complexity is O(n).\\n\\n# Space complexity: O(1). We only use two indexes, the space\\n# complexity is O(1).\\n\\ndef two_sum(numbers, target)\\n  i = 0\\n  j = numbers.length - 1\\n\\n  while i < j\\n    sum = numbers[i] + numbers[j]\\n\\n    if target < sum\\n      j -= 1\\n    elsif target > sum\\n      i += 1\\n    else\\n      return [i + 1, j + 1]\\n    end\\n  end\\nend\\n\\nnums = [2, 7, 11, 15]\\ntarget = 9\\nprint(two_sum(nums, target))\\n# => [1,2]\\n\\nnums = [2, 3, 4]\\ntarget = 6\\nprint(two_sum(nums, target))\\n# => [1,3]\\n\\nnums = [-1, 0]\\ntarget = -1\\nprint(two_sum(nums, target))\\n# => [1,2]\\n\"",
    "inorder traversal": "\"# Definition for a binary tree node.\\n# class TreeNode\\n#   attr_accessor :val, :left, :right\\n#   def initialize(val)\\n#     @val = val\\n#     @left, @right = nil, nil\\n#   end\\n# end\\n\\n# @param {TreeNode} root\\n# @return {Integer[]}\\ndef inorder_traversal(root)\\n  ans = []\\n  def traverse(node, ans)\\n    unless node.nil?\\n      traverse(node.left, ans)\\n      ans.push(node.val)\\n      traverse(node.right, ans)\\n    end\\n  end\\n  traverse(root, ans)\\n  ans\\nend\\n\"",
    "invert": "\"# Definition for a binary tree node.\\n# class TreeNode\\n#   attr_accessor :val, :left, :right\\n#   def initialize(val)\\n#     @val = val\\n#     @left, @right = nil, nil\\n#   end\\n# end\\n\\n# @param {TreeNode} root\\n# @return {TreeNode}\\ndef invert_tree(root)\\n  return nil if root.nil?\\n\\n  temp = root.left\\n  root.left = invert_tree(root.right)\\n  root.right = invert_tree(temp)\\n  root\\nend\\n\"",
    "postorder traversal": "\"# Definition for a binary tree node.\\n# class TreeNode\\n#   attr_accessor :val, :left, :right\\n#   def initialize(val)\\n#     @val = val\\n#     @left, @right = nil, nil\\n#   end\\n# end\\n\\n# @param {TreeNode} root\\n# @return {Integer[]}\\ndef postorder_traversal(root)\\n  ans = []\\n  def traverse(node, ans)\\n    unless node.nil?\\n      traverse(node.left, ans)\\n      traverse(node.right, ans)\\n      ans.push(node.val)\\n    end\\n  end\\n  traverse(root, ans)\\n  ans\\nend\\n\"",
    "preorder traversal": "\"# Definition for a binary tree node.\\n# class TreeNode\\n#   attr_accessor :val, :left, :right\\n#   def initialize(val)\\n#     @val = val\\n#     @left, @right = nil, nil\\n#   end\\n# end\\n\\n# @param {TreeNode} root\\n# @return {Integer[]}\\ndef preorder_traversal(root)\\n  ans = []\\n  def traverse(node, ans)\\n    unless node.nil?\\n      ans.push(node.val)\\n      traverse(node.left, ans)\\n      traverse(node.right, ans)\\n    end\\n  end\\n  traverse(root, ans)\\n  ans\\nend\\n\"",
    "disjoint sets": "\"class Node\\n  attr_accessor :data, :parent, :rank, :parent, :rank\\n\\n  def initialize(data)\\n    @data = data\\n    @parent = self\\n    @rank = 0\\n  end\\nend\\n\\nclass DisjointSets\\n  def make_set(d)\\n    Node.new(d)\\n  end\\n\\n  def find_set(x)\\n    raise ArgumentError unless x.class <= Node\\n\\n    x.parent = (find_set(x.parent)) unless x.parent == x\\n    x.parent\\n  end\\n\\n  def union_set(x, y)\\n    px = find_set(x)\\n    py = find_set(y)\\n    return if px == py\\n\\n    if px.rank > py.rank\\n      py.parent = px\\n    elsif py.rank > px.rank\\n      px.parent = py\\n    else\\n      px.parent = py\\n      py.rank += 1\\n    end\\n  end\\nend\\n\\nds = DisjointSets.new\\none = ds.make_set(1)\\ntwo = ds.make_set(2)\\nthree = ds.make_set(3)\\nds.union_set(one, two)\\nputs ds.find_set(one) == ds.find_set(two) # should be true\\nds.union_set(one, three)\\nputs ds.find_set(two) == ds.find_set(three) # should be true\\nputs one.rank + two.rank + three.rank == 1 # should be true\\n\"",
    "anagram checker": "\"# Challenge name: Is anagram\\n#\\n# Given two strings s and t , write a function to determine\\n# if t is an anagram of s.\\n#\\n# Note:\\n# You may assume the string contains only lowercase alphabets.\\n#\\n# Follow up:\\n# What if the inputs contain unicode characters?\\n# How would you adapt your solution to such case?\\n#\\n# @param {String} s\\n# @param {String} t\\n# @return {Boolean}\\n\\n#\\n# Approach: Hash table\\n#\\n\\n# Complexity analysis:\\n#\\n# Time complexity: O(n). Time complexity is O(n) since accessing the counter\\n# table is a constant time operation.\\n# Space complexity: O(1). Although we do use extra space,\\n# the space complexity is O(1) because the table's size stays constant no\\n# matter how large n is.\\n#\\ndef is_anagram(s, t)\\n  s_length = s.length\\n  t_length = t.length\\n  counter = Hash.new(0)\\n\\n  return false unless s_length == t_length\\n\\n  (0...s_length).each do |i|\\n    counter[s[i]] += 1\\n    counter[t[i]] -= 1\\n  end\\n\\n  counter.each do |_k, v|\\n    return false unless v == 0\\n  end\\n\\n  true\\nend\\n\\ns = 'anagram'\\nt = 'nagaram'\\nputs(is_anagram(s, t))\\n# => true\\n\\ns = 'rat'\\nt = 'car'\\nputs(is_anagram(s, t))\\n# => false\\n\\ns = 'a'\\nt = 'ab'\\nputs(is_anagram(s, t))\\n# => false\\n\\n#\\n# Approach 2: Hash table\\n#\\n\\n# Algorithm: we could also first increment the counter for s,\\n# then decrement the counter for t. If at any point the counter\\n# drops below zero, we know that t contains an extra letter,\\n# not in s, and return false immediately.\\n\\n# Complexity analysis:\\n#\\n# Time complexity: O(n).\\n# Space complexity: O(1).\\n#\\n\\ndef is_anagram(s, t)\\n  s_length = s.length\\n  t_length = t.length\\n  counter = Hash.new(0)\\n\\n  return false unless s_length == t_length\\n\\n  (0...s_length).each do |i|\\n    counter[s[i]] += 1\\n  end\\n\\n  (0...s_length).each do |i|\\n    counter[t[i]] -= 1\\n\\n    return false if counter[t[i]] < 0\\n  end\\n\\n  true\\nend\\n\\ns = 'anagram'\\nt = 'nagaram'\\nputs(is_anagram(s, t))\\n# => true\\n\\ns = 'rat'\\nt = 'car'\\nputs(is_anagram(s, t))\\n# => false\\n\\ns = 'a'\\nt = 'ab'\\nputs(is_anagram(s, t))\\n# => false\\n\\n#\\n# Approach 3: populate 2 hashes and compare them\\n#\\n\\ndef is_anagram(s, t)\\n  s = s.chars\\n  t = t.chars\\n\\n  return false if s.count != t.count\\n\\n  hash1 = {}\\n  s.each do |value|\\n    hash1[value] = if hash1[value]\\n                     hash1[value] + 1\\n                   else\\n                     1\\n                   end\\n  end\\n\\n  hash2 = {}\\n  t.each do |value|\\n    hash2[value] = if hash2[value]\\n                     hash2[value] + 1\\n                   else\\n                     1\\n                   end\\n  end\\n\\n  hash1.keys.each do |key|\\n    return false if hash2[key] != hash1[key]\\n  end\\n\\n  true\\nend\\n\\ns = 'anagram'\\nt = 'nagaram'\\nputs(is_anagram(s, t))\\n# => true\\n\\ns = 'rat'\\nt = 'car'\\nputs(is_anagram(s, t))\\n# => false\\n\\ns = 'a'\\nt = 'ab'\\nputs(is_anagram(s, t))\\n# => false\\n\"",
    "arrays intersection": "\"# Given three integer arrays arr1, arr2 and arr3 sorted in strictly increasing order, return a sorted array of only the integers that appeared in all three arrays.\\n#\\n# Example 1:\\n#\\n# Input: arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8]\\n# Output: [1,5]\\n# Explanation: Only 1 and 5 appeared in the three arrays.\\n#\\n# Example 2:\\n#\\n# Input: arr1 = [197,418,523,876,1356], arr2 = [501,880,1593,1710,1870], arr3 = [521,682,1337,1395,1764]\\n# Output: []\\n#\\n#\\n\\n#\\n# Approach: Hash table\\n#\\n\\n# Complexity Analysis\\n\\n# Time Complexity: O(n) - n is the total length of\\n# all of the input arrays.\\n# Space Complexity: O(n) - n is the total length of all of the\\n# input arrays. This is because we adopted a Hash table to store all\\n# numbers and their number of appearances as values.\\n\\ndef arrays_intersection(arr1, arr2, arr3)\\n  hash = Hash.new(0)\\n\\n  add_to_hash(arr1, hash)\\n  add_to_hash(arr2, hash)\\n  add_to_hash(arr3, hash)\\n\\n  hash.select { |_key, value| value == 3 }.keys\\nend\\n\\ndef add_to_hash(arr, hash)\\n  arr.count.times do |pointer|\\n    value = arr[pointer]\\n    hash[value] += 1\\n  end\\nend\\n\\narr1 = [1, 2, 3, 4, 5]\\narr2 = [1, 2, 5, 7, 9]\\narr3 = [1, 3, 4, 5, 8]\\nprint arrays_intersection(arr1, arr2, arr3)\\n# Output: [1,5]\\n# Explanation: Only 1 and 5 appeared in the three arrays.\\n\\narr1 = [197, 418, 523, 876, 1356]\\narr2 = [501, 880, 1593, 1710, 1870]\\narr3 = [521, 682, 1337, 1395, 1764]\\nprint arrays_intersection(arr1, arr2, arr3)\\n# Output: []\\n\"",
    "common characters": "\"# Challenge name: Find Common Characters\\n#\\n# Given an array A of strings made only from lowercase letters, return a list\\n# of all characters that show up in all strings within the list\\n# (including duplicates).  For example, if a character occurs 3 times in all\\n# strings but not 4 times, you need to include that character three times in\\n# the final answer.\\n#\\n# You may return the answer in any order.\\n#\\n# Example 1:\\n# Input: [\\\"bella\\\",\\\"label\\\",\\\"roller\\\"]\\n# Output: [\\\"e\\\",\\\"l\\\",\\\"l\\\"]\\n#\\n# Example 2:\\n# Input: [\\\"cool\\\",\\\"lock\\\",\\\"cook\\\"]\\n# Output: [\\\"c\\\",\\\"o\\\"]\\n\\n#\\n# Approach 1: Hash\\n#\\n# Time Complexity: O(n)\\n#\\ndef common_characters(arr)\\n  target_count = arr.count\\n\\n  hash = Hash.new(0)\\n  (0...target_count).each do |i|\\n    arr[i].split('').each do |letter|\\n      hash[letter] += 1\\n    end\\n  end\\n\\n  result = []\\n  hash.each do |k, v|\\n    while v >= target_count\\n      if v >= target_count\\n        result << k\\n        v -= target_count\\n      end\\n    end\\n  end\\n\\n  result\\nend\\n\\nputs common_characters(%w[bella label roller])\\n# => [\\\"e\\\",\\\"l\\\",\\\"l\\\"]\\n\\nputs common_characters(%w[cool lock cook])\\n# => [\\\"c\\\",\\\"o\\\"]\\n\"",
    "isomorphic strings": "\"# Challenge name: Isomorphic Strings\\n#\\n# Given two strings s and t, determine if they are isomorphic.\\n# Two strings s and t are isomorphic if the characters in s can be replaced to get t.\\n# All occurrences of a character must be replaced with another character while preserving the order of characters.\\n# No two characters may map to the same character, but a character may map to itself.\\n#\\n# Example 1:\\n# Input: s = \\\"egg\\\", t = \\\"add\\\"\\n# Output: true\\n#\\n# Example 2:\\n# Input: s = \\\"foo\\\", t = \\\"bar\\\"\\n# Output: false\\n#\\n# Example 3:\\n# Input: s = \\\"paper\\\", t = \\\"title\\\"\\n# Output: true\\n#\\n# Constraints:\\n# 1 <= s.length <= 5 * 104\\n# t.length == s.length\\n# s and t consist of any valid ascii character.\\n\\n# Approach 1: Hash Map\\n# Time Complexity: O(N)\\n# Space Complexity: O(N)\\n\\ndef isomorphic_strings_check(s, t)\\n  # store character mappings\\n  map = {}\\n  # store already mapped characters\\n  set = []\\n\\n  (0..s.length - 1).each do |i|\\n    # store characters to compare\\n    char1 = s[i]\\n    char2 = t[i]\\n\\n    # if char1 is mapped\\n    if map[char1]\\n      # return false if char1 is mapped to a different character than already present\\n      return false if map[char1] != char2\\n    # if char1 is not mapped\\n    else\\n      # return false if char2 is already mapped to a different character\\n      return false if set.include?(char2)\\n\\n      # checks passed: add new character map and track that char2 has been mapped\\n      map[char1] = char2\\n      set << char2\\n    end\\n  end\\n  true\\nend\\n\\nputs isomorphic_strings_check('egg', 'add')\\n# => true\\n\\nputs isomorphic_strings_check('foo', 'bar')\\n# => false\\n\\nputs isomorphic_strings_check('paper', 'title')\\n# => true\\n\"",
    "uncommon words": "\"# Challenge name: Uncommon words from two sentences\\n#\\n# We are given two sentences A and B.\\n# (A sentence is a string of space separated words.\\n# Each word consists only of lowercase letters.)\\n#\\n# A word is uncommon if it appears exactly once in one of the sentences,\\n# and does not appear in the other sentence.\\n#\\n# Return a list of all uncommon words.\\n# You may return the list in any order.\\n#\\n# Example 1:\\n# Input: A = \\\"this apple is sweet\\\", B = \\\"this apple is sour\\\"\\n# Output: [\\\"sweet\\\",\\\"sour\\\"]\\n#\\n# Example 2:\\n# Input: A = \\\"apple apple\\\", B = \\\"banana\\\"\\n# Output: [\\\"banana\\\"]\\n\\n#\\n# Approach 1: Hash\\n#\\n# Time Complexitiy: O(n)\\n\\ndef find_uncommon_words(strA, strB)\\n  array = strA.concat(' ', strB).split(' ')\\n  hash = Hash.new(0)\\n  result = []\\n\\n  array.each do |word|\\n    hash[word] += 1\\n  end\\n\\n  hash.each do |k, v|\\n    result.push(k) if v < 2\\n  end\\n\\n  result\\nend\\n\\nputs find_uncommon_words('this apple is sweet', 'this apple is sour')\\n# => [\\\"sweet\\\", \\\"sour\\\"]\\n\\nputs find_uncommon_words('apple apple', 'banana')\\n# => [\\\"banana\\\"]\\n\"",
    "circular linked list": "\"# Define a node for the list\\nclass Node\\n  attr_accessor :value, :next\\n\\n  def initialize(value)\\n    @value = value\\n    @next = nil\\n  end\\nend\\n\\n# Class for circular linked list (last node points to the head node)\\nclass CircularList\\n  attr_reader :head\\n\\n  def initialize\\n    @head = nil\\n  end\\n\\n  def insert_tail(value)\\n    newNode = Node.new(value)\\n    if @head.nil?\\n      @head = newNode\\n      @head.next = @head\\n    else\\n      tempNode = @head\\n      tempNode = tempNode.next while tempNode.next != @head\\n      newNode.next = @head\\n      tempNode.next = newNode\\n    end\\n  end\\n\\n  def insert_head(value)\\n    newNode = Node.new(value)\\n    if @head.nil?\\n      @head = newNode\\n      @head.next = head\\n    else\\n      tempNode = @head\\n      tempNode = tempNode.next while tempNode.next != @head\\n      newNode.next = @head\\n      tempNode.next = newNode\\n      @head = newNode\\n    end\\n  end\\n\\n  def print_list\\n    print '['\\n    unless @head.nil?\\n      printNode = @head\\n      while printNode.next != @head\\n        print printNode.value.to_s\\n        print ', '\\n        printNode = printNode.next\\n      end\\n      print printNode.value\\n    end\\n    print ']'\\n\\n    puts(STDOUT.flush)\\n  end\\n\\n  def delete_head\\n    return if @head.nil?\\n\\n    if @head.next != @head\\n      newHead = @head.next\\n      tempNode = newHead\\n      tempNode = tempNode.next while tempNode.next != @head\\n      tempNode.next = newHead\\n      @head = newHead\\n    elsif !@head.nil? && (@head.next == @head)\\n      @head = nil\\n    end\\n  end\\n\\n  def delete_tail\\n    return if @head.nil?\\n\\n    if @head.next != @head\\n      tempNode = @head\\n      tempNode = tempNode.next while tempNode.next.next != @head\\n      tempNode.next = @head\\n    elsif !@head.nil? && (@head.next == @head)\\n      @head = nil\\n    end\\n  end\\n\\n  def is_empty\\n    @head.nil?\\n  end\\nend\\n\\nobj = CircularList.new\\n\\nobj.insert_tail(1)\\nobj.insert_tail(2)\\nobj.insert_tail(3)\\nobj.insert_tail(4)\\nobj.insert_tail(5)\\nobj.print_list\\n\\nobj.insert_head(6)\\nobj.print_list\\n\\nobj.delete_tail\\nobj.print_list\\n\\nobj.delete_head\\nobj.print_list\\n\"",
    "doubly linked list": "\"class DoublyLinkedList\\n  # Initialize the data structure here.\\n  attr_reader :head, :tail, :size\\n\\n  def initialize\\n    @head = nil\\n    @tail = nil\\n    @size = 0\\n  end\\n\\n  # Get the value of the index-th node in the linked list.\\n  # If the index is invalid, return -1.\\n  def get(index)\\n    return -1 if @head.nil?\\n    return -1 if index > @size - 1\\n\\n    if index < @size - index\\n      iter = @head\\n      cnt = 0\\n      until iter.nil?\\n        return iter.val if cnt == index\\n\\n        iter = iter.next\\n        cnt += 1\\n      end\\n    else\\n      iter = @tail\\n      cnt = @size - 1\\n      until iter.nil?\\n        return iter.val if cnt == index\\n\\n        iter = iter.prev\\n        cnt -= 1\\n      end\\n    end\\n    -1\\n  end\\n\\n  # Add a node of value val before the first element of the linked list.\\n  # After the insertion, the new node will be the first node of the linked list.\\n  def insert_head(val)\\n    node = Node.new(val, nil, @head)\\n    @tail = node unless @head\\n    @head.prev = node if @head\\n    @head = node\\n    @size += 1\\n  end\\n\\n  # Append a node of value val to the last element of the linked list.\\n  def insert_tail(val)\\n    return insert_head(val) unless @head\\n\\n    node = Node.new(val, @tail, nil)\\n    @tail.next = node\\n    @tail = node\\n    @size += 1\\n  end\\n\\n  # Add a node of value val before the index-th node in the linked list.\\n  # If index equals to the length of linked list, the node will be appended\\n  # to the end of linked list. If index is greater than the length, the node\\n  # will not be inserted.\\n  def add_at_index(index, val)\\n    case index\\n    when 0 then insert_head(val)\\n    when @size then insert_tail(val)\\n    when 1...@size\\n      if index < @size - index\\n        iter = @head\\n        cnt = 0\\n        until iter.nil?\\n          return insert(iter, Node.new(val)) if cnt == index - 1\\n\\n          iter = iter.next\\n          cnt += 1\\n        end\\n      else\\n        iter = @tail\\n        cnt = @size - 1\\n        until iter.nil?\\n          return insert(iter, Node.new(val)) if cnt == index - 1\\n\\n          iter = iter.prev\\n          cnt -= 1\\n        end\\n      end\\n    end\\n  end\\n\\n  def insert(node, new_node)\\n    new_node.prev = node\\n    new_node.next = node.next\\n    node.next.prev = new_node\\n    node.next = new_node\\n    @size += 1\\n  end\\n\\n  # Delete the index-th node in the linked list, if the index is valid.\\n  def delete_at_index(index)\\n    case index\\n    when 0\\n      return unless @head\\n      return @head, @tail, @size = nil, nil, 0 if @size == 1\\n\\n      remove(@head)\\n    when @size - 1\\n      remove(@tail)\\n    when 1...@size - 1\\n      if index < @size - index\\n        iter = @head\\n        cnt = 0\\n        until iter.nil?\\n          return remove(iter) if cnt == index\\n\\n          iter = iter.next\\n          cnt += 1\\n        end\\n      else\\n        iter = @tail\\n        cnt = @size - 1\\n        until iter.nil?\\n          return remove(iter) if cnt == index\\n\\n          iter = iter.prev\\n          cnt -= 1\\n        end\\n      end\\n    end\\n  end\\n\\n  def remove(node)\\n    if node == @head\\n      @head = @head.next\\n      @head.prev = nil\\n    elsif node == @tail\\n      @tail = tail.prev\\n      @tail.next = nil\\n    else\\n      node.prev.next = node.next\\n      node.next.prev = node.prev\\n    end\\n    @size -= 1\\n  end\\n\\n  def print_values(head = @head)\\n    print \\\"#{head.val} --> \\\"\\n    if head.next.nil?\\n      puts(\\\"nil\\\\n\\\")\\n    else\\n      print_values(head.next)\\n    end\\n  end\\nend\\n\\nclass Node\\n  attr_accessor :val, :prev, :next\\n\\n  def initialize(val = nil, prev = nil, next_ = nil)\\n    @val = val\\n    @prev = prev\\n    @next = next_\\n  end\\nend\\n\\nobj = DoublyLinkedList.new\\nobj.get(1)\\n\\nobj.insert_head(2)\\nobj.print_values\\n\\nobj.insert_tail(3)\\nobj.print_values\\n\\nobj.add_at_index(3, 5)\\nobj.print_values\\n\\nobj.delete_at_index(1)\\nobj.print_values\\n\"",
    "singly linked list": "\"# Define a node in the list\\nclass Node\\n  # Initialize the data structure here.\\n  attr_accessor :value, :next\\n\\n  def initialize(value)\\n    @value = value\\n    @next = nil\\n  end\\nend\\n\\n# A Class for single linked lists (each element links to the next one, but not to the previous one)\\nclass SinglyLinkedList\\n  include Enumerable\\n  attr_accessor :head\\n\\n  def initialize\\n    @head = nil\\n  end\\n\\n  def insert_tail(value)\\n    newNode = Node.new(value)\\n    if @head.nil?\\n      @head = newNode\\n    else\\n      tempNode = @head\\n      tempNode = tempNode.next until tempNode.next.nil?\\n      tempNode.next = newNode\\n    end\\n  end\\n\\n  def insert_head(value)\\n    newNode = Node.new(value)\\n    if @head.nil?\\n      @head = newNode\\n    else\\n      newNode.next = @head\\n      @head = newNode\\n    end\\n  end\\n\\n  def each\\n    return if @head.nil?\\n\\n    current = @head\\n    until current.nil?\\n      yield current.value\\n      current = current.next\\n    end\\n  end\\n\\n  def print_list\\n    puts '[' + to_a.join(', ') + ']'\\n  end\\n\\n  def delete_head\\n    if !@head.nil? && !@head.next.nil?\\n      newHead = @head.next\\n      @head = newHead\\n    elsif !@head.nil? && @head.next.nil?\\n      @head = nil\\n    end\\n  end\\n\\n  def delete_tail\\n    return if @head.nil?\\n\\n    tempNode = @head\\n    tempNode = tempNode.next until tempNode.next.next.nil?\\n    tempNode.next = nil\\n  end\\n\\n  def empty?\\n    @head.nil?\\n  end\\nend\\n\\nobj = SinglyLinkedList.new\\n\\nobj.insert_head(1)\\nobj.insert_head(2)\\nobj.insert_head(3)\\nobj.insert_head(4)\\nobj.insert_head(5)\\nobj.print_list\\n\\nobj.insert_tail(6)\\nobj.print_list\\n\\nobj.delete_head\\nobj.print_list\\n\\nobj.delete_tail\\nobj.print_list\\n\"",
    "circular queue": "\"# Challenge name: Circular Queue\\n#\\n# Design the implementation of a circular queue.\\n# The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and\\n# the last position is connected back to the first position to make a circle. It is also called \\\"Ring Buffer\\\".\\n#\\n\\n#\\n# Complexity Analysis\\n#\\n# Time complexity: O(1).\\n# All of the methods in our circular data structure are of constant time complexity.\\n#\\n# Space Complexity: O(N).\\n# The overall space complexity of the data structure is linear, where N is the pre-assigned capacity of the queue.\\n# However, it is worth mentioning that the memory consumption of the data structure remains as its pre-assigned capacity during its entire life cycle.\\n\\nclass CircularQueue\\n  def initialize(max_size)\\n    @max_size = max_size\\n    @queue = Array.new(max_size, nil)\\n    @front = 0\\n    @back = 0\\n    @size = 0\\n  end\\n\\n  attr_accessor :front, :back, :size\\n  attr_reader :max_size, :queue\\n\\n  def empty?\\n    size == 0\\n  end\\n\\n  def peek\\n    return nil if empty?\\n\\n    queue[front]\\n  end\\n\\n  def add(x)\\n    raise 'Queue is at max capacity' if size == max_size\\n\\n    queue[back] = x\\n    @back = (back + 1) % max_size\\n    @size += 1\\n  end\\n\\n  def pop\\n    raise 'Queue is empty' if size == 0\\n\\n    temp = queue[front]\\n    queue[front] = nil\\n    @front = (front + 1) % max_size\\n    @size -= 1\\n\\n    temp\\n  end\\nend\\n\\nqueue = CircularQueue.new(3)\\n\\nbegin\\n  queue.pop\\nrescue StandardError => e\\n  puts e.message\\nend\\n\\nqueue.add(1)\\nqueue.add(2)\\nqueue.add(3)\\n\\nbegin\\n  queue.add(4)\\nrescue StandardError => e\\n  puts e.message\\nend\\n\\nputs queue.inspect\\n# => #<CircularQueue:0x00007fea23876cd8 @max_size=3, @queue=[1, 2, 3], @front=0, @back=0, @size=3>\\n\\nputs queue.peek\\n# => 1\\n\\nqueue.pop\\n\\nputs queue.peek\\n# => 2\\n\"",
    "queue": "\"# A queue is like a waiting list.\\n# Imagine you are waiting in line to buy the latest Android product\\n# or getting a parking ticket. These are queues!\\n\\n#\\n#\\n# 1. An array can behave like a Queue if you use the right methods.\\n#\\n# These methods are:\\n# - unshift: when you unshift, you are adding one item to the queue\\n# - pop\\n#\\n\\nclass ArrayQueue\\n  def initialize(queue = [])\\n    @queue = queue\\n  end\\n\\n  attr_accessor :queue\\n\\n  def add(item)\\n    queue.unshift(item)\\n  end\\n\\n  def pop\\n    queue.pop\\n  end\\n\\n  def peek\\n    queue[-1]\\n  end\\nend\\n\\nqueue = ArrayQueue.new\\nqueue.add(3)\\nqueue.add(4)\\nqueue.add(5)\\n\\nputs queue.inspect\\n# => #<ArrayQueue:0x00007fc78200f5e0 @queue=[5, 4, 3]>\\n\\nqueue.pop\\n\\nputs queue.inspect\\n# => #<ArrayQueue:0x00007fc78200f5e0 @queue=[5, 4]>\\n\\nputs(queue.peek)\\n# => 4\\n\\n#\\n#\\n# 2. Ruby Concurrent Queue\\n# Ruby has a proper thread-safe, blocking, Queue class.\\n# You can use this queue for coordinating work in a multi-threaded program.\\n#\\n# Reference: https://ruby-doc.org/core-2.5.0/Queue.html\\n#\\n\\nqueue = Queue.new\\n\\nqueue << 1\\nqueue << 2\\nqueue << 3\\n\\nqueue.pop\\n# 1\\n\\nqueue.pop\\n# 2\\n\\n# If the queue is empty, calling pop will put your current\\n# thread to sleep & wait until something is added to the queue.\\n\\n#\\n#\\n# 3. How to Use a Ruby SizedQueue\\n# A sized queue is the same as a regular queue but with a size limit.\\n#\\n# Reference: https://ruby-doc.org/core-2.5.0/SizedQueue.html\\n#\\n\\nqueue = SizedQueue.new(5)\\n\\n# When the queue is full, the push (same as <<) operation\\n# will suspend the current thread until an item is taken off the queue.\\n\\nqueue.push(:oranges)\\nqueue.push(:apples)\\nqueue.push(:blue)\\nqueue.push(:orange)\\nqueue.push(:green)\\n# At this point, the SizedQueue is full\\n\\nqueue.push(:throw_expection)\\n# data_structures/queues/queue.rb:81:in `push': No live threads left. Deadlock? (fatal)\\n# 1 threads, 1 sleeps current:0x00007ff54f407130 main thread:0x00007ff54f407130\\n# * #<Thread:0x00007ff54f86ef38 sleep_forever>\\n#    rb_thread_t:0x00007ff54f407130 native:0x000000010dd24dc0 int:0\\n#    data_structures/queues/queue.rb:81:in `push'\\n#    data_structures/queues/queue.rb:81:in `<main>'\\n# \\tfrom data_structures/queues/queue.rb:81:in `<main>'\\n\\n# You can choose to raise an exception, passing true as an argument as follows:\\nqueue.push(:throw_expection, true)\\n# data_structures/queues/queue.rb:83:in `push': queue full (ThreadError)\\n# \\tfrom data_structures/queues/queue.rb:83:in `<main>'\\n\"",
    "stack": "\"# A stack is an abstract data type that serves as a collection of\\n# elements with two principal operations: push() and pop(). push() adds an\\n# element to the top of the stack, and pop() removes an element from the top\\n# of a stack. The order in which elements come off of a stack are\\n# Last In, First Out (LIFO)\\n\\nclass StackOverflowError < StandardError; end\\n\\nclass Stack\\n  def initialize(limit, stack = [])\\n    @stack = stack\\n    @limit = limit\\n  end\\n\\n  attr_accessor :stack, :limit\\n\\n  def push(item)\\n    raise StackOverflowError unless stack.count < limit\\n\\n    stack << item\\n  end\\n\\n  def pop\\n    stack.pop\\n  end\\n\\n  def peek\\n    stack.last\\n  end\\n\\n  def empty?\\n    stack.count.zero?\\n  end\\n\\n  def full?\\n    stack.count == limit\\n  end\\n\\n  def size\\n    stack.count\\n  end\\n\\n  def contains?(item)\\n    stack.include?(item)\\n  end\\nend\\n\\nstack = Stack.new(10, [])\\n\\nputs stack.empty?\\n# => true\\n\\nstack.push(3)\\nstack.push(5)\\nstack.push(7)\\nstack.push(9)\\n\\nputs stack.full?\\n# => false\\n\\nputs stack.contains?(5)\\n# => true\\n\\nputs stack.pop\\n# => 9\\n\\nputs stack.peek\\n# => 7\\n\\nputs stack.size\\n# => 3\\n\\nputs stack.inspect\\n# => #<Stack:0x00007fceed83eb40 @stack=[3, 5, 7], @limit=10>\\n\\nstack.push(13)\\nstack.push(15)\\nstack.push(17)\\nstack.push(19)\\nstack.push(23)\\nstack.push(25)\\nstack.push(27)\\n# At this point, the stack is full\\n\\nstack.push(29)\\n# => data_structures/stacks/stack.rb:18:in `push': StackOverflowError (StackOverflowError)\\n# from data_structures/stacks/stack.rb:83:in `<main>'\\n\"",
    "trie": "\"# A Trie (prefix tree) is a kind of search tree used to provide quick lookup\\n# of words/patterns in a set of words. A basic Trie however has O(n^2)\\n# space complexity making it impractical in practice.\\n# It however provides O(max(search_string, length of longest word))\\n# lookup time making it an optimal approach when space is not an issue.\\n\\nclass Node\\n  attr_reader   :value, :next\\n  attr_accessor :word\\n\\n  def initialize(value)\\n    @value = value\\n    @word  = false\\n    @next  = []\\n  end\\nend\\n\\nclass Trie\\n  def initialize\\n    @root = Node.new('*')\\n  end\\n\\n  def insert_many(word)\\n    letters = word.chars\\n    base    = @root\\n\\n    letters.each do |letter|\\n      base = insert(letter, base.next)\\n    end\\n  end\\n\\n  def include?(word)\\n    letters = word.chars\\n    base    = @root\\n\\n    letters.all? do |letter|\\n      base = find(letter, base.next)\\n    end\\n  end\\n\\n  private\\n\\n  # check if it already exists\\n  # if not add character to node\\n  def insert(character, trie)\\n    found = trie.find do |n|\\n      n.value == character\\n    end\\n\\n    add_node(character, trie) unless found\\n  end\\n\\n  def add_node(character, trie)\\n    Node.new(character).tap do |new_node|\\n      trie << new_node\\n    end\\n  end\\n\\n  def find(character, trie)\\n    trie.find do |n|\\n      n.value == character\\n    end\\n  end\\nend\\n\\ntrie = Trie.new\\ntrie.insert_many('Dogs')\\ntrie.insert_many('South')\\ntrie.insert_many('Cape Town')\\n\\nputs trie.include?('Cape Town')\\n# => true\\n\\nputs trie.include?('not presented')\\n# => false\\n\""
  }
}
