{
  "go": {
    "luhn": "\"// lunh.go\\n// description: Luhn algorithm\\n// details: is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, etc [Lunh](https://en.wikipedia.org/wiki/Luhn_algorithm)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see lunh_test.go\\n\\n// Package checksum describes algorithms for finding various checksums\\npackage checksum\\n\\n// LuhnAlgorithm This function calculates the checksum using the Luna algorithm\\nfunc LuhnAlgorithm(s []rune) bool {\\n\\tn := len(s)\\n\\tnumber := 0\\n\\tresult := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tnumber = int(s[i]) - '0'\\n\\t\\tif i%2 != 0 {\\n\\t\\t\\tresult += number\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tnumber *= 2\\n\\t\\tif number > 9 {\\n\\t\\t\\tnumber -= 9\\n\\t\\t}\\n\\t\\tresult += number\\n\\t}\\n\\treturn result%10 == 0\\n}\\n\"",
    "luhn test": "\"// luhn_test.go\\n// description: Test for Luhn algorithm\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see luhn.go\\n\\npackage checksum\\n\\nimport \\\"testing\\\"\\n\\nfunc TestLuhnAlgorithm(t *testing.T) {\\n\\ttests := []struct {\\n\\t\\tname string\\n\\t\\ts    []rune\\n\\t\\twant bool\\n\\t}{\\n\\t\\t{\\\"check 4242424242424242\\\", []rune(\\\"4242424242424242\\\"), true},\\n\\t\\t{\\\"check 6200000000000005\\\", []rune(\\\"6200000000000005\\\"), true},\\n\\t\\t{\\\"check 5534200028533164\\\", []rune(\\\"5534200028533164\\\"), true},\\n\\t\\t{\\\"check 36227206271667\\\", []rune(\\\"36227206271667\\\"), true},\\n\\t\\t{\\\"check 471629309440\\\", []rune(\\\"471629309440\\\"), false},\\n\\t\\t{\\\"check 1111\\\", []rune(\\\"1111\\\"), false},\\n\\t\\t{\\\"check 12345674\\\", []rune(\\\"12345674\\\"), true},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tif got := LuhnAlgorithm(test.s); got != test.want {\\n\\t\\t\\t\\tt.Errorf(\\\"LuhnAlgorithm() = %v, want %v\\\", got, test.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkBruteForceFactorial(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tLuhnAlgorithm([]rune(\\\"4242424242424242\\\"))\\n\\t}\\n}\\n\"",
    "cipher test": "\"// Empty test file to keep track of all the tests for the algorithms.\\n\\npackage cipher\\n\"",
    "base64": "\"// base64.go\\n// description: The base64 encoding algorithm as defined in the RFC4648 standard.\\n// author: [Paul Leydier] (https://github.com/paul-leydier)\\n// ref: https://datatracker.ietf.org/doc/html/rfc4648#section-4\\n// ref: https://en.wikipedia.org/wiki/Base64\\n// see base64_test.go\\n\\npackage conversion\\n\\nimport (\\n\\t\\\"strings\\\" // Used for efficient string builder (more efficient than simply appending strings)\\n)\\n\\nconst Alphabet = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\"\\n\\n// Base64Encode encodes the received input bytes slice into a base64 string.\\n// The implementation follows the RFC4648 standard, which is documented\\n// at https://datatracker.ietf.org/doc/html/rfc4648#section-4\\nfunc Base64Encode(input []byte) string {\\n\\tvar sb strings.Builder\\n\\t// If not 24 bits (3 bytes) multiple, pad with 0 value bytes, and with \\\"=\\\" for the output\\n\\tvar padding string\\n\\tfor i := len(input) % 3; i > 0 && i < 3; i++ {\\n\\t\\tvar zeroByte byte\\n\\t\\tinput = append(input, zeroByte)\\n\\t\\tpadding += \\\"=\\\"\\n\\t}\\n\\n\\t// encode 24 bits per 24 bits (3 bytes per 3 bytes)\\n\\tfor i := 0; i < len(input); i += 3 {\\n\\t\\t// select 3 8-bit input groups, and re-arrange them into 4 6-bit groups\\n\\t\\t// the literal 0x3F corresponds to the byte \\\"0011 1111\\\"\\n\\t\\t// the operation \\\"byte & 0x3F\\\" masks the two left-most bits\\n\\t\\tgroup := [4]byte{\\n\\t\\t\\tinput[i] >> 2,\\n\\t\\t\\t(input[i]<<4)&0x3F + input[i+1]>>4,\\n\\t\\t\\t(input[i+1]<<2)&0x3F + input[i+2]>>6,\\n\\t\\t\\tinput[i+2] & 0x3F,\\n\\t\\t}\\n\\n\\t\\t// translate each group into a char using the static map\\n\\t\\tfor _, b := range group {\\n\\t\\t\\tsb.WriteString(string(Alphabet[int(b)]))\\n\\t\\t}\\n\\t}\\n\\tencoded := sb.String()\\n\\n\\t// Apply the output padding\\n\\tencoded = encoded[:len(encoded)-len(padding)] + padding[:]\\n\\n\\treturn encoded\\n}\\n\\n// Base64Decode decodes the received input base64 string into a byte slice.\\n// The implementation follows the RFC4648 standard, which is documented\\n// at https://datatracker.ietf.org/doc/html/rfc4648#section-4\\nfunc Base64Decode(input string) []byte {\\n\\tpadding := strings.Count(input, \\\"=\\\") // Number of bytes which will be ignored\\n\\tvar decoded []byte\\n\\n\\t// select 4 6-bit input groups, and re-arrange them into 3 8-bit groups\\n\\tfor i := 0; i < len(input); i += 4 {\\n\\t\\t// translate each group into a byte using the static map\\n\\t\\tbyteInput := [4]byte{\\n\\t\\t\\tbyte(strings.IndexByte(Alphabet, input[i])),\\n\\t\\t\\tbyte(strings.IndexByte(Alphabet, input[i+1])),\\n\\t\\t\\tbyte(strings.IndexByte(Alphabet, input[i+2])),\\n\\t\\t\\tbyte(strings.IndexByte(Alphabet, input[i+3])),\\n\\t\\t}\\n\\n\\t\\tgroup := [3]byte{\\n\\t\\t\\tbyteInput[0]<<2 + byteInput[1]>>4,\\n\\t\\t\\tbyteInput[1]<<4 + byteInput[2]>>2,\\n\\t\\t\\tbyteInput[2]<<6 + byteInput[3],\\n\\t\\t}\\n\\n\\t\\tdecoded = append(decoded, group[:]...)\\n\\t}\\n\\n\\treturn decoded[:len(decoded)-padding]\\n}\\n\"",
    "base64 test": "\"package conversion\\n\\nimport \\\"testing\\\"\\n\\nfunc TestBase64Encode(t *testing.T) {\\n\\ttestCases := []struct {\\n\\t\\tin       string\\n\\t\\texpected string\\n\\t}{\\n\\t\\t{\\\"Hello World!\\\", \\\"SGVsbG8gV29ybGQh\\\"},       // multiple of 3 byte length (multiple of 24-bits)\\n\\t\\t{\\\"Hello World!a\\\", \\\"SGVsbG8gV29ybGQhYQ==\\\"},  // multiple of 3 byte length + 1\\n\\t\\t{\\\"Hello World!ab\\\", \\\"SGVsbG8gV29ybGQhYWI=\\\"}, // multiple of 3 byte length + 2\\n\\t\\t{\\\"\\\", \\\"\\\"},      // empty byte slice\\n\\t\\t{\\\"6\\\", \\\"Ng==\\\"}, // short text\\n\\t\\t{\\\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\\", \\\"TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLg==\\\"}, // Long text\\n\\t}\\n\\n\\tfor _, tc := range testCases {\\n\\t\\tresult := Base64Encode([]byte(tc.in))\\n\\t\\tif result != tc.expected {\\n\\t\\t\\tt.Fatalf(\\\"Base64Encode(%s) = %s, want %s\\\", tc.in, result, tc.expected)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkBase64Encode(b *testing.B) {\\n\\tbenchmarks := []struct {\\n\\t\\tname     string\\n\\t\\tin       string\\n\\t\\texpected string\\n\\t}{\\n\\t\\t{\\\"Hello World!\\\", \\\"Hello World!\\\", \\\"SGVsbG8gV29ybGQh\\\"},         // multiple of 3 byte length (multiple of 24-bits)\\n\\t\\t{\\\"Hello World!a\\\", \\\"Hello World!a\\\", \\\"SGVsbG8gV29ybGQhYQ==\\\"},   // multiple of 3 byte length + 1\\n\\t\\t{\\\"Hello World!ab\\\", \\\"Hello World!ab\\\", \\\"SGVsbG8gV29ybGQhYWI=\\\"}, // multiple of 3 byte length + 2\\n\\t\\t{\\\"Empty\\\", \\\"\\\", \\\"\\\"},  // empty byte slice\\n\\t\\t{\\\"6\\\", \\\"6\\\", \\\"Ng==\\\"}, // short text\\n\\t\\t{\\\"Lorem ipsum\\\", \\\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\\", \\\"TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLg==\\\"}, // Long text\\n\\t}\\n\\n\\tfor _, bm := range benchmarks {\\n\\t\\tb.Run(bm.name, func(b *testing.B) {\\n\\t\\t\\tfor i := 0; i < b.N; i++ {\\n\\t\\t\\t\\tBase64Encode([]byte(bm.in))\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestBase64Decode(t *testing.T) {\\n\\ttestCases := []struct {\\n\\t\\texpected string\\n\\t\\tin       string\\n\\t}{\\n\\t\\t{\\\"Hello World!\\\", \\\"SGVsbG8gV29ybGQh\\\"},       // multiple of 3 byte length (multiple of 24-bits)\\n\\t\\t{\\\"Hello World!a\\\", \\\"SGVsbG8gV29ybGQhYQ==\\\"},  // multiple of 3 byte length + 1\\n\\t\\t{\\\"Hello World!ab\\\", \\\"SGVsbG8gV29ybGQhYWI=\\\"}, // multiple of 3 byte length + 2\\n\\t\\t{\\\"\\\", \\\"\\\"},      // empty byte slice\\n\\t\\t{\\\"6\\\", \\\"Ng==\\\"}, // short text\\n\\t\\t{\\\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\\", \\\"TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLg==\\\"}, // Long text\\n\\t}\\n\\n\\tfor _, tc := range testCases {\\n\\t\\tresult := string(Base64Decode(tc.in))\\n\\t\\tif result != tc.expected {\\n\\t\\t\\tt.Fatalf(\\\"Base64Decode(%s) = %s, want %s\\\", tc.in, result, tc.expected)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkBase64Decode(b *testing.B) {\\n\\tbenchmarks := []struct {\\n\\t\\tname     string\\n\\t\\texpected string\\n\\t\\tin       string\\n\\t}{\\n\\t\\t{\\\"Hello World!\\\", \\\"Hello World!\\\", \\\"SGVsbG8gV29ybGQh\\\"},         // multiple of 3 byte length (multiple of 24-bits)\\n\\t\\t{\\\"Hello World!a\\\", \\\"Hello World!a\\\", \\\"SGVsbG8gV29ybGQhYQ==\\\"},   // multiple of 3 byte length + 1\\n\\t\\t{\\\"Hello World!ab\\\", \\\"Hello World!ab\\\", \\\"SGVsbG8gV29ybGQhYWI=\\\"}, // multiple of 3 byte length + 2\\n\\t\\t{\\\"Empty\\\", \\\"\\\", \\\"\\\"},  // empty byte slice\\n\\t\\t{\\\"6\\\", \\\"6\\\", \\\"Ng==\\\"}, // short text\\n\\t\\t{\\\"Lorem ipsum\\\", \\\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\\", \\\"TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLg==\\\"}, // Long text\\n\\t}\\n\\n\\tfor _, bm := range benchmarks {\\n\\t\\tb.Run(bm.name, func(b *testing.B) {\\n\\t\\t\\tfor i := 0; i < b.N; i++ {\\n\\t\\t\\t\\tBase64Decode(bm.in)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestBase64EncodeDecodeInverse(t *testing.T) {\\n\\ttestCases := []struct {\\n\\t\\tin string\\n\\t}{\\n\\t\\t{\\\"Hello World!\\\"},   // multiple of 3 byte length (multiple of 24-bits)\\n\\t\\t{\\\"Hello World!a\\\"},  // multiple of 3 byte length + 1\\n\\t\\t{\\\"Hello World!ab\\\"}, // multiple of 3 byte length + 2\\n\\t\\t{\\\"\\\"},               // empty byte slice\\n\\t\\t{\\\"6\\\"},              // short text\\n\\t\\t{\\\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\\"}, // Long text\\n\\t}\\n\\n\\tfor _, tc := range testCases {\\n\\t\\tresult := string(Base64Decode(Base64Encode([]byte(tc.in))))\\n\\t\\tif result != tc.in {\\n\\t\\t\\tt.Fatalf(\\\"Base64Decode(Base64Encode(%s)) = %s, want %s\\\", tc.in, result, tc.in)\\n\\t\\t}\\n\\t}\\n}\\n\"",
    "binary to decimal": "\"/*\\nAuthor: Motasim\\nGitHub: https://github.com/motasimmakki\\nDate: 19-Oct-2021\\n*/\\n\\n// This algorithm will convert any Binary number(0 or 1) to Decimal number(+ve number).\\n// https://en.wikipedia.org/wiki/Binary_number\\n// https://en.wikipedia.org/wiki/Decimal\\n// Function receives a Binary Number as string and returns the Decimal number as integer.\\n// Supported Binary number range is 0 to 2^(31-1).\\n\\npackage conversion\\n\\n// Importing necessary package.\\nimport (\\n\\t\\\"errors\\\"\\n\\t\\\"regexp\\\"\\n)\\n\\nvar isValid = regexp.MustCompile(\\\"^[0-1]{1,}$\\\").MatchString\\n\\n// BinaryToDecimal() function that will take Binary number as string,\\n// and return it's Decimal equivalent as integer.\\nfunc BinaryToDecimal(binary string) (int, error) {\\n\\tif !isValid(binary) {\\n\\t\\treturn -1, errors.New(\\\"not a valid binary string\\\")\\n\\t}\\n\\tif len(binary) > 32 {\\n\\t\\treturn -1, errors.New(\\\"binary number must be in range 0 to 2^(31-1)\\\")\\n\\t}\\n\\tvar result, base int = 0, 1\\n\\tfor i := len(binary) - 1; i >= 0; i-- {\\n\\t\\tif binary[i] == '1' {\\n\\t\\t\\tresult += base\\n\\t\\t}\\n\\t\\tbase *= 2\\n\\t}\\n\\treturn result, nil\\n}\\n\"",
    "binary to decimal test": "\"package conversion\\n\\nimport \\\"testing\\\"\\n\\nvar binaryTestCases = map[string]int{\\n\\t\\\"0\\\": 0, \\\"1\\\": 1, \\\"10\\\": 2, \\\"11\\\": 3, \\\"100\\\": 4,\\n\\t\\\"101\\\": 5, \\\"110\\\": 6, \\\"111\\\": 7, \\\"1000\\\": 8, \\\"1001\\\": 9,\\n\\t\\\"1010\\\": 10, \\\"1011\\\": 11, \\\"1100\\\": 12, \\\"1101\\\": 13, \\\"1110\\\": 14,\\n\\t\\\"1111\\\": 15, \\\"10000\\\": 16, \\\"10001\\\": 17, \\\"10010\\\": 18, \\\"10011\\\": 19,\\n\\t\\\"10100\\\": 20, \\\"10101\\\": 21, \\\"10110\\\": 22, \\\"10111\\\": 23, \\\"11000\\\": 24,\\n\\t\\\"11001\\\": 25, \\\"11010\\\": 26, \\\"11011\\\": 27, \\\"11100\\\": 28, \\\"11101\\\": 29,\\n\\t\\\"11110\\\": 30, \\\"11111\\\": 31, \\\"100000\\\": 32, \\\"100001\\\": 33, \\\"100010\\\": 34,\\n\\t\\\"100011\\\": 35, \\\"100100\\\": 36, \\\"100101\\\": 37, \\\"100110\\\": 38, \\\"100111\\\": 39,\\n\\t\\\"101000\\\": 40, \\\"101001\\\": 41, \\\"101010\\\": 42, \\\"101011\\\": 43, \\\"101100\\\": 44,\\n\\t\\\"101101\\\": 45, \\\"101110\\\": 46, \\\"101111\\\": 47, \\\"110000\\\": 48, \\\"110001\\\": 49,\\n\\t\\\"110010\\\": 50, \\\"110011\\\": 51, \\\"110100\\\": 52, \\\"110101\\\": 53, \\\"110110\\\": 54,\\n\\t\\\"110111\\\": 55, \\\"111000\\\": 56, \\\"111001\\\": 57, \\\"111010\\\": 58, \\\"111011\\\": 59,\\n\\t\\\"111100\\\": 60, \\\"111101\\\": 61, \\\"111110\\\": 62, \\\"111111\\\": 63, \\\"1000000\\\": 64,\\n\\t\\\"1000001\\\": 65, \\\"1000010\\\": 66, \\\"1000011\\\": 67, \\\"1000100\\\": 68, \\\"1000101\\\": 69,\\n\\t\\\"1000110\\\": 70, \\\"1000111\\\": 71, \\\"1001000\\\": 72, \\\"1001001\\\": 73, \\\"1001010\\\": 74,\\n\\t\\\"1001011\\\": 75, \\\"1001100\\\": 76, \\\"1001101\\\": 77, \\\"1001110\\\": 78, \\\"1001111\\\": 79,\\n\\t\\\"1010000\\\": 80, \\\"1010001\\\": 81, \\\"1010010\\\": 82, \\\"1010011\\\": 83, \\\"1010100\\\": 84,\\n\\t\\\"1010101\\\": 85, \\\"1010110\\\": 86, \\\"1010111\\\": 87, \\\"1011000\\\": 88, \\\"1011001\\\": 89,\\n\\t\\\"1011010\\\": 90, \\\"1011011\\\": 91, \\\"1011100\\\": 92, \\\"1011101\\\": 93, \\\"1011110\\\": 94,\\n\\t\\\"1011111\\\": 95, \\\"1100000\\\": 96, \\\"1100001\\\": 97, \\\"1100010\\\": 98, \\\"1100011\\\": 99,\\n\\t\\\"1100100\\\": 100,\\n}\\n\\nfunc TestBinaryToDecimal(t *testing.T) {\\n\\tfor input, expected := range binaryTestCases {\\n\\t\\tout, err := BinaryToDecimal(input)\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Errorf(\\\"BinaryToDecimal(%s) returned an error %s\\\", input, err.Error())\\n\\t\\t}\\n\\t\\tif out != expected {\\n\\t\\t\\tt.Errorf(\\\"BinaryToDecimal(%s) = %d; want %d\\\", input, out, expected)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkBinaryToDecimal(b *testing.B) {\\n\\tb.ReportAllocs()\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = BinaryToDecimal(\\\"1100100\\\")\\n\\t}\\n}\\n\"",
    "conversion test": "\"// Empty test file to keep track of all the tests for the algorithms.\\n\\npackage conversion\\n\"",
    "decimal to binary": "\"/*\\nAuthor: Motasim\\nGitHub: https://github.com/motasimmakki\\nDate: 14-Oct-2021\\n*/\\n\\n// This algorithm will convert any Decimal (+ve integer) number to Binary number.\\n// https://en.wikipedia.org/wiki/Binary_number\\n// Function receives a integer as a Decimal number and returns the Binary number.\\n// Supported integer value range is 0 to 2^(31 -1).\\n\\npackage conversion\\n\\n// Importing necessary package.\\nimport (\\n\\t\\\"errors\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\n// Reverse() function that will take string,\\n// and returns the reverse of that string.\\nfunc Reverse(str string) string {\\n\\trStr := []rune(str)\\n\\tfor i, j := 0, len(rStr)-1; i < len(rStr)/2; i, j = i+1, j-1 {\\n\\t\\trStr[i], rStr[j] = rStr[j], rStr[i]\\n\\t}\\n\\treturn string(rStr)\\n}\\n\\n// DecimalToBinary() function that will take Decimal number as int,\\n// and return it's Binary equivalent as string.\\nfunc DecimalToBinary(num int) (string, error) {\\n\\tif num < 0 {\\n\\t\\treturn \\\"\\\", errors.New(\\\"integer must have +ve value\\\")\\n\\t}\\n\\tif num == 0 {\\n\\t\\treturn \\\"0\\\", nil\\n\\t}\\n\\tvar result string = \\\"\\\"\\n\\tfor num > 0 {\\n\\t\\tresult += strconv.Itoa(num & 1)\\n\\t\\tnum >>= 1\\n\\t}\\n\\treturn Reverse(result), nil\\n}\\n\"",
    "decimal to binary test": "\"package conversion\\n\\nimport \\\"testing\\\"\\n\\nvar decimalTestCases = map[int]string{\\n\\t0: \\\"0\\\", 1: \\\"1\\\", 2: \\\"10\\\", 3: \\\"11\\\", 4: \\\"100\\\",\\n\\t5: \\\"101\\\", 6: \\\"110\\\", 7: \\\"111\\\", 8: \\\"1000\\\", 9: \\\"1001\\\",\\n\\t10: \\\"1010\\\", 11: \\\"1011\\\", 12: \\\"1100\\\", 13: \\\"1101\\\", 14: \\\"1110\\\",\\n\\t15: \\\"1111\\\", 16: \\\"10000\\\", 17: \\\"10001\\\", 18: \\\"10010\\\", 19: \\\"10011\\\",\\n\\t20: \\\"10100\\\", 21: \\\"10101\\\", 22: \\\"10110\\\", 23: \\\"10111\\\", 24: \\\"11000\\\",\\n\\t25: \\\"11001\\\", 26: \\\"11010\\\", 27: \\\"11011\\\", 28: \\\"11100\\\", 29: \\\"11101\\\",\\n\\t30: \\\"11110\\\", 31: \\\"11111\\\", 32: \\\"100000\\\", 33: \\\"100001\\\", 34: \\\"100010\\\",\\n\\t35: \\\"100011\\\", 36: \\\"100100\\\", 37: \\\"100101\\\", 38: \\\"100110\\\", 39: \\\"100111\\\",\\n\\t40: \\\"101000\\\", 41: \\\"101001\\\", 42: \\\"101010\\\", 43: \\\"101011\\\", 44: \\\"101100\\\",\\n\\t45: \\\"101101\\\", 46: \\\"101110\\\", 47: \\\"101111\\\", 48: \\\"110000\\\", 49: \\\"110001\\\",\\n\\t50: \\\"110010\\\", 51: \\\"110011\\\", 52: \\\"110100\\\", 53: \\\"110101\\\", 54: \\\"110110\\\",\\n\\t55: \\\"110111\\\", 56: \\\"111000\\\", 57: \\\"111001\\\", 58: \\\"111010\\\", 59: \\\"111011\\\",\\n\\t60: \\\"111100\\\", 61: \\\"111101\\\", 62: \\\"111110\\\", 63: \\\"111111\\\", 64: \\\"1000000\\\",\\n\\t65: \\\"1000001\\\", 66: \\\"1000010\\\", 67: \\\"1000011\\\", 68: \\\"1000100\\\", 69: \\\"1000101\\\",\\n\\t70: \\\"1000110\\\", 71: \\\"1000111\\\", 72: \\\"1001000\\\", 73: \\\"1001001\\\", 74: \\\"1001010\\\",\\n\\t75: \\\"1001011\\\", 76: \\\"1001100\\\", 77: \\\"1001101\\\", 78: \\\"1001110\\\", 79: \\\"1001111\\\",\\n\\t80: \\\"1010000\\\", 81: \\\"1010001\\\", 82: \\\"1010010\\\", 83: \\\"1010011\\\", 84: \\\"1010100\\\",\\n\\t85: \\\"1010101\\\", 86: \\\"1010110\\\", 87: \\\"1010111\\\", 88: \\\"1011000\\\", 89: \\\"1011001\\\",\\n\\t90: \\\"1011010\\\", 91: \\\"1011011\\\", 92: \\\"1011100\\\", 93: \\\"1011101\\\", 94: \\\"1011110\\\",\\n\\t95: \\\"1011111\\\", 96: \\\"1100000\\\", 97: \\\"1100001\\\", 98: \\\"1100010\\\", 99: \\\"1100011\\\",\\n\\t100: \\\"1100100\\\",\\n}\\n\\nfunc TestDecimalToBinary(t *testing.T) {\\n\\tfor input, expected := range decimalTestCases {\\n\\t\\tout, err := DecimalToBinary(input)\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Errorf(\\\"DecimalToBinary(%d) returned an error %s\\\", input, err.Error())\\n\\t\\t}\\n\\t\\tif out != expected {\\n\\t\\t\\tt.Errorf(\\\"DecimalToBinary(%d) = %s; want %s\\\", input, out, expected)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkDecimalToBinary(b *testing.B) {\\n\\tb.ReportAllocs()\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = DecimalToBinary(100)\\n\\t}\\n}\\n\"",
    "integerto roman": "\"package conversion\\n\\nimport (\\n\\t\\\"errors\\\"\\n)\\n\\nvar (\\n\\t// lookup arrays used for converting from an int to a roman numeral extremely quickly.\\n\\tr0 = []string{\\\"\\\", \\\"I\\\", \\\"II\\\", \\\"III\\\", \\\"IV\\\", \\\"V\\\", \\\"VI\\\", \\\"VII\\\", \\\"VIII\\\", \\\"IX\\\"} // 1 - 9\\n\\tr1 = []string{\\\"\\\", \\\"X\\\", \\\"XX\\\", \\\"XXX\\\", \\\"XL\\\", \\\"L\\\", \\\"LX\\\", \\\"LXX\\\", \\\"LXXX\\\", \\\"XC\\\"} // 10 - 90\\n\\tr2 = []string{\\\"\\\", \\\"C\\\", \\\"CC\\\", \\\"CCC\\\", \\\"CD\\\", \\\"D\\\", \\\"DC\\\", \\\"DCC\\\", \\\"DCCC\\\", \\\"CM\\\"} // 100 - 900\\n\\tr3 = []string{\\\"\\\", \\\"M\\\", \\\"MM\\\", \\\"MMM\\\"}                                       // 1,000 - 3,000\\n)\\n\\n// IntToRoman converts an integer value to a roman numeral string. An error is\\n// returned if the integer is not between 1 and 3999.\\nfunc IntToRoman(n int) (string, error) {\\n\\tif n < 1 || n > 3999 {\\n\\t\\treturn \\\"\\\", errors.New(\\\"integer must be between 1 and 3999\\\")\\n\\t}\\n\\t// Concatenate strings for each of 4 lookup array categories.\\n\\t//\\n\\t// Key behavior to note here is how math with integers is handled. Values are floored to the\\n\\t// nearest int, not rounded up. For example, 26/10 = 2 even though the actual result is 2.6.\\n\\t//\\n\\t// For example, lets use an input value of 126:\\n\\t// `r3[n%1e4/1e3]` --> 126 % 10_000 = 126 --> 126 / 1_000 = 0.126 (0 as int) --> r3[0] = \\\"\\\"\\n\\t// `r2[n%1e3/1e2]` --> 126 % 1_000 = 126 --> 126 / 100 = 1.26 (1 as int) --> r2[1] = \\\"C\\\"\\n\\t// `r1[n%100/10]` --> 126 % 100 = 26 --> 26 / 10 = 2.6 (2 as int) --> r1[2] = \\\"XX\\\"\\n\\t// `r0[n%10]` --> 126 % 10 = 6 --> r0[6] = \\\"VI\\\"\\n\\t// FINAL --> \\\"\\\" + \\\"C\\\" + \\\"XX\\\" + \\\"VI\\\" = \\\"CXXVI\\\"\\n\\t//\\n\\t// This is efficient in Go. The 4 operands are evaluated,\\n\\t// then a single allocation is made of the exact size needed for the result.\\n\\treturn r3[n%1e4/1e3] + r2[n%1e3/1e2] + r1[n%100/10] + r0[n%10], nil\\n}\\n\"",
    "integerto roman test": "\"package conversion\\n\\nimport \\\"testing\\\"\\n\\nfunc TestIntToRoman(t *testing.T) {\\n\\tfor expected, input := range romanTestCases {\\n\\t\\tout, err := IntToRoman(input)\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Errorf(\\\"IntToRoman(%d) returned an error %s\\\", input, err.Error())\\n\\t\\t}\\n\\t\\tif out != expected {\\n\\t\\t\\tt.Errorf(\\\"IntToRoman(%d) = %s; want %s\\\", input, out, expected)\\n\\t\\t}\\n\\t}\\n\\t_, err := IntToRoman(100000)\\n\\tif err == nil {\\n\\t\\tt.Errorf(\\\"IntToRoman(%d) expected an error\\\", 100000)\\n\\t}\\n\\t_, err = IntToRoman(0)\\n\\tif err == nil {\\n\\t\\tt.Errorf(\\\"IntToRoman(%d) expected an error\\\", 0)\\n\\t}\\n}\\n\\nfunc BenchmarkIntToRoman(b *testing.B) {\\n\\tb.ReportAllocs()\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = IntToRoman(3999)\\n\\t}\\n}\\n\"",
    "rgbhex": "\"// rgbhex.go\\n// description: convert hex input to red, green and blue and vice versa\\n// author(s) [darmiel](https://github.com/darmiel)\\n// see rgbhex_test.go\\n\\npackage conversion\\n\\n// HEXToRGB splits an RGB input (e.g. a color in hex format; 0x<color-code>)\\n// into the individual components: red, green and blue\\nfunc HEXToRGB(hex uint) (red, green, blue byte) {\\n\\t// A hex code is structured like this:\\n\\t// #3498db (light blue) - converted to binary:\\n\\t// 00110100 10011000 11011011\\n\\t//  <red>   <green>   <blue>\\n\\n\\t// To get the blue value we use the bit operation AND with the bit mask 0xFF (in binary: 11111111)\\n\\t// 00110100 10011000 <11011011> &\\n\\t// 00000000 00000000  11111111  =\\n\\t// 00000000 00000000 <11011011> =\\n\\tblue = byte(hex & 0xFF)\\n\\n\\t// To get the green value, we first shift the value 8 bits to the right:\\n\\t//  00110100 <10011000>  11011011  >> 8 =\\n\\t//  00000000  00110100  <10011000> &\\n\\t//  00000000  00000000   11111111  =\\n\\t//  00000000  00000000  <10011000> =\\n\\tgreen = byte((hex >> 8) & 0xFF)\\n\\n\\t// Same as green value, only this time shift 16 to the right\\n\\t// Alternatively, you can apply a bitmask first and then shift it.\\n\\t// <00110100> 10011000  11011011 &\\n\\t//  11111111  00000000  00000000 =\\n\\t// <00110100> 00000000  00000000 >> 16\\n\\t//  00000000  00000000 <00110100> =\\n\\tred = byte((hex >> 16) & 0xFF)\\n\\treturn\\n}\\n\\n// RGBToHEX does exactly the opposite of HEXToRGB:\\n// it combines the three components red, green and blue to an RGB value, which can be converted to e.g. Hex\\nfunc RGBToHEX(red, green, blue byte) (hex uint) {\\n\\t// Sets the bits of blue in position 1-8, green in 9-16 and red in 17-24\\n\\n\\t// Red: 00110100\\n\\t// Green: 10011000\\n\\t// Blue: 11011011\\n\\t// RGB:\\n\\t// R << 16: [00110100]  00000000   00000000 |\\n\\t// G << 8 :  00000000  {10011000}  00000000 |\\n\\t// B      :  00000000   00000000  <11011011> =\\n\\t//          [00110100] {10011000} <11011011>\\n\\treturn (uint(red) << 16) | (uint(green) << 8) | uint(blue)\\n}\\n\"",
    "rgbhex test": "\"package conversion\\n\\nimport \\\"testing\\\"\\n\\nvar HEX = []uint{\\n\\t0x1abc9c,\\n\\t0x3498db,\\n\\t0x9b59b6,\\n}\\n\\nvar RGB = [][]byte{\\n\\t{26, 188, 156},\\n\\t{52, 152, 219},\\n\\t{155, 89, 182},\\n}\\n\\nfunc TestHEXToRGB(t *testing.T) {\\n\\tfor i := 0; i < len(HEX); i++ {\\n\\t\\thex := HEX[i]\\n\\t\\texpected := RGB[i]\\n\\t\\tresultR, resultG, resultB := HEXToRGB(hex)\\n\\t\\tif resultR != expected[0] || resultG != expected[1] || resultB != expected[2] {\\n\\t\\t\\tt.Errorf(\\\"HEXToRGB(%d) = %d,%d,%d; want %d,%d,%d\\\",\\n\\t\\t\\t\\thex, resultR, resultG, resultB, expected[0], expected[1], expected[2])\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkHEXToRGB(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _, _ = HEXToRGB(0xdeadbe)\\n\\t}\\n}\\n\\nfunc TestRGBToHEX(t *testing.T) {\\n\\tfor i := 0; i < len(RGB); i++ {\\n\\t\\targs := RGB[i]\\n\\t\\texpected := HEX[i]\\n\\t\\tresult := RGBToHEX(args[0], args[1], args[2])\\n\\t\\tif result != expected {\\n\\t\\t\\tt.Errorf(\\\"RGBToHEX(%d,%d,%d) = %d; want %d\\\",\\n\\t\\t\\t\\targs[0], args[1], args[2], result, expected)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkRGBToHEX(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_ = RGBToHEX(222, 173, 190)\\n\\t}\\n}\\n\"",
    "romanto integer": "\"// This algorithm will convert a standard roman number to an integer\\n// https://en.wikipedia.org/wiki/Roman_numerals\\n// Function receives a string as a roman number and outputs an integer\\n// Maximum output will be 3999\\n// Only standard form is supported\\n\\npackage conversion\\n\\nimport (\\n\\t\\\"errors\\\"\\n\\t\\\"strings\\\"\\n)\\n\\n// numeral describes the value and symbol of a single roman numeral\\ntype numeral struct {\\n\\tval int\\n\\tsym string\\n}\\n\\n// lookup array for numeral values sorted by largest to smallest\\nvar nums = []numeral{\\n\\t{1000, \\\"M\\\"},\\n\\t{900, \\\"CM\\\"},\\n\\t{500, \\\"D\\\"},\\n\\t{400, \\\"CD\\\"},\\n\\t{100, \\\"C\\\"},\\n\\t{90, \\\"XC\\\"},\\n\\t{50, \\\"L\\\"},\\n\\t{40, \\\"XL\\\"},\\n\\t{10, \\\"X\\\"},\\n\\t{9, \\\"IX\\\"},\\n\\t{5, \\\"V\\\"},\\n\\t{4, \\\"IV\\\"},\\n\\t{1, \\\"I\\\"},\\n}\\n\\n// RomanToInteger converts a roman numeral string to an integer. Roman numerals for numbers\\n// outside the range 1 to 3,999 will return an error. Nil or empty string return 0\\n// with no error thrown.\\nfunc RomanToInteger(input string) (int, error) {\\n\\tif input == \\\"\\\" {\\n\\t\\treturn 0, nil\\n\\t}\\n\\tvar output int\\n\\tfor _, n := range nums {\\n\\t\\tfor strings.HasPrefix(input, n.sym) {\\n\\t\\t\\toutput += n.val\\n\\t\\t\\tinput = input[len(n.sym):]\\n\\t\\t}\\n\\t}\\n\\t// if we are still left with input string values then the\\n\\t// input was invalid and an error is returned.\\n\\tif len(input) > 0 {\\n\\t\\treturn 0, errors.New(\\\"invalid roman numeral\\\")\\n\\t}\\n\\treturn output, nil\\n}\\n\"",
    "romanto integer test": "\"package conversion\\n\\nimport \\\"testing\\\"\\n\\nvar romanTestCases = map[string]int{\\n\\t\\\"I\\\": 1, \\\"II\\\": 2, \\\"III\\\": 3, \\\"IV\\\": 4, \\\"V\\\": 5, \\\"VI\\\": 6,\\n\\t\\\"VII\\\": 7, \\\"VIII\\\": 8, \\\"IX\\\": 9, \\\"X\\\": 10, \\\"XI\\\": 11, \\\"XII\\\": 12,\\n\\t\\\"XIII\\\": 13, \\\"XIV\\\": 14, \\\"XV\\\": 15, \\\"XVI\\\": 16, \\\"XVII\\\": 17,\\n\\t\\\"XVIII\\\": 18, \\\"XIX\\\": 19, \\\"XX\\\": 20, \\\"XXXI\\\": 31, \\\"XXXII\\\": 32,\\n\\t\\\"XXXIII\\\": 33, \\\"XXXIV\\\": 34, \\\"XXXV\\\": 35, \\\"XXXVI\\\": 36, \\\"XXXVII\\\": 37,\\n\\t\\\"XXXVIII\\\": 38, \\\"XXXIX\\\": 39, \\\"XL\\\": 40, \\\"XLI\\\": 41, \\\"XLII\\\": 42,\\n\\t\\\"XLIII\\\": 43, \\\"XLIV\\\": 44, \\\"XLV\\\": 45, \\\"XLVI\\\": 46, \\\"XLVII\\\": 47,\\n\\t\\\"XLVIII\\\": 48, \\\"XLIX\\\": 49, \\\"L\\\": 50, \\\"LXXXIX\\\": 89, \\\"XC\\\": 90,\\n\\t\\\"XCI\\\": 91, \\\"XCII\\\": 92, \\\"XCIII\\\": 93, \\\"XCIV\\\": 94, \\\"XCV\\\": 95,\\n\\t\\\"XCVI\\\": 96, \\\"XCVII\\\": 97, \\\"XCVIII\\\": 98, \\\"XCIX\\\": 99, \\\"C\\\": 100,\\n\\t\\\"CI\\\": 101, \\\"CII\\\": 102, \\\"CIII\\\": 103, \\\"CIV\\\": 104, \\\"CV\\\": 105,\\n\\t\\\"CVI\\\": 106, \\\"CVII\\\": 107, \\\"CVIII\\\": 108, \\\"CIX\\\": 109, \\\"CXLIX\\\": 149,\\n\\t\\\"CCCXLIX\\\": 349, \\\"CDLVI\\\": 456, \\\"D\\\": 500, \\\"DCIV\\\": 604, \\\"DCCLXXXIX\\\": 789,\\n\\t\\\"DCCCXLIX\\\": 849, \\\"CMIV\\\": 904, \\\"M\\\": 1000, \\\"MVII\\\": 1007, \\\"MLXVI\\\": 1066,\\n\\t\\\"MCCXXXIV\\\": 1234, \\\"MDCCLXXVI\\\": 1776, \\\"MMXXI\\\": 2021, \\\"MMDCCCVI\\\": 2806,\\n\\t\\\"MMCMXCIX\\\": 2999, \\\"MMM\\\": 3000, \\\"MMMCMLXXIX\\\": 3979, \\\"MMMCMXCIX\\\": 3999,\\n}\\n\\nfunc TestRomanToInteger(t *testing.T) {\\n\\tfor input, expected := range romanTestCases {\\n\\t\\tout, err := RomanToInteger(input)\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Errorf(\\\"RomanToInteger(%s) returned an error %s\\\", input, err.Error())\\n\\t\\t}\\n\\t\\tif out != expected {\\n\\t\\t\\tt.Errorf(\\\"RomanToInteger(%s) = %d; want %d\\\", input, out, expected)\\n\\t\\t}\\n\\t}\\n\\t_, err := RomanToInteger(\\\"IVCMXCIX\\\")\\n\\tif err == nil {\\n\\t\\tt.Error(\\\"RomanToInteger(IVCMXCIX) expected an error\\\")\\n\\t}\\n\\n\\tval, err := RomanToInteger(\\\"\\\")\\n\\tif val != 0 {\\n\\t\\tt.Errorf(\\\"RomanToInteger(\\\\\\\"\\\\\\\") = %d; want 0\\\", val)\\n\\t}\\n\\tif err != nil {\\n\\t\\tt.Errorf(\\\"RomanToInteger(\\\\\\\"\\\\\\\") returned an error %s\\\", err.Error())\\n\\t}\\n}\\n\\nfunc BenchmarkRomanToInteger(b *testing.B) {\\n\\tb.ReportAllocs()\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = RomanToInteger(\\\"MMMCMXCIX\\\")\\n\\t}\\n}\\n\"",
    "binomial coefficient": "\"package dynamic\\n\\nimport \\\"github.com/TheAlgorithms/Go/math/min\\\"\\n\\n// func main() {\\n// \\tmyArrayOfK := [4]int{5, 6, 7, 8}\\n// \\tvar x int\\n\\n// \\tfmt.Println(\\\"\\\\nBinomial Coefficient Using Dynamic Programming:\\\", bin2(50, 5))\\n// \\tfor _, element := range myArrayOfK {\\n// \\t\\tstart := time.Now()\\n// \\t\\tx = bin2(50, element)\\n// \\t\\telapsed := time.Since(start)\\n// \\t\\tfmt.Println(\\\"bin2 (50,\\\", element, \\\") = \\\", x, \\\"    took \\\", elapsed)\\n\\n// \\t}\\n\\n// }\\n\\n// Bin2 function\\nfunc Bin2(n int, k int) int {\\n\\tvar i, j int\\n\\tB := make([][]int, (n + 1))\\n\\tfor i := range B {\\n\\t\\tB[i] = make([]int, k+1)\\n\\t}\\n\\n\\tfor i = 0; i <= n; i++ {\\n\\t\\tfor j = 0; j <= min.Int(i, k); j++ {\\n\\t\\t\\tif j == 0 || j == i {\\n\\t\\t\\t\\tB[i][j] = 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tB[i][j] = B[i-1][j-1] + B[i-1][j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn B[n][k]\\n}\\n\"",
    "binomial coefficient test": "\"package dynamic_test\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n\\n\\t\\\"github.com/TheAlgorithms/Go/dynamic\\\"\\n)\\n\\nfunc TestBin2(t *testing.T) {\\n\\ttd := []struct {\\n\\t\\tn, k, expected int\\n\\t}{\\n\\t\\t{0, 0, 1},\\n\\t\\t{1, 1, 1},\\n\\t\\t{2, 0, 1}, {2, 1, 2}, {2, 2, 1},\\n\\t\\t{3, 0, 1}, {3, 1, 3}, {3, 2, 3}, {3, 3, 1},\\n\\t\\t{4, 0, 1}, {4, 1, 4}, {4, 2, 6}, {4, 3, 4}, {4, 4, 1},\\n\\t\\t{5, 0, 1}, {5, 1, 5}, {5, 2, 10}, {5, 3, 10}, {5, 4, 5}, {5, 5, 1},\\n\\t\\t{10, 2, 45},\\n\\t\\t{15, 10, 3003},\\n\\t}\\n\\tfor _, tc := range td {\\n\\t\\tname := fmt.Sprintf(\\\"binomial coefficient of (%d, %d)\\\", tc.n, tc.k)\\n\\t\\tt.Run(name, func(t *testing.T) {\\n\\t\\t\\tactual := dynamic.Bin2(tc.n, tc.k)\\n\\t\\t\\tif actual != tc.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"expecting binomial coefficient of (%d, %d) to be %d but got %d\\\", tc.n, tc.k, tc.expected, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "catalan": "\"//The Catalan numbers are a sequence of positive integers that appear in many counting\\n//problems in combinatorics.\\n//reference: https://brilliant.org/wiki/catalan-numbers/\\n\\npackage dynamic\\n\\nimport \\\"fmt\\\"\\n\\nvar errCatalan = fmt.Errorf(\\\"can't have a negative n-th catalan number\\\")\\n\\n// NthCatalan returns the n-th Catalan Number\\n// Complexity: O(n²)\\nfunc NthCatalanNumber(n int) (int64, error) {\\n\\tif n < 0 {\\n\\t\\t//doesn't accept negative number\\n\\t\\treturn 0, errCatalan\\n\\t}\\n\\n\\tvar catalanNumberList []int64\\n\\tcatalanNumberList = append(catalanNumberList, 1) //first value is 1\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tcatalanNumberList = append(catalanNumberList, 0) //append 0 and calculate\\n\\n\\t\\tfor j := 0; j < i; j++ {\\n\\t\\t\\tcatalanNumberList[i] += catalanNumberList[j] * catalanNumberList[i-j-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn catalanNumberList[n], nil\\n}\\n\"",
    "catalan test": "\"package dynamic\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestCatalanNumbers(t *testing.T) {\\n\\tvar testCatalanNumbersData = []struct {\\n\\t\\tnthCatalanNumber      int\\n\\t\\texpectedCatalanNumber int64\\n\\t\\texpectedError         error\\n\\t}{\\n\\t\\t{nthCatalanNumber: -1000, expectedCatalanNumber: 0, expectedError: errCatalan},\\n\\t\\t{nthCatalanNumber: -1, expectedCatalanNumber: 0, expectedError: errCatalan},\\n\\t\\t{nthCatalanNumber: 0, expectedCatalanNumber: 1, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 1, expectedCatalanNumber: 1, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 2, expectedCatalanNumber: 2, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 3, expectedCatalanNumber: 5, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 4, expectedCatalanNumber: 14, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 5, expectedCatalanNumber: 42, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 6, expectedCatalanNumber: 132, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 7, expectedCatalanNumber: 429, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 8, expectedCatalanNumber: 1430, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 9, expectedCatalanNumber: 4862, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 10, expectedCatalanNumber: 16796, expectedError: nil},\\n\\t\\t{nthCatalanNumber: 1000, expectedCatalanNumber: 4233371109654655040, expectedError: nil},\\n\\t}\\n\\n\\tfor i := range testCatalanNumbersData {\\n\\t\\tt.Run(fmt.Sprintf(\\\"the %dth Catalan Number\\\", testCatalanNumbersData[i].nthCatalanNumber), func(t *testing.T) {\\n\\t\\t\\tnthCatalanNumber := testCatalanNumbersData[i].nthCatalanNumber\\n\\t\\t\\tresult, err := NthCatalanNumber(nthCatalanNumber)\\n\\t\\t\\texpectedCatalanNumber := testCatalanNumbersData[i].expectedCatalanNumber\\n\\t\\t\\texpectedError := testCatalanNumbersData[i].expectedError\\n\\n\\t\\t\\tif err != expectedError {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected %dth Catalan Number error: %d\\\\nFound: %d\\\\n\\\", nthCatalanNumber, expectedError, err)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif result != expectedCatalanNumber {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected %dth Catalan Number: %d\\\\nFound: %d\\\\n\\\", nthCatalanNumber, expectedCatalanNumber, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "dynamic test": "\"// Empty test file to keep track of all the tests for the algorithms.\\n\\npackage dynamic\\n\"",
    "edit distance": "\"// EDIT DISTANCE PROBLEM\\n// https://www.geeksforgeeks.org/edit-distance-dp-5/\\n// https://leetcode.com/problems/edit-distance/\\n\\npackage dynamic\\n\\nimport \\\"github.com/TheAlgorithms/Go/math/min\\\"\\n\\n// EditDistanceRecursive is a naive implementation with exponential time complexity.\\nfunc EditDistanceRecursive(first string, second string, pointerFirst int, pointerSecond int) int {\\n\\n\\tif pointerFirst == 0 {\\n\\t\\treturn pointerSecond\\n\\t}\\n\\n\\tif pointerSecond == 0 {\\n\\t\\treturn pointerFirst\\n\\t}\\n\\n\\t// Characters match, so we recur for the remaining portions\\n\\tif first[pointerFirst-1] == second[pointerSecond-1] {\\n\\t\\treturn EditDistanceRecursive(first, second, pointerFirst-1, pointerSecond-1)\\n\\t}\\n\\n\\t// We have three choices, all with cost of 1 unit\\n\\treturn 1 + min.Int(EditDistanceRecursive(first, second, pointerFirst, pointerSecond-1), // Insert\\n\\t\\tEditDistanceRecursive(first, second, pointerFirst-1, pointerSecond),   // Delete\\n\\t\\tEditDistanceRecursive(first, second, pointerFirst-1, pointerSecond-1)) // Replace\\n}\\n\\n// EditDistanceDP is an optimised implementation which builds on the ideas of the recursive implementation.\\n// We use dynamic programming to compute the DP table where dp[i][j] denotes the edit distance value\\n// of first[0..i-1] and second[0..j-1]. Time complexity is O(m * n) where m and n are lengths of the strings,\\n// first and second respectively.\\nfunc EditDistanceDP(first string, second string) int {\\n\\n\\tm := len(first)\\n\\tn := len(second)\\n\\n\\t// Create the DP table\\n\\tdp := make([][]int, m+1)\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tdp[i] = make([]int, n+1)\\n\\t}\\n\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\n\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\tdp[i][j] = j\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tif j == 0 {\\n\\t\\t\\t\\tdp[i][j] = i\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tif first[i-1] == second[j-1] {\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1]\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[i][j] = 1 + min.Int(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m][n]\\n}\\n\"",
    "edit distance test": "\"package dynamic\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc Test_EditDistance(t *testing.T) {\\n\\n\\tvar testCases = []struct {\\n\\t\\tfirst    string\\n\\t\\tsecond   string\\n\\t\\texpected int\\n\\t}{\\n\\t\\t{\\\"\\\", \\\"\\\", 0},\\n\\t\\t{\\\"horse\\\", \\\"ros\\\", 3},\\n\\t\\t{\\\"intention\\\", \\\"execution\\\", 5},\\n\\t\\t{\\\"abcdxabcde\\\", \\\"abcdeabcdx\\\", 2},\\n\\t\\t{\\\"sunday\\\", \\\"saturday\\\", 3},\\n\\t\\t{\\\"food\\\", \\\"money\\\", 4},\\n\\t\\t{\\\"voldemort\\\", \\\"dumbledore\\\", 7},\\n\\t}\\n\\n\\tfor i := range testCases {\\n\\n\\t\\tt.Run(fmt.Sprintf(\\\"Word 1: %s, Word 2: %s\\\", testCases[i].first, testCases[i].second), func(t *testing.T) {\\n\\n\\t\\t\\tcomputed := EditDistanceDP(testCases[i].first, testCases[i].second)\\n\\n\\t\\t\\tif computed != testCases[i].expected {\\n\\t\\t\\t\\tt.Errorf(\\\"Word 1: %s, Word 2: %s, Expected: %d, Computed: %d\\\", testCases[i].first, testCases[i].second, testCases[i].expected, computed)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "fibonacci": "\"package dynamic\\n\\n// https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/\\n\\n// NthFibonacci returns the nth Fibonacci Number\\nfunc NthFibonacci(n uint) uint {\\n\\tif n == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// n1 and n2 are the (i-1)th and ith Fibonacci numbers, respectively\\n\\tvar n1, n2 uint = 0, 1\\n\\n\\tfor i := uint(1); i < n; i++ {\\n\\t\\tn3 := n1 + n2\\n\\t\\tn1 = n2\\n\\t\\tn2 = n3\\n\\t}\\n\\n\\treturn n2\\n}\\n\"",
    "fibonacci test": "\"package dynamic\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc Test_NthFibonacci(t *testing.T) {\\n\\t// source: http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibtable.html\\n\\tvar fibonacciNumbers = []struct {\\n\\t\\tnth       uint\\n\\t\\tfibonacci uint\\n\\t}{\\n\\t\\t{0, 0},\\n\\t\\t{1, 1},\\n\\t\\t{2, 1},\\n\\t\\t{3, 2},\\n\\t\\t{4, 3},\\n\\t\\t{5, 5},\\n\\t\\t{6, 8},\\n\\t\\t{7, 13},\\n\\t\\t{8, 21},\\n\\t\\t{9, 34},\\n\\t\\t{10, 55},\\n\\t\\t{20, 6765},\\n\\t\\t{30, 832040},\\n\\t\\t{40, 102334155},\\n\\t\\t{50, 12586269025},\\n\\t\\t{60, 1548008755920},\\n\\t\\t{70, 190392490709135},\\n\\t\\t{80, 23416728348467685},\\n\\t\\t{90, 2880067194370816120},\\n\\t}\\n\\tfor i := range fibonacciNumbers {\\n\\t\\tt.Run(fmt.Sprintf(\\\"the %dth Fibonacci number\\\", fibonacciNumbers[i].nth), func(t *testing.T) {\\n\\t\\t\\tresult := NthFibonacci(fibonacciNumbers[i].nth)\\n\\t\\t\\tif result != fibonacciNumbers[i].fibonacci {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected the %dth Fibonacci number to be %d, got %d\\\", fibonacciNumbers[i].nth, fibonacciNumbers[i].fibonacci, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "knapsack": "\"package dynamic\\n\\n// Knapsack Problem\\n// https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/\\n\\nimport (\\n\\t\\\"math\\\"\\n)\\n\\n// Max function - possible duplicate\\nfunc Max(a, b int) int {\\n\\treturn int(math.Max(float64(a), float64(b)))\\n}\\n\\n// Knapsack solves knapsack problem\\n// return maxProfit\\nfunc Knapsack(maxWeight int, weights, values []int) int {\\n\\tn := len(weights)\\n\\tm := maxWeight\\n\\t// create dp data structure\\n\\tdp := make([][]int, n+1)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([]int, m+1)\\n\\t}\\n\\tfor i := 0; i < len(weights); i++ {\\n\\t\\tfor j := 0; j <= maxWeight; j++ {\\n\\t\\t\\tif weights[i] > j {\\n\\t\\t\\t\\tdp[i+1][j] = dp[i][j]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[i+1][j] = Max(dp[i][j-weights[i]]+values[i], dp[i][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n][m]\\n}\\n\\n/*\\nfunc main() {\\n\\tmaxWeight := 50\\n\\tvalues := []int{\\n\\t\\t60, 100, 120,\\n\\t}\\n\\tweights := []int{\\n\\t\\t10, 20, 30,\\n\\t}\\n\\tmaxProfit := Knapsack(maxWeight, weights, values)\\n\\tfmt.Println(maxProfit)\\n}\\n*/\\n\"",
    "knapsack test": "\"package dynamic_test\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n\\n\\t\\\"github.com/TheAlgorithms/Go/dynamic\\\"\\n)\\n\\nfunc TestKnapsack(t *testing.T) {\\n\\ttd := []struct {\\n\\t\\tmaxWeight int\\n\\t\\tweights   []int\\n\\t\\tvalues    []int\\n\\t\\texpected  int\\n\\t}{\\n\\t\\t{0, []int{0}, []int{0}, 0},\\n\\t\\t{10, []int{1, 2, 3}, []int{1, 1, 1}, 3},                              // picks all\\n\\t\\t{10, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 1, 1, 1, 1}, 4},            // picks 1,2,3,4\\n\\t\\t{10, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 1, 1, 1, 5}, 7},            // picks 1,3,6\\n\\t\\t{10, []int{1, 2, 3, 4, 5, 6}, []int{-1, 10, -3, -4, 10, 1}, 20},      // picks 2,5\\n\\t\\t{10, []int{1, 2, 3, 4, 5, 6}, []int{-10, -10, -10, -10, 10, 10}, 10}, // picks 5 or 6\\n\\t}\\n\\tfor _, tc := range td {\\n\\t\\tname := fmt.Sprintf(\\\"Knapsack problem with (maxWeight: %d, weights: %v, values: %v)\\\", tc.maxWeight, tc.weights, tc.values)\\n\\t\\tt.Run(name, func(t *testing.T) {\\n\\t\\t\\tactual := dynamic.Knapsack(tc.maxWeight, tc.weights, tc.values)\\n\\t\\t\\tif actual != tc.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"expecting knapsack with (maxWeight: %d, weights: %v, values: %v) to return %d but got %d\\\", tc.maxWeight, tc.weights, tc.values, tc.expected, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc ExampleKnapsack() {\\n\\tfmt.Print(dynamic.Knapsack(10, []int{4, 5, 8}, []int{50, 15, 60}))\\n\\t//Output:65\\n}\\n\"",
    "longest common subsequence": "\"// LONGEST COMMON SUBSEQUENCE\\n// DP - 4\\n// https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/\\n\\npackage dynamic\\n\\n// LongestCommonSubsequence function\\nfunc LongestCommonSubsequence(a string, b string, m int, n int) int {\\n\\t// m is the length of string a and n is the length of string b\\n\\n\\t// here we are making a 2d slice of size (m+1)*(n+1)\\n\\tlcs := make([][]int, m+1)\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tlcs[i] = make([]int, n+1)\\n\\t}\\n\\n\\t// block that implements LCS\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tif i == 0 || j == 0 {\\n\\t\\t\\t\\tlcs[i][j] = 0\\n\\t\\t\\t} else if a[i-1] == b[j-1] {\\n\\t\\t\\t\\tlcs[i][j] = lcs[i-1][j-1] + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlcs[i][j] = Max(lcs[i-1][j], lcs[i][j-1])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// returning the length of longest common subsequence\\n\\treturn lcs[m][n]\\n}\\n\\n// func main(){\\n// \\t// declaring two strings and asking for input\\n\\n// \\tvar a,b string\\n// \\tfmt.Scan(&a, &b)\\n// \\t// calling the LCS function\\n// \\tfmt.Println(\\\"The length of longest common subsequence is:\\\", longestCommonSubsequence(a,b, len(a), len(b)))\\n// }\\n\"",
    "longest increasing subsequence": "\"package dynamic\\n\\nimport (\\n\\t\\\"github.com/TheAlgorithms/Go/math/max\\\"\\n)\\n\\n// LongestIncreasingSubsequence returns the longest increasing subsequence\\n// where all elements of the subsequence are sorted in increasing order\\nfunc LongestIncreasingSubsequence(elements []int) int {\\n\\tn := len(elements)\\n\\tlis := make([]int, n)\\n\\tfor i := range lis {\\n\\t\\tlis[i] = 1\\n\\t}\\n\\tfor i := range lis {\\n\\t\\tfor j := 0; j < i; j++ {\\n\\t\\t\\tif elements[i] > elements[j] && lis[i] < lis[j]+1 {\\n\\t\\t\\t\\tlis[i] = lis[j] + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tres := 0\\n\\tfor _, value := range lis {\\n\\t\\tres = max.Int(res, value)\\n\\t}\\n\\treturn res\\n}\\n\"",
    "longest increasing subsequence test": "\"package dynamic_test\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n\\n\\t\\\"github.com/TheAlgorithms/Go/dynamic\\\"\\n)\\n\\nfunc TestLongestIncreasingSubsequence(t *testing.T) {\\n\\ttd := []struct {\\n\\t\\telements    []int\\n\\t\\texpectedLen int\\n\\t}{\\n\\t\\t{[]int{1, 2, 3, 4, 5, 10}, 6},\\n\\t\\t{[]int{1, 7, 3, 4, 5}, 4}, // 1,3,4,5\\n\\t\\t{[]int{1, 3, 5}, 3},\\n\\t\\t{[]int{7, 1, 6}, 2},\\n\\t\\t{[]int{4, 1, 6, 2}, 2},\\n\\t\\t{[]int{11, 9, 6}, 1},\\n\\t}\\n\\tfor _, tc := range td {\\n\\t\\tt.Run(fmt.Sprint(\\\"test with\\\", tc.elements), func(t *testing.T) {\\n\\t\\t\\tactualLen := dynamic.LongestIncreasingSubsequence(tc.elements)\\n\\t\\t\\tif tc.expectedLen != actualLen {\\n\\t\\t\\t\\tt.Fatalf(\\\"expecting a sequence of len %d to be found but the actual len was %d; input: %v\\\", tc.expectedLen, actualLen, tc.elements)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "longest palindromic subsequence": "\"// longest palindromic subsequence\\n// http://www.geeksforgeeks.org/dynamic-programming-set-12-longest-palindromic-subsequence/\\n\\npackage dynamic\\n\\n// LpsRec function\\nfunc LpsRec(word string, i, j int) int {\\n\\tif i == j {\\n\\t\\treturn 1\\n\\t}\\n\\tif i > j {\\n\\t\\treturn 0\\n\\t}\\n\\tif word[i] == word[j] {\\n\\t\\treturn 2 + LpsRec(word, i+1, j-1)\\n\\t}\\n\\treturn Max(LpsRec(word, i, j-1), LpsRec(word, i+1, j))\\n}\\n\\n// LpsDp function\\nfunc LpsDp(word string) int {\\n\\tN := len(word)\\n\\tdp := make([][]int, N)\\n\\n\\tfor i := 0; i < N; i++ {\\n\\t\\tdp[i] = make([]int, N)\\n\\t\\tdp[i][i] = 1\\n\\t}\\n\\n\\tfor l := 2; l <= N; l++ {\\n\\t\\t// for length l\\n\\t\\tfor i := 0; i < N-l+1; i++ {\\n\\t\\t\\tj := i + l - 1\\n\\t\\t\\tif word[i] == word[j] {\\n\\t\\t\\t\\tif l == 2 {\\n\\t\\t\\t\\t\\tdp[i][j] = 2\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = 2 + dp[i+1][j-1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[i][j] = Max(dp[i+1][j], dp[i][j-1])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[1][N-1]\\n}\\n\\n/*\\nfunc main() {\\n\\t// word := \\\"aaabbbbababbabbabbabf\\\"\\n\\tword := \\\"aaaabbbba\\\"\\n\\tfmt.Printf(\\\"%d\\\\n\\\", lpsRec(word, 0, len(word)-1))\\n\\tfmt.Printf(\\\"%d\\\\n\\\", lpsDp(word))\\n}\\n*/\\n\"",
    "matrix multiplication": "\"// matrix chain multiplication problem\\n// https://en.wikipedia.org/wiki/Matrix_chain_multiplication\\n// www.geeksforgeeks.org/dynamic_programming-set-8-matrix-chain-multiplication/\\n\\npackage dynamic\\n\\nimport \\\"github.com/TheAlgorithms/Go/math/min\\\"\\n\\n// MatrixChainRec function\\nfunc MatrixChainRec(D []int, i, j int) int {\\n\\t// d[i-1] x d[i] : dimension of matrix i\\n\\tif i == j {\\n\\t\\treturn 0\\n\\t}\\n\\tq := 1 << 32\\n\\tfor k := i; k < j; k++ {\\n\\t\\tprod := MatrixChainRec(D, i, k) + MatrixChainRec(D, k+1, j) + D[i-1]*D[k]*D[j]\\n\\t\\tq = min.Int(prod, q)\\n\\t}\\n\\treturn q\\n}\\n\\n// MatrixChainDp function\\nfunc MatrixChainDp(D []int) int {\\n\\t// d[i-1] x d[i] : dimension of matrix i\\n\\tN := len(D)\\n\\n\\tdp := make([][]int, N) // dp[i][j] = matrixChainRec(D, i, j)\\n\\tfor i := 0; i < N; i++ {\\n\\t\\tdp[i] = make([]int, N)\\n\\t\\tdp[i][i] = 0\\n\\t}\\n\\n\\tfor l := 2; l < N; l++ {\\n\\t\\tfor i := 1; i < N-l+1; i++ {\\n\\t\\t\\tj := i + l - 1\\n\\t\\t\\tdp[i][j] = 1 << 31\\n\\t\\t\\tfor k := i; k < j; k++ {\\n\\t\\t\\t\\tprod := dp[i][k] + dp[k+1][j] + D[i-1]*D[k]*D[j]\\n\\t\\t\\t\\tdp[i][j] = min.Int(prod, dp[i][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[1][N-1]\\n}\\n\\n/*\\nfunc main() {\\n\\tD := []int{2, 2, 2, 2, 2} // 4 matrices\\n\\tfmt.Print(matrixChainRec(D, 1, 4), \\\"\\\\n\\\")\\n\\tfmt.Print(matrixChainDp(D), \\\"\\\\n\\\")\\n}\\n*/\\n\"",
    "rodcutting": "\"// Solution to Rod cutting problem\\n// https://en.wikipedia.org/wiki/Cutting_stock_problem\\n// http://www.geeksforgeeks.org/dynamic-programming-set-13-cutting-a-rod/\\n\\npackage dynamic\\n\\n// CutRodRec solve the problem recursively: initial approach\\nfunc CutRodRec(price []int, length int) int {\\n\\tif length == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tq := -1\\n\\tfor i := 1; i <= length; i++ {\\n\\t\\tq = Max(q, price[i]+CutRodRec(price, length-i))\\n\\t}\\n\\treturn q\\n}\\n\\n// CutRodDp solve the same problem using dynamic programming\\nfunc CutRodDp(price []int, length int) int {\\n\\tr := make([]int, length+1) // a.k.a the memoization array\\n\\tr[0] = 0                   // cost of 0 length rod is 0\\n\\n\\tfor j := 1; j <= length; j++ { // for each length (subproblem)\\n\\t\\tq := -1\\n\\t\\tfor i := 1; i <= j; i++ {\\n\\t\\t\\tq = Max(q, price[i]+r[j-i]) // avoiding recursive call\\n\\t\\t}\\n\\t\\tr[j] = q\\n\\t}\\n\\n\\treturn r[length]\\n}\\n\\n/*\\nfunc main() {\\n\\tlength := 10\\n\\tprice := []int{0, 1, 5, 8, 9, 17, 17, 17, 20, 24, 30}\\n\\t// price := []int{0, 10, 5, 8, 9, 17, 17, 17, 20, 24, 30}\\n\\n\\t// fmt.Print(price[5]+price[length-5], \\\"\\\\n\\\")\\n\\n\\tfmt.Print(cutRodRec(price, length), \\\"\\\\n\\\")\\n\\tfmt.Print(cutRodDp(price, length), \\\"\\\\n\\\")\\n}\\n*/\\n\"",
    "subsetsum": "\"//Given a set of non-negative integers, and a (positive) value sum,\\n//determine if there is a subset of the given set with sum\\n//equal to given sum.\\n//Complexity: O(n*sum)\\n//references: https://www.geeksforgeeks.org/subset-sum-problem-dp-25/\\n\\npackage dynamic\\n\\nimport \\\"fmt\\\"\\n\\nvar ErrInvalidPosition = fmt.Errorf(\\\"invalid position in subset\\\")\\nvar ErrNegativeSum = fmt.Errorf(\\\"negative sum is not allowed\\\")\\n\\nfunc IsSubsetSum(array []int, sum int) (bool, error) {\\n\\tif sum < 0 {\\n\\t\\t//not allow negative sum\\n\\t\\treturn false, ErrNegativeSum\\n\\t}\\n\\n\\t//create subset matrix\\n\\tarraySize := len(array)\\n\\tsubset := make([][]bool, arraySize+1)\\n\\tfor i := 0; i <= arraySize; i++ {\\n\\t\\tsubset[i] = make([]bool, sum+1)\\n\\t}\\n\\n\\tfor i := 0; i <= arraySize; i++ {\\n\\t\\t//sum 0 is always true\\n\\t\\tsubset[i][0] = true\\n\\t}\\n\\n\\tfor i := 1; i <= sum; i++ {\\n\\t\\t//empty set is false when sum is not 0\\n\\t\\tsubset[0][i] = false\\n\\t}\\n\\n\\tfor i := 1; i <= arraySize; i++ {\\n\\t\\tfor j := 1; j <= sum; j++ {\\n\\t\\t\\tif array[i-1] > j {\\n\\t\\t\\t\\tsubset[i][j] = subset[i-1][j]\\n\\t\\t\\t}\\n\\n\\t\\t\\tif array[i-1] <= j {\\n\\t\\t\\t\\tif j-array[i-1] < 0 || j-array[i-1] > sum {\\n\\t\\t\\t\\t\\t//out of bounds\\n\\t\\t\\t\\t\\treturn false, ErrInvalidPosition\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tsubset[i][j] = subset[i-1][j] || subset[i-1][j-array[i-1]]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn subset[arraySize][sum], nil\\n}\\n\"",
    "subsetsum test": "\"package dynamic\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestSubsetSum(t *testing.T) {\\n\\n\\tvar subsetSumTestData = []struct {\\n\\t\\tdescription    string\\n\\t\\tarray          []int\\n\\t\\tsum            int\\n\\t\\texpectedResult bool\\n\\t\\texpectedError  error\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tdescription:    \\\"array of size 0 and sum 0\\\",\\n\\t\\t\\tarray:          []int{},\\n\\t\\t\\tsum:            0,\\n\\t\\t\\texpectedResult: true,\\n\\t\\t\\texpectedError:  nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription:    \\\"array of size 0 and non-zero sum\\\",\\n\\t\\t\\tarray:          []int{},\\n\\t\\t\\tsum:            2,\\n\\t\\t\\texpectedResult: false,\\n\\t\\t\\texpectedError:  nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription:    \\\"array of size 2 and sum 0\\\",\\n\\t\\t\\tarray:          []int{1, 2},\\n\\t\\t\\tsum:            0,\\n\\t\\t\\texpectedResult: true,\\n\\t\\t\\texpectedError:  nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription:    \\\"array of size 5 and sum 6\\\",\\n\\t\\t\\tarray:          []int{1, 2, 3, 4, 5},\\n\\t\\t\\tsum:            6,\\n\\t\\t\\texpectedResult: true,\\n\\t\\t\\texpectedError:  nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription:    \\\"array of size 5 and sum 7\\\",\\n\\t\\t\\tarray:          []int{1, 2, 3, 4, 5},\\n\\t\\t\\tsum:            7,\\n\\t\\t\\texpectedResult: true,\\n\\t\\t\\texpectedError:  nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription:    \\\"array of size 5 and sum 17\\\",\\n\\t\\t\\tarray:          []int{1, 2, 3, 4, 5},\\n\\t\\t\\tsum:            17,\\n\\t\\t\\texpectedResult: false,\\n\\t\\t\\texpectedError:  nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription:    \\\"array of size 6 negative values and sum positive\\\",\\n\\t\\t\\tarray:          []int{-1, -2, -3, -4, -5, -6},\\n\\t\\t\\tsum:            1,\\n\\t\\t\\texpectedResult: false,\\n\\t\\t\\texpectedError:  ErrInvalidPosition,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription:    \\\"array of size 6 with positive and negative values, also with a negative sum\\\",\\n\\t\\t\\tarray:          []int{-1, -1, 3, 4, 5, 6},\\n\\t\\t\\tsum:            -2,\\n\\t\\t\\texpectedResult: false,\\n\\t\\t\\texpectedError:  ErrNegativeSum,\\n\\t\\t},\\n\\t}\\n\\n\\tfor i := range subsetSumTestData {\\n\\n\\t\\tt.Run(fmt.Sprintf(subsetSumTestData[i].description), func(t *testing.T) {\\n\\t\\t\\tarray := subsetSumTestData[i].array\\n\\t\\t\\tsum := subsetSumTestData[i].sum\\n\\n\\t\\t\\texpectedResult := subsetSumTestData[i].expectedResult\\n\\t\\t\\tresult, err := IsSubsetSum(array, sum)\\n\\t\\t\\texpectedError := subsetSumTestData[i].expectedError\\n\\n\\t\\t\\tif err != expectedError {\\n\\t\\t\\t\\tt.Logf(\\\"FAIL: %s\\\", subsetSumTestData[i].description)\\n\\t\\t\\t\\tt.Fatalf(\\\"Expected error:%t\\\\nFound: %t\\\", expectedError, err)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif result != expectedResult {\\n\\t\\t\\t\\tt.Logf(\\\"FAIL: %s\\\", subsetSumTestData[i].description)\\n\\t\\t\\t\\tt.Fatalf(\\\"Expected result:%t\\\\nFound: %t\\\", expectedResult, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "bellman ford": "\"// The Bellman–Ford algorithm is an algorithm that computes shortest paths from a\\n// single source vertex to all of the other vertices in a weighted durected graph.\\n// It is slower than Dijkstra but capable of handling negative edge weights.\\n// https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\\n// Implementation is based on the book 'Introduction to Algorithms' (CLRS)\\n\\npackage graph\\n\\nimport (\\n\\t\\\"errors\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc (g *Graph) BellmanFord(start, end int) (isReachable bool, distance int, err error) {\\n\\tINF := math.Inf(1)\\n\\tdistances := make([]float64, g.vertices)\\n\\n\\t// Set all vertices to unreachable, initialize source\\n\\tfor i := 0; i < g.vertices; i++ {\\n\\t\\tdistances[i] = INF\\n\\t}\\n\\tdistances[start] = 0\\n\\n\\t// Making iterations equal to #vertices\\n\\tfor n := 0; n < g.vertices; n++ {\\n\\n\\t\\t// Looping over all edges\\n\\t\\tfor u, adjacents := range g.edges {\\n\\t\\t\\tfor v, weightUV := range adjacents {\\n\\n\\t\\t\\t\\t// If new shorter distance is found, update distance value (relaxation step)\\n\\t\\t\\t\\tif newDistance := distances[u] + float64(weightUV); distances[v] > newDistance {\\n\\t\\t\\t\\t\\tdistances[v] = newDistance\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Check for negative weight cycle\\n\\tfor u, adjacents := range g.edges {\\n\\t\\tfor v, weightUV := range adjacents {\\n\\t\\t\\tif newDistance := distances[u] + float64(weightUV); distances[v] > newDistance {\\n\\t\\t\\t\\treturn false, -1, errors.New(\\\"negative weight cycle present\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn distances[end] != INF, int(distances[end]), nil\\n}\\n\"",
    "bellman ford test": "\"package graph\\n\\nimport (\\n\\t\\\"errors\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestBellmanford(t *testing.T) {\\n\\n\\tvar testCases = []struct {\\n\\t\\tname        string\\n\\t\\tedges       [][]int\\n\\t\\tvertices    int\\n\\t\\tstart       int\\n\\t\\tend         int\\n\\t\\tisReachable bool\\n\\t\\tdistance    int\\n\\t\\terr         error\\n\\t}{\\n\\t\\t{\\n\\t\\t\\t\\\"single edge\\\",\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 1, 1},\\n\\t\\t\\t},\\n\\t\\t\\t2, 0, 1, true, 1, nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"negative weights\\\",\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 1, 1},\\n\\t\\t\\t\\t{1, 2, -3},\\n\\t\\t\\t\\t{2, 1, 4},\\n\\t\\t\\t\\t{2, 3, 1},\\n\\t\\t\\t},\\n\\t\\t\\t4, 0, 1, true, 1, nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"negative cycle\\\",\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 1, 1},\\n\\t\\t\\t\\t{1, 2, -3},\\n\\t\\t\\t\\t{2, 1, 1},\\n\\t\\t\\t\\t{2, 3, 1},\\n\\t\\t\\t},\\n\\t\\t\\t4, 0, 1, false, -1, errors.New(\\\"negative weight cycle present\\\"),\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"unreachable vertex\\\",\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 6, 771},\\n\\t\\t\\t\\t{0, 9, 782},\\n\\t\\t\\t\\t{1, 2, 454},\\n\\t\\t\\t\\t{2, 8, 48},\\n\\t\\t\\t\\t{3, 8, 249},\\n\\t\\t\\t\\t{3, 9, 880},\\n\\t\\t\\t\\t{3, 5, 280},\\n\\t\\t\\t\\t{7, 1, 92},\\n\\t\\t\\t\\t{7, 2, 497},\\n\\t\\t\\t\\t{8, 1, 102},\\n\\t\\t\\t\\t{8, 4, 977},\\n\\t\\t\\t},\\n\\t\\t\\t10, 8, 3, false, int(math.Inf(1)), nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"disconnected graph\\\",\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 1, 10},\\n\\t\\t\\t\\t{2, 3, 15},\\n\\t\\t\\t\\t{3, 5, 10},\\n\\t\\t\\t},\\n\\t\\t\\t6, 0, 3, false, int(math.Inf(1)), nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"multiple paths\\\",\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 1, 5},\\n\\t\\t\\t\\t{1, 2, 10},\\n\\t\\t\\t\\t{1, 3, 30},\\n\\t\\t\\t\\t{2, 4, 10},\\n\\t\\t\\t\\t{4, 5, 15},\\n\\t\\t\\t\\t{3, 5, 10},\\n\\t\\t\\t},\\n\\t\\t\\t6, 0, 5, true, 40, nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"random 1\\\",\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 1, 10},\\n\\t\\t\\t\\t{1, 2, 10},\\n\\t\\t\\t\\t{0, 2, 100},\\n\\t\\t\\t\\t{2, 0, -10},\\n\\t\\t\\t\\t{1, 2, 1},\\n\\t\\t\\t},\\n\\t\\t\\t3, 0, 1, true, 10, nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"random 2\\\",\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 1, 5498},\\n\\t\\t\\t\\t{2, 0, 7679},\\n\\t\\t\\t\\t{0, 3, 4999},\\n\\t\\t\\t\\t{1, 2, 8629},\\n\\t\\t\\t\\t{1, 3, -948},\\n\\t\\t\\t\\t{2, 3, 6231},\\n\\t\\t\\t},\\n\\t\\t\\t4, 0, 3, true, 4550, nil,\\n\\t\\t},\\n\\t}\\n\\n\\tfor _, test := range testCases {\\n\\t\\tt.Run(fmt.Sprint(test.name), func(t *testing.T) {\\n\\t\\t\\t// Initializing graph, adding edges\\n\\t\\t\\tgraph := New(test.vertices)\\n\\t\\t\\tgraph.Directed = true\\n\\t\\t\\tfor _, edge := range test.edges {\\n\\t\\t\\t\\tgraph.AddWeightedEdge(edge[0], edge[1], edge[2])\\n\\t\\t\\t}\\n\\n\\t\\t\\tresIsReachable, resDistance, resError := graph.BellmanFord(test.start, test.end)\\n\\t\\t\\tif resDistance != test.distance {\\n\\t\\t\\t\\tt.Errorf(\\\"Distance, Expected: %d, Computed: %d\\\", test.distance, resDistance)\\n\\t\\t\\t}\\n\\t\\t\\tif resIsReachable != test.isReachable {\\n\\t\\t\\t\\tt.Errorf(\\\"Reachable, Expected: %t, Computed: %t\\\", test.isReachable, resIsReachable)\\n\\t\\t\\t}\\n\\t\\t\\tif resError != test.err {\\n\\t\\t\\t\\tif resError == nil || test.err == nil {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"Reachable, Expected: %s, Computed: %s\\\", test.err, resError)\\n\\t\\t\\t\\t} else if resError.Error() != test.err.Error() {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"Reachable, Expected: %s, Computed: %s\\\", test.err.Error(), resError.Error())\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "breadth first search": "\"package graph\\n\\n// BreadthFirstSearch is an algorithm for traversing and searching graph data structures.\\n// It starts at an arbitrary node of a graph, and explores all of the neighbor nodes\\n// at the present depth prior to moving on to the nodes at the next depth level.\\n// Worst-case performance\\t \\t\\tO(|V|+|E|)=O(b^{d})}O(|V|+|E|)=O(b^{d})\\n// Worst-case space complexity\\t \\tO(|V|)=O(b^{d})}O(|V|)=O(b^{d})\\n// reference: https://en.wikipedia.org/wiki/Breadth-first_search\\nfunc BreadthFirstSearch(start, end, nodes int, edges [][]int) (isConnected bool, distance int) {\\n\\tqueue := make([]int, 0)\\n\\tdiscovered := make([]int, nodes)\\n\\tdiscovered[start] = 1\\n\\tqueue = append(queue, start)\\n\\tfor len(queue) > 0 {\\n\\t\\tv := queue[0]\\n\\t\\tif len(queue) > 0 {\\n\\t\\t\\tqueue = queue[1:]\\n\\t\\t}\\n\\t\\tfor i := 0; i < len(edges[v]); i++ {\\n\\t\\t\\tif discovered[i] == 0 && edges[v][i] > 0 {\\n\\t\\t\\t\\tif i == end {\\n\\t\\t\\t\\t\\treturn true, discovered[v]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdiscovered[i] = discovered[v] + 1\\n\\t\\t\\t\\tqueue = append(queue, i)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false, 0\\n}\\n\"",
    "breadth first search test": "\"package graph\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestBreadthFirstSearch(t *testing.T) {\\n\\tvar bfsTestData = []struct {\\n\\t\\tdescription string\\n\\t\\tstart       int\\n\\t\\tend         int\\n\\t\\tnodes       int\\n\\t\\tedges       [][]int\\n\\t\\texpected1   bool\\n\\t\\texpected2   int\\n\\t}{\\n\\t\\t{\\n\\t\\t\\t\\\"test 1 connected with distance 2\\\",\\n\\t\\t\\t0,\\n\\t\\t\\t5,\\n\\t\\t\\t6,\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 1, 1, 0, 0, 0},\\n\\t\\t\\t\\t{1, 0, 0, 1, 0, 1},\\n\\t\\t\\t\\t{1, 0, 0, 1, 0, 0},\\n\\t\\t\\t\\t{0, 1, 1, 0, 1, 0},\\n\\t\\t\\t\\t{0, 0, 0, 1, 0, 0},\\n\\t\\t\\t\\t{0, 1, 0, 0, 0, 0},\\n\\t\\t\\t},\\n\\t\\t\\ttrue,\\n\\t\\t\\t2,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"test 2 connected with distance 4\\\",\\n\\t\\t\\t0,\\n\\t\\t\\t5,\\n\\t\\t\\t6,\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 1, 1, 0, 0, 0},\\n\\t\\t\\t\\t{1, 0, 0, 1, 0, 0},\\n\\t\\t\\t\\t{1, 0, 0, 1, 0, 0},\\n\\t\\t\\t\\t{0, 1, 1, 0, 1, 0},\\n\\t\\t\\t\\t{0, 0, 0, 1, 0, 1},\\n\\t\\t\\t\\t{0, 0, 0, 0, 1, 0},\\n\\t\\t\\t},\\n\\t\\t\\ttrue,\\n\\t\\t\\t4,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"test 2 not connected\\\",\\n\\t\\t\\t0,\\n\\t\\t\\t5,\\n\\t\\t\\t6,\\n\\t\\t\\t[][]int{\\n\\t\\t\\t\\t{0, 1, 1, 0, 0, 0},\\n\\t\\t\\t\\t{1, 0, 0, 1, 0, 0},\\n\\t\\t\\t\\t{1, 0, 0, 1, 0, 0},\\n\\t\\t\\t\\t{0, 1, 1, 0, 1, 0},\\n\\t\\t\\t\\t{0, 0, 0, 1, 0, 0},\\n\\t\\t\\t\\t{0, 0, 0, 0, 0, 0},\\n\\t\\t\\t},\\n\\t\\t\\tfalse,\\n\\t\\t\\t0,\\n\\t\\t},\\n\\t}\\n\\tfor _, test := range bfsTestData {\\n\\t\\tt.Run(test.description, func(t *testing.T) {\\n\\t\\t\\tr1, r2 := BreadthFirstSearch(test.start, test.end,\\n\\t\\t\\t\\ttest.nodes, test.edges)\\n\\t\\t\\tif r1 != test.expected1 || r2 != test.expected2 {\\n\\t\\t\\t\\tt.Logf(\\\"FAIL: %s\\\", test.description)\\n\\t\\t\\t\\tt.Fatalf(\\\"Nodes '%v' and Edges '%v' start from '%d' and end in '%d' \\\"+\\n\\t\\t\\t\\t\\t\\\"was expecting '%v' with distance '%d' but result was '%v','%d'\\\",\\n\\t\\t\\t\\t\\ttest.nodes, test.edges, test.start, test.end, test.expected1, test.expected2, r1, r2)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "depth first search": "\"package graph\\n\\nfunc GetIdx(target int, nodes []int) int {\\n\\tfor i := 0; i < len(nodes); i++ {\\n\\t\\tif nodes[i] == target {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc NotExist(target int, slice []int) bool {\\n\\tfor i := 0; i < len(slice); i++ {\\n\\t\\tif slice[i] == target {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc DepthFirstSearchHelper(start, end int, nodes []int, edges [][]bool, showroute bool) ([]int, bool) {\\n\\tvar route []int\\n\\tvar stack []int\\n\\tstartIdx := GetIdx(start, nodes)\\n\\tstack = append(stack, startIdx)\\n\\tfor len(stack) > 0 {\\n\\t\\tnow := stack[len(stack)-1]\\n\\t\\troute = append(route, nodes[now])\\n\\t\\tif len(stack) > 1 {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t}\\n\\t\\tfor i := 0; i < len(edges[now]); i++ {\\n\\t\\t\\tif edges[now][i] && NotExist(i, stack) {\\n\\t\\t\\t\\tstack = append(stack, i)\\n\\t\\t\\t}\\n\\t\\t\\tedges[now][i] = false\\n\\t\\t\\tedges[i][now] = false\\n\\t\\t}\\n\\t\\tif route[len(route)-1] == end {\\n\\t\\t\\treturn route, true\\n\\t\\t}\\n\\t}\\n\\n\\tif showroute {\\n\\t\\treturn route, false\\n\\t} else {\\n\\t\\treturn nil, false\\n\\t}\\n}\\n\\nfunc DepthFirstSearch(start, end int, nodes []int, edges [][]bool) ([]int, bool) {\\n\\treturn DepthFirstSearchHelper(start, end, nodes, edges, false)\\n}\\n\\n// func main() {\\n// \\tnodes := []int{\\n// \\t\\t1, 2, 3, 4, 5, 6,\\n// \\t}\\n// \\t/*\\n// \\t\\tsample graph\\n// \\t\\t①-②\\n// \\t\\t|  |\\n// \\t\\t③-④-⑤-⑥\\n// \\t*/\\n// \\tedges := [][]bool{\\n// \\t\\t{false, true, true, false, false, false},\\n// \\t\\t{true, false, false, true, false, false},\\n// \\t\\t{true, false, false, true, false, false},\\n// \\t\\t{false, true, true, false, true, false},\\n// \\t\\t{false, false, false, true, false, true},\\n// \\t\\t{false, false, false, false, true, false},\\n// \\t}\\n// \\tstart := 1\\n// \\tend := 6\\n// \\troute, _ := dfs(start, end, nodes, edges)\\n// \\tfmt.Println(route)\\n// }\\n\"",
    "depth first search test": "\"package graph\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestDfsWhenPathIsFound(t *testing.T) {\\n\\tnodes := []int{\\n\\t\\t1, 2, 3, 4, 5, 6,\\n\\t}\\n\\n\\t//Adjacency Matrix for connected nodes\\n\\tedges := [][]bool{\\n\\t\\t{false, true, true, false, false, false},\\n\\t\\t{true, false, false, true, false, false},\\n\\t\\t{true, false, false, true, false, false},\\n\\t\\t{false, true, true, false, true, false},\\n\\t\\t{false, false, false, true, false, true},\\n\\t\\t{false, false, false, false, true, false},\\n\\t}\\n\\n\\tstart := 1\\n\\tend := 6\\n\\n\\tactual, actualIsFound := DepthFirstSearch(start, end, nodes, edges)\\n\\texpected := []int{1, 3, 4, 5, 6}\\n\\texpectedIsFound := true\\n\\tt.Run(\\\"Test Dfs\\\", func(t *testing.T) {\\n\\t\\tif !reflect.DeepEqual(expected, actual) || !reflect.DeepEqual(actualIsFound, expectedIsFound) {\\n\\t\\t\\tt.Errorf(\\\"got route: %v, want route: %v\\\", actual, expected)\\n\\t\\t\\tt.Errorf(\\\"got isFound: %v, want isFound: %v\\\", actualIsFound, expectedIsFound)\\n\\t\\t}\\n\\t})\\n}\\n\\nfunc TestDfsWhenPathIsNotFound(t *testing.T) {\\n\\tnodes := []int{\\n\\t\\t1, 2, 3, 4, 5, 6,\\n\\t}\\n\\n\\t//Adjacency Matrix for connected nodes\\n\\tedges := [][]bool{\\n\\t\\t{false, true, true, false, false, false},\\n\\t\\t{true, false, false, true, false, false},\\n\\t\\t{true, false, false, true, false, false},\\n\\t\\t{false, true, true, false, true, false},\\n\\t\\t{false, false, false, true, false, true},\\n\\t\\t{false, false, false, false, true, false},\\n\\t}\\n\\n\\tstart := 1\\n\\tend := 7\\n\\n\\tactual, actualIsFound := DepthFirstSearch(start, end, nodes, edges)\\n\\tvar expected []int\\n\\texpectedIsFound := false\\n\\tt.Run(\\\"Test Dfs\\\", func(t *testing.T) {\\n\\t\\tif !reflect.DeepEqual(expected, actual) || !reflect.DeepEqual(actualIsFound, expectedIsFound) {\\n\\t\\t\\tt.Errorf(\\\"got route: %v, want route: %v\\\", actual, expected)\\n\\t\\t\\tt.Errorf(\\\"got isFound: %v, want isFound: %v\\\", actualIsFound, expectedIsFound)\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "dijkstra": "\"package graph\\n\\nimport \\\"github.com/TheAlgorithms/Go/sort\\\"\\n\\ntype Item struct {\\n\\tnode int\\n\\tdist int\\n}\\n\\nfunc (a Item) More(b interface{}) bool {\\n\\t// reverse direction for minheap\\n\\treturn a.dist < b.(Item).dist\\n}\\nfunc (a Item) Idx() int {\\n\\treturn a.node\\n}\\n\\nfunc (g *Graph) Dijkstra(start, end int) (int, bool) {\\n\\tvisited := make(map[int]bool)\\n\\tnodes := make(map[int]*Item)\\n\\n\\tnodes[start] = &Item{\\n\\t\\tdist: 0,\\n\\t\\tnode: start,\\n\\t}\\n\\tpq := sort.MaxHeap{}\\n\\tpq.Init(nil)\\n\\tpq.Push(*nodes[start])\\n\\n\\tvisit := func(curr Item) {\\n\\t\\tvisited[curr.node] = true\\n\\t\\tfor n, d := range g.edges[curr.node] {\\n\\t\\t\\tif visited[n] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\titem := nodes[n]\\n\\t\\t\\tdist2 := curr.dist + d\\n\\t\\t\\tif item == nil {\\n\\t\\t\\t\\tnodes[n] = &Item{node: n, dist: dist2}\\n\\t\\t\\t\\tpq.Push(*nodes[n])\\n\\t\\t\\t} else if item.dist > dist2 {\\n\\t\\t\\t\\titem.dist = dist2\\n\\t\\t\\t\\tpq.Update(*item)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor pq.Size() > 0 {\\n\\t\\tcurr := pq.Pop().(Item)\\n\\t\\tif curr.node == end {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tvisit(curr)\\n\\t}\\n\\n\\titem := nodes[end]\\n\\tif item == nil {\\n\\t\\treturn -1, false\\n\\t}\\n\\treturn item.dist, true\\n}\\n\"",
    "dijkstra test": "\"package graph\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nvar tc_dijkstra = []struct {\\n\\tname     string\\n\\tedges    [][]int\\n\\tnode0    int\\n\\tnode1    int\\n\\texpected int\\n}{\\n\\t{\\n\\t\\t\\\"straight line graph\\\",\\n\\t\\t[][]int{{0, 1, 5}, {1, 2, 2}},\\n\\t\\t0, 2, 7,\\n\\t},\\n\\t{\\n\\t\\t\\\"unconnected node\\\",\\n\\t\\t[][]int{{0, 1, 5}},\\n\\t\\t0, 2, -1,\\n\\t},\\n\\t{\\n\\t\\t\\\"double paths\\\",\\n\\t\\t[][]int{{0, 1, 5}, {1, 3, 5}, {0, 2, 5}, {2, 3, 4}},\\n\\t\\t0, 3, 9,\\n\\t},\\n\\t{\\n\\t\\t\\\"double paths extended\\\",\\n\\t\\t[][]int{{0, 1, 5}, {1, 3, 5}, {0, 2, 5}, {2, 3, 4}, {3, 4, 1}},\\n\\t\\t0, 4, 10,\\n\\t},\\n}\\n\\nfunc TestDijkstra(t *testing.T) {\\n\\tfor _, tc := range tc_dijkstra {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tvar graph Graph\\n\\t\\t\\tfor _, edge := range tc.edges {\\n\\t\\t\\t\\tgraph.AddWeightedEdge(edge[0], edge[1], edge[2])\\n\\t\\t\\t}\\n\\n\\t\\t\\tactual, _ := graph.Dijkstra(tc.node0, tc.node1)\\n\\t\\t\\tif actual != tc.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"expected %d, got %d, from node %d to %d, with %v\\\",\\n\\t\\t\\t\\t\\ttc.expected, actual, tc.node0, tc.node1, tc.edges)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "floyd warshall": "\"// Floyd-Warshall algorithm\\n// https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\npackage graph\\n\\nimport \\\"math\\\"\\n\\n// WeightedGraph defining matrix to use 2d array easier\\ntype WeightedGraph [][]float64\\n\\n// Defining maximum value. If two vertices share this value, it means they are not connected\\nvar Inf = math.Inf(1)\\n\\n// FloydWarshall Returns all pair's shortest path using Floyd Warshall algorithm\\nfunc FloydWarshall(graph WeightedGraph) WeightedGraph {\\n\\t// If graph is empty, returns nil\\n\\tif len(graph) == 0 || len(graph) != len(graph[0]) {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tfor i := 0; i < len(graph); i++ {\\n\\t\\t//If graph matrix width is different than the height, returns nil\\n\\t\\tif len(graph[i]) != len(graph) {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t}\\n\\n\\tnumVertices := len(graph)\\n\\n\\t// Initializing result matrix and filling it up with same values as given graph\\n\\tresult := make(WeightedGraph, numVertices)\\n\\n\\tfor i := 0; i < numVertices; i++ {\\n\\t\\tresult[i] = make([]float64, numVertices)\\n\\t\\tfor j := 0; j < numVertices; j++ {\\n\\t\\t\\tresult[i][j] = graph[i][j]\\n\\t\\t}\\n\\t}\\n\\n\\t// Running over the result matrix and following the algorithm\\n\\tfor k := 0; k < numVertices; k++ {\\n\\t\\tfor i := 0; i < numVertices; i++ {\\n\\t\\t\\tfor j := 0; j < numVertices; j++ {\\n\\t\\t\\t\\t// If there is a less costly path from i to j node, remembering it\\n\\t\\t\\t\\tif result[i][j] > result[i][k]+result[k][j] {\\n\\t\\t\\t\\t\\tresult[i][j] = result[i][k] + result[k][j]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\"",
    "floyd warshall test": "\"package graph\\n\\nimport (\\n\\t\\\"math\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nconst float64EqualityThreshold = 1e-9\\n\\n//almostEqual subtracts two float64 variables and returns true if they differ less then float64EqualityThreshold\\n//reference: https://stackoverflow.com/a/47969546\\nfunc almostEqual(a, b float64) bool {\\n\\treturn math.Abs(a-b) <= float64EqualityThreshold\\n}\\n\\n//IsAlmostEqualTo verifies if two WeightedGraphs can be considered almost equal\\nfunc (a *WeightedGraph) IsAlmostEqualTo(b WeightedGraph) bool {\\n\\tif len(*a) != len(b) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tfor i := range *a {\\n\\t\\tif len((*a)[i]) != len(b[i]) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tfor j := range (*a)[i] {\\n\\t\\t\\tif (*a)[i][j] == Inf && b[i][j] == Inf {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tif !almostEqual((*a)[i][j], b[i][j]) {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\nfunc TestFloydWarshall(t *testing.T) {\\n\\tvar floydWarshallTestData = []struct {\\n\\t\\tdescription string\\n\\t\\tgraph       [][]float64\\n\\t\\texpected    [][]float64\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tdescription: \\\"test empty graph\\\",\\n\\t\\t\\tgraph:       nil,\\n\\t\\t\\texpected:    nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription: \\\"test graph with wrong dimensions\\\",\\n\\t\\t\\tgraph: [][]float64{\\n\\t\\t\\t\\t{1, 2},\\n\\t\\t\\t\\t{Inf},\\n\\t\\t\\t},\\n\\t\\t\\texpected: nil,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription: \\\"test graph with no edges\\\",\\n\\t\\t\\tgraph: [][]float64{\\n\\t\\t\\t\\t{Inf, Inf},\\n\\t\\t\\t\\t{Inf, Inf},\\n\\t\\t\\t},\\n\\t\\t\\texpected: [][]float64{\\n\\t\\t\\t\\t{Inf, Inf},\\n\\t\\t\\t\\t{Inf, Inf},\\n\\t\\t\\t},\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription: \\\"test graph with only negative edges\\\",\\n\\t\\t\\tgraph: [][]float64{\\n\\t\\t\\t\\t{-3, -2},\\n\\t\\t\\t\\t{-3, -2},\\n\\t\\t\\t},\\n\\t\\t\\texpected: [][]float64{\\n\\t\\t\\t\\t{-17, -25},\\n\\t\\t\\t\\t{-26, -34},\\n\\t\\t\\t},\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription: \\\"test graph with 5 vertices and self-loops\\\",\\n\\t\\t\\tgraph: [][]float64{\\n\\t\\t\\t\\t{1, 2, Inf, Inf, Inf},\\n\\t\\t\\t\\t{Inf, Inf, 3, -4, Inf},\\n\\t\\t\\t\\t{Inf, Inf, Inf, Inf, 5},\\n\\t\\t\\t\\t{1, Inf, Inf, Inf, Inf},\\n\\t\\t\\t\\t{Inf, Inf, Inf, 2, Inf},\\n\\t\\t\\t},\\n\\t\\t\\texpected: [][]float64{\\n\\t\\t\\t\\t{-1, 1, 4, -3, 8},\\n\\t\\t\\t\\t{-3, -1, 2, -5, 6},\\n\\t\\t\\t\\t{7, 9, 12, 5, 5},\\n\\t\\t\\t\\t{0, 2, 5, -2, 9},\\n\\t\\t\\t\\t{2, 4, 7, 0, 9},\\n\\t\\t\\t},\\n\\t\\t},\\n\\t}\\n\\tfor _, test := range floydWarshallTestData {\\n\\t\\tt.Run(test.description, func(t *testing.T) {\\n\\t\\t\\tresult := FloydWarshall(test.graph)\\n\\n\\t\\t\\tif !result.IsAlmostEqualTo(test.expected) {\\n\\t\\t\\t\\tt.Logf(\\\"FAIL: %s\\\", test.description)\\n\\t\\t\\t\\tt.Fatalf(\\\"Expected result:%f\\\\nFound: %f\\\", test.expected, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "graph test": "\"// Tests for directed and undirected graphs\\n\\npackage graph\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nvar graphTestCases = []struct {\\n\\tname     string\\n\\tedges    [][]int\\n\\tvertices int\\n}{\\n\\t{\\n\\t\\t\\\"single edge\\\",\\n\\t\\t[][]int{\\n\\t\\t\\t{0, 1, 1},\\n\\t\\t},\\n\\t\\t2,\\n\\t},\\n\\t{\\n\\t\\t\\\"many edges\\\",\\n\\t\\t[][]int{\\n\\t\\t\\t{0, 1, 1},\\n\\t\\t\\t{0, 2, 2},\\n\\t\\t\\t{1, 3, 4},\\n\\t\\t\\t{3, 4, 3},\\n\\t\\t\\t{4, 8, 3},\\n\\t\\t\\t{4, 9, 1},\\n\\t\\t\\t{7, 8, 2},\\n\\t\\t\\t{8, 9, 2},\\n\\t\\t},\\n\\t\\t10,\\n\\t},\\n\\t{\\n\\t\\t\\\"cycles\\\",\\n\\t\\t[][]int{\\n\\t\\t\\t{0, 1, 1},\\n\\t\\t\\t{0, 2, 2},\\n\\t\\t\\t{1, 3, 4},\\n\\t\\t\\t{3, 4, 3},\\n\\t\\t\\t{4, 2, 1},\\n\\t\\t},\\n\\t\\t5,\\n\\t},\\n\\t{\\n\\t\\t\\\"disconnected graphs\\\",\\n\\t\\t[][]int{\\n\\t\\t\\t{0, 1, 5},\\n\\t\\t\\t{2, 4, 5},\\n\\t\\t\\t{3, 8, 5},\\n\\t\\t},\\n\\t\\t2,\\n\\t},\\n}\\n\\nfunc TestDirectedGraph(t *testing.T) {\\n\\n\\t// Testing self-loops separately only for directed graphs.\\n\\t// For undirected graphs each edge already creates a self-loop.\\n\\tdirectedGraphTestCases := append(graphTestCases, struct {\\n\\t\\tname     string\\n\\t\\tedges    [][]int\\n\\t\\tvertices int\\n\\t}{\\n\\t\\t\\\"self-loops\\\",\\n\\t\\t[][]int{\\n\\t\\t\\t{0, 1, 1},\\n\\t\\t\\t{1, 2, 2},\\n\\t\\t\\t{2, 1, 3},\\n\\t\\t},\\n\\t\\t3,\\n\\t})\\n\\n\\tfor _, test := range directedGraphTestCases {\\n\\t\\tt.Run(fmt.Sprint(test.name), func(t *testing.T) {\\n\\t\\t\\t// Initializing graph, adding edges\\n\\t\\t\\tgraph := New(test.vertices)\\n\\t\\t\\tgraph.Directed = true\\n\\t\\t\\tfor _, edge := range test.edges {\\n\\t\\t\\t\\tgraph.AddWeightedEdge(edge[0], edge[1], edge[2])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif graph.vertices != test.vertices {\\n\\t\\t\\t\\tt.Errorf(\\\"Number of vertices, Expected: %d, Computed: %d\\\", test.vertices, graph.vertices)\\n\\t\\t\\t}\\n\\t\\t\\tedgeCount := 0\\n\\t\\t\\tfor _, e := range graph.edges {\\n\\t\\t\\t\\tedgeCount += len(e)\\n\\t\\t\\t}\\n\\t\\t\\tif edgeCount != len(test.edges) {\\n\\t\\t\\t\\tt.Errorf(\\\"Number of edges, Expected: %d, Computed: %d\\\", len(test.edges), edgeCount)\\n\\t\\t\\t}\\n\\t\\t\\tfor _, edge := range test.edges {\\n\\t\\t\\t\\tif val, found := graph.edges[edge[0]][edge[1]]; !found || val != edge[2] {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"Edge {%d->%d (%d)} not found\\\", edge[0], edge[1], edge[2])\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestUndirectedGraph(t *testing.T) {\\n\\n\\tfor _, test := range graphTestCases {\\n\\t\\tt.Run(fmt.Sprint(test.name), func(t *testing.T) {\\n\\t\\t\\t// Initializing graph, adding edges\\n\\t\\t\\tgraph := New(test.vertices)\\n\\t\\t\\tfor _, edge := range test.edges {\\n\\t\\t\\t\\tgraph.AddWeightedEdge(edge[0], edge[1], edge[2])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif graph.vertices != test.vertices {\\n\\t\\t\\t\\tt.Errorf(\\\"Number of vertices, Expected: %d, Computed: %d\\\", test.vertices, graph.vertices)\\n\\t\\t\\t}\\n\\t\\t\\tedgeCount := 0\\n\\t\\t\\tfor _, e := range graph.edges {\\n\\t\\t\\t\\tedgeCount += len(e)\\n\\t\\t\\t}\\n\\t\\t\\tif edgeCount != len(test.edges)*2 {\\n\\t\\t\\t\\tt.Errorf(\\\"Number of edges, Expected: %d, Computed: %d\\\", len(test.edges)*2, edgeCount)\\n\\t\\t\\t}\\n\\t\\t\\tfor _, edge := range test.edges {\\n\\t\\t\\t\\tif val, found := graph.edges[edge[0]][edge[1]]; !found || val != edge[2] {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"Edge {%d->%d (%d)} not found\\\", edge[0], edge[1], edge[2])\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "kruskal": "\"// KRUSKAL'S ALGORITHM\\n// https://cp-algorithms.com/data_structures/disjoint_set_union.html\\n// https://cp-algorithms.com/graph/mst_kruskal_with_dsu.html\\n\\npackage graph\\n\\nimport (\\n\\t\\\"sort\\\"\\n)\\n\\ntype Vertex int\\n\\n// Edge describes the edge of a weighted graph\\ntype Edge struct {\\n\\tStart  Vertex\\n\\tEnd    Vertex\\n\\tWeight int\\n}\\n\\n// DisjointSetUnionElement describes what an element of DSU looks like\\ntype DisjointSetUnionElement struct {\\n\\tParent Vertex\\n\\tRank   int\\n}\\n\\n// DisjointSetUnion is a data structure that treats its elements as separate sets\\n// and provides fast operations for set creation, merging sets, and finding the parent\\n// of the given element of a set.\\ntype DisjointSetUnion []DisjointSetUnionElement\\n\\n// NewDSU will return an initialised DSU using the value of n\\n// which will be treated as the number of elements out of which\\n// the DSU is being made\\nfunc NewDSU(n int) *DisjointSetUnion {\\n\\n\\tdsu := DisjointSetUnion(make([]DisjointSetUnionElement, n))\\n\\treturn &dsu\\n}\\n\\n// MakeSet will create a set in the DSU for the given node\\nfunc (dsu DisjointSetUnion) MakeSet(node Vertex) {\\n\\n\\tdsu[node].Parent = node\\n\\tdsu[node].Rank = 0\\n}\\n\\n// FindSetRepresentative will return the parent element of the set the given node\\n// belongs to. Since every single element in the path from node to parent\\n// has the same parent, we store the parent value for each element in the\\n// path. This reduces consequent function calls and helps in going from O(n)\\n// to O(log n). This is known as path compression technique.\\nfunc (dsu DisjointSetUnion) FindSetRepresentative(node Vertex) Vertex {\\n\\n\\tif node == dsu[node].Parent {\\n\\t\\treturn node\\n\\t}\\n\\n\\tdsu[node].Parent = dsu.FindSetRepresentative(dsu[node].Parent)\\n\\treturn dsu[node].Parent\\n}\\n\\n// unionSets will merge two given sets. The naive implementation of this\\n// always combines the secondNode's tree with the firstNode's tree. This can lead\\n// to creation of trees of length O(n) so we optimize by attaching the node with\\n// smaller rank to the node with bigger rank. Rank represents the upper bound depth of the tree.\\nfunc (dsu DisjointSetUnion) UnionSets(firstNode Vertex, secondNode Vertex) {\\n\\n\\tfirstNode = dsu.FindSetRepresentative(firstNode)\\n\\tsecondNode = dsu.FindSetRepresentative(secondNode)\\n\\n\\tif firstNode != secondNode {\\n\\n\\t\\tif dsu[firstNode].Rank < dsu[secondNode].Rank {\\n\\t\\t\\tfirstNode, secondNode = secondNode, firstNode\\n\\t\\t}\\n\\t\\tdsu[secondNode].Parent = firstNode\\n\\n\\t\\tif dsu[firstNode].Rank == dsu[secondNode].Rank {\\n\\t\\t\\tdsu[firstNode].Rank++\\n\\t\\t}\\n\\t}\\n}\\n\\n// KruskalMST will return a minimum spanning tree along with its total cost\\n// to using Kruskal's algorithm. Time complexity is O(m * log (n)) where m is\\n// the number of edges in the graph and n is number of nodes in it.\\nfunc KruskalMST(n int, edges []Edge) ([]Edge, int) {\\n\\n\\tvar mst []Edge // The resultant minimum spanning tree\\n\\tvar cost int = 0\\n\\n\\tdsu := NewDSU(n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tdsu.MakeSet(Vertex(i))\\n\\t}\\n\\n\\tsort.SliceStable(edges, func(i, j int) bool {\\n\\t\\treturn edges[i].Weight < edges[j].Weight\\n\\t})\\n\\n\\tfor _, edge := range edges {\\n\\n\\t\\tif dsu.FindSetRepresentative(edge.Start) != dsu.FindSetRepresentative(edge.End) {\\n\\n\\t\\t\\tmst = append(mst, edge)\\n\\t\\t\\tcost += edge.Weight\\n\\t\\t\\tdsu.UnionSets(edge.Start, edge.End)\\n\\t\\t}\\n\\t}\\n\\n\\treturn mst, cost\\n}\\n\"",
    "kruskal test": "\"package graph\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc Test_KruskalMST(t *testing.T) {\\n\\n\\tvar testCases = []struct {\\n\\t\\tn     int\\n\\t\\tgraph []Edge\\n\\t\\tcost  int\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tn: 5,\\n\\t\\t\\tgraph: []Edge{\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    1,\\n\\t\\t\\t\\t\\tWeight: 4,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    2,\\n\\t\\t\\t\\t\\tWeight: 13,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    3,\\n\\t\\t\\t\\t\\tWeight: 7,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    4,\\n\\t\\t\\t\\t\\tWeight: 7,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  1,\\n\\t\\t\\t\\t\\tEnd:    2,\\n\\t\\t\\t\\t\\tWeight: 9,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  1,\\n\\t\\t\\t\\t\\tEnd:    3,\\n\\t\\t\\t\\t\\tWeight: 3,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  1,\\n\\t\\t\\t\\t\\tEnd:    4,\\n\\t\\t\\t\\t\\tWeight: 7,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  2,\\n\\t\\t\\t\\t\\tEnd:    3,\\n\\t\\t\\t\\t\\tWeight: 10,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  2,\\n\\t\\t\\t\\t\\tEnd:    4,\\n\\t\\t\\t\\t\\tWeight: 14,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  3,\\n\\t\\t\\t\\t\\tEnd:    4,\\n\\t\\t\\t\\t\\tWeight: 4,\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t\\tcost: 20,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tn: 3,\\n\\t\\t\\tgraph: []Edge{\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    1,\\n\\t\\t\\t\\t\\tWeight: 12,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    2,\\n\\t\\t\\t\\t\\tWeight: 18,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  1,\\n\\t\\t\\t\\t\\tEnd:    2,\\n\\t\\t\\t\\t\\tWeight: 6,\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t\\tcost: 18,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tn: 4,\\n\\t\\t\\tgraph: []Edge{\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    1,\\n\\t\\t\\t\\t\\tWeight: 2,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    2,\\n\\t\\t\\t\\t\\tWeight: 1,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    3,\\n\\t\\t\\t\\t\\tWeight: 2,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  1,\\n\\t\\t\\t\\t\\tEnd:    2,\\n\\t\\t\\t\\t\\tWeight: 1,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  1,\\n\\t\\t\\t\\t\\tEnd:    3,\\n\\t\\t\\t\\t\\tWeight: 2,\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  2,\\n\\t\\t\\t\\t\\tEnd:    3,\\n\\t\\t\\t\\t\\tWeight: 3,\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t\\tcost: 4,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tn: 2,\\n\\t\\t\\tgraph: []Edge{\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    1,\\n\\t\\t\\t\\t\\tWeight: 4000000,\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t\\tcost: 4000000,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tn: 1,\\n\\t\\t\\tgraph: []Edge{\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tStart:  0,\\n\\t\\t\\t\\t\\tEnd:    0,\\n\\t\\t\\t\\t\\tWeight: 0,\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t\\tcost: 0,\\n\\t\\t},\\n\\t}\\n\\n\\tfor i := range testCases {\\n\\n\\t\\tt.Run(fmt.Sprintf(\\\"Test Case %d\\\", i), func(t *testing.T) {\\n\\n\\t\\t\\t_, computed := KruskalMST(testCases[i].n, testCases[i].graph)\\n\\t\\t\\tif computed != testCases[i].cost {\\n\\t\\t\\t\\tt.Errorf(\\\"Test Case %d, Expected: %d, Computed: %d\\\", i, testCases[i].cost, computed)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "topological": "\"package graph\\n\\n// Assumes that graph given is valid and possible to\\n// get a topo ordering.\\n// constraints are array of []int{a, b}, representing\\n// an edge going from a to b\\nfunc Topological(N int, constraints [][]int) []int {\\n\\tdependencies := make([]int, N)\\n\\tnodes := make([]int, N)\\n\\tfor i := range nodes {\\n\\t\\tnodes[i] = i\\n\\t}\\n\\tedges := make([][]bool, N)\\n\\tfor i := range edges {\\n\\t\\tedges[i] = make([]bool, N)\\n\\t}\\n\\n\\tfor _, c := range constraints {\\n\\t\\ta := c[0]\\n\\t\\tb := c[1]\\n\\t\\tdependencies[b]++\\n\\t\\tedges[a][b] = true\\n\\t}\\n\\n\\tanswer := []int{}\\n\\tfor s := 0; s < N; s++ {\\n\\t\\t// Only start walking from top level nodes\\n\\t\\tif dependencies[s] == 0 {\\n\\t\\t\\troute, _ := DepthFirstSearchHelper(s, N, nodes, edges, true)\\n\\t\\t\\tanswer = append(answer, route...)\\n\\t\\t}\\n\\t}\\n\\n\\treturn answer\\n}\\n\"",
    "topological test": "\"package graph\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nvar testCases = []struct {\\n\\tname        string\\n\\tN           int\\n\\tconstraints [][]int\\n}{\\n\\t{\\n\\t\\t\\\"basic test\\\", 2,\\n\\t\\t[][]int{{1, 0}},\\n\\t},\\n\\t{\\n\\t\\t\\\"double path\\\", 7,\\n\\t\\t[][]int{\\n\\t\\t\\t{0, 1}, {1, 3}, {3, 5},\\n\\t\\t\\t{0, 2}, {2, 4}, {4, 6}},\\n\\t},\\n\\t{\\n\\t\\t\\\"star shape\\\", 7,\\n\\t\\t[][]int{\\n\\t\\t\\t{0, 1}, {0, 3}, {0, 5},\\n\\t\\t\\t{0, 2}, {0, 4}, {0, 6}},\\n\\t},\\n\\t{\\n\\t\\t\\\"tree shape\\\", 7,\\n\\t\\t[][]int{\\n\\t\\t\\t{0, 1}, {1, 3}, {1, 5},\\n\\t\\t\\t{0, 2}, {2, 4}, {2, 6}},\\n\\t},\\n}\\n\\nfunc TestTopological(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := Topological(tc.N, tc.constraints)\\n\\n\\t\\t\\tvisited := make([]bool, tc.N)\\n\\t\\t\\tpositions := make([]int, tc.N)\\n\\t\\t\\tfor i := 0; i < tc.N; i++ {\\n\\t\\t\\t\\tpositions[actual[i]] = i\\n\\t\\t\\t\\tvisited[actual[i]] = true\\n\\t\\t\\t}\\n\\t\\t\\tfor _, v := range visited {\\n\\t\\t\\t\\tif !v {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"nodes not all visited, %v\\\", visited)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor _, c := range tc.constraints {\\n\\t\\t\\t\\tif positions[c[0]] > positions[c[1]] {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"%v dun satisfy %v\\\", actual, c)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "hashing test": "\"// Empty test file to keep track of all the tests for the algorithms.\\n\\npackage hashing\\n\"",
    "checkisnumberpoweroftwo test": "\"// checkisnumberpoweroftwo_test.go\\n// description: Test for Is the number a power of two\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see checkisnumberpoweroftwo.go\\n\\npackage math\\n\\nimport (\\n\\t\\\"math\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc getTestsForPowerOfTwo() []struct {\\n\\tname    string\\n\\ta       int\\n\\tmissing bool\\n} {\\n\\tvar tests = []struct {\\n\\t\\tname    string\\n\\t\\ta       int\\n\\t\\tmissing bool\\n\\t}{\\n\\t\\t{\\\"Is 64 a power of 2? - YES\\\", 64, true},\\n\\t\\t{\\\"Is 1 a power of 2? - YES\\\", 1, true},\\n\\t\\t{\\\"Is 2 a power of 2? - YES\\\", 2, true},\\n\\t\\t{\\\"Is 5 a power of 2? - NO\\\", 5, false},\\n\\t\\t{\\\"Is 1023 a power of 2? - NO\\\", 1023, false},\\n\\t\\t{\\\"Is 1024 a power of 2? - YES\\\", 1024, true},\\n\\t\\t{\\\"Is 0 a power of 2? - NO\\\", 0, false},\\n\\t\\t{\\\"Is 9223372036854775807 a power of 2? - NO\\\", math.MaxInt64, false},\\n\\t\\t{\\\"Is 9223372036854775806 a power of 2? - NO\\\", math.MaxInt64, false},\\n\\t\\t{\\\"Is 4611686018427387904 a power of 2? - YES\\\", 4611686018427387904, true},\\n\\t}\\n\\treturn tests\\n}\\n\\nfunc TestIsPowOfTwoUseLog(t *testing.T) {\\n\\ttests := getTestsForPowerOfTwo()\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := IsPowOfTwoUseLog(float64(tv.a))\\n\\t\\t\\tt.Log(tv.a, \\\" \\\", result)\\n\\t\\t\\tif result != tv.missing {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%v, returned:%v \\\", tv.missing, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkIsPowerOfTwoUseLog(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tIsPowOfTwoUseLog(1024)\\n\\t}\\n}\\n\"",
    "eulertotient": "\"package math\\n\\n// Phi is the Euler totient function.\\n// This function computes the number of numbers less then n that are coprime with n.\\nfunc Phi(n int64) int64 {\\n\\tresult := n\\n\\tfor i := int64(2); i*i <= n; i += 1 {\\n\\t\\tif n%i == 0 {\\n\\t\\t\\tfor {\\n\\t\\t\\t\\tif n%i != 0 {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn /= i\\n\\t\\t\\t}\\n\\t\\t\\tresult -= result / i\\n\\t\\t}\\n\\t}\\n\\n\\tif n > 1 {\\n\\t\\tresult -= result / n\\n\\t}\\n\\treturn result\\n}\\n\"",
    "eulertotient test": "\"package math\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc getTestsForPhi() []struct {\\n\\tn        int64\\n\\texpected int64\\n} {\\n\\tvar tests = []struct {\\n\\t\\tn        int64\\n\\t\\texpected int64\\n\\t}{\\n\\t\\t{4, 2},\\n\\t\\t{5, 4},\\n\\t\\t{7, 6},\\n\\t\\t{10, 4},\\n\\t\\t{999, 648},\\n\\t\\t{1000, 400},\\n\\t\\t{1000000, 400000},\\n\\t\\t{999999, 466560},\\n\\t\\t{999999999999878, 473684210526240},\\n\\t}\\n\\treturn tests\\n}\\n\\nfunc TestPhi(t *testing.T) {\\n\\n\\ttests := getTestsForPhi()\\n\\tfor _, test := range tests {\\n\\t\\tresult := Phi(test.n)\\n\\t\\tt.Log(test.n, \\\" \\\", result)\\n\\t\\tif result != test.expected {\\n\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%v, returned:%v \\\", test.expected, result)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkPhi(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tPhi(65536)\\n\\t}\\n}\\n\"",
    "math test": "\"// Empty test file to keep track of all the tests for the algorithms.\\n\\npackage math\\n\"",
    "other test": "\"// Empty test file to keep track of all the tests for the algorithms.\\n\\npackage other\\n\"",
    "binary": "\"package search\\n\\n// Binary search for target within a sorted array by repeatedly dividing the array in half and comparing the midpoint with the target.\\n// This function uses recursive call to itself.\\n// If a target is found, the index of the target is returned. Else the function return -1 and ErrNotFound.\\nfunc Binary(array []int, target int, lowIndex int, highIndex int) (int, error) {\\n\\tif highIndex < lowIndex || len(array) == 0 {\\n\\t\\treturn -1, ErrNotFound\\n\\t}\\n\\tmid := int(lowIndex + (highIndex-lowIndex)/2)\\n\\tif array[mid] > target {\\n\\t\\treturn Binary(array, target, lowIndex, mid-1)\\n\\t} else if array[mid] < target {\\n\\t\\treturn Binary(array, target, mid+1, highIndex)\\n\\t} else {\\n\\t\\treturn mid, nil\\n\\t}\\n}\\n\\n// BinaryIterative search for target within a sorted array by repeatedly dividing the array in half and comparing the midpoint with the target.\\n// Unlike Binary, this function uses iterative method and not recursive.\\n// If a target is found, the index of the target is returned. Else the function return -1 and ErrNotFound.\\nfunc BinaryIterative(array []int, target int, lowIndex int, highIndex int) (int, error) {\\n\\tstartIndex := lowIndex\\n\\tendIndex := highIndex\\n\\tvar mid int\\n\\tfor startIndex <= endIndex {\\n\\t\\tmid = int(startIndex + (endIndex-startIndex)/2)\\n\\t\\tif array[mid] > target {\\n\\t\\t\\tendIndex = mid - 1\\n\\t\\t} else if array[mid] < target {\\n\\t\\t\\tstartIndex = mid + 1\\n\\t\\t} else {\\n\\t\\t\\treturn mid, nil\\n\\t\\t}\\n\\t}\\n\\treturn -1, ErrNotFound\\n}\\n\"",
    "binary test": "\"package search\\n\\nimport \\\"testing\\\"\\n\\nfunc TestBinary(t *testing.T) {\\n\\tfor _, test := range searchTests {\\n\\t\\tactualValue, actualError := Binary(test.data, test.key, 0, len(test.data)-1)\\n\\t\\tif actualValue != test.expected {\\n\\t\\t\\tt.Errorf(\\\"test '%s' failed: input array '%v' with key '%d', expected '%d', get '%d'\\\", test.name, test.data, test.key, test.expected, actualValue)\\n\\t\\t}\\n\\t\\tif actualError != test.expectedError {\\n\\t\\t\\tt.Errorf(\\\"test '%s' failed: input array '%v' with key '%d', expected error '%s', get error '%s'\\\", test.name, test.data, test.key, test.expectedError, actualError)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc TestBinaryIterative(t *testing.T) {\\n\\tfor _, test := range searchTests {\\n\\t\\tactualValue, actualError := BinaryIterative(test.data, test.key, 0, len(test.data)-1)\\n\\t\\tif actualValue != test.expected {\\n\\t\\t\\tt.Errorf(\\\"test '%s' failed: input array '%v' with key '%d', expected '%d', get '%d'\\\", test.name, test.data, test.key, test.expected, actualValue)\\n\\t\\t}\\n\\t\\tif actualError != test.expectedError {\\n\\t\\t\\tt.Errorf(\\\"test '%s' failed: input array '%v' with key '%d', expected error '%s', get error '%s'\\\", test.name, test.data, test.key, test.expectedError, actualError)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkBinary(b *testing.B) {\\n\\ttestCase := generateBenchmarkTestCase()\\n\\tb.ResetTimer() // this is important because the generateBenchmarkTestCase() is expensive\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = Binary(testCase, i, 0, len(testCase)-1)\\n\\t}\\n}\\n\\nfunc BenchmarkBinaryIterative(b *testing.B) {\\n\\ttestCase := generateBenchmarkTestCase()\\n\\tb.ResetTimer() // this is important because the generateBenchmarkTestCase() is expensive\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = BinaryIterative(testCase, i, 0, len(testCase)-1)\\n\\t}\\n}\\n\"",
    "errors": "\"package search\\n\\nimport \\\"errors\\\"\\n\\n// ErrNotFound is returned by search functions when target is not found\\nvar ErrNotFound = errors.New(\\\"target not found in array\\\")\\n\"",
    "interpolation": "\"package search\\n\\n// Interpolation searches for the entity in the given sortedData.\\n// if the entity is present, it will return the index of the entity, if not -1 will be returned.\\n// see: https://en.wikipedia.org/wiki/Interpolation_search\\n// Complexity\\n// \\t\\tWorst: O(N)\\n// \\t\\tAverage: O(log(log(N))  if the elements are uniformly distributed\\n// \\t\\tBest: O(1)\\n// Example\\n// \\t\\tfmt.Println(InterpolationSearch([]int{1, 2, 9, 20, 31, 45, 63, 70, 100},100))\\nfunc Interpolation(sortedData []int, guess int) (int, error) {\\n\\tif len(sortedData) == 0 {\\n\\t\\treturn -1, ErrNotFound\\n\\t}\\n\\n\\tvar (\\n\\t\\tlow, high       = 0, len(sortedData) - 1\\n\\t\\tlowVal, highVal = sortedData[low], sortedData[high]\\n\\t)\\n\\n\\tfor lowVal != highVal && (lowVal <= guess) && (guess <= highVal) {\\n\\t\\tmid := low + int(float64(float64((guess-lowVal)*(high-low))/float64(highVal-lowVal)))\\n\\n\\t\\t// if guess is found, array can also have duplicate values, so scan backwards and find the first index\\n\\t\\tif sortedData[mid] == guess {\\n\\t\\t\\tfor mid > 0 && sortedData[mid-1] == guess {\\n\\t\\t\\t\\tmid--\\n\\t\\t\\t}\\n\\t\\t\\treturn mid, nil\\n\\n\\t\\t}\\n\\n\\t\\t// adjust our guess and continue\\n\\t\\tif sortedData[mid] > guess {\\n\\t\\t\\thigh, highVal = mid-1, sortedData[high]\\n\\n\\t\\t} else {\\n\\t\\t\\tlow, lowVal = mid+1, sortedData[low]\\n\\t\\t}\\n\\n\\t}\\n\\n\\tif guess == lowVal {\\n\\t\\treturn low, nil\\n\\t}\\n\\treturn -1, ErrNotFound\\n}\\n\"",
    "interpolation test": "\"package search\\n\\nimport \\\"testing\\\"\\n\\nfunc TestInterpolation(t *testing.T) {\\n\\tfor _, test := range searchTests {\\n\\t\\tactualValue, actualError := Interpolation(test.data, test.key)\\n\\t\\tif actualValue != test.expected {\\n\\t\\t\\tt.Errorf(\\\"test '%s' failed: input array '%v' with key '%d', expected '%d', get '%d'\\\", test.name, test.data, test.key, test.expected, actualValue)\\n\\t\\t}\\n\\t\\tif actualError != test.expectedError {\\n\\t\\t\\tt.Errorf(\\\"test '%s' failed: input array '%v' with key '%d', expected error '%s', get error '%s'\\\", test.name, test.data, test.key, test.expectedError, actualError)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkInterpolation(b *testing.B) {\\n\\ttestCase := generateBenchmarkTestCase()\\n\\tb.ResetTimer() // exclude time taken to generate test case\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = Interpolation(testCase, i)\\n\\t}\\n}\\n\"",
    "jump": "\"// jump.go\\n// description: Implementation of jump search\\n// details:\\n// A search algorithm for ordered list that jump through the list to narrow down the range\\n// before performing a linear search\\n// reference: https://en.wikipedia.org/wiki/Jump_search\\n// see jump_test.go for a test implementation, test function TestJump\\n\\npackage search\\n\\nimport \\\"math\\\"\\n\\n// Jump search works by jumping multiple steps ahead in sorted list until it find an item larger than target,\\n// then create a sublist of item from the last searched item up to the current item and perform a linear search.\\nfunc Jump(array []int, target int) (int, error) {\\n\\tn := len(array)\\n\\tif n == 0 {\\n\\t\\treturn -1, ErrNotFound\\n\\t}\\n\\n\\t// the optimal value of step is square root of the length of list\\n\\tstep := int(math.Round(math.Sqrt(float64(n))))\\n\\n\\tprev := 0    // previous index\\n\\tcurr := step // current index\\n\\tfor array[curr-1] < target {\\n\\t\\tprev = curr\\n\\t\\tif prev >= len(array) {\\n\\t\\t\\treturn -1, ErrNotFound\\n\\t\\t}\\n\\n\\t\\tcurr += step\\n\\n\\t\\t// prevent jumping over list range\\n\\t\\tif curr > n {\\n\\t\\t\\tcurr = n\\n\\t\\t}\\n\\t}\\n\\n\\t// perform linear search from index prev to index curr\\n\\tfor array[prev] < target {\\n\\t\\tprev++\\n\\n\\t\\t// if reach end of range, indicate target not found\\n\\t\\tif prev == curr {\\n\\t\\t\\treturn -1, ErrNotFound\\n\\t\\t}\\n\\t}\\n\\tif array[prev] == target {\\n\\t\\treturn prev, nil\\n\\t}\\n\\n\\treturn -1, ErrNotFound\\n\\n}\\n\"",
    "jump test": "\"package search\\n\\nimport \\\"testing\\\"\\n\\nfunc TestJump(t *testing.T) {\\n\\tfor _, test := range searchTests {\\n\\t\\tactualValue, actualError := Jump(test.data, test.key)\\n\\t\\tif actualValue != test.expected {\\n\\t\\t\\tt.Errorf(\\\"test '%s' failed: input array '%v' with key '%d', expected '%d', get '%d'\\\", test.name, test.data, test.key, test.expected, actualValue)\\n\\t\\t}\\n\\t\\tif actualError != test.expectedError {\\n\\t\\t\\tt.Errorf(\\\"test '%s' failed: input array '%v' with key '%d', expected error '%s', get error '%s'\\\", test.name, test.data, test.key, test.expectedError, actualError)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkJump(b *testing.B) {\\n\\ttestCase := generateBenchmarkTestCase()\\n\\tb.ResetTimer() // exclude time taken to generate test case\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = Jump(testCase, i)\\n\\t}\\n}\\n\"",
    "linear": "\"package search\\n\\n// Linear Simple linear search algorithm that iterates over all elements of an array in the worst case scenario\\nfunc Linear(array []int, query int) (int, error) {\\n\\tfor i, item := range array {\\n\\t\\tif item == query {\\n\\t\\t\\treturn i, nil\\n\\t\\t}\\n\\t}\\n\\treturn -1, ErrNotFound\\n}\\n\"",
    "linear test": "\"package search\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestLinear(t *testing.T) {\\n\\tfor _, test := range searchTests {\\n\\t\\tactualValue, actualError := Linear(test.data, test.key)\\n\\t\\tif actualValue != test.expected {\\n\\t\\t\\tt.Errorf(\\\"test '%s' failed: input array '%v' with key '%d', expected '%d', get '%d'\\\", test.name, test.data, test.key, test.expected, actualValue)\\n\\t\\t}\\n\\t\\tif actualError != test.expectedError {\\n\\t\\t\\tt.Errorf(\\\"test '%s' failed: input array '%v' with key '%d', expected error '%s', get error '%s'\\\", test.name, test.data, test.key, test.expectedError, actualError)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkLinear(b *testing.B) {\\n\\ttestCase := generateBenchmarkTestCase()\\n\\tb.ResetTimer() // exclude time taken to generate test case\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = Linear(testCase, i)\\n\\t}\\n}\\n\"",
    "ternary": "\"package search\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\n// TernaryMax is a function to search for maximum value of a uni-modal function `f`\\n// in the interval [a, b]. a and b should be finit numbers\\nfunc TernaryMax(a, b, epsilon float64, f func(x float64) float64) (float64, error) {\\n\\tif a == math.Inf(-1) || b == math.Inf(1) {\\n\\t\\treturn -1, fmt.Errorf(\\\"interval boundaries should be finite numbers\\\")\\n\\t}\\n\\tif math.Abs(a-b) <= epsilon {\\n\\t\\treturn f((a + b) / 2), nil\\n\\t}\\n\\tleft := (2*a + b) / 3\\n\\tright := (a + 2*b) / 3\\n\\tif f(left) < f(right) {\\n\\t\\treturn TernaryMax(left, b, epsilon, f)\\n\\t}\\n\\treturn TernaryMax(a, right, epsilon, f)\\n}\\n\\n// TernaryMin is a function to search for minimum value of a uni-modal function `f`\\n// in the interval [a, b]. a and b should be finit numbers.\\nfunc TernaryMin(a, b, epsilon float64, f func(x float64) float64) (float64, error) {\\n\\tif a == math.Inf(-1) || b == math.Inf(1) {\\n\\t\\treturn -1, fmt.Errorf(\\\"interval boundaries should be finite numbers\\\")\\n\\t}\\n\\tif math.Abs(a-b) <= epsilon {\\n\\t\\treturn f((a + b) / 2), nil\\n\\t}\\n\\tleft := (2*a + b) / 3\\n\\tright := (a + 2*b) / 3\\n\\tif f(left) > f(right) {\\n\\t\\treturn TernaryMin(left, b, epsilon, f)\\n\\t}\\n\\treturn TernaryMin(a, right, epsilon, f)\\n}\\n\"",
    "ternary test": "\"package search\\n\\nimport (\\n\\t\\\"math\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nconst EPS = 1e-6\\n\\nfunc equal(a, b float64) bool {\\n\\treturn math.Abs(a-b) <= EPS\\n}\\n\\nfunc TestTernaryMax(t *testing.T) {\\n\\n\\tvar tests = []struct {\\n\\t\\tf        func(x float64) float64\\n\\t\\ta        float64\\n\\t\\tb        float64\\n\\t\\texpected float64\\n\\t}{\\n\\t\\t{f: func(x float64) float64 { return -x * x }, a: 1, b: -1, expected: 0},\\n\\t\\t{f: func(x float64) float64 { return -2*x*x - x + 1 }, a: -1, b: 1, expected: 1.125},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tresult, err := TernaryMax(test.a, test.b, EPS, test.f)\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Errorf(\\\"error occurred: %v\\\", err)\\n\\t\\t}\\n\\t\\tif !equal(result, test.expected) {\\n\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%v, returned:%v \\\", test.expected, result)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc TestTernaryMin(t *testing.T) {\\n\\n\\tvar tests = []struct {\\n\\t\\tf        func(x float64) float64\\n\\t\\ta        float64\\n\\t\\tb        float64\\n\\t\\texpected float64\\n\\t}{\\n\\t\\t{f: func(x float64) float64 { return x * x }, a: -1, b: 1, expected: 0},\\n\\t\\t{f: func(x float64) float64 { return 2*x*x + x + 1 }, a: -1, b: 1, expected: 0.875},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tresult, err := TernaryMin(test.a, test.b, EPS, test.f)\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Errorf(\\\"error occurred: %v\\\", err)\\n\\t\\t}\\n\\t\\tif !equal(result, test.expected) {\\n\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%v, returned:%v \\\", test.expected, result)\\n\\t\\t}\\n\\t}\\n}\\n\"",
    "testcases": "\"package search\\n\\ntype searchTest struct {\\n\\tdata          []int\\n\\tkey           int\\n\\texpected      int\\n\\texpectedError error\\n\\tname          string\\n}\\n\\n// Note that these are immutable therefore they are shared among all the search tests.\\n// If your algorithm is mutating these then it is advisable to create separate test cases.\\nvar searchTests = []searchTest{\\n\\t//Sanity\\n\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 10, 9, nil, \\\"Sanity\\\"},\\n\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 9, 8, nil, \\\"Sanity\\\"},\\n\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 8, 7, nil, \\\"Sanity\\\"},\\n\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 7, 6, nil, \\\"Sanity\\\"},\\n\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 6, 5, nil, \\\"Sanity\\\"},\\n\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 5, 4, nil, \\\"Sanity\\\"},\\n\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 4, 3, nil, \\\"Sanity\\\"},\\n\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 3, 2, nil, \\\"Sanity\\\"},\\n\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 2, 1, nil, \\\"Sanity\\\"},\\n\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 1, 0, nil, \\\"Sanity\\\"},\\n\\t//Absent\\n\\t{[]int{1, 4, 5, 6, 7, 10}, -25, -1, ErrNotFound, \\\"Absent\\\"},\\n\\t{[]int{1, 4, 5, 6, 7, 10}, 25, -1, ErrNotFound, \\\"Absent\\\"},\\n\\t//Empty slice\\n\\t{[]int{}, 2, -1, ErrNotFound, \\\"Empty\\\"},\\n}\\n\\n// This function generate consistent testcase for benchmark test.\\nfunc generateBenchmarkTestCase() []int {\\n\\tvar testCase []int\\n\\tfor i := 0; i < 1000; i++ {\\n\\t\\ttestCase = append(testCase, i)\\n\\t}\\n\\treturn testCase\\n}\\n\"",
    "bubble sort": "\"// Implementation of basic bubble sort algorithm\\n// Reference: https://en.wikipedia.org/wiki/Bubble_sort\\n\\npackage sort\\n\\nfunc bubbleSort(arr []int) []int {\\n\\tswapped := true\\n\\tfor swapped {\\n\\t\\tswapped = false\\n\\t\\tfor i := 0; i < len(arr)-1; i++ {\\n\\t\\t\\tif arr[i+1] < arr[i] {\\n\\t\\t\\t\\tarr[i+1], arr[i] = arr[i], arr[i+1]\\n\\t\\t\\t\\tswapped = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn arr\\n}\\n\"",
    "comb sort": "\"// Implementation of comb sort algorithm, an improvement of bubble sort\\n// Reference: https://www.geeksforgeeks.org/comb-sort/\\n\\npackage sort\\n\\nfunc getNextGap(gap int) int {\\n\\tgap = (gap * 10) / 13\\n\\tif gap < 1 {\\n\\t\\treturn 1\\n\\t}\\n\\treturn gap\\n}\\n\\nfunc Comb(data []int) []int {\\n\\tn := len(data)\\n\\tgap := n\\n\\tswapped := true\\n\\n\\tfor gap != 1 || swapped {\\n\\t\\tgap = getNextGap(gap)\\n\\t\\tswapped = false\\n\\t\\tfor i := 0; i < n-gap; i++ {\\n\\t\\t\\tif data[i] > data[i+gap] {\\n\\t\\t\\t\\tdata[i], data[i+gap] = data[i+gap], data[i]\\n\\t\\t\\t\\tswapped = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn data\\n}\\n\"",
    "counting sort": "\"// countingsort.go\\n// description: Implementation of counting sort algorithm\\n// details: A simple counting sort algorithm implementation\\n// author [Phil](https://github.com/pschik)\\n// see sort_test.go for a test implementation, test function TestQuickSort\\n\\npackage sort\\n\\nfunc Count(data []int) []int {\\n\\tvar aMin, aMax = -1000, 1000\\n\\tcount := make([]int, aMax-aMin+1)\\n\\tfor _, x := range data {\\n\\t\\tcount[x-aMin]++\\n\\t}\\n\\tz := 0\\n\\tfor i, c := range count {\\n\\t\\tfor c > 0 {\\n\\t\\t\\tdata[z] = i + aMin\\n\\t\\t\\tz++\\n\\t\\t\\tc--\\n\\t\\t}\\n\\t}\\n\\treturn data\\n}\\n\"",
    "exchange sort": "\"// Implementation of exchange sort algorithm, a variant of bubble sort\\n// Reference: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\\n\\npackage sort\\n\\nfunc Exchange(arr []int) []int {\\n\\tfor i := 0; i < len(arr)-1; i++ {\\n\\t\\tfor j := i + 1; j < len(arr); j++ {\\n\\t\\t\\tif arr[i] > arr[j] {\\n\\t\\t\\t\\tarr[i], arr[j] = arr[j], arr[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr\\n}\\n\"",
    "heap sort": "\"package sort\\n\\ntype MaxHeap struct {\\n\\tslice    []Comparable\\n\\theapSize int\\n\\tindices  map[int]int\\n}\\n\\nfunc buildMaxHeap(slice0 []int) MaxHeap {\\n\\tvar slice []Comparable\\n\\tfor _, i := range slice0 {\\n\\t\\tslice = append(slice, Int(i))\\n\\t}\\n\\th := MaxHeap{}\\n\\th.Init(slice)\\n\\treturn h\\n}\\n\\nfunc (h *MaxHeap) Init(slice []Comparable) {\\n\\tif slice == nil {\\n\\t\\tslice = make([]Comparable, 0)\\n\\t}\\n\\n\\th.slice = slice\\n\\th.heapSize = len(slice)\\n\\th.indices = make(map[int]int)\\n\\th.Heapify()\\n}\\n\\nfunc (h MaxHeap) Heapify() {\\n\\tfor i, v := range h.slice {\\n\\t\\th.indices[v.Idx()] = i\\n\\t}\\n\\tfor i := h.heapSize / 2; i >= 0; i-- {\\n\\t\\th.heapifyDown(i)\\n\\t}\\n}\\n\\nfunc (h *MaxHeap) Pop() Comparable {\\n\\tif h.heapSize == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\ti := h.slice[0]\\n\\th.heapSize--\\n\\n\\th.slice[0] = h.slice[h.heapSize]\\n\\th.updateidx(0)\\n\\th.heapifyDown(0)\\n\\n\\th.slice = h.slice[0:h.heapSize]\\n\\treturn i\\n}\\n\\nfunc (h *MaxHeap) Push(i Comparable) {\\n\\th.slice = append(h.slice, i)\\n\\th.updateidx(h.heapSize)\\n\\th.heapifyUp(h.heapSize)\\n\\th.heapSize++\\n}\\n\\nfunc (h MaxHeap) Size() int {\\n\\treturn h.heapSize\\n}\\n\\nfunc (h MaxHeap) Update(i Comparable) {\\n\\th.slice[h.indices[i.Idx()]] = i\\n\\th.heapifyUp(h.indices[i.Idx()])\\n\\th.heapifyDown(h.indices[i.Idx()])\\n}\\n\\nfunc (h MaxHeap) updateidx(i int) {\\n\\th.indices[h.slice[i].Idx()] = i\\n}\\n\\nfunc (h MaxHeap) heapifyUp(i int) {\\n\\tif i == 0 {\\n\\t\\treturn\\n\\t}\\n\\tp := i / 2\\n\\n\\tif h.slice[i].More(h.slice[p]) {\\n\\t\\th.slice[i], h.slice[p] = h.slice[p], h.slice[i]\\n\\t\\th.updateidx(i)\\n\\t\\th.updateidx(p)\\n\\t\\th.heapifyUp(p)\\n\\t}\\n}\\n\\nfunc (h MaxHeap) heapifyDown(i int) {\\n\\tl, r := 2*i+1, 2*i+2\\n\\tmax := i\\n\\n\\tif l < h.heapSize && h.slice[l].More(h.slice[max]) {\\n\\t\\tmax = l\\n\\t}\\n\\tif r < h.heapSize && h.slice[r].More(h.slice[max]) {\\n\\t\\tmax = r\\n\\t}\\n\\tif max != i {\\n\\t\\th.slice[i], h.slice[max] = h.slice[max], h.slice[i]\\n\\t\\th.updateidx(i)\\n\\t\\th.updateidx(max)\\n\\t\\th.heapifyDown(max)\\n\\t}\\n}\\n\\ntype Comparable interface {\\n\\tIdx() int\\n\\tMore(interface{}) bool\\n}\\ntype Int int\\n\\nfunc (a Int) More(b interface{}) bool {\\n\\treturn a > b.(Int)\\n}\\nfunc (a Int) Idx() int {\\n\\treturn int(a)\\n}\\n\\nfunc HeapSort(slice []int) []int {\\n\\th := buildMaxHeap(slice)\\n\\tfor i := len(h.slice) - 1; i >= 1; i-- {\\n\\t\\th.slice[0], h.slice[i] = h.slice[i], h.slice[0]\\n\\t\\th.heapSize--\\n\\t\\th.heapifyDown(0)\\n\\t}\\n\\n\\tres := []int{}\\n\\tfor _, i := range h.slice {\\n\\t\\tres = append(res, int(i.(Int)))\\n\\t}\\n\\treturn res\\n}\\n\"",
    "insertion sort": "\"package sort\\n\\nfunc InsertionSort(arr []int) []int {\\n\\tfor currentIndex := 1; currentIndex < len(arr); currentIndex++ {\\n\\t\\ttemporary := arr[currentIndex]\\n\\t\\titerator := currentIndex\\n\\t\\tfor ; iterator > 0 && arr[iterator-1] >= temporary; iterator-- {\\n\\t\\t\\tarr[iterator] = arr[iterator-1]\\n\\t\\t}\\n\\t\\tarr[iterator] = temporary\\n\\t}\\n\\treturn arr\\n}\\n\"",
    "merge sort": "\"package sort\\n\\nfunc merge(a []int, b []int) []int {\\n\\n\\tvar r = make([]int, len(a)+len(b))\\n\\tvar i = 0\\n\\tvar j = 0\\n\\n\\tfor i < len(a) && j < len(b) {\\n\\n\\t\\tif a[i] <= b[j] {\\n\\t\\t\\tr[i+j] = a[i]\\n\\t\\t\\ti++\\n\\t\\t} else {\\n\\t\\t\\tr[i+j] = b[j]\\n\\t\\t\\tj++\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfor i < len(a) {\\n\\t\\tr[i+j] = a[i]\\n\\t\\ti++\\n\\t}\\n\\tfor j < len(b) {\\n\\t\\tr[i+j] = b[j]\\n\\t\\tj++\\n\\t}\\n\\n\\treturn r\\n\\n}\\n\\n//Mergesort Perform mergesort on a slice of ints\\nfunc Mergesort(items []int) []int {\\n\\n\\tif len(items) < 2 {\\n\\t\\treturn items\\n\\n\\t}\\n\\n\\tvar middle = len(items) / 2\\n\\tvar a = Mergesort(items[:middle])\\n\\tvar b = Mergesort(items[middle:])\\n\\treturn merge(a, b)\\n\\n}\\n\"",
    "pigeonhole sort": "\"// Pigeonhole algorithm's working at wikipedia.\\n// https://en.wikipedia.org/wiki/Pigeonhole_sort\\n\\npackage sort\\n\\nimport (\\n\\t\\\"github.com/TheAlgorithms/Go/math/max\\\"\\n\\t\\\"github.com/TheAlgorithms/Go/math/min\\\"\\n)\\n\\n// Pigeonhole sorts a slice using pigeonhole sorting algorithm.\\nfunc Pigeonhole(arr []int) []int {\\n\\tif len(arr) == 0 {\\n\\t\\treturn arr\\n\\t}\\n\\n\\tmax := max.Int(arr...)\\n\\tmin := min.Int(arr...)\\n\\n\\tsize := max - min + 1\\n\\n\\tholes := make([]int, size)\\n\\n\\tfor _, element := range arr {\\n\\t\\tholes[element-min]++\\n\\t}\\n\\n\\ti := 0\\n\\n\\tfor j := 0; j < size; j++ {\\n\\t\\tfor holes[j] > 0 {\\n\\t\\t\\tholes[j]--\\n\\t\\t\\tarr[i] = j + min\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr\\n}\\n\"",
    "quick sort": "\"// quicksort.go\\n// description: Implementation of in-place quicksort algorithm\\n// details:\\n// A simple in-place quicksort algorithm implementation. [Wikipedia](https://en.wikipedia.org/wiki/Quicksort)\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see sort_test.go for a test implementation, test function TestQuickSort.\\n\\npackage sort\\n\\nfunc partition(arr []int, low, high int) int {\\n\\tindex := low - 1\\n\\tpivotElement := arr[high]\\n\\tfor i := low; i < high; i++ {\\n\\t\\tif arr[i] <= pivotElement {\\n\\t\\t\\tindex += 1\\n\\t\\t\\tarr[index], arr[i] = arr[i], arr[index]\\n\\t\\t}\\n\\t}\\n\\tarr[index+1], arr[high] = arr[high], arr[index+1]\\n\\treturn index + 1\\n}\\n\\n// QuickSortRange Sorts the specified range within the array\\nfunc QuickSortRange(arr []int, low, high int) {\\n\\tif len(arr) <= 1 {\\n\\t\\treturn\\n\\t}\\n\\n\\tif low < high {\\n\\t\\tpivot := partition(arr, low, high)\\n\\t\\tQuickSortRange(arr, low, pivot-1)\\n\\t\\tQuickSortRange(arr, pivot+1, high)\\n\\t}\\n}\\n\\n// QuickSort Sorts the entire array\\nfunc QuickSort(arr []int) []int {\\n\\tQuickSortRange(arr, 0, len(arr)-1)\\n\\treturn arr\\n}\\n\"",
    "radix sort": "\"package sort\\n\\nimport \\\"github.com/TheAlgorithms/Go/math/max\\\"\\n\\nfunc countSort(arr []int, exp int) []int {\\n\\tvar digits [10]int\\n\\tvar output = make([]int, len(arr))\\n\\n\\tfor _, item := range arr {\\n\\t\\tdigits[(item/exp)%10]++\\n\\t}\\n\\tfor i := 1; i < 10; i++ {\\n\\t\\tdigits[i] += digits[i-1]\\n\\t}\\n\\n\\tfor i := len(arr) - 1; i >= 0; i-- {\\n\\t\\toutput[digits[(arr[i]/exp)%10]-1] = arr[i]\\n\\t\\tdigits[(arr[i]/exp)%10]--\\n\\t}\\n\\n\\treturn output\\n}\\n\\nfunc unsignedRadixSort(arr []int) []int {\\n\\tif len(arr) == 0 {\\n\\t\\treturn arr\\n\\t}\\n\\tmaxElement := max.Int(arr...)\\n\\tfor exp := 1; maxElement/exp > 0; exp *= 10 {\\n\\t\\tarr = countSort(arr, exp)\\n\\t}\\n\\treturn arr\\n}\\n\\nfunc RadixSort(arr []int) []int {\\n\\tif len(arr) < 1 {\\n\\t\\treturn arr\\n\\t}\\n\\tvar negatives, nonNegatives []int\\n\\n\\tfor _, item := range arr {\\n\\t\\tif item < 0 {\\n\\t\\t\\tnegatives = append(negatives, -item)\\n\\t\\t} else {\\n\\t\\t\\tnonNegatives = append(nonNegatives, item)\\n\\t\\t}\\n\\t}\\n\\tnegatives = unsignedRadixSort(negatives)\\n\\n\\t// Reverse the negative array and restore signs\\n\\tfor i, j := 0, len(negatives)-1; i <= j; i, j = i+1, j-1 {\\n\\t\\tnegatives[i], negatives[j] = -negatives[j], -negatives[i]\\n\\t}\\n\\treturn append(negatives, unsignedRadixSort(nonNegatives)...)\\n}\\n\"",
    "selection sort": "\"package sort\\n\\nfunc SelectionSort(arr []int) []int {\\n\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tmin := i\\n\\t\\tfor j := i + 1; j < len(arr); j++ {\\n\\t\\t\\tif arr[j] < arr[min] {\\n\\t\\t\\t\\tmin = j\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tarr[i], arr[min] = arr[min], arr[i]\\n\\t}\\n\\treturn arr\\n}\\n\"",
    "shell sort": "\"package sort\\n\\nfunc ShellSort(arr []int) []int {\\n\\tfor d := int(len(arr) / 2); d > 0; d /= 2 {\\n\\t\\tfor i := d; i < len(arr); i++ {\\n\\t\\t\\tfor j := i; j >= d && arr[j-d] > arr[j]; j -= d {\\n\\t\\t\\t\\tarr[j], arr[j-d] = arr[j-d], arr[j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn arr\\n}\\n\"",
    "simple sort": "\"// simplesort.go\\n// description: Implementation of a simple sorting algorithm\\n// details:\\n// A simple sorting algorithm that look counter intuitive at first glance and very similar to Exchange Sort\\n// An improved version is included with slight changes to make the sort slightly more efficient\\n// reference: https://arxiv.org/abs/2110.01111v1\\n// see sort_test.go for a test implementation, test function TestSimple and TestImprovedSimple\\n\\npackage sort\\n\\nfunc SimpleSort(arr []int) []int {\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tfor j := 0; j < len(arr); j++ {\\n\\t\\t\\tif arr[i] < arr[j] {\\n\\t\\t\\t\\t// swap arr[i] and arr[j]\\n\\t\\t\\t\\tarr[i], arr[j] = arr[j], arr[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn arr\\n}\\n\\n// ImprovedSimpleSort is a improve SimpleSort by skipping an unnecessary comparison of the first and last.\\n// This improved version is more similar to implementation of insertion sort\\nfunc ImprovedSimpleSort(arr []int) []int {\\n\\tfor i := 1; i < len(arr); i++ {\\n\\t\\tfor j := 0; j < len(arr)-1; j++ {\\n\\t\\t\\tif arr[i] < arr[j] {\\n\\t\\t\\t\\t// swap arr[i] and arr[j]\\n\\t\\t\\t\\tarr[i], arr[j] = arr[j], arr[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn arr\\n}\\n\"",
    "sorts test": "\"package sort\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc testFramework(t *testing.T, sortingFunction func([]int) []int) {\\n\\tsortTests := []struct {\\n\\t\\tinput    []int\\n\\t\\texpected []int\\n\\t\\tname     string\\n\\t}{\\n\\t\\t//Sorted slice\\n\\t\\t{\\n\\t\\t\\tinput:    []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\\n\\t\\t\\texpected: []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\\n\\t\\t\\tname:     \\\"Sorted Unsigned\\\",\\n\\t\\t},\\n\\t\\t//Reversed slice\\n\\t\\t{\\n\\t\\t\\tinput:    []int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1},\\n\\t\\t\\texpected: []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\\n\\t\\t\\tname:     \\\"Reversed Unsigned\\\",\\n\\t\\t},\\n\\t\\t//Sorted slice\\n\\t\\t{\\n\\t\\t\\tinput:    []int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\\n\\t\\t\\texpected: []int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\\n\\t\\t\\tname:     \\\"Sorted Signed\\\",\\n\\t\\t},\\n\\t\\t//Reversed slice\\n\\t\\t{\\n\\t\\t\\tinput:    []int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10},\\n\\t\\t\\texpected: []int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\\n\\t\\t\\tname:     \\\"Reversed Signed\\\",\\n\\t\\t},\\n\\t\\t//Reversed slice, even length\\n\\t\\t{\\n\\t\\t\\tinput:    []int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10},\\n\\t\\t\\texpected: []int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\\n\\t\\t\\tname:     \\\"Reversed Signed #2\\\",\\n\\t\\t},\\n\\t\\t//Random order with repetitions\\n\\t\\t{\\n\\t\\t\\tinput:    []int{-5, 7, 4, -2, 6, 5, 8, 3, 2, -7, -1, 0, -3, 9, -6, -4, 10, 9, 1, -8, -9, -10},\\n\\t\\t\\texpected: []int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10},\\n\\t\\t\\tname:     \\\"Random order Signed\\\",\\n\\t\\t},\\n\\t\\t//Single-entry slice\\n\\t\\t{\\n\\t\\t\\tinput:    []int{1},\\n\\t\\t\\texpected: []int{1},\\n\\t\\t\\tname:     \\\"Singleton\\\",\\n\\t\\t},\\n\\t\\t// Empty slice\\n\\t\\t{\\n\\t\\t\\tinput:    []int{},\\n\\t\\t\\texpected: []int{},\\n\\t\\t\\tname:     \\\"Empty Slice\\\",\\n\\t\\t},\\n\\t}\\n\\tfor _, test := range sortTests {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tactual := sortingFunction(test.input)\\n\\t\\t\\tsorted := reflect.DeepEqual(actual, test.expected)\\n\\t\\t\\tif !sorted {\\n\\t\\t\\t\\tt.Errorf(\\\"test %s failed\\\", test.name)\\n\\t\\t\\t\\tt.Errorf(\\\"actual %v expected %v\\\", actual, test.expected)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\n//BEGIN TESTS\\n\\nfunc TestBubble(t *testing.T) {\\n\\ttestFramework(t, bubbleSort)\\n}\\n\\nfunc TestExchange(t *testing.T) {\\n\\ttestFramework(t, Exchange)\\n}\\n\\nfunc TestInsertion(t *testing.T) {\\n\\ttestFramework(t, InsertionSort)\\n}\\n\\nfunc TestMerge(t *testing.T) {\\n\\ttestFramework(t, Mergesort)\\n}\\n\\nfunc TestHeap(t *testing.T) {\\n\\ttestFramework(t, HeapSort)\\n}\\n\\nfunc TestCount(t *testing.T) {\\n\\ttestFramework(t, Count)\\n}\\n\\nfunc TestQuick(t *testing.T) {\\n\\ttestFramework(t, QuickSort)\\n}\\n\\nfunc TestShell(t *testing.T) {\\n\\ttestFramework(t, ShellSort)\\n}\\n\\nfunc TestRadix(t *testing.T) {\\n\\ttestFramework(t, RadixSort)\\n}\\n\\nfunc TestSimple(t *testing.T) {\\n\\ttestFramework(t, SimpleSort)\\n}\\n\\nfunc TestImprovedSimple(t *testing.T) {\\n\\ttestFramework(t, ImprovedSimpleSort)\\n}\\n\\nfunc TestSelection(t *testing.T) {\\n\\ttestFramework(t, SelectionSort)\\n}\\n\\nfunc TestComb(t *testing.T) {\\n\\ttestFramework(t, Comb)\\n}\\n\\nfunc TestPigeonhole(t *testing.T) {\\n\\ttestFramework(t, Pigeonhole)\\n}\\n\\n//END TESTS\\n\\nfunc benchmarkFramework(b *testing.B, f func(arr []int) []int) {\\n\\tvar sortTests = []struct {\\n\\t\\tinput    []int\\n\\t\\texpected []int\\n\\t\\tname     string\\n\\t}{\\n\\t\\t//Sorted slice\\n\\t\\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\\n\\t\\t\\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, \\\"Sorted Unsigned\\\"},\\n\\t\\t//Reversed slice\\n\\t\\t{[]int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1},\\n\\t\\t\\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, \\\"Reversed Unsigned\\\"},\\n\\t\\t//Sorted slice\\n\\t\\t{[]int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\\n\\t\\t\\t[]int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, \\\"Sorted Signed\\\"},\\n\\t\\t//Reversed slice\\n\\t\\t{[]int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10},\\n\\t\\t\\t[]int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, \\\"Reversed Signed\\\"},\\n\\t\\t//Reversed slice, even length\\n\\t\\t{[]int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10},\\n\\t\\t\\t[]int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, \\\"Reversed Signed #2\\\"},\\n\\t\\t//Random order with repetitions\\n\\t\\t{[]int{-5, 7, 4, -2, 6, 5, 8, 3, 2, -7, -1, 0, -3, 9, -6, -4, 10, 9, 1, -8, -9, -10},\\n\\t\\t\\t[]int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10}, \\\"Random order Signed\\\"},\\n\\t\\t//Empty slice\\n\\t\\t{[]int{}, []int{}, \\\"Empty\\\"},\\n\\t\\t//Single-entry slice\\n\\t\\t{[]int{1}, []int{1}, \\\"Singleton\\\"},\\n\\t}\\n\\tb.ResetTimer()\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tfor _, test := range sortTests {\\n\\t\\t\\tf(test.input)\\n\\t\\t}\\n\\t}\\n}\\n\\n//BEGIN BENCHMARKS\\n\\nfunc BenchmarkBubble(b *testing.B) {\\n\\tbenchmarkFramework(b, bubbleSort)\\n}\\n\\nfunc BenchmarkExchange(b *testing.B) {\\n\\tbenchmarkFramework(b, Exchange)\\n}\\n\\nfunc BenchmarkInsertion(b *testing.B) {\\n\\tbenchmarkFramework(b, InsertionSort)\\n}\\n\\nfunc BenchmarkMerge(b *testing.B) {\\n\\tbenchmarkFramework(b, Mergesort)\\n}\\n\\nfunc BenchmarkHeap(b *testing.B) {\\n\\tbenchmarkFramework(b, HeapSort)\\n}\\n\\nfunc BenchmarkCount(b *testing.B) {\\n\\tbenchmarkFramework(b, Count)\\n}\\n\\nfunc BenchmarkQuick(b *testing.B) {\\n\\tbenchmarkFramework(b, QuickSort)\\n}\\n\\nfunc BenchmarkShell(b *testing.B) {\\n\\tbenchmarkFramework(b, ShellSort)\\n}\\n\\nfunc BenchmarkRadix(b *testing.B) {\\n\\tbenchmarkFramework(b, RadixSort)\\n}\\n\\nfunc BenchmarkSimple(b *testing.B) {\\n\\tbenchmarkFramework(b, SimpleSort)\\n}\\n\\nfunc BenchmarkImprovedSimple(b *testing.B) {\\n\\tbenchmarkFramework(b, ImprovedSimpleSort)\\n}\\n\\n// Very Slow, consider commenting\\nfunc BenchmarkSelection(b *testing.B) {\\n\\tbenchmarkFramework(b, SelectionSort)\\n}\\n\\nfunc BenchmarkComb(b *testing.B) {\\n\\tbenchmarkFramework(b, Comb)\\n}\\n\\nfunc BenchmarkPigeonhole(b *testing.B) {\\n\\tbenchmarkFramework(b, Pigeonhole)\\n}\\n\"",
    "strings test": "\"// Empty test file to keep track of all the tests for the algorithms.\\n\\npackage strings\\n\"",
    "structure test": "\"// Empty test file to keep track of all the tests for the algorithms.\\n\\npackage structure\\n\"",
    "caesar": "\"// Package caesar is the shift cipher\\n// ref: https://en.wikipedia.org/wiki/Caesar_cipher\\npackage caesar\\n\\n// Encrypt encrypts by right shift of \\\"key\\\" each character of \\\"input\\\"\\nfunc Encrypt(input string, key int) string {\\n\\t// if key is negative value,\\n\\t// updates \\\"key\\\" the number which congruents to \\\"key\\\" modulo 26\\n\\tkey8 := byte(key%26+26) % 26\\n\\n\\tvar outputBuffer []byte\\n\\t// r is a rune, which is the equivalent of uint32.\\n\\tfor _, r := range input {\\n\\t\\tnewByte := byte(r)\\n\\t\\tif 'A' <= r && r <= 'Z' {\\n\\t\\t\\toutputBuffer = append(outputBuffer, 'A'+(newByte-'A'+key8)%26)\\n\\t\\t} else if 'a' <= r && r <= 'z' {\\n\\t\\t\\toutputBuffer = append(outputBuffer, 'a'+(newByte-'a'+key8)%26)\\n\\t\\t} else {\\n\\t\\t\\toutputBuffer = append(outputBuffer, newByte)\\n\\t\\t}\\n\\t}\\n\\treturn string(outputBuffer)\\n}\\n\\n// Decrypt decrypts by left shift of \\\"key\\\" each character of \\\"input\\\"\\nfunc Decrypt(input string, key int) string {\\n\\t// left shift of \\\"key\\\" is same as right shift of 26-\\\"key\\\"\\n\\treturn Encrypt(input, 26-key)\\n}\\n\"",
    "caesar test": "\"package caesar\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestEncrypt(t *testing.T) {\\n\\tvar caesarTestData = []struct {\\n\\t\\tdescription string\\n\\t\\tinput       string\\n\\t\\tkey         int\\n\\t\\texpected    string\\n\\t}{\\n\\t\\t{\\n\\t\\t\\t\\\"Basic caesar encryption with letter 'a'\\\",\\n\\t\\t\\t\\\"a\\\",\\n\\t\\t\\t3,\\n\\t\\t\\t\\\"d\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Basic caesar encryption wrap around alphabet on letter 'z'\\\",\\n\\t\\t\\t\\\"z\\\",\\n\\t\\t\\t3,\\n\\t\\t\\t\\\"c\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Encrypt a simple string with caesar encryiption\\\",\\n\\t\\t\\t\\\"hello\\\",\\n\\t\\t\\t3,\\n\\t\\t\\t\\\"khoor\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Encrypt a simple string with key 13\\\",\\n\\t\\t\\t\\\"hello\\\",\\n\\t\\t\\t13,\\n\\t\\t\\t\\\"uryyb\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Encrypt a simple string with key -13\\\",\\n\\t\\t\\t\\\"hello\\\",\\n\\t\\t\\t-13,\\n\\t\\t\\t\\\"uryyb\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"With key of 26 output should be the same as the input\\\",\\n\\t\\t\\t\\\"no change\\\",\\n\\t\\t\\t26,\\n\\t\\t\\t\\\"no change\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Encrypt sentence with key 10\\\",\\n\\t\\t\\t\\\"the quick brown fox jumps over the lazy dog.\\\",\\n\\t\\t\\t10,\\n\\t\\t\\t\\\"dro aesmu lbygx pyh tewzc yfob dro vkji nyq.\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Encrypt sentence with key 10\\\",\\n\\t\\t\\t\\\"The Quick Brown Fox Jumps over the Lazy Dog.\\\",\\n\\t\\t\\t10,\\n\\t\\t\\t\\\"Dro Aesmu Lbygx Pyh Tewzc yfob dro Vkji Nyq.\\\",\\n\\t\\t},\\n\\t}\\n\\tfor _, test := range caesarTestData {\\n\\t\\tt.Run(test.description, func(t *testing.T) {\\n\\t\\t\\tactual := Encrypt(test.input, test.key)\\n\\t\\t\\tif actual != test.expected {\\n\\t\\t\\t\\tt.Logf(\\\"FAIL: %s\\\", test.description)\\n\\t\\t\\t\\tt.Fatalf(\\\"With input string '%s' and key '%d' was expecting '%s' but actual was '%s'\\\",\\n\\t\\t\\t\\t\\ttest.input, test.key, test.expected, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestDecrypt(t *testing.T) {\\n\\tvar caesarTestData = []struct {\\n\\t\\tdescription string\\n\\t\\tinput       string\\n\\t\\tkey         int\\n\\t\\texpected    string\\n\\t}{\\n\\t\\t{\\n\\t\\t\\t\\\"Basic caesar decryption with letter 'a'\\\",\\n\\t\\t\\t\\\"a\\\",\\n\\t\\t\\t3,\\n\\t\\t\\t\\\"x\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Basic caesar decryption wrap around alphabet on letter 'z'\\\",\\n\\t\\t\\t\\\"z\\\",\\n\\t\\t\\t3,\\n\\t\\t\\t\\\"w\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Decrypt a simple string with caesar encryiption\\\",\\n\\t\\t\\t\\\"hello\\\",\\n\\t\\t\\t3,\\n\\t\\t\\t\\\"ebiil\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Decrypt a simple string with key 13\\\",\\n\\t\\t\\t\\\"hello\\\",\\n\\t\\t\\t13,\\n\\t\\t\\t\\\"uryyb\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Decrypt a simple string with key -13\\\",\\n\\t\\t\\t\\\"hello\\\",\\n\\t\\t\\t-13,\\n\\t\\t\\t\\\"uryyb\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"With key of 26 output should be the same as the input\\\",\\n\\t\\t\\t\\\"no change\\\",\\n\\t\\t\\t26,\\n\\t\\t\\t\\\"no change\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\\"Decrypt sentence with key 10\\\",\\n\\t\\t\\t\\\"Dro Aesmu Lbygx Pyh Tewzc yfob dro Vkji Nyq.\\\",\\n\\t\\t\\t10,\\n\\t\\t\\t\\\"The Quick Brown Fox Jumps over the Lazy Dog.\\\",\\n\\t\\t},\\n\\t}\\n\\n\\tfor _, test := range caesarTestData {\\n\\t\\tt.Run(test.description, func(t *testing.T) {\\n\\t\\t\\tactual := Decrypt(test.input, test.key)\\n\\t\\t\\tif actual != test.expected {\\n\\t\\t\\t\\tt.Logf(\\\"FAIL: %s\\\", test.description)\\n\\t\\t\\t\\tt.Fatalf(\\\"With input string '%s' and key '%d' was expecting '%s' but actual was '%s'\\\",\\n\\t\\t\\t\\t\\ttest.input, test.key, test.expected, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc Example() {\\n\\tconst (\\n\\t\\tkey   = 10\\n\\t\\tinput = \\\"The Quick Brown Fox Jumps over the Lazy Dog.\\\"\\n\\t)\\n\\n\\tencryptedText := Encrypt(input, key)\\n\\tfmt.Printf(\\\"Encrypt=> key: %d, input: %s, encryptedText: %s\\\\n\\\", key, input, encryptedText)\\n\\n\\tdecryptedText := Decrypt(encryptedText, key)\\n\\tfmt.Printf(\\\"Decrypt=> key: %d, input: %s, decryptedText: %s\\\\n\\\", key, encryptedText, decryptedText)\\n\\n\\t// Output:\\n\\t// Encrypt=> key: 10, input: The Quick Brown Fox Jumps over the Lazy Dog., encryptedText: Dro Aesmu Lbygx Pyh Tewzc yfob dro Vkji Nyq.\\n\\t// Decrypt=> key: 10, input: Dro Aesmu Lbygx Pyh Tewzc yfob dro Vkji Nyq., decryptedText: The Quick Brown Fox Jumps over the Lazy Dog.\\n}\\n\"",
    "diffiehell mankey exchange": "\"// Package diffiehellman implements Deffie Hellman Key Exchange Algorithm\\n// for more information watch : https://www.youtube.com/watch?v=NmM9HA2MQGI\\npackage diffiehellman\\n\\nconst (\\n\\tgenerator         = 3\\n\\tprimeNumber int64 = 6700417 // prime number discovered by Leonhard Euler\\n)\\n\\n// GenerateShareKey : generates a key using client private key , generator and primeNumber\\n// this key can be made public\\n// shareKey = (g^key)%primeNumber\\nfunc GenerateShareKey(prvKey int64) int64 {\\n\\treturn modularExponentiation(generator, prvKey, primeNumber)\\n}\\n\\n// GenerateMutualKey : generates a mutual key that can be used by only alice and bob\\n// mutualKey = (shareKey^prvKey)%primeNumber\\nfunc GenerateMutualKey(prvKey, shareKey int64) int64 {\\n\\treturn modularExponentiation(shareKey, prvKey, primeNumber)\\n}\\n\\n// r = (b^e)%mod\\nfunc modularExponentiation(b, e, mod int64) int64 {\\n\\n\\t//runs in O(log(n)) where n = e\\n\\t//uses exponentiation by squaring to speed up the process\\n\\tif mod == 1 {\\n\\t\\treturn 0\\n\\t}\\n\\tvar r int64 = 1\\n\\tb = b % mod\\n\\tfor e > 0 {\\n\\t\\tif e&1 == 1 {\\n\\t\\t\\tr = (r * b) % mod\\n\\t\\t}\\n\\t\\te = e >> 1\\n\\t\\tb = (b * b) % mod\\n\\t}\\n\\treturn r\\n}\\n\"",
    "diffiehell mankey exchange test": "\"package diffiehellman\\n\\nimport (\\n\\t\\\"crypto/rand\\\"\\n\\t\\\"crypto/rsa\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestDiffieHellmanKeyExchange(t *testing.T) {\\n\\tt.Run(\\\"Test 1: modularExponentiation\\\", func(t *testing.T) {\\n\\t\\tvar want int64 = 9 // (3^5)mod13 = 243mod13 = 9\\n\\t\\tvar prvKey int64 = 5\\n\\t\\tvar generator int64 = 3\\n\\t\\tvar primeNumber int64 = 13\\n\\t\\tgot := modularExponentiation(generator, prvKey, primeNumber)\\n\\t\\tif got != want {\\n\\t\\t\\tt.Errorf(`with privateKey=%d, generator=%d and primeNumber=%d  \\n\\t\\t\\tmodularExponentiation should result=%d, but resulted=%d`, prvKey, generator, primeNumber, want, got)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test 2: Key Exchange\\\", func(t *testing.T) {\\n\\t\\t// generating a small sized rsa_cipher key for testing\\n\\t\\talicePrvKey, _ := rsa.GenerateKey(rand.Reader, 31)\\n\\t\\tbobPrvKey, _ := rsa.GenerateKey(rand.Reader, 31)\\n\\n\\t\\t// alice and bob generates their respective share key with their privateKey\\n\\t\\tshareKeyByAlice := GenerateShareKey(alicePrvKey.D.Int64())\\n\\t\\tshareKeyByBob := GenerateShareKey(bobPrvKey.D.Int64())\\n\\n\\t\\t// generated share key now can be exchanged even via insecure channel\\n\\n\\t\\t// mutualKey can be computed using shared key\\n\\t\\tmutualKeyComputedByAlice := GenerateMutualKey(alicePrvKey.D.Int64(), shareKeyByBob)\\n\\t\\tmutualKeyComputedByBob := GenerateMutualKey(bobPrvKey.D.Int64(), shareKeyByAlice)\\n\\n\\t\\tif mutualKeyComputedByAlice != mutualKeyComputedByBob {\\n\\t\\t\\tt.Errorf(\\\"mutual key computed by alice and bob should be same, but got un-equal\\\")\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "polybius": "\"// Package polybius is encrypting method with polybius square\\n// ref: https://en.wikipedia.org/wiki/Polybius_square#Hybrid_Polybius_Playfair_Cipher\\npackage polybius\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n\\t\\\"strings\\\"\\n)\\n\\n// Polybius is struct having size, characters, and key\\ntype Polybius struct {\\n\\tsize       int\\n\\tcharacters string\\n\\tkey        string\\n}\\n\\n// NewPolybius returns a pointer to object of Polybius.\\n// If the size of \\\"chars\\\" is longer than \\\"size\\\",\\n// \\\"chars\\\" are truncated to \\\"size\\\".\\nfunc NewPolybius(key string, size int, chars string) (*Polybius, error) {\\n\\tkey = strings.ToUpper(key)\\n\\tchars = strings.ToUpper(chars)[:size]\\n\\tfor idx, ch := range chars {\\n\\t\\tif strings.Contains(chars[idx+1:], string(ch)) {\\n\\t\\t\\treturn nil, fmt.Errorf(\\\"\\\\\\\"chars\\\\\\\" contains same character: %c\\\", ch)\\n\\t\\t}\\n\\t}\\n\\n\\tif len(key) != size*size {\\n\\t\\treturn nil, fmt.Errorf(\\\"len(key): %d must be as long as size squared: %d\\\", len(key), size*size)\\n\\t}\\n\\treturn &Polybius{size, chars, key}, nil\\n}\\n\\n// Encrypt encrypts with polybius encryption\\nfunc (p *Polybius) Encrypt(text string) (string, error) {\\n\\tencryptedText := \\\"\\\"\\n\\tfor _, char := range strings.ToUpper(text) {\\n\\t\\tencryptedChar, err := p.encipher(char)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn \\\"\\\", fmt.Errorf(\\\"failed encipher: %w\\\", err)\\n\\t\\t}\\n\\t\\tencryptedText += encryptedChar\\n\\t}\\n\\treturn encryptedText, nil\\n}\\n\\n// Decrypt decrypts with polybius encryption\\nfunc (p *Polybius) Decrypt(text string) (string, error) {\\n\\tchars := []rune(strings.ToUpper(text))\\n\\tdecryptedText := \\\"\\\"\\n\\tfor i := 0; i < len(chars); i += 2 {\\n\\t\\tdecryptedChar, err := p.decipher(chars[i:int(math.Min(float64(i+2), float64(len(chars))))])\\n\\t\\tif err != nil {\\n\\t\\t\\treturn \\\"\\\", fmt.Errorf(\\\"failed decipher: %w\\\", err)\\n\\t\\t}\\n\\t\\tdecryptedText += decryptedChar\\n\\t}\\n\\treturn decryptedText, nil\\n}\\n\\nfunc (p *Polybius) encipher(char rune) (string, error) {\\n\\tindex := strings.IndexRune(p.key, char)\\n\\tif index < 0 {\\n\\t\\treturn \\\"\\\", fmt.Errorf(\\\"%c does not exist in keys\\\", char)\\n\\t}\\n\\trow := index / p.size\\n\\tcol := index % p.size\\n\\tchars := []rune(p.characters)\\n\\treturn string([]rune{chars[row], chars[col]}), nil\\n}\\n\\nfunc (p *Polybius) decipher(chars []rune) (string, error) {\\n\\tif len(chars) != 2 {\\n\\t\\treturn \\\"\\\", fmt.Errorf(\\\"the size of \\\\\\\"chars\\\\\\\" must be even\\\")\\n\\t}\\n\\trow := strings.IndexRune(p.characters, chars[0])\\n\\tif row < 0 {\\n\\t\\treturn \\\"\\\", fmt.Errorf(\\\"%c does not exist in characters\\\", chars[0])\\n\\t}\\n\\tcol := strings.IndexRune(p.characters, chars[1])\\n\\tif col < 0 {\\n\\t\\treturn \\\"\\\", fmt.Errorf(\\\"%c does not exist in characters\\\", chars[1])\\n\\t}\\n\\treturn string([]rune(p.key)[row*p.size+col]), nil\\n}\\n\"",
    "polybius test": "\"package polybius\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"log\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc ExampleNewPolybius() {\\n\\t// initialize\\n\\tconst (\\n\\t\\tplainText  = \\\"HogeFugaPiyoSpam\\\"\\n\\t\\tsize       = 5\\n\\t\\tcharacters = \\\"HogeF\\\"\\n\\t\\tkey        = \\\"abcdefghijklmnopqrstuvwxy\\\"\\n\\t)\\n\\tp, err := NewPolybius(key, size, characters)\\n\\tif err != nil {\\n\\t\\tlog.Fatalf(\\\"failed NewPolybius: %v\\\", err)\\n\\t}\\n\\tencryptedText, err := p.Encrypt(plainText)\\n\\tif err != nil {\\n\\t\\tlog.Fatalf(\\\"failed Encrypt: %v\\\", err)\\n\\t}\\n\\tfmt.Printf(\\\"Encrypt=> plainText: %s, encryptedText: %s\\\\n\\\", plainText, encryptedText)\\n\\n\\tdecryptedText, err := p.Decrypt(encryptedText)\\n\\tif err != nil {\\n\\t\\tlog.Fatalf(\\\"failed Decrypt: %v\\\", err)\\n\\t}\\n\\tfmt.Printf(\\\"Decrypt=> encryptedText: %s, decryptedText: %s\\\\n\\\", encryptedText, decryptedText)\\n\\n\\t// Output:\\n\\t// Encrypt=> plainText: HogeFugaPiyoSpam, encryptedText: OGGFOOHFOHFHOOHHEHOEFFGFEEEHHHGG\\n\\t// Decrypt=> encryptedText: OGGFOOHFOHFHOOHHEHOEFFGFEEEHHHGG, decryptedText: HOGEFUGAPIYOSPAM\\n}\\n\\nfunc TestNewPolybius(t *testing.T) {\\n\\tt.Parallel()\\n\\tcases := []struct {\\n\\t\\tname       string\\n\\t\\tsize       int\\n\\t\\tcharacters string\\n\\t\\tkey        string\\n\\t\\twantErr    string\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname: \\\"correct initialization\\\", size: 5, characters: \\\"HogeF\\\", key: \\\"abcdefghijklmnopqrstuvwxy\\\", wantErr: \\\"\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname: \\\"truncate characters\\\", size: 5, characters: \\\"HogeFuga\\\", key: \\\"abcdefghijklmnopqrstuvwxy\\\", wantErr: \\\"\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname: \\\"invalid key\\\", size: 5, characters: \\\"HogeFuga\\\", key: \\\"abcdefghi\\\", wantErr: \\\"len(key): 9 must be as long as size squared: 25\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname: \\\"invalid characters\\\", size: 5, characters: \\\"HogeH\\\", key: \\\"abcdefghijklmnopqrstuvwxy\\\", wantErr: \\\"\\\\\\\"chars\\\\\\\" contains same character: H\\\",\\n\\t\\t},\\n\\t}\\n\\n\\tfor _, tc := range cases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\t_, err := NewPolybius(tc.key, tc.size, tc.characters)\\n\\t\\t\\tif err != nil && err.Error() != tc.wantErr {\\n\\t\\t\\t\\tt.Errorf(\\\"failed NewPolybius: %v\\\", err)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestPolybiusEncrypt(t *testing.T) {\\n\\tt.Parallel()\\n\\tcases := []struct {\\n\\t\\tname string\\n\\t\\ttext string\\n\\t\\twant string\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname: \\\"correct encryption\\\", text: \\\"HogeFugaPiyoSpam\\\", want: \\\"OGGFOOHFOHFHOOHHEHOEFFGFEEEHHHGG\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname: \\\"invalid encryption\\\", text: \\\"hogz\\\", want: \\\"failed encipher: Z does not exist in keys\\\",\\n\\t\\t},\\n\\t}\\n\\t// initialize\\n\\tconst (\\n\\t\\tsize       = 5\\n\\t\\tcharacters = \\\"HogeF\\\"\\n\\t\\tkey        = \\\"abcdefghijklmnopqrstuvwxy\\\"\\n\\t)\\n\\tp, err := NewPolybius(key, size, characters)\\n\\tif err != nil {\\n\\t\\tt.Fatalf(\\\"failed NewPolybius: %v\\\", err)\\n\\t}\\n\\tfor _, tc := range cases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tencrypted, err := p.Encrypt(tc.text)\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tif err.Error() != tc.want {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"failed Encrypt: %v\\\", err)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if encrypted != tc.want {\\n\\t\\t\\t\\tt.Errorf(\\\"Encrypt: %v, want: %v\\\", encrypted, tc.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestPolybiusDecrypt(t *testing.T) {\\n\\tt.Parallel()\\n\\tcases := []struct {\\n\\t\\tname string\\n\\t\\ttext string\\n\\t\\twant string\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname: \\\"correct decryption\\\", text: \\\"OGGFOOHFOHFHOOHHEHOEFFGFEEEHHHGG\\\", want: \\\"HOGEFUGAPIYOSPAM\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname: \\\"invalid decryption(position of even number)\\\", text: \\\"hogz\\\", want: \\\"failed decipher: Z does not exist in characters\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname: \\\"invalid decryption(position of odd number)\\\", text: \\\"hode\\\", want: \\\"failed decipher: D does not exist in characters\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname: \\\"invalid text size which is odd\\\", text: \\\"hog\\\", want: \\\"failed decipher: the size of \\\\\\\"chars\\\\\\\" must be even\\\",\\n\\t\\t},\\n\\t}\\n\\t// initialize\\n\\tconst (\\n\\t\\tsize       = 5\\n\\t\\tcharacters = \\\"HogeF\\\"\\n\\t\\tkey        = \\\"abcdefghijklmnopqrstuvwxy\\\"\\n\\t)\\n\\tp, err := NewPolybius(key, size, characters)\\n\\tif err != nil {\\n\\t\\tt.Fatalf(\\\"failed NewPolybius: %v\\\", err)\\n\\t}\\n\\tfor _, tc := range cases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tencrypted, err := p.Decrypt(tc.text)\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tif err.Error() != tc.want {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"failed Encrypt: %v\\\", err)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if encrypted != tc.want {\\n\\t\\t\\t\\tt.Errorf(\\\"Encrypt: %v, want: %v\\\", encrypted, tc.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "rot13": "\"// Package rot13 is a simple letter substitution cipher that replaces a letter with the 13th letter after it in the alphabet.\\n// ref: https://en.wikipedia.org/wiki/ROT13\\npackage rot13\\n\\nimport (\\n\\t\\\"github.com/TheAlgorithms/Go/cipher/caesar\\\"\\n)\\n\\n// rot13 is a special case, which is fixed the shift of 13, of the Caesar cipher\\nfunc rot13(input string) string {\\n\\treturn caesar.Encrypt(input, 13)\\n}\\n\"",
    "rot13 test": "\"package rot13\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nvar rot13TestData = []struct {\\n\\tdescription string\\n\\tinput       string\\n\\texpected    string\\n}{\\n\\t{\\n\\t\\t\\\"Basic rotation with letter 'a' gives 'n\\\",\\n\\t\\t\\\"a\\\",\\n\\t\\t\\\"n\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Rotation with wrapping around alphabet on letter 'z' gives 'm'\\\",\\n\\t\\t\\\"z\\\",\\n\\t\\t\\\"m\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Rotation on 'hello world'\\\",\\n\\t\\t\\\"hello world\\\",\\n\\t\\t\\\"uryyb jbeyq\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Rotation on the rotation of 'hello world' gives 'hello world' back\\\",\\n\\t\\t\\\"uryyb jbeyq\\\",\\n\\t\\t\\\"hello world\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Full sentence rotation\\\",\\n\\t\\t\\\"the quick brown fox jumps over the lazy dog.\\\",\\n\\t\\t\\\"gur dhvpx oebja sbk whzcf bire gur ynml qbt.\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Sentence from Rot13.go main function\\\",\\n\\t\\t\\\"we'll just make him an offer he can't refuse... tell me you get the pop culture reference\\\",\\n\\t\\t\\\"jr'yy whfg znxr uvz na bssre ur pna'g ershfr... gryy zr lbh trg gur cbc phygher ersrerapr\\\",\\n\\t},\\n}\\n\\nfunc TestRot13Encrypt(t *testing.T) {\\n\\tfor _, test := range rot13TestData {\\n\\t\\tt.Run(test.description, func(t *testing.T) {\\n\\t\\t\\tinput := test.input\\n\\t\\t\\texpected := test.expected\\n\\t\\t\\tassertRot13Output(t, input, expected)\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestRot13Decrypt(t *testing.T) {\\n\\tfor _, test := range rot13TestData {\\n\\t\\tt.Run(test.description, func(t *testing.T) {\\n\\t\\t\\tinput := test.expected\\n\\t\\t\\texpected := test.input\\n\\t\\t\\tassertRot13Output(t, input, expected)\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc assertRot13Output(t *testing.T, input, expected string) {\\n\\tactual := rot13(input)\\n\\tif actual != expected {\\n\\t\\tt.Fatalf(\\\"With input string '%s' was expecting '%s' but actual was '%s'\\\",\\n\\t\\t\\tinput, expected, actual)\\n\\t}\\n}\\n\"",
    "rsa": "\"// rsa.go\\n// description: Simple RSA algorithm implementation\\n// details:\\n// A simple RSA Encryption and Decryption algorithm.\\n// It uses prime numbers that fit in int64 datatypes and\\n// thus both the Encrypt and Decrypt are not a production\\n// ready implementation. The OpenSSL implementation of RSA\\n// also adds a padding which is not present in this algorithm.\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see rsa_test.go\\n\\n// Package rsa shows a simple implementation of RSA algorithm\\npackage rsa\\n\\nimport (\\n\\t\\\"errors\\\"\\n\\n\\tmodular \\\"github.com/TheAlgorithms/Go/math/modular\\\"\\n)\\n\\n// ErrorFailedToEncrypt Raised when Encrypt function fails to encrypt the message\\nvar ErrorFailedToEncrypt = errors.New(\\\"failed to Encrypt\\\")\\n\\n// ErrorFailedToDecrypt Raised when Decrypt function fails to decrypt the encrypted message\\nvar ErrorFailedToDecrypt = errors.New(\\\"failed to Decrypt\\\")\\n\\n// Encrypt encrypts based on the RSA algorithm - uses modular exponentitation in math directory\\nfunc Encrypt(message []rune, publicExponent, modulus int64) ([]rune, error) {\\n\\tvar encrypted []rune\\n\\n\\tfor _, letter := range message {\\n\\t\\tencryptedLetter, err := modular.Exponentiation(int64(letter), publicExponent, modulus)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, ErrorFailedToEncrypt\\n\\t\\t}\\n\\t\\tencrypted = append(encrypted, rune(encryptedLetter))\\n\\t}\\n\\n\\treturn encrypted, nil\\n}\\n\\n// Decrypt decrypts encrypted rune slice based on the RSA algorithm\\nfunc Decrypt(encrypted []rune, privateExponent, modulus int64) (string, error) {\\n\\tvar decrypted []rune\\n\\n\\tfor _, letter := range encrypted {\\n\\t\\tdecryptedLetter, err := modular.Exponentiation(int64(letter), privateExponent, modulus)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn \\\"\\\", ErrorFailedToDecrypt\\n\\t\\t}\\n\\t\\tdecrypted = append(decrypted, rune(decryptedLetter))\\n\\t}\\n\\treturn string(decrypted), nil\\n}\\n\"",
    "rsa test": "\"// rsa_test.go\\n// description: Test for RSA Encrypt and Decrypt algorithms\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see rsa.go\\n\\npackage rsa\\n\\nimport (\\n\\t\\\"testing\\\"\\n\\n\\t\\\"github.com/TheAlgorithms/Go/math/gcd\\\"\\n\\t\\\"github.com/TheAlgorithms/Go/math/lcm\\\"\\n\\t\\\"github.com/TheAlgorithms/Go/math/modular\\\"\\n)\\n\\nvar rsaTestData = []struct {\\n\\tdescription string\\n\\tinput       string\\n}{\\n\\t{\\n\\t\\t\\\"Encrypt letter 'a'\\\",\\n\\t\\t\\\"a\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Encrypt 'hello world'\\\",\\n\\t\\t\\\"hello world\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Encrypt full sentence\\\",\\n\\t\\t\\\"the quick brown fox jumps over the lazy dog.\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Encrypt full sentence from rsacipher.go main function\\\",\\n\\t\\t\\\"I think RSA is really great\\\",\\n\\t},\\n}\\n\\nfunc TestEncryptDecrypt(t *testing.T) {\\n\\t// Both prime numbers\\n\\tp := int64(61)\\n\\tq := int64(53)\\n\\n\\tn := p * q\\n\\n\\tdelta := lcm.Lcm(p-1, q-1)\\n\\n\\te := int64(17) // Coprime with delta\\n\\n\\tif gcd.Recursive(e, delta) != 1 {\\n\\t\\tt.Fatal(\\\"Algorithm failed in preamble stage:\\\\n\\\\tPrime numbers are chosen statically and it shouldn't fail at this stage\\\")\\n\\t}\\n\\n\\td, err := modular.Inverse(e, delta)\\n\\n\\tif err != nil {\\n\\t\\tt.Fatalf(\\\"Algorithm failed in preamble stage:\\\\n\\\\tProblem with a modular directory dependency: %v\\\", err)\\n\\t}\\n\\n\\tfor _, test := range rsaTestData {\\n\\t\\tt.Run(test.description, func(t *testing.T) {\\n\\n\\t\\t\\tmessage := []rune(test.input)\\n\\t\\t\\tencrypted, err := Encrypt(message, e, n)\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tt.Fatalf(\\\"Failed to Encrypt test string:\\\\n\\\\tDescription: %v\\\\n\\\\tErrMessage: %v\\\", test.description, err)\\n\\t\\t\\t}\\n\\n\\t\\t\\tdecrypted, err := Decrypt(encrypted, d, n)\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tt.Fatalf(\\\"Failed to Decrypt test message:\\\\n\\\\tDescription: %v\\\\n\\\\tErrMessage: %v\\\", test.description, err)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif actual := test.input; actual != decrypted {\\n\\t\\t\\t\\tt.Logf(\\\"FAIL: %s\\\", test.description)\\n\\t\\t\\t\\tt.Fatalf(\\\"Expecting %v, actual %v\\\", decrypted, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "transposition": "\"// transposition.go\\n// description: Transposition cipher\\n// details:\\n// Implementation \\\"Transposition cipher\\\" is a method of encryption by which the positions held by units of plaintext (which are commonly characters or groups of characters) are shifted according to a regular system, so that the ciphertext constitutes a permutation of the plaintext [Transposition cipher](https://en.wikipedia.org/wiki/Transposition_cipher)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see transposition_test.go\\n\\npackage transposition\\n\\nimport (\\n\\t\\\"sort\\\"\\n\\t\\\"strings\\\"\\n)\\n\\ntype NoTextToEncryptError struct{}\\ntype KeyMissingError struct{}\\n\\nfunc (n *NoTextToEncryptError) Error() string {\\n\\treturn \\\"No text to encrypt\\\"\\n}\\nfunc (n *KeyMissingError) Error() string {\\n\\treturn \\\"Missing Key\\\"\\n}\\n\\nfunc getKey(keyWord string) []int {\\n\\tkeyWord = strings.ToLower(keyWord)\\n\\tword := []rune(keyWord)\\n\\tvar sortedWord = make([]rune, len(word))\\n\\tcopy(sortedWord, word)\\n\\tsort.Slice(sortedWord, func(i, j int) bool { return sortedWord[i] < sortedWord[j] })\\n\\tusedLettersMap := make(map[rune]int)\\n\\twordLength := len(word)\\n\\tresultKey := make([]int, wordLength)\\n\\tfor i := 0; i < wordLength; i++ {\\n\\t\\tchar := word[i]\\n\\t\\tnumberOfUsage := usedLettersMap[char]\\n\\t\\tresultKey[i] = getIndex(sortedWord, char) + numberOfUsage + 1 //+1 -so that indexing does not start at 0\\n\\t\\tnumberOfUsage++\\n\\t\\tusedLettersMap[char] = numberOfUsage\\n\\t}\\n\\treturn resultKey\\n}\\n\\nfunc getIndex(wordSet []rune, subString rune) int {\\n\\tn := len(wordSet)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif wordSet[i] == subString {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc Encrypt(text []rune, keyWord string) (string, error) {\\n\\tkey := getKey(keyWord)\\n\\tspace := ' '\\n\\tkeyLength := len(key)\\n\\ttextLength := len(text)\\n\\tif keyLength <= 0 {\\n\\t\\treturn \\\"\\\", &KeyMissingError{}\\n\\t}\\n\\tif textLength <= 0 {\\n\\t\\treturn \\\"\\\", &NoTextToEncryptError{}\\n\\t}\\n\\tn := textLength % keyLength\\n\\n\\tfor i := 0; i < keyLength-n; i++ {\\n\\t\\ttext = append(text, space)\\n\\t}\\n\\ttextLength = len(text)\\n\\tresult := \\\"\\\"\\n\\tfor i := 0; i < textLength; i += keyLength {\\n\\t\\ttransposition := make([]rune, keyLength)\\n\\t\\tfor j := 0; j < keyLength; j++ {\\n\\t\\t\\ttransposition[key[j]-1] = text[i+j]\\n\\t\\t}\\n\\t\\tresult += string(transposition)\\n\\t}\\n\\treturn result, nil\\n}\\n\\nfunc Decrypt(text []rune, keyWord string) (string, error) {\\n\\tkey := getKey(keyWord)\\n\\ttextLength := len(text)\\n\\tif textLength <= 0 {\\n\\t\\treturn \\\"\\\", &NoTextToEncryptError{}\\n\\t}\\n\\tkeyLength := len(key)\\n\\tif keyLength <= 0 {\\n\\t\\treturn \\\"\\\", &KeyMissingError{}\\n\\t}\\n\\tspace := ' '\\n\\tn := textLength % keyLength\\n\\tfor i := 0; i < keyLength-n; i++ {\\n\\t\\ttext = append(text, space)\\n\\t}\\n\\tresult := \\\"\\\"\\n\\tfor i := 0; i < textLength; i += keyLength {\\n\\t\\ttransposition := make([]rune, keyLength)\\n\\t\\tfor j := 0; j < keyLength; j++ {\\n\\t\\t\\ttransposition[j] = text[i+key[j]-1]\\n\\t\\t}\\n\\t\\tresult += string(transposition)\\n\\t}\\n\\treturn result, nil\\n}\\n\"",
    "transposition test": "\"// transposition_test.go\\n// description: Transposition cipher\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see transposition.go\\n\\npackage transposition\\n\\nimport (\\n\\t\\\"errors\\\"\\n\\t\\\"math/rand\\\"\\n\\t\\\"strings\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nconst enAlphabet = \\\"abcdefghijklmnopqrstuvwxyz \\\"\\n\\nfunc getTexts() []string {\\n\\treturn []string{\\n\\t\\t\\\"Ilya Sokolov\\\",\\n\\t\\t\\\"A slice literal is declared just like an array literal, except you leave out the element count\\\",\\n\\t\\t\\\"Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.\\\",\\n\\t\\t\\\"Go’s treatment of errors as values has served us well over the last decade. Although the standard library’s support for errors has been minimal—just the errors.New and fmt.Errorf functions, which produce errors that contain only a message—the built-in error interface allows Go programmers to add whatever information they desire. All it requires is a type that implements an Error method:\\\",\\n\\t\\t\\\"А тут для примера русский текст\\\",\\n\\t}\\n}\\n\\nfunc getRandomString() string {\\n\\tenRunes := []rune(enAlphabet)\\n\\tb := make([]rune, rand.Intn(100))\\n\\tfor i := range b {\\n\\t\\tb[i] = enRunes[rand.Intn(len(enRunes))]\\n\\t}\\n\\treturn string(b)\\n}\\n\\nfunc TestEncrypt(t *testing.T) {\\n\\tfn := func(text string, keyWord string) (bool, error) {\\n\\t\\tencrypt, err := Encrypt([]rune(text), keyWord)\\n\\t\\tif err != nil && !errors.Is(err, &NoTextToEncryptError{}) && !errors.Is(err, &KeyMissingError{}) {\\n\\t\\t\\tt.Error(\\\"Unexpected error \\\", err)\\n\\t\\t}\\n\\t\\treturn text == encrypt, err\\n\\t}\\n\\tfor _, s := range getTexts() {\\n\\t\\tif check, err := fn(s, getRandomString()); check || err != nil {\\n\\t\\t\\tt.Error(\\\"String \\\", s, \\\" not encrypted\\\")\\n\\t\\t}\\n\\t}\\n\\tif _, err := fn(getRandomString(), \\\"\\\"); err == nil {\\n\\t\\tt.Error(\\\"Error! empty string encryption\\\")\\n\\t}\\n}\\n\\nfunc TestDecrypt(t *testing.T) {\\n\\tfor _, s := range getTexts() {\\n\\t\\tkeyWord := getRandomString()\\n\\t\\tencrypt, errEncrypt := Encrypt([]rune(s), keyWord)\\n\\t\\tif errEncrypt != nil &&\\n\\t\\t\\t!errors.Is(errEncrypt, &NoTextToEncryptError{}) &&\\n\\t\\t\\t!errors.Is(errEncrypt, &KeyMissingError{}) {\\n\\t\\t\\tt.Error(\\\"Unexpected error \\\", errEncrypt)\\n\\t\\t}\\n\\t\\tif errEncrypt != nil {\\n\\t\\t\\tt.Error(errEncrypt)\\n\\t\\t}\\n\\t\\tdecrypt, errDecrypt := Decrypt([]rune(encrypt), keyWord)\\n\\t\\tif errDecrypt != nil &&\\n\\t\\t\\t!errors.Is(errDecrypt, &NoTextToEncryptError{}) &&\\n\\t\\t\\t!errors.Is(errDecrypt, &KeyMissingError{}) {\\n\\t\\t\\tt.Error(\\\"Unexpected error \\\", errDecrypt)\\n\\t\\t}\\n\\t\\tif errDecrypt != nil {\\n\\t\\t\\tt.Error(errDecrypt)\\n\\t\\t}\\n\\t\\tif encrypt == decrypt {\\n\\t\\t\\tt.Error(\\\"String \\\", s, \\\" not encrypted\\\")\\n\\t\\t}\\n\\t\\tif encrypt == s {\\n\\t\\t\\tt.Error(\\\"String \\\", s, \\\" not encrypted\\\")\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc TestEncryptDecrypt(t *testing.T) {\\n\\ttext := \\\"Test text for checking the algorithm\\\"\\n\\tkey1 := \\\"testKey\\\"\\n\\tkey2 := \\\"Test Key2\\\"\\n\\tencrypt, errEncrypt := Encrypt([]rune(text), key1)\\n\\tif errEncrypt != nil {\\n\\t\\tt.Error(errEncrypt)\\n\\t}\\n\\tdecrypt, errDecrypt := Decrypt([]rune(encrypt), key1)\\n\\tif errDecrypt != nil {\\n\\t\\tt.Error(errDecrypt)\\n\\t}\\n\\tif strings.Contains(decrypt, text) == false {\\n\\t\\tt.Error(\\\"The string was not decrypted correctly\\\")\\n\\t}\\n\\tdecrypt, _ = Decrypt([]rune(encrypt), key2)\\n\\tif strings.Contains(decrypt, text) == true {\\n\\t\\tt.Error(\\\"The string was decrypted with a different key\\\")\\n\\t}\\n}\\n\"",
    "xor": "\"// Package xor is an encryption algorithm that operates the exclusive disjunction(XOR)\\n// ref: https://en.wikipedia.org/wiki/XOR_cipher\\npackage xor\\n\\n// Encrypt encrypts with Xor encryption after converting each character to byte\\n// The returned value might not be readable because there is no guarantee\\n// which is within the ASCII range\\n// If using other type such as string, []int, or some other types,\\n// add the statements for converting the type to []byte.\\nfunc Encrypt(key byte, plaintext []byte) []byte {\\n\\tcipherText := []byte{}\\n\\tfor _, ch := range plaintext {\\n\\t\\tcipherText = append(cipherText, key^ch)\\n\\t}\\n\\treturn cipherText\\n}\\n\\n// Decrypt decrypts with Xor encryption\\nfunc Decrypt(key byte, cipherText []byte) []byte {\\n\\tplainText := []byte{}\\n\\tfor _, ch := range cipherText {\\n\\t\\tplainText = append(plainText, key^ch)\\n\\t}\\n\\treturn plainText\\n}\\n\"",
    "xor test": "\"package xor\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc Example() {\\n\\tconst (\\n\\t\\tseed = \\\"Hello World\\\"\\n\\t\\tkey  = 97\\n\\t)\\n\\n\\tencrypted := Encrypt(byte(key), []byte(seed))\\n\\tfmt.Printf(\\\"Encrypt=> key: %d, seed: %s, encryptedText: %v\\\\n\\\", key, seed, encrypted)\\n\\n\\tdecrypted := Decrypt(byte(key), encrypted)\\n\\tfmt.Printf(\\\"Decrypt=> key: %d, encryptedText: %v, DecryptedText: %s\\\\n\\\", key, encrypted, string(decrypted))\\n\\n\\t// Output:\\n\\t// Encrypt=> key: 97, seed: Hello World, encryptedText: [41 4 13 13 14 65 54 14 19 13 5]\\n\\t// Decrypt=> key: 97, encryptedText: [41 4 13 13 14 65 54 14 19 13 5], DecryptedText: Hello World\\n}\\n\\nvar xorTestData = []struct {\\n\\tdescription string\\n\\tinput       string\\n\\tkey         int\\n\\tencrypted   string\\n}{\\n\\t{\\n\\t\\t\\\"Encrypt letter 'a' with key 0 makes no changes\\\",\\n\\t\\t\\\"a\\\",\\n\\t\\t0,\\n\\t\\t\\\"a\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Encrypt letter 'a' with key 1\\\",\\n\\t\\t\\\"a\\\",\\n\\t\\t1,\\n\\t\\t\\\"`\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Encrypt letter 'a' with key 10\\\",\\n\\t\\t\\\"a\\\",\\n\\t\\t10,\\n\\t\\t\\\"k\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Encrypt 'hello world' with key 0 makes no changes\\\",\\n\\t\\t\\\"hello world\\\",\\n\\t\\t0,\\n\\t\\t\\\"hello world\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Encrypt 'hello world' with key 1\\\",\\n\\t\\t\\\"hello world\\\",\\n\\t\\t1,\\n\\t\\t\\\"idmmn!vnsme\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Encrypt 'hello world' with key 10\\\",\\n\\t\\t\\\"hello world\\\",\\n\\t\\t10,\\n\\t\\t\\\"boffe*}exfn\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Encrypt full sentence with key 64\\\",\\n\\t\\t\\\"the quick brown fox jumps over the lazy dog.\\\",\\n\\t\\t64,\\n\\t\\t\\\"4(%`15)#+`\\\\\\\"2/7.`&/8`*5-03`/6%2`4(%`,!:9`$/'n\\\",\\n\\t},\\n\\t{\\n\\t\\t\\\"Encrypt a word with key 32 make the case swap\\\",\\n\\t\\t\\\"abcdefghijklmNOPQRSTUVWXYZ\\\",\\n\\t\\t32,\\n\\t\\t\\\"ABCDEFGHIJKLMnopqrstuvwxyz\\\",\\n\\t},\\n}\\n\\nfunc TestXorCipherEncrypt(t *testing.T) {\\n\\tfor _, test := range xorTestData {\\n\\t\\tt.Run(test.description, func(t *testing.T) {\\n\\t\\t\\tencrypted := Encrypt(byte(test.key), []byte(test.input))\\n\\t\\t\\tif !reflect.DeepEqual(string(encrypted), test.encrypted) {\\n\\t\\t\\t\\tt.Logf(\\\"FAIL: %s\\\", test.description)\\n\\t\\t\\t\\tt.Fatalf(\\\"Expecting %s, actual %s\\\", test.encrypted, string(encrypted))\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestXorCipherDecrypt(t *testing.T) {\\n\\tfor _, test := range xorTestData {\\n\\t\\tt.Run(test.description, func(t *testing.T) {\\n\\t\\t\\tdecrypted := Decrypt(byte(test.key), []byte(test.encrypted))\\n\\n\\t\\t\\tif !reflect.DeepEqual(string(decrypted), test.input) {\\n\\t\\t\\t\\tt.Logf(\\\"FAIL: %s\\\", test.description)\\n\\t\\t\\t\\tt.Fatalf(\\\"Expecting %s, actual %s\\\", test.input, string(decrypted))\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "backtracking": "\"// This file contains the graph coloring implementation using backtracking\\n// Author(s): [Shivam](https://github.com/Shivam010)\\n\\npackage coloring\\n\\n// ColorUsingBacktracking will return the Color of each vertex and the\\n// total number of different colors used, using backtracking\\nfunc (g *Graph) ColorUsingBacktracking() (map[int]Color, int) {\\n\\tvertexColors := make(map[int]Color, g.vertices)\\n\\tg.colorVertex(0, vertexColors)\\n\\n\\tcolorsUsed := 0\\n\\tfor _, cr := range vertexColors {\\n\\t\\tif colorsUsed < int(cr) {\\n\\t\\t\\tcolorsUsed = int(cr)\\n\\t\\t}\\n\\t}\\n\\treturn vertexColors, colorsUsed\\n}\\n\\n// colorVertex will try to color provided vertex, v\\nfunc (g *Graph) colorVertex(v int, color map[int]Color) bool {\\n\\t// If all vertices are colored, the colors store will be completely filled.\\n\\tif len(color) == g.vertices {\\n\\t\\treturn true\\n\\t}\\n\\n\\t// As the upper bound of no. of colors is the no. of vertices in graph,\\n\\t// try assigning each color to the vertex v\\n\\tfor cr := Color(1); cr <= Color(g.vertices); cr++ {\\n\\t\\t// Use the color, cr for vertex, v if it is safe to use, by\\n\\t\\t// checking its neighbours\\n\\t\\tsafe := true\\n\\t\\tfor nb := range g.edges[v] {\\n\\t\\t\\t// cr, color is not safe if color of nb, crnb is not equal to cr\\n\\t\\t\\tif crnb, ok := color[nb]; ok && crnb == cr {\\n\\t\\t\\t\\tsafe = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif safe {\\n\\t\\t\\tcolor[v] = cr\\n\\t\\t\\tif g.colorVertex(v+1, color) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\tdelete(color, v)\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\"",
    "backtracking test": "\"// This file provides tests for coloring using backtracking.\\n// Author(s): [Shivam](https://github.com/Shivam010)\\n\\npackage coloring_test\\n\\nimport (\\n\\t\\\"strconv\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestGraphColorUsingBacktracking(t *testing.T) {\\n\\tfor i, tt := range getTestGraphs() {\\n\\t\\tt.Run(strconv.Itoa(i), func(t *testing.T) {\\n\\t\\t\\tcolorsOfVertices, colors := tt.Graph.ColorUsingBacktracking()\\n\\t\\t\\tif colors != tt.ColorsUsed {\\n\\t\\t\\t\\tt.Errorf(\\\"ColorUsingBacktracking() return more number of colors: %v, want %v colors\\\", colors, tt.ColorsUsed)\\n\\t\\t\\t}\\n\\t\\t\\t// check colors\\n\\t\\t\\tif err := tt.Graph.ValidateColorsOfVertex(colorsOfVertices); err != nil {\\n\\t\\t\\t\\tt.Errorf(\\\"ColorUsingBacktracking() assigned colors are wrong, error = %v\\\", err)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "bfs": "\"// This file contains the graph coloring implementation using BFS\\n// Author(s): [Shivam](https://github.com/Shivam010)\\n\\npackage coloring\\n\\nimport \\\"container/list\\\"\\n\\n// ColorUsingBFS will return the Color of each vertex and the\\n// total number of different colors used, using BFS\\nfunc (g *Graph) ColorUsingBFS() (map[int]Color, int) {\\n\\t// Initially all vertices will have same color\\n\\tvertexColors := make(map[int]Color, g.vertices)\\n\\tfor i := 0; i < g.vertices; i++ {\\n\\t\\tvertexColors[i] = 1\\n\\t}\\n\\n\\tvisited := make(map[int]struct{})\\n\\t// Run BFS from each non-visited vertex\\n\\tfor i := 0; i < g.vertices; i++ {\\n\\t\\tif _, ok := visited[i]; ok {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tvisited[i] = struct{}{}\\n\\n\\t\\tqueue := list.New()\\n\\t\\tqueue.PushBack(i)\\n\\n\\t\\tfor queue.Len() != 0 {\\n\\t\\t\\t// front vertex in the queue\\n\\t\\t\\tfrontNode := queue.Front()\\n\\t\\t\\tfront := frontNode.Value.(int)\\n\\t\\t\\tqueue.Remove(frontNode)\\n\\n\\t\\t\\t// Now, check all neighbours of front vertex, if they have same\\n\\t\\t\\t// color as that of front, change their color\\n\\t\\t\\tfor nb := range g.edges[front] {\\n\\t\\t\\t\\tif vertexColors[nb] == vertexColors[front] {\\n\\t\\t\\t\\t\\tvertexColors[nb]++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if the neighbour is not already visited, add it to the queue\\n\\t\\t\\t\\tif _, ok := visited[nb]; !ok {\\n\\t\\t\\t\\t\\tvisited[nb] = struct{}{}\\n\\t\\t\\t\\t\\tqueue.PushBack(nb)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tcolorsUsed := 0\\n\\tfor _, cr := range vertexColors {\\n\\t\\tif colorsUsed < int(cr) {\\n\\t\\t\\tcolorsUsed = int(cr)\\n\\t\\t}\\n\\t}\\n\\treturn vertexColors, colorsUsed\\n}\\n\"",
    "bfs test": "\"// This file provides tests for coloring using BFS.\\n// Author(s): [Shivam](https://github.com/Shivam010)\\n\\npackage coloring_test\\n\\nimport (\\n\\t\\\"strconv\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestGraphColorUsingBFS(t *testing.T) {\\n\\tfor i, tt := range getTestGraphs() {\\n\\t\\tt.Run(strconv.Itoa(i), func(t *testing.T) {\\n\\t\\t\\tcolorsOfVertices, colors := tt.Graph.ColorUsingBFS()\\n\\t\\t\\tif colors != tt.ColorsUsed {\\n\\t\\t\\t\\tt.Errorf(\\\"ColorUsingBFS() return more number of colors: %v, want %v colors\\\", colors, tt.ColorsUsed)\\n\\t\\t\\t}\\n\\t\\t\\t// check colors\\n\\t\\t\\tif err := tt.Graph.ValidateColorsOfVertex(colorsOfVertices); err != nil {\\n\\t\\t\\t\\tt.Errorf(\\\"ColorUsingBFS() assigned colors are wrong, error = %v\\\", err)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "bipartite": "\"package coloring\\n\\nfunc (g *Graph) TryBipartiteColoring() map[int]Color {\\n\\t// 0 is uncolored, 1/2 is colors\\n\\tcolors := make(map[int]Color)\\n\\tvisited := make(map[int]bool)\\n\\n\\tfor i := range g.edges {\\n\\t\\tcolors[i] = 0\\n\\t\\tvisited[i] = false\\n\\t}\\n\\n\\tvar color_node func(int)\\n\\tcolor_node = func(s int) {\\n\\t\\tvisited[s] = true\\n\\t\\tcoloring := []Color{0, 2, 1}\\n\\n\\t\\tfor n := range g.edges[s] {\\n\\t\\t\\tif colors[n] == 0 {\\n\\t\\t\\t\\tcolors[n] = coloring[colors[s]]\\n\\t\\t\\t}\\n\\t\\t\\tif !visited[n] {\\n\\t\\t\\t\\tcolor_node(n)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := range g.edges {\\n\\t\\tif colors[i] == 0 {\\n\\t\\t\\tcolors[i] = 1\\n\\t\\t\\tcolor_node(i)\\n\\t\\t}\\n\\t}\\n\\n\\treturn colors\\n}\\n\\n// basically tries to color the graph in two colors if each edge\\n// connects 2 differently colored nodes the graph can be considered bipartite\\nfunc BipartiteCheck(N int, edges [][]int) bool {\\n\\tvar graph Graph\\n\\tfor i := 0; i < N; i++ {\\n\\t\\tgraph.AddVertex(i)\\n\\t}\\n\\tfor _, e := range edges {\\n\\t\\tgraph.AddEdge(e[0], e[1])\\n\\t}\\n\\treturn graph.ValidateColorsOfVertex(graph.TryBipartiteColoring()) == nil\\n}\\n\"",
    "bipartite test": "\"package coloring\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nvar testCases = []struct {\\n\\tname        string\\n\\tN           int\\n\\tisBipartite bool\\n\\tedges       [][]int\\n}{\\n\\t{\\n\\t\\t\\\"basic true\\\", 2, true,\\n\\t\\t[][]int{{1, 0}},\\n\\t},\\n\\t{\\n\\t\\t\\\"basic false\\\", 3, false,\\n\\t\\t[][]int{{0, 1}, {1, 2}, {2, 0}},\\n\\t},\\n}\\n\\nfunc TestBipartite(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := BipartiteCheck(tc.N, tc.edges)\\n\\t\\t\\tif tc.isBipartite != actual {\\n\\t\\t\\t\\tt.Errorf(\\\"failed %s: %v\\\", tc.name, tc.edges)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "greedy": "\"// This file contains the graph coloring implementation using Greedy Approach.\\n// Author(s): [Shivam](https://github.com/Shivam010)\\n\\npackage coloring\\n\\nimport \\\"sort\\\"\\n\\n// ColorUsingGreedyApproach will return the Color of each vertex and the\\n// total number of different colors used, using a greedy approach, based on\\n// the number of edges (or degree) from any vertex.\\nfunc (g *Graph) ColorUsingGreedyApproach() (map[int]Color, int) {\\n\\tdegreeOfVertex := make([]struct{ degree, vertex int }, 0, g.vertices)\\n\\tfor v, neighbours := range g.edges {\\n\\t\\tdegreeOfVertex = append(degreeOfVertex,\\n\\t\\t\\tstruct{ degree, vertex int }{\\n\\t\\t\\t\\tvertex: v,\\n\\t\\t\\t\\tdegree: len(neighbours),\\n\\t\\t\\t},\\n\\t\\t)\\n\\t}\\n\\t// sort the degreeOfVertex in decreasing order of degrees\\n\\tsort.Slice(degreeOfVertex, func(i, j int) bool {\\n\\t\\treturn degreeOfVertex[i].degree > degreeOfVertex[j].degree\\n\\t})\\n\\n\\tvertexColors := make(map[int]Color, g.vertices)\\n\\t// Start with a color and assign the color to all possible vertices in the degreeOfVertex slice\\n\\t// and then, re-iterate with new color for all those which are left\\n\\tfor color := 1; color <= g.vertices; color++ {\\n\\tvertexLoop:\\n\\t\\tfor _, val := range degreeOfVertex {\\n\\t\\t\\t// skip, if already assigned\\n\\t\\t\\tif _, ok := vertexColors[val.vertex]; ok {\\n\\t\\t\\t\\tcontinue vertexLoop\\n\\t\\t\\t}\\n\\t\\t\\t// Check its neighbours\\n\\t\\t\\tfor ng := range g.edges[val.vertex] {\\n\\t\\t\\t\\tif vertexColors[ng] == Color(color) {\\n\\t\\t\\t\\t\\t// not possible to use this color for val.vertex\\n\\t\\t\\t\\t\\tcontinue vertexLoop\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Assign color to the vertex\\n\\t\\t\\tvertexColors[val.vertex] = Color(color)\\n\\t\\t}\\n\\t\\t// continue till all the vertices are colored\\n\\t\\tif len(vertexColors) == g.vertices {\\n\\t\\t\\treturn vertexColors, color\\n\\t\\t}\\n\\t}\\n\\treturn vertexColors, g.vertices\\n}\\n\"",
    "graph": "\"// This file contains the simple structural implementation of undirected\\n// graph, used in coloring algorithms.\\n// Author(s): [Shivam](https://github.com/Shivam010)\\n\\npackage coloring\\n\\nimport \\\"errors\\\"\\n\\n// Color provides a type for vertex color\\ntype Color int\\n\\n// Graph provides a structure to store an undirected graph.\\n// It is safe to use its empty object.\\ntype Graph struct {\\n\\tvertices int\\n\\tedges    map[int]map[int]struct{}\\n}\\n\\n// AddVertex will add a new vertex in the graph, if the vertex already\\n// exist it will do nothing\\nfunc (g *Graph) AddVertex(v int) {\\n\\tif g.edges == nil {\\n\\t\\tg.edges = make(map[int]map[int]struct{})\\n\\t}\\n\\n\\t// Check if vertex is present or not\\n\\tif _, ok := g.edges[v]; !ok {\\n\\t\\tg.vertices++\\n\\t\\tg.edges[v] = make(map[int]struct{})\\n\\t}\\n}\\n\\n// AddEdge will add a new edge between the provided vertices in the graph\\nfunc (g *Graph) AddEdge(one, two int) {\\n\\t// Add vertices: one and two to the graph if they are not present\\n\\tg.AddVertex(one)\\n\\tg.AddVertex(two)\\n\\n\\t// and finally add the edges: one->two and two->one for undirected graph\\n\\tg.edges[one][two] = struct{}{}\\n\\tg.edges[two][one] = struct{}{}\\n}\\n\\nfunc (g *Graph) ValidateColorsOfVertex(colors map[int]Color) error {\\n\\tif g.vertices != len(colors) {\\n\\t\\treturn errors.New(\\\"coloring: not all vertices of graph are colored\\\")\\n\\t}\\n\\t// check colors\\n\\tfor vertex, neighbours := range g.edges {\\n\\t\\tfor nb := range neighbours {\\n\\t\\t\\tif colors[vertex] == colors[nb] {\\n\\t\\t\\t\\treturn errors.New(\\\"coloring: same colors of neighbouring vertex\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n\"",
    "greedy test": "\"// This file provides tests for coloring using Greedy approach.\\n// Author(s): [Shivam](https://github.com/Shivam010)\\n\\npackage coloring_test\\n\\nimport (\\n\\t\\\"strconv\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestGraphColorUsingGreedyApproach(t *testing.T) {\\n\\tfor i, tt := range getTestGraphs() {\\n\\t\\tt.Run(strconv.Itoa(i), func(t *testing.T) {\\n\\t\\t\\tcolorsOfVertices, colors := tt.Graph.ColorUsingGreedyApproach()\\n\\t\\t\\tif colors != tt.ColorsUsed {\\n\\t\\t\\t\\tt.Errorf(\\\"ColorUsingGreedyApproach() return more number of colors: %v, want %v colors\\\", colors, tt.ColorsUsed)\\n\\t\\t\\t}\\n\\t\\t\\t// check colors\\n\\t\\t\\tif err := tt.Graph.ValidateColorsOfVertex(colorsOfVertices); err != nil {\\n\\t\\t\\t\\tt.Errorf(\\\"ColorUsingGreedyApproach() assigned colors are wrong, error = %v\\\", err)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "sha256": "\"// sha256.go\\n// description: The sha256 cryptographic hash function as defined in the RFC6234 standard.\\n// author: [Paul Leydier] (https://github.com/paul-leydier)\\n// ref: https://datatracker.ietf.org/doc/html/rfc6234\\n// ref: https://en.wikipedia.org/wiki/SHA-2\\n// see sha256_test.go\\n\\npackage sha256\\n\\nimport (\\n\\t\\\"encoding/binary\\\" // Used for interacting with uint at the byte level\\n\\t\\\"math/bits\\\"       // Used for bits rotation operations\\n)\\n\\nvar K = [64]uint32{\\n\\t0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\\n\\t0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\\n\\t0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\\n\\t0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\\n\\t0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\\n\\t0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\\n\\t0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\\n\\t0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\\n}\\n\\nconst chunkSize = 64\\n\\n// pad returns a padded version of the input message, such as the padded message's length is a multiple\\n// of 512 bits.\\n// The padding methodology is as follows:\\n// A \\\"1\\\" bit is appended at the end of the input message, followed by m \\\"0\\\" bits such as the length is\\n// 64 bits short of a 512 bits multiple. The remaining 64 bits are filled with the initial length of the\\n// message, represented as a 64-bits unsigned integer.\\n// For more details, see: https://datatracker.ietf.org/doc/html/rfc6234#section-4.1\\nfunc pad(message []byte) []byte {\\n\\tL := make([]byte, 8)\\n\\tbinary.BigEndian.PutUint64(L, uint64(len(message)*8))\\n\\tmessage = append(message, 0x80) // \\\"1\\\" bit followed by 7 \\\"0\\\" bits\\n\\tfor (len(message)+8)%64 != 0 {\\n\\t\\tmessage = append(message, 0x00) // 8 \\\"0\\\" bits\\n\\t}\\n\\tmessage = append(message, L...)\\n\\n\\treturn message\\n}\\n\\n// Hash hashes the input message using the sha256 hashing function, and return a 32 byte array.\\n// The implementation follows the RGC6234 standard, which is documented\\n// at https://datatracker.ietf.org/doc/html/rfc6234\\nfunc Hash(message []byte) [32]byte {\\n\\tmessage = pad(message)\\n\\n\\t// Initialize round constants\\n\\th0, h1, h2, h3, h4, h5, h6, h7 := uint32(0x6a09e667), uint32(0xbb67ae85), uint32(0x3c6ef372), uint32(0xa54ff53a),\\n\\t\\tuint32(0x510e527f), uint32(0x9b05688c), uint32(0x1f83d9ab), uint32(0x5be0cd19)\\n\\n\\t// Iterate through 512-bit chunks\\n\\tfor chunkStart := 0; chunkStart < len(message); chunkStart += chunkSize {\\n\\t\\t// Message schedule\\n\\t\\tvar w [64]uint32\\n\\t\\tfor i := 0; i*4 < chunkSize; i++ {\\n\\t\\t\\tw[i] = binary.BigEndian.Uint32(message[chunkStart+i*4 : chunkStart+(i+1)*4])\\n\\t\\t}\\n\\n\\t\\t// Extend the 16 bytes chunk to the whole 64 bytes message schedule\\n\\t\\tfor i := 16; i < 64; i++ {\\n\\t\\t\\ts0 := bits.RotateLeft32(w[i-15], -7) ^ bits.RotateLeft32(w[i-15], -18) ^ (w[i-15] >> 3)\\n\\t\\t\\ts1 := bits.RotateLeft32(w[i-2], -17) ^ bits.RotateLeft32(w[i-2], -19) ^ (w[i-2] >> 10)\\n\\t\\t\\tw[i] = w[i-16] + s0 + w[i-7] + s1\\n\\t\\t}\\n\\n\\t\\t// Actual hashing loop\\n\\t\\ta, b, c, d, e, f, g, h := h0, h1, h2, h3, h4, h5, h6, h7\\n\\t\\tfor i := 0; i < 64; i++ {\\n\\t\\t\\tS1 := bits.RotateLeft32(e, -6) ^ bits.RotateLeft32(e, -11) ^ bits.RotateLeft32(e, -25)\\n\\t\\t\\tch := (e & f) ^ ((^e) & g)\\n\\t\\t\\ttmp1 := h + S1 + ch + K[i] + w[i]\\n\\t\\t\\tS0 := bits.RotateLeft32(a, -2) ^ bits.RotateLeft32(a, -13) ^ bits.RotateLeft32(a, -22)\\n\\t\\t\\tmaj := (a & b) ^ (a & c) ^ (b & c)\\n\\t\\t\\ttmp2 := S0 + maj\\n\\t\\t\\th = g\\n\\t\\t\\tg = f\\n\\t\\t\\tf = e\\n\\t\\t\\te = d + tmp1\\n\\t\\t\\td = c\\n\\t\\t\\tc = b\\n\\t\\t\\tb = a\\n\\t\\t\\ta = tmp1 + tmp2\\n\\t\\t}\\n\\t\\th0 += a\\n\\t\\th1 += b\\n\\t\\th2 += c\\n\\t\\th3 += d\\n\\t\\th4 += e\\n\\t\\th5 += f\\n\\t\\th6 += g\\n\\t\\th7 += h\\n\\t}\\n\\n\\t// Export digest\\n\\tdigest := [32]byte{}\\n\\tbinary.BigEndian.PutUint32(digest[:4], h0)\\n\\tbinary.BigEndian.PutUint32(digest[4:8], h1)\\n\\tbinary.BigEndian.PutUint32(digest[8:12], h2)\\n\\tbinary.BigEndian.PutUint32(digest[12:16], h3)\\n\\tbinary.BigEndian.PutUint32(digest[16:20], h4)\\n\\tbinary.BigEndian.PutUint32(digest[20:24], h5)\\n\\tbinary.BigEndian.PutUint32(digest[24:28], h6)\\n\\tbinary.BigEndian.PutUint32(digest[28:], h7)\\n\\n\\treturn digest\\n}\\n\"",
    "sha256 test": "\"package sha256\\n\\nimport (\\n\\t\\\"encoding/hex\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestHash(t *testing.T) {\\n\\ttestCases := []struct {\\n\\t\\tin       string\\n\\t\\texpected string\\n\\t}{\\n\\t\\t{\\\"hello world\\\", \\\"b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\\\"},\\n\\t\\t{\\\"\\\", \\\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\\\"},\\n\\t\\t{\\\"a\\\", \\\"ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb\\\"},\\n\\t\\t{\\\"The quick brown fox jumps over the lazy dog\\\", \\\"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\\\"},\\n\\t\\t{\\\"The quick brown fox jumps over the lazy dog.\\\", \\\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\\\"},\\n\\t\\t{\\\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\\", \\\"2d8c2f6d978ca21712b5f6de36c9d31fa8e96a4fa5d8ff8b0188dfb9e7c171bb\\\"},\\n\\t}\\n\\tfor _, tc := range testCases {\\n\\t\\tres := Hash([]byte(tc.in))\\n\\t\\tresult := hex.EncodeToString(res[:])\\n\\t\\tif result != tc.expected {\\n\\t\\t\\tt.Fatalf(\\\"Hash(%s) = %s, expected %s\\\", tc.in, result, tc.expected)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkHash(b *testing.B) {\\n\\ttestCases := []struct {\\n\\t\\tname string\\n\\t\\tin   string\\n\\t}{\\n\\t\\t{\\\"hello world\\\", \\\"hello world\\\"},\\n\\t\\t{\\\"empty\\\", \\\"\\\"},\\n\\t\\t{\\\"a\\\", \\\"a\\\"},\\n\\t\\t{\\\"The quick brown fox jumps over the lazy dog\\\", \\\"The quick brown fox jumps over the lazy dog\\\"},\\n\\t\\t{\\\"The quick brown fox jumps over the lazy dog.\\\", \\\"The quick brown fox jumps over the lazy dog.\\\"},\\n\\t\\t{\\\"Lorem ipsum\\\", \\\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\\"},\\n\\t}\\n\\tfor _, testCase := range testCases {\\n\\t\\tb.Run(testCase.name, func(b *testing.B) {\\n\\t\\t\\tfor i := 0; i < b.N; i++ {\\n\\t\\t\\t\\tHash([]byte(testCase.in))\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "armstrong": "\"// isarmstrong.go\\n// description: Checks if the given number is armstrong number or not\\n// details: An Armstrong number is a n-digit number that is equal to the sum of each of its digits taken to the nth power.\\n// ref: https://mathlair.allfunandgames.ca/armstrong.php\\n// author: Kavitha J\\n\\npackage armstrong\\n\\nimport (\\n\\t\\\"math\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc IsArmstrong(number int) bool {\\n\\tvar rightMost int\\n\\tvar sum int = 0\\n\\tvar tempNum int = number\\n\\n\\t// to get the number of digits in the number\\n\\tlength := float64(len(strconv.Itoa(number)))\\n\\n\\t// get the right most digit and break the loop once all digits are iterated\\n\\tfor tempNum > 0 {\\n\\t\\trightMost = tempNum % 10\\n\\t\\tsum += int(math.Pow(float64(rightMost), length))\\n\\n\\t\\t// update the input digit minus the processed rightMost\\n\\t\\ttempNum /= 10\\n\\t}\\n\\n\\treturn number == sum\\n}\\n\"",
    "isarmstrong test": "\"// isarmstrong_test.go\\n\\npackage armstrong\\n\\nimport \\\"testing\\\"\\n\\nvar testCases = []struct {\\n\\tname     string // test description\\n\\tinput    int    // user input\\n\\texpected bool   // expected return\\n}{\\n\\t{\\n\\t\\t\\\"negative number: Not an armstrong number\\\",\\n\\t\\t-140,\\n\\t\\tfalse,\\n\\t},\\n\\t{\\n\\t\\t\\\"positive number: Not an armstrong number\\\",\\n\\t\\t23,\\n\\t\\tfalse,\\n\\t},\\n\\t{\\n\\t\\t\\\"smallest armstrong number\\\",\\n\\t\\t0,\\n\\t\\ttrue,\\n\\t},\\n\\t{\\n\\t\\t\\\"smallest armstrong number with more than one digit\\\",\\n\\t\\t153,\\n\\t\\ttrue,\\n\\t},\\n\\t{\\n\\t\\t\\\"random armstrong number\\\",\\n\\t\\t407,\\n\\t\\ttrue,\\n\\t},\\n\\t{\\n\\t\\t\\\"random armstrong number\\\",\\n\\t\\t9474,\\n\\t\\ttrue,\\n\\t},\\n}\\n\\nfunc TestIsArmstrong(t *testing.T) {\\n\\tfor _, test := range testCases {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tfuncResult := IsArmstrong(test.input)\\n\\t\\t\\tif test.expected != funcResult {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected answer '%t' for the number '%d' but answer given was %t\\\", test.expected, test.input, funcResult)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "arithmetic mean": "\"// arithmeticmean.go\\n// description: Arithmetic mean\\n// details:\\n// The most common type of average is the arithmetic mean. If n numbers are given, each number denoted by ai (where i = 1,2, ..., n), the arithmetic mean is the sum of the as divided by n or - [Arithmetic mean](https://en.wikipedia.org/wiki/Average#Arithmetic_mean)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see arithmeticmean_test.go\\n\\n// Package binary describes algorithms that use binary operations for different calculations.\\npackage binary\\n\\n// MeanUsingAndXor This function finds arithmetic mean using \\\"AND\\\" and \\\"XOR\\\" operations\\nfunc MeanUsingAndXor(a int, b int) int {\\n\\treturn ((a ^ b) >> 1) + (a & b)\\n}\\n\\n// MeanUsingRightShift This function finds arithmetic mean using right shift\\nfunc MeanUsingRightShift(a int, b int) int {\\n\\treturn (a + b) >> 1\\n}\\n\"",
    "arithmeticmean test": "\"// arithmeticmean_test.go\\n// description: Test for Arithmetic mean\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see arithmeticmean.go\\n\\npackage binary\\n\\nimport \\\"testing\\\"\\n\\nfunc TestMeanUsingAndXor(t *testing.T) {\\n\\ttests := getTests()\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := MeanUsingAndXor(tv.a, tv.b)\\n\\t\\t\\tif result != tv.result {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%d, returned:%d \\\", tv.result, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n\\n}\\n\\nfunc TestMeanUsingRightShift(t *testing.T) {\\n\\ttests := getTests()\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := MeanUsingRightShift(tv.a, tv.b)\\n\\t\\t\\tif result != tv.result {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%d, returned:%d \\\", tv.result, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n\\n}\\nfunc getTests() []struct {\\n\\tname   string\\n\\ta      int\\n\\tb      int\\n\\tresult int\\n} {\\n\\tvar tests = []struct {\\n\\t\\tname   string\\n\\t\\ta      int\\n\\t\\tb      int\\n\\t\\tresult int\\n\\t}{\\n\\t\\t{\\\"Average of 2 and 4\\\", 2, 4, 3},\\n\\t\\t{\\\"Average of 5 and 5\\\", 5, 5, 5},\\n\\t\\t{\\\"Average of 1000 and 1002\\\", 1000, 1002, 1001},\\n\\t\\t{\\\"Average of 80 and 40\\\", 80, 40, 60},\\n\\t\\t{\\\"Average of 7 and 4\\\", 7, 4, 5},\\n\\t}\\n\\treturn tests\\n}\\nfunc BenchmarkMeanUsingAndXor(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tMeanUsingAndXor(222, 888)\\n\\t}\\n}\\n\\nfunc BenchmarkMeanUsingRightShift(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tMeanUsingRightShift(222, 888)\\n\\t}\\n}\\n\"",
    "bit counter": "\"// bitcounter.go\\n// description: Counts the number of set bits in a number\\n// details:\\n// For unsigned integer number N, return the number of bits set to 1 - [Bit numbering](https://en.wikipedia.org/wiki/Bit_numbering)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see bitcounter_test.go\\n\\npackage binary\\n\\n// BitCounter - The function returns the number of set bits for an unsigned integer number\\nfunc BitCounter(n uint) int {\\n\\tcounter := 0\\n\\tfor n != 0 {\\n\\t\\tif n&1 == 1 {\\n\\t\\t\\tcounter++\\n\\t\\t}\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn counter\\n}\\n\"",
    "bit counter test": "\"// bitcounter_test.go\\n// description: Test for counts the number of set bits in a number\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see bitcounter.go\\n\\npackage binary\\n\\nimport \\\"testing\\\"\\n\\nfunc TestBitCounter(t *testing.T) {\\n\\ttests := []struct {\\n\\t\\tname   string\\n\\t\\tnumber uint\\n\\t\\twant   int\\n\\t}{\\n\\t\\t{\\\"Number of bits in a number 0\\\", 0, 0},\\n\\t\\t{\\\"Number of bits in a number 1\\\", 1, 1},\\n\\t\\t{\\\"Number of bits in a number 255\\\", 255, 8},\\n\\t\\t{\\\"Number of bits in a number 7\\\", 7, 3},\\n\\t\\t{\\\"Number of bits in a number 8\\\", 8, 1},\\n\\t\\t{\\\"Number of bits in a number 9223372036854775807\\\", 9223372036854775807, 63},\\n\\t\\t{\\\"Number of bits in a number 2147483647\\\", 2147483647, 31},\\n\\t\\t{\\\"Number of bits in a number 15\\\", 15, 4},\\n\\t\\t{\\\"Number of bits in a number 16\\\", 16, 1},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tif got := BitCounter(test.number); got != test.want {\\n\\t\\t\\t\\tt.Errorf(\\\"BitCounter() = %v, want %v\\\", got, test.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "check is number power of two": "\"// checkisnumberpoweroftwo.go\\n// description: Is the number a power of two\\n// details:\\n// Checks if a number is a power of two- [Power of two](https://en.wikipedia.org/wiki/Power_of_two)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see checkisnumberpoweroftwo_test.go\\n\\npackage binary\\n\\n// IsPowerOfTwo This function uses the fact that powers of 2 are represented\\n// like 10...0 in binary, and numbers one less than the power of 2\\n// are represented like 11...1.\\n// Therefore, using the and function:\\n//    10...0\\n//  & 01...1\\n//    00...0 -> 0\\n// This is also true for 0, which is not a power of 2, for which we\\n// have to add and extra condition.\\nfunc IsPowerOfTwo(x int) bool {\\n\\treturn x > 0 && (x&(x-1)) == 0\\n}\\n\\n// IsPowerOfTwoLeftShift This function takes advantage of the fact that left shifting a number\\n// by 1 is equivalent to multiplying by 2. For example, binary 00000001 when shifted by 3 becomes 00001000,\\n// which in decimal system is 8 or = 2 * 2 * 2\\nfunc IsPowerOfTwoLeftShift(number uint) bool {\\n\\tif number == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tfor p := uint(1); p > 0; p = p << 1 {\\n\\t\\tif number == p {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\"",
    "check is number power of two test": "\"// checkisnumberpoweroftwo_test.go\\n// description: Test for Is the number a power of two\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see checkisnumberpoweroftwo.go\\n\\npackage binary\\n\\nimport (\\n\\tmath2 \\\"github.com/TheAlgorithms/Go/math\\\"\\n\\t\\\"math\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc getTestsForPowerOfTwo() []struct {\\n\\tname    string\\n\\ta       int\\n\\tmissing bool\\n} {\\n\\tvar tests = []struct {\\n\\t\\tname    string\\n\\t\\ta       int\\n\\t\\tmissing bool\\n\\t}{\\n\\t\\t{\\\"Is 64 a power of 2? - YES\\\", 64, true},\\n\\t\\t{\\\"Is 1 a power of 2? - YES\\\", 1, true},\\n\\t\\t{\\\"Is 2 a power of 2? - YES\\\", 2, true},\\n\\t\\t{\\\"Is 5 a power of 2? - NO\\\", 5, false},\\n\\t\\t{\\\"Is 1023 a power of 2? - NO\\\", 1023, false},\\n\\t\\t{\\\"Is 1024 a power of 2? - YES\\\", 1024, true},\\n\\t\\t{\\\"Is 0 a power of 2? - NO\\\", 0, false},\\n\\t\\t{\\\"Is 9223372036854775807 a power of 2? - NO\\\", math.MaxInt64, false},\\n\\t\\t{\\\"Is 9223372036854775806 a power of 2? - NO\\\", math.MaxInt64, false},\\n\\t\\t{\\\"Is 4611686018427387904 a power of 2? - YES\\\", 4611686018427387904, true},\\n\\t}\\n\\treturn tests\\n}\\n\\nfunc TestIsPowerOfTwo(t *testing.T) {\\n\\ttests := getTestsForPowerOfTwo()\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := IsPowerOfTwo(tv.a)\\n\\t\\t\\tt.Log(tv.a, \\\" \\\", result)\\n\\t\\t\\tif result != tv.missing {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%v, returned:%v \\\", tv.missing, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestIsPowerOfTwoLeftShift(t *testing.T) {\\n\\ttests := getTestsForPowerOfTwo()\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := IsPowerOfTwoLeftShift(uint(tv.a))\\n\\t\\t\\tt.Log(tv.a, \\\" \\\", result)\\n\\t\\t\\tif result != tv.missing {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%v, returned:%v \\\", tv.missing, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestIsPowOfTwoUseLog(t *testing.T) {\\n\\ttests := getTestsForPowerOfTwo()\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := math2.IsPowOfTwoUseLog(float64(tv.a))\\n\\t\\t\\tt.Log(tv.a, \\\" \\\", result)\\n\\t\\t\\tif result != tv.missing {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%v, returned:%v \\\", tv.missing, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkIsPowerOfTwoBinaryMethod(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tIsPowerOfTwo(1024)\\n\\t}\\n}\\n\\nfunc BenchmarkIsPowerOfTwoUseCycleAndLeftShift(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tIsPowerOfTwoLeftShift(1024)\\n\\t}\\n}\\n\\nfunc BenchmarkIsPowerOfTwoUseLog(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tmath2.IsPowOfTwoUseLog(1024)\\n\\t}\\n}\\n\"",
    "rbc": "\"// rbc.go\\n// description: Reflected binary code (RBC)\\n// details:\\n// The reflected binary code (RBC), also known just as reflected binary (RB) or Gray code after Frank Gray, is an ordering of the binary numeral system such that two successive values differ in only one bit (binary digit). - [RBC](https://en.wikipedia.org/wiki/Gray_code)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see rbc_test.go\\n\\npackage binary\\n\\n// SequenceGrayCode The function generates an \\\"Gray code\\\" sequence of length n\\nfunc SequenceGrayCode(n uint) []uint {\\n\\tresult := make([]uint, 0)\\n\\tvar i uint\\n\\tfor i = 0; i < 1<<n; i++ {\\n\\t\\tresult = append(result, i^(i>>1))\\n\\t}\\n\\treturn result\\n}\\n\"",
    "rbc test": "\"// rbc_test.go\\n// description: Test for Reflected binary code\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see rbc.go\\n\\npackage binary\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestSequenceGrayCode(t *testing.T) {\\n\\ttests := []struct {\\n\\t\\tname string\\n\\t\\tn    uint\\n\\t\\twant []uint\\n\\t}{\\n\\t\\t{\\\"Sequence of values for 1\\\", 1, []uint{0, 1}},\\n\\t\\t{\\\"Sequence of values for 2\\\", 2, []uint{0, 1, 3, 2}},\\n\\t\\t{\\\"Sequence of values for 6\\\", 6, []uint{0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8, 24, 25, 27, 26, 30, 31, 29, 28, 20, 21, 23, 22, 18, 19, 17, 16, 48, 49, 51, 50, 54, 55, 53, 52, 60, 61, 63, 62, 58, 59, 57, 56, 40, 41, 43, 42, 46, 47, 45, 44, 36, 37, 39, 38, 34, 35, 33, 32}},\\n\\t\\t{\\\"Sequence of values for 8\\\", 8, []uint{0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8, 24, 25, 27, 26, 30, 31, 29, 28, 20, 21, 23, 22, 18, 19, 17, 16, 48, 49, 51, 50, 54, 55, 53, 52, 60, 61, 63, 62, 58, 59, 57, 56, 40, 41, 43, 42, 46, 47, 45, 44, 36, 37, 39, 38, 34, 35, 33, 32, 96, 97, 99, 98, 102, 103, 101, 100, 108, 109, 111, 110, 106, 107, 105, 104, 120, 121, 123, 122, 126, 127, 125, 124, 116, 117, 119, 118, 114, 115, 113, 112, 80, 81, 83, 82, 86, 87, 85, 84, 92, 93, 95, 94, 90, 91, 89, 88, 72, 73, 75, 74, 78, 79, 77, 76, 68, 69, 71, 70, 66, 67, 65, 64, 192, 193, 195, 194, 198, 199, 197, 196, 204, 205, 207, 206, 202, 203, 201, 200, 216, 217, 219, 218, 222, 223, 221, 220, 212, 213, 215, 214, 210, 211, 209, 208, 240, 241, 243, 242, 246, 247, 245, 244, 252, 253, 255, 254, 250, 251, 249, 248, 232, 233, 235, 234, 238, 239, 237, 236, 228, 229, 231, 230, 226, 227, 225, 224, 160, 161, 163, 162, 166, 167, 165, 164, 172, 173, 175, 174, 170, 171, 169, 168, 184, 185, 187, 186, 190, 191, 189, 188, 180, 181, 183, 182, 178, 179, 177, 176, 144, 145, 147, 146, 150, 151, 149, 148, 156, 157, 159, 158, 154, 155, 153, 152, 136, 137, 139, 138, 142, 143, 141, 140, 132, 133, 135, 134, 130, 131, 129, 128}},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tif got := SequenceGrayCode(test.n); !reflect.DeepEqual(got, test.want) {\\n\\t\\t\\t\\tt.Errorf(\\\"SequenceGrayCode() = %v, want %v\\\", got, test.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkSequenceGrayCode(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tSequenceGrayCode(6)\\n\\t}\\n}\\n\"",
    "reverse bits": "\"// reversebits.go\\n// description: Reverse bits\\n// details:\\n// Reverse the bits of an integer number\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see reversebits_test.go\\n\\npackage binary\\n\\n// ReverseBits This function initialized the result by 0 (all bits 0) and process the given number starting\\n// from its least significant bit. If the current bit is 1, set the corresponding most significant bit in the result\\n// and finally move on to the next bit in the input number.\\n// Repeat this till all its bits are processed.\\nfunc ReverseBits(number uint) uint {\\n\\tresult := uint(0)\\n\\tintSize := 31\\n\\tfor number != 0 {\\n\\t\\tresult += (number & 1) << intSize\\n\\t\\tnumber = number >> 1\\n\\t\\tintSize -= 1\\n\\t}\\n\\treturn result\\n}\\n\"",
    "reverse bits test": "\"// reversebits_test.go\\n// description: Reverse bits\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see reversebits.go\\n\\npackage binary\\n\\nimport \\\"testing\\\"\\n\\nfunc TestReverseBits(t *testing.T) {\\n\\tvar tests = []struct {\\n\\t\\tname   string\\n\\t\\tnumber uint\\n\\t\\tresult uint\\n\\t}{\\n\\t\\t{\\\"43261596 (00000010100101000001111010011100) to 964176192 (00111001011110000010100101000000)\\\", 43261596, 964176192},\\n\\t\\t{\\\"3758096384 (11100000000000000000000000000000) to 7 (00000000000000000000000000000111)\\\", 3758096384, 7},\\n\\t\\t{\\\"7 (00000000000000000000000000000111) to 3758096384 (11100000000000000000000000000000)\\\", 7, 3758096384},\\n\\t\\t{\\\"2684354560 (10100000000000000000000000000000) to 5 (00000000000000000000000000000101)\\\", 2684354560, 5},\\n\\t\\t{\\\"2684354561 (10100000000000000000000000000001) to 5 (10000000000000000000000000000101)\\\", 2684354561, 2147483653},\\n\\t}\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := ReverseBits(tv.number)\\n\\t\\t\\tt.Log(result)\\n\\t\\t\\tif result != tv.result {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%d, returned:%d \\\", tv.result, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkReverseBits(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tReverseBits(2684354560)\\n\\t}\\n}\\n\"",
    "xor search": "\"// xorsearch.go\\n// description: Find a missing number in a sequence\\n// details:\\n// Given an array A containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. - [xor](https://en.wikipedia.org/wiki/Exclusive_or)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see xorsearch_test.go\\n\\npackage binary\\n\\n// XorSearchMissingNumber This function finds a missing number in a sequence\\nfunc XorSearchMissingNumber(a []int) int {\\n\\tn := len(a)\\n\\tresult := len(a)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tresult ^= i ^ a[i]\\n\\t}\\n\\treturn result\\n}\\n\"",
    "xor search test": "\"// xorsearch_test.go\\n// description: Test for Find a missing number in a sequence\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see xorsearch.go\\n\\npackage binary\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestXorSearchMissingNumber(t *testing.T) {\\n\\tvar tests = []struct {\\n\\t\\tname    string\\n\\t\\ta       []int\\n\\t\\tmissing int\\n\\t}{\\n\\t\\t{\\\"[3, 0, 1]/2\\\", []int{3, 0, 1}, 2},\\n\\t\\t{\\\"[0, 1, 3, 4, 5, 6, 7]/2\\\", []int{0, 1, 3, 4, 5, 6, 7}, 2},\\n\\t\\t{\\\"[0, 2, 3, 4, 5, 6, 7, 8, 9]/1\\\", []int{0, 2, 3, 4, 5, 6, 7, 8, 9}, 1},\\n\\t\\t{\\\"[0, 10, 9, 7, 2, 1,  4, 3, 5, 6]/8\\\", []int{0, 10, 9, 7, 2, 1, 4, 3, 5, 6}, 8},\\n\\t}\\n\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := XorSearchMissingNumber(tv.a)\\n\\t\\t\\tif result != tv.missing {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%d, returned:%d \\\", tv.missing, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n\\n}\\n\\nfunc BenchmarkTestXorSearchMissingNumber(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tXorSearchMissingNumber([]int{0, 10, 9, 7, 2, 1, 4, 3, 5, 6})\\n\\t}\\n}\\n\"",
    "catalan number": "\"// catalannumber.go\\n// description: Returns the Catalan number\\n// details:\\n// In combinatorial mathematics, the Catalan numbers are a sequence of natural numbers that occur in various counting problems, often involving recursively defined objects. - [Catalan number](https://en.wikipedia.org/wiki/Catalan_number)\\n// The input is the number of the Catalan number n, at the output we get the value of the number\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see catalannumber_test.go\\n\\npackage catalan\\n\\nimport (\\n\\tf \\\"github.com/TheAlgorithms/Go/math/factorial\\\"\\n)\\n\\n// CatalanNumber This function returns the `nth` Catalan number\\nfunc CatalanNumber(n int) int {\\n\\treturn f.Iterative(n*2) / (f.Iterative(n) * f.Iterative(n+1))\\n}\\n\"",
    "catalan number test": "\"// catalannumber_test.go\\n// description: Test for returns the Catalan number\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see catalannumber.go\\n\\npackage catalan\\n\\nimport \\\"testing\\\"\\n\\nfunc TestCatalanNumber(t *testing.T) {\\n\\ttests := []struct {\\n\\t\\tname string\\n\\t\\tn    int\\n\\t\\twant int\\n\\t}{\\n\\t\\t{\\\"zero Catalan number \\\", 0, 1},\\n\\t\\t{\\\"second Catalan number \\\", 2, 2},\\n\\t\\t{\\\"third Catalan number \\\", 3, 5},\\n\\t\\t{\\\"fourth Catalan number \\\", 4, 14},\\n\\t\\t{\\\"fifth Catalan number \\\", 5, 42},\\n\\t\\t{\\\"sixth Catalan number \\\", 6, 132},\\n\\t\\t{\\\"tenth Catalan number \\\", 10, 16796},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tif got := CatalanNumber(test.n); got != test.want {\\n\\t\\t\\t\\tt.Errorf(\\\"CatalanNumber() = %v, want %v\\\", got, test.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkCatalanNumber(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tCatalanNumber(10)\\n\\t}\\n}\\n\"",
    "factorial": "\"// factorial.go\\n// description: Calculating factorial\\n// details:\\n// The factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n - [Factorial](https://en.wikipedia.org/wiki/Factorial)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see factorial_test.go\\n\\n// Package factorial describes algorithms Factorials calculations.\\npackage factorial\\n\\n// Iterative returns the iteratively brute forced factorial of n\\nfunc Iterative(n int) int {\\n\\tresult := 1\\n\\tfor i := 2; i <= n; i++ {\\n\\t\\tresult *= i\\n\\t}\\n\\treturn result\\n}\\n\\n// Recursive This function recursively computes the factorial of a number\\nfunc Recursive(n int) int {\\n\\tif n == 1 {\\n\\t\\treturn 1\\n\\t} else {\\n\\t\\treturn n * Recursive(n-1)\\n\\t}\\n}\\n\\n// UsingTree This function finds the factorial of a number using a binary tree\\nfunc UsingTree(n int) int {\\n\\tif n < 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tif n == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tif n == 1 || n == 2 {\\n\\t\\treturn n\\n\\t}\\n\\treturn prodTree(2, n)\\n}\\n\\nfunc prodTree(l int, r int) int {\\n\\tif l > r {\\n\\t\\treturn 1\\n\\t}\\n\\tif l == r {\\n\\t\\treturn l\\n\\t}\\n\\tif r-l == 1 {\\n\\t\\treturn l * r\\n\\t}\\n\\tm := (l + r) / 2\\n\\treturn prodTree(l, m) * prodTree(m+1, r)\\n}\\n\"",
    "factorial test": "\"// factorial_test.go\\n// description: Test for calculating factorial\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see factorial.go\\n\\npackage factorial\\n\\nimport \\\"testing\\\"\\n\\nfunc getTests() []struct {\\n\\tname   string\\n\\tn      int\\n\\tresult int\\n} {\\n\\tvar tests = []struct {\\n\\t\\tname   string\\n\\t\\tn      int\\n\\t\\tresult int\\n\\t}{\\n\\t\\t{\\\"5!\\\", 5, 120},\\n\\t\\t{\\\"3!\\\", 3, 6},\\n\\t\\t{\\\"6!\\\", 6, 720},\\n\\t\\t{\\\"12!\\\", 12, 479001600},\\n\\t\\t{\\\"1!\\\", 1, 1},\\n\\t}\\n\\treturn tests\\n}\\n\\nfunc TestBruteForceFactorial(t *testing.T) {\\n\\ttests := getTests()\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := Iterative(tv.n)\\n\\t\\t\\tif result != tv.result {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%d, returned:%d \\\", tv.result, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestRecursiveFactorial(t *testing.T) {\\n\\ttests := getTests()\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := Recursive(tv.n)\\n\\t\\t\\tif result != tv.result {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%d, returned:%d \\\", tv.result, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestCalculateFactorialUseTree(t *testing.T) {\\n\\ttests := getTests()\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.name, func(t *testing.T) {\\n\\t\\t\\tresult := UsingTree(tv.n)\\n\\t\\t\\tif result != tv.result {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%d, returned:%d \\\", tv.result, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkBruteForceFactorial(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tIterative(10)\\n\\t}\\n}\\n\\nfunc BenchmarkRecursiveFactorial(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tRecursive(10)\\n\\t}\\n}\\n\\nfunc BenchmarkCalculateFactorialUseTree(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tRecursive(10)\\n\\t}\\n}\\n\"",
    "extended": "\"// extended.go\\n// description: Implementation of Extended GCD Algorithm\\n// details:\\n// A simple implementation of Extended GCD algorithm, that returns GCD, a and b\\n// which solves ax + by = gcd(a, b)\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see extended_test.go\\n\\npackage gcd\\n\\n// Extended simple extended gcd\\nfunc Extended(a, b int64) (int64, int64, int64) {\\n\\tif a == 0 {\\n\\t\\treturn b, 0, 1\\n\\t}\\n\\tgcd, xPrime, yPrime := Extended(b%a, a)\\n\\treturn gcd, yPrime - (b/a)*xPrime, xPrime\\n}\\n\"",
    "extendedgcd": "\"package gcd\\n\\n// ExtendedRecursive finds and returns gcd(a, b), x, y satisfying a*x + b*y = gcd(a, b).\\nfunc ExtendedRecursive(a, b int64) (int64, int64, int64) {\\n\\tif b > 0 {\\n\\t\\td, y, x := ExtendedRecursive(b, a%b)\\n\\t\\ty -= (a / b) * x\\n\\t\\treturn d, x, y\\n\\t}\\n\\n\\treturn a, 1, 0\\n}\\n\"",
    "extended gcd iterative": "\"package gcd\\n\\n// ExtendedIterative finds and returns gcd(a, b), x, y satisfying a*x + b*y = gcd(a, b).\\nfunc ExtendedIterative(a, b int64) (int64, int64, int64) {\\n\\tvar u, y, v, x int64 = 1, 1, 0, 0\\n\\tfor a > 0 {\\n\\t\\tvar q int64 = b / a\\n\\t\\tx, u = u, x-q*u\\n\\t\\ty, v = v, y-q*v\\n\\t\\tb, a = a, b-q*a\\n\\t}\\n\\treturn b, x, y\\n}\\n\"",
    "extended gcd test": "\"package gcd\\n\\nimport \\\"testing\\\"\\n\\ntype testExtendedFunction func(int64, int64) (int64, int64, int64)\\n\\nfunc TemplateTestExtendedGCD(t *testing.T, f testExtendedFunction) {\\n\\tvar testCasesExtended = []struct {\\n\\t\\tname string\\n\\t\\ta    int64\\n\\t\\tb    int64\\n\\t\\tgcd  int64\\n\\t\\tx    int64\\n\\t\\ty    int64\\n\\t}{\\n\\t\\t{\\\"gcd of 10 and 0\\\", 10, 0, 10, 1, 0},\\n\\t\\t{\\\"gcd of 98 and 56\\\", 98, 56, 14, -1, 2},\\n\\t\\t{\\\"gcd of 0 and 10\\\", 0, 10, 10, 0, 1},\\n\\t}\\n\\tfor _, tc := range testCasesExtended {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactualGcd, actualX, actualY := f(tc.a, tc.b)\\n\\t\\t\\tif actualGcd != tc.gcd {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected GCD of %d and %d to be: %v, but got: %d\\\", tc.a, tc.b, tc.gcd, actualGcd)\\n\\t\\t\\t}\\n\\t\\t\\tif actualX != tc.x {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected x satisfying %d * x + %d * y = gcd to be: %v, but got: %d\\\", tc.a, tc.b, tc.x, actualX)\\n\\t\\t\\t}\\n\\t\\t\\tif actualY != tc.y {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected y satisfying %d * x + %d * y = gcd to be: %v, but got: %d\\\", tc.a, tc.b, tc.y, actualY)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestExtendedGCDRecursive(t *testing.T) {\\n\\tTemplateTestExtendedGCD(t, ExtendedRecursive)\\n}\\n\\nfunc TestExtendedGCDIterative(t *testing.T) {\\n\\tTemplateTestExtendedGCD(t, ExtendedIterative)\\n}\\n\\nfunc TemplateBenchmarkExtendedGCD(b *testing.B, f testExtendedFunction) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tf(98, 56)\\n\\t}\\n}\\n\\nfunc BenchmarkExtendedGCDRecursive(b *testing.B) {\\n\\tTemplateBenchmarkExtendedGCD(b, ExtendedRecursive)\\n}\\n\\nfunc BenchmarkExtendedGCDIterative(b *testing.B) {\\n\\tTemplateBenchmarkExtendedGCD(b, ExtendedIterative)\\n}\\n\"",
    "extended test": "\"// extended_test.go\\n// description: Test for Extended GCD algorithm in extended.go\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see extended.go\\n\\npackage gcd\\n\\nimport \\\"testing\\\"\\n\\nfunc TestExtended(t *testing.T) {\\n\\tvar testCasesExtended = []struct {\\n\\t\\tname string\\n\\t\\ta    int64\\n\\t\\tb    int64\\n\\t\\tgcd  int64\\n\\t\\tx    int64\\n\\t\\ty    int64\\n\\t}{\\n\\t\\t{\\\"gcd of 30 and 50\\\", 30, 50, 10, 2, -1},\\n\\t}\\n\\tfor _, tc := range testCasesExtended {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tgcd, x, y := Extended(tc.a, tc.b)\\n\\t\\t\\tif gcd != tc.gcd && x != tc.x && y != tc.y {\\n\\t\\t\\t\\tt.Fatalf(\\\"Expected values:\\\\n\\\\tGCD: Expected %v Returned %v,\\\\n\\\\tx: Expected %v Returned %v\\\\n\\\\ty: Expected %v Returned %v\\\", tc.gcd, gcd, tc.x, x, tc.y, y)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "gcd": "\"package gcd\\n\\n// Recursive finds and returns the greatest common divisor of a given integer.\\nfunc Recursive(a, b int64) int64 {\\n\\tif b == 0 {\\n\\t\\treturn a\\n\\t}\\n\\treturn Recursive(b, a%b)\\n}\\n\"",
    "gcd iterative": "\"package gcd\\n\\n// Iterative Faster iterative version of GcdRecursive without holding up too much of the stack\\nfunc Iterative(a, b int64) int64 {\\n\\tfor b != 0 {\\n\\t\\ta, b = b, a%b\\n\\t}\\n\\treturn a\\n}\\n\"",
    "gcd test": "\"package gcd\\n\\nimport \\\"testing\\\"\\n\\ntype testFunction func(int64, int64) int64\\n\\nvar testCases = []struct {\\n\\tname   string\\n\\ta      int64\\n\\tb      int64\\n\\toutput int64\\n}{\\n\\t{\\\"gcd of 10 and 0\\\", 10, 0, 10},\\n\\t{\\\"gcd of 98 and 56\\\", 98, 56, 14},\\n\\t{\\\"gcd of 0 and 10\\\", 0, 10, 10},\\n}\\n\\nfunc TemplateTestGCD(t *testing.T, f testFunction) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := f(tc.a, tc.b)\\n\\t\\t\\tif actual != tc.output {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected GCD of %d and %d to be: %v, but got: %d\\\", tc.a, tc.b, tc.output, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestGCDRecursive(t *testing.T) {\\n\\tTemplateTestGCD(t, Recursive)\\n}\\n\\nfunc TestGCDIterative(t *testing.T) {\\n\\tTemplateTestGCD(t, Iterative)\\n}\\n\\nfunc TemplateBenchmarkGCD(b *testing.B, f testFunction) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tf(98, 56)\\n\\t}\\n}\\n\\nfunc BenchmarkGCDRecursive(b *testing.B) {\\n\\tTemplateBenchmarkGCD(b, Recursive)\\n}\\n\\nfunc BenchmarkGCDIterative(b *testing.B) {\\n\\tTemplateBenchmarkGCD(b, Iterative)\\n}\\n\"",
    "straight lines": "\"package geometry\\n\\nimport (\\n\\t\\\"math\\\"\\n)\\n\\n// Defines a point with x and y coordinates.\\ntype Point struct {\\n\\tX, Y float64\\n}\\n\\ntype Line struct {\\n\\tP1, P2 Point\\n}\\n\\n// Calculates the shortest distance between two points.\\nfunc Distance(a, b *Point) float64 {\\n\\treturn math.Sqrt(math.Pow(a.X-b.X, 2) + math.Pow(a.Y-b.Y, 2))\\n}\\n\\n// Calculates the Point that divides a line in specific ratio.\\n// DO NOT specify the ratio in the form m:n, specify it as r, where r = m / n.\\nfunc Section(p1, p2 *Point, r float64) Point {\\n\\tvar point Point\\n\\tpoint.X = (r*p2.X + p1.X) / (r + 1)\\n\\tpoint.Y = (r*p2.Y + p1.Y) / (r + 1)\\n\\treturn point\\n}\\n\\n// Calculates the slope (gradient) of a line.\\nfunc Slope(l *Line) float64 {\\n\\treturn (l.P2.Y - l.P1.Y) / (l.P2.X - l.P1.X)\\n}\\n\\n// Calculates the Y-Intercept of a line from a specific Point.\\nfunc Intercept(p *Point, slope float64) float64 {\\n\\treturn p.Y - (slope * p.X)\\n}\\n\\n// Checks if two lines are parallel or not.\\nfunc IsParallel(l1, l2 *Line) bool {\\n\\treturn Slope(l1) == Slope(l2)\\n}\\n\\n// Checks if two lines are perpendicular or not.\\nfunc IsPerpendicular(l1, l2 *Line) bool {\\n\\treturn Slope(l1)*Slope(l2) == -1\\n}\\n\\n// Calculates the distance of a given Point from a given line.\\n// The slice should contain the coefficiet of x, the coefficient of y and the constant in the respective order.\\nfunc PointDistance(p *Point, equation [3]float64) float64 {\\n\\treturn math.Abs(equation[0]*p.X+equation[1]*p.Y+equation[2]) / math.Sqrt(math.Pow(equation[0], 2)+math.Pow(equation[1], 2))\\n}\\n\"",
    "straight lines test": "\"package geometry\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestDistance(t *testing.T) {\\n\\tp1 := Point{0, 0}\\n\\tp2 := Point{3, 4}\\n\\tvar wantedDistance float64 = 5\\n\\tvar calculatedDistance float64 = Distance(&p1, &p2)\\n\\tif calculatedDistance != wantedDistance {\\n\\t\\tt.Fatalf(\\\"Failed to calculate Distance.\\\")\\n\\t}\\n}\\n\\nfunc TestSection(t *testing.T) {\\n\\tp1 := Point{1, 0}\\n\\tp2 := Point{5, 0}\\n\\twantedPoint := Point{3, 0}\\n\\tcalculatedPoint := Section(&p1, &p2, 1)\\n\\tif calculatedPoint != wantedPoint {\\n\\t\\tt.Fatalf(\\\"Failed to calculate Section.\\\")\\n\\t}\\n}\\n\\nfunc TestSlope(t *testing.T) {\\n\\tline := Line{P1: Point{1, 2}, P2: Point{2, 4}}\\n\\tvar wantedSlope float64 = 2\\n\\tvar calculatedSlope float64 = Slope(&line)\\n\\tif calculatedSlope != wantedSlope {\\n\\t\\tt.Fatalf(\\\"Failed to calculate Slope.\\\")\\n\\t}\\n}\\n\\nfunc TestIntercept(t *testing.T) {\\n\\tp := Point{0, 3}\\n\\tvar slope float64 = -5\\n\\tvar wantedIntercept float64 = 3\\n\\tvar calculatedIntercept float64 = Intercept(&p, slope)\\n\\tif calculatedIntercept != wantedIntercept {\\n\\t\\tt.Fatalf(\\\"Failed to calculate Intercept.\\\")\\n\\t}\\n}\\n\\nfunc TestIsParallel(t *testing.T) {\\n\\tl1 := Line{P1: Point{1, 2}, P2: Point{2, 4}}\\n\\tl2 := Line{P1: Point{25, 50}, P2: Point{50, 100}}\\n\\tif !IsParallel(&l1, &l2) {\\n\\t\\tt.Fatalf(\\\"Failed to check if Parallel.\\\")\\n\\t}\\n}\\n\\nfunc TestIsPerpendicular(t *testing.T) {\\n\\tl1 := Line{P1: Point{1, 2}, P2: Point{2, 4}}\\n\\tl2 := Line{P1: Point{2, 2}, P2: Point{4, 1}}\\n\\tif !IsPerpendicular(&l1, &l2) {\\n\\t\\tt.Fatalf(\\\"Failed to check if Perpendicular.\\\")\\n\\t}\\n}\\n\\nfunc TestPointDistance(t *testing.T) {\\n\\tp := Point{1, 1}\\n\\tequation := [3]float64{4, 3, 1}\\n\\tvar wantedDistance float64 = 1.6\\n\\tvar calculatedDistance float64 = PointDistance(&p, equation)\\n\\tif calculatedDistance != wantedDistance {\\n\\t\\tt.Fatalf(\\\"Failed to calculate Point Distance.\\\")\\n\\t}\\n}\\n\"",
    "lcm": "\"package lcm\\n\\nimport (\\n\\t\\\"math\\\"\\n\\n\\t\\\"github.com/TheAlgorithms/Go/math/gcd\\\"\\n)\\n\\n// Lcm returns the lcm of two numbers using the fact that lcm(a,b) * gcd(a,b) = | a * b |\\nfunc Lcm(a, b int64) int64 {\\n\\treturn int64(math.Abs(float64(a*b)) / float64(gcd.Iterative(a, b)))\\n}\\n\"",
    "lcm test": "\"package lcm\\n\\nimport \\\"testing\\\"\\n\\nfunc TestLcm(t *testing.T) {\\n\\ttestCases := []struct {\\n\\t\\tname   string\\n\\t\\ta      int64\\n\\t\\tb      int64\\n\\t\\toutput int64\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname:   \\\"LCM of 1 & 5\\\",\\n\\t\\t\\ta:      1,\\n\\t\\t\\tb:      5,\\n\\t\\t\\toutput: 5,\\n\\t\\t}, {\\n\\t\\t\\tname:   \\\"LCM of 2 & 5\\\",\\n\\t\\t\\ta:      2,\\n\\t\\t\\tb:      5,\\n\\t\\t\\toutput: 10,\\n\\t\\t}, {\\n\\t\\t\\tname:   \\\"LCM of 5 & 10\\\",\\n\\t\\t\\ta:      10,\\n\\t\\t\\tb:      5,\\n\\t\\t\\toutput: 10,\\n\\t\\t}, {\\n\\t\\t\\tname:   \\\"LCM of 5 & 5\\\",\\n\\t\\t\\ta:      5,\\n\\t\\t\\tb:      5,\\n\\t\\t\\toutput: 5,\\n\\t\\t},\\n\\t}\\n\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual_output := Lcm(tc.a, tc.b)\\n\\t\\t\\tif actual_output != tc.output {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected LCM of %d and %d is %d, but got %d\\\", tc.a, tc.b, tc.output,\\n\\t\\t\\t\\t\\tactual_output)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "bitwise max": "\"// bitwiseMax.go\\n// description: Gives max of two integers\\n// details:\\n// implementation of finding the maximum of two numbers using only binary operations without using conditions\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see bitwiseMax_test.go\\n\\npackage max\\n\\n// Bitwise computes using bitwise operator the maximum of all the integer input and returns it\\nfunc Bitwise(a int, b int, base int) int {\\n\\tz := a - b\\n\\ti := (z >> base) & 1\\n\\treturn a - (i * z)\\n}\\n\"",
    "bitwise max test": "\"// bitwiseMax_test.go\\n// description: Test for Bitwise\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see bitwiseMax.go\\n\\npackage max\\n\\nimport \\\"testing\\\"\\n\\nfunc TestBitwiseMax(t *testing.T) {\\n\\tbase32 := 31\\n\\n\\tt.Run(\\\"Testing(32bit) a = 32 and m = 64: \\\", func(t *testing.T) {\\n\\t\\tmax := Bitwise(32, 64, base32)\\n\\t\\tif max != 64 {\\n\\t\\t\\tt.Fatalf(\\\"Error: Bitwise returned bad value\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Testing(32bit) a = 1024 and m = -9: \\\", func(t *testing.T) {\\n\\t\\tmax := Bitwise(1024, -9, base32)\\n\\t\\tif max != 1024 {\\n\\t\\t\\tt.Fatalf(\\\"Error: Bitwise returned bad value\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Testing(32bit) a = -6 and m = -6: \\\", func(t *testing.T) {\\n\\t\\tmax := Bitwise(-6, -6, base32)\\n\\t\\tif max != -6 {\\n\\t\\t\\tt.Fatalf(\\\"Error: Bitwise returned bad value\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Testing(32bit) a = -72 and m = -73: \\\", func(t *testing.T) {\\n\\t\\tmax := Bitwise(-72, -73, base32)\\n\\t\\tif max != -72 {\\n\\t\\t\\tt.Fatalf(\\\"Error: Bitwise returned bad value\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tbase64 := 63\\n\\tt.Run(\\\"Testing(64bit) a = 32 and m = 9223372036854775807: \\\", func(t *testing.T) {\\n\\t\\tmax := Bitwise(32, 9223372036854775807, base64)\\n\\t\\tif max != 9223372036854775807 {\\n\\t\\t\\tt.Fatalf(\\\"Error: Bitwise returned bad value\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Testing(64bit) a = 1024 and m = -9223372036854770001: \\\", func(t *testing.T) {\\n\\t\\tmax := Bitwise(1024, -9223372036854770001, base64)\\n\\t\\tif max != 1024 {\\n\\t\\t\\tt.Fatalf(\\\"Error: Bitwise returned bad value\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Testing(64bit) a = -6 and m = -6: \\\", func(t *testing.T) {\\n\\t\\tmax := Bitwise(-6, -6, base64)\\n\\t\\tif max != -6 {\\n\\t\\t\\tt.Fatalf(\\\"Error: Bitwise returned bad value\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Testing(64bit) a = -4223372036854775809 and m = -4223372036854775808: \\\", func(t *testing.T) {\\n\\t\\tmax := Bitwise(-4223372036854775809, -4223372036854775808, base64)\\n\\t\\tif max != -4223372036854775808 {\\n\\t\\t\\tt.Fatalf(\\\"Error: Bitwise returned bad value\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tbase8 := 7\\n\\tt.Run(\\\"Testing(8bit) a = 257 and m = 256: \\\", func(t *testing.T) {\\n\\t\\tmax := Bitwise(8, 16, base8)\\n\\t\\tif max != 16 {\\n\\t\\t\\tt.Fatalf(\\\"Error: Bitwise returned bad value\\\")\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "max": "\"package max\\n\\n// Int is a function which returns the maximum of all the integers provided as arguments.\\nfunc Int(values ...int) int {\\n\\tmax := values[0]\\n\\tfor _, value := range values {\\n\\t\\tif value > max {\\n\\t\\t\\tmax = value\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\"",
    "max test": "\"package max\\n\\nimport \\\"testing\\\"\\n\\nfunc TestMax(t *testing.T) {\\n\\ttestCases := []struct {\\n\\t\\tname  string\\n\\t\\tleft  int\\n\\t\\tright int\\n\\t\\tmax   int\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname:  \\\"Left is max\\\",\\n\\t\\t\\tleft:  10,\\n\\t\\t\\tright: 9,\\n\\t\\t\\tmax:   10,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname:  \\\"right is max\\\",\\n\\t\\t\\tleft:  1,\\n\\t\\t\\tright: 10,\\n\\t\\t\\tmax:   10,\\n\\t\\t},\\n\\t}\\n\\n\\tfor _, test := range testCases {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\treturnedMax := Int(test.left, test.right)\\n\\t\\t\\tif returnedMax != test.max {\\n\\t\\t\\t\\tt.Errorf(\\\"Failed test %s\\\\n\\\\tleft: %v, right: %v, max: %v but received: %v\\\",\\n\\t\\t\\t\\t\\ttest.name, test.left, test.right, test.max, returnedMax)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestMaxOfThree(t *testing.T) {\\n\\ttestCases := []struct {\\n\\t\\tname   string\\n\\t\\tleft   int\\n\\t\\tmiddle int\\n\\t\\tright  int\\n\\t\\tmax    int\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname:   \\\"right is max\\\",\\n\\t\\t\\tleft:   1,\\n\\t\\t\\tmiddle: 5,\\n\\t\\t\\tright:  10,\\n\\t\\t\\tmax:    10,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname:   \\\"left is max\\\",\\n\\t\\t\\tleft:   10,\\n\\t\\t\\tmiddle: 5,\\n\\t\\t\\tright:  9,\\n\\t\\t\\tmax:    10,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname:   \\\"left is max\\\",\\n\\t\\t\\tleft:   10,\\n\\t\\t\\tmiddle: 8,\\n\\t\\t\\tright:  6,\\n\\t\\t\\tmax:    10,\\n\\t\\t},\\n\\t}\\n\\n\\tfor _, test := range testCases {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tactualMax := Int(test.left, test.middle, test.right)\\n\\t\\t\\tif actualMax != test.max {\\n\\t\\t\\t\\tt.Errorf(\\\"Failed test %s\\\\n\\\\tleft: %v, middle: %v, right: %v, max: %v but received: %v\\\",\\n\\t\\t\\t\\t\\ttest.name, test.left, test.middle, test.right, test.max, actualMax)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "bitwise min": "\"// bitwisemin.go\\n// description: Gives min of two integers\\n// details:\\n// implementation of finding the minimum of two numbers using only binary operations without using conditions\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see bitwisemin_test.go\\n\\npackage min\\n\\n// Bitwise This function returns the minimum integer using bit operations\\nfunc Bitwise(base int, value int, values ...int) int {\\n\\tmin := value\\n\\tfor _, val := range values {\\n\\t\\tmin = min&((min-val)>>base) | val&(^(min-val)>>base)\\n\\t}\\n\\treturn min\\n}\\n\"",
    "min": "\"package min\\n\\n// Int is a function which returns the minimum of all the integers provided as arguments.\\nfunc Int(values ...int) int {\\n\\tmin := values[0]\\n\\tfor _, value := range values {\\n\\t\\tif value < min {\\n\\t\\t\\tmin = value\\n\\t\\t}\\n\\t}\\n\\treturn min\\n}\\n\"",
    "min test": "\"package min\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc getTestCases() []struct {\\n\\tname    string\\n\\tbase    int\\n\\tnumbers []int\\n\\tmin     int\\n} {\\n\\tvar tests = []struct {\\n\\t\\tname    string\\n\\t\\tbase    int\\n\\t\\tnumbers []int\\n\\t\\tmin     int\\n\\t}{\\n\\t\\t{\\\"Minimum of [128, 127], min = 117\\\", 8, []int{128, 127}, 127},\\n\\t\\t{\\\"Minimum of [5], min = 5\\\", 32, []int{5}, 5},\\n\\t\\t{\\\"Minimum of [-8, 32, 64, -1, 0], min = -8\\\", 64, []int{-8, 32, 64, -1, 0}, -8},\\n\\t\\t{\\\"Minimum of [1, 2, 3, 4, 5], min = 1\\\", 32, []int{1, 2, 3, 4, 5}, 1},\\n\\t\\t{\\\"Minimum of [1024, 512, 256, 333, 777], min = 256\\\", 64, []int{1024, 512, 256, 333, 777}, 256},\\n\\t\\t{\\\"Minimum of [-9223372036854770001, -9223372036854770000, 256, 333, 777], min = 256\\\", 64, []int{-9223372036854770001, -9223372036854770000, 256, 333, 777}, -9223372036854770001},\\n\\t}\\n\\treturn tests\\n}\\n\\nfunc TestBitwiseMin(t *testing.T) {\\n\\ttests := getTestCases()\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tresult := Bitwise(test.base, 999, test.numbers...)\\n\\t\\t\\tif result != test.min {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%v, returned:%v \\\", test.min, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestMin(t *testing.T) {\\n\\tfor _, test := range getTestCases() {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tactualMin := Int(test.numbers...)\\n\\t\\t\\tif actualMin != test.min {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%v, returned:%v \\\", test.min, actualMin)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkTestMinInt(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tInt(0, 10, 9, 7, 2, 1, 4, 3, 5, 6)\\n\\t}\\n}\\n\\nfunc BenchmarkTestBitwiseMin(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tBitwise(32, 10, 9, 7, 2, 1, 4, 3, 5, 6)\\n\\t}\\n}\\n\"",
    "exponentiation": "\"// exponentiation.go\\n// description: Implementation of Modular Exponentiation Algorithm\\n// details:\\n// A simple implementation of Modular Exponentiation - [Modular Exponenetation wiki](https://en.wikipedia.org/wiki/Modular_exponentiation)\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see exponentiation_test.go\\n\\npackage modular\\n\\nimport (\\n\\t\\\"errors\\\"\\n\\t\\\"math\\\"\\n)\\n\\n// ErrorIntOverflow For asserting that the values do not overflow in Int64\\nvar ErrorIntOverflow = errors.New(\\\"integer overflow\\\")\\n\\n// ErrorNegativeExponent for asserting that the exponent we receive is positive\\nvar ErrorNegativeExponent = errors.New(\\\"negative Exponent provided\\\")\\n\\n// Exponentiation returns base^exponent % mod\\nfunc Exponentiation(base, exponent, mod int64) (int64, error) {\\n\\tif mod == 1 {\\n\\t\\treturn 0, nil\\n\\t}\\n\\n\\tif exponent < 0 {\\n\\t\\treturn -1, ErrorNegativeExponent\\n\\t}\\n\\t_, err := Multiply64BitInt(mod-1, mod-1)\\n\\n\\tif err != nil {\\n\\t\\treturn -1, err\\n\\t}\\n\\n\\tvar result int64 = 1\\n\\n\\tbase = base % mod\\n\\n\\tfor exponent > 0 {\\n\\t\\tif exponent%2 == 1 {\\n\\t\\t\\tresult = (result * base) % mod\\n\\t\\t}\\n\\t\\texponent = exponent >> 1\\n\\t\\tbase = (base * base) % mod\\n\\t}\\n\\treturn result, nil\\n}\\n\\n// Multiply64BitInt Checking if the integer multiplication overflows\\nfunc Multiply64BitInt(left, right int64) (int64, error) {\\n\\tif math.Abs(float64(left)) > float64(math.MaxInt64)/math.Abs(float64(right)) {\\n\\t\\treturn 0, ErrorIntOverflow\\n\\t}\\n\\treturn left * right, nil\\n}\\n\"",
    "exponentiation test": "\"// exponentiation_test.go\\n// description: Test for ModularExponentation\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see exponentiation.go\\n\\npackage modular\\n\\nimport \\\"testing\\\"\\n\\ntype cases struct {\\n\\tname          string\\n\\tdescription   string\\n\\tbase          int64\\n\\texponent      int64\\n\\tmod           int64\\n\\texpected      int64\\n\\texpectedError error\\n}\\n\\nvar testCases = []cases{\\n\\t{\\n\\t\\tname:          \\\"Test 1\\\",\\n\\t\\tdescription:   \\\"Test 1: 3^6 % 3 == 0\\\",\\n\\t\\tbase:          3,\\n\\t\\texponent:      6,\\n\\t\\tmod:           3,\\n\\t\\texpected:      0,\\n\\t\\texpectedError: nil,\\n\\t},\\n\\t{\\n\\t\\tname:          \\\"Test 2\\\",\\n\\t\\tdescription:   \\\"Test 2: 33^60 % 25 == 1\\\",\\n\\t\\tbase:          33,\\n\\t\\texponent:      60,\\n\\t\\tmod:           25,\\n\\t\\texpected:      1,\\n\\t\\texpectedError: nil,\\n\\t},\\n\\t{\\n\\t\\tname:          \\\"Test 3\\\",\\n\\t\\tdescription:   \\\"Test 3: 17^60 % 23 == 2\\\",\\n\\t\\tbase:          17,\\n\\t\\texponent:      60,\\n\\t\\tmod:           23,\\n\\t\\texpected:      2,\\n\\t\\texpectedError: nil,\\n\\t},\\n\\t{\\n\\t\\tname:          \\\"Test 4\\\",\\n\\t\\tdescription:   \\\"Test 4: 17^60 % 1 == 0\\\", // handling result when we get mod = 1\\n\\t\\tbase:          17,\\n\\t\\texponent:      60,\\n\\t\\tmod:           1,\\n\\t\\texpected:      0,\\n\\t\\texpectedError: nil,\\n\\t},\\n\\t{\\n\\t\\tname:          \\\"Error test 1\\\",\\n\\t\\tdescription:   \\\"Testing whether we receive the expected errors gracefully\\\",\\n\\t\\tbase:          50,\\n\\t\\texponent:      -1,\\n\\t\\tmod:           2,\\n\\t\\texpected:      -1,\\n\\t\\texpectedError: ErrorNegativeExponent,\\n\\t},\\n}\\n\\nfunc TestExponentiation(t *testing.T) {\\n\\tfor _, test := range testCases {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tresult, err := Exponentiation(test.base, test.exponent, test.mod)\\n\\t\\t\\tif err != test.expectedError {\\n\\t\\t\\t\\tt.Logf(\\\"Test Failed for %s\\\", test.name)\\n\\t\\t\\t\\tt.Logf(\\\"Unexpected error occurred\\\")\\n\\t\\t\\t\\tt.Errorf(\\\"Expected error: %v, Received error: %v\\\", test.expectedError, err)\\n\\t\\t\\t}\\n\\t\\t\\tif result != test.expected {\\n\\t\\t\\t\\tt.Logf(\\\"Test Failed for %s\\\", test.description)\\n\\t\\t\\t\\tt.Fatalf(\\\"Expected: %d, Received: %d\\\", test.expected, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkExponentiation(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = Exponentiation(17, 60, 23)\\n\\t}\\n}\\n\"",
    "inverse": "\"// inverse.go\\n// description: Implementation of Modular Inverse Algorithm\\n// details:\\n// A simple implementation of Modular Inverse - [Modular Inverse wiki](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see inverse_test.go\\n\\npackage modular\\n\\nimport (\\n\\t\\\"errors\\\"\\n\\n\\t\\\"github.com/TheAlgorithms/Go/math/gcd\\\"\\n)\\n\\n// ErrorIntOverflow For asserting that the values do not overflow in Int64\\nvar ErrorInverse = errors.New(\\\"no Modular Inverse exists\\\")\\n\\n// Inverse Modular function\\nfunc Inverse(a, b int64) (int64, error) {\\n\\tgcd, x, _ := gcd.Extended(a, b)\\n\\tif gcd != 1 {\\n\\t\\treturn 0, ErrorInverse\\n\\t}\\n\\n\\treturn ((b + (x % b)) % b), nil // this is necessary because of Go's use of architecture specific instruction for the % operator.\\n}\\n\"",
    "inverse test": "\"// inverse_test.go\\n// description: Test for Modular Inverse\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see inverse.go\\n\\npackage modular\\n\\nimport \\\"testing\\\"\\n\\nfunc TestInverse(t *testing.T) {\\n\\tt.Run(\\\"Testing a = 3 and m = 11: \\\", func(t *testing.T) {\\n\\t\\tinv, err := Inverse(3, 11)\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Fatalf(\\\"Error was raised when it shouldn't: %v\\\", err)\\n\\t\\t}\\n\\t\\tif inv != 4 {\\n\\t\\t\\tt.Fatalf(\\\"Test failed:\\\\n\\\\tExpected values: %v\\\\n\\\\tReturned value: %v\\\", 4, inv)\\n\\t\\t}\\n\\t})\\n\\tt.Run(\\\"Testing a = 10 and m = 17: \\\", func(t *testing.T) {\\n\\t\\tinv, err := Inverse(10, 17)\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Fatalf(\\\"Error was raised when it shouldn't: %v\\\", err)\\n\\t\\t}\\n\\t\\tif inv != 12 {\\n\\t\\t\\tt.Fatalf(\\\"Test failed:\\\\n\\\\tExpected values: %v\\\\n\\\\tReturned value: %v\\\", 12, inv)\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "sequence": "\"// The Moser-de Bruijn sequence is the sequence obtained by\\n// adding up the distinct powers of the number 4 (For example 1, 4, 16, 64, etc).\\n// You can get more details on https://en.wikipedia.org/wiki/Moser%E2%80%93de_Bruijn_sequence.\\n\\npackage moserdebruijnsequence\\n\\nfunc MoserDeBruijnSequence(number int) []int {\\n\\tsequence := []int{}\\n\\n\\tfor i := 0; i < number; i++ {\\n\\t\\tres := generateNthTerm(i)\\n\\t\\tsequence = append(sequence, res)\\n\\t}\\n\\n\\treturn sequence\\n}\\n\\nfunc generateNthTerm(num int) int {\\n\\tif num == 0 || num == 1 {\\n\\t\\treturn num\\n\\t}\\n\\n\\t//number is even\\n\\tif num%2 == 0 {\\n\\t\\treturn 4 * generateNthTerm(num/2)\\n\\t}\\n\\n\\t//number is odd\\n\\treturn 4*generateNthTerm(num/2) + 1\\n}\\n\"",
    "sequence test": "\"package moserdebruijnsequence\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nvar testCases = []struct {\\n\\tname     string\\n\\tinputNum int\\n\\texpected []int\\n}{\\n\\t{\\\"first 15 terms\\\", 15, []int{0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84}},\\n}\\n\\nfunc TestMoserDeBruijnSequence(t *testing.T) {\\n\\n\\tfor _, test := range testCases {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tif output := MoserDeBruijnSequence(test.inputNum); !reflect.DeepEqual(output, test.expected) {\\n\\t\\t\\t\\tt.Errorf(\\\"For input: %d, expected: %v, but got: %v\\\", test.inputNum, test.expected, output)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "pascaltriangle": "\"// pascaltriangle.go\\n// description: Pascal's triangle\\n// details:\\n// Pascal's triangle is a triangular array of the binomial coefficients that arises in probability theory, combinatorics, and algebra. - [Pascal's triangle](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\\n// example:\\n//1\\n//1 1\\n//1 2 1\\n//1 3 3 1\\n//1 4 6 4 1\\n//1 5 10 10 5 1\\n//1 6 15 20 15 6 1\\n//1 7 21 35 35 21 7 1\\n//1 8 28 56 70 56 28 8 1\\n//1 9 36 84 126 126 84 36 9 1\\n//1 10 45 120 210 252 210 120 45 10 1\\n//...\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see pascaltriangle_test.go\\n\\npackage pascal\\n\\n// GenerateTriangle This function generates a Pascal's triangle of n lines\\nfunc GenerateTriangle(n int) [][]int {\\n\\tvar triangle = make([][]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\ttriangle[i] = make([]int, i+1)\\n\\t\\ttriangle[i][0], triangle[i][i] = 1, 1\\n\\t\\tfor j := 1; j < i; j++ {\\n\\t\\t\\ttriangle[i][j] = triangle[i-1][j] + triangle[i-1][j-1]\\n\\t\\t}\\n\\t}\\n\\treturn triangle\\n}\\n\"",
    "pascaltriangle test": "\"// pascaltriangle_test.go\\n// description: Test for Pascal's triangle\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see pascaltriangle.go\\n\\npackage pascal\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestGenerateTriangle(t *testing.T) {\\n\\ttests := []struct {\\n\\t\\tname string\\n\\t\\tn    int\\n\\t\\twant [][]int\\n\\t}{\\n\\t\\t{name: \\\"Pascal's three-line triangle\\\", n: 3, want: [][]int{{1}, {1, 1}, {1, 2, 1}}},\\n\\t\\t{name: \\\"Pascal's 0-line triangle\\\", n: 0, want: [][]int{}},\\n\\t\\t{name: \\\"Pascal's one-line triangle\\\", n: 1, want: [][]int{{1}}},\\n\\t\\t{name: \\\"Pascal's 7-line triangle\\\", n: 7, want: [][]int{{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}}},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tif got := GenerateTriangle(test.n); !reflect.DeepEqual(got, test.want) {\\n\\t\\t\\t\\tt.Errorf(\\\"GenerateTriangle() = %v, want %v\\\", got, test.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkGenerateTriangle(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tGenerateTriangle(10)\\n\\t}\\n}\\n\"",
    "heaps": "\"package permutation\\n\\nimport (\\n\\t\\\"strings\\\"\\n)\\n\\n// Heap's Algorithm for generating all permutations of n objects\\nfunc Heaps(out chan []string, n int) {\\n\\telementSetCh := make(chan []string)\\n\\tgo GenerateElementSet(elementSetCh, n)\\n\\telementSet := <-elementSetCh\\n\\n\\tvar recursiveGenerate func([]string, int, []string)\\n\\tvar permutations []string\\n\\trecursiveGenerate = func(previousIteration []string, n int, elements []string) {\\n\\t\\tif n == 1 {\\n\\t\\t\\tpermutations = append(permutations, strings.Join(elements, \\\"\\\"))\\n\\t\\t} else {\\n\\t\\t\\tfor i := 0; i < n; i++ {\\n\\t\\t\\t\\trecursiveGenerate(previousIteration, n-1, elements)\\n\\t\\t\\t\\tif n%2 == 1 {\\n\\t\\t\\t\\t\\ttmp := elements[i]\\n\\t\\t\\t\\t\\telements[i] = elements[n-1]\\n\\t\\t\\t\\t\\telements[n-1] = tmp\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttmp := elements[0]\\n\\t\\t\\t\\t\\telements[0] = elements[n-1]\\n\\t\\t\\t\\t\\telements[n-1] = tmp\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\trecursiveGenerate(permutations, n, elementSet)\\n\\tout <- permutations\\n}\\n\\nfunc GenerateElementSet(out chan []string, n int) {\\n\\telementSet := make([]string, n)\\n\\tfor i := range elementSet {\\n\\t\\telementSet[i] = string(rune(i + 49)) // Adjust this if you want to change your charset\\n\\t}\\n\\tout <- elementSet\\n}\\n\"",
    "heaps test": "\"package permutation\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"sort\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestHeaps(t *testing.T) {\\n\\tt.Run(\\\"Should generate permutations for various size sets\\\", func(t *testing.T) {\\n\\t\\texpectedValues := [][]string{\\n\\t\\t\\t{\\\"1\\\"},\\n\\t\\t\\t{\\\"12\\\", \\\"21\\\"},\\n\\t\\t\\t{\\\"123\\\", \\\"213\\\", \\\"321\\\", \\\"231\\\", \\\"312\\\", \\\"132\\\"},\\n\\t\\t\\t{\\\"1234\\\", \\\"1243\\\", \\\"1324\\\", \\\"1342\\\", \\\"1423\\\", \\\"1432\\\", \\\"2134\\\", \\\"2143\\\", \\\"2314\\\", \\\"2341\\\", \\\"2413\\\", \\\"2431\\\", \\\"3124\\\", \\\"3142\\\", \\\"3214\\\", \\\"3241\\\", \\\"3412\\\", \\\"3421\\\", \\\"4123\\\", \\\"4132\\\", \\\"4213\\\", \\\"4231\\\", \\\"4312\\\", \\\"4321\\\"},\\n\\t\\t\\t{\\\"12345\\\", \\\"12354\\\", \\\"12435\\\", \\\"12453\\\", \\\"12534\\\", \\\"12543\\\", \\\"13245\\\", \\\"13254\\\", \\\"13425\\\", \\\"13452\\\", \\\"13524\\\", \\\"13542\\\", \\\"14235\\\", \\\"14253\\\", \\\"14325\\\", \\\"14352\\\", \\\"14523\\\", \\\"14532\\\", \\\"15234\\\", \\\"15243\\\", \\\"15324\\\", \\\"15342\\\", \\\"15423\\\", \\\"15432\\\", \\\"21345\\\", \\\"21354\\\", \\\"21435\\\", \\\"21453\\\", \\\"21534\\\", \\\"21543\\\", \\\"23145\\\", \\\"23154\\\", \\\"23415\\\", \\\"23451\\\", \\\"23514\\\", \\\"23541\\\", \\\"24135\\\", \\\"24153\\\", \\\"24315\\\", \\\"24351\\\", \\\"24513\\\", \\\"24531\\\", \\\"25134\\\", \\\"25143\\\", \\\"25314\\\", \\\"25341\\\", \\\"25413\\\", \\\"25431\\\", \\\"31245\\\", \\\"31254\\\", \\\"31425\\\", \\\"31452\\\", \\\"31524\\\", \\\"31542\\\", \\\"32145\\\", \\\"32154\\\", \\\"32415\\\", \\\"32451\\\", \\\"32514\\\", \\\"32541\\\", \\\"34125\\\", \\\"34152\\\", \\\"34215\\\", \\\"34251\\\", \\\"34512\\\", \\\"34521\\\", \\\"35124\\\", \\\"35142\\\", \\\"35214\\\", \\\"35241\\\", \\\"35412\\\", \\\"35421\\\", \\\"41235\\\", \\\"41253\\\", \\\"41325\\\", \\\"41352\\\", \\\"41523\\\", \\\"41532\\\", \\\"42135\\\", \\\"42153\\\", \\\"42315\\\", \\\"42351\\\", \\\"42513\\\", \\\"42531\\\", \\\"43125\\\", \\\"43152\\\", \\\"43215\\\", \\\"43251\\\", \\\"43512\\\", \\\"43521\\\", \\\"45123\\\", \\\"45132\\\", \\\"45213\\\", \\\"45231\\\", \\\"45312\\\", \\\"45321\\\", \\\"51234\\\", \\\"51243\\\", \\\"51324\\\", \\\"51342\\\", \\\"51423\\\", \\\"51432\\\", \\\"52134\\\", \\\"52143\\\", \\\"52314\\\", \\\"52341\\\", \\\"52413\\\", \\\"52431\\\", \\\"53124\\\", \\\"53142\\\", \\\"53214\\\", \\\"53241\\\", \\\"53412\\\", \\\"53421\\\", \\\"54123\\\", \\\"54132\\\", \\\"54213\\\", \\\"54231\\\", \\\"54312\\\", \\\"54321\\\"},\\n\\t\\t}\\n\\t\\tpermutationsCh := make(chan []string)\\n\\t\\tvar value []string\\n\\n\\t\\tfor i := 1; i <= 5; i++ {\\n\\t\\t\\tgo Heaps(permutationsCh, i)\\n\\t\\t\\tvalue = <-permutationsCh\\n\\t\\t\\tsort.Strings(value)\\n\\t\\t\\tsort.Strings(expectedValues[i-1])\\n\\t\\t\\tif !reflect.DeepEqual(value, expectedValues[i-1]) {\\n\\t\\t\\t\\tt.Errorf(\\\"Permutation set is incorrect for element size of %v. Expected (%v) and received (%v)\\\", i, expectedValues[i-1], value)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "pi using monte carlo": "\"// montecarlopi.go\\n// description: Calculating pi by the Monte Carlo method\\n// details:\\n// implementations of Monte Carlo Algorithm for the calculating of Pi - [Monte Carlo method](https://en.wikipedia.org/wiki/Monte_Carlo_method)\\n// author(s): [red_byte](https://github.com/i-redbyte), [Paul Leydier] (https://github.com/paul-leydier)\\n// see montecarlopi_test.go\\n\\npackage pi\\n\\nimport (\\n\\t\\\"fmt\\\"       // Used for error formatting\\n\\t\\\"math/rand\\\" // Used for random number generation in Monte Carlo method\\n\\t\\\"runtime\\\"   // Used to get information on available CPUs\\n\\t\\\"time\\\"      // Used for seeding the random number generation\\n)\\n\\nfunc MonteCarloPi(randomPoints int) float64 {\\n\\trnd := rand.New(rand.NewSource(time.Now().UnixNano()))\\n\\tinside := 0\\n\\tfor i := 0; i < randomPoints; i++ {\\n\\t\\tx := rnd.Float64()\\n\\t\\ty := rnd.Float64()\\n\\t\\tif x*x+y*y <= 1 {\\n\\t\\t\\tinside += 1\\n\\t\\t}\\n\\t}\\n\\tpi := float64(inside) / float64(randomPoints) * 4\\n\\treturn pi\\n}\\n\\n// MonteCarloPiConcurrent approximates the value of pi using the Monte Carlo method.\\n// Unlike the MonteCarloPi function (first version), this implementation uses\\n// goroutines and channels to parallelize the computation.\\n// More details on the Monte Carlo method available at https://en.wikipedia.org/wiki/Monte_Carlo_method.\\n// More details on goroutines parallelization available at https://go.dev/doc/effective_go#parallel.\\nfunc MonteCarloPiConcurrent(n int) (float64, error) {\\n\\tnumCPU := runtime.GOMAXPROCS(0)\\n\\tc := make(chan int, numCPU)\\n\\tpointsToDraw, err := splitInt(n, numCPU) // split the task in sub-tasks of approximately equal sizes\\n\\tif err != nil {\\n\\t\\treturn 0, err\\n\\t}\\n\\n\\t// launch numCPU parallel tasks\\n\\tfor _, p := range pointsToDraw {\\n\\t\\tgo drawPoints(p, c)\\n\\t}\\n\\n\\t// collect the tasks results\\n\\tinside := 0\\n\\tfor i := 0; i < numCPU; i++ {\\n\\t\\tinside += <-c\\n\\t}\\n\\treturn float64(inside) / float64(n) * 4, nil\\n}\\n\\n// drawPoints draws n random two-dimensional points in the interval [0, 1), [0, 1) and sends through c\\n// the number of points which where within the circle of center 0 and radius 1 (unit circle)\\nfunc drawPoints(n int, c chan<- int) {\\n\\trnd := rand.New(rand.NewSource(time.Now().UnixNano()))\\n\\tinside := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tx, y := rnd.Float64(), rnd.Float64()\\n\\t\\tif x*x+y*y <= 1 {\\n\\t\\t\\tinside++\\n\\t\\t}\\n\\t}\\n\\tc <- inside\\n}\\n\\n// splitInt takes an integer x and splits it within an integer slice of length n in the most uniform\\n// way possible.\\n// For example, splitInt(10, 3) will return []int{4, 3, 3}, nil\\nfunc splitInt(x int, n int) ([]int, error) {\\n\\tif x < n {\\n\\t\\treturn nil, fmt.Errorf(\\\"x must be < n - given values are x=%d, n=%d\\\", x, n)\\n\\t}\\n\\tsplit := make([]int, n)\\n\\tif x%n == 0 {\\n\\t\\tfor i := 0; i < n; i++ {\\n\\t\\t\\tsplit[i] = x / n\\n\\t\\t}\\n\\t} else {\\n\\t\\tlimit := x % n\\n\\t\\tfor i := 0; i < limit; i++ {\\n\\t\\t\\tsplit[i] = x/n + 1\\n\\t\\t}\\n\\t\\tfor i := limit; i < n; i++ {\\n\\t\\t\\tsplit[i] = x / n\\n\\t\\t}\\n\\t}\\n\\treturn split, nil\\n}\\n\"",
    "montecarlopi test": "\"// montecarlopi_test.go\\n// description: Test for calculating pi by the Monte Carlo method\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see montecarlopi.go\\n\\npackage pi\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestMonteCarloPi(t *testing.T) {\\n\\tt.Run(\\\"Monte Carlo Pi\\\", func(t *testing.T) {\\n\\t\\tresult := fmt.Sprintf(\\\"%.2f\\\", MonteCarloPi(100000000))\\n\\t\\tt.Log(result)\\n\\t\\tif result != \\\"3.14\\\" {\\n\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%f, returned:%s \\\", 3.1415, result)\\n\\t\\t}\\n\\t})\\n}\\n\\nfunc BenchmarkMonteCarloPi(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tMonteCarloPi(100000000)\\n\\t}\\n}\\n\\nfunc TestSplitInt(t *testing.T) {\\n\\ttestCases := []struct {\\n\\t\\tname           string\\n\\t\\tx              int\\n\\t\\tn              int\\n\\t\\texpectedResult []int\\n\\t\\texpectedError  bool\\n\\t}{\\n\\t\\t{\\\"multiple\\\", 10, 5, []int{2, 2, 2, 2, 2}, false},\\n\\t\\t{\\\"n=1\\\", 10, 1, []int{10}, false},\\n\\t\\t{\\\"x=10, n=3\\\", 10, 3, []int{4, 3, 3}, false},\\n\\t\\t{\\\"x=10, n=7\\\", 10, 7, []int{2, 2, 2, 1, 1, 1, 1}, false},\\n\\t\\t{\\\"n>x\\\", 10, 11, nil, true},\\n\\t}\\n\\tfor _, testCase := range testCases {\\n\\t\\tt.Run(testCase.name, func(t *testing.T) {\\n\\t\\t\\tres, err := splitInt(testCase.x, testCase.n)\\n\\t\\t\\tfor i := 0; i < len(testCase.expectedResult); i++ {\\n\\t\\t\\t\\tif res[i] != testCase.expectedResult[i] {\\n\\t\\t\\t\\t\\tt.Fatalf(\\\"unexpected result at index %d: %d - expected %d\\\", i, res[i], testCase.expectedResult[i])\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif testCase.expectedError {\\n\\t\\t\\t\\tif err == nil {\\n\\t\\t\\t\\t\\tt.Fatal(\\\"expected an error, got nil\\\")\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif err != nil {\\n\\t\\t\\t\\t\\tt.Fatalf(\\\"unexpected error - %s\\\", err)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestMonteCarloPi2(t *testing.T) {\\n\\tres, err := MonteCarloPiConcurrent(100000000)\\n\\tif err != nil {\\n\\t\\tt.Errorf(\\\"unexpected error %s\\\", err)\\n\\t}\\n\\tresult := fmt.Sprintf(\\\"%.2f\\\", res)\\n\\tt.Log(result)\\n\\tif result != \\\"3.14\\\" {\\n\\t\\tt.Errorf(\\\"Wrong result! Expected:%f, returned:%s \\\", 3.1415, result)\\n\\t}\\n}\\n\\nfunc BenchmarkMonteCarloPi2(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, err := MonteCarloPiConcurrent(100000000)\\n\\t\\tif err != nil {\\n\\t\\t\\tb.Fatalf(\\\"unexpected error - %s\\\", err)\\n\\t\\t}\\n\\t}\\n}\\n\"",
    "spigot pi": "\"// spigotpi.go\\n// description: A Spigot Algorithm for the Digits of Pi\\n// details:\\n// implementation of Spigot Algorithm for the Digits of Pi - [Spigot algorithm](https://en.wikipedia.org/wiki/Spigot_algorithm)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see spigotpi_test.go\\n\\npackage pi\\n\\nimport \\\"strconv\\\"\\n\\nfunc Spigot(n int) string {\\n\\tpi := \\\"\\\"\\n\\tboxes := n * 10 / 3\\n\\tremainders := make([]int, boxes)\\n\\tfor i := 0; i < boxes; i++ {\\n\\t\\tremainders[i] = 2\\n\\t}\\n\\tdigitsHeld := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tcarriedOver := 0\\n\\t\\tsum := 0\\n\\t\\tfor j := boxes - 1; j >= 0; j-- {\\n\\t\\t\\tremainders[j] *= 10\\n\\t\\t\\tsum = remainders[j] + carriedOver\\n\\t\\t\\tquotient := sum / (j*2 + 1)\\n\\t\\t\\tremainders[j] = sum % (j*2 + 1)\\n\\t\\t\\tcarriedOver = quotient * j\\n\\t\\t}\\n\\t\\tremainders[0] = sum % 10\\n\\t\\tq := sum / 10\\n\\t\\tswitch q {\\n\\t\\tcase 9:\\n\\t\\t\\tdigitsHeld++\\n\\t\\tcase 10:\\n\\t\\t\\tq = 0\\n\\t\\t\\tfor k := 1; k <= digitsHeld; k++ {\\n\\t\\t\\t\\treplaced, _ := strconv.Atoi(pi[i-k : i-k+1])\\n\\t\\t\\t\\tif replaced == 9 {\\n\\t\\t\\t\\t\\treplaced = 0\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treplaced++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpi = delChar(pi, i-k)\\n\\t\\t\\t\\tpi = pi[:i-k] + strconv.Itoa(replaced) + pi[i-k:]\\n\\t\\t\\t}\\n\\t\\t\\tdigitsHeld = 1\\n\\t\\tdefault:\\n\\t\\t\\tdigitsHeld = 1\\n\\t\\t}\\n\\t\\tpi += strconv.Itoa(q)\\n\\t}\\n\\treturn pi\\n}\\n\\nfunc delChar(s string, index int) string {\\n\\ttmp := []rune(s)\\n\\treturn string(append(tmp[0:index], tmp[index+1:]...))\\n}\\n\"",
    "spigot pi test": "\"// spigotpi_test.go\\n// description: Test for Spigot Algorithm for the Digits of Pi\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see spigotpi.go\\npackage pi\\n\\nimport (\\n\\t\\\"strconv\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestSpigot(t *testing.T) {\\n\\tvar tests = []struct {\\n\\t\\tresult string\\n\\t\\tn      int\\n\\t}{\\n\\t\\t{\\\"314159\\\", 6},\\n\\t\\t{\\\"31415926535\\\", 11},\\n\\t\\t{\\\"314159265358\\\", 12},\\n\\t\\t{\\\"314159265358979323846\\\", 21},\\n\\t\\t{\\\"314\\\", 3},\\n\\t\\t{\\\"31415\\\", 5},\\n\\t}\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(strconv.Itoa(tv.n)+\\\":\\\"+tv.result, func(t *testing.T) {\\n\\t\\t\\tresult := Spigot(tv.n)\\n\\t\\t\\tif result != tv.result {\\n\\t\\t\\t\\tt.Errorf(\\\"Bad result %d:%s\\\", tv.n, tv.result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkPiSpigotN10(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tSpigot(10)\\n\\t}\\n}\\n\\nfunc BenchmarkPiSpigotN100(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tSpigot(100)\\n\\t}\\n}\\n\\nfunc BenchmarkPiSpigotN1000(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tSpigot(1000)\\n\\t}\\n}\\n\"",
    "fast exponent": "\"package power\\n\\n// IterativePower is iterative O(logn) function for pow(x, y)\\nfunc IterativePower(n uint, power uint) uint {\\n\\tvar res uint = 1\\n\\tfor power > 0 {\\n\\t\\tif (power & 1) != 0 {\\n\\t\\t\\tres = res * n\\n\\t\\t}\\n\\n\\t\\tpower = power >> 1\\n\\t\\tn *= n\\n\\t}\\n\\treturn res\\n}\\n\\n// RecursivePower is recursive O(logn) function for pow(x, y)\\nfunc RecursivePower(n uint, power uint) uint {\\n\\tif power == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tvar temp = RecursivePower(n, power/2)\\n\\tif power%2 == 0 {\\n\\t\\treturn temp * temp\\n\\t}\\n\\treturn n * temp * temp\\n}\\n\\n// RecursivePower1 is recursive O(n) function for pow(x, y)\\nfunc RecursivePower1(n uint, power uint) uint {\\n\\tif power == 0 {\\n\\t\\treturn 1\\n\\t} else if power%2 == 0 {\\n\\t\\treturn RecursivePower1(n, power/2) * RecursivePower1(n, power/2)\\n\\t} else {\\n\\t\\treturn n * RecursivePower1(n, power/2) * RecursivePower1(n, power/2)\\n\\t}\\n}\\n\"",
    "fast exponent test": "\"package power\\n\\nimport \\\"testing\\\"\\n\\nvar testCases = []struct {\\n\\tname     string\\n\\tbase     uint\\n\\tpower    uint\\n\\texpected uint\\n}{\\n\\t{\\\"0^2\\\", 0, 2, 0},\\n\\t{\\\"2^0\\\", 2, 0, 1},\\n\\t{\\\"2^3\\\", 2, 3, 8},\\n\\t{\\\"8^3\\\", 8, 3, 512},\\n\\t{\\\"10^5\\\", 10, 5, 100000},\\n}\\n\\nfunc TestIterativePower(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := IterativePower(tc.base, tc.power)\\n\\t\\t\\tif actual != tc.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected %d to the power of %d to be: %d, but got: %d\\\", tc.base, tc.power, tc.expected, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestRecursivePower(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := RecursivePower(tc.base, tc.power)\\n\\t\\t\\tif actual != tc.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected %d to the power of %d to be: %d, but got: %d\\\", tc.base, tc.power, tc.expected, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestRecursivePower1(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := RecursivePower1(tc.base, tc.power)\\n\\t\\t\\tif actual != tc.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected %d to the power of %d to be: %d, but got: %d\\\", tc.base, tc.power, tc.expected, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkIterativePower(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tIterativePower(10, 5)\\n\\t}\\n}\\n\\nfunc BenchmarkRecursivePower(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tRecursivePower(10, 5)\\n\\t}\\n}\\n\\nfunc BenchmarkRecursivePower1(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tRecursivePower1(10, 5)\\n\\t}\\n}\\n\"",
    "pow via logarithm": "\"// powvialogarithm.go\\n// description: Powers in terms of logarithms\\n// details:\\n// implementation of exponentiation using exponent and logarithm, without using loops  - [Powers via logarithms wiki](https://en.wikipedia.org/wiki/Exponentiation#Powers_via_logarithms)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see powvialogarithm_test.go\\n\\npackage power\\n\\nimport (\\n\\t\\\"math\\\"\\n)\\n\\nfunc UsingLog(a float64, b float64) float64 {\\n\\tvar p float64\\n\\tp = 1\\n\\tif a < 0 && int(b)&1 != 0 {\\n\\t\\tp = -1\\n\\t}\\n\\tlog := math.Log(math.Abs(a))\\n\\texp := math.Exp(b * log)\\n\\tresult := exp * p\\n\\treturn math.Round(result)\\n}\\n\"",
    "pow via logarithm test": "\"// powvialogarithm_test.go\\n// description: Test for UsingLog\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see powvialogarithm.go\\n\\npackage power\\n\\nimport \\\"testing\\\"\\n\\nfunc TestUsingLog(t *testing.T) {\\n\\tvar tests = []struct {\\n\\t\\tname     string\\n\\t\\tbase     float64\\n\\t\\tpower    float64\\n\\t\\texpected float64\\n\\t}{\\n\\t\\t{\\\"0^0\\\", 99, 1, 99},\\n\\t\\t{\\\"-3^9\\\", -3, 9, -19683},\\n\\t\\t{\\\"0^2\\\", 0, 2, 0},\\n\\t\\t{\\\"2^0\\\", 2, 0, 1},\\n\\t\\t{\\\"2^3\\\", 2, 3, 8},\\n\\t\\t{\\\"8^3\\\", 8, 3, 512},\\n\\t\\t{\\\"11^11\\\", 11, 11, 285311670611},\\n\\t\\t{\\\"5^5\\\", 5, 5, 3125},\\n\\t\\t{\\\"-7^2\\\", -7, 2, 49},\\n\\t\\t{\\\"-6^3\\\", -6, 3, -216},\\n\\t}\\n\\n\\tfor _, tc := range tests {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tresult := UsingLog(tc.base, tc.power)\\n\\t\\t\\tt.Log(result)\\n\\t\\t\\tif result != tc.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected %.2f to the power of %.2f to be: %.2f, but got: %.2f\\\", tc.base, tc.power, tc.expected, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkUsingLog(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tUsingLog(10, 5)\\n\\t}\\n}\\n\"",
    "miller rabin primality test": "\"// millerrabinprimalitytest.go\\n// description: An implementation of Miller-Rabin primality test\\n// details:\\n// A simple implementation of Miller-Rabin Primality Test\\n// [Miller-Rabin primality test Wiki](https://en.wikipedia.org/wiki/Miller–Rabin_primality_test)\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see millerrabinprimalitytest_test.go\\n\\npackage prime\\n\\nimport (\\n\\t\\\"math/rand\\\"\\n\\n\\t\\\"github.com/TheAlgorithms/Go/math/modular\\\"\\n)\\n\\n// findD accepts a number and returns the\\n// odd number d such that num = 2^r * d - 1\\nfunc findRD(num int64) (int64, int64) {\\n\\tr := int64(0)\\n\\td := num - 1\\n\\tfor num%2 == 0 {\\n\\t\\td /= 2\\n\\t\\tr++\\n\\t}\\n\\treturn d, r\\n}\\n\\n// MillerTest This is the intermediate step that repeats within the\\n// miller rabin primality test for better probabilitic chances of\\n// receiving the correct result.\\nfunc MillerTest(d, num int64) (bool, error) {\\n\\trandom := rand.Int63n(num-1) + 2\\n\\n\\tres, err := modular.Exponentiation(random, d, num)\\n\\n\\tif err != nil {\\n\\t\\treturn false, err\\n\\t}\\n\\t// miller conditions checks\\n\\tif res == 1 || res == num-1 {\\n\\t\\treturn true, nil\\n\\t}\\n\\n\\tfor d != num-1 {\\n\\t\\tres = (res * res) % num\\n\\t\\td *= 2\\n\\t\\tif res == 1 {\\n\\t\\t\\treturn false, nil\\n\\t\\t}\\n\\t\\tif res == num-1 {\\n\\t\\t\\treturn true, nil\\n\\t\\t}\\n\\t}\\n\\treturn false, nil\\n}\\n\\n// MillerRabinTest Probabilistic test for primality of an integer based of the algorithm devised by Miller and Rabin.\\nfunc MillerRabinTest(num, rounds int64) (bool, error) {\\n\\tif num <= 4 {\\n\\t\\tif num == 2 || num == 3 {\\n\\t\\t\\treturn true, nil\\n\\t\\t}\\n\\t\\treturn false, nil\\n\\t}\\n\\tif num%2 == 0 {\\n\\t\\treturn false, nil\\n\\t}\\n\\td, _ := findRD(num)\\n\\n\\tfor i := int64(0); i < rounds; i++ {\\n\\t\\tval, err := MillerTest(d, num)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn false, err\\n\\t\\t}\\n\\t\\tif !val {\\n\\t\\t\\treturn false, nil\\n\\t\\t}\\n\\t}\\n\\treturn true, nil\\n}\\n\"",
    "miller rabin primality test test": "\"// millerrabinprimality_test.go\\n// description: Test for Miller-Rabin Primality Test\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see millerrabinprimalitytest.go\\n\\npackage prime\\n\\nimport \\\"testing\\\"\\n\\nfunc TestMillerRabinTest(t *testing.T) {\\n\\tvar tests = []struct {\\n\\t\\tname     string\\n\\t\\tinput    int64\\n\\t\\texpected bool\\n\\t\\trounds   int64\\n\\t\\terr      error\\n\\t}{\\n\\t\\t{\\\"smallest prime\\\", 2, true, 5, nil},\\n\\t\\t{\\\"random prime\\\", 3, true, 5, nil},\\n\\t\\t{\\\"neither prime nor composite\\\", 1, false, 5, nil},\\n\\t\\t{\\\"random non-prime\\\", 10, false, 5, nil},\\n\\t\\t{\\\"another random prime\\\", 23, true, 5, nil},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\toutput, err := MillerRabinTest(test.input, test.rounds)\\n\\t\\t\\tif err != test.err {\\n\\t\\t\\t\\tt.Errorf(\\\"For input: %d, unexpected error: %v, expected error: %v\\\", test.input, err, test.err)\\n\\t\\t\\t}\\n\\t\\t\\tif output != test.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"For input: %d, expected: %v\\\", test.input, output)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc BenchmarkMillerRabinPrimalityTest(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\t_, _ = MillerRabinTest(23, 5)\\n\\t}\\n}\\n\"",
    "prime check": "\"package prime\\n\\n// A primality test is an algorithm for determining whether an input number is prime.Among other fields of mathematics, it is used for cryptography.\\n//Unlike integer factorization, primality tests do not generally give prime factors, only stating whether the input number is prime or not.\\n//Source - Wikipedia https://en.wikipedia.org/wiki/Primality_test\\n\\n// NaiveApproach checks if an integer is prime or not. Returns a bool.\\nfunc NaiveApproach(n int) bool {\\n\\tif n < 2 {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := 2; i < n; i++ {\\n\\n\\t\\tif n%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n// PairApproach checks primality of an integer and returns a bool. More efficient than the naive approach as number of iterations are less.\\nfunc PairApproach(n int) bool {\\n\\tif n < 2 {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := 2; i*i <= n; i++ {\\n\\t\\tif n%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\"",
    "prime check test": "\"package prime\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestTableNaiveApproach(t *testing.T) {\\n\\tvar tests = []struct {\\n\\t\\tname     string\\n\\t\\tinput    int\\n\\t\\texpected bool\\n\\t}{\\n\\t\\t{\\\"smallest prime\\\", 2, true},\\n\\t\\t{\\\"random prime\\\", 3, true},\\n\\t\\t{\\\"neither prime nor composite\\\", 1, false},\\n\\t\\t{\\\"random non-prime\\\", 10, false},\\n\\t\\t{\\\"another random prime\\\", 23, true},\\n\\t}\\n\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tif output := NaiveApproach(test.input); output != test.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"For input: %d, expected: %v, but got: %v\\\", test.input, test.expected, output)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n\\n}\\nfunc TestTablePairApproach(t *testing.T) {\\n\\tvar tests = []struct {\\n\\t\\tname     string\\n\\t\\tinput    int\\n\\t\\texpected bool\\n\\t}{\\n\\t\\t{\\\"smallest prime\\\", 2, true},\\n\\t\\t{\\\"random prime\\\", 3, true},\\n\\t\\t{\\\"neither prime nor composite\\\", 1, false},\\n\\t\\t{\\\"random non-prime\\\", 10, false},\\n\\t\\t{\\\"another random prime\\\", 23, true},\\n\\t}\\n\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tif output := NaiveApproach(test.input); output != test.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"For input: %d, expected: %v, but got: %v\\\", test.input, test.expected, output)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n\\n}\\n\\nfunc BenchmarkNaiveApproach(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tNaiveApproach(23)\\n\\t}\\n}\\n\\nfunc BenchmarkPairApproach(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tPairApproach(23)\\n\\t}\\n}\\n\"",
    "prime factorization": "\"package prime\\n\\n// Factorize is a function that computes the exponents\\n// of each prime in the prime factorization of n\\nfunc Factorize(n int64) map[int64]int64 {\\n\\tresult := make(map[int64]int64)\\n\\n\\tfor i := int64(2); i*i <= n; i += 1 {\\n\\t\\tfor {\\n\\t\\t\\tif n%i != 0 {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tresult[i] += 1\\n\\t\\t\\tn /= i\\n\\t\\t}\\n\\n\\t}\\n\\tif n > 1 {\\n\\t\\tresult[n] += 1\\n\\t}\\n\\treturn result\\n}\\n\"",
    "prime factorization test": "\"package prime\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestFactorize(t *testing.T) {\\n\\tvar tests = []struct {\\n\\t\\tn        int64\\n\\t\\texpected map[int64]int64\\n\\t}{\\n\\t\\t{4, map[int64]int64{2: 2}},\\n\\t\\t{5, map[int64]int64{5: 1}},\\n\\t\\t{7, map[int64]int64{7: 1}},\\n\\t\\t{10, map[int64]int64{2: 1, 5: 1}},\\n\\t\\t{999, map[int64]int64{3: 3, 37: 1}},\\n\\t\\t{999999999999878, map[int64]int64{2: 1, 19: 1, 26315789473681: 1}},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tresult := Factorize(test.n)\\n\\t\\tt.Log(test.n, \\\" \\\", result)\\n\\t\\tif !reflect.DeepEqual(result, test.expected) {\\n\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%v, returned:%v \\\", test.expected, result)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc BenchmarkFactorize(b *testing.B) {\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tFactorize(1000000007)\\n\\t}\\n}\\n\"",
    "sieve": "\"// sieve.go\\n// description: Algorithms for generating prime numbers efficiently\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see sieve_test.go\\n\\npackage prime\\n\\n// Generate generates the sequence of integers starting at 2 and sends it to the channel `ch`\\nfunc GenerateChannel(ch chan<- int) {\\n\\tfor i := 2; ; i++ {\\n\\t\\tch <- i\\n\\t}\\n}\\n\\n// Sieve Sieving the numbers that are not prime from the channel - basically removing them from the channels\\nfunc Sieve(in <-chan int, out chan<- int, prime int) {\\n\\tfor {\\n\\t\\ti := <-in\\n\\t\\tif i%prime != 0 {\\n\\t\\t\\tout <- i\\n\\t\\t}\\n\\t}\\n}\\n\\n// Generate returns a int slice of prime numbers up to the limit\\nfunc Generate(limit int) []int {\\n\\tvar primes []int\\n\\n\\tch := make(chan int)\\n\\tgo GenerateChannel(ch)\\n\\n\\tfor i := 0; i < limit; i++ {\\n\\t\\tprimes = append(primes, <-ch)\\n\\t\\tch1 := make(chan int)\\n\\t\\tgo Sieve(ch, ch1, primes[i])\\n\\t\\tch = ch1\\n\\t}\\n\\n\\treturn primes\\n}\\n\"",
    "sieve test": "\"// sieve_test.go\\n// description: Testing all the algorithms related to the generation of prime numbers in sieve.go\\n// author(s) [Taj](https://github.com/tjgurwara99)\\n// see sieve.go\\n\\npackage prime\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestSieve(t *testing.T) {\\n\\tfirstTenPrimes := [10]int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\\n\\n\\tt.Run(\\\"First 10 primes test\\\", func(t *testing.T) {\\n\\t\\tvar testTenPrimes [10]int\\n\\n\\t\\tch := make(chan int)\\n\\t\\tgo GenerateChannel(ch)\\n\\n\\t\\tfor i := 0; i < 10; i++ {\\n\\t\\t\\ttestTenPrimes[i] = <-ch\\n\\t\\t\\tch1 := make(chan int)\\n\\t\\t\\tgo Sieve(ch, ch1, testTenPrimes[i])\\n\\t\\t\\tch = ch1\\n\\t\\t}\\n\\n\\t\\tif firstTenPrimes != testTenPrimes {\\n\\t\\t\\tt.Errorf(\\\"The first 10 primes do not match\\\")\\n\\t\\t}\\n\\n\\t})\\n}\\n\\nfunc TestGeneratePrimes(t *testing.T) {\\n\\tfirstTenPrimes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\\n\\n\\tt.Run(\\\"Testing GeneratePrimes Function\\\", func(t *testing.T) {\\n\\t\\ttestPrimes := Generate(10)\\n\\n\\t\\tif !reflect.DeepEqual(firstTenPrimes, testPrimes) {\\n\\t\\t\\tt.Fatal(\\\"GeneratePrimes function failed\\\")\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "pythagoras": "\"package pythagoras\\n\\nimport (\\n\\t\\\"math\\\"\\n)\\n\\n//Vector defines a tuple with 3 values in 3d-space\\ntype Vector struct {\\n\\tx float64\\n\\ty float64\\n\\tz float64\\n}\\n\\n//Distance calculates the distance between to vectors with the   Pythagoras theorem\\nfunc Distance(a, b Vector) float64 {\\n\\tres := math.Pow(b.x-a.x, 2.0) + math.Pow(b.y-a.y, 2.0) + math.Pow(b.z-a.z, 2.0)\\n\\treturn math.Sqrt(res)\\n}\\n\"",
    "pythagoras test": "\"package pythagoras\\n\\nimport (\\n\\t\\\"math\\\"\\n\\t\\\"testing\\\"\\n)\\n\\n// TableDrivenTest for checking multiple values against our Test Function\\nvar distanceTest = []struct {\\n\\tname string\\n\\tv1   Vector\\n\\tv2   Vector\\n\\tres  float64\\n}{\\n\\t{\\\"random negative vector\\\", Vector{2, -1, 7}, Vector{1, -3, 5}, 3.0},\\n\\t{\\\"random wide vectors\\\", Vector{4, 10, 9}, Vector{4, 3, 5}, 8.06},\\n\\t{\\\"random wide vectors\\\", Vector{8, 5, 5}, Vector{1, 1, 12}, 10.67},\\n\\t{\\\"random short vectors\\\", Vector{1, 1, 1}, Vector{2, 2, 2}, 1.73},\\n}\\n\\n//TestDistance tests the Function Distance with 2 vectors\\nfunc TestDistance(t *testing.T) {\\n\\tt.Parallel() // marks TestDistance as capable of running in parallel with other tests\\n\\tfor _, tt := range distanceTest {\\n\\t\\ttt := tt // NOTE: https://github.com/golang/go/wiki/CommonMistakes#using-goroutines-on-loop-iterator-variables\\n\\t\\tt.Run(tt.name, func(t *testing.T) {\\n\\t\\t\\tt.Parallel()\\n\\t\\t\\tres := Distance(tt.v1, tt.v2)           // Calculate result for\\n\\t\\t\\troundRes := (math.Floor(res*100) / 100) // Round to 2 decimal places because we can't compare an infinite number of places\\n\\t\\t\\t// Check result\\n\\t\\t\\tif roundRes != tt.res {\\n\\t\\t\\t\\tt.Errorf(\\\"Distance(%v, %v) = %f, expected %f\\\",\\n\\t\\t\\t\\t\\ttt.v1, tt.v2, roundRes, tt.res)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "max subarray sum": "\"/* O(n) solution, for calculating\\nmaximum contiguous sum in the given array. */\\n\\n// Package maxsubarraysum is a package containing a solution to a common\\n// problem of finding max contiguous sum within a array of ints.\\npackage maxsubarraysum\\n\\nimport (\\n\\t\\\"github.com/TheAlgorithms/Go/math/max\\\"\\n)\\n\\n// MaxSubarraySum returns the maximum subarray sum\\nfunc MaxSubarraySum(array []int) int {\\n\\tvar currentMax int\\n\\tvar maxTillNow int\\n\\tif len(array) != 0 {\\n\\t\\tcurrentMax = array[0]\\n\\t\\tmaxTillNow = array[0]\\n\\t}\\n\\tfor _, v := range array {\\n\\t\\tcurrentMax = max.Int(v, currentMax+v)\\n\\t\\tmaxTillNow = max.Int(maxTillNow, currentMax)\\n\\t}\\n\\treturn maxTillNow\\n}\\n\"",
    "max subarray sum test": "\"package maxsubarraysum\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestMaxSubarraySum(t *testing.T) {\\n\\ttestCases := []struct {\\n\\t\\tname     string\\n\\t\\tslice    []int\\n\\t\\texpected int\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname:     \\\"Empty slice\\\",\\n\\t\\t\\tslice:    []int{},\\n\\t\\t\\texpected: 0,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname:     \\\"Max is 0\\\",\\n\\t\\t\\tslice:    []int{0, -1, -2, -4, -5},\\n\\t\\t\\texpected: 0,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname:     \\\"Max is -1\\\",\\n\\t\\t\\tslice:    []int{-1, -3, -2, -5, -7},\\n\\t\\t\\texpected: -1,\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname:     \\\"Max is 7\\\",\\n\\t\\t\\tslice:    []int{-2, -5, 6, 0, -2, 0, -3, 1, 0, 5, -6},\\n\\t\\t\\texpected: 7,\\n\\t\\t},\\n\\t}\\n\\tfor _, test := range testCases {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tif result := MaxSubarraySum(test.slice); result != test.expected {\\n\\t\\t\\t\\tt.Fatalf(\\\"%s\\\\n\\\\tslice: %v, expected: %v, returned: %v\\\", test.name, test.slice, test.expected, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "nested brackets": "\"// Package nested provides functions for testing\\n// strings proper brackets nesting.\\npackage nested\\n\\n// IsBalanced returns true if provided input string is properly nested.\\n//\\n// Input is a sequence of brackets: '(', ')', '[', ']', '{', '}'.\\n//\\n// A sequence of brackets `s` is considered properly nested\\n// if any of the following conditions are true:\\n// \\t- `s` is empty;\\n// \\t- `s` has the form (U) or [U] or {U} where U is a properly nested string;\\n// \\t- `s` has the form VW where V and W are properly nested strings.\\n//\\n// For example, the string \\\"()()[()]\\\" is properly nested but \\\"[(()]\\\" is not.\\n//\\n// **Note** Providing characters other then brackets would return false,\\n// despite brackets sequence in the string. Make sure to filter\\n// input before usage.\\nfunc IsBalanced(input string) bool {\\n\\tif len(input) == 0 {\\n\\t\\treturn true\\n\\t}\\n\\n\\tif len(input)%2 != 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\t// Brackets such as '{', '[', '(' are valid UTF-8 characters,\\n\\t// which means that only one byte is required to code them,\\n\\t// so can be stored as bytes.\\n\\tvar stack []byte\\n\\n\\tfor i := 0; i < len(input); i++ {\\n\\t\\tif input[i] == '(' || input[i] == '{' || input[i] == '[' {\\n\\t\\t\\tstack = append(stack, input[i])\\n\\t\\t} else {\\n\\t\\t\\tif len(stack) > 0 {\\n\\t\\t\\t\\tpair := string(stack[len(stack)-1]) + string(input[i])\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\n\\t\\t\\t\\tif pair != \\\"[]\\\" && pair != \\\"{}\\\" && pair != \\\"()\\\" {\\n\\t\\t\\t\\t\\t// This means that two types of brackets has\\n\\t\\t\\t\\t\\t// been mixed together, for example \\\"([)]\\\",\\n\\t\\t\\t\\t\\t// which makes seuqence invalid by definition.\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// This means that closing bracket is encountered\\n\\t\\t\\t\\t// before opening one, which makes all sequence\\n\\t\\t\\t\\t// invalid by definition.\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// If sequence is properly nested, all elements in stack\\n\\t// has been paired with closing elements. If even one\\n\\t// element has not been paired with a closing bracket,\\n\\t// means that sequence is invalid by definition.\\n\\treturn len(stack) == 0\\n}\\n\"",
    "nested brackets test": "\"package nested\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestIsBalancedSimple(t *testing.T) {\\n\\tinput := \\\"{[()]}\\\"\\n\\n\\tgot := IsBalanced(input)\\n\\twant := true\\n\\n\\tif got != want {\\n\\t\\tt.Errorf(\\\"\\\\nInput: %s\\\\nGot: %v\\\\nWant: %v\\\\n\\\", input, got, want)\\n\\t}\\n}\\n\\nfunc TestIsBalancedFalty(t *testing.T) {\\n\\tinput := \\\"{([()]}\\\"\\n\\n\\tgot := IsBalanced(input)\\n\\twant := false\\n\\n\\tif got != want {\\n\\t\\tt.Errorf(\\\"\\\\nInput: %s\\\\nGot: %v\\\\nWant: %v\\\\n\\\", input, got, want)\\n\\t}\\n}\\n\\nfunc TestIsBalancedHandlesEmpty(t *testing.T) {\\n\\tinput := \\\"\\\"\\n\\n\\tgot := IsBalanced(input)\\n\\twant := true\\n\\n\\tif got != want {\\n\\t\\tt.Errorf(\\\"\\\\nInput: %s\\\\nGot: %v\\\\nWant: %v\\\\n\\\", input, got, want)\\n\\t}\\n}\\n\\nfunc TestIsBalancedHandlesOneChar(t *testing.T) {\\n\\tinput := \\\"{\\\"\\n\\n\\tgot := IsBalanced(input)\\n\\twant := false\\n\\n\\tif got != want {\\n\\t\\tt.Errorf(\\\"\\\\nInput: %s\\\\nGot: %v\\\\nWant: %v\\\\n\\\", input, got, want)\\n\\t}\\n}\\n\\nfunc TestIsBalancedHandlesNonBracketsCorrectly(t *testing.T) {\\n\\tinput := \\\"aaaa\\\"\\n\\n\\tgot := IsBalanced(input)\\n\\twant := false\\n\\n\\tif got != want {\\n\\t\\tt.Errorf(\\\"\\\\nInput: %s\\\\nGot: %v\\\\nWant: %v\\\\n\\\", input, got, want)\\n\\t}\\n}\\n\\nfunc TestIsBalancedHandlesOrdering(t *testing.T) {\\n\\tinput := \\\"([)]\\\"\\n\\n\\tgot := IsBalanced(input)\\n\\twant := false\\n\\n\\tif got != want {\\n\\t\\tt.Errorf(\\\"\\\\nInput: %s\\\\nGot: %v\\\\nWant: %v\\\\n\\\", input, got, want)\\n\\t}\\n}\\n\\nfunc BenchmarkIsBalanced(b *testing.B) {\\n\\tinput := \\\"{[()]}\\\"\\n\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tIsBalanced(input)\\n\\t}\\n}\\n\"",
    "generator": "\"// This program generates a password from a list of possible chars\\n// You must provide a minimum length and a maximum length\\n// This length is not fixed if you generate multiple passwords for the same range\\n\\n// Package password contains functions to help generate random passwords\\npackage password\\n\\nimport (\\n\\t\\\"crypto/rand\\\"\\n\\t\\\"io\\\"\\n\\t\\\"math/big\\\"\\n)\\n\\n// Generate returns a newly generated password\\nfunc Generate(minLength int, maxLength int) string {\\n\\tvar chars = []byte(\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+,.?/:;{}[]`~\\\")\\n\\n\\tlength, err := rand.Int(rand.Reader, big.NewInt(int64(maxLength-minLength)))\\n\\tif err != nil {\\n\\t\\tpanic(err) // handle this gracefully\\n\\t}\\n\\tlength.Add(length, big.NewInt(int64(minLength)))\\n\\n\\tintLength := int(length.Int64())\\n\\n\\tnewPassword := make([]byte, intLength)\\n\\trandomData := make([]byte, intLength+intLength/4)\\n\\tclen := byte(len(chars))\\n\\tmaxrb := byte(256 - (256 % len(chars)))\\n\\ti := 0\\n\\tfor {\\n\\t\\tif _, err := io.ReadFull(rand.Reader, randomData); err != nil {\\n\\t\\t\\tpanic(err)\\n\\t\\t}\\n\\t\\tfor _, c := range randomData {\\n\\t\\t\\tif c >= maxrb {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tnewPassword[i] = chars[c%clen]\\n\\t\\t\\ti++\\n\\t\\t\\tif i == intLength {\\n\\t\\t\\t\\treturn string(newPassword)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\"",
    "advanced ahocorasick": "\"package ahocorasick\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"time\\\"\\n)\\n\\n// Advanced Function performing the Advanced Aho-Corasick algorithm.\\n// Finds and prints occurrences of each pattern.\\nfunc Advanced(t string, p []string) Result {\\n\\tstartTime := time.Now()\\n\\toccurrences := make(map[int][]int)\\n\\tac, f := BuildExtendedAc(p)\\n\\tcurrent := 0\\n\\tfor pos := 0; pos < len(t); pos++ {\\n\\t\\tif GetTransition(current, t[pos], ac) != -1 {\\n\\t\\t\\tcurrent = GetTransition(current, t[pos], ac)\\n\\t\\t} else {\\n\\t\\t\\tcurrent = 0\\n\\t\\t}\\n\\t\\t_, ok := f[current]\\n\\t\\tif ok {\\n\\t\\t\\tfor i := range f[current] {\\n\\t\\t\\t\\tif p[f[current][i]] == GetWord(pos-len(p[f[current][i]])+1, pos, t) { //check for word match\\n\\t\\t\\t\\t\\tnewOccurrences := IntArrayCapUp(occurrences[f[current][i]])\\n\\t\\t\\t\\t\\toccurrences[f[current][i]] = newOccurrences\\n\\t\\t\\t\\t\\toccurrences[f[current][i]][len(newOccurrences)-1] = pos - len(p[f[current][i]]) + 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\telapsed := time.Since(startTime)\\n\\tfmt.Printf(\\\"\\\\n\\\\nElapsed %f secs\\\\n\\\", elapsed.Seconds())\\n\\n\\tvar resultOccurrences = make(map[string][]int)\\n\\tfor key, value := range occurrences {\\n\\t\\tresultOccurrences[p[key]] = value\\n\\t}\\n\\n\\treturn Result{\\n\\t\\tresultOccurrences,\\n\\t}\\n}\\n\\n// BuildExtendedAc Functions that builds extended Aho Corasick automaton.\\nfunc BuildExtendedAc(p []string) (acToReturn map[int]map[uint8]int, f map[int][]int) {\\n\\tacTrie, stateIsTerminal, f := ConstructTrie(p)\\n\\ts := make([]int, len(stateIsTerminal)) //supply function\\n\\ti := 0                                 //root of acTrie\\n\\tacToReturn = acTrie\\n\\ts[i] = -1\\n\\tfor current := 1; current < len(stateIsTerminal); current++ {\\n\\t\\to, parent := GetParent(current, acTrie)\\n\\t\\tdown := s[parent]\\n\\t\\tfor StateExists(down, acToReturn) && GetTransition(down, o, acToReturn) == -1 {\\n\\t\\t\\tdown = s[down]\\n\\t\\t}\\n\\t\\tif StateExists(down, acToReturn) {\\n\\t\\t\\ts[current] = GetTransition(down, o, acToReturn)\\n\\t\\t\\tif stateIsTerminal[s[current]] {\\n\\t\\t\\t\\tstateIsTerminal[current] = true\\n\\t\\t\\t\\tf[current] = ArrayUnion(f[current], f[s[current]]) //F(Current) <- F(Current) union F(S(Current))\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\ts[current] = i //initial state?\\n\\t\\t}\\n\\t}\\n\\ta := ComputeAlphabet(p) // concat of all patterns in p\\n\\tfor j := range a {\\n\\t\\tif GetTransition(i, a[j], acToReturn) == -1 {\\n\\t\\t\\tCreateTransition(i, a[j], i, acToReturn)\\n\\t\\t}\\n\\t}\\n\\tfor current := 1; current < len(stateIsTerminal); current++ {\\n\\t\\tfor j := range a {\\n\\t\\t\\tif GetTransition(current, a[j], acToReturn) == -1 {\\n\\t\\t\\t\\tCreateTransition(current, a[j], GetTransition(s[current], a[j], acToReturn), acToReturn)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn acToReturn, f\\n}\\n\"",
    "advanced ahocorasick test": "\"package ahocorasick\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nvar testCases = []struct {\\n\\tname     string\\n\\twords    []string\\n\\ttext     string\\n\\texpected Result\\n}{\\n\\n\\t{\\n\\t\\t\\\"String comparison on all patterns found\\\",\\n\\t\\t[]string{\\\"announce\\\", \\\"annual\\\", \\\"annually\\\"},\\n\\t\\t\\\"CPM_annual_conferenceannounce_announce_annually_announce\\\",\\n\\t\\tResult{\\n\\t\\t\\tmap[string][]int{\\n\\t\\t\\t\\t\\\"annual\\\":   {4, 39},\\n\\t\\t\\t\\t\\\"announce\\\": {21, 30, 48},\\n\\t\\t\\t\\t\\\"annually\\\": {39},\\n\\t\\t\\t},\\n\\t\\t},\\n\\t},\\n\\t{\\n\\t\\t\\\"String comparison on not all patterns found\\\",\\n\\t\\t[]string{\\\"announce\\\", \\\"annual\\\", \\\"annually\\\"},\\n\\t\\t\\\"CPM_annual_conference_announce\\\",\\n\\t\\tResult{\\n\\t\\t\\tmap[string][]int{\\n\\t\\t\\t\\t\\\"annual\\\":   {4},\\n\\t\\t\\t\\t\\\"announce\\\": {22},\\n\\t\\t\\t},\\n\\t\\t},\\n\\t},\\n\\t{\\n\\t\\t\\\"String comparison on not all patterns found\\\",\\n\\t\\t[]string{\\\"announce\\\", \\\"annual\\\", \\\"annually\\\"},\\n\\t\\t\\\"CPM_annual_conference_announce\\\",\\n\\t\\tResult{\\n\\t\\t\\tmap[string][]int{\\n\\t\\t\\t\\t\\\"annual\\\":   {4},\\n\\t\\t\\t\\t\\\"announce\\\": {22},\\n\\t\\t\\t},\\n\\t\\t},\\n\\t},\\n}\\n\\nfunc TestAdvanced(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := AhoCorasick(tc.text, tc.words)\\n\\t\\t\\tif !reflect.DeepEqual(actual, tc.expected) {\\n\\t\\t\\t\\tactualString := convertToString(actual)\\n\\t\\t\\t\\texpectedString := convertToString(tc.expected)\\n\\t\\t\\t\\tt.Errorf(\\\"Expected matches for patterns %s for string '%s' are: patterns and positions found %v, but actual matches are: patterns and positions found %v\\\",\\n\\t\\t\\t\\t\\ttc.words, tc.text, actualString, expectedString)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "ahocorasick": "\"package ahocorasick\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"time\\\"\\n)\\n\\n// Result structure to hold occurrences\\ntype Result struct {\\n\\toccurrences map[string][]int\\n}\\n\\n// AhoCorasick Function performing the Basic Aho-Corasick algorithm.\\n// Finds and prints occurrences of each pattern.\\nfunc AhoCorasick(t string, p []string) Result {\\n\\tstartTime := time.Now()\\n\\toccurrences := make(map[int][]int)\\n\\tac, f, s := BuildAc(p)\\n\\tcurrent := 0\\n\\tfor pos := 0; pos < len(t); pos++ {\\n\\t\\tfor GetTransition(current, t[pos], ac) == -1 && s[current] != -1 {\\n\\t\\t\\tcurrent = s[current]\\n\\t\\t}\\n\\t\\tif GetTransition(current, t[pos], ac) != -1 {\\n\\t\\t\\tcurrent = GetTransition(current, t[pos], ac)\\n\\t\\t\\tfmt.Printf(\\\" (Continue) \\\\n\\\")\\n\\t\\t} else {\\n\\t\\t\\tcurrent = 0\\n\\t\\t}\\n\\t\\t_, ok := f[current]\\n\\t\\tif ok {\\n\\t\\t\\tfor i := range f[current] {\\n\\t\\t\\t\\tif p[f[current][i]] == GetWord(pos-len(p[f[current][i]])+1, pos, t) { //check for word match\\n\\t\\t\\t\\t\\tnewOccurrences := IntArrayCapUp(occurrences[f[current][i]])\\n\\t\\t\\t\\t\\toccurrences[f[current][i]] = newOccurrences\\n\\t\\t\\t\\t\\toccurrences[f[current][i]][len(newOccurrences)-1] = pos - len(p[f[current][i]]) + 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\telapsed := time.Since(startTime)\\n\\tfmt.Printf(\\\"\\\\n\\\\nElapsed %f secs\\\\n\\\", elapsed.Seconds())\\n\\tvar resultOccurrences = make(map[string][]int)\\n\\tfor key, value := range occurrences {\\n\\t\\tresultOccurrences[p[key]] = value\\n\\t}\\n\\n\\treturn Result{\\n\\t\\tresultOccurrences,\\n\\t}\\n}\\n\\n// Functions that builds Aho Corasick automaton.\\nfunc BuildAc(p []string) (acToReturn map[int]map[uint8]int, f map[int][]int, s []int) {\\n\\tacTrie, stateIsTerminal, f := ConstructTrie(p)\\n\\ts = make([]int, len(stateIsTerminal)) //supply function\\n\\ti := 0                                //root of acTrie\\n\\tacToReturn = acTrie\\n\\ts[i] = -1\\n\\tfor current := 1; current < len(stateIsTerminal); current++ {\\n\\t\\to, parent := GetParent(current, acTrie)\\n\\t\\tdown := s[parent]\\n\\t\\tfor StateExists(down, acToReturn) && GetTransition(down, o, acToReturn) == -1 {\\n\\t\\t\\tdown = s[down]\\n\\t\\t}\\n\\t\\tif StateExists(down, acToReturn) {\\n\\t\\t\\ts[current] = GetTransition(down, o, acToReturn)\\n\\t\\t\\tif stateIsTerminal[s[current]] {\\n\\t\\t\\t\\tstateIsTerminal[current] = true\\n\\t\\t\\t\\tf[current] = ArrayUnion(f[current], f[s[current]]) //F(Current) <- F(Current) union F(S(Current))\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\ts[current] = i //initial state?\\n\\t\\t}\\n\\t}\\n\\treturn acToReturn, f, s\\n}\\n\"",
    "ahocorasick test": "\"package ahocorasick\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"reflect\\\"\\n\\t\\\"strings\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestAhoCorasick(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := AhoCorasick(tc.text, tc.words)\\n\\t\\t\\tif !reflect.DeepEqual(actual, tc.expected) {\\n\\t\\t\\t\\tactualString := convertToString(actual)\\n\\t\\t\\t\\texpectedString := convertToString(tc.expected)\\n\\t\\t\\t\\tt.Errorf(\\\"Expected matches for patterns %s for string '%s' are: patterns and positions found %v, but actual matches are: patterns and positions found %v\\\",\\n\\t\\t\\t\\t\\ttc.words, tc.text, actualString, expectedString)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc convertToString(res Result) string {\\n\\tvar r strings.Builder\\n\\tfor key, val := range res.occurrences {\\n\\t\\tr.WriteString(fmt.Sprintf(\\\"Word: '%s' at positions: \\\", key))\\n\\t\\tfor i := range val {\\n\\t\\t\\tr.WriteString(fmt.Sprintf(\\\"%d\\\", val[i]))\\n\\t\\t\\tif i != len(val)-1 {\\n\\t\\t\\t\\tr.WriteString(\\\", \\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tr.WriteString(\\\". \\\")\\n\\t}\\n\\treturn r.String()\\n}\\n\"",
    "patterns": "\"announce annual annually\"",
    "shared": "\"package ahocorasick\\n\\n// ConstructTrie Function that constructs Trie as an automaton for a set of reversed & trimmed strings.\\nfunc ConstructTrie(p []string) (trie map[int]map[uint8]int, stateIsTerminal []bool, f map[int][]int) {\\n\\ttrie = make(map[int]map[uint8]int)\\n\\tstateIsTerminal = make([]bool, 1)\\n\\tf = make(map[int][]int)\\n\\tstate := 1\\n\\tCreateNewState(0, trie)\\n\\tfor i := 0; i < len(p); i++ {\\n\\t\\tcurrent := 0\\n\\t\\tj := 0\\n\\t\\tfor j < len(p[i]) && GetTransition(current, p[i][j], trie) != -1 {\\n\\t\\t\\tcurrent = GetTransition(current, p[i][j], trie)\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t\\tfor j < len(p[i]) {\\n\\t\\t\\tstateIsTerminal = BoolArrayCapUp(stateIsTerminal)\\n\\t\\t\\tCreateNewState(state, trie)\\n\\t\\t\\tstateIsTerminal[state] = false\\n\\t\\t\\tCreateTransition(current, p[i][j], state, trie)\\n\\t\\t\\tcurrent = state\\n\\t\\t\\tj++\\n\\t\\t\\tstate++\\n\\t\\t}\\n\\t\\tif stateIsTerminal[current] {\\n\\t\\t\\tnewArray := IntArrayCapUp(f[current])\\n\\t\\t\\tnewArray[len(newArray)-1] = i\\n\\t\\t\\tf[current] = newArray // F(Current) <- F(Current) union {i}\\n\\t\\t} else {\\n\\t\\t\\tstateIsTerminal[current] = true\\n\\t\\t\\tf[current] = []int{i} // F(Current) <- {i}\\n\\t\\t}\\n\\t}\\n\\treturn trie, stateIsTerminal, f\\n}\\n\\n// Contains Returns 'true' if array of int's 's' contains int 'e', 'false' otherwise.\\nfunc Contains(s []int, e int) bool {\\n\\tfor _, a := range s {\\n\\t\\tif a == e {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n// GetWord Function that returns word found in text 't' at position range 'begin' to 'end'.\\nfunc GetWord(begin, end int, t string) string {\\n\\tfor end >= len(t) {\\n\\t\\treturn \\\"\\\"\\n\\t}\\n\\td := make([]uint8, end-begin+1)\\n\\tfor j, i := 0, begin; i <= end; i, j = i+1, j+1 {\\n\\t\\td[j] = t[i]\\n\\t}\\n\\treturn string(d)\\n}\\n\\n// ComputeAlphabet Function that returns string of all the possible characters in given patterns.\\nfunc ComputeAlphabet(p []string) (s string) {\\n\\ts = p[0]\\n\\tfor i := 1; i < len(p); i++ {\\n\\t\\ts = s + p[i]\\n\\t}\\n\\treturn s\\n}\\n\\n// IntArrayCapUp Dynamically increases an array size of int's by 1.\\nfunc IntArrayCapUp(old []int) (new []int) {\\n\\tnew = make([]int, cap(old)+1)\\n\\tcopy(new, old) //copy(dst,src)\\n\\t// old = new\\n\\treturn new\\n}\\n\\n// BoolArrayCapUp Dynamically increases an array size of bool's by 1.\\nfunc BoolArrayCapUp(old []bool) (new []bool) {\\n\\tnew = make([]bool, cap(old)+1)\\n\\tcopy(new, old)\\n\\t// old = new\\n\\treturn new\\n}\\n\\n// ArrayUnion Concats two arrays of int's into one.\\nfunc ArrayUnion(to, from []int) (concat []int) {\\n\\tconcat = to\\n\\tfor i := range from {\\n\\t\\tif !Contains(concat, from[i]) {\\n\\t\\t\\tconcat = IntArrayCapUp(concat)\\n\\t\\t\\tconcat[len(concat)-1] = from[i]\\n\\t\\t}\\n\\t}\\n\\treturn concat\\n}\\n\\n// GetParent Function that finds the first previous state of a state and returns it.\\n// Used for trie where there is only one parent.\\nfunc GetParent(state int, at map[int]map[uint8]int) (uint8, int) {\\n\\tfor beginState, transitions := range at {\\n\\t\\tfor c, endState := range transitions {\\n\\t\\t\\tif endState == state {\\n\\t\\t\\t\\treturn c, beginState\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0, 0 //unreachable\\n}\\n\\n// CreateNewState Automaton function for creating a new state 'state'.\\nfunc CreateNewState(state int, at map[int]map[uint8]int) {\\n\\tat[state] = make(map[uint8]int)\\n}\\n\\n// CreateTransition Creates a transition for function σ(state,letter) = end.\\nfunc CreateTransition(fromState int, overChar uint8, toState int, at map[int]map[uint8]int) {\\n\\tat[fromState][overChar] = toState\\n}\\n\\n// GetTransition Returns ending state for transition σ(fromState,overChar), '-1' if there is none.\\nfunc GetTransition(fromState int, overChar uint8, at map[int]map[uint8]int) (toState int) {\\n\\tif !StateExists(fromState, at) {\\n\\t\\treturn -1\\n\\t}\\n\\ttoState, ok := at[fromState][overChar]\\n\\tif !ok {\\n\\t\\treturn -1\\n\\t}\\n\\treturn toState\\n}\\n\\n// StateExists Checks if state 'state' exists. Returns 'true' if it does, 'false' otherwise.\\nfunc StateExists(state int, at map[int]map[uint8]int) bool {\\n\\t_, ok := at[state]\\n\\tif !ok || state == -1 || at[state] == nil {\\n\\t\\treturn false\\n\\t}\\n\\treturn true\\n}\\n\"",
    "text": "\"CPM_annual_conference_announce\"",
    "bom": "\"package bom\\n\\n// User defined.\\n// Set to true to print various extra stuff out (slows down the execution)\\n// Set to false for quick and quiet execution.\\n// const debugMode bool = false\\n\\n// User defined.\\n// Set to true to read input from two command line arguments\\n// Set to false to read input from two files \\\"pattern.txt\\\" and \\\"text.txt\\\"\\n// const commandLineInput bool = false\\n\\n// Implementation of Backward Oracle Matching algorithm (Factor based approach).\\n// Requires either a two command line arguments separated by a single space,\\n// or two files in the same folder: \\\"pattern.txt\\\" containing the string to\\n// be searched for, \\\"text.txt\\\" containing the text to be searched in.\\n// func main() {\\n// \\tif commandLineInput == true { // case of command line input\\n// \\t\\targs := os.Args\\n// \\t\\tif len(args) <= 2 {\\n// \\t\\t\\tlog.Fatal(\\\"Not enough arguments. Two string arguments separated by spaces are required!\\\")\\n// \\t\\t}\\n// \\t\\tpattern := args[1]\\n// \\t\\ts := args[2]\\n// \\t\\tfor i := 3; i < len(args); i++ {\\n// \\t\\t\\ts = s + \\\" \\\" + args[i]\\n// \\t\\t}\\n// \\t\\tif len(args[1]) > len(s) {\\n// \\t\\t\\tlog.Fatal(\\\"Pattern  is longer than text!\\\")\\n// \\t\\t}\\n// \\t\\tif debugMode == true {\\n// \\t\\t\\tfmt.Printf(\\\"\\\\nRunning: Backward Oracle Matching algorithm.\\\\n\\\\n\\\")\\n// \\t\\t\\tfmt.Printf(\\\"Search word (%d chars long): %q.\\\\n\\\", len(args[1]), pattern)\\n// \\t\\t\\tfmt.Printf(\\\"Text        (%d chars long): %q.\\\\n\\\\n\\\", len(s), s)\\n// \\t\\t} else {\\n// \\t\\t\\tfmt.Printf(\\\"\\\\nRunning: Backward Oracle Matching algorithm.\\\\n\\\\n\\\")\\n// \\t\\t}\\n// \\t\\tbom(s, pattern)\\n// \\t} else if commandLineInput == false { // case of file line input\\n// \\t\\tpatFile, err := ioutil.ReadFile(\\\"pattern.txt\\\")\\n// \\t\\tif err != nil {\\n// \\t\\t\\tlog.Fatal(err)\\n// \\t\\t}\\n// \\t\\ttextFile, err := ioutil.ReadFile(\\\"text.txt\\\")\\n// \\t\\tif err != nil {\\n// \\t\\t\\tlog.Fatal(err)\\n// \\t\\t}\\n// \\t\\tif len(patFile) > len(textFile) {\\n// \\t\\t\\tlog.Fatal(\\\"Pattern  is longer than text!\\\")\\n// \\t\\t}\\n// \\t\\tif debugMode == true {\\n// \\t\\t\\tfmt.Printf(\\\"\\\\nRunning: Backward Oracle Matching algorithm.\\\\n\\\\n\\\")\\n// \\t\\t\\tfmt.Printf(\\\"Search word (%d chars long): %q.\\\\n\\\", len(patFile), patFile)\\n// \\t\\t\\tfmt.Printf(\\\"Text        (%d chars long): %q.\\\\n\\\\n\\\", len(textFile), textFile)\\n// \\t\\t} else {\\n// \\t\\t\\tfmt.Printf(\\\"\\\\nRunning: Backward Oracle Matching algorithm.\\\\n\\\\n\\\")\\n// \\t\\t}\\n// \\t\\tbom(string(textFile), string(patFile))\\n// \\t}\\n// }\\n\\n// // Function bom performing the Backward Oracle Matching algorithm.\\n// // Prints whether the word/pattern was found + positions of possible multiple occurrences\\n// // or that the word was not found.\\n// func bom(t, p string) {\\n// \\tstartTime := time.Now()\\n// \\tn, m := len(t), len(p)\\n// \\tvar current, j, pos int\\n// \\toracle := oracleOnLine(reverse(p))\\n// \\toccurrences := make([]int, len(t))\\n// \\tcurrentOcc := 0\\n// \\tpos = 0\\n// \\tif debugMode == true {\\n// \\t\\tfmt.Printf(\\\"\\\\n\\\\nWe are reading backwards in %q, searching for %q\\\\n\\\\nat position %d:\\\\n\\\", t, p, pos+m-1)\\n// \\t}\\n// \\tfor pos <= n-m {\\n// \\t\\tcurrent = 0 //initial state of the oracle\\n// \\t\\tj = m\\n// \\t\\tfor j > 0 && stateExists(current, oracle) {\\n// \\t\\t\\tif debugMode == true {\\n// \\t\\t\\t\\tprettyPrint(current, j, n, pos, t, oracle)\\n// \\t\\t\\t}\\n// \\t\\t\\tcurrent = getTransition(current, t[pos+j-1], oracle)\\n// \\t\\t\\tj--\\n// \\t\\t}\\n// \\t\\tif stateExists(current, oracle) {\\n// \\t\\t\\tif debugMode == true {\\n// \\t\\t\\t\\tfmt.Printf(\\\" We got an occurrence!\\\")\\n// \\t\\t\\t}\\n// \\t\\t\\toccurrences[currentOcc] = pos\\n// \\t\\t\\tcurrentOcc++\\n// \\t\\t}\\n// \\t\\tpos = pos + j + 1\\n// \\t\\tif pos+m-1 < len(t) {\\n// \\t\\t\\tif debugMode == true {\\n// \\t\\t\\t\\tfmt.Printf(\\\"\\\\n\\\\nposition %d:\\\\n\\\", pos+m-1)\\n// \\t\\t\\t}\\n// \\t\\t}\\n// \\t}\\n// \\telapsed := time.Since(startTime)\\n// \\tfmt.Printf(\\\"\\\\n\\\\nElapsed %f secs\\\\n\\\", elapsed.Seconds())\\n// \\tfmt.Printf(\\\"\\\\n\\\\n\\\")\\n// \\tif currentOcc > 0 {\\n// \\t\\tfmt.Printf(\\\"Word %q was found %d times at positions: \\\", p, currentOcc)\\n// \\t\\tfor k := 0; k < currentOcc-1; k++ {\\n// \\t\\t\\tfmt.Printf(\\\"%d, \\\", occurrences[k])\\n// \\t\\t}\\n// \\t\\tfmt.Printf(\\\"%d\\\", occurrences[currentOcc-1])\\n// \\t\\tfmt.Printf(\\\".\\\\n\\\")\\n// \\t}\\n// \\tif currentOcc == 0 {\\n// \\t\\tfmt.Printf(\\\"\\\\nWord was not found.\\\\n\\\")\\n// \\t}\\n// \\treturn\\n// }\\n\\n// // Construction of the factor oracle automaton for a word p.\\n// func oracleOnLine(p string) (oracle map[int]map[uint8]int) {\\n// \\tif debugMode == true {\\n// \\t\\tfmt.Printf(\\\"Oracle construction: \\\\n\\\")\\n// \\t}\\n// \\toracle = make(map[int]map[uint8]int)\\n// \\tsupply := make([]int, len(p)+2) // supply function\\n// \\tcreateNewState(0, oracle)\\n// \\tsupply[0] = -1\\n// \\tvar orP string\\n// \\tfor j := 0; j < len(p); j++ {\\n// \\t\\toracle, orP = oracleAddLetter(oracle, supply, orP, p[j])\\n// \\t}\\n// \\treturn oracle\\n// }\\n\\n// // Adds one letter to the oracle.\\n// func oracleAddLetter(oracle map[int]map[uint8]int, supply []int, orP string, o uint8) (oracleToReturn map[int]map[uint8]int, orPToReturn string) {\\n// \\tm := len(orP)\\n// \\tvar s int\\n// \\tcreateNewState(m+1, oracle)\\n// \\tcreateTransition(m, o, m+1, oracle)\\n// \\tk := supply[m]\\n// \\tfor k > -1 && getTransition(k, o, oracle) == -1 {\\n// \\t\\tcreateTransition(k, o, m+1, oracle)\\n// \\t\\tk = supply[k]\\n// \\t}\\n// \\tif k == -1 {\\n// \\t\\ts = 0\\n// \\t} else {\\n// \\t\\ts = getTransition(k, o, oracle)\\n// \\t}\\n// \\tsupply[m+1] = s\\n// \\treturn oracle, orP + string(o)\\n// }\\n\\n// // Function that takes a single string and reverses it.\\n// // @author 'Walter' http://stackoverflow.com/a/10043083\\n// func reverse(s string) string {\\n// \\tl := len(s)\\n// \\tm := make([]rune, l)\\n// \\tfor _, c := range s {\\n// \\t\\tl--\\n// \\t\\tm[l] = c\\n// \\t}\\n// \\treturn string(m)\\n// }\\n\\n// // Automaton function for creating a new state.\\n// func createNewState(state int, at map[int]map[uint8]int) {\\n// \\tat[state] = make(map[uint8]int)\\n// \\tif debugMode == true {\\n// \\t\\tfmt.Printf(\\\"\\\\ncreated state %d\\\", state)\\n// \\t}\\n// }\\n\\n// // Creates a transition for function σ(state,letter) = end.\\n// func createTransition(fromState int, overChar uint8, toState int, at map[int]map[uint8]int) {\\n// \\tat[fromState][overChar] = toState\\n// \\tif debugMode == true {\\n// \\t\\tfmt.Printf(\\\"\\\\n    σ(%d,%c)=%d;\\\", fromState, overChar, toState)\\n// \\t}\\n// }\\n\\n// // Returns ending state for transition σ(fromState,overChar), -1 if there is none.\\n// func getTransition(fromState int, overChar uint8, at map[int]map[uint8]int) (toState int) {\\n// \\tif !stateExists(fromState, at) {\\n// \\t\\treturn -1\\n// \\t}\\n// \\ttoState, ok := at[fromState][overChar]\\n// \\tif ok == false {\\n// \\t\\treturn -1\\n// \\t}\\n// \\treturn toState\\n// }\\n\\n// // Checks if state exists. Returns true if it does, false otherwise.\\n// func stateExists(state int, at map[int]map[uint8]int) bool {\\n// \\t_, ok := at[state]\\n// \\tif !ok || state == -1 || at[state] == nil {\\n// \\t\\treturn false\\n// \\t}\\n// \\treturn true\\n// }\\n\\n// // Just some printing of extra information about what the algorithm does.\\n// func prettyPrint(current int, j int, n int, pos int, t string, oracle map[int]map[uint8]int) {\\n// \\tif current == 0 && !(getTransition(current, t[pos+j-1], oracle) == -1) {\\n// \\t\\tfmt.Printf(\\\"\\\\n -->(%d)---(%c)--->(%d)\\\", current, t[pos+j-1], getTransition(current, t[pos+j-1], oracle))\\n// \\t} else if getTransition(current, t[pos+j-1], oracle) == -1 && current != 0 {\\n// \\t\\tfmt.Printf(\\\"\\\\n    (%d)---(%c)       \\\", current, t[pos+j-1])\\n// \\t} else if getTransition(current, t[pos+j-1], oracle) == -1 && current == 0 {\\n// \\t\\tfmt.Printf(\\\"\\\\n -->(%d)---(%c)       \\\", current, t[pos+j-1])\\n// \\t} else {\\n// \\t\\tfmt.Printf(\\\"\\\\n    (%d)---(%c)--->(%d)\\\", current, t[pos+j-1], getTransition(current, t[pos+j-1], oracle))\\n// \\t}\\n// \\tfmt.Printf(\\\" \\\")\\n// \\tfor a := 0; a < pos+j-1; a++ {\\n// \\t\\tfmt.Printf(\\\"%c\\\", t[a])\\n// \\t}\\n// \\tif getTransition(current, t[pos+j-1], oracle) == -1 {\\n// \\t\\tfmt.Printf(\\\"[%c]\\\", t[pos+j-1])\\n// \\t} else {\\n// \\t\\tfmt.Printf(\\\"[%c]\\\", t[pos+j-1])\\n// \\t}\\n// \\tfor a := pos + j; a < n; a++ {\\n// \\t\\tfmt.Printf(\\\"%c\\\", t[a])\\n// \\t}\\n// \\tif getTransition(current, t[pos+j-1], oracle) == -1 {\\n// \\t\\tfmt.Printf(\\\" FAIL on the character[%c]\\\", t[pos+j-1])\\n// \\t}\\n// }\\n\"",
    "combination": "\"// Package combination ...\\npackage combination\\n\\nimport \\\"fmt\\\"\\n\\n// Combinations structure with in and out rune\\ntype Combinations struct {\\n\\tout []rune\\n\\tin  []rune\\n}\\n\\n// Start ...\\nfunc Start(input string) {\\n\\tc := &Combinations{\\n\\t\\tin: []rune(input),\\n\\t}\\n\\n\\tc.Combine(0)\\n}\\n\\n// Combine ...\\nfunc (c *Combinations) Combine(seed int) {\\n\\tinLen := len(c.in)\\n\\tfor i := seed; i < inLen-1; i++ {\\n\\t\\tc.out = append(c.out, c.in[i])\\n\\t\\tfmt.Println(string(c.out))\\n\\t\\tc.Combine(i + 1)\\n\\t\\tc.out = c.out[:len(c.out)-1]\\n\\t}\\n\\tc.out = append(c.out, c.in[inLen-1])\\n\\tfmt.Println(string(c.out))\\n\\tc.out = c.out[:len(c.out)-1]\\n}\\n\"",
    "generate parentheses": "\"// generateparenthesesgo\\n// description: Generate Parentheses\\n// details:\\n// Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see generateparentheses_test.go\\n\\npackage generateparentheses\\n\\nimport \\\"strings\\\"\\n\\nfunc GenerateParenthesis(n int) []string {\\n\\tresult := make([]string, 0)\\n\\tmaxLen := 2 * n\\n\\tvar recursiveComputation func(s []string, left int, right int)\\n\\trecursiveComputation = func(s []string, left int, right int) {\\n\\t\\tif len(s) == maxLen {\\n\\t\\t\\tresult = append(result, strings.Join(s, \\\"\\\"))\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif left < n {\\n\\t\\t\\ts = append(s, \\\"(\\\")\\n\\t\\t\\trecursiveComputation(s, left+1, right)\\n\\t\\t\\ts = s[:len(s)-1]\\n\\t\\t}\\n\\t\\tif right < left {\\n\\t\\t\\ts = append(s, \\\")\\\")\\n\\t\\t\\trecursiveComputation(s, left, right+1)\\n\\t\\t\\t_ = s[:len(s)-1]\\n\\t\\t}\\n\\t}\\n\\trecursiveComputation(make([]string, 0), 0, 0)\\n\\treturn result\\n}\\n\"",
    "generate parentheses test": "\"// generateparentheses_test.go\\n// description: Generate Parentheses\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see generateparentheses.go\\n\\npackage generateparentheses\\n\\nimport \\\"testing\\\"\\n\\nfunc TestGenerateParenthesis(t *testing.T) {\\n\\tt.Run(\\\"GenerateParenthesis\\\", func(t *testing.T) {\\n\\t\\tresult := GenerateParenthesis(3)\\n\\t\\tt.Log(result)\\n\\t\\texp := []string{\\\"((()))\\\", \\\"(()())\\\", \\\"(())()\\\", \\\"()(())\\\", \\\"()()()\\\"}\\n\\t\\tfor i, v := range result {\\n\\t\\t\\tif v != exp[i] {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%s, returned:%s \\\", result[i], exp[i])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "genetic": "\"// Package genetic provides functions to work with strings\\n// using genetic algorithm. https://en.wikipedia.org/wiki/Genetic_algorithm\\n//\\n// Author: D4rkia\\npackage genetic\\n\\nimport (\\n\\t\\\"errors\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"math/rand\\\"\\n\\t\\\"sort\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"time\\\"\\n\\t\\\"unicode/utf8\\\"\\n)\\n\\n// Population item represent a single step in the evolution process.\\n// One can think of population item as a single species.\\n// Key stands for the actual data entity of the species, which is a string\\n// in current implementation. Key can be interpreted as species DNA.\\n// Value shows how close this species to the desired target, where 1 means,\\n// that species DNA equals to the targeted one, 0 for no matchings in the DNA.\\n//\\n// **Note** In the current implementation species DNA length is suppose to be\\n// equal to the target length for algorithm to work.\\ntype PopulationItem struct {\\n\\tKey   string\\n\\tValue float64\\n}\\n\\n// Conf stands for cofigurations set provided to GeneticString function.\\ntype Conf struct {\\n\\t// Maximum size of the population.\\n\\t// Bigger could be faster but more memory expensive.\\n\\tPopulationNum int\\n\\n\\t// Number of elements selected in every generation for evolution\\n\\t// the selection takes. Place from the best to the worst of that\\n\\t// generation must be smaller than PopulationNum.\\n\\tSelectionNum int\\n\\n\\t// Probability that an element of a generation can mutate changing one of\\n\\t// its genes this guarantees that all genes will be used during evolution.\\n\\tMutationProb float64\\n\\n\\t// Enables debugging output to the console.\\n\\tDebug bool\\n}\\n\\n// Result structure contains generation process statistics, as well as the\\n// best resulted population item.\\ntype Result struct {\\n\\t// Number of generations steps performed.\\n\\tGeneration int\\n\\n\\t// Number of generated population items.\\n\\tAnalyzed int\\n\\n\\t// Result of generation with the best Value.\\n\\tBest PopulationItem\\n}\\n\\n// GeneticString generates PopultaionItem based on the imputed target\\n// string, and a set of possible runes to build a string with. In order\\n// to optimise string generation additional configurations can be provided\\n// with Conf instance. Empty instance of Conf (&Conf{}) can be provided,\\n// then default values would be set.\\n//\\n// Link to the same algorithm implemented in python:\\n// https://github.com/TheAlgorithms/Python/blob/master/genetic_algorithm/basic_string.py\\nfunc GeneticString(target string, charmap []rune, conf *Conf) (*Result, error) {\\n\\tpopulationNum := conf.PopulationNum\\n\\tif populationNum == 0 {\\n\\t\\tpopulationNum = 200\\n\\t}\\n\\n\\tselectionNum := conf.SelectionNum\\n\\tif selectionNum == 0 {\\n\\t\\tselectionNum = 50\\n\\t}\\n\\n\\t// Verify if 'populationNum' s bigger than 'selectionNum'\\n\\tif populationNum < selectionNum {\\n\\t\\treturn nil, errors.New(\\\"populationNum must be bigger than selectionNum\\\")\\n\\t}\\n\\n\\tmutationProb := conf.MutationProb\\n\\tif mutationProb == .0 {\\n\\t\\tmutationProb = .4\\n\\t}\\n\\n\\tdebug := conf.Debug\\n\\n\\t// Just a seed to improve randomness required by the algorithm\\n\\trand.Seed(time.Now().UnixNano())\\n\\n\\t// Verify that the target contains no genes besides the ones inside genes variable.\\n\\tfor position, r := range target {\\n\\t\\tinvalid := true\\n\\t\\tfor _, n := range charmap {\\n\\t\\t\\tif n == r {\\n\\t\\t\\t\\tinvalid = false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif invalid {\\n\\t\\t\\tmessage := fmt.Sprintf(\\\"character not available in charmap at position: %v\\\", position)\\n\\t\\t\\treturn nil, errors.New(message)\\n\\t\\t}\\n\\t}\\n\\n\\t// Generate random starting population\\n\\tpop := make([]PopulationItem, populationNum)\\n\\tfor i := 0; i < populationNum; i++ {\\n\\t\\tkey := \\\"\\\"\\n\\t\\tfor x := 0; x < utf8.RuneCountInString(target); x++ {\\n\\t\\t\\tchoice := rand.Intn(len(charmap))\\n\\t\\t\\tkey += string(charmap[choice])\\n\\t\\t}\\n\\t\\tpop[i] = PopulationItem{key, 0}\\n\\t}\\n\\n\\t// Just some logs to know what the algorithms is doing\\n\\tgen, generatedPop := 0, 0\\n\\n\\t// This loop will end when we will find a perfect match for our target\\n\\tfor {\\n\\t\\tgen++\\n\\t\\tgeneratedPop += len(pop)\\n\\n\\t\\t// Random population created now it's time to evaluate\\n\\t\\tfor i, item := range pop {\\n\\t\\t\\tpop[i].Value = 0\\n\\t\\t\\titemKey, targetRune := []rune(item.Key), []rune(target)\\n\\t\\t\\tfor x := 0; x < len(target); x++ {\\n\\t\\t\\t\\tif itemKey[x] == targetRune[x] {\\n\\t\\t\\t\\t\\tpop[i].Value++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tpop[i].Value = pop[i].Value / float64(len(targetRune))\\n\\t\\t}\\n\\t\\tsort.SliceStable(pop, func(i, j int) bool { return pop[i].Value > pop[j].Value })\\n\\n\\t\\t// Check if there is a matching evolution\\n\\t\\tif pop[0].Key == target {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// Print the best resultPrint the Best result every 10 generations\\n\\t\\t// just to know that the algorithm is working\\n\\t\\tif debug && gen%10 == 0 {\\n\\t\\t\\tfmt.Println(\\\"Generation:\\\", strconv.Itoa(gen), \\\"Analyzed:\\\", generatedPop, \\\"Best:\\\", pop[0])\\n\\t\\t}\\n\\n\\t\\t// Generate a new population vector keeping some of the best evolutions\\n\\t\\t// Keeping this avoid regression of evolution\\n\\t\\tvar popChildren []PopulationItem\\n\\t\\tpopChildren = append(popChildren, pop[0:int(selectionNum/3)]...)\\n\\n\\t\\t// This is Selection\\n\\t\\tfor i := 0; i < int(selectionNum); i++ {\\n\\t\\t\\tparent1 := pop[i]\\n\\t\\t\\t// Generate more child proportionally to the fitness score\\n\\t\\t\\tnChild := (parent1.Value * 100) + 1\\n\\t\\t\\tif nChild >= 10 {\\n\\t\\t\\t\\tnChild = 10\\n\\t\\t\\t}\\n\\t\\t\\tfor x := 0.0; x < nChild; x++ {\\n\\t\\t\\t\\tparent2 := pop[rand.Intn(selectionNum)]\\n\\t\\t\\t\\t// Crossover\\n\\t\\t\\t\\tsplit := rand.Intn(utf8.RuneCountInString(target))\\n\\t\\t\\t\\tchild1 := append([]rune(parent1.Key)[:split], []rune(parent2.Key)[split:]...)\\n\\t\\t\\t\\tchild2 := append([]rune(parent2.Key)[:split], []rune(parent1.Key)[split:]...)\\n\\t\\t\\t\\t// Clean fitness value\\n\\t\\t\\t\\t// Mutate\\n\\t\\t\\t\\tif rand.Float64() < mutationProb {\\n\\t\\t\\t\\t\\tchild1[rand.Intn(len(child1))] = charmap[rand.Intn(len(charmap))]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif rand.Float64() < mutationProb {\\n\\t\\t\\t\\t\\tchild2[rand.Intn(len(child2))] = charmap[rand.Intn(len(charmap))]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Push into 'popChildren'\\n\\t\\t\\t\\tpopChildren = append(popChildren, PopulationItem{string(child1), 0})\\n\\t\\t\\t\\tpopChildren = append(popChildren, PopulationItem{string(child2), 0})\\n\\n\\t\\t\\t\\t// Check if the population has already reached the maximum value and if so,\\n\\t\\t\\t\\t// break the cycle. If this check is disabled the algorithm will take\\n\\t\\t\\t\\t// forever to compute large strings but will also calculate small string in\\n\\t\\t\\t\\t// a lot fewer generationsù\\n\\t\\t\\t\\tif len(popChildren) >= selectionNum {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpop = popChildren\\n\\t}\\n\\treturn &Result{gen, generatedPop, pop[0]}, nil\\n}\\n\"",
    "genetic algorithm test": "\"package genetic\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestSimple(t *testing.T) {\\n\\ttarget := \\\"This is a genetic algorithm to evaluate, combine, evolve and mutate a string!\\\"\\n\\tcharmap := []rune(\\\" ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,;!?+-*#@^'èéòà€ù=)(&%$£/\\\\\\\\\\\")\\n\\n\\tres, err := GeneticString(target, charmap, &Conf{})\\n\\tif err != nil {\\n\\t\\tt.Errorf(\\\"Unexpected error: %v\\\\n\\\", err)\\n\\t}\\n\\n\\tgot := res.Best\\n\\n\\tif got.Value != float64(1.0) {\\n\\t\\tt.Errorf(\\\"Target value not reached\\\\nwant: %f\\\\n, got: %f\\\\n\\\", float64(1.0), got.Value)\\n\\t}\\n\\n\\tif got.Key != target {\\n\\t\\tt.Errorf(\\\"Target string not reached\\\\nwant: %s\\\\n, got: %s\\\\n\\\", target, got.Key)\\n\\t}\\n}\\n\"",
    "horspool": "\"package horspool\\n\\n// User defined.\\n// Set to true to read input from two command line arguments\\n// Set to false to read input from two files \\\"pattern.txt\\\" and \\\"text.txt\\\"\\n// const commandLineInput bool = false\\n\\n// Implementation of Boyer-Moore-Horspool algorithm (Suffix based approach).\\n// Requires either a two command line arguments separated by a single space,\\n// or two files in the same folder: \\\"pattern.txt\\\" containing the string to\\n// be searched for, \\\"text.txt\\\" containing the text to be searched in.\\n// func main() {\\n// \\tif commandLineInput == true { // case of command line input\\n// \\t\\targs := os.Args\\n// \\t\\tif len(args) <= 2 {\\n// \\t\\t\\tlog.Fatal(\\\"Not enough arguments. Two string arguments separated by spaces are required!\\\")\\n// \\t\\t}\\n// \\t\\tpattern := args[1]\\n// \\t\\ts := args[2]\\n// \\t\\tfor i := 3; i < len(args); i++ {\\n// \\t\\t\\ts = s + \\\" \\\" + args[i]\\n// \\t\\t}\\n// \\t\\tif len(args[1]) > len(s) {\\n// \\t\\t\\tlog.Fatal(\\\"Pattern  is longer than text!\\\")\\n// \\t\\t}\\n// \\t\\tfmt.Printf(\\\"\\\\nRunning: Horspool algorithm.\\\\n\\\\n\\\")\\n// \\t\\tfmt.Printf(\\\"Search word (%d chars long): %q.\\\\n\\\", len(args[1]), pattern)\\n// \\t\\tfmt.Printf(\\\"Text        (%d chars long): %q.\\\\n\\\\n\\\", len(s), s)\\n// \\t\\thorspool(s, pattern)\\n// \\t} else if commandLineInput == false { // case of file line input\\n// \\t\\tpatFile, err := ioutil.ReadFile(\\\"pattern.txt\\\")\\n// \\t\\tif err != nil {\\n// \\t\\t\\tlog.Fatal(err)\\n// \\t\\t}\\n// \\t\\ttextFile, err := ioutil.ReadFile(\\\"text.txt\\\")\\n// \\t\\tif err != nil {\\n// \\t\\t\\tlog.Fatal(err)\\n// \\t\\t}\\n// \\t\\tif len(patFile) > len(textFile) {\\n// \\t\\t\\tlog.Fatal(\\\"Pattern  is longer than text!\\\")\\n// \\t\\t}\\n// \\t\\tfmt.Printf(\\\"\\\\nRunning: Horspool algorithm.\\\\n\\\\n\\\")\\n// \\t\\tfmt.Printf(\\\"Search word (%d chars long): %q.\\\\n\\\", len(patFile), patFile)\\n// \\t\\tfmt.Printf(\\\"Text        (%d chars long): %q.\\\\n\\\\n\\\", len(textFile), textFile)\\n// \\t\\thorspool(string(textFile), string(patFile))\\n// \\t}\\n// }\\n\\n// // Function horspool performing the Horspool algorithm.\\n// // Prints whether the word/pattern was found and on what position in the text or not.\\n// func horspool(t, p string) {\\n// \\tm, n, c, pos := len(p), len(t), 0, 0\\n// \\t//Perprocessing\\n// \\td := preprocess(t, p)\\n// \\t//Map output\\n// \\tfmt.Printf(\\\"Precomputed shifts per symbol: \\\")\\n// \\tfor key, value := range d {\\n// \\t\\tfmt.Printf(\\\"%c:%d; \\\", key, value)\\n// \\t}\\n// \\tfmt.Println()\\n// \\t//Searching\\n// \\tfor pos <= n-m {\\n// \\t\\tj := m\\n// \\t\\tif t[pos+j-1] != p[j-1] {\\n// \\t\\t\\tfmt.Printf(\\\"\\\\n   comparing characters %c %c at positions %d %d\\\", t[pos+j-1], p[j-1], pos+j-1, j-1)\\n// \\t\\t\\tc++\\n// \\t\\t}\\n// \\t\\tfor j > 0 && t[pos+j-1] == p[j-1] {\\n// \\t\\t\\tfmt.Printf(\\\"\\\\n   comparing characters %c %c at positions %d %d\\\", t[pos+j-1], p[j-1], pos+j-1, j-1)\\n// \\t\\t\\tc++\\n// \\t\\t\\tfmt.Printf(\\\" - match\\\")\\n// \\t\\t\\tj--\\n// \\t\\t}\\n// \\t\\tif j == 0 {\\n// \\t\\t\\tfmt.Printf(\\\"\\\\n\\\\nWord %q was found at position %d in %q. \\\\n%d comparisons were done.\\\", p, pos, t, c)\\n// \\t\\t\\treturn\\n// \\t\\t}\\n// \\t\\tpos = pos + d[t[pos+m]]\\n// \\t}\\n// \\tfmt.Printf(\\\"\\\\n\\\\nWord was not found.\\\\n%d comparisons were done.\\\", c)\\n// \\treturn\\n// }\\n\\n// // Function that pre-computes map with Key: uint8 (char) Value: int.\\n// // Values determine safe shifting of search window.\\n// func preprocess(t, p string) (d map[uint8]int) {\\n// \\td = make(map[uint8]int)\\n// \\tfor i := 0; i < len(t); i++ {\\n// \\t\\td[t[i]] = len(p)\\n// \\t}\\n// \\tfor i := 0; i < len(p); i++ {\\n// \\t\\td[p[i]] = len(p) - i\\n// \\t}\\n// \\treturn d\\n// }\\n\"",
    "kmp": "\"package kmp\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\n// User defined.\\n// Set to true to read input from two command line arguments\\n// Set to false to read input from two files \\\"pattern.txt\\\" and \\\"text.txt\\\"\\n\\n// const isTakingInputFromCommandLine bool = true\\n\\nconst notFoundPosition int = -1\\n\\ntype Result struct {\\n\\tresultPosition     int\\n\\tnumberOfComparison int\\n}\\n\\n// Implementation of Knuth-Morris-Pratt algorithm (Prefix based approach).\\n// Requires either a two command line arguments separated by a single space,\\n// or two files in the same folder: \\\"pattern.txt\\\" containing the string to\\n// be searched for, \\\"text.txt\\\" containing the text to be searched in.\\n// func main() {\\n// \\tvar text string\\n// \\tvar word string\\n\\n// \\tif isTakingInputFromCommandLine { // case of command line input\\n// \\t\\targs := os.Args\\n// \\t\\tif len(args) <= 2 {\\n// \\t\\t\\tlog.Fatal(\\\"Not enough arguments. Two string arguments separated by spaces are required!\\\")\\n// \\t\\t}\\n// \\t\\tword = args[1]\\n// \\t\\ttext = args[2]\\n// \\t\\tfor i := 3; i < len(args); i++ {\\n// \\t\\t\\ttext = text + \\\" \\\" + args[i]\\n// \\t\\t}\\n// \\t} else { // case of file input\\n// \\t\\tpatFile, err := ioutil.ReadFile(\\\"../pattern.txt\\\")\\n// \\t\\tif err != nil {\\n// \\t\\t\\tlog.Fatal(err)\\n// \\t\\t}\\n// \\t\\ttextFile, err := ioutil.ReadFile(\\\"../text.txt\\\")\\n// \\t\\tif err != nil {\\n// \\t\\t\\tlog.Fatal(err)\\n// \\t\\t}\\n// \\t\\ttext = string(textFile)\\n// \\t\\tword = string(patFile)\\n// \\t}\\n\\n// \\tif len(word) > len(text) {\\n// \\t\\tlog.Fatal(\\\"Pattern is longer than text!\\\")\\n// \\t}\\n// \\tfmt.Printf(\\\"\\\\nRunning: Knuth-Morris-Pratt algorithm.\\\\n\\\\n\\\")\\n// \\tfmt.Printf(\\\"Search word (%d chars long): %q.\\\\n\\\", len(word), word)\\n// \\tfmt.Printf(\\\"Text        (%d chars long): %q.\\\\n\\\\n\\\", len(text), text)\\n\\n// \\tr := kmp(text, word)\\n// \\tif r.resultPosition == notFoundPosition {\\n// \\t\\tfmt.Printf(\\\"\\\\n\\\\nWord was not found.\\\\n%d comparisons were done.\\\", r.numberOfComparison)\\n// \\t} else {\\n// \\t\\tfmt.Printf(\\\"\\\\n\\\\nWord %q was found at position %d in %q. \\\\n%d comparisons were done.\\\", word,\\n// \\t\\t\\tr.resultPosition, text, r.numberOfComparison)\\n// \\t}\\n// }\\n\\n// Kmp Function kmp performing the Knuth-Morris-Pratt algorithm.\\n// Prints whether the word/pattern was found and on what position in the text or not.\\n// m - current match in text, i - current character in w, c - amount of comparisons.\\nfunc Kmp(text string, word string) Result {\\n\\tm, i, c := 0, 0, 0\\n\\tt := kmpTable(word)\\n\\tfor m+i < len(text) {\\n\\t\\tfmt.Printf(\\\"\\\\n   comparing characters %c %c at positions %d %d\\\", text[m+i], word[i], m+i, i)\\n\\t\\tc++\\n\\t\\tif word[i] == text[m+i] {\\n\\t\\t\\tfmt.Printf(\\\" - match\\\")\\n\\t\\t\\tif i == len(word)-1 {\\n\\t\\t\\t\\treturn Result{\\n\\t\\t\\t\\t\\tm, c,\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti++\\n\\t\\t} else {\\n\\t\\t\\tm = m + i - t[i]\\n\\t\\t\\tif t[i] > -1 {\\n\\t\\t\\t\\ti = t[i]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn Result{notFoundPosition,\\n\\t\\tc,\\n\\t}\\n}\\n\\n// Table building algorithm.\\n// Takes word to be analyzed and table to be filled.\\nfunc kmpTable(word string) (t []int) {\\n\\tt = make([]int, len(word))\\n\\tpos, cnd := 2, 0\\n\\tt[0], t[1] = -1, 0\\n\\tfor pos < len(word) {\\n\\t\\tif word[pos-1] == word[cnd] {\\n\\t\\t\\tcnd++\\n\\t\\t\\tt[pos] = cnd\\n\\t\\t\\tpos++\\n\\t\\t} else if cnd > 0 {\\n\\t\\t\\tcnd = t[cnd]\\n\\t\\t} else {\\n\\t\\t\\tt[pos] = 0\\n\\t\\t\\tpos++\\n\\t\\t}\\n\\t}\\n\\treturn t\\n}\\n\"",
    "kmp test": "\"package kmp\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nvar testCases = []struct {\\n\\tname     string\\n\\tword     string\\n\\ttext     string\\n\\texpected Result\\n}{\\n\\t{\\n\\t\\t\\\"String comparison on single pattern match\\\",\\n\\t\\t\\\"announce\\\",\\n\\t\\t\\\"CPM_annual_conference_announce\\\",\\n\\t\\tResult{\\n\\t\\t\\t22,\\n\\t\\t\\t32,\\n\\t\\t},\\n\\t},\\n\\t{\\n\\t\\t\\\"String comparison on multiple pattern match\\\",\\n\\t\\t\\\"AABA\\\",\\n\\t\\t\\\"AABAACAADAABAABA\\\",\\n\\t\\tResult{\\n\\t\\t\\t0,\\n\\t\\t\\t4,\\n\\t\\t},\\n\\t},\\n\\t{\\n\\t\\t\\\"String comparison with not found pattern\\\",\\n\\t\\t\\\"AABC\\\",\\n\\t\\t\\\"AABAACAADAABAABA\\\",\\n\\t\\tResult{\\n\\t\\t\\t-1,\\n\\t\\t\\t23,\\n\\t\\t},\\n\\t},\\n}\\n\\nfunc TestKMP(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := Kmp(tc.text, tc.word)\\n\\t\\t\\tif !reflect.DeepEqual(actual, tc.expected) {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected matches for pattern '%s' for string '%s' are: %v steps at position %v, but actual matches are: %v steps at position %v\\\",\\n\\t\\t\\t\\t\\ttc.word, tc.text, tc.expected.numberOfComparison, tc.expected.resultPosition, actual.numberOfComparison, actual.resultPosition)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "levenshtein distance": "\"/*\\nThis algorithm calculates the distance between two strings.\\nParameters: two strings to compare and weights of insertion, substitution and deletion.\\nOutput: distance between both strings\\n*/\\n\\npackage levenshtein\\n\\n// Distance Function that gives Levenshtein Distance\\nfunc Distance(str1, str2 string, icost, scost, dcost int) int {\\n\\trow1 := make([]int, len(str2)+1)\\n\\trow2 := make([]int, len(str2)+1)\\n\\n\\tfor i := 1; i <= len(str2); i++ {\\n\\t\\trow1[i] = i * icost\\n\\t}\\n\\n\\tfor i := 1; i <= len(str1); i++ {\\n\\t\\trow2[0] = i * dcost\\n\\n\\t\\tfor j := 1; j <= len(str2); j++ {\\n\\t\\t\\tif str1[i-1] == str2[j-1] {\\n\\t\\t\\t\\trow2[j] = row1[j-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tins := row2[j-1] + icost\\n\\t\\t\\t\\tdel := row1[j] + dcost\\n\\t\\t\\t\\tsub := row1[j-1] + scost\\n\\n\\t\\t\\t\\tif ins < del && ins < sub {\\n\\t\\t\\t\\t\\trow2[j] = ins\\n\\t\\t\\t\\t} else if del < sub {\\n\\t\\t\\t\\t\\trow2[j] = del\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\trow2[j] = sub\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\trow1, row2 = row2, row1\\n\\t}\\n\\n\\treturn row1[len(row1)-1]\\n}\\n\"",
    "levenshtein distance test": "\"package levenshtein\\n\\nimport \\\"testing\\\"\\n\\nvar testCases = []struct {\\n\\tname             string\\n\\tstring1          string\\n\\tstring2          string\\n\\tinsertionCost    int\\n\\tsubstitutionCost int\\n\\tdeletionCost     int\\n\\texpected         int\\n}{\\n\\t{\\n\\t\\t\\\"strings with equal operation weights.\\\",\\n\\t\\t\\\"stingy\\\",\\n\\t\\t\\\"ring\\\",\\n\\t\\t1,\\n\\t\\t1,\\n\\t\\t1,\\n\\t\\t3,\\n\\t},\\n\\t{\\n\\t\\t\\\"strings with different operation weights.\\\",\\n\\t\\t\\\"stingy\\\",\\n\\t\\t\\\"ring\\\",\\n\\t\\t1,\\n\\t\\t1,\\n\\t\\t3,\\n\\t\\t7,\\n\\t},\\n\\t{\\n\\t\\t\\\"strings with different operation weights.\\\",\\n\\t\\t\\\"kitten\\\",\\n\\t\\t\\\"sitting\\\",\\n\\t\\t1,\\n\\t\\t1,\\n\\t\\t1,\\n\\t\\t3,\\n\\t},\\n}\\n\\nfunc TestLevenshteinDistance(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := Distance(tc.string1, tc.string2, tc.insertionCost, tc.substitutionCost, tc.deletionCost)\\n\\t\\t\\tif actual != tc.expected {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected Levenshtein distance between strings: '%s' and '%s' is %v, but got: %v\\\", tc.string1, tc.string2, tc.expected, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "longest palindrome": "\"// longestpalindrome.go\\n// description: Manacher's algorithm (Longest palindromic substring)\\n// details:\\n// An algorithm with linear running time that allows you to get compressed information about all palindromic substrings of a given string. - [Manacher's algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see longestpalindrome_test.go\\n\\npackage manacher\\n\\nimport (\\n\\t\\\"github.com/TheAlgorithms/Go/math/min\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc makeBoundaries(s string) string {\\n\\tvar result strings.Builder\\n\\tresult.WriteRune('#')\\n\\tfor _, ch := range s {\\n\\t\\tif ch != ' ' { //ignore space as palindrome character\\n\\t\\t\\tresult.WriteRune(ch)\\n\\t\\t}\\n\\t\\tresult.WriteRune('#')\\n\\t}\\n\\treturn result.String()\\n}\\n\\nfunc nextBoundary(s string) string {\\n\\tvar result strings.Builder\\n\\tfor _, ch := range s {\\n\\t\\tif ch != '#' {\\n\\t\\t\\tresult.WriteRune(ch)\\n\\t\\t}\\n\\t}\\n\\treturn result.String()\\n}\\n\\nfunc LongestPalindrome(s string) string {\\n\\tboundaries := makeBoundaries(s)\\n\\tb := make([]int, len(boundaries))\\n\\tk := 0\\n\\tindex := 0\\n\\tmaxLen := 0\\n\\tmaxCenterSize := 0\\n\\tfor i := range b {\\n\\t\\tif i < k {\\n\\t\\t\\tb[i] = min.Int(b[2*index-i], k-i)\\n\\t\\t} else {\\n\\t\\t\\tb[i] = 1\\n\\t\\t}\\n\\t\\tfor i-b[i] >= 0 && i+b[i] < len(boundaries) && boundaries[i-b[i]] == boundaries[i+b[i]] {\\n\\t\\t\\tb[i] += 1\\n\\t\\t}\\n\\t\\tif maxLen < b[i]-1 {\\n\\t\\t\\tmaxLen = b[i] - 1\\n\\t\\t\\tmaxCenterSize = i\\n\\t\\t}\\n\\t\\tif b[i]+i-1 > k {\\n\\t\\t\\tk = b[i] + i - 1\\n\\t\\t\\tindex = i\\n\\t\\t}\\n\\t}\\n\\treturn nextBoundary(boundaries[maxCenterSize-maxLen : maxCenterSize+maxLen])\\n}\\n\"",
    "longest palindrome test": "\"// longestpalindrome_test.go\\n// description: Manacher's algorithm (Longest palindromic substring)\\n// author(s) [red_byte](https://github.com/i-redbyte)\\n// see longestpalindrome.go\\n\\npackage manacher\\n\\nimport \\\"testing\\\"\\n\\nfunc getTests() []struct {\\n\\ts      string\\n\\tresult string\\n} {\\n\\tvar tests = []struct {\\n\\t\\ts      string\\n\\t\\tresult string\\n\\t}{\\n\\t\\t{\\\"olokazakabba\\\", \\\"kazak\\\"},\\n\\t\\t{\\\"abaacakkkkk\\\", \\\"kkkkk\\\"},\\n\\t\\t{\\\"qqqq C++ groovy mom pooop\\\", \\\"pooop\\\"},\\n\\t\\t{\\\"CCCPCCC @@@ hello\\\", \\\"CCCPCCC\\\"},\\n\\t\\t{\\\"goog gogogogogog -go- gogogogo \\\", \\\"gogogogogog\\\"},\\n\\t}\\n\\treturn tests\\n}\\n\\nfunc TestLongestPalindrome(t *testing.T) {\\n\\ttests := getTests()\\n\\tfor _, tv := range tests {\\n\\t\\tt.Run(tv.s, func(t *testing.T) {\\n\\t\\t\\tresult := LongestPalindrome(tv.s)\\n\\t\\t\\tt.Log(tv.s, \\\" \\\", result)\\n\\t\\t\\tif result != tv.result {\\n\\t\\t\\t\\tt.Errorf(\\\"Wrong result! Expected:%s, returned:%s \\\", tv.result, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "is palindrome": "\"// ispalindrome.go\\n// description: Checks if a given string is palindrome or not\\n// details:\\n// Palindromes are expressions that read the same way forwards and backwards.\\n// They can be words/phrases (like \\\"racecar\\\" and \\\"Do geese see God?\\\"), or even\\n// numbers (like \\\"02/02/2020\\\"). Usually punctuation signs, capitalization\\n// and spaces are ignored. A regular expression was used to achieve that.\\n// See more information on: https://en.wikipedia.org/wiki/Palindrome\\n// author(s) [Fernanda Kawasaki](https://github.com/fernandakawasaki)\\n// see ispalindrome_test.go\\n\\npackage palindrome\\n\\nimport (\\n\\t\\\"regexp\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc cleanString(text string) string {\\n\\tclean_text := strings.ToLower(text)\\n\\tclean_text = strings.Join(strings.Fields(clean_text), \\\"\\\") // Remove spaces\\n\\tregex, _ := regexp.Compile(`[^\\\\p{L}\\\\p{N} ]+`)             // Regular expression for alphanumeric only characters\\n\\treturn regex.ReplaceAllString(clean_text, \\\"\\\")\\n}\\n\\nfunc IsPalindrome(text string) bool {\\n\\tclean_text := cleanString(text)\\n\\tvar i, j int\\n\\trune := []rune(clean_text)\\n\\tfor i = 0; i < len(rune)/2; i++ {\\n\\t\\tj = len(rune) - 1 - i\\n\\t\\tif string(rune[i]) != string(rune[j]) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\"",
    "is palindrome test": "\"package palindrome\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nvar testCases = []struct {\\n\\tname     string // test description\\n\\tinput    string // user input\\n\\texpected bool   // expected return\\n}{\\n\\t{\\n\\t\\t\\\"non palindrome string\\\",\\n\\t\\t\\\"According to the laws of aviation bees can't flyã\\\",\\n\\t\\tfalse,\\n\\t},\\n\\t{\\n\\t\\t\\\"non palindrome string\\\",\\n\\t\\t\\\"Alô?\\\",\\n\\t\\tfalse,\\n\\t},\\n\\t{\\n\\t\\t\\\"palindrome string 1\\\",\\n\\t\\t\\\"Do geese see God?\\\",\\n\\t\\ttrue,\\n\\t},\\n\\t{\\n\\t\\t\\\"palindrome string 2\\\",\\n\\t\\t\\\"ΝΙΨΟΝ ΑΝΟΜΗΜΑΤΑ ΜΗ ΜΟΝΑΝ ΟΨΙΝ\\\",\\n\\t\\ttrue,\\n\\t},\\n\\t{\\n\\t\\t\\\"palindrome string 3\\\",\\n\\t\\t\\\"Was it a car or a cat I saw?\\\",\\n\\t\\ttrue,\\n\\t},\\n\\t{\\n\\t\\t\\\"empty string\\\",\\n\\t\\t\\\"\\\",\\n\\t\\ttrue,\\n\\t},\\n}\\n\\nfunc TestIsPalindrome(t *testing.T) {\\n\\tfor _, test := range testCases {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tfunc_result := IsPalindrome(test.input)\\n\\t\\t\\tif test.expected != func_result {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected answer '%t' for string '%s' but answer given was %t\\\", test.expected, test.input, func_result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "is pangram": "\"// ispangram.go\\n// description: Checks if a given string is pangram or not\\n// details: A pangram is a sentence or expression that uses all the letters of the alphabet.\\n// Reference: https://www.geeksforgeeks.org/pangram-checking/\\n// Author : Kavitha J\\n\\npackage pangram\\n\\nimport (\\n\\t\\\"regexp\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc cleanString(text string) string {\\n\\tcleanText := strings.ToLower(text)                      // Convert to lowercase\\n\\tcleanText = strings.Join(strings.Fields(cleanText), \\\"\\\") // Remove spaces\\n\\tregex, _ := regexp.Compile(`[^\\\\p{L}\\\\p{N} ]+`)           // Regular expression for alphanumeric only characters\\n\\treturn regex.ReplaceAllString(cleanText, \\\"\\\")\\n}\\n\\nfunc IsPangram(text string) bool {\\n\\tcleanText := cleanString(text)\\n\\tif len(cleanText) < 26 {\\n\\t\\treturn false\\n\\t}\\n\\tvar data = make(map[rune]bool)\\n\\tfor _, i := range cleanText {\\n\\t\\tdata[i] = true\\n\\t}\\n\\treturn len(data) == 26\\n}\\n\"",
    "is pangram test": "\"package pangram\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nvar testCases = []struct {\\n\\tname     string // test description\\n\\tinput    string // user input\\n\\texpected bool   // expected return\\n}{\\n\\t{\\n\\t\\t\\\"empty string\\\",\\n\\t\\t\\\"\\\",\\n\\t\\tfalse,\\n\\t},\\n\\t{\\n\\t\\t\\\"non pangram string without spaces\\\",\\n\\t\\t\\\"abc\\\",\\n\\t\\tfalse,\\n\\t},\\n\\t{\\n\\t\\t\\\"non pangram string with spaces\\\",\\n\\t\\t\\\"Hello World\\\",\\n\\t\\tfalse,\\n\\t},\\n\\t{\\n\\t\\t\\\"Pangram string 1\\\",\\n\\t\\t\\\" Abcdefghijklmnopqrstuvwxyz\\\",\\n\\t\\ttrue,\\n\\t},\\n\\t{\\n\\t\\t\\\"pangram string 2\\\",\\n\\t\\t\\\"cdefghijklmnopqrstuvwxABC zyb\\\",\\n\\t\\ttrue,\\n\\t},\\n\\t{\\n\\t\\t\\\"pangram string 3\\\",\\n\\t\\t\\\"The Quick Brown Fox Jumps Over the Lazy Dog\\\",\\n\\t\\ttrue,\\n\\t},\\n}\\n\\nfunc TestIsPangram(t *testing.T) {\\n\\tfor _, test := range testCases {\\n\\t\\tt.Run(test.name, func(t *testing.T) {\\n\\t\\t\\tfunc_result := IsPangram(test.input)\\n\\t\\t\\tif test.expected != func_result {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected answer '%t' for string '%s' but answer given was %t\\\", test.expected, test.input, func_result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "boyer moore": "\"package search\\n\\n// Implementation of boyer moore string search\\n// O(l) where l=len(text)\\nfunc BoyerMoore(text string, pattern string) []int {\\n\\tvar positions []int\\n\\n\\tl := len(text)\\n\\tn := len(pattern)\\n\\n\\t// using booyer moore horspool modification\\n\\t// O(n) space instead of O(n**2)\\n\\tbcr := make(map[byte]int)\\n\\tfor i := 0; i < n-1; i++ {\\n\\t\\tbcr[pattern[i]] = n - i - 1\\n\\t}\\n\\n\\t// Apostolico–Giancarlo modification\\n\\t// allow to skip patterns that we know matches\\n\\t// let us do O(l) instead of O(ln)\\n\\tskips := make(map[int]int)\\n\\tfor _, s := range bcr {\\n\\t\\ti := 0\\n\\t\\tfor ; i < n-s; i++ {\\n\\t\\t\\tif pattern[n-1-i] != pattern[n-1-s-i] {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tskips[s] = i\\n\\t}\\n\\n\\tskip := 0\\n\\tjump := n\\n\\tfor i := 0; i < l-n+1; {\\n\\t\\tskip = skips[jump]\\n\\t\\tfor k := n - 1; k > -1; k-- {\\n\\t\\t\\tif text[i+k] != pattern[k] {\\n\\t\\t\\t\\tjump, ok := bcr[text[i+k]]\\n\\t\\t\\t\\tif !ok {\\n\\t\\t\\t\\t\\tjump = n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti += jump\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tif k == n-jump {\\n\\t\\t\\t\\tk -= skip\\n\\t\\t\\t}\\n\\t\\t\\tif k == 0 {\\n\\t\\t\\t\\tpositions = append(positions, i)\\n\\t\\t\\t\\tjump = 1\\n\\t\\t\\t\\ti += jump\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn positions\\n}\\n\"",
    "naive": "\"package search\\n\\n// Implementation of naive string search\\n// O(n*m) where n=len(txt) and m=len(pattern)\\nfunc Naive(text string, pattern string) []int {\\n\\tvar positions []int\\n\\tfor i := 0; i <= len(text)-len(pattern); i++ {\\n\\t\\tvar match bool = true\\n\\t\\tfor j := 0; j < len(pattern); j++ {\\n\\t\\t\\tif text[i+j] != pattern[j] {\\n\\t\\t\\t\\tmatch = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tif match {\\n\\t\\t\\tpositions = append(positions, i)\\n\\t\\t}\\n\\t}\\n\\treturn positions\\n}\\n\"",
    "pattern search test": "\"package search\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nvar testCases = []struct {\\n\\tname     string\\n\\tinput    string\\n\\tpattern  string\\n\\texpected []int\\n}{\\n\\t{\\n\\t\\t\\\"string with multiple pattern matches\\\",\\n\\t\\t\\\"ABAAABCDBBABCDDEBCABC\\\",\\n\\t\\t\\\"ABC\\\",\\n\\t\\t[]int{4, 10, 18},\\n\\t},\\n\\t{\\n\\t\\t\\\"string with single pattern match\\\",\\n\\t\\t\\\"ABCDEFGHIJKLMN\\\",\\n\\t\\t\\\"CDE\\\",\\n\\t\\t[]int{2},\\n\\t},\\n\\t{\\n\\t\\t\\\"string with no pattern match\\\",\\n\\t\\t\\\"ABCDEFGHIJKLMN\\\",\\n\\t\\t\\\"XYZ\\\",\\n\\t\\t[]int(nil),\\n\\t},\\n\\t{\\n\\t\\t\\\"empty string\\\",\\n\\t\\t\\\"\\\",\\n\\t\\t\\\"XYZ\\\",\\n\\t\\t[]int(nil),\\n\\t},\\n\\t{\\n\\t\\t\\\"worse case 1\\\",\\n\\t\\t\\\"AAAAAAAAAA\\\",\\n\\t\\t\\\"AAA\\\",\\n\\t\\t[]int{0, 1, 2, 3, 4, 5, 6, 7},\\n\\t},\\n\\t{\\n\\t\\t\\\"worse case 2\\\",\\n\\t\\t\\\"NANANANANANANANANA\\\",\\n\\t\\t\\\"NANANA\\\",\\n\\t\\t[]int{0, 2, 4, 6, 8, 10, 12},\\n\\t},\\n}\\n\\nfunc TestNaive(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := Naive(tc.input, tc.pattern)\\n\\t\\t\\tif !reflect.DeepEqual(actual, tc.expected) {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected matches for pattern '%s' for string '%s' are: %v, but actual matches are: %v\\\", tc.pattern, tc.input, tc.expected, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestBooyerMoore(t *testing.T) {\\n\\tfor _, tc := range testCases {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\tactual := BoyerMoore(tc.input, tc.pattern)\\n\\t\\t\\tif !reflect.DeepEqual(actual, tc.expected) {\\n\\t\\t\\t\\tt.Errorf(\\\"Expected matches for pattern '%s' for string '%s' are: %v, but actual matches are: %v\\\", tc.pattern, tc.input, tc.expected, actual)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "avl": "\"// Package avl is a Adelson-Velskii and Landis tree implemnation\\n// avl is self-balancing tree, i.e for all node in a tree, height difference\\n// between its left and right child will not exceed 1\\n// more information : https://en.wikipedia.org/wiki/AVL_tree\\npackage avl\\n\\n// Node of a tree\\ntype Node struct {\\n\\tKey         int\\n\\tHeight      int\\n\\tLeft, Right *Node\\n}\\n\\n// NewTree create a new AVL tree\\nfunc NewTree() *Node {\\n\\treturn nil\\n}\\n\\n// Get : return node with given key\\nfunc Get(root *Node, key int) *Node {\\n\\tif root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\tif root.Key == key {\\n\\t\\treturn root\\n\\t} else if root.Key < key {\\n\\t\\troot = root.Right\\n\\t} else {\\n\\t\\troot = root.Left\\n\\t}\\n\\treturn Get(root, key)\\n}\\n\\n// Insert a new item\\nfunc Insert(root **Node, key int) {\\n\\tif *root == nil {\\n\\t\\t*root = &Node{\\n\\t\\t\\tKey:    key,\\n\\t\\t\\tHeight: 1,\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\tif (*root).Key < key {\\n\\t\\tInsert(&(*root).Right, key)\\n\\t} else if (*root).Key > key {\\n\\t\\tInsert(&(*root).Left, key)\\n\\t}\\n\\n\\t// update height\\n\\t(*root).Height = height(*root)\\n\\n\\tbFactor := balanceFactor(*root)\\n\\n\\tif bFactor == 2 { // L\\n\\t\\tbFactor = balanceFactor((*root).Left)\\n\\t\\tif bFactor == 1 { // LL\\n\\t\\t\\tllRotation(root)\\n\\t\\t} else if bFactor == -1 { // LR\\n\\t\\t\\tlrRotation(root)\\n\\t\\t}\\n\\t} else if bFactor == -2 { // R\\n\\t\\tbFactor = balanceFactor((*root).Right)\\n\\t\\tif bFactor == 1 { // RL\\n\\t\\t\\trlRotation(root)\\n\\t\\t} else if bFactor == -1 { // RR\\n\\t\\t\\trrRotation(root)\\n\\t\\t}\\n\\t}\\n}\\n\\n// Delete : remove given key from the tree\\nfunc Delete(root **Node, key int) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\tif (*root).Key < key {\\n\\t\\tDelete(&(*root).Right, key)\\n\\t} else if (*root).Key > key {\\n\\t\\tDelete(&(*root).Left, key)\\n\\t} else {\\n\\t\\t// 3 cases\\n\\t\\t// 1. No Child\\n\\t\\t// 2. With One Child\\n\\t\\t// 3. With Two Child\\n\\t\\tif (*root).Left == nil && (*root).Right == nil {\\n\\t\\t\\t*root = nil\\n\\t\\t} else if (*root).Left == nil {\\n\\t\\t\\t*root = (*root).Right\\n\\t\\t} else if (*root).Right == nil {\\n\\t\\t\\t*root = (*root).Left\\n\\t\\t} else {\\n\\t\\t\\tminVal := min((*root).Right)\\n\\t\\t\\t(*root).Key = minVal\\n\\t\\t\\tDelete(root, minVal)\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\t// update height\\n\\t(*root).Height = height(*root)\\n\\n\\tbFactor := balanceFactor(*root)\\n\\n\\tif bFactor == 2 { // L\\n\\t\\tswitch balanceFactor((*root).Left) {\\n\\t\\tcase 1: // LL\\n\\t\\t\\tllRotation(root)\\n\\t\\tcase -1: // LR\\n\\t\\t\\tlrRotation(root)\\n\\t\\tcase 0: //  LL OR LR\\n\\t\\t\\tllRotation(root)\\n\\t\\t}\\n\\t} else if bFactor == -2 { // L\\n\\t\\tswitch balanceFactor((*root).Right) {\\n\\t\\tcase 1: // RL\\n\\t\\t\\trlRotation(root)\\n\\t\\tcase -1: // RR\\n\\t\\t\\trrRotation(root)\\n\\t\\tcase 0: // RL OR RR\\n\\t\\t\\trrRotation(root)\\n\\t\\t}\\n\\t}\\n}\\n\\n// rotations\\n// 1. LL\\n// 2. LR\\n// 3. RR\\n// 4. RL\\nfunc llRotation(root **Node) {\\n\\tb := (*root).Left\\n\\tbr := b.Right\\n\\tb.Right = *root\\n\\t(*root).Left = br\\n\\t(*root).Height = height(*root)\\n\\tb.Height = height(b)\\n\\t*root = b\\n}\\nfunc lrRotation(root **Node) {\\n\\tc := (*root).Left.Right\\n\\tcl := c.Left\\n\\tcr := c.Right\\n\\n\\tc.Left = (*root).Left\\n\\tc.Right = (*root)\\n\\tc.Left.Right = cl\\n\\n\\t(*root).Left = cr\\n\\n\\t(*root).Height = height(*root)\\n\\tc.Left.Height = height(c.Left)\\n\\tc.Height = height(c)\\n\\n\\t*root = c\\n\\n}\\nfunc rrRotation(root **Node) {\\n\\tb := (*root).Right\\n\\tbl := b.Left\\n\\tb.Left = *root\\n\\n\\t(*root).Right = bl\\n\\t(*root).Height = height(*root)\\n\\tb.Height = height(b)\\n\\t*root = b\\n\\n}\\nfunc rlRotation(root **Node) {\\n\\tc := (*root).Right.Left\\n\\tcl := c.Left\\n\\tcr := c.Right\\n\\n\\tc.Right = (*root).Right\\n\\tc.Right.Left = cr\\n\\tc.Left = *root\\n\\t(*root).Right = cl\\n\\n\\t(*root).Height = height(*root)\\n\\tc.Right.Height = height(c.Right)\\n\\tc.Height = height(c)\\n\\t*root = c\\n}\\n\\n// balanceFactor : -ve balance factor means subtree root is heavy toward left\\n// and +ve balance factor means subtree root is heavy toward right side\\nfunc balanceFactor(root *Node) int {\\n\\tvar leftHeight, rightHeight int\\n\\tif root.Left != nil {\\n\\t\\tleftHeight = root.Left.Height\\n\\t}\\n\\tif root.Right != nil {\\n\\t\\trightHeight = root.Right.Height\\n\\t}\\n\\treturn leftHeight - rightHeight\\n}\\n\\nfunc height(root *Node) int {\\n\\tif root == nil {\\n\\t\\treturn 0\\n\\t}\\n\\tvar leftHeight, rightHeight int\\n\\tif root.Left != nil {\\n\\t\\tleftHeight = root.Left.Height\\n\\t}\\n\\tif root.Right != nil {\\n\\t\\trightHeight = root.Right.Height\\n\\t}\\n\\tmax := leftHeight\\n\\tif rightHeight > leftHeight {\\n\\t\\tmax = rightHeight\\n\\t}\\n\\treturn 1 + max\\n}\\n\\nfunc min(root *Node) int {\\n\\tif root.Left == nil {\\n\\t\\treturn root.Key\\n\\t}\\n\\treturn min(root.Left)\\n}\\n\"",
    "avl test": "\"package avl\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestInsert(t *testing.T) {\\n\\tt.Run(\\\"LLRotaion-Test\\\", func(t *testing.T) {\\n\\t\\troot := NewTree()\\n\\t\\tInsert(&root, 5)\\n\\t\\tInsert(&root, 4)\\n\\t\\tInsert(&root, 3)\\n\\n\\t\\tif root.Key != 4 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 4\\\")\\n\\t\\t}\\n\\t\\tif root.Height != 2 {\\n\\t\\t\\tt.Errorf(\\\"height of root should be = 2\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Left.Key != 3 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 3\\\")\\n\\t\\t}\\n\\t\\tif root.Left.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of left child should be 1\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Right.Key != 5 {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = 5\\\")\\n\\t\\t}\\n\\t\\tif root.Right.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of right should be 1\\\")\\n\\t\\t}\\n\\n\\t})\\n\\tt.Run(\\\"LRRotaion-Test\\\", func(t *testing.T) {\\n\\t\\troot := NewTree()\\n\\t\\tInsert(&root, 5)\\n\\t\\tInsert(&root, 3)\\n\\t\\tInsert(&root, 4)\\n\\n\\t\\tif root.Key != 4 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 4\\\")\\n\\t\\t}\\n\\t\\tif root.Height != 2 {\\n\\t\\t\\tt.Errorf(\\\"height of root should be = 2\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Left.Key != 3 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 3\\\")\\n\\t\\t}\\n\\t\\tif root.Left.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of left child should be 1\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Right.Key != 5 {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = 5\\\")\\n\\t\\t}\\n\\t\\tif root.Right.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of right should be 1\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"RRRotaion-Test\\\", func(t *testing.T) {\\n\\t\\troot := NewTree()\\n\\t\\tInsert(&root, 3)\\n\\t\\tInsert(&root, 4)\\n\\t\\tInsert(&root, 5)\\n\\n\\t\\tif root.Key != 4 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 4\\\")\\n\\t\\t}\\n\\t\\tif root.Height != 2 {\\n\\t\\t\\tt.Errorf(\\\"height of root should be = 2\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Left.Key != 3 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 3\\\")\\n\\t\\t}\\n\\t\\tif root.Left.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of left child should be 1\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Right.Key != 5 {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = 5\\\")\\n\\t\\t}\\n\\t\\tif root.Right.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of right should be 1\\\")\\n\\t\\t}\\n\\t})\\n\\tt.Run(\\\"RLRotaion-Test\\\", func(t *testing.T) {\\n\\t\\troot := NewTree()\\n\\t\\tInsert(&root, 3)\\n\\t\\tInsert(&root, 5)\\n\\t\\tInsert(&root, 4)\\n\\n\\t\\tif root.Key != 4 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 4\\\")\\n\\t\\t}\\n\\t\\tif root.Height != 2 {\\n\\t\\t\\tt.Errorf(\\\"height of root should be = 2\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Left.Key != 3 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 3\\\")\\n\\t\\t}\\n\\t\\tif root.Left.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of left child should be 1\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Right.Key != 5 {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = 5\\\")\\n\\t\\t}\\n\\t\\tif root.Right.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of right should be 1\\\")\\n\\t\\t}\\n\\t})\\n}\\n\\nfunc TestDelete(t *testing.T) {\\n\\tt.Run(\\\"LLRotaion-Test\\\", func(t *testing.T) {\\n\\t\\troot := NewTree()\\n\\n\\t\\tInsert(&root, 5)\\n\\t\\tInsert(&root, 4)\\n\\t\\tInsert(&root, 3)\\n\\t\\tInsert(&root, 2)\\n\\n\\t\\tDelete(&root, 5)\\n\\n\\t\\tif root.Key != 3 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 3\\\")\\n\\t\\t}\\n\\t\\tif root.Height != 2 {\\n\\t\\t\\tt.Errorf(\\\"height of root should be = 2\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Left.Key != 2 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 2\\\")\\n\\t\\t}\\n\\t\\tif root.Left.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of left child should be 1\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Right.Key != 4 {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = 5\\\")\\n\\t\\t}\\n\\t\\tif root.Right.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of right should be 1\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"LRRotaion-Test\\\", func(t *testing.T) {\\n\\t\\troot := NewTree()\\n\\n\\t\\tInsert(&root, 10)\\n\\t\\tInsert(&root, 8)\\n\\t\\tInsert(&root, 6)\\n\\t\\tInsert(&root, 7)\\n\\n\\t\\tDelete(&root, 10)\\n\\n\\t\\tif root.Key != 7 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 7\\\")\\n\\t\\t}\\n\\t\\tif root.Height != 2 {\\n\\t\\t\\tt.Errorf(\\\"height of root should be = 2\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Left.Key != 6 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 6\\\")\\n\\t\\t}\\n\\t\\tif root.Left.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of left child should be 1\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Right.Key != 8 {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = 8\\\")\\n\\t\\t}\\n\\t\\tif root.Right.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of right should be 1\\\")\\n\\t\\t}\\n\\n\\t})\\n\\n\\tt.Run(\\\"RRRotaion-Test\\\", func(t *testing.T) {\\n\\t\\troot := NewTree()\\n\\n\\t\\tInsert(&root, 2)\\n\\t\\tInsert(&root, 3)\\n\\t\\tInsert(&root, 4)\\n\\t\\tInsert(&root, 5)\\n\\n\\t\\tDelete(&root, 2)\\n\\n\\t\\tif root.Key != 4 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 4\\\")\\n\\t\\t}\\n\\t\\tif root.Height != 2 {\\n\\t\\t\\tt.Errorf(\\\"height of root should be = 2\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Left.Key != 3 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 3\\\")\\n\\t\\t}\\n\\t\\tif root.Left.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of left child should be 1\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Right.Key != 5 {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = 5\\\")\\n\\t\\t}\\n\\t\\tif root.Right.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of right should be 1\\\")\\n\\t\\t}\\n\\n\\t})\\n\\n\\tt.Run(\\\"RLRotaion-Test\\\", func(t *testing.T) {\\n\\t\\troot := NewTree()\\n\\n\\t\\tInsert(&root, 7)\\n\\t\\tInsert(&root, 6)\\n\\t\\tInsert(&root, 9)\\n\\t\\tInsert(&root, 8)\\n\\n\\t\\tDelete(&root, 6)\\n\\n\\t\\tif root.Key != 8 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 8\\\")\\n\\t\\t}\\n\\t\\tif root.Height != 2 {\\n\\t\\t\\tt.Errorf(\\\"height of root should be = 2\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Left.Key != 7 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 7\\\")\\n\\t\\t}\\n\\t\\tif root.Left.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of left child should be 1\\\")\\n\\t\\t}\\n\\n\\t\\tif root.Right.Key != 9 {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = 9\\\")\\n\\t\\t}\\n\\t\\tif root.Right.Height != 1 {\\n\\t\\t\\tt.Errorf(\\\"height of right should be 1\\\")\\n\\t\\t}\\n\\n\\t})\\n}\\n\\nfunc TestGet(t *testing.T) {\\n\\n\\troot := NewTree()\\n\\n\\tif Get(root, 5) != nil {\\n\\t\\tt.Error(\\\"no item should exists in newly created AVL tree\\\")\\n\\t}\\n\\n\\tInsert(&root, 5)\\n\\tInsert(&root, 4)\\n\\tInsert(&root, 3)\\n\\n\\tn := Get(root, 4)\\n\\tif n.Key != 4 {\\n\\t\\tt.Error(\\\"key should be 4\\\")\\n\\t}\\n\\tif n.Right.Key != 5 {\\n\\t\\tt.Error(\\\"right child should have value 5\\\")\\n\\t}\\n\\n\\tif n.Left.Key != 3 {\\n\\t\\tt.Error(\\\"left child should have value 3\\\")\\n\\t}\\n\\n}\\n\"",
    "bs tree": "\"package binarytree\\n\\n// BSTree Returns a binary search tree structure which contains only a root Node\\ntype BSTree struct {\\n\\tRoot *Node\\n}\\n\\n// calculateDepth helper function for BSTree's depth()\\nfunc calculateDepth(n *Node, depth int) int {\\n\\tif n == nil {\\n\\t\\treturn depth\\n\\t}\\n\\treturn Max(calculateDepth(n.left, depth+1), calculateDepth(n.right, depth+1))\\n}\\n\\n// Insert a value in the BSTree\\nfunc Insert(root *Node, val int) *Node {\\n\\tif root == nil {\\n\\t\\treturn NewNode(val)\\n\\t}\\n\\tif val < root.val {\\n\\t\\troot.left = Insert(root.left, val)\\n\\t} else {\\n\\t\\troot.right = Insert(root.right, val)\\n\\t}\\n\\treturn root\\n}\\n\\n// Depth returns the calculated depth of a binary saerch tree\\nfunc (t *BSTree) Depth() int {\\n\\treturn calculateDepth(t.Root, 0)\\n}\\n\\n// InOrderSuccessor Goes to the left\\nfunc InOrderSuccessor(root *Node) *Node {\\n\\tcur := root\\n\\tfor cur.left != nil {\\n\\t\\tcur = cur.left\\n\\t}\\n\\treturn cur\\n}\\n\\n// BstDelete removes the node\\nfunc BstDelete(root *Node, val int) *Node {\\n\\tif root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\tif val < root.val {\\n\\t\\troot.left = BstDelete(root.left, val)\\n\\t} else if val > root.val {\\n\\t\\troot.right = BstDelete(root.right, val)\\n\\t} else {\\n\\t\\t// this is the node to delete\\n\\t\\t// node with one child\\n\\t\\tif root.left == nil {\\n\\t\\t\\treturn root.right\\n\\t\\t} else if root.right == nil {\\n\\t\\t\\treturn root.left\\n\\t\\t} else {\\n\\t\\t\\tn := root.right\\n\\t\\t\\td := InOrderSuccessor(n)\\n\\t\\t\\td.left = root.left\\n\\t\\t\\treturn root.right\\n\\t\\t}\\n\\t}\\n\\treturn root\\n}\\n\\n// InOrder add's children to a node in order left first then right recursively\\nfunc inOrderRecursive(n *Node, traversal *[]int) {\\n\\tif n != nil {\\n\\t\\tinOrderRecursive(n.left, traversal)\\n\\t\\t*traversal = append(*traversal, n.val)\\n\\t\\tinOrderRecursive(n.right, traversal)\\n\\t}\\n}\\n\\n// Travers the tree in the following order left --> root --> right\\nfunc InOrder(root *Node) []int {\\n\\ttraversal := make([]int, 0)\\n\\tinOrderRecursive(root, &traversal)\\n\\treturn traversal\\n}\\n\\n// PreOrder Preorder\\nfunc preOrderRecursive(n *Node, traversal *[]int) {\\n\\tif n == nil {\\n\\t\\treturn\\n\\t}\\n\\t*traversal = append(*traversal, n.val)\\n\\tpreOrderRecursive(n.left, traversal)\\n\\tpreOrderRecursive(n.right, traversal)\\n}\\n\\n// Travers the tree in the following order root --> left --> right\\nfunc PreOrder(root *Node) []int {\\n\\ttraversal := make([]int, 0)\\n\\tpreOrderRecursive(root, &traversal)\\n\\treturn traversal\\n}\\n\\n// PostOrder PostOrder\\nfunc postOrderRecursive(n *Node, traversal *[]int) {\\n\\tif n == nil {\\n\\t\\treturn\\n\\t}\\n\\tpostOrderRecursive(n.left, traversal)\\n\\tpostOrderRecursive(n.right, traversal)\\n\\t*traversal = append(*traversal, n.val)\\n}\\n\\n// Travers the tree in the following order left --> right --> root\\nfunc PostOrder(root *Node) []int {\\n\\ttraversal := make([]int, 0)\\n\\tpostOrderRecursive(root, &traversal)\\n\\treturn traversal\\n}\\n\\n// LevelOrder LevelOrder\\nfunc levelOrderRecursive(root *Node, traversal *[]int) {\\n\\tvar q []*Node // queue\\n\\tvar n *Node   // temporary node\\n\\n\\tq = append(q, root)\\n\\n\\tfor len(q) != 0 {\\n\\t\\tn, q = q[0], q[1:]\\n\\t\\t*traversal = append(*traversal, n.val)\\n\\t\\tif n.left != nil {\\n\\t\\t\\tq = append(q, n.left)\\n\\t\\t}\\n\\t\\tif n.right != nil {\\n\\t\\t\\tq = append(q, n.right)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc LevelOrder(root *Node) []int {\\n\\ttraversal := make([]int, 0)\\n\\tlevelOrderRecursive(root, &traversal)\\n\\treturn traversal\\n}\\n\\n// AccessNodesByLayer Function that access nodes layer by layer instead of printing the results as one line.\\nfunc AccessNodesByLayer(root *Node) [][]int {\\n\\tvar res [][]int\\n\\tif root == nil {\\n\\t\\treturn res\\n\\t}\\n\\tvar q []*Node\\n\\tvar n *Node\\n\\tvar idx = 0\\n\\tq = append(q, root)\\n\\n\\tfor len(q) != 0 {\\n\\t\\tres = append(res, []int{})\\n\\t\\tqLen := len(q)\\n\\t\\tfor i := 0; i < qLen; i++ {\\n\\t\\t\\tn, q = q[0], q[1:]\\n\\t\\t\\tres[idx] = append(res[idx], n.val)\\n\\t\\t\\tif n.left != nil {\\n\\t\\t\\t\\tq = append(q, n.left)\\n\\t\\t\\t}\\n\\t\\t\\tif n.right != nil {\\n\\t\\t\\t\\tq = append(q, n.right)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tidx++\\n\\t}\\n\\treturn res\\n}\\n\\n// Max Function that returns max of two numbers - possibly already declared.\\nfunc Max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\"",
    "bs tree test": "\"package binarytree\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestInsert(t *testing.T) {\\n\\tBSTree := BSTree{\\n\\t\\tRoot: NewNode(90),\\n\\t}\\n\\n\\troot := BSTree.Root\\n\\n\\tInsert(root, 80)\\n\\tInsert(root, 100)\\n\\n\\tif root.val != 90 {\\n\\t\\tt.Errorf(\\\"root should have value = 90\\\")\\n\\t}\\n\\n\\tif root.left.val != 80 {\\n\\t\\tt.Errorf(\\\"left child should have value = 80\\\")\\n\\t}\\n\\n\\tif root.right.val != 100 {\\n\\t\\tt.Errorf(\\\"right child should have value = 100\\\")\\n\\t}\\n\\n\\tif BSTree.Depth() != 2 {\\n\\t\\tt.Errorf(\\\"tree should have depth = 1\\\")\\n\\t}\\n}\\n\\nfunc TestDelete(t *testing.T) {\\n\\tt.Run(\\\"Delete a node with no child\\\", func(t *testing.T) {\\n\\t\\tBSTree := BSTree{\\n\\t\\t\\tRoot: NewNode(90),\\n\\t\\t}\\n\\n\\t\\troot := BSTree.Root\\n\\n\\t\\tInsert(root, 80)\\n\\t\\tInsert(root, 100)\\n\\n\\t\\tBstDelete(root, 100)\\n\\n\\t\\tif root.val != 90 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 90\\\")\\n\\t\\t}\\n\\n\\t\\tif root.left.val != 80 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 80\\\")\\n\\t\\t}\\n\\n\\t\\tif root.right != nil {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = nil\\\")\\n\\t\\t}\\n\\n\\t\\tif BSTree.Depth() != 2 {\\n\\t\\t\\tt.Errorf(\\\"Depth should have value = 2\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Delete a node with one child\\\", func(t *testing.T) {\\n\\t\\tBSTree := BSTree{\\n\\t\\t\\tRoot: NewNode(90),\\n\\t\\t}\\n\\n\\t\\troot := BSTree.Root\\n\\n\\t\\tInsert(root, 80)\\n\\t\\tInsert(root, 100)\\n\\t\\tInsert(root, 70)\\n\\n\\t\\tBstDelete(root, 80)\\n\\n\\t\\tif root.val != 90 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 90\\\")\\n\\t\\t}\\n\\n\\t\\tif root.right.val != 100 {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = 100\\\")\\n\\t\\t}\\n\\n\\t\\tif root.left.val != 70 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 70\\\")\\n\\t\\t}\\n\\n\\t\\tif BSTree.Depth() != 2 {\\n\\t\\t\\tt.Errorf(\\\"Depth should have value = 2\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Delete a node with two children\\\", func(t *testing.T) {\\n\\t\\tBSTree := BSTree{\\n\\t\\t\\tRoot: NewNode(90),\\n\\t\\t}\\n\\n\\t\\troot := BSTree.Root\\n\\n\\t\\tInsert(root, 80)\\n\\t\\tInsert(root, 100)\\n\\t\\tInsert(root, 70)\\n\\t\\tInsert(root, 85)\\n\\n\\t\\tBstDelete(root, 80)\\n\\n\\t\\tif root.val != 90 {\\n\\t\\t\\tt.Errorf(\\\"root should have value = 90\\\")\\n\\t\\t}\\n\\n\\t\\tif root.left.val != 85 {\\n\\t\\t\\tt.Errorf(\\\"left child should have value = 85\\\")\\n\\t\\t}\\n\\n\\t\\tif root.right.val != 100 {\\n\\t\\t\\tt.Errorf(\\\"right child should have value = 100\\\")\\n\\t\\t}\\n\\n\\t\\tif BSTree.Depth() != 3 {\\n\\t\\t\\tt.Errorf(\\\"Depth should have value = 3\\\")\\n\\t\\t}\\n\\t})\\n}\\n\\nfunc TestInOrder(t *testing.T) {\\n\\tBSTree := BSTree{\\n\\t\\tRoot: NewNode(90),\\n\\t}\\n\\n\\troot := BSTree.Root\\n\\n\\tInsert(root, 80)\\n\\tInsert(root, 100)\\n\\tInsert(root, 70)\\n\\tInsert(root, 85)\\n\\tInsert(root, 95)\\n\\tInsert(root, 105)\\n\\n\\ta := InOrder(root)\\n\\tb := []int{70, 80, 85, 90, 95, 100, 105}\\n\\n\\tif !reflect.DeepEqual(a, b) {\\n\\t\\tt.Errorf(\\\"Nodes should have value = [70 80 85 90 95 100 105]\\\")\\n\\t}\\n}\\n\\nfunc TestPreOrder(t *testing.T) {\\n\\tBSTree := BSTree{\\n\\t\\tRoot: NewNode(90),\\n\\t}\\n\\n\\troot := BSTree.Root\\n\\n\\tInsert(root, 80)\\n\\tInsert(root, 100)\\n\\tInsert(root, 70)\\n\\tInsert(root, 85)\\n\\tInsert(root, 95)\\n\\tInsert(root, 105)\\n\\n\\ta := PreOrder(root)\\n\\tb := []int{90, 80, 70, 85, 100, 95, 105}\\n\\n\\tif !reflect.DeepEqual(a, b) {\\n\\t\\tt.Errorf(\\\"Nodes should have value = [90 80 70 85 100 95 105]\\\")\\n\\t}\\n}\\n\\nfunc TestPostOrder(t *testing.T) {\\n\\tBSTree := BSTree{\\n\\t\\tRoot: NewNode(90),\\n\\t}\\n\\n\\troot := BSTree.Root\\n\\n\\tInsert(root, 80)\\n\\tInsert(root, 100)\\n\\tInsert(root, 70)\\n\\tInsert(root, 85)\\n\\tInsert(root, 95)\\n\\tInsert(root, 105)\\n\\n\\ta := PostOrder(root)\\n\\tb := []int{70, 85, 80, 95, 105, 100, 90}\\n\\n\\tif !reflect.DeepEqual(a, b) {\\n\\t\\tt.Errorf(\\\"Nodes should have value = [70 85 80 95 105 100 90]\\\")\\n\\t}\\n}\\n\\nfunc TestLevelOrder(t *testing.T) {\\n\\tBSTree := BSTree{\\n\\t\\tRoot: NewNode(90),\\n\\t}\\n\\n\\troot := BSTree.Root\\n\\n\\tInsert(root, 80)\\n\\tInsert(root, 100)\\n\\tInsert(root, 70)\\n\\tInsert(root, 85)\\n\\tInsert(root, 95)\\n\\tInsert(root, 105)\\n\\n\\ta := LevelOrder(root)\\n\\tb := []int{90, 80, 100, 70, 85, 95, 105}\\n\\n\\tif !reflect.DeepEqual(a, b) {\\n\\t\\tt.Errorf(\\\"Nodes should have value = [90 80 100 70 85 95 105]\\\")\\n\\t}\\n}\\n\\nfunc TestAccessNodesByLayer(t *testing.T) {\\n\\tBSTree := BSTree{\\n\\t\\tRoot: NewNode(90),\\n\\t}\\n\\n\\troot := BSTree.Root\\n\\n\\tInsert(root, 80)\\n\\tInsert(root, 100)\\n\\tInsert(root, 70)\\n\\tInsert(root, 85)\\n\\tInsert(root, 95)\\n\\tInsert(root, 105)\\n\\n\\ta := AccessNodesByLayer(root)\\n\\tb := [][]int{{90}, {80, 100}, {70, 85, 95, 105}}\\n\\n\\tif !reflect.DeepEqual(a, b) {\\n\\t\\tt.Errorf(\\\"Nodes should have value = [[90] [80 100] [70 85 95 105]]\\\")\\n\\t}\\n}\\n\"",
    "node": "\"package binarytree\\n\\n// Node structure for Nodes\\ntype Node struct {\\n\\tval   int\\n\\tleft  *Node\\n\\tright *Node\\n}\\n\\n// NewNode Returns a new pointer to an empty Node\\nfunc NewNode(val int) *Node {\\n\\treturn &Node{val, nil, nil}\\n}\\n\"",
    "dynamic array": "\"// Package dynamicarray\\n// A dynamic array is quite similar to a regular array, but its Size is modifiable during program runtime,\\n// very similar to how a slice in Go works. The implementation is for educational purposes and explains\\n// how one might go about implementing their own version of slices.\\n//\\n// For more details check out those links below here:\\n// GeeksForGeeks article : https://www.geeksforgeeks.org/how-do-dynamic-arrays-work/\\n// Go blog: https://blog.golang.org/slices-intro\\n// Go blog: https://blog.golang.org/slices\\n// authors [Wesllhey Holanda](https://github.com/wesllhey), [Milad](https://github.com/miraddo)\\n// see dynamicarray.go, dynamicarray_test.go\\npackage dynamicarray\\n\\nimport (\\n\\t\\\"errors\\\"\\n)\\n\\nvar defaultCapacity = 10\\n\\n// DynamicArray structure\\ntype DynamicArray struct {\\n\\tSize        int\\n\\tCapacity    int\\n\\tElementData []interface{}\\n}\\n\\n// Put function is change/update the value in array with the index and new value\\nfunc (da *DynamicArray) Put(index int, element interface{}) error {\\n\\terr := da.CheckRangeFromIndex(index)\\n\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\tda.ElementData[index] = element\\n\\n\\treturn nil\\n}\\n\\n// Add function is add new element to our array\\nfunc (da *DynamicArray) Add(element interface{}) {\\n\\tif da.Size == da.Capacity {\\n\\t\\tda.NewCapacity()\\n\\t}\\n\\n\\tda.ElementData[da.Size] = element\\n\\tda.Size++\\n}\\n\\n// Remove function is remove an element with the index\\nfunc (da *DynamicArray) Remove(index int) error {\\n\\terr := da.CheckRangeFromIndex(index)\\n\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\tcopy(da.ElementData[index:], da.ElementData[index+1:da.Size])\\n\\tda.ElementData[da.Size-1] = nil\\n\\n\\tda.Size--\\n\\n\\treturn nil\\n}\\n\\n// Get function is return one element with the index of array\\nfunc (da *DynamicArray) Get(index int) (interface{}, error) {\\n\\terr := da.CheckRangeFromIndex(index)\\n\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\treturn da.ElementData[index], nil\\n}\\n\\n// IsEmpty function is check that the array has value or not\\nfunc (da *DynamicArray) IsEmpty() bool {\\n\\treturn da.Size == 0\\n}\\n\\n// GetData function return all value of array\\nfunc (da *DynamicArray) GetData() []interface{} {\\n\\treturn da.ElementData[:da.Size]\\n}\\n\\n// CheckRangeFromIndex function it will check the range from the index\\nfunc (da *DynamicArray) CheckRangeFromIndex(index int) error {\\n\\tif index >= da.Size || index < 0 {\\n\\t\\treturn errors.New(\\\"index out of range\\\")\\n\\t}\\n\\treturn nil\\n}\\n\\n// NewCapacity function increase the Capacity\\nfunc (da *DynamicArray) NewCapacity() {\\n\\tif da.Capacity == 0 {\\n\\t\\tda.Capacity = defaultCapacity\\n\\t} else {\\n\\t\\tda.Capacity = da.Capacity << 1\\n\\t}\\n\\n\\tnewDataElement := make([]interface{}, da.Capacity)\\n\\n\\tcopy(newDataElement, da.ElementData)\\n\\n\\tda.ElementData = newDataElement\\n}\\n\"",
    "dynamic array test": "\"package dynamicarray\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestDynamicArray(t *testing.T) {\\n\\tnumbers := DynamicArray{}\\n\\n\\t// check numbers is empty or nut\\n\\tt.Run(\\\"Check Empty Dynamic Array\\\", func(t *testing.T) {\\n\\t\\tif numbers.IsEmpty() != true {\\n\\t\\t\\tt.Errorf(\\\"Expected be true but got %v\\\", numbers.IsEmpty())\\n\\t\\t}\\n\\t})\\n\\n\\tnumbers.Add(10)\\n\\tnumbers.Add(20)\\n\\tnumbers.Add(30)\\n\\tnumbers.Add(40)\\n\\tnumbers.Add(50)\\n\\n\\t// check numbers added to our dynamic array\\n\\tt.Run(\\\"Add Element into Dynamic Array\\\", func(t *testing.T) {\\n\\t\\tif numbers.IsEmpty() != false {\\n\\t\\t\\tt.Errorf(\\\"Expected be false but got %v\\\", numbers.IsEmpty())\\n\\t\\t}\\n\\t\\tvar res []interface{}\\n\\t\\tres = append(res, 10)\\n\\t\\tres = append(res, 20)\\n\\t\\tres = append(res, 30)\\n\\t\\tres = append(res, 40)\\n\\t\\tres = append(res, 50)\\n\\n\\t\\tif !reflect.DeepEqual(numbers.GetData(), res) {\\n\\t\\t\\tt.Errorf(\\\"Expected be [10, 20, 30, 40, 50] but got %v\\\", numbers.GetData())\\n\\t\\t}\\n\\t})\\n\\n\\t// Remove an Element inside the dynamic array with the index of array\\n\\tt.Run(\\\"Remove in Dynamic Array\\\", func(t *testing.T) {\\n\\t\\tif numbers.IsEmpty() != false {\\n\\t\\t\\tt.Errorf(\\\"Expected be false but got %v\\\", numbers.IsEmpty())\\n\\t\\t}\\n\\t\\tvar res []interface{}\\n\\t\\tres = append(res, 10)\\n\\t\\tres = append(res, 30)\\n\\t\\tres = append(res, 40)\\n\\t\\tres = append(res, 50)\\n\\n\\t\\t// remove the element by the index\\n\\t\\terr := numbers.Remove(1)\\n\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Errorf(\\\"Expected be [10, 30, 40, 50] but got an Error %v\\\", err)\\n\\t\\t}\\n\\n\\t\\tif !reflect.DeepEqual(numbers.GetData(), res) {\\n\\t\\t\\tt.Errorf(\\\"Expected be [10, 30, 40, 50] but got %v\\\", numbers.GetData())\\n\\t\\t}\\n\\t})\\n\\n\\t// get one element by the index of the dynamic array\\n\\tt.Run(\\\"Get in Dynamic Array\\\", func(t *testing.T) {\\n\\t\\tif numbers.IsEmpty() != false {\\n\\t\\t\\tt.Errorf(\\\"Expected be false but got %v\\\", numbers.IsEmpty())\\n\\t\\t}\\n\\n\\t\\t// return one element with the index\\n\\t\\tgetOne, _ := numbers.Get(2)\\n\\n\\t\\tif getOne != 40 {\\n\\t\\t\\tt.Errorf(\\\"Expected be 40 but got %v\\\", getOne)\\n\\t\\t}\\n\\n\\t})\\n\\n\\t// Put to add a value to specific index of Dynamic Array\\n\\tt.Run(\\\"Put to Dynamic Array\\\", func(t *testing.T) {\\n\\t\\tif numbers.IsEmpty() != false {\\n\\t\\t\\tt.Errorf(\\\"Expected be false but got %v\\\", numbers.IsEmpty())\\n\\t\\t}\\n\\n\\t\\t// change value of specific index\\n\\t\\terr := numbers.Put(0, 100)\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Errorf(\\\"Expected be [10, 30, 40, 50] but got an Error %v\\\", err)\\n\\t\\t}\\n\\n\\t\\tgetOne, _ := numbers.Get(0)\\n\\t\\tif getOne != 100 {\\n\\t\\t\\tt.Errorf(\\\"Expected be 100 but got %v\\\", getOne)\\n\\t\\t}\\n\\t})\\n\\n}\\n\"",
    "hashmap": "\"package hashmap\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"hash/fnv\\\"\\n)\\n\\nvar defaultCapacity uint64 = 1 << 10\\n\\ntype node struct {\\n\\tkey   interface{}\\n\\tvalue interface{}\\n\\tnext  *node\\n}\\n\\n// HashMap is golang implementation of hashmap\\ntype HashMap struct {\\n\\tcapacity uint64\\n\\tsize     uint64\\n\\ttable    []*node\\n}\\n\\n// New return new HashMap instance\\nfunc New() *HashMap {\\n\\treturn &HashMap{\\n\\t\\tcapacity: defaultCapacity,\\n\\t\\ttable:    make([]*node, defaultCapacity),\\n\\t}\\n}\\n\\n// Make creates a new HashMap instance with input size and capacity\\nfunc Make(size, capacity uint64) HashMap {\\n\\treturn HashMap{\\n\\t\\tsize:     size,\\n\\t\\tcapacity: capacity,\\n\\t\\ttable:    make([]*node, capacity),\\n\\t}\\n}\\n\\n// Get returns value associated with given key\\nfunc (hm *HashMap) Get(key interface{}) interface{} {\\n\\tnode := hm.getNodeByHash(hm.hash(key))\\n\\n\\tif node != nil {\\n\\t\\treturn node.value\\n\\t}\\n\\n\\treturn nil\\n}\\n\\n// Put puts new key value in hashmap\\nfunc (hm *HashMap) Put(key interface{}, value interface{}) interface{} {\\n\\treturn hm.putValue(hm.hash(key), key, value)\\n}\\n\\n// Contains checks if given key is stored in hashmap\\nfunc (hm *HashMap) Contains(key interface{}) bool {\\n\\tnode := hm.getNodeByHash(hm.hash(key))\\n\\treturn node != nil\\n}\\n\\nfunc (hm *HashMap) putValue(hash uint64, key interface{}, value interface{}) interface{} {\\n\\tif hm.capacity == 0 {\\n\\t\\thm.capacity = defaultCapacity\\n\\t\\thm.table = make([]*node, defaultCapacity)\\n\\t}\\n\\n\\tnode := hm.getNodeByHash(hash)\\n\\n\\tif node == nil {\\n\\t\\thm.table[hash] = newNode(key, value)\\n\\n\\t} else if node.key == key {\\n\\t\\thm.table[hash] = newNodeWithNext(key, value, node)\\n\\t\\treturn value\\n\\n\\t} else {\\n\\t\\thm.resize()\\n\\t\\treturn hm.putValue(hash, key, value)\\n\\t}\\n\\n\\thm.size++\\n\\n\\treturn value\\n\\n}\\n\\nfunc (hm *HashMap) getNodeByHash(hash uint64) *node {\\n\\treturn hm.table[hash]\\n}\\n\\nfunc (hm *HashMap) resize() {\\n\\thm.capacity <<= 1\\n\\n\\ttempTable := hm.table\\n\\n\\thm.table = make([]*node, hm.capacity)\\n\\n\\tfor i := 0; i < len(tempTable); i++ {\\n\\t\\tnode := tempTable[i]\\n\\t\\tif node == nil {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\thm.table[hm.hash(node.key)] = node\\n\\t}\\n}\\n\\nfunc newNode(key interface{}, value interface{}) *node {\\n\\treturn &node{\\n\\t\\tkey:   key,\\n\\t\\tvalue: value,\\n\\t}\\n}\\n\\nfunc newNodeWithNext(key interface{}, value interface{}, next *node) *node {\\n\\treturn &node{\\n\\t\\tkey:   key,\\n\\t\\tvalue: value,\\n\\t\\tnext:  next,\\n\\t}\\n}\\n\\nfunc (hm *HashMap) hash(key interface{}) uint64 {\\n\\th := fnv.New64a()\\n\\t_, _ = h.Write([]byte(fmt.Sprintf(\\\"%v\\\", key)))\\n\\n\\thashValue := h.Sum64()\\n\\n\\treturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))\\n}\\n\"",
    "hashmap test": "\"package hashmap_test\\n\\nimport (\\n\\t\\\"testing\\\"\\n\\n\\t\\\"github.com/TheAlgorithms/Go/structure/hashmap\\\"\\n)\\n\\nfunc TestHashMap(t *testing.T) {\\n\\n\\tmp := hashmap.New()\\n\\n\\tt.Run(\\\"Test 1: Put(10) and checking if Get() is correct\\\", func(t *testing.T) {\\n\\t\\tmp.Put(\\\"test\\\", 10)\\n\\t\\tgot := mp.Get(\\\"test\\\")\\n\\t\\tif got != 10 {\\n\\t\\t\\tt.Errorf(\\\"Put: %v, Got: %v\\\", 10, got)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test 2: Reassiging the value and checking if its correct\\\", func(t *testing.T) {\\n\\t\\tmp.Put(\\\"test\\\", 20)\\n\\t\\tgot := mp.Get(\\\"test\\\")\\n\\t\\tif got != 20 {\\n\\t\\t\\tt.Errorf(\\\"Put (reassign): %v, Got: %v\\\", 20, got)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test 3: Adding new key when there is already some data\\\", func(t *testing.T) {\\n\\t\\tmp.Put(\\\"test2\\\", 30)\\n\\t\\tgot := mp.Get(\\\"test2\\\")\\n\\t\\tif got != 30 {\\n\\t\\t\\tt.Errorf(\\\"Put: %v, Got: %v\\\", got, 30)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test 4: Adding numeric key\\\", func(t *testing.T) {\\n\\t\\tmp.Put(1, 40)\\n\\t\\tgot := mp.Get(1)\\n\\t\\tif got != 40 {\\n\\t\\t\\tt.Errorf(\\\"Put: %v, Got: %v\\\", got, 40)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test 5: Checking the Contains function\\\", func(t *testing.T) {\\n\\t\\twant := true\\n\\t\\tgot := mp.Contains(1)\\n\\t\\tif want != got {\\n\\t\\t\\tt.Errorf(\\\"Key '1' exists but couldn't be retrieved\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test 6: Checking if the key that does not exist returns false\\\", func(t *testing.T) {\\n\\t\\twant := false\\n\\t\\tgot := mp.Contains(2)\\n\\t\\tif got != want {\\n\\t\\t\\tt.Errorf(\\\"Key '2' does not exist in the map but it says otherwise\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test 7: Checking if the key does not exist Get func returns nil\\\", func(t *testing.T) {\\n\\t\\twant := interface{}(nil)\\n\\t\\tgot := mp.Get(2)\\n\\t\\tif got != want {\\n\\t\\t\\tt.Errorf(\\\"Key '2' does not exists in the map but it says otherwise\\\")\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test 8: Resizing a map\\\", func(t *testing.T) {\\n\\t\\tmp := hashmap.Make(4, 4)\\n\\n\\t\\tfor i := 0; i < 20; i++ {\\n\\t\\t\\tmp.Put(i, 40)\\n\\t\\t}\\n\\n\\t\\tgot := mp.Get(5)\\n\\t\\tif got != 40 {\\n\\t\\t\\tt.Errorf(\\\"Put: %v, Got: %v\\\", got, 40)\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "cyclic": "\"package linkedlist\\n\\nimport \\\"fmt\\\"\\n\\n// Cyclic Struct which cycles the linked list in this implementation.\\ntype Cyclic struct {\\n\\tSize int\\n\\tHead *Node\\n}\\n\\n// Create new list.\\nfunc NewCyclic() *Cyclic {\\n\\treturn &Cyclic{0, nil}\\n}\\n\\n// Inserting the first node is a special case. It will\\n// point to itself. For other cases, the node will be added\\n// to the end of the list. End of the list is Prev field of\\n// current item. Complexity O(1).\\nfunc (cl *Cyclic) Add(val interface{}) {\\n\\tn := NewNode(val)\\n\\tcl.Size++\\n\\tif cl.Head == nil {\\n\\t\\tn.Prev = n\\n\\t\\tn.Next = n\\n\\t\\tcl.Head = n\\n\\t} else {\\n\\t\\tn.Prev = cl.Head.Prev\\n\\t\\tn.Next = cl.Head\\n\\t\\tcl.Head.Prev.Next = n\\n\\t\\tcl.Head.Prev = n\\n\\t}\\n}\\n\\n// Rotate list by P places.\\n// This method is interesting for optimization.\\n// For first optimization we must decrease\\n// P value so that it ranges from 0 to N-1.\\n// For this we need to use the operation of\\n// division modulo. But be careful if P is less than 0.\\n// if it is - make it positive. This can be done without\\n// violating the meaning of the number by adding to it\\n// a multiple of N. Now you can decrease P modulo N to\\n// rotate the list by the minimum number of places.\\n// We use the fact that moving forward in a circle by P\\n// places is the same as moving N - P places back.\\n// Therefore, if P > N / 2, you can turn the list by N-P places back.\\n// Complexity O(n).\\nfunc (cl *Cyclic) Rotate(places int) {\\n\\tif cl.Size > 0 {\\n\\t\\tif places < 0 {\\n\\t\\t\\tmultiple := cl.Size - 1 - places/cl.Size\\n\\t\\t\\tplaces += multiple * cl.Size\\n\\t\\t}\\n\\t\\tplaces %= cl.Size\\n\\n\\t\\tif places > cl.Size/2 {\\n\\t\\t\\tplaces = cl.Size - places\\n\\t\\t\\tfor i := 0; i < places; i++ {\\n\\t\\t\\t\\tcl.Head = cl.Head.Prev\\n\\t\\t\\t}\\n\\t\\t} else if places == 0 {\\n\\t\\t\\treturn\\n\\t\\t} else {\\n\\t\\t\\tfor i := 0; i < places; i++ {\\n\\t\\t\\t\\tcl.Head = cl.Head.Next\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n}\\n\\n// Delete the current item.\\nfunc (cl *Cyclic) Delete() bool {\\n\\tvar deleted bool\\n\\tvar prevItem, thisItem, nextItem *Node\\n\\n\\tif cl.Size == 0 {\\n\\t\\treturn deleted\\n\\t}\\n\\n\\tdeleted = true\\n\\tthisItem = cl.Head\\n\\tnextItem = thisItem.Next\\n\\tprevItem = thisItem.Prev\\n\\n\\tif cl.Size == 1 {\\n\\t\\tcl.Head = nil\\n\\t} else {\\n\\t\\tcl.Head = nextItem\\n\\t\\tnextItem.Prev = prevItem\\n\\t\\tprevItem.Next = nextItem\\n\\t}\\n\\tcl.Size--\\n\\n\\treturn deleted\\n}\\n\\n// Destroy all items in the list.\\nfunc (cl *Cyclic) Destroy() {\\n\\tfor cl.Delete() {\\n\\t\\tcontinue\\n\\t}\\n}\\n\\n// Show list body.\\nfunc (cl *Cyclic) Walk() *Node {\\n\\tvar start *Node\\n\\tstart = cl.Head\\n\\n\\tfor i := 0; i < cl.Size; i++ {\\n\\t\\tfmt.Printf(\\\"%v \\\\n\\\", start.Val)\\n\\t\\tstart = start.Next\\n\\t}\\n\\treturn start\\n}\\n\\n// https://en.wikipedia.org/wiki/Josephus_problem\\n// This is a struct-based solution for Josephus problem.\\nfunc JosephusProblem(cl *Cyclic, k int) int {\\n\\tfor cl.Size > 1 {\\n\\t\\tcl.Rotate(k)\\n\\t\\tcl.Delete()\\n\\t\\tcl.Rotate(-1)\\n\\t}\\n\\tretval := cl.Head.Val.(int)\\n\\tcl.Destroy()\\n\\treturn retval\\n}\\n\"",
    "cyclic test": "\"package linkedlist\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc fillList(list *Cyclic, n int) {\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tlist.Add(i)\\n\\t}\\n}\\n\\nfunc TestAdd(t *testing.T) {\\n\\tlist := NewCyclic()\\n\\tfillList(list, 3)\\n\\n\\twant := []interface{}{1, 2, 3}\\n\\tvar got []interface{}\\n\\tvar start *Node\\n\\tstart = list.Head\\n\\n\\tfor i := 0; i < list.Size; i++ {\\n\\t\\tgot = append(got, start.Val)\\n\\t\\tstart = start.Next\\n\\t}\\n\\tif !reflect.DeepEqual(got, want) {\\n\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t}\\n}\\n\\nfunc TestWalk(t *testing.T) {\\n\\tlist := NewCyclic()\\n\\tfillList(list, 3)\\n\\n\\twant := 1\\n\\tgot := list.Walk()\\n\\n\\tif got.Val != want {\\n\\t\\tt.Errorf(\\\"got: %v, want: nil\\\", got)\\n\\t}\\n}\\n\\nfunc TestRotate(t *testing.T) {\\n\\ttype testCase struct {\\n\\t\\tparam        int\\n\\t\\twantToReturn int\\n\\t}\\n\\tlist := NewCyclic()\\n\\tfillList(list, 3)\\n\\n\\ttestCases := []testCase{\\n\\t\\t{1, 2},\\n\\t\\t{3, 2},\\n\\t\\t{6, 2},\\n\\t\\t{7, 3},\\n\\t\\t{-2, 1},\\n\\t\\t{5, 3},\\n\\t\\t{8, 2},\\n\\t\\t{-8, 3},\\n\\t}\\n\\tfor idx, tCase := range testCases {\\n\\t\\tlist.Rotate(tCase.param)\\n\\t\\tgot := list.Head.Val\\n\\t\\tif got != tCase.wantToReturn {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v for test id %v\\\", got, tCase.wantToReturn, idx)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc TestDelete(t *testing.T) {\\n\\tlist := NewCyclic()\\n\\tfillList(list, 3)\\n\\n\\twant := 2\\n\\twantSize := 2\\n\\tlist.Delete()\\n\\tgot := list.Head.Val\\n\\tif want != got {\\n\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t}\\n\\tif wantSize != list.Size {\\n\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t}\\n}\\n\\nfunc TestDestroy(t *testing.T) {\\n\\tlist := NewCyclic()\\n\\tfillList(list, 3)\\n\\twantSize := 0\\n\\tlist.Destroy()\\n\\n\\tgot := list.Head\\n\\n\\tif got != nil {\\n\\t\\tt.Errorf(\\\"got: %v, want: nil\\\", got)\\n\\t}\\n\\n\\tif wantSize != list.Size {\\n\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, wantSize)\\n\\t}\\n}\\n\\nfunc TestJosephusProblem(t *testing.T) {\\n\\ttype testCase struct {\\n\\t\\tparam        int\\n\\t\\twantToReturn int\\n\\t\\tlistCount    int\\n\\t}\\n\\n\\ttestCases := []testCase{\\n\\t\\t{5, 4, 8},\\n\\t\\t{3, 8, 8},\\n\\t\\t{8, 5, 8},\\n\\t\\t{8, 5, 8},\\n\\t\\t{2, 14, 14},\\n\\t\\t{13, 56, 58},\\n\\t\\t{7, 5, 5},\\n\\t}\\n\\n\\tfor _, tCase := range testCases {\\n\\t\\tlist := NewCyclic()\\n\\t\\tfillList(list, tCase.listCount)\\n\\t\\tgot := JosephusProblem(list, tCase.param)\\n\\t\\tif got != tCase.wantToReturn {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, tCase.wantToReturn)\\n\\t\\t}\\n\\t}\\n}\\n\"",
    "doc": "\"// Package linkedlist demonstates different implementations on linkedlists.\\npackage linkedlist\\n\"",
    "doubly": "\"package linkedlist\\n\\nimport \\\"fmt\\\"\\n\\n// Doubly structure with just the Head Node\\n// We call it `Doubly` to make it easier to\\n// understand when calling this in peoples\\n// own local code to understand and experiment\\n// with this easily.\\n// For example, we can use gotools `go get` command to get\\n// this repository cloned inside the\\n// $GOPATH/src/github.com/TheAlgorithms/Go (you can do this\\n// manually as well) and use the import statement as follows:\\n//\\n// `import \\\"github.com/TheAlgorithms/Go/structure/linkedlist\\\"`\\n//\\n// and call linkedlist.Doubly to create a new doubly linked list.\\ntype Doubly struct {\\n\\tHead *Node\\n}\\n\\nfunc NewDoubly() *Doubly {\\n\\treturn &Doubly{nil}\\n}\\n\\n// AddAtBeg Add a node to the beginning of the linkedlist\\nfunc (ll *Doubly) AddAtBeg(val interface{}) {\\n\\tn := NewNode(val)\\n\\tn.Next = ll.Head\\n\\n\\tif ll.Head != nil {\\n\\t\\tll.Head.Prev = n\\n\\t}\\n\\n\\tll.Head = n\\n\\n}\\n\\n// AddAtEnd Add a node at the end of the linkedlist\\nfunc (ll *Doubly) AddAtEnd(val interface{}) {\\n\\tn := NewNode(val)\\n\\n\\tif ll.Head == nil {\\n\\t\\tll.Head = n\\n\\t\\treturn\\n\\t}\\n\\n\\tcur := ll.Head\\n\\tfor ; cur.Next != nil; cur = cur.Next {\\n\\t}\\n\\tcur.Next = n\\n\\tn.Prev = cur\\n}\\n\\n// DelAtBeg Delete the node at the beginning of the linkedlist\\nfunc (ll *Doubly) DelAtBeg() interface{} {\\n\\tif ll.Head == nil {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tcur := ll.Head\\n\\tll.Head = cur.Next\\n\\n\\tif ll.Head != nil {\\n\\t\\tll.Head.Prev = nil\\n\\t}\\n\\treturn cur.Val\\n}\\n\\n// DetAtEnd Delete a node at the end of the linkedlist\\nfunc (ll *Doubly) DelAtEnd() interface{} {\\n\\t// no item\\n\\tif ll.Head == nil {\\n\\t\\treturn -1\\n\\t}\\n\\n\\t// only one item\\n\\tif ll.Head.Next == nil {\\n\\t\\treturn ll.DelAtBeg()\\n\\t}\\n\\n\\t// more than one, go to second last\\n\\tcur := ll.Head\\n\\tfor ; cur.Next.Next != nil; cur = cur.Next {\\n\\t}\\n\\n\\tretval := cur.Next.Val\\n\\tcur.Next = nil\\n\\treturn retval\\n}\\n\\n// Count Number of nodes in the linkedlist\\nfunc (ll *Doubly) Count() interface{} {\\n\\tvar ctr int = 0\\n\\n\\tfor cur := ll.Head; cur != nil; cur = cur.Next {\\n\\t\\tctr += 1\\n\\t}\\n\\n\\treturn ctr\\n}\\n\\n// Reverse Reverse the order of the linkedlist\\nfunc (ll *Doubly) Reverse() {\\n\\tvar Prev, Next *Node\\n\\tcur := ll.Head\\n\\n\\tfor cur != nil {\\n\\t\\tNext = cur.Next\\n\\t\\tcur.Next = Prev\\n\\t\\tcur.Prev = Next\\n\\t\\tPrev = cur\\n\\t\\tcur = Next\\n\\t}\\n\\n\\tll.Head = Prev\\n}\\n\\n// Display display the linked list\\nfunc (ll *Doubly) Display() {\\n\\tfor cur := ll.Head; cur != nil; cur = cur.Next {\\n\\t\\tfmt.Print(cur.Val, \\\" \\\")\\n\\t}\\n\\n\\tfmt.Print(\\\"\\\\n\\\")\\n}\\n\\n// DisplayReverse Display the linkedlist in reverse order\\nfunc (ll *Doubly) DisplayReverse() {\\n\\tif ll.Head == nil {\\n\\t\\treturn\\n\\t}\\n\\tvar cur *Node\\n\\tfor cur = ll.Head; cur.Next != nil; cur = cur.Next {\\n\\t}\\n\\n\\tfor ; cur != nil; cur = cur.Prev {\\n\\t\\tfmt.Print(cur.Val, \\\" \\\")\\n\\t}\\n\\n\\tfmt.Print(\\\"\\\\n\\\")\\n}\\n\"",
    "doubly test": "\"package linkedlist\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestDoubly(t *testing.T) {\\n\\tnewList := NewDoubly()\\n\\n\\tnewList.AddAtBeg(1)\\n\\tnewList.AddAtBeg(2)\\n\\tnewList.AddAtBeg(3)\\n\\n\\tt.Run(\\\"Test AddAtBeg\\\", func(t *testing.T) {\\n\\t\\twantNext := []int{3, 2, 1}\\n\\t\\twantPrev := []int{1, 2, 3}\\n\\t\\tgot := []int{}\\n\\n\\t\\t// check from Next address\\n\\t\\tcurrent := newList.Head\\n\\n\\t\\tgot = append(got, current.Val.(int))\\n\\n\\t\\tfor current.Next != nil {\\n\\t\\t\\tcurrent = current.Next\\n\\t\\t\\tgot = append(got, current.Val.(int))\\n\\t\\t}\\n\\n\\t\\tif !reflect.DeepEqual(got, wantNext) {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, wantNext)\\n\\t\\t}\\n\\n\\t\\t// check from Prev address\\n\\t\\tgot = []int{}\\n\\t\\tgot = append(got, current.Val.(int))\\n\\n\\t\\tfor current.Prev != nil {\\n\\t\\t\\tcurrent = current.Prev\\n\\t\\t\\tgot = append(got, current.Val.(int))\\n\\t\\t}\\n\\n\\t\\tif !reflect.DeepEqual(got, wantPrev) {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, wantPrev)\\n\\t\\t}\\n\\t})\\n\\n\\tnewList.AddAtEnd(4)\\n\\n\\tt.Run(\\\"Test AddAtEnd\\\", func(t *testing.T) {\\n\\t\\twant := []int{3, 2, 1, 4}\\n\\t\\tgot := []int{}\\n\\t\\tcurrent := newList.Head\\n\\t\\tgot = append(got, current.Val.(int))\\n\\t\\tfor current.Next != nil {\\n\\t\\t\\tcurrent = current.Next\\n\\t\\t\\tgot = append(got, current.Val.(int))\\n\\t\\t}\\n\\t\\tif !reflect.DeepEqual(got, want) {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test DelAtBeg\\\", func(t *testing.T) {\\n\\t\\twant := 3\\n\\t\\tgot := newList.DelAtBeg()\\n\\t\\tif got != want {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test DelAtEnd\\\", func(t *testing.T) {\\n\\t\\twant := 4\\n\\t\\tgot := newList.DelAtEnd()\\n\\t\\tif got != want {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test Count\\\", func(t *testing.T) {\\n\\t\\twant := 2\\n\\t\\tgot := newList.Count()\\n\\t\\tif got != want {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n\\n\\tnewList2 := NewDoubly()\\n\\tnewList2.AddAtBeg(1)\\n\\tnewList2.AddAtBeg(2)\\n\\tnewList2.AddAtBeg(3)\\n\\tt.Run(\\\"Test Reverse\\\", func(t *testing.T) {\\n\\t\\twant := []int{1, 2, 3}\\n\\t\\tgot := []int{}\\n\\t\\tnewList2.Reverse()\\n\\t\\tcurrent := newList2.Head\\n\\t\\tgot = append(got, current.Val.(int))\\n\\t\\tfor current.Next != nil {\\n\\t\\t\\tcurrent = current.Next\\n\\t\\t\\tgot = append(got, current.Val.(int))\\n\\t\\t}\\n\\t\\tif !reflect.DeepEqual(got, want) {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "readme": "\"# Linked List\\n***\\n## What is it?\\n***\\nLinked list is a data structure that is a linear chain of data elements whose order is not given by their phyisical placement in memory. This structure is built up of nodes which point to the element ahead or behind this particular node (depending on the type of Linked List).\\n\\n# Types of Linked List implemented within this repository\\n\\n## Singly Linked List\\nSingly Linked List is a linked list in which a node only points to the next element.\\nSome of the main applications of Singly Linked List are in the construction\\nof fundamental data structures such as Stacks and Queues.\\n\\n## Doubly Linked List\\nDoubly Linked List is a linked list in which a node points to both the element ahead and behind the node.\\nAny application which requires us to keep track of forward and backward information uses doubly linked list.\\nFor example, the feature of undo and redo are implemented using these doubly linked lists.\\n\\n## Cyclic Linked List AKA Looped Linked List\\nLooped Linked Lists are singly or doubly-linked that chase their own tail:\\nA points to B, B points to C, C points to D, and D points to A. \\nThey are better suited for cyclic data such as train schedules.\\nThese lists are missing the first and last items.\\nTherefore, it is necessary to introduce the concept of the current position.\\n\\nThis picture shows similar lists:\\n![Alt text](./Linked_Cyclic_List.jpg?raw=true)\\n\"",
    "shared": "\"package linkedlist\\n\\n// Node Structure representing the linkedlist node.\\n// This node is shared across different implementations.\\ntype Node struct {\\n\\tVal  interface{}\\n\\tPrev *Node\\n\\tNext *Node\\n}\\n\\n// Create new node.\\nfunc NewNode(val interface{}) *Node {\\n\\treturn &Node{val, nil, nil}\\n}\\n\"",
    "singly linked list": "\"package linkedlist\\n\\n// demonstration of singly linked list in golang\\nimport (\\n\\t\\\"errors\\\"\\n\\t\\\"fmt\\\"\\n)\\n\\n// Singly structure with length of the list and its head\\ntype Singly struct {\\n\\tlength int\\n\\n\\t// Note that Node here holds both Next and Prev Node\\n\\t// however only the Next node is used in Singly methods.\\n\\tHead *Node\\n}\\n\\n// NewSingly returns a new instance of a linked list\\nfunc NewSingly() *Singly {\\n\\treturn &Singly{}\\n}\\n\\n// AddAtBeg adds a new snode with given value at the beginning of the list.\\nfunc (ll *Singly) AddAtBeg(val interface{}) {\\n\\tn := NewNode(val)\\n\\tn.Next = ll.Head\\n\\tll.Head = n\\n\\tll.length++\\n}\\n\\n// AddAtEnd adds a new snode with given value at the end of the list.\\nfunc (ll *Singly) AddAtEnd(val int) {\\n\\tn := NewNode(val)\\n\\n\\tif ll.Head == nil {\\n\\t\\tll.Head = n\\n\\t\\tll.length++\\n\\t\\treturn\\n\\t}\\n\\n\\tcur := ll.Head\\n\\tfor ; cur.Next != nil; cur = cur.Next {\\n\\t}\\n\\tcur.Next = n\\n\\tll.length++\\n}\\n\\n// DelAtBeg deletes the snode at the head(beginning) of the list and returns its value. Returns -1 if the list is empty.\\nfunc (ll *Singly) DelAtBeg() interface{} {\\n\\tif ll.Head == nil {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tcur := ll.Head\\n\\tll.Head = cur.Next\\n\\tll.length--\\n\\n\\treturn cur.Val\\n}\\n\\n// DelAtEnd deletes the snode at the tail(end) of the list and returns its value. Returns -1 if the list is empty.\\nfunc (ll *Singly) DelAtEnd() interface{} {\\n\\tif ll.Head == nil {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tif ll.Head.Next == nil {\\n\\t\\treturn ll.DelAtBeg()\\n\\t}\\n\\n\\tcur := ll.Head\\n\\n\\tfor ; cur.Next.Next != nil; cur = cur.Next {\\n\\t}\\n\\n\\tretval := cur.Next.Val\\n\\tcur.Next = nil\\n\\tll.length--\\n\\treturn retval\\n\\n}\\n\\n// Count returns the current size of the list.\\nfunc (ll *Singly) Count() int {\\n\\treturn ll.length\\n}\\n\\n// Reverse reverses the list.\\nfunc (ll *Singly) Reverse() {\\n\\tvar prev, Next *Node\\n\\tcur := ll.Head\\n\\n\\tfor cur != nil {\\n\\t\\tNext = cur.Next\\n\\t\\tcur.Next = prev\\n\\t\\tprev = cur\\n\\t\\tcur = Next\\n\\t}\\n\\n\\tll.Head = prev\\n}\\n\\n// ReversePartition Reverse the linked list from the ath to the bth node\\nfunc (ll *Singly) ReversePartition(left, right int) error {\\n\\terr := ll.CheckRangeFromIndex(left, right)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\ttmpNode := NewNode(-1)\\n\\ttmpNode.Next = ll.Head\\n\\tpre := tmpNode\\n\\tfor i := 0; i < left-1; i++ {\\n\\t\\tpre = pre.Next\\n\\t}\\n\\tcur := pre.Next\\n\\tfor i := 0; i < right-left; i++ {\\n\\t\\tnext := cur.Next\\n\\t\\tcur.Next = next.Next\\n\\t\\tnext.Next = pre.Next\\n\\t\\tpre.Next = next\\n\\t}\\n\\tll.Head = tmpNode.Next\\n\\treturn nil\\n}\\nfunc (ll *Singly) CheckRangeFromIndex(left, right int) error {\\n\\tif left > right {\\n\\t\\treturn errors.New(\\\"left boundary must smaller than right\\\")\\n\\t} else if left < 1 {\\n\\t\\treturn errors.New(\\\"left boundary starts from the first node\\\")\\n\\t} else if right > ll.length {\\n\\t\\treturn errors.New(\\\"right boundary cannot be greater than the length of the linked list\\\")\\n\\t}\\n\\treturn nil\\n}\\n\\n// Display prints out the elements of the list.\\nfunc (ll *Singly) Display() {\\n\\tfor cur := ll.Head; cur != nil; cur = cur.Next {\\n\\t\\tfmt.Print(cur.Val, \\\" \\\")\\n\\t}\\n\\n\\tfmt.Print(\\\"\\\\n\\\")\\n}\\n\"",
    "singly linked list test": "\"package linkedlist\\n\\nimport (\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestSingly(t *testing.T) {\\n\\tlist := NewSingly()\\n\\tlist.AddAtBeg(1)\\n\\tlist.AddAtBeg(2)\\n\\tlist.AddAtBeg(3)\\n\\n\\tt.Run(\\\"Test AddAtBeg()\\\", func(t *testing.T) {\\n\\t\\twant := []interface{}{3, 2, 1}\\n\\t\\tgot := []interface{}{}\\n\\t\\tcurrent := list.Head\\n\\t\\tgot = append(got, current.Val)\\n\\t\\tfor current.Next != nil {\\n\\t\\t\\tcurrent = current.Next\\n\\t\\t\\tgot = append(got, current.Val)\\n\\t\\t}\\n\\t\\tif !reflect.DeepEqual(got, want) {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n\\n\\tlist.AddAtEnd(4)\\n\\n\\tt.Run(\\\"Test AddAtEnd()\\\", func(t *testing.T) {\\n\\t\\twant := []interface{}{3, 2, 1, 4}\\n\\t\\tgot := []interface{}{}\\n\\t\\tcurrent := list.Head\\n\\t\\tgot = append(got, current.Val)\\n\\t\\tfor current.Next != nil {\\n\\t\\t\\tcurrent = current.Next\\n\\t\\t\\tgot = append(got, current.Val)\\n\\t\\t}\\n\\t\\tif !reflect.DeepEqual(got, want) {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test DelAtBeg()\\\", func(t *testing.T) {\\n\\t\\twant := interface{}(3)\\n\\t\\tgot := list.DelAtBeg()\\n\\t\\tif got != want {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test DelAtEnd()\\\", func(t *testing.T) {\\n\\t\\twant := interface{}(4)\\n\\t\\tgot := list.DelAtEnd()\\n\\t\\tif got != want {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test Count()\\\", func(t *testing.T) {\\n\\t\\twant := 2\\n\\t\\tgot := list.Count()\\n\\t\\tif got != want {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n\\n\\tlist2 := Singly{}\\n\\tlist2.AddAtBeg(1)\\n\\tlist2.AddAtBeg(2)\\n\\tlist2.AddAtBeg(3)\\n\\tlist2.AddAtBeg(4)\\n\\tlist2.AddAtBeg(5)\\n\\tlist2.AddAtBeg(6)\\n\\n\\tt.Run(\\\"Test Reverse()\\\", func(t *testing.T) {\\n\\t\\twant := []interface{}{1, 2, 3, 4, 5, 6}\\n\\t\\tgot := []interface{}{}\\n\\t\\tlist2.Reverse()\\n\\t\\tcurrent := list2.Head\\n\\t\\tgot = append(got, current.Val)\\n\\t\\tfor current.Next != nil {\\n\\t\\t\\tcurrent = current.Next\\n\\t\\t\\tgot = append(got, current.Val)\\n\\t\\t}\\n\\t\\tif !reflect.DeepEqual(got, want) {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Test ReversePartition()\\\", func(t *testing.T) {\\n\\t\\twant := []interface{}{1, 5, 4, 3, 2, 6}\\n\\t\\tgot := []interface{}{}\\n\\t\\terr := list2.ReversePartition(2, 5)\\n\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Errorf(\\\"Incorrect boundary conditions entered%v\\\", err)\\n\\t\\t}\\n\\t\\tcurrent := list2.Head\\n\\t\\tgot = append(got, current.Val)\\n\\t\\tfor current.Next != nil {\\n\\t\\t\\tcurrent = current.Next\\n\\t\\t\\tgot = append(got, current.Val)\\n\\t\\t}\\n\\t\\tif !reflect.DeepEqual(got, want) {\\n\\t\\t\\tt.Errorf(\\\"got: %v, want: %v\\\", got, want)\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "queue array": "\"// Queue Array\\n// description: based on `geeksforgeeks` description A Queue is a linear structure which follows a particular order in which the operations are performed.\\n// \\tThe order is First In First Out (FIFO).\\n// details:\\n// \\tQueue Data Structure : https://www.geeksforgeeks.org/queue-data-structure/\\n//  Queue (abstract data type) : https://en.wikipedia.org/wiki/Queue_(abstract_data_type)\\n// author [Milad](https://github.com/miraddo)\\n// see queuelinkedlist.go, queuelinkedlistwithlist.go, queue_test.go\\n\\npackage queue\\n\\nvar ListQueue []interface{}\\n\\n// EnQueue it will be added new value into our list\\nfunc EnQueue(n interface{}) {\\n\\tListQueue = append(ListQueue, n)\\n}\\n\\n// DeQueue it will be removed the first value that added into the list\\nfunc DeQueue() interface{} {\\n\\tdata := ListQueue[0]\\n\\tListQueue = ListQueue[1:]\\n\\treturn data\\n}\\n\\n// FrontQueue return the Front value\\nfunc FrontQueue() interface{} {\\n\\treturn ListQueue[0]\\n}\\n\\n// BackQueue return the Back value\\nfunc BackQueue() interface{} {\\n\\treturn ListQueue[len(ListQueue)-1]\\n}\\n\\n// LenQueue will return the length of the queue list\\nfunc LenQueue() int {\\n\\treturn len(ListQueue)\\n}\\n\\n// IsEmptyQueue check our list is empty or not\\nfunc IsEmptyQueue() bool {\\n\\treturn len(ListQueue) == 0\\n}\\n\"",
    "queue linked list": "\"// Queue Linked-List\\n// description: based on `geeksforgeeks` description A Queue is a linear structure which follows a particular order in which the operations are performed.\\n// \\tThe order is First In First Out (FIFO).\\n// details:\\n// \\tQueue Data Structure : https://www.geeksforgeeks.org/queue-data-structure/\\n//  Queue (abstract data type) : https://en.wikipedia.org/wiki/Queue_(abstract_data_type)\\n// author [Milad](https://github.com/miraddo)\\n// see queuearray.go, queuelinkedlistwithlist.go, queue_test.go\\n\\npackage queue\\n\\n// Node will be store the value and the next node as well\\ntype Node struct {\\n\\tData interface{}\\n\\tNext *Node\\n}\\n\\n// Queue structure is tell us what our head is and what tail should be with length of the list\\ntype Queue struct {\\n\\thead   *Node\\n\\ttail   *Node\\n\\tlength int\\n}\\n\\n// enqueue it will be added new value into queue\\nfunc (ll *Queue) enqueue(n interface{}) {\\n\\tvar newNode Node // create new Node\\n\\tnewNode.Data = n // set the data\\n\\n\\tif ll.tail != nil {\\n\\t\\tll.tail.Next = &newNode\\n\\t}\\n\\n\\tll.tail = &newNode\\n\\n\\tif ll.head == nil {\\n\\t\\tll.head = &newNode\\n\\t}\\n\\tll.length++\\n}\\n\\n// dequeue it will be removed the first value into queue (First In First Out)\\nfunc (ll *Queue) dequeue() interface{} {\\n\\tif ll.isEmpty() {\\n\\t\\treturn -1 // if is empty return -1\\n\\t}\\n\\tdata := ll.head.Data\\n\\n\\tll.head = ll.head.Next\\n\\n\\tif ll.head == nil {\\n\\t\\tll.tail = nil\\n\\t}\\n\\n\\tll.length--\\n\\treturn data\\n}\\n\\n// isEmpty it will check our list is empty or not\\nfunc (ll *Queue) isEmpty() bool {\\n\\treturn ll.length == 0\\n}\\n\\n// len is return the length of queue\\nfunc (ll *Queue) len() int {\\n\\treturn ll.length\\n}\\n\\n// frontQueue it will return the front data\\nfunc (ll *Queue) frontQueue() interface{} {\\n\\treturn ll.head.Data\\n}\\n\\n// backQueue it will return the back data\\nfunc (ll *Queue) backQueue() interface{} {\\n\\treturn ll.tail.Data\\n}\\n\"",
    "queue linked list with list": "\"// Queue Linked-List with standard library (Container/List)\\n// description: based on `geeksforgeeks` description A Queue is a linear structure which follows a particular order in which the operations are performed.\\n// \\tThe order is First In First Out (FIFO).\\n// details:\\n// \\tQueue Data Structure : https://www.geeksforgeeks.org/queue-data-structure/\\n//  Queue (abstract data type) : https://en.wikipedia.org/wiki/Queue_(abstract_data_type)\\n// author [Milad](https://github.com/miraddo)\\n// see queuearray.go, queuelinkedlist.go, queue_test.go\\n\\npackage queue\\n\\n// container/list: is used as linked-list\\n// fmt: used to return fmt.Errorf for the error part\\nimport (\\n\\t\\\"container/list\\\"\\n\\t\\\"fmt\\\"\\n)\\n\\n// LQueue will be store the value into the list\\ntype LQueue struct {\\n\\tqueue *list.List\\n}\\n\\n// Enqueue will be added new value\\nfunc (lq *LQueue) Enqueue(value interface{}) {\\n\\tlq.queue.PushBack(value)\\n}\\n\\n// Dequeue will be removed the first value that input (First In First Out - FIFO)\\nfunc (lq *LQueue) Dequeue() error {\\n\\n\\tif !lq.Empty() {\\n\\t\\telement := lq.queue.Front()\\n\\t\\tlq.queue.Remove(element)\\n\\n\\t\\treturn nil\\n\\t}\\n\\n\\treturn fmt.Errorf(\\\"dequeue is empty we got an error\\\")\\n}\\n\\n// Front it will return the front value\\nfunc (lq *LQueue) Front() (interface{}, error) {\\n\\tif !lq.Empty() {\\n\\t\\tval := lq.queue.Front().Value\\n\\t\\treturn val, nil\\n\\t}\\n\\n\\treturn \\\"\\\", fmt.Errorf(\\\"error queue is empty\\\")\\n}\\n\\n// Back it will return the back value\\nfunc (lq *LQueue) Back() (interface{}, error) {\\n\\tif !lq.Empty() {\\n\\t\\tval := lq.queue.Back().Value\\n\\t\\treturn val, nil\\n\\t}\\n\\n\\treturn \\\"\\\", fmt.Errorf(\\\"error queue is empty\\\")\\n}\\n\\n// Len it will return the length of list\\nfunc (lq *LQueue) Len() int {\\n\\treturn lq.queue.Len()\\n}\\n\\n// Empty is check our list is empty or not\\nfunc (lq *LQueue) Empty() bool {\\n\\treturn lq.queue.Len() == 0\\n}\\n\"",
    "queue test": "\"// Queue Test\\n// description: based on `geeksforgeeks` description A Queue is a linear structure which follows a particular order in which the operations are performed.\\n// \\tThe order is First In First Out (FIFO).\\n// details:\\n// \\tQueue Data Structure : https://www.geeksforgeeks.org/queue-data-structure/\\n//  Queue (abstract data type) : https://en.wikipedia.org/wiki/Queue_(abstract_data_type)\\n// author [Milad](https://github.com/miraddo)\\n// see queuearray.go, queuelinkedlist.go, queuelinkedlistwithlist.go\\n\\npackage queue\\n\\nimport (\\n\\t\\\"container/list\\\"\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestQueue(t *testing.T) {\\n\\n\\t// Handle Queue Linked List\\n\\tt.Run(\\\"Test Queue Linked List\\\", func(t *testing.T) {\\n\\n\\t\\tt.Run(\\\"Test EnQueue\\\", func(t *testing.T) {\\n\\t\\t\\tvar newQueue Queue\\n\\t\\t\\tnewQueue.enqueue(2)\\n\\t\\t\\tnewQueue.enqueue(3)\\n\\t\\t\\tnewQueue.enqueue(4)\\n\\t\\t\\tnewQueue.enqueue(45)\\n\\n\\t\\t\\tif newQueue.frontQueue() != 2 && newQueue.backQueue() != 45 {\\n\\t\\t\\t\\tt.Errorf(\\\"Test EnQueue is wrong the result must be %v and %v but got %v and %v\\\", 2, 45, newQueue.frontQueue(), newQueue.backQueue())\\n\\t\\t\\t}\\n\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"Test DeQueue\\\", func(t *testing.T) {\\n\\t\\t\\tvar newQueue Queue\\n\\t\\t\\tnewQueue.enqueue(2)\\n\\t\\t\\tnewQueue.enqueue(3)\\n\\t\\t\\tnewQueue.enqueue(4)\\n\\n\\t\\t\\tnewQueue.dequeue()\\n\\t\\t\\tif newQueue.dequeue() != 3 {\\n\\t\\t\\t\\tt.Errorf(\\\"Test DeQueue is wrong the result must be %v but got %v\\\", 3, newQueue.dequeue())\\n\\t\\t\\t}\\n\\n\\t\\t\\t//fmt.Println(newQueue.show())\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"Test Queue isEmpty\\\", func(t *testing.T) {\\n\\t\\t\\tvar newQueue Queue\\n\\t\\t\\tif newQueue.isEmpty() != true {\\n\\t\\t\\t\\tt.Errorf(\\\"Test Queue isEmpty is wrong the result must be %v but got %v\\\", true, newQueue.isEmpty())\\n\\t\\t\\t}\\n\\n\\t\\t\\tnewQueue.enqueue(3)\\n\\t\\t\\tnewQueue.enqueue(4)\\n\\n\\t\\t\\tif newQueue.isEmpty() != false {\\n\\t\\t\\t\\tt.Errorf(\\\"Test Queue isEmpty is wrong the result must be %v but got %v\\\", false, newQueue.isEmpty())\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"Test Queue Length\\\", func(t *testing.T) {\\n\\t\\t\\tvar newQueue Queue\\n\\t\\t\\tif newQueue.len() != 0 {\\n\\t\\t\\t\\tt.Errorf(\\\"Test Queue Length is wrong the result must be %v but got %v\\\", 0, newQueue.len())\\n\\t\\t\\t}\\n\\n\\t\\t\\tnewQueue.enqueue(3)\\n\\t\\t\\tnewQueue.enqueue(4)\\n\\t\\t\\tnewQueue.dequeue()\\n\\t\\t\\tnewQueue.enqueue(22)\\n\\t\\t\\tnewQueue.enqueue(99)\\n\\t\\t\\tnewQueue.dequeue()\\n\\t\\t\\tnewQueue.dequeue()\\n\\n\\t\\t\\tif newQueue.len() != 1 {\\n\\t\\t\\t\\tt.Errorf(\\\"Test Queue Length is wrong the result must be %v but got %v\\\", 1, newQueue.len())\\n\\t\\t\\t}\\n\\n\\t\\t})\\n\\t})\\n\\n\\t// Handle Queue Array\\n\\tt.Run(\\\"Test Queue Array\\\", func(t *testing.T) {\\n\\t\\tt.Run(\\\"Test EnQueue\\\", func(t *testing.T) {\\n\\t\\t\\tEnQueue(2)\\n\\t\\t\\tEnQueue(23)\\n\\t\\t\\tEnQueue(45)\\n\\t\\t\\tEnQueue(66)\\n\\n\\t\\t\\tif FrontQueue() != 2 && BackQueue() != 66 {\\n\\t\\t\\t\\tt.Errorf(\\\"Test EnQueue is wrong the result must be %v and %v but got %v and %v\\\", 2, 66, FrontQueue(), BackQueue())\\n\\t\\t\\t}\\n\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"Test DeQueue\\\", func(t *testing.T) {\\n\\t\\t\\tEnQueue(2)\\n\\t\\t\\tEnQueue(23)\\n\\t\\t\\tEnQueue(45)\\n\\t\\t\\tEnQueue(66)\\n\\n\\t\\t\\tDeQueue()\\n\\t\\t\\tDeQueue()\\n\\n\\t\\t\\tif DeQueue() != 45 {\\n\\t\\t\\t\\tt.Errorf(\\\"Test DeQueue is wrong the result must be %v but got %v\\\", 45, DeQueue())\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tListQueue = []interface{}{}\\n\\n\\t\\tt.Run(\\\"Test Queue isEmpty\\\", func(t *testing.T) {\\n\\n\\t\\t\\tif IsEmptyQueue() != true {\\n\\t\\t\\t\\tt.Errorf(\\\"Test Queue isEmpty is wrong the result must be %v but got %v\\\", true, IsEmptyQueue())\\n\\t\\t\\t}\\n\\n\\t\\t\\tEnQueue(3)\\n\\t\\t\\tEnQueue(4)\\n\\n\\t\\t\\tif IsEmptyQueue() != false {\\n\\t\\t\\t\\tt.Errorf(\\\"Test Queue isEmpty is wrong the result must be %v but got %v\\\", false, IsEmptyQueue())\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tListQueue = []interface{}{}\\n\\t\\tt.Run(\\\"Test Queue Length\\\", func(t *testing.T) {\\n\\t\\t\\tif LenQueue() != 0 {\\n\\t\\t\\t\\tt.Errorf(\\\"Test Queue Length is wrong the result must be %v but got %v\\\", 0, LenQueue())\\n\\t\\t\\t}\\n\\n\\t\\t\\tEnQueue(3)\\n\\t\\t\\tEnQueue(4)\\n\\t\\t\\tDeQueue()\\n\\t\\t\\tEnQueue(22)\\n\\t\\t\\tEnQueue(99)\\n\\t\\t\\tDeQueue()\\n\\t\\t\\tDeQueue()\\n\\n\\t\\t\\tif LenQueue() != 1 {\\n\\t\\t\\t\\tt.Errorf(\\\"Test Queue Length is wrong the result must be %v but got %v\\\", 1, LenQueue())\\n\\t\\t\\t}\\n\\n\\t\\t})\\n\\n\\t})\\n\\n\\t// Handle Queue Linked-List With Container/List (STL)\\n\\tt.Run(\\\"Test Container/List For Queue\\\", func(t *testing.T) {\\n\\t\\tlistQueue := &LQueue{\\n\\t\\t\\tqueue: list.New(),\\n\\t\\t}\\n\\n\\t\\tt.Run(\\\"List Enqueue\\\", func(t *testing.T) {\\n\\t\\t\\tlistQueue.Enqueue(\\\"Snap\\\")\\n\\t\\t\\tlistQueue.Enqueue(123)\\n\\t\\t\\tlistQueue.Enqueue(true)\\n\\t\\t\\tlistQueue.Enqueue(212.545454)\\n\\n\\t\\t\\tif listQueue.Len() != 4 {\\n\\t\\t\\t\\tt.Errorf(\\\"List Enqueue is not correct expected %d but got %d\\\", 4, listQueue.Len())\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"List Dequeue\\\", func(t *testing.T) {\\n\\n\\t\\t\\terr := listQueue.Dequeue()\\n\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tt.Error(\\\"got an unexpected error \\\", err)\\n\\t\\t\\t}\\n\\t\\t\\tif listQueue.Len() != 3 {\\n\\t\\t\\t\\tt.Errorf(\\\"List Dequeue is not correct expected %d but got %d\\\", 3, listQueue.Len())\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"List Front\\\", func(t *testing.T) {\\n\\n\\t\\t\\terr := listQueue.Dequeue()\\n\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tt.Error(\\\"got an unexpected error \\\", err)\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult, err := listQueue.Front()\\n\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tt.Error(\\\"got an unexpected error \\\", err)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif result != true {\\n\\t\\t\\t\\tt.Errorf(\\\"List Front is not correct expected %v but got %v\\\", true, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"List Back\\\", func(t *testing.T) {\\n\\n\\t\\t\\terr := listQueue.Dequeue()\\n\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tt.Error(\\\"got an unexpected error \\\", err)\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult, err := listQueue.Back()\\n\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tt.Error(\\\"got an unexpected error \\\", err)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif result != 212.545454 {\\n\\t\\t\\t\\tt.Errorf(\\\"List Back is not correct expected %v but got %v\\\", 212.545454, result)\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"List Length\\\", func(t *testing.T) {\\n\\n\\t\\t\\tlistQueue.Enqueue(\\\"Snap\\\")\\n\\n\\t\\t\\terr := listQueue.Dequeue()\\n\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tt.Error(\\\"got an unexpected error \\\", err)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif listQueue.Len() != 1 {\\n\\t\\t\\t\\tt.Errorf(\\\"List Length is not correct expected %v but got %v\\\", 1, listQueue.Len())\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"List Empty\\\", func(t *testing.T) {\\n\\n\\t\\t\\terr := listQueue.Dequeue()\\n\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tt.Error(\\\"got an unexpected error \\\", err)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif !listQueue.Empty() {\\n\\t\\t\\t\\tt.Errorf(\\\"List Empty is not correct expected %v but got %v\\\", true, listQueue.Empty())\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t})\\n\\n}\\n\"",
    "segment tree": "\"//Segment Tree Data Structure for Range Queries\\n//Build: O(n*log(n))\\n//Query: O(log(n))\\n//Update: O(log(n))\\n//reference: https://cp-algorithms.com/data_structures/segment_tree.html\\n\\npackage segmenttree\\n\\nimport (\\n\\t\\\"github.com/TheAlgorithms/Go/math/max\\\"\\n\\t\\\"github.com/TheAlgorithms/Go/math/min\\\"\\n)\\n\\nconst emptyLazyNode = -1\\n\\n//SegmentTree with original Array and the Segment Tree Array\\ntype SegmentTree struct {\\n\\tArray       []int\\n\\tSegmentTree []int\\n\\tLazyTree    []int\\n}\\n\\n//Propagate lazy tree node values\\nfunc (s *SegmentTree) Propagate(node int, leftNode int, rightNode int) {\\n\\tif s.LazyTree[node] != emptyLazyNode {\\n\\t\\t//add lazy node value multiplied by (right-left+1), which represents all interval\\n\\t\\t//this is the same of adding a value on each node\\n\\t\\ts.SegmentTree[node] += (rightNode - leftNode + 1) * s.LazyTree[node]\\n\\n\\t\\tif leftNode == rightNode {\\n\\t\\t\\t//leaf node\\n\\t\\t\\ts.Array[leftNode] = s.LazyTree[node]\\n\\t\\t} else {\\n\\t\\t\\t//propagate lazy node value for children nodes\\n\\t\\t\\ts.LazyTree[2*node] = s.LazyTree[node]\\n\\t\\t\\ts.LazyTree[2*node+1] = s.LazyTree[node]\\n\\t\\t}\\n\\n\\t\\t//clear lazy node\\n\\t\\ts.LazyTree[node] = emptyLazyNode\\n\\t}\\n}\\n\\n//Query on interval [firstIndex, leftIndex]\\n//node, leftNode and rightNode always should start with 1, 0 and len(Array)-1\\nfunc (s *SegmentTree) Query(node int, leftNode int, rightNode int, firstIndex int, lastIndex int) int {\\n\\tif (firstIndex > lastIndex) || (leftNode > rightNode) {\\n\\t\\t//outside the interval\\n\\t\\treturn 0\\n\\t}\\n\\n\\t//propagate lazy tree\\n\\ts.Propagate(node, leftNode, rightNode)\\n\\n\\tif (leftNode >= firstIndex) && (rightNode <= lastIndex) {\\n\\t\\t//inside the interval\\n\\t\\treturn s.SegmentTree[node]\\n\\t}\\n\\n\\t//get sum of left and right nodes\\n\\tmid := (leftNode + rightNode) / 2\\n\\n\\tleftNodeSum := s.Query(2*node, leftNode, mid, firstIndex, min.Int(mid, lastIndex))\\n\\trightNodeSum := s.Query(2*node+1, mid+1, rightNode, max.Int(firstIndex, mid+1), lastIndex)\\n\\n\\treturn leftNodeSum + rightNodeSum\\n}\\n\\n//Update Segment Tree\\n//node, leftNode and rightNode always should start with 1, 0 and len(Array)-1\\n//index is the Array index that you want to update\\n//value is the value that you want to override\\nfunc (s *SegmentTree) Update(node int, leftNode int, rightNode int, firstIndex int, lastIndex int, value int) {\\n\\t//propagate lazy tree\\n\\ts.Propagate(node, leftNode, rightNode)\\n\\n\\tif (firstIndex > lastIndex) || (leftNode > rightNode) {\\n\\t\\t//outside the interval\\n\\t\\treturn\\n\\t}\\n\\n\\tif (leftNode >= firstIndex) && (rightNode <= lastIndex) {\\n\\t\\t//inside the interval\\n\\t\\ts.LazyTree[node] = value\\n\\t\\ts.Propagate(node, leftNode, rightNode)\\n\\t} else {\\n\\t\\t//update left and right nodes\\n\\t\\tmid := (leftNode + rightNode) / 2\\n\\n\\t\\ts.Update(2*node, leftNode, mid, firstIndex, min.Int(mid, lastIndex), value)\\n\\t\\ts.Update(2*node+1, mid+1, rightNode, max.Int(firstIndex, mid+1), lastIndex, value)\\n\\n\\t\\ts.SegmentTree[node] = s.SegmentTree[2*node] + s.SegmentTree[2*node+1]\\n\\t}\\n}\\n\\n//Build Segment Tree\\n//node, leftNode and rightNode always should start with 1, 0 and len(Array)-1\\nfunc (s *SegmentTree) Build(node int, left int, right int) {\\n\\tif left == right {\\n\\t\\t//leaf node\\n\\t\\ts.SegmentTree[node] = s.Array[left]\\n\\t} else {\\n\\t\\t//get sum of left and right nodes\\n\\t\\tmid := (left + right) / 2\\n\\n\\t\\ts.Build(2*node, left, mid)\\n\\t\\ts.Build(2*node+1, mid+1, right)\\n\\n\\t\\ts.SegmentTree[node] = s.SegmentTree[2*node] + s.SegmentTree[2*node+1]\\n\\t}\\n}\\n\\nfunc NewSegmentTree(Array []int) *SegmentTree {\\n\\tif len(Array) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tsegTree := SegmentTree{\\n\\t\\tArray:       Array,\\n\\t\\tSegmentTree: make([]int, 4*len(Array)),\\n\\t\\tLazyTree:    make([]int, 4*len(Array)),\\n\\t}\\n\\n\\tfor i := range segTree.LazyTree {\\n\\t\\t//fill LazyTree with empty lazy nodes\\n\\t\\tsegTree.LazyTree[i] = emptyLazyNode\\n\\t}\\n\\n\\t//starts with node 1 and interval [0, len(arr)-1] inclusive\\n\\tsegTree.Build(1, 0, len(Array)-1)\\n\\n\\treturn &segTree\\n}\\n\"",
    "segment tree test": "\"package segmenttree\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\n//Query interval\\ntype query struct {\\n\\tfirstIndex int\\n\\tlastIndex  int\\n}\\n\\ntype update struct {\\n\\tfirstIndex int\\n\\tlastIndex  int\\n\\tvalue      int\\n}\\n\\nfunc TestSegmentTree(t *testing.T) {\\n\\tvar segmentTreeTestData = []struct {\\n\\t\\tdescription string\\n\\t\\tarray       []int\\n\\t\\tupdates     []update\\n\\t\\tqueries     []query\\n\\t\\texpected    []int\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tdescription: \\\"test empty array\\\",\\n\\t\\t\\tarray:       []int{},\\n\\t\\t\\tqueries:     []query{{0, 0}},\\n\\t\\t\\texpected:    []int{0},\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription: \\\"test array with size 5\\\",\\n\\t\\t\\tarray:       []int{1, 2, 3, 4, 5},\\n\\t\\t\\tqueries:     []query{{0, 5}, {0, 2}, {2, 4}},\\n\\t\\t\\texpected:    []int{15, 6, 12},\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription: \\\"test array with size 5 and updates\\\",\\n\\t\\t\\tarray:       []int{1, 2, 3, 4, 5},\\n\\t\\t\\tupdates: []update{{firstIndex: 1, lastIndex: 1, value: 2},\\n\\t\\t\\t\\t{firstIndex: 2, lastIndex: 2, value: 3}},\\n\\t\\t\\tqueries:  []query{{0, 5}, {0, 2}, {2, 4}},\\n\\t\\t\\texpected: []int{20, 11, 15},\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription: \\\"test array with size 5 and single index updates\\\",\\n\\t\\t\\tarray:       []int{1, 2, 3, 4, 5},\\n\\t\\t\\tupdates: []update{{firstIndex: 1, lastIndex: 1, value: 2},\\n\\t\\t\\t\\t{firstIndex: 2, lastIndex: 2, value: 3}},\\n\\t\\t\\tqueries:  []query{{0, 5}, {0, 2}, {2, 4}},\\n\\t\\t\\texpected: []int{20, 11, 15},\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tdescription: \\\"test array with size 5 and range updates\\\",\\n\\t\\t\\tarray:       []int{1, 2, 3, 4, 5},\\n\\t\\t\\tupdates: []update{{firstIndex: 0, lastIndex: 4, value: 2},\\n\\t\\t\\t\\t{firstIndex: 2, lastIndex: 4, value: 2}},\\n\\t\\t\\tqueries:  []query{{0, 5}, {0, 2}, {2, 4}},\\n\\t\\t\\texpected: []int{31, 14, 24},\\n\\t\\t},\\n\\t}\\n\\tfor _, test := range segmentTreeTestData {\\n\\t\\tt.Run(test.description, func(t *testing.T) {\\n\\t\\t\\tsegmentTree := NewSegmentTree(test.array)\\n\\n\\t\\t\\tfor i := 0; i < len(test.updates); i++ {\\n\\t\\t\\t\\tsegmentTree.Update(1, 0, len(test.array)-1, test.updates[i].firstIndex, test.updates[i].lastIndex, test.updates[i].value)\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor i := 0; i < len(test.queries); i++ {\\n\\t\\t\\t\\tresult := segmentTree.Query(1, 0, len(test.array)-1, test.queries[i].firstIndex, test.queries[i].lastIndex)\\n\\n\\t\\t\\t\\tif result != test.expected[i] {\\n\\t\\t\\t\\t\\tt.Logf(\\\"FAIL: %s\\\", test.description)\\n\\t\\t\\t\\t\\tt.Fatalf(\\\"Expected result: %d\\\\nFound: %d\\\\n\\\", test.expected[i], result)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "set": "\"// package set implements a Set using a golang map.\\n// This implies that only the types that are accepted as valid map keys can be used as set elements.\\n// For instance, do not try to Add a slice, or the program will panic.\\npackage set\\n\\n// New gives new set.\\nfunc New(items ...interface{}) Set {\\n\\tst := set{\\n\\t\\telements: make(map[interface{}]bool),\\n\\t}\\n\\tfor _, item := range items {\\n\\t\\tst.Add(item)\\n\\t}\\n\\treturn &st\\n}\\n\\n// Set is an interface of possible methods on 'set'.\\ntype Set interface {\\n\\t// Add: adds new element to the set\\n\\tAdd(item interface{})\\n\\t// Delete: deletes the passed element from the set if present\\n\\tDelete(item interface{})\\n\\t// Len: gives the length of the set (total no. of elements in set)\\n\\tLen() int\\n\\t// GetItems: gives the array( []interface{} ) of elements of the set.\\n\\tGetItems() []interface{}\\n\\t// In: checks whether item is present in set or not.\\n\\tIn(item interface{}) bool\\n\\t// IsSubsetOf: checks whether set is subset of set2 or not.\\n\\tIsSubsetOf(set2 Set) bool\\n\\t// IsSupersetOf: checks whether set is superset of set2 or not.\\n\\tIsSupersetOf(set2 Set) bool\\n\\t// Union: gives new union set of both sets.\\n\\t// ex: [1,2,3] union [3,4,5] -> [1,2,3,4,5]\\n\\tUnion(set2 Set) Set\\n\\t// Intersection: gives new intersection set of both sets.\\n\\t// ex: [1,2,3] Intersection [3,4,5] -> [3]\\n\\tIntersection(set2 Set) Set\\n\\t// Difference: gives new difference set of both sets.\\n\\t// ex: [1,2,3] Difference [3,4,5] -> [1,2]\\n\\tDifference(set2 Set) Set\\n\\t// SymmetricDifference: gives new symmetric difference set of both sets.\\n\\t// ex: [1,2,3] SymmetricDifference [3,4,5] -> [1,2,4,5]\\n\\tSymmetricDifference(set2 Set) Set\\n}\\n\\ntype set struct {\\n\\telements map[interface{}]bool\\n}\\n\\nfunc (st *set) Add(value interface{}) {\\n\\tst.elements[value] = true\\n}\\n\\nfunc (st *set) Delete(value interface{}) {\\n\\tdelete(st.elements, value)\\n}\\n\\nfunc (st *set) GetItems() []interface{} {\\n\\tkeys := make([]interface{}, 0, len(st.elements))\\n\\tfor k := range st.elements {\\n\\t\\tkeys = append(keys, k)\\n\\t}\\n\\treturn keys\\n}\\n\\nfunc (st *set) Len() int {\\n\\treturn len(st.elements)\\n}\\n\\nfunc (st *set) In(value interface{}) bool {\\n\\tif _, in := st.elements[value]; in {\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc (st *set) IsSubsetOf(superSet Set) bool {\\n\\tif st.Len() > superSet.Len() {\\n\\t\\treturn false\\n\\t}\\n\\n\\tfor _, item := range st.GetItems() {\\n\\t\\tif !superSet.In(item) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc (st *set) IsSupersetOf(subSet Set) bool {\\n\\treturn subSet.IsSubsetOf(st)\\n}\\n\\nfunc (st *set) Union(st2 Set) Set {\\n\\tunionSet := New()\\n\\tfor _, item := range st.GetItems() {\\n\\t\\tunionSet.Add(item)\\n\\t}\\n\\tfor _, item := range st2.GetItems() {\\n\\t\\tunionSet.Add(item)\\n\\t}\\n\\treturn unionSet\\n}\\n\\nfunc (st *set) Intersection(st2 Set) Set {\\n\\tintersectionSet := New()\\n\\tvar minSet, maxSet Set\\n\\tif st.Len() > st2.Len() {\\n\\t\\tminSet = st2\\n\\t\\tmaxSet = st\\n\\t} else {\\n\\t\\tminSet = st\\n\\t\\tmaxSet = st2\\n\\t}\\n\\tfor _, item := range minSet.GetItems() {\\n\\t\\tif maxSet.In(item) {\\n\\t\\t\\tintersectionSet.Add(item)\\n\\t\\t}\\n\\t}\\n\\treturn intersectionSet\\n}\\n\\nfunc (st *set) Difference(st2 Set) Set {\\n\\tdifferenceSet := New()\\n\\tfor _, item := range st.GetItems() {\\n\\t\\tif !st2.In(item) {\\n\\t\\t\\tdifferenceSet.Add(item)\\n\\t\\t}\\n\\t}\\n\\treturn differenceSet\\n}\\n\\nfunc (st *set) SymmetricDifference(st2 Set) Set {\\n\\tsymmetricDifferenceSet := New()\\n\\tdropSet := New()\\n\\tfor _, item := range st.GetItems() {\\n\\t\\tif st2.In(item) {\\n\\t\\t\\tdropSet.Add(item)\\n\\t\\t} else {\\n\\t\\t\\tsymmetricDifferenceSet.Add(item)\\n\\t\\t}\\n\\t}\\n\\tfor _, item := range st2.GetItems() {\\n\\t\\tif !dropSet.In(item) {\\n\\t\\t\\tsymmetricDifferenceSet.Add(item)\\n\\t\\t}\\n\\t}\\n\\treturn symmetricDifferenceSet\\n}\\n\"",
    "set example test": "\"package set\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc ExampleSet() {\\n\\n\\tset := New(1, 2, 3)\\n\\tfmt.Println(set.Len()) // 3\\n\\tset.Add(3)\\n\\tfmt.Println(set.Len()) // 3\\n\\tset.Add(4)\\n\\tfmt.Println(set.Len()) // 4\\n\\n\\t// output:\\n\\t// 3\\n\\t// 3\\n\\t// 4\\n}\\n\"",
    "set test": "\"package set\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestNew(t *testing.T) {\\n\\tset := New(1, 2, 3)\\n\\tif set.Len() != 3 {\\n\\t\\tt.Errorf(\\\"expecting 3 elements in the set but got %v: %v\\\", set.Len(), set.GetItems())\\n\\t}\\n\\tfor _, n := range []int{1, 2, 3} {\\n\\t\\tif !set.In(n) {\\n\\t\\t\\tt.Errorf(\\\"expecting %d to be present in the set but was not; set is %v\\\", n, set.GetItems())\\n\\t\\t}\\n\\t}\\n\\tif set.In(5) {\\n\\t\\tt.Errorf(\\\"expecting 5 not to be present in the set but it was; set is %v\\\", set.GetItems())\\n\\t}\\n}\\n\\nfunc TestAdd(t *testing.T) {\\n\\ttd := []struct {\\n\\t\\tname     string\\n\\t\\tinput    int\\n\\t\\texpElems []int\\n\\t}{\\n\\t\\t{\\\"add new element\\\", 5, []int{1, 2, 3, 5}},\\n\\t\\t{\\\"add exiting element\\\", 3, []int{1, 2, 3}},\\n\\t}\\n\\tfor _, tc := range td {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\ts := New(1, 2, 3)\\n\\t\\t\\ts.Add(tc.input)\\n\\t\\t\\tif s.Len() != len(tc.expElems) {\\n\\t\\t\\t\\tt.Errorf(\\\"expecting %d elements in the set but got %d: set is %v\\\", len(tc.expElems), s.Len(), s.GetItems())\\n\\t\\t\\t}\\n\\t\\t\\tfor _, n := range tc.expElems {\\n\\t\\t\\t\\tif !s.In(n) {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"expecting %d to be present in the set but was not; set is %v\\\", n, s.GetItems())\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestDelete(t *testing.T) {\\n\\ttd := []struct {\\n\\t\\tname     string\\n\\t\\tinput    int\\n\\t\\texpElems []int\\n\\t}{\\n\\t\\t{\\\"delete exiting element\\\", 3, []int{1, 2}},\\n\\t\\t{\\\"delete not existing element\\\", 5, []int{1, 2, 3}},\\n\\t}\\n\\tfor _, tc := range td {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\ts := New(1, 2, 3)\\n\\t\\t\\ts.Delete(tc.input)\\n\\t\\t\\tif s.Len() != len(tc.expElems) {\\n\\t\\t\\t\\tt.Errorf(\\\"expecting %d elements in the set but got %d: set is %v\\\", len(tc.expElems), s.Len(), s.GetItems())\\n\\t\\t\\t}\\n\\t\\t\\tfor _, n := range tc.expElems {\\n\\t\\t\\t\\tif !s.In(n) {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"expecting %d to be present in the set but was not; set is %v\\\", n, s.GetItems())\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestIsSubsetOf(t *testing.T) {\\n\\ts1, s2 := New(1, 2, 3), New(1, 2, 3, 4)\\n\\tif !s1.IsSubsetOf(s2) {\\n\\t\\tt.Errorf(\\\"expecting %v to be a subset of %v\\\", s1, s2)\\n\\t}\\n\\tif s2.IsSubsetOf(s1) {\\n\\t\\tt.Errorf(\\\"expecting %v not to be a subset of %v\\\", s2, s1)\\n\\t}\\n\\tif s3 := New(1, 2, 5, 6); s1.IsSubsetOf(s3) {\\n\\t\\tt.Errorf(\\\"expecting %v not to be a subset of %v\\\", s1, s3)\\n\\t}\\n}\\n\\nfunc TestIsSupersetOf(t *testing.T) {\\n\\ts1, s2 := New(1, 2, 3), New(1, 2, 3, 4)\\n\\tif !s2.IsSupersetOf(s1) {\\n\\t\\tt.Errorf(\\\"expecting %v to be a superset of %v\\\", s2, s1)\\n\\t}\\n\\tif s1.IsSupersetOf(s2) {\\n\\t\\tt.Errorf(\\\"expecting %v not to be a superset of %v\\\", s1, s2)\\n\\t}\\n\\tif s3 := New(1, 2, 5); s2.IsSupersetOf(s3) {\\n\\t\\tt.Errorf(\\\"expecting %v not to be a superset of %v\\\", s2, s3)\\n\\t}\\n}\\n\\nfunc TestUnion(t *testing.T) {\\n\\ttd := []struct {\\n\\t\\tname   string\\n\\t\\ts1     Set\\n\\t\\ts2     Set\\n\\t\\texpSet Set\\n\\t}{\\n\\t\\t{\\\"union of different sets\\\", New(1, 2, 3), New(4, 5, 6), New(1, 2, 3, 4, 5, 6)},\\n\\t\\t{\\\"union of sets with elements in common\\\", New(1, 2, 3), New(1, 2, 4), New(1, 2, 3, 4)},\\n\\t\\t{\\\"union of same sets\\\", New(1, 2, 3), New(1, 2, 3), New(1, 2, 3)},\\n\\t}\\n\\tfor _, tc := range td {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\ts := tc.s1.Union(tc.s2)\\n\\t\\t\\tif s.Len() != tc.expSet.Len() {\\n\\t\\t\\t\\tt.Errorf(\\\"expecting %d elements in the set but got %d: set is %v\\\", tc.expSet.Len(), s.Len(), s.GetItems())\\n\\t\\t\\t}\\n\\t\\t\\tfor _, n := range tc.expSet.GetItems() {\\n\\t\\t\\t\\tif !s.In(n) {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"expecting %d to be present in the set but was not; set is %v\\\", n, s.GetItems())\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestIntersection(t *testing.T) {\\n\\ttd := []struct {\\n\\t\\tname   string\\n\\t\\ts1     Set\\n\\t\\ts2     Set\\n\\t\\texpSet Set\\n\\t}{\\n\\t\\t{\\\"intersection of different sets\\\", New(0, 1, 2, 3), New(4, 5, 6), New()},\\n\\t\\t{\\\"intersection of sets with elements in common\\\", New(1, 2, 3), New(1, 2, 4), New(1, 2)},\\n\\t\\t{\\\"intersection of same sets\\\", New(1, 2, 3), New(1, 2, 3), New(1, 2, 3)},\\n\\t}\\n\\tfor _, tc := range td {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\ts := tc.s1.Intersection(tc.s2)\\n\\t\\t\\tif s.Len() != tc.expSet.Len() {\\n\\t\\t\\t\\tt.Errorf(\\\"expecting %d elements in the set but got %d: set is %v\\\", tc.expSet.Len(), s.Len(), s.GetItems())\\n\\t\\t\\t}\\n\\t\\t\\tfor _, n := range tc.expSet.GetItems() {\\n\\t\\t\\t\\tif !s.In(n) {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"expecting %d to be present in the set but was not; set is %v\\\", n, s.GetItems())\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestDifference(t *testing.T) {\\n\\ttd := []struct {\\n\\t\\tname   string\\n\\t\\ts1     Set\\n\\t\\ts2     Set\\n\\t\\texpSet Set\\n\\t}{\\n\\t\\t{\\\"difference of different sets\\\", New(1, 2, 3), New(4, 5, 6), New(1, 2, 3)},\\n\\t\\t{\\\"difference of sets with elements in common\\\", New(1, 2, 3), New(1, 2, 4), New(3)},\\n\\t\\t{\\\"difference of same sets\\\", New(1, 2, 3), New(1, 2, 3), New()},\\n\\t}\\n\\tfor _, tc := range td {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\ts := tc.s1.Difference(tc.s2)\\n\\t\\t\\tif s.Len() != tc.expSet.Len() {\\n\\t\\t\\t\\tt.Errorf(\\\"expecting %d elements in the set but got %d: set is %v\\\", tc.expSet.Len(), s.Len(), s.GetItems())\\n\\t\\t\\t}\\n\\t\\t\\tfor _, n := range tc.expSet.GetItems() {\\n\\t\\t\\t\\tif !s.In(n) {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"expecting %d to be present in the set but was not; set is %v\\\", n, s.GetItems())\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\\nfunc TestSymmetricDifference(t *testing.T) {\\n\\ttd := []struct {\\n\\t\\tname   string\\n\\t\\ts1     Set\\n\\t\\ts2     Set\\n\\t\\texpSet Set\\n\\t}{\\n\\t\\t{\\\"symmetric difference of different sets\\\", New(1, 2, 3), New(4, 5, 6), New(1, 2, 3, 4, 5, 6)},\\n\\t\\t{\\\"symmetric difference of sets with elements in common\\\", New(1, 2, 3), New(1, 2, 4), New(3, 4)},\\n\\t\\t{\\\"symmetric difference of same sets\\\", New(1, 2, 3), New(1, 2, 3), New()},\\n\\t}\\n\\tfor _, tc := range td {\\n\\t\\tt.Run(tc.name, func(t *testing.T) {\\n\\t\\t\\ts := tc.s1.SymmetricDifference(tc.s2)\\n\\t\\t\\tif s.Len() != tc.expSet.Len() {\\n\\t\\t\\t\\tt.Errorf(\\\"expecting %d elements in the set but got %d: set is %v\\\", tc.expSet.Len(), s.Len(), s.GetItems())\\n\\t\\t\\t}\\n\\t\\t\\tfor _, n := range tc.expSet.GetItems() {\\n\\t\\t\\t\\tif !s.In(n) {\\n\\t\\t\\t\\t\\tt.Errorf(\\\"expecting %d to be present in the set but was not; set is %v\\\", n, s.GetItems())\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n\"",
    "stack array": "\"// Stack Array\\n// description: based on `geeksforgeeks` description Stack is a linear data structure which follows a particular order in which the operations are performed.\\n//\\tThe order may be LIFO(Last In First Out) or FILO(First In Last Out).\\n// details:\\n// \\tStack Data Structure : https://www.geeksforgeeks.org/stack-data-structure-introduction-program/\\n// \\tStack (abstract data type) : https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\\n// author [Milad](https://github.com/miraddo)\\n// see stacklinkedlist.go, stacklinkedlistwithlist.go, stack_test.go\\n\\npackage stack\\n\\nvar stackArray []interface{}\\n\\n// stackPush push to first index of array\\nfunc stackPush(n interface{}) {\\n\\tstackArray = append([]interface{}{n}, stackArray...)\\n}\\n\\n// stackLength return length of array\\nfunc stackLength() int {\\n\\treturn len(stackArray)\\n}\\n\\n// stackPeak return last input of array\\nfunc stackPeak() interface{} {\\n\\treturn stackArray[0]\\n}\\n\\n// stackEmpty check array is empty or not\\nfunc stackEmpty() bool {\\n\\treturn len(stackArray) == 0\\n}\\n\\n// stackPop return last input and remove it in array\\nfunc stackPop() interface{} {\\n\\tpop := stackArray[0]\\n\\tstackArray = stackArray[1:]\\n\\treturn pop\\n}\\n\"",
    "stack linked list": "\"// Stack Linked-List\\n// description: based on `geeksforgeeks` description Stack is a linear data structure which follows a particular order in which the operations are performed.\\n//\\tThe order may be LIFO(Last In First Out) or FILO(First In Last Out).\\n// details:\\n// \\tStack Data Structure : https://www.geeksforgeeks.org/stack-data-structure-introduction-program/\\n// \\tStack (abstract data type) : https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\\n// author [Milad](https://github.com/miraddo)\\n// see stacklinkedlistwithlist.go, stackarray.go, stack_test.go\\n\\npackage stack\\n\\n// Node structure\\ntype Node struct {\\n\\tVal  interface{}\\n\\tNext *Node\\n}\\n\\n// Stack has jost top of node and with length\\ntype Stack struct {\\n\\ttop    *Node\\n\\tlength int\\n}\\n\\n// push add value to last index\\nfunc (ll *Stack) push(n interface{}) {\\n\\tnewStack := &Node{} // new node\\n\\n\\tnewStack.Val = n\\n\\tnewStack.Next = ll.top\\n\\n\\tll.top = newStack\\n\\tll.length++\\n}\\n\\n// pop remove last item as first output\\nfunc (ll *Stack) pop() interface{} {\\n\\tresult := ll.top.Val\\n\\tif ll.top.Next == nil {\\n\\t\\tll.top = nil\\n\\t} else {\\n\\t\\tll.top.Val, ll.top.Next = ll.top.Next.Val, ll.top.Next.Next\\n\\t}\\n\\n\\tll.length--\\n\\treturn result\\n}\\n\\n// isEmpty to check our array is empty or not\\nfunc (ll *Stack) isEmpty() bool {\\n\\treturn ll.length == 0\\n}\\n\\n// len use to return length of our stack\\nfunc (ll *Stack) len() int {\\n\\treturn ll.length\\n}\\n\\n// peak return last input value\\nfunc (ll *Stack) peak() interface{} {\\n\\treturn ll.top.Val\\n}\\n\\n// show all value as an interface array\\nfunc (ll *Stack) show() (in []interface{}) {\\n\\tcurrent := ll.top\\n\\n\\tfor current != nil {\\n\\t\\tin = append(in, current.Val)\\n\\t\\tcurrent = current.Next\\n\\t}\\n\\treturn\\n}\\n\"",
    "stack linked list with list": "\"// Stack Linked-List with standard library (Container/List)\\n// description: based on `geeksforgeeks` description Stack is a linear data structure which follows a particular order in which the operations are performed.\\n//\\tThe order may be LIFO(Last In First Out) or FILO(First In Last Out).\\n// details:\\n// \\tStack Data Structure : https://www.geeksforgeeks.org/stack-data-structure-introduction-program/\\n// \\tStack (abstract data type) : https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\\n// author [Milad](https://github.com/miraddo)\\n// see stacklinkedlist.go, stackarray.go, stack_test.go\\n\\npackage stack\\n\\nimport (\\n\\t\\\"container/list\\\"\\n\\t\\\"fmt\\\"\\n)\\n\\n// SList is our struct that point to stack with container/list.List library\\ntype SList struct {\\n\\tstack *list.List\\n}\\n\\n// Push add a value into our stack\\nfunc (sl *SList) Push(val interface{}) {\\n\\tsl.stack.PushFront(val)\\n}\\n\\n// Peak is return last value that insert into our stack\\nfunc (sl *SList) Peak() (interface{}, error) {\\n\\tif !sl.Empty() {\\n\\t\\telement := sl.stack.Front()\\n\\t\\treturn element.Value, nil\\n\\t}\\n\\treturn \\\"\\\", fmt.Errorf(\\\"stack list is empty\\\")\\n}\\n\\n// Pop is return last value that insert into our stack\\n//also it will remove it in our stack\\nfunc (sl *SList) Pop() (interface{}, error) {\\n\\tif !sl.Empty() {\\n\\t\\t// get last element that insert into stack\\n\\t\\telement := sl.stack.Front()\\n\\t\\t// remove element in stack\\n\\t\\tsl.stack.Remove(element)\\n\\t\\t// return element value\\n\\t\\treturn element.Value, nil\\n\\t}\\n\\treturn \\\"\\\", fmt.Errorf(\\\"stack list is empty\\\")\\n}\\n\\n// Length return length of our stack\\nfunc (sl *SList) Length() int {\\n\\treturn sl.stack.Len()\\n}\\n\\n// Empty check our stack has value or not\\nfunc (sl *SList) Empty() bool {\\n\\t// check our stack is empty or not\\n\\t// if is 0 it means our stack is empty otherwise is not empty\\n\\treturn sl.stack.Len() == 0\\n}\\n\"",
    "stack test": "\"// Stack Test\\n// description: based on `geeksforgeeks` description Stack is a linear data structure which follows a particular order in which the operations are performed.\\n//\\tThe order may be LIFO(Last In First Out) or FILO(First In Last Out).\\n// details:\\n// \\tStack Data Structure : https://www.geeksforgeeks.org/stack-data-structure-introduction-program/\\n// \\tStack (abstract data type) : https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\\n// author [Milad](https://github.com/miraddo)\\n// see stackarray.go, stacklinkedlist.go, stacklinkedlistwithlist.go\\n\\npackage stack\\n\\nimport (\\n\\t\\\"container/list\\\"\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\\n\\n// TestStackLinkedList for testing Stack with LinkedList\\nfunc TestStackLinkedList(t *testing.T) {\\n\\tvar newStack Stack\\n\\n\\tnewStack.push(1)\\n\\tnewStack.push(2)\\n\\n\\tt.Run(\\\"Stack Push\\\", func(t *testing.T) {\\n\\t\\tresult := newStack.show()\\n\\t\\texpected := []interface{}{2, 1}\\n\\t\\tfor x := range result {\\n\\t\\t\\tif result[x] != expected[x] {\\n\\t\\t\\t\\tt.Errorf(\\\"Stack Push is not work, got %v but expected %v\\\", result, expected)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Stack isEmpty\\\", func(t *testing.T) {\\n\\t\\tif newStack.isEmpty() {\\n\\t\\t\\tt.Error(\\\"Stack isEmpty is returned true but expected false\\\", newStack.isEmpty())\\n\\t\\t}\\n\\n\\t})\\n\\n\\tt.Run(\\\"Stack Length\\\", func(t *testing.T) {\\n\\t\\tif newStack.len() != 2 {\\n\\t\\t\\tt.Error(\\\"Stack Length should be 2 but got\\\", newStack.len())\\n\\t\\t}\\n\\t})\\n\\n\\tnewStack.pop()\\n\\tpop := newStack.pop()\\n\\n\\tt.Run(\\\"Stack Pop\\\", func(t *testing.T) {\\n\\t\\tif pop != 1 {\\n\\t\\t\\tt.Error(\\\"Stack Pop should return 1 but is returned\\\", pop)\\n\\t\\t}\\n\\n\\t})\\n\\n\\tnewStack.push(52)\\n\\tnewStack.push(23)\\n\\tnewStack.push(99)\\n\\tt.Run(\\\"Stack Peak\\\", func(t *testing.T) {\\n\\t\\tif newStack.peak() != 99 {\\n\\t\\t\\tt.Error(\\\"Stack Peak should return 99 but got \\\", newStack.peak())\\n\\t\\t}\\n\\t})\\n}\\n\\n// TestStackArray for testing Stack with Array\\nfunc TestStackArray(t *testing.T) {\\n\\tt.Run(\\\"Stack With Array\\\", func(t *testing.T) {\\n\\n\\t\\tstackPush(2)\\n\\t\\tstackPush(3)\\n\\n\\t\\tt.Run(\\\"Stack Push\\\", func(t *testing.T) {\\n\\t\\t\\tif !reflect.DeepEqual([]interface{}{3, 2}, stackArray) {\\n\\t\\t\\t\\tt.Errorf(\\\"Stack Push is not work we expected %v but got %v\\\", []interface{}{3, 2}, stackArray)\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tpop := stackPop()\\n\\n\\t\\tt.Run(\\\"Stack Pop\\\", func(t *testing.T) {\\n\\n\\t\\t\\tif stackLength() == 2 && pop != 3 {\\n\\t\\t\\t\\tt.Errorf(\\\"Stack Pop is not work we expected %v but got %v\\\", 3, pop)\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tstackPush(2)\\n\\t\\tstackPush(83)\\n\\n\\t\\tt.Run(\\\"Stack Peak\\\", func(t *testing.T) {\\n\\n\\t\\t\\tif stackPeak() != 83 {\\n\\t\\t\\t\\tt.Errorf(\\\"Stack Peak is not work we expected %v but got %v\\\", 83, stackPeak())\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"Stack Length\\\", func(t *testing.T) {\\n\\t\\t\\tif stackLength() != 3 {\\n\\t\\t\\t\\tt.Errorf(\\\"Stack Length is not work we expected %v but got %v\\\", 3, stackLength())\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tt.Run(\\\"Stack Empty\\\", func(t *testing.T) {\\n\\t\\t\\tif stackEmpty() == true {\\n\\t\\t\\t\\tt.Errorf(\\\"Stack Empty is not work we expected %v but got %v\\\", false, stackEmpty())\\n\\t\\t\\t}\\n\\n\\t\\t\\tstackPop()\\n\\t\\t\\tstackPop()\\n\\t\\t\\tstackPop()\\n\\n\\t\\t\\tif stackEmpty() == false {\\n\\t\\t\\t\\tt.Errorf(\\\"Stack Empty is not work we expected %v but got %v\\\", true, stackEmpty())\\n\\t\\t\\t}\\n\\t\\t})\\n\\t})\\n}\\n\\n// TestStackLinkedListWithList for testing Stack with Container/List Library (STL)\\nfunc TestStackLinkedListWithList(t *testing.T) {\\n\\tstackList := &SList{\\n\\t\\tstack: list.New(),\\n\\t}\\n\\n\\tt.Run(\\\"Stack Push\\\", func(t *testing.T) {\\n\\n\\t\\tstackList.Push(2)\\n\\t\\tstackList.Push(3)\\n\\n\\t\\tif stackList.Length() != 2 {\\n\\t\\t\\tt.Errorf(\\\"Stack Push is not work we expected %v but got %v\\\", 2, stackList.Length())\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Stack Pop\\\", func(t *testing.T) {\\n\\t\\tpop, _ := stackList.Pop()\\n\\n\\t\\tif stackList.Length() == 1 && pop != 3 {\\n\\t\\t\\tt.Errorf(\\\"Stack Pop is not work we expected %v but got %v\\\", 3, pop)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Stack Peak\\\", func(t *testing.T) {\\n\\n\\t\\tstackList.Push(2)\\n\\t\\tstackList.Push(83)\\n\\t\\tpeak, _ := stackList.Peak()\\n\\t\\tif peak != 83 {\\n\\t\\t\\tt.Errorf(\\\"Stack Peak is not work we expected %v but got %v\\\", 83, peak)\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Stack Length\\\", func(t *testing.T) {\\n\\t\\tif stackList.Length() != 3 {\\n\\t\\t\\tt.Errorf(\\\"Stack Length is not work we expected %v but got %v\\\", 3, stackList.Length())\\n\\t\\t}\\n\\t})\\n\\n\\tt.Run(\\\"Stack Empty\\\", func(t *testing.T) {\\n\\t\\tif stackList.Empty() == true {\\n\\t\\t\\tt.Errorf(\\\"Stack Empty is not work we expected %v but got %v\\\", false, stackList.Empty())\\n\\t\\t}\\n\\n\\t\\td1, err := stackList.Pop()\\n\\t\\td2, _ := stackList.Pop()\\n\\t\\td3, _ := stackList.Pop()\\n\\n\\t\\tif err != nil {\\n\\t\\t\\tt.Errorf(\\\"got an unexpected error %v, pop1: %v, pop2: %v, pop3: %v\\\", err, d1, d2, d3)\\n\\t\\t}\\n\\n\\t\\tif stackList.Empty() == false {\\n\\t\\t\\tt.Errorf(\\\"Stack Empty is not work we expected %v but got %v\\\", true, stackList.Empty())\\n\\t\\t}\\n\\t})\\n}\\n\"",
    "trie": "\"// Package trie provides Trie data structures in golang.\\n//\\n// Wikipedia: https://en.wikipedia.org/wiki/Trie\\npackage trie\\n\\n// Node represents each node in Trie.\\ntype Node struct {\\n\\tchildren map[rune]*Node // map children nodes\\n\\tisLeaf   bool           // current node value\\n}\\n\\n// NewNode creates a new Trie node with initialized\\n// children map.\\nfunc NewNode() *Node {\\n\\tn := &Node{}\\n\\tn.children = make(map[rune]*Node)\\n\\tn.isLeaf = false\\n\\treturn n\\n}\\n\\n// insert a single word at a Trie node.\\nfunc (n *Node) insert(s string) {\\n\\tcurr := n\\n\\tfor _, c := range s {\\n\\t\\tnext, ok := curr.children[c]\\n\\t\\tif !ok {\\n\\t\\t\\tnext = NewNode()\\n\\t\\t\\tcurr.children[c] = next\\n\\t\\t}\\n\\t\\tcurr = next\\n\\t}\\n\\tcurr.isLeaf = true\\n}\\n\\n// Insert zero, one or more words at a Trie node.\\nfunc (n *Node) Insert(s ...string) {\\n\\tfor _, ss := range s {\\n\\t\\tn.insert(ss)\\n\\t}\\n}\\n\\n// Find  words at a Trie node.\\nfunc (n *Node) Find(s string) bool {\\n\\tnext, ok := n, false\\n\\tfor _, c := range s {\\n\\t\\tnext, ok = next.children[c]\\n\\t\\tif !ok {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn next.isLeaf\\n}\\n\\n// Capacity returns the number of nodes in the Trie\\nfunc (n *Node) Capacity() int {\\n\\tr := 0\\n\\tfor _, c := range n.children {\\n\\t\\tr += c.Capacity()\\n\\t}\\n\\treturn 1 + r\\n}\\n\\n// Size returns the number of words in the Trie\\nfunc (n *Node) Size() int {\\n\\tr := 0\\n\\tfor _, c := range n.children {\\n\\t\\tr += c.Size()\\n\\t}\\n\\tif n.isLeaf {\\n\\t\\tr++\\n\\t}\\n\\treturn r\\n}\\n\\n// remove lazily a word from the Trie node, no node is actually removed.\\nfunc (n *Node) remove(s string) {\\n\\tif len(s) == 0 {\\n\\t\\treturn\\n\\t}\\n\\tnext, ok := n, false\\n\\tfor _, c := range s {\\n\\t\\tnext, ok = next.children[c]\\n\\t\\tif !ok {\\n\\t\\t\\t// word cannot be found - we're done !\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t}\\n\\tnext.isLeaf = false\\n}\\n\\n// Remove zero, one or more words lazily from the Trie, no node is actually removed.\\nfunc (n *Node) Remove(s ...string) {\\n\\tfor _, ss := range s {\\n\\t\\tn.remove(ss)\\n\\t}\\n}\\n\\n// Compact will remove unecessay nodes, reducing the capacity, returning true if node n itself should be removed.\\nfunc (n *Node) Compact() (remove bool) {\\n\\n\\tfor r, c := range n.children {\\n\\t\\tif c.Compact() {\\n\\t\\t\\tdelete(n.children, r)\\n\\t\\t}\\n\\t}\\n\\treturn !n.isLeaf && len(n.children) == 0\\n}\\n\"",
    "trie example test": "\"package trie\\n\\nimport \\\"fmt\\\"\\n\\nfunc ExampleNode() {\\n\\t// creates a new node\\n\\tnode := NewNode()\\n\\n\\t// adds words\\n\\tnode.Insert(\\\"nikola\\\")\\n\\tnode.Insert(\\\"tesla\\\")\\n\\n\\t// check size and capacity\\n\\tfmt.Println(node.Size())     // 2 words\\n\\tfmt.Println(node.Capacity()) // 12 nodes\\n\\n\\t// finds words\\n\\tfmt.Println(node.Find(\\\"thomas\\\")) // false\\n\\tfmt.Println(node.Find(\\\"edison\\\")) // false\\n\\tfmt.Println(node.Find(\\\"nikola\\\")) // true\\n\\n\\t// remove a word, and check it is gone\\n\\tnode.Remove(\\\"tesla\\\")\\n\\tfmt.Println(node.Find(\\\"tesla\\\")) // false\\n\\n\\t// size and capacity have changed\\n\\tfmt.Println(node.Size())     // 1 word left\\n\\tfmt.Println(node.Capacity()) // 12 nodes remaining\\n\\n\\t// output:\\n\\t// 2\\n\\t// 12\\n\\t// false\\n\\t// false\\n\\t// true\\n\\t// false\\n\\t// 1\\n\\t// 12\\n}\\n\"",
    "trie bench test": "\"package trie\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math/rand\\\"\\n\\t\\\"testing\\\"\\n)\\n\\n// CAUTION : make sure to limit the benchamrks to 3000 iterations,\\n// or removal will mostly process an empty Trie, giving absurd results.\\n\\n// go test -v -bench=. -benchmem -benchtime=3000x\\n\\n// === RUN   TestTrieInsert\\n// --- PASS: TestTrieInsert (0.00s)\\n// === RUN   TestTrieRemove\\n// --- PASS: TestTrieRemove (0.00s)\\n// === RUN   ExampleNode\\n// --- PASS: ExampleNode (0.00s)\\n// goos: linux\\n// goarch: amd64\\n// pkg: github.com/TheAlgorithms/Go/structure/trie\\n// BenchmarkTrie_Insert\\n// BenchmarkTrie_Insert-8                      3000           1559881 ns/op         1370334 B/op      25794 allocs/op\\n// BenchmarkTrie_Find_non_existant\\n// BenchmarkTrie_Find_non_existant-8           3000                59.1 ns/op             0 B/op          0 allocs/op\\n// BenchmarkTrie_Find_existant\\n// BenchmarkTrie_Find_existant-8               3000               238 ns/op               0 B/op          0 allocs/op\\n// BenchmarkTrie_Remove_lazy\\n// BenchmarkTrie_Remove_lazy-8                 3000               126 ns/op               0 B/op          0 allocs/op\\n// BenchmarkTrie_Remove_and_Compact\\n// BenchmarkTrie_Remove_and_Compact-8          3000            213945 ns/op               0 B/op          0 allocs/op\\n// PASS\\n// ok      github.com/TheAlgorithms/Go/structure/trie      5.355s\\n\\nfunc BenchmarkTrie_Insert(b *testing.B) {\\n\\n\\t// prepare random words for insertion\\n\\tinsert := make([]string, 3000)\\n\\tfor i := 0; i < len(insert); i++ {\\n\\t\\tinsert[i] = fmt.Sprintf(\\\"%f\\\", rand.Float64())\\n\\t}\\n\\n\\t// Reset timer and run benchmark for insertion\\n\\tb.ResetTimer()\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tn := NewNode()\\n\\t\\tn.Insert(insert...)\\n\\t}\\n}\\n\\nfunc BenchmarkTrie_Find_non_existant(b *testing.B) {\\n\\n\\t// prepare random words for insertion\\n\\tinsert := make([]string, 3000)\\n\\tfor i := 0; i < len(insert); i++ {\\n\\t\\tinsert[i] = fmt.Sprintf(\\\"%f\\\", rand.Float64())\\n\\t}\\n\\tn := NewNode()\\n\\tn.Insert(insert...)\\n\\n\\t// Reset timer and run benchmark for finding non existing\\n\\tb.ResetTimer()\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tn.Find(\\\"0.3213213244346546546546565465465\\\") // does not exists\\n\\t}\\n}\\n\\nfunc BenchmarkTrie_Find_existant(b *testing.B) {\\n\\t// prepare and insert random words\\n\\tinsert := make([]string, 3000)\\n\\tfor i := 0; i < len(insert); i++ {\\n\\t\\tinsert[i] = fmt.Sprintf(\\\"%f\\\", rand.Float64())\\n\\t}\\n\\tn := NewNode()\\n\\tn.Insert(insert...)\\n\\n\\t// Reset timer and run benchmark for finding existing words\\n\\tb.ResetTimer()\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tn.Find(insert[i%3000]) // always exists !\\n\\t}\\n}\\n\\nfunc BenchmarkTrie_Remove_lazy(b *testing.B) {\\n\\t// prepare and insert random words\\n\\tinsert := make([]string, 3000)\\n\\tfor i := 0; i < len(insert); i++ {\\n\\t\\tinsert[i] = fmt.Sprintf(\\\"%f\\\", rand.Float64())\\n\\t}\\n\\tn := NewNode()\\n\\tn.Insert(insert...)\\n\\n\\t// Reset timer and run benchmark for lazily removing words\\n\\tb.ResetTimer()\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tn.Remove(insert[i%3000]) //  exists, at least until removed ...\\n\\t}\\n}\\n\\nfunc BenchmarkTrie_Remove_and_Compact(b *testing.B) {\\n\\t// prepare and insert random words\\n\\tinsert := make([]string, 3000)\\n\\tfor i := 0; i < len(insert); i++ {\\n\\t\\tinsert[i] = fmt.Sprintf(\\\"%f\\\", rand.Float64())\\n\\t}\\n\\tn := NewNode()\\n\\tn.Insert(insert...)\\n\\n\\t// Reset timer and run benchmark for removing words and immediately compacting\\n\\tb.ResetTimer()\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tn.Remove(insert[i%3000])\\n\\t\\tn.Compact()\\n\\t}\\n}\\n\"",
    "trie test": "\"package trie\\n\\nimport (\\n\\t\\\"testing\\\"\\n)\\n\\nfunc TestTrieInsert(t *testing.T) {\\n\\tn := NewNode()\\n\\n\\tinsertWords := []string{\\n\\t\\t\\\"nikola\\\",\\n\\t\\t\\\"tesla\\\",\\n\\t}\\n\\n\\tcheckWords := map[string]bool{\\n\\t\\t\\\"thomas\\\": false,\\n\\t\\t\\\"edison\\\": false,\\n\\t\\t\\\"nikola\\\": true,\\n\\t}\\n\\n\\tn.Insert(insertWords...)\\n\\tn.verify(t, checkWords)\\n\\tn.verifySizeCapa(t, 2, 12)\\n\\n}\\n\\nfunc TestTrieInsert_substrings(t *testing.T) {\\n\\tn := NewNode()\\n\\n\\tinsertWords := []string{\\n\\t\\t\\\"aa\\\",\\n\\t\\t\\\"aaaa\\\",\\n\\t\\t\\\"aaaaa\\\",\\n\\t}\\n\\n\\tcheckWords := map[string]bool{\\n\\t\\t\\\"a\\\":       false,\\n\\t\\t\\\"aa\\\":      true,\\n\\t\\t\\\"aaa\\\":     false,\\n\\t\\t\\\"aaaa\\\":    true,\\n\\t\\t\\\"aaaaa\\\":   true,\\n\\t\\t\\\"aaaaaa\\\":  false,\\n\\t\\t\\\"aaaaaaa\\\": false,\\n\\t}\\n\\n\\tn.Insert(insertWords...)\\n\\tn.verify(t, checkWords)\\n\\tn.verifySizeCapa(t, 3, 5+1)\\n\\n\\tn.Remove(\\\"aaaa\\\")\\n\\tcheckWords[\\\"aaaa\\\"] = false\\n\\tn.verify(t, checkWords)\\n\\tn.verifySizeCapa(t, 2, 5+1)\\n\\n\\tif n.Compact() {\\n\\t\\tt.Fatalf(\\\"it should not be possible to remove the node\\\")\\n\\t}\\n\\tn.verify(t, checkWords)\\n\\tn.verifySizeCapa(t, 2, 5+1)\\n}\\n\\nfunc TestTrieRemove(t *testing.T) {\\n\\tn := NewNode()\\n\\n\\tinsertWords := []string{\\n\\t\\t\\\"nikola\\\",\\n\\t\\t\\\"tesla\\\",\\n\\t\\t\\\"albert\\\",\\n\\t\\t\\\"einstein\\\",\\n\\t}\\n\\n\\tcheckWords := map[string]bool{\\n\\t\\t\\\"thomas\\\":   false,\\n\\t\\t\\\"edison\\\":   false,\\n\\t\\t\\\"nikola\\\":   true,\\n\\t\\t\\\"albert\\\":   true,\\n\\t\\t\\\"einstein\\\": true,\\n\\t}\\n\\n\\tn.Insert(insertWords...)\\n\\tn.verify(t, checkWords)\\n\\tsize, capa := n.Size(), n.Capacity() // 4 words ...\\n\\n\\tn.Remove(\\\"albert\\\")\\n\\tcheckWords[\\\"albert\\\"] = false\\n\\tsize-- // 3 words in size, but no change in capacity\\n\\tn.verify(t, checkWords)\\n\\tn.verifySizeCapa(t, size, capa)\\n\\n\\tn.Remove(\\\"albert\\\") // no effect since already removed\\n\\tn.verify(t, checkWords)\\n\\tn.verifySizeCapa(t, size, capa)\\n\\n\\tn.Remove(\\\"marcel\\\") // no effect since ,o, existent\\n\\tn.verify(t, checkWords)\\n\\tn.verifySizeCapa(t, size, capa)\\n\\n\\tn.Remove(\\\"nikola\\\", \\\"tesla\\\") // 1 word\\n\\tcheckWords[\\\"nikola\\\"] = false\\n\\tcheckWords[\\\"tesla\\\"] = false\\n\\tsize -= 2 // t1 word left,  but still no change in capacity\\n\\tn.verify(t, checkWords)\\n\\tn.verifySizeCapa(t, size, capa)\\n\\n\\t// compact the Tree\\n\\tif n.Compact() {\\n\\t\\tt.Fatal(\\\"the Trie should not be completely removable after compaction\\\")\\n\\t}\\n\\tif capa <= n.Capacity() {\\n\\t\\tt.Fatal(\\\"capacity should have reduced following compaction\\\")\\n\\t}\\n\\tcapa = n.Capacity()\\n\\tn.verify(t, checkWords)\\n\\tn.verifySizeCapa(t, size, capa) // still 1 word, reduced capacity\\n\\n\\tn.Remove(\\\"einstein\\\")\\n\\tcheckWords[\\\"einstein\\\"] = false\\n\\tsize-- // No more words\\n\\tn.verify(t, checkWords)\\n\\tn.verifySizeCapa(t, size, capa) // no words, but still have some nodes left capacity\\n\\n\\tif !n.Compact() {\\n\\t\\tt.Fatal(\\\"the root node of an empty Trie should be marked as removable after compaction\\\")\\n\\t}\\n\\tn.verifySizeCapa(t, 0, 1) // no words, only the root node left\\n}\\n\\n// --------------- helper functions ---------------------------\\n\\n// verify if provided words are present\\nfunc (n *Node) verify(t *testing.T, checkWords map[string]bool) {\\n\\tfor k, v := range checkWords {\\n\\t\\tok := n.Find(k)\\n\\t\\tif ok != v {\\n\\t\\t\\tt.Fatalf(\\n\\t\\t\\t\\t\\\"%q is %s supposed to be in the Trie.\\\",\\n\\t\\t\\t\\tk,\\n\\t\\t\\t\\tmap[bool]string{true: \\\"\\\", false: \\\"NOT \\\"}[v],\\n\\t\\t\\t)\\n\\t\\t}\\n\\t\\t// t.Logf(\\n\\t\\t// \\t\\\"\\\\\\\"%s\\\\\\\" is %sin the Trie.\\\",\\n\\t\\t// \\tk,\\n\\t\\t// \\tmap[bool]string{true: \\\"\\\", false: \\\"NOT \\\"}[ok],\\n\\t\\t// )\\n\\t}\\n}\\n\\n// verify expected size and capacity\\nfunc (n *Node) verifySizeCapa(t *testing.T, expectedSize, expectedCapacity int) {\\n\\tif got := n.Size(); got != expectedSize {\\n\\t\\tt.Fatalf(\\\"Expected Size was %d but got %d\\\", expectedSize, got)\\n\\t}\\n\\tif got := n.Capacity(); got != expectedCapacity {\\n\\t\\tt.Fatalf(\\\"Expected Capacity was %d but got %d\\\", expectedCapacity, got)\\n\\t}\\n}\\n\""
  }
}
