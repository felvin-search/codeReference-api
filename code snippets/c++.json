{
  "c++": {
    "graph coloring": "\"/**\\n * @file\\n * @brief prints the assigned colors\\n * using [Graph Coloring](https://en.wikipedia.org/wiki/Graph_coloring)\\n * algorithm\\n *\\n * @details\\n * In graph theory, graph coloring is a special case of graph labeling;\\n * it is an assignment of labels traditionally called \\\"colors\\\" to elements of a\\n * graph subject to certain constraints. In its simplest form, it is a way of\\n * coloring the vertices of a graph such that no two adjacent vertices are of\\n * the same color; this is called a vertex coloring. Similarly, an edge coloring\\n * assigns a color to each edge so that no two adjacent edges are of the same\\n * color, and a face coloring of a planar graph assigns a color to each face or\\n * region so that no two faces that share a boundary have the same color.\\n *\\n * @author [Anup Kumar Panwar](https://github.com/AnupKumarPanwar)\\n * @author [David Leal](https://github.com/Panquesito7)\\n */\\n\\n#include <array>     /// for std::array\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace backtracking\\n * @brief Backtracking algorithms\\n */\\nnamespace backtracking {\\n/**\\n * @namespace graph_coloring\\n * @brief Functions for the [Graph\\n * Coloring](https://en.wikipedia.org/wiki/Graph_coloring) algorithm,\\n */\\nnamespace graph_coloring {\\n/**\\n * @brief A utility function to print the solution\\n * @tparam V number of vertices in the graph\\n * @param color array of colors assigned to the nodes\\n */\\ntemplate <size_t V>\\nvoid printSolution(const std::array<int, V>& color) {\\n    std::cout << \\\"Following are the assigned colors\\\\n\\\";\\n    for (auto& col : color) {\\n        std::cout << col;\\n    }\\n    std::cout << \\\"\\\\n\\\";\\n}\\n\\n/**\\n * @brief Utility function to check if the current color assignment is safe for\\n * vertex v\\n * @tparam V number of vertices in the graph\\n * @param v index of graph vertex to check\\n * @param graph matrix of graph nonnectivity\\n * @param color vector of colors assigned to the graph nodes/vertices\\n * @param c color value to check for the node `v`\\n * @returns `true` if the color is safe to be assigned to the node\\n * @returns `false` if the color is not safe to be assigned to the node\\n */\\ntemplate <size_t V>\\nbool isSafe(int v, const std::array<std::array<int, V>, V>& graph,\\n            const std::array<int, V>& color, int c) {\\n    for (int i = 0; i < V; i++) {\\n        if (graph[v][i] && c == color[i]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * @brief Recursive utility function to solve m coloring problem\\n * @tparam V number of vertices in the graph\\n * @param graph matrix of graph nonnectivity\\n * @param m number of colors\\n * @param [in,out] color description // used in,out to notify in documentation\\n * that this parameter gets modified by the function\\n * @param v index of graph vertex to check\\n */\\ntemplate <size_t V>\\nvoid graphColoring(const std::array<std::array<int, V>, V>& graph, int m,\\n                   std::array<int, V> color, int v) {\\n    // base case:\\n    // If all vertices are assigned a color then return true\\n    if (v == V) {\\n        printSolution<V>(color);\\n        return;\\n    }\\n\\n    // Consider this vertex v and try different colors\\n    for (int c = 1; c <= m; c++) {\\n        // Check if assignment of color c to v is fine\\n        if (isSafe<V>(v, graph, color, c)) {\\n            color[v] = c;\\n\\n            // recur to assign colors to rest of the vertices\\n            graphColoring<V>(graph, m, color, v + 1);\\n\\n            // If assigning color c doesn't lead to a solution then remove it\\n            color[v] = 0;\\n        }\\n    }\\n}\\n}  // namespace graph_coloring\\n}  // namespace backtracking\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    // Create following graph and test whether it is 3 colorable\\n    // (3)---(2)\\n    // |   / |\\n    // |  /  |\\n    // | /   |\\n    // (0)---(1)\\n\\n    const int V = 4;  // number of vertices in the graph\\n    std::array<std::array<int, V>, V> graph = {\\n        std::array<int, V>({0, 1, 1, 1}), std::array<int, V>({1, 0, 1, 0}),\\n        std::array<int, V>({1, 1, 0, 1}), std::array<int, V>({1, 0, 1, 0})};\\n\\n    int m = 3;  // Number of colors\\n    std::array<int, V> color{};\\n\\n    backtracking::graph_coloring::graphColoring<V>(graph, m, color, 0);\\n    return 0;\\n}\\n\"",
    "knight tour": "\"/**\\n * @file\\n * @brief [Knight's tour](https://en.wikipedia.org/wiki/Knight%27s_tour)\\n * algorithm\\n *\\n * @details\\n * A knight's tour is a sequence of moves of a knight on a chessboard\\n * such that the knight visits every square only once. If the knight\\n * ends on a square that is one knight's move from the beginning\\n * square (so that it could tour the board again immediately, following\\n * the same path, the tour is closed; otherwise, it is open.\\n *\\n * @author [Nikhil Arora](https://github.com/nikhilarora068)\\n * @author [David Leal](https://github.com/Panquesito7)\\n */\\n#include <array>     /// for std::array\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * @namespace backtracking\\n * @brief Backtracking algorithms\\n */\\nnamespace backtracking {\\n/**\\n * @namespace knight_tour\\n * @brief Functions for the [Knight's\\n * tour](https://en.wikipedia.org/wiki/Knight%27s_tour) algorithm\\n */\\nnamespace knight_tour {\\n/**\\n * A utility function to check if i,j are valid indexes for N*N chessboard\\n * @tparam V number of vertices in array\\n * @param x current index in rows\\n * @param y current index in columns\\n * @param sol matrix where numbers are saved\\n * @returns `true` if ....\\n * @returns `false` if ....\\n */\\ntemplate <size_t V>\\nbool issafe(int x, int y, const std::array<std::array<int, V>, V> &sol) {\\n    return (x < V && x >= 0 && y < V && y >= 0 && sol[x][y] == -1);\\n}\\n\\n/**\\n * Knight's tour algorithm\\n * @tparam V number of vertices in array\\n * @param x current index in rows\\n * @param y current index in columns\\n * @param mov movement to be done\\n * @param sol matrix where numbers are saved\\n * @param xmov next move of knight (x coordinate)\\n * @param ymov next move of knight (y coordinate)\\n * @returns `true` if solution exists\\n * @returns `false` if solution does not exist\\n */\\ntemplate <size_t V>\\nbool solve(int x, int y, int mov, std::array<std::array<int, V>, V> &sol,\\n           const std::array<int, V> &xmov, std::array<int, V> &ymov) {\\n    int k = 0, xnext = 0, ynext = 0;\\n\\n    if (mov == V * V) {\\n        return true;\\n    }\\n\\n    for (k = 0; k < V; k++) {\\n        xnext = x + xmov[k];\\n        ynext = y + ymov[k];\\n\\n        if (issafe<V>(xnext, ynext, sol)) {\\n            sol[xnext][ynext] = mov;\\n\\n            if (solve<V>(xnext, ynext, mov + 1, sol, xmov, ymov) == true) {\\n                return true;\\n            } else {\\n                sol[xnext][ynext] = -1;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n}  // namespace knight_tour\\n}  // namespace backtracking\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    const int n = 8;\\n    std::array<std::array<int, n>, n> sol = {0};\\n\\n    int i = 0, j = 0;\\n    for (i = 0; i < n; i++) {\\n        for (j = 0; j < n; j++) {\\n            sol[i][j] = -1;\\n        }\\n    }\\n\\n    std::array<int, n> xmov = {2, 1, -1, -2, -2, -1, 1, 2};\\n    std::array<int, n> ymov = {1, 2, 2, 1, -1, -2, -2, -1};\\n\\n    sol[0][0] = 0;\\n\\n    bool flag = backtracking::knight_tour::solve<n>(0, 0, 1, sol, xmov, ymov);\\n    if (flag == false) {\\n        std::cout << \\\"Error: Solution does not exist\\\\n\\\";\\n    } else {\\n        for (i = 0; i < n; i++) {\\n            for (j = 0; j < n; j++) {\\n                std::cout << sol[i][j] << \\\"  \\\";\\n            }\\n            std::cout << \\\"\\\\n\\\";\\n        }\\n    }\\n    return 0;\\n}\\n\"",
    "magic sequence": "\"/*\\n * @brief [Magic sequence](https://www.csplib.org/Problems/prob019/)\\n * implementation\\n *\\n * @details Solve the magic sequence problem with backtracking\\n *\\n * \\\"A magic sequence of length $n$ is a sequence of integers $x_0\\n * \\\\ldots x_{n-1}$ between $0$ and $n-1$, such that for all $i$\\n * in $0$ to $n-1$, the number $i$ occurs exactly $x_i$ times in\\n * the sequence. For instance, $6,2,1,0,0,0,1,0,0,0$ is a magic\\n * sequence since $0$ occurs $6$ times in it, $1$ occurs twice, etc.\\\"\\n * Quote taken from the [CSPLib](https://www.csplib.org/Problems/prob019/)\\n * website\\n *\\n * @author [Jxtopher](https://github.com/Jxtopher)\\n */\\n\\n#include <algorithm>  /// for std::count\\n#include <cassert>    /// for assert\\n#include <iostream>   /// for IO operations\\n#include <list>       /// for std::list\\n#include <numeric>    /// for std::accumulate\\n#include <vector>     /// for std::vector\\n\\n/**\\n * @namespace backtracking\\n * @brief Backtracking algorithms\\n */\\nnamespace backtracking {\\n/**\\n * @namespace magic_sequence\\n * @brief Functions for the [Magic\\n * sequence](https://www.csplib.org/Problems/prob019/) implementation\\n */\\nnamespace magic_sequence {\\nusing sequence_t =\\n    std::vector<unsigned int>;  ///< Definition of the sequence type\\n/**\\n * @brief Print the magic sequence\\n * @param s working memory for the sequence\\n */\\nvoid print(const sequence_t& s) {\\n    for (const auto& item : s) std::cout << item << \\\" \\\";\\n    std::cout << std::endl;\\n}\\n\\n/**\\n * @brief Check if the sequence is magic\\n * @param s working memory for the sequence\\n * @returns true if it's a magic sequence\\n * @returns false if it's NOT a magic sequence\\n */\\nbool is_magic(const sequence_t& s) {\\n    for (unsigned int i = 0; i < s.size(); i++) {\\n        if (std::count(s.cbegin(), s.cend(), i) != s[i]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * @brief Sub-solutions filtering\\n * @param s working memory for the sequence\\n * @param depth current depth in tree\\n * @returns true if the sub-solution is valid\\n * @returns false if the sub-solution is NOT valid\\n */\\nbool filtering(const sequence_t& s, unsigned int depth) {\\n    return std::accumulate(s.cbegin(), s.cbegin() + depth,\\n                           static_cast<unsigned int>(0)) <= s.size();\\n}\\n\\n/**\\n * @brief Solve the Magic Sequence problem\\n * @param s working memory for the sequence\\n * @param ret list of the valid magic sequences\\n * @param depth current depth in the tree\\n */\\nvoid solve(sequence_t* s, std::list<sequence_t>* ret, unsigned int depth = 0) {\\n    if (depth == s->size()) {\\n        if (is_magic(*s)) {\\n            ret->push_back(*s);\\n        }\\n    } else {\\n        for (unsigned int i = 0; i < s->size(); i++) {\\n            (*s)[depth] = i;\\n            if (filtering(*s, depth + 1)) {\\n                solve(s, ret, depth + 1);\\n            }\\n        }\\n    }\\n}\\n\\n}  // namespace magic_sequence\\n}  // namespace backtracking\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // test a valid magic sequence\\n    backtracking::magic_sequence::sequence_t s_magic = {6, 2, 1, 0, 0,\\n                                                        0, 1, 0, 0, 0};\\n    assert(backtracking::magic_sequence::is_magic(s_magic));\\n\\n    // test a non-valid magic sequence\\n    backtracking::magic_sequence::sequence_t s_not_magic = {5, 2, 1, 0, 0,\\n                                                            0, 1, 0, 0, 0};\\n    assert(!backtracking::magic_sequence::is_magic(s_not_magic));\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n\\n    // solve magic sequences of size 2 to 11 and print the solutions\\n    for (unsigned int i = 2; i < 12; i++) {\\n        std::cout << \\\"Solution for n = \\\" << i << std::endl;\\n        // valid magic sequence list\\n        std::list<backtracking::magic_sequence::sequence_t> list_of_solutions;\\n        // initialization of a sequence\\n        backtracking::magic_sequence::sequence_t s1(i, i);\\n        // launch of solving the problem\\n        backtracking::magic_sequence::solve(&s1, &list_of_solutions);\\n        // print solutions\\n        for (const auto& item : list_of_solutions) {\\n            backtracking::magic_sequence::print(item);\\n        }\\n    }\\n    return 0;\\n}\\n\"",
    "minimax": "\"/**\\n * @file\\n * @brief returns which is the longest/shortest number\\n * using [minimax](https://en.wikipedia.org/wiki/Minimax) algorithm\\n *\\n * @details\\n * Minimax (sometimes MinMax, MM or saddle point) is a decision rule used in\\n * artificial intelligence, decision theory, game theory, statistics,\\n * and philosophy for minimizing the possible loss for a worst case (maximum\\n * loss) scenario. When dealing with gains, it is referred to as \\\"maximin\\\"—to\\n * maximize the minimum gain. Originally formulated for two-player zero-sum game\\n * theory, covering both the cases where players take alternate moves and those\\n * where they make simultaneous moves, it has also been extended to more complex\\n * games and to general decision-making in the presence of uncertainty.\\n *\\n * @author [Gleison Batista](https://github.com/gleisonbs)\\n * @author [David Leal](https://github.com/Panquesito7)\\n */\\n#include <algorithm>  /// for std::max, std::min\\n#include <array>      /// for std::array\\n#include <cmath>      /// for log2\\n#include <iostream>   /// for IO operations\\n\\n/**\\n * @namespace backtracking\\n * @brief Backtracking algorithms\\n */\\nnamespace backtracking {\\n/**\\n * @brief Check which is the maximum/minimum number in the array\\n * @param depth current depth in game tree\\n * @param node_index current index in array\\n * @param is_max if current index is the longest number\\n * @param scores saved numbers in array\\n * @param height maximum height for game tree\\n * @returns the maximum or minimum number\\n */\\ntemplate <size_t T>\\nint minimax(int depth, int node_index, bool is_max,\\n            const std::array<int, T> &scores, double height) {\\n    if (depth == height) {\\n        return scores[node_index];\\n    }\\n\\n    int v1 = minimax(depth + 1, node_index * 2, !is_max, scores, height);\\n    int v2 = minimax(depth + 1, node_index * 2 + 1, !is_max, scores, height);\\n\\n    return is_max ? std::max(v1, v2) : std::min(v1, v2);\\n}\\n}  // namespace backtracking\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    std::array<int, 8> scores = {90, 23, 6, 33, 21, 65, 123, 34423};\\n    double height = log2(scores.size());\\n\\n    std::cout << \\\"Optimal value: \\\"\\n              << backtracking::minimax(0, 0, true, scores, height) << std::endl;\\n    return 0;\\n}\\n\"",
    "nqueen print all solutions": "\"/**\\r\\n * @file\\r\\n * @brief [Eight Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle)\\r\\n * puzzle, printing all solutions\\r\\n *\\r\\n * @author [Himani Negi](https://github.com/Himani2000)\\r\\n * @author [David Leal](https://github.com/Panquesito7)\\r\\n *\\r\\n */\\r\\n#include <array>     /// for std::array\\r\\n#include <iostream>  /// for IO operations\\r\\n\\r\\n/**\\r\\n * @namespace backtracking\\r\\n * @brief Backtracking algorithms\\r\\n */\\r\\nnamespace backtracking {\\r\\n/**\\r\\n * @namespace n_queens_all_solutions\\r\\n * @brief Functions for the [Eight\\r\\n * Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle) puzzle with all\\r\\n * solutions.\\r\\n */\\r\\nnamespace n_queens_all_solutions {\\r\\n/**\\r\\n * @brief Utility function to print matrix\\r\\n * @tparam n number of matrix size\\r\\n * @param board matrix where numbers are saved\\r\\n */\\r\\ntemplate <size_t n>\\r\\nvoid PrintSol(const std::array<std::array<int, n>, n>& board) {\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        for (int j = 0; j < n; j++) {\\r\\n            std::cout << board[i][j] << \\\" \\\";\\r\\n        }\\r\\n        std::cout << std::endl;\\r\\n    }\\r\\n    std::cout << std::endl;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Check if a queen can be placed on the matrix\\r\\n * @tparam n number of matrix size\\r\\n * @param board matrix where numbers are saved\\r\\n * @param row current index in rows\\r\\n * @param col current index in columns\\r\\n * @returns `true` if queen can be placed on matrix\\r\\n * @returns `false` if queen can't be placed on matrix\\r\\n */\\r\\ntemplate <size_t n>\\r\\nbool CanIMove(const std::array<std::array<int, n>, n>& board, int row,\\r\\n              int col) {\\r\\n    /// check in the row\\r\\n    for (int i = 0; i < col; i++) {\\r\\n        if (board[row][i] == 1) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    /// check the first diagonal\\r\\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {\\r\\n        if (board[i][j] == 1) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    /// check the second diagonal\\r\\n    for (int i = row, j = col; i <= n - 1 && j >= 0; i++, j--) {\\r\\n        if (board[i][j] == 1) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    return true;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function to solve the N Queens problem\\r\\n * @tparam n number of matrix size\\r\\n * @param board matrix where numbers are saved\\r\\n * @param col current index in columns\\r\\n */\\r\\ntemplate <size_t n>\\r\\nvoid NQueenSol(std::array<std::array<int, n>, n> board, int col) {\\r\\n    if (col >= n) {\\r\\n        PrintSol(board);\\r\\n        return;\\r\\n    }\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        if (CanIMove(board, i, col)) {\\r\\n            board[i][col] = 1;\\r\\n            NQueenSol(board, col + 1);\\r\\n            board[i][col] = 0;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n}  // namespace n_queens_all_solutions\\r\\n}  // namespace backtracking\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @returns 0 on exit\\r\\n */\\r\\nint main() {\\r\\n    const int n = 4;\\r\\n    std::array<std::array<int, n>, n> board{0};\\r\\n\\r\\n    backtracking::n_queens_all_solutions::NQueenSol(board, 0);\\r\\n}\\r\\n\"",
    "n queens": "\"/**\\n * @file\\n * @brief [Eight Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle)\\n * puzzle\\n *\\n * @details\\n * The **eight queens puzzle** is the problem of placing eight chess queens on\\n * an 8×8 chessboard so that no two queens threaten each other; thus, a solution\\n * requires that no two queens share the same row, column, or diagonal. The\\n * eight queens puzzle is an example of the more general **n queens problem** of\\n * placing n non-attacking queens on an n×n chessboard, for which solutions\\n * exist for all natural numbers n with the exception of n = 2 and n = 3.\\n *\\n * @author Unknown author\\n * @author [David Leal](https://github.com/Panquesito7)\\n *\\n */\\n#include <array>\\n#include <iostream>\\n\\n/**\\n * @namespace backtracking\\n * @brief Backtracking algorithms\\n */\\nnamespace backtracking {\\n/**\\n * @namespace n_queens\\n * @brief Functions for [Eight\\n * Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle) puzzle.\\n */\\nnamespace n_queens {\\n/**\\n * Utility function to print matrix\\n * @tparam n number of matrix size\\n * @param board matrix where numbers are saved\\n */\\ntemplate <size_t n>\\nvoid printSolution(const std::array<std::array<int, n>, n> &board) {\\n    std::cout << \\\"\\\\n\\\";\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            std::cout << \\\"\\\" << board[i][j] << \\\" \\\";\\n        }\\n        std::cout << \\\"\\\\n\\\";\\n    }\\n}\\n\\n/**\\n * Check if a queen can be placed on matrix\\n * @tparam n number of matrix size\\n * @param board matrix where numbers are saved\\n * @param row current index in rows\\n * @param col current index in columns\\n * @returns `true` if queen can be placed on matrix\\n * @returns `false` if queen can't be placed on matrix\\n */\\ntemplate <size_t n>\\nbool isSafe(const std::array<std::array<int, n>, n> &board, const int &row,\\n            const int &col) {\\n    int i = 0, j = 0;\\n\\n    // Check this row on left side\\n    for (i = 0; i < col; i++) {\\n        if (board[row][i]) {\\n            return false;\\n        }\\n    }\\n\\n    // Check upper diagonal on left side\\n    for (i = row, j = col; i >= 0 && j >= 0; i--, j--) {\\n        if (board[i][j]) {\\n            return false;\\n        }\\n    }\\n    // Check lower diagonal on left side\\n    for (i = row, j = col; j >= 0 && i < n; i++, j--) {\\n        if (board[i][j]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * Solve n queens problem\\n * @tparam n number of matrix size\\n * @param board matrix where numbers are saved\\n * @param col current index in columns\\n */\\ntemplate <size_t n>\\nvoid solveNQ(std::array<std::array<int, n>, n> board, const int &col) {\\n    if (col >= n) {\\n        printSolution<n>(board);\\n        return;\\n    }\\n\\n    // Consider this column and try placing\\n    // this queen in all rows one by one\\n    for (int i = 0; i < n; i++) {\\n        // Check if queen can be placed\\n        // on board[i][col]\\n        if (isSafe<n>(board, i, col)) {\\n            // Place this queen in matrix\\n            board[i][col] = 1;\\n\\n            // Recursive to place rest of the queens\\n            solveNQ<n>(board, col + 1);\\n\\n            board[i][col] = 0;  // backtrack\\n        }\\n    }\\n}\\n}  // namespace n_queens\\n}  // namespace backtracking\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    const int n = 4;\\n    std::array<std::array<int, n>, n> board = {\\n        std::array<int, n>({0, 0, 0, 0}), std::array<int, n>({0, 0, 0, 0}),\\n        std::array<int, n>({0, 0, 0, 0}), std::array<int, n>({0, 0, 0, 0})};\\n\\n    backtracking::n_queens::solveNQ<n>(board, 0);\\n    return 0;\\n}\\n\"",
    "n queens all solution optimised": "\"/**\\n * @file\\n * @brief [N queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle) all\\n * optimized\\n *\\n * @author [Sombit Bose](https://github.com/deadshotsb)\\n * @author [David Leal](https://github.com/Panquesito7)\\n */\\n\\n#include <array>\\n#include <iostream>\\n\\n/**\\n * @namespace backtracking\\n * @brief Backtracking algorithms\\n */\\nnamespace backtracking {\\n/**\\n * @namespace n_queens_optimized\\n * @brief Functions for [Eight\\n * Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle) puzzle optimized.\\n */\\nnamespace n_queens_optimized {\\n/**\\n * Utility function to print matrix\\n * @tparam n number of matrix size\\n * @param board matrix where numbers are saved\\n */\\ntemplate <size_t n>\\nvoid PrintSol(const std::array<std::array<int, n>, n> &board) {\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            std::cout << board[i][j] << \\\" \\\";\\n        }\\n        std::cout << std::endl;\\n    }\\n    std::cout << std::endl;\\n    if (n % 2 == 0 || (n % 2 == 1 && board[n / 2 + 1][0] != 1)) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                std::cout << board[j][i] << \\\" \\\";\\n            }\\n            std::cout << std::endl;\\n        }\\n        std::cout << std::endl;\\n    }\\n}\\n\\n/**\\n * Check if a queen can be placed on matrix\\n * @tparam n number of matrix size\\n * @param board matrix where numbers are saved\\n * @param row current index in rows\\n * @param col current index in columns\\n * @returns `true` if queen can be placed on matrix\\n * @returns `false` if queen can't be placed on matrix\\n */\\ntemplate <size_t n>\\nbool CanIMove(const std::array<std::array<int, n>, n> &board, int row,\\n              int col) {\\n    /// check in the row\\n    for (int i = 0; i <= col; i++) {\\n        if (board[row][i] == 1) {\\n            return false;\\n        }\\n    }\\n    /// check the first diagonal\\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {\\n        if (board[i][j] == 1) {\\n            return false;\\n        }\\n    }\\n    /// check the second diagonal\\n    for (int i = row, j = col; i <= n - 1 && j >= 0; i++, j--) {\\n        if (board[i][j] == 1) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * Solve n queens problem\\n * @tparam n number of matrix size\\n * @param board matrix where numbers are saved\\n * @param col current index in columns\\n */\\ntemplate <size_t n>\\nvoid NQueenSol(std::array<std::array<int, n>, n> board, int col) {\\n    if (col >= n) {\\n        PrintSol<n>(board);\\n        return;\\n    }\\n    for (int i = 0; i < n; i++) {\\n        if (CanIMove<n>(board, i, col)) {\\n            board[i][col] = 1;\\n            NQueenSol<n>(board, col + 1);\\n            board[i][col] = 0;\\n        }\\n    }\\n}\\n}  // namespace n_queens_optimized\\n}  // namespace backtracking\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    const int n = 4;\\n    std::array<std::array<int, n>, n> board{};\\n\\n    if (n % 2 == 0) {\\n        for (int i = 0; i <= n / 2 - 1; i++) {\\n            if (backtracking::n_queens_optimized::CanIMove(board, i, 0)) {\\n                board[i][0] = 1;\\n                backtracking::n_queens_optimized::NQueenSol(board, 1);\\n                board[i][0] = 0;\\n            }\\n        }\\n    } else {\\n        for (int i = 0; i <= n / 2; i++) {\\n            if (backtracking::n_queens_optimized::CanIMove(board, i, 0)) {\\n                board[i][0] = 1;\\n                backtracking::n_queens_optimized::NQueenSol(board, 1);\\n                board[i][0] = 0;\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n\"",
    "rat maze": "\"/**\\n * @file\\n * @brief Implements [Rat in a\\n * Maze](https://www.codesdope.com/blog/article/backtracking-to-\\n * solve-a-rat-in-a-maze-c-java-pytho/) algorithm\\n *\\n * @details\\n * A Maze is given as N*N binary matrix of blocks where source block is the\\n * upper left most block i.e., maze[0][0] and destination block is lower\\n * rightmost block i.e., maze[N-1][N-1]. A rat starts from source and has to\\n * reach destination. The rat can move only in two directions: forward and down.\\n * In the maze matrix, 0 means the block is dead end and 1 means the block can\\n * be used in the path from source to destination.\\n *\\n * @author [Vaibhav Thakkar](https://github.com/vaithak)\\n * @author [David Leal](https://github.com/Panquesito7)\\n */\\n\\n#include <array>     /// for std::array\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * @namespace backtracking\\n * @brief Backtracking algorithms\\n */\\nnamespace backtracking {\\n/**\\n * @namespace rat_maze\\n * @brief Functions for [Rat in a\\n * Maze](https://www.codesdope.com/blog/article/backtracking-to-\\n * solve-a-rat-in-a-maze-c-java-pytho/) algorithm\\n */\\nnamespace rat_maze {\\n/**\\n * @brief Solve rat maze problem\\n * @tparam size number of matrix size\\n * @param currposrow current position in rows\\n * @param currposcol current position in columns\\n * @param maze matrix where numbers are saved\\n * @param soln matrix to problem solution\\n * @returns `true` if there exists a solution to move one step ahead in a column\\n * or in a row\\n * @returns `false` for the backtracking part\\n */\\ntemplate <size_t size>\\nbool solveMaze(int currposrow, int currposcol,\\n               const std::array<std::array<int, size>, size> &maze,\\n               std::array<std::array<int, size>, size> soln) {\\n    if ((currposrow == size - 1) && (currposcol == size - 1)) {\\n        soln[currposrow][currposcol] = 1;\\n        for (int i = 0; i < size; ++i) {\\n            for (int j = 0; j < size; ++j) {\\n                std::cout << soln[i][j] << \\\" \\\";\\n            }\\n            std::cout << std::endl;\\n        }\\n        return true;\\n    } else {\\n        soln[currposrow][currposcol] = 1;\\n\\n        // if there exist a solution by moving one step ahead in a column\\n        if ((currposcol < size - 1) && maze[currposrow][currposcol + 1] == 1 &&\\n            solveMaze(currposrow, currposcol + 1, maze, soln)) {\\n            return true;\\n        }\\n\\n        // if there exists a solution by moving one step ahead in a row\\n        if ((currposrow < size - 1) && maze[currposrow + 1][currposcol] == 1 &&\\n            solveMaze(currposrow + 1, currposcol, maze, soln)) {\\n            return true;\\n        }\\n\\n        // the backtracking part\\n        soln[currposrow][currposcol] = 0;\\n        return false;\\n    }\\n}\\n}  // namespace rat_maze\\n}  // namespace backtracking\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    const int size = 4;\\n    std::array<std::array<int, size>, size> maze = {\\n        std::array<int, size>{1, 0, 1, 0}, std::array<int, size>{1, 0, 1, 1},\\n        std::array<int, size>{1, 0, 0, 1}, std::array<int, size>{1, 1, 1, 1}};\\n\\n    std::array<std::array<int, size>, size> soln{};\\n\\n    // Backtracking: setup matrix solution to zero\\n    for (int i = 0; i < size; ++i) {\\n        for (int j = 0; j < size; ++j) {\\n            soln[i][j] = 0;\\n        }\\n    }\\n\\n    int currposrow = 0;  // Current position in the rows\\n    int currposcol = 0;  // Current position in the columns\\n\\n    assert(backtracking::rat_maze::solveMaze<size>(currposrow, currposcol, maze,\\n                                                   soln) == 1);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "subarray sum": "\"/**\\n * @file\\n * @brief [Subset-sum](https://en.wikipedia.org/wiki/Subset_sum_problem) (only\\n * continuous subsets) problem\\n * @details We are given an array and a sum value. The algorithms find all\\n * the subarrays of that array with sum equal to the given sum and return such\\n * subarrays count. This approach will have \\\\f$O(n)\\\\f$ time complexity and\\n * \\\\f$O(n)\\\\f$ space complexity. NOTE: In this problem, we are only referring to\\n * the continuous subsets as subarrays everywhere. Subarrays can be created\\n * using deletion operation at the end of the front of an array only. The parent\\n * array is also counted in subarrays having 0 number of deletion operations.\\n *\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n */\\n\\n#include <cassert>        /// for assert\\n#include <iostream>       /// for IO operations\\n#include <unordered_map>  /// for unordered_map\\n#include <vector>         /// for std::vector\\n\\n/**\\n * @namespace backtracking\\n * @brief Backtracking algorithms\\n */\\nnamespace backtracking {\\n/**\\n * @namespace subarray_sum\\n * @brief Functions for the [Subset\\n * sum](https://en.wikipedia.org/wiki/Subset_sum_problem) implementation\\n */\\nnamespace subarray_sum {\\n/**\\n * @brief The main function that implements the count of the subarrays\\n * @param sum is the required sum of any subarrays\\n * @param in_arr is the input array\\n * @returns count of the number of subsets with required sum\\n */\\nuint64_t subarray_sum(int64_t sum, const std::vector<int64_t> &in_arr) {\\n    int64_t nelement = in_arr.size();\\n    int64_t count_of_subset = 0;\\n    int64_t current_sum = 0;\\n    std::unordered_map<int64_t, int64_t>\\n        sumarray;  // to store the subarrays count\\n                   // frequency having some sum value\\n\\n    for (int64_t i = 0; i < nelement; i++) {\\n        current_sum += in_arr[i];\\n\\n        if (current_sum == sum) {\\n            count_of_subset++;\\n        }\\n        // If in case current_sum is greater than the required sum\\n        if (sumarray.find(current_sum - sum) != sumarray.end()) {\\n            count_of_subset += (sumarray[current_sum - sum]);\\n        }\\n        sumarray[current_sum]++;\\n    }\\n    return count_of_subset;\\n}\\n}  // namespace subarray_sum\\n}  // namespace backtracking\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st test\\n    std::cout << \\\"1st test \\\";\\n    std::vector<int64_t> array1 = {-7, -3, -2, 5, 8};  // input array\\n    assert(\\n        backtracking::subarray_sum::subarray_sum(0, array1) ==\\n        1);  // first argument in subarray_sum function is the required sum and\\n             // second is the input array, answer is the subarray {(-3,-2,5)}\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 2nd test\\n    std::cout << \\\"2nd test \\\";\\n    std::vector<int64_t> array2 = {1, 2, 3, 3};\\n    assert(backtracking::subarray_sum::subarray_sum(6, array2) ==\\n           2);  // here we are expecting 2 subsets which sum up to 6 i.e.\\n                // {(1,2,3),(3,3)}\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 3rd test\\n    std::cout << \\\"3rd test \\\";\\n    std::vector<int64_t> array3 = {1, 1, 1, 1};\\n    assert(backtracking::subarray_sum::subarray_sum(1, array3) ==\\n           4);  // here we are expecting 4 subsets which sum up to 1 i.e.\\n                // {(1),(1),(1),(1)}\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 4rd test\\n    std::cout << \\\"4th test \\\";\\n    std::vector<int64_t> array4 = {3, 3, 3, 3};\\n    assert(backtracking::subarray_sum::subarray_sum(6, array4) ==\\n           3);  // here we are expecting 3 subsets which sum up to 6 i.e.\\n                // {(3,3),(3,3),(3,3)}\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 5th test\\n    std::cout << \\\"5th test \\\";\\n    std::vector<int64_t> array5 = {};\\n    assert(backtracking::subarray_sum::subarray_sum(6, array5) ==\\n           0);  // here we are expecting 0 subsets which sum up to 6 i.e. we\\n                // cannot select anything from an empty array\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "subset sum": "\"/**\\n * @file\\n * @brief Implementation of the [Subset\\n * Sum](https://en.wikipedia.org/wiki/Subset_sum_problem) problem.\\n * @details\\n * We are given an array and a sum value. The algorithm finds all\\n * the subsets of that array with sum equal to the given sum and return such\\n * subsets count. This approach will have exponential time complexity.\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace backtracking\\n * @brief Backtracking algorithms\\n */\\nnamespace backtracking {\\n/**\\n * @namespace Subsets\\n * @brief Functions for the [Subset\\n * Sum](https://en.wikipedia.org/wiki/Subset_sum_problem) problem.\\n */\\nnamespace subset_sum {\\n/**\\n * @brief The main function implements count of subsets\\n * @param sum is the required sum of any subset\\n * @param in_arr is the input array\\n * @returns count of the number of subsets with required sum\\n */\\nuint64_t number_of_subsets(int32_t sum, const std::vector<int32_t> &in_arr) {\\n    int32_t nelement = in_arr.size();\\n    uint64_t count_of_subset = 0;\\n\\n    for (int32_t i = 0; i < (1 << (nelement)); i++) {\\n        int32_t check = 0;\\n        for (int32_t j = 0; j < nelement; j++) {\\n            if (i & (1 << j)) {\\n                check += (in_arr[j]);\\n            }\\n        }\\n        if (check == sum) {\\n            count_of_subset++;\\n        }\\n    }\\n    return count_of_subset;\\n}\\n}  // namespace subset_sum\\n}  // namespace backtracking\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st test\\n    std::cout << \\\"1st test \\\";\\n    std::vector<int32_t> array1 = {-7, -3, -2, 5, 8};  // input array\\n    assert(backtracking::subset_sum::number_of_subsets(0, array1) ==\\n           2);  // first argument in subset_sum function is the required sum and\\n                // second is the input array\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 2nd test\\n    std::cout << \\\"2nd test \\\";\\n    std::vector<int32_t> array2 = {1, 2, 3, 3};\\n    assert(backtracking::subset_sum::number_of_subsets(6, array2) ==\\n           3);  // here we are expecting 3 subsets which sum up to 6 i.e.\\n                // {(1,2,3),(1,2,3),(3,3)}\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 3rd test\\n    std::cout << \\\"3rd test \\\";\\n    std::vector<int32_t> array3 = {1, 1, 1, 1};\\n    assert(backtracking::subset_sum::number_of_subsets(1, array3) ==\\n           4);  // here we are expecting 4 subsets which sum up to 1 i.e.\\n                // {(1),(1),(1),(1)}\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 4th test\\n    std::cout << \\\"4th test \\\";\\n    std::vector<int32_t> array4 = {3, 3, 3, 3};\\n    assert(backtracking::subset_sum::number_of_subsets(6, array4) ==\\n           6);  // here we are expecting 6 subsets which sum up to 6 i.e.\\n                // {(3,3),(3,3),(3,3),(3,3),(3,3),(3,3)}\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // Test 5\\n    std::cout << \\\"5th test \\\";\\n    std::vector<int32_t> array5 = {};\\n    assert(backtracking::subset_sum::number_of_subsets(6, array5) ==\\n           0);  // here we are expecting 0 subsets which sum up to 6 i.e. we\\n                // cannot select anything from an empty array\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "sudoku solve": "\"/**\\r\\n * @file\\r\\n * @brief [Sudoku Solver](https://en.wikipedia.org/wiki/Sudoku) algorithm.\\r\\n *\\r\\n * @details\\r\\n * Sudoku (数独, sūdoku, digit-single) (/suːˈdoʊkuː/, /-ˈdɒk-/, /sə-/,\\r\\n * originally called Number Place) is a logic-based, combinatorial\\r\\n * number-placement puzzle. In classic sudoku, the objective is to fill a 9×9\\r\\n * grid with digits so that each column, each row, and each of the nine 3×3\\r\\n * subgrids that compose the grid (also called \\\"boxes\\\", \\\"blocks\\\", or \\\"regions\\\")\\r\\n * contain all of the digits from 1 to 9. The puzzle setter provides a\\r\\n * partially completed grid, which for a well-posed puzzle has a single\\r\\n * solution.\\r\\n *\\r\\n * @author [DarthCoder3200](https://github.com/DarthCoder3200)\\r\\n * @author [David Leal](https://github.com/Panquesito7)\\r\\n */\\r\\n#include <array>     /// for assert\\r\\n#include <iostream>  /// for IO operations\\r\\n\\r\\n/**\\r\\n * @namespace backtracking\\r\\n * @brief Backtracking algorithms\\r\\n */\\r\\nnamespace backtracking {\\r\\n/**\\r\\n * @namespace sudoku_solver\\r\\n * @brief Functions for the [Sudoku\\r\\n * Solver](https://en.wikipedia.org/wiki/Sudoku) implementation\\r\\n */\\r\\nnamespace sudoku_solver {\\r\\n/**\\r\\n * @brief Check if it's possible to place a number (`no` parameter)\\r\\n * @tparam V number of vertices in the array\\r\\n * @param mat matrix where numbers are saved\\r\\n * @param i current index in rows\\r\\n * @param j current index in columns\\r\\n * @param no number to be added in matrix\\r\\n * @param n number of times loop will run\\r\\n * @returns `true` if 'mat' is different from 'no'\\r\\n * @returns `false` if 'mat' equals to 'no'\\r\\n */\\r\\ntemplate <size_t V>\\r\\nbool isPossible(const std::array<std::array<int, V>, V> &mat, int i, int j,\\r\\n                int no, int n) {\\r\\n    /// `no` shouldn't be present in either row i or column j\\r\\n    for (int x = 0; x < n; x++) {\\r\\n        if (mat[x][j] == no || mat[i][x] == no) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// `no` shouldn't be present in the 3*3 subgrid\\r\\n    int sx = (i / 3) * 3;\\r\\n    int sy = (j / 3) * 3;\\r\\n\\r\\n    for (int x = sx; x < sx + 3; x++) {\\r\\n        for (int y = sy; y < sy + 3; y++) {\\r\\n            if (mat[x][y] == no) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return true;\\r\\n}\\r\\n/**\\r\\n * @brief Utility function to print the matrix\\r\\n * @tparam V number of vertices in array\\r\\n * @param mat matrix where numbers are saved\\r\\n * @param starting_mat copy of mat, required by printMat for highlighting the\\r\\n * differences\\r\\n * @param n number of times loop will run\\r\\n * @return void\\r\\n */\\r\\ntemplate <size_t V>\\r\\nvoid printMat(const std::array<std::array<int, V>, V> &mat,\\r\\n              const std::array<std::array<int, V>, V> &starting_mat, int n) {\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        for (int j = 0; j < n; j++) {\\r\\n            if (starting_mat[i][j] != mat[i][j]) {\\r\\n                std::cout << \\\"\\\\033[93m\\\" << mat[i][j] << \\\"\\\\033[0m\\\"\\r\\n                          << \\\" \\\";\\r\\n            } else {\\r\\n                std::cout << mat[i][j] << \\\" \\\";\\r\\n            }\\r\\n            if ((j + 1) % 3 == 0) {\\r\\n                std::cout << '\\\\t';\\r\\n            }\\r\\n        }\\r\\n        if ((i + 1) % 3 == 0) {\\r\\n            std::cout << std::endl;\\r\\n        }\\r\\n        std::cout << std::endl;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function to implement the Sudoku algorithm\\r\\n * @tparam V number of vertices in array\\r\\n * @param mat matrix where numbers are saved\\r\\n * @param starting_mat copy of mat, required by printMat for highlighting the\\r\\n * differences\\r\\n * @param i current index in rows\\r\\n * @param j current index in columns\\r\\n * @returns `true` if 'no' was placed\\r\\n * @returns `false` if 'no' was not placed\\r\\n */\\r\\ntemplate <size_t V>\\r\\nbool solveSudoku(std::array<std::array<int, V>, V> &mat,\\r\\n                 const std::array<std::array<int, V>, V> &starting_mat, int i,\\r\\n                 int j) {\\r\\n    /// Base Case\\r\\n    if (i == 9) {\\r\\n        /// Solved for 9 rows already\\r\\n        printMat<V>(mat, starting_mat, 9);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// Crossed the last  Cell in the row\\r\\n    if (j == 9) {\\r\\n        return solveSudoku<V>(mat, starting_mat, i + 1, 0);\\r\\n    }\\r\\n\\r\\n    /// Blue Cell - Skip\\r\\n    if (mat[i][j] != 0) {\\r\\n        return solveSudoku<V>(mat, starting_mat, i, j + 1);\\r\\n    }\\r\\n    /// White Cell\\r\\n    /// Try to place every possible no\\r\\n    for (int no = 1; no <= 9; no++) {\\r\\n        if (isPossible<V>(mat, i, j, no, 9)) {\\r\\n            /// Place the 'no' - assuming a solution will exist\\r\\n            mat[i][j] = no;\\r\\n            bool solution_found = solveSudoku<V>(mat, starting_mat, i, j + 1);\\r\\n            if (solution_found) {\\r\\n                return true;\\r\\n            }\\r\\n            /// Couldn't find a solution\\r\\n            /// loop will place the next `no`.\\r\\n        }\\r\\n    }\\r\\n    /// Solution couldn't be found for any of the numbers provided\\r\\n    mat[i][j] = 0;\\r\\n    return false;\\r\\n}\\r\\n}  // namespace sudoku_solver\\r\\n}  // namespace backtracking\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @returns 0 on exit\\r\\n */\\r\\nint main() {\\r\\n    const int V = 9;\\r\\n    std::array<std::array<int, V>, V> mat = {\\r\\n        std::array<int, V>{5, 3, 0, 0, 7, 0, 0, 0, 0},\\r\\n        std::array<int, V>{6, 0, 0, 1, 9, 5, 0, 0, 0},\\r\\n        std::array<int, V>{0, 9, 8, 0, 0, 0, 0, 6, 0},\\r\\n        std::array<int, V>{8, 0, 0, 0, 6, 0, 0, 0, 3},\\r\\n        std::array<int, V>{4, 0, 0, 8, 0, 3, 0, 0, 1},\\r\\n        std::array<int, V>{7, 0, 0, 0, 2, 0, 0, 0, 6},\\r\\n        std::array<int, V>{0, 6, 0, 0, 0, 0, 2, 8, 0},\\r\\n        std::array<int, V>{0, 0, 0, 4, 1, 9, 0, 0, 5},\\r\\n        std::array<int, V>{0, 0, 0, 0, 8, 0, 0, 7, 9}};\\r\\n\\r\\n    backtracking::sudoku_solver::printMat<V>(mat, mat, 9);\\r\\n    std::cout << \\\"Solution \\\" << std::endl;\\r\\n    std::array<std::array<int, V>, V> starting_mat = mat;\\r\\n    backtracking::sudoku_solver::solveSudoku<V>(mat, starting_mat, 0, 0);\\r\\n\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "wildcard matching": "\"/**\\n * @file\\n * @brief Implementation of the [Wildcard\\n * Matching](https://www.geeksforgeeks.org/wildcard-pattern-matching/) problem.\\n * @details\\n * Given a matching string and a pattern, implement wildcard pattern\\n * matching with support for `?` and `*`. `?` matches any single character.\\n * `*` matches any sequence of characters (including the empty sequence).\\n * The matching should cover the entire matching string (not partial). The task\\n * is to determine if the pattern matches with the matching string\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace backtracking\\n * @brief Backtracking algorithms\\n */\\nnamespace backtracking {\\n/**\\n * @namespace wildcard_matching\\n * @brief Functions for the [Wildcard\\n * Matching](https://www.geeksforgeeks.org/wildcard-pattern-matching/) problem.\\n */\\nnamespace wildcard_matching {\\n/**\\n * @brief The main function implements if pattern can be matched with given\\n * string\\n * @param s is the given matching string\\n * @param p is the given pattern\\n * @param pos1 is the starting index\\n * @param pos2 is the last index\\n * @returns 1 if pattern matches with matching string otherwise 0\\n */\\nstd::vector<std::vector<int64_t>> dpTable(1000, std::vector<int64_t>(1000, -1));\\nbool wildcard_matching(std::string s, std::string p, uint32_t pos1,\\n                       uint32_t pos2) {\\n    uint32_t n = s.length();\\n    uint32_t m = p.length();\\n    // matching is successfull if both strings are done\\n    if (pos1 == n && pos2 == m) {\\n        return true;\\n    }\\n\\n    // matching is unsuccessfull if pattern is not finished but matching string\\n    // is\\n    if (pos1 != n && pos2 == m) {\\n        return false;\\n    }\\n\\n    // all the remaining characters of patterns must be * inorder to match with\\n    // finished string\\n    if (pos1 == n && pos2 != m) {\\n        while (pos2 < m && p[pos2] == '*') {\\n            pos2++;\\n        }\\n\\n        return pos2 == m;\\n    }\\n\\n    // if already calculted for these positions\\n    if (dpTable[pos1][pos2] != -1) {\\n        return dpTable[pos1][pos2];\\n    }\\n\\n    // if the characters are same just go ahead in both the string\\n    if (s[pos1] == p[pos2]) {\\n        return dpTable[pos1][pos2] =\\n                   wildcard_matching(s, p, pos1 + 1, pos2 + 1);\\n    }\\n\\n    else {\\n        // can only single character\\n        if (p[pos2] == '?') {\\n            return dpTable[pos1][pos2] =\\n                       wildcard_matching(s, p, pos1 + 1, pos2 + 1);\\n        }\\n        // have choice either to match one or more charcters\\n        else if (p[pos2] == '*') {\\n            return dpTable[pos1][pos2] =\\n                       wildcard_matching(s, p, pos1, pos2 + 1) ||\\n                       wildcard_matching(s, p, pos1 + 1, pos2);\\n        }\\n        // not possible to match\\n        else {\\n            return dpTable[pos1][pos2] = 0;\\n        }\\n    }\\n}\\n\\n}  // namespace wildcard_matching\\n}  // namespace backtracking\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st test\\n    std::cout << \\\"1st test \\\";\\n    std::string matching1 = \\\"baaabab\\\";\\n    std::string pattern1 = \\\"*****ba*****ab\\\";\\n    assert(backtracking::wildcard_matching::wildcard_matching(matching1,\\n                                                              pattern1, 0, 0) ==\\n           1);  // here the pattern matches with given string\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 2nd test\\n    std::cout << \\\"2nd test \\\";\\n    std::string matching2 = \\\"baaabab\\\";\\n    std::string pattern2 = \\\"ba*****ab\\\";\\n    assert(backtracking::wildcard_matching::wildcard_matching(matching2,\\n                                                              pattern2, 0, 0) ==\\n           1);  // here the pattern matches with given string\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 3rd test\\n    std::cout << \\\"3rd test \\\";\\n    std::string matching3 = \\\"baaabab\\\";\\n    std::string pattern3 = \\\"ba*ab\\\";\\n    assert(backtracking::wildcard_matching::wildcard_matching(matching3,\\n                                                              pattern3, 0, 0) ==\\n           1);  // here the pattern matches with given string\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 4th test\\n    std::cout << \\\"4th test \\\";\\n    std::string matching4 = \\\"baaabab\\\";\\n    std::string pattern4 = \\\"a*ab\\\";\\n    assert(backtracking::wildcard_matching::wildcard_matching(matching4,\\n                                                              pattern4, 0, 0) ==\\n           1);  // here the pattern matches with given string\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 5th test\\n    std::cout << \\\"5th test \\\";\\n    std::string matching5 = \\\"baaabab\\\";\\n    std::string pattern5 = \\\"aa?ab\\\";\\n    assert(backtracking::wildcard_matching::wildcard_matching(matching5,\\n                                                              pattern5, 0, 0) ==\\n           1);  // here the pattern matches with given string\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "count of set bits": "\"/**\\n * @file\\n * @brief Implementation to [count number of set bits of a number]\\n * (https://www.geeksforgeeks.org/count-set-bits-in-an-integer/) in an\\n * integer.\\n *\\n * @details\\n * We are given an integer number. We need to calculate the number of set bits\\n * in it.\\n *\\n * A binary number consists of two digits. They are 0 & 1. Digit 1 is known as\\n * set bit in computer terms.\\n * Worst Case Time Complexity: O(log n)\\n * Space complexity: O(1)\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n * @author [Prashant Thakur](https://github.com/prashant-th18)\\n */\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n/**\\n * @namespace bit_manipulation\\n * @brief Bit manipulation algorithms\\n */\\nnamespace bit_manipulation {\\n/**\\n * @namespace count_of_set_bits\\n * @brief Functions for the [count sets\\n * bits](https://www.geeksforgeeks.org/count-set-bits-in-an-integer/)\\n * implementation\\n */\\nnamespace count_of_set_bits {\\n/**\\n * @brief The main function implements set bit count\\n * @param n is the number whose set bit will be counted\\n * @returns total number of set-bits in the binary representation of number `n`\\n */\\nstd::uint64_t countSetBits(\\n    std ::int64_t n) {  // int64_t is preferred over int so that\\n                        // no Overflow can be there.\\n\\n    int count = 0;  // \\\"count\\\" variable is used to count number of set-bits('1')\\n                    // in binary representation of number 'n'\\n    while (n != 0) {\\n        ++count;\\n        n = (n & (n - 1));\\n    }\\n    return count;\\n    // Why this algorithm is better than the standard one?\\n    // Because this algorithm runs the same number of times as the number of\\n    // set-bits in it. Means if my number is having \\\"3\\\" set bits, then this\\n    // while loop will run only \\\"3\\\" times!!\\n}\\n}  // namespace count_of_set_bits\\n}  // namespace bit_manipulation\\n\\nstatic void test() {\\n    // n = 4 return 1\\n    assert(bit_manipulation::count_of_set_bits::countSetBits(4) == 1);\\n    // n = 6 return 2\\n    assert(bit_manipulation::count_of_set_bits::countSetBits(6) == 2);\\n    // n = 13 return 3\\n    assert(bit_manipulation::count_of_set_bits::countSetBits(13) == 3);\\n    // n = 9 return 2\\n    assert(bit_manipulation::count_of_set_bits::countSetBits(9) == 2);\\n    // n = 15 return 4\\n    assert(bit_manipulation::count_of_set_bits::countSetBits(15) == 4);\\n    // n = 25 return 3\\n    assert(bit_manipulation::count_of_set_bits::countSetBits(25) == 3);\\n    // n = 97 return 3\\n    assert(bit_manipulation::count_of_set_bits::countSetBits(97) == 3);\\n    // n = 31 return 5\\n    assert(bit_manipulation::count_of_set_bits::countSetBits(31) == 5);\\n    std::cout << \\\"All test cases successfully passed!\\\" << std::endl;\\n}\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "count of trailing ciphers in factorial n": "\"/**\\n * @file\\n * @brief [Count the number of\\n * ciphers](https://www.tutorialspoint.com/count-trailing-zeros-in-factorial-of-a-number-in-cplusplus) in `n!` implementation\\n * @details\\n * Given an integer number as input. The goal is to find the number of trailing\\n zeroes in the factorial calculated for\\n * that number. A factorial of a number N is a product of all numbers in the\\n range [1, N].\\n\\n * We know that we get a trailing zero only if the number is multiple of 10 or\\n has a factor pair (2,5). In all factorials of\\n * any number greater than 5, we have many 2s more than 5s in the prime\\n factorization of that number. Dividing a\\n * number by powers of 5 will give us the count of 5s in its factors. So, the\\n number of 5s will tell us the number of trailing zeroes.\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * @namespace bit_manipulation\\n * @brief Bit manipulation algorithms\\n */\\nnamespace bit_manipulation {\\n/**\\n * @namespace count_of_trailing_ciphers_in_factorial_n\\n * @brief Functions for the [Count the number of\\n * ciphers](https://www.tutorialspoint.com/count-trailing-zeros-in-factorial-of-a-number-in-cplusplus)\\n * in `n!` implementation\\n */\\nnamespace count_of_trailing_ciphers_in_factorial_n {\\n/**\\n * @brief Function to count the number of the trailing ciphers\\n * @param n number for which `n!` ciphers are returned\\n * @return count, Number of ciphers in `n!`.\\n */\\nuint64_t numberOfCiphersInFactorialN(uint64_t n) {\\n    // count is to store the number of 5's in factorial(n)\\n    uint64_t count = 0;\\n\\n    // Keep dividing n by powers of\\n    // 5 and update count\\n    for (uint64_t i = 5; n / i >= 1; i *= 5) {\\n        count += static_cast<uint64_t>(n) / i;\\n    }\\n\\n    return count;\\n}\\n}  // namespace count_of_trailing_ciphers_in_factorial_n\\n}  // namespace bit_manipulation\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st test\\n    std::cout << \\\"1st test \\\";\\n    assert(bit_manipulation::count_of_trailing_ciphers_in_factorial_n::\\n               numberOfCiphersInFactorialN(395) == 97);\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 2nd test\\n    std::cout << \\\"2nd test \\\";\\n    assert(bit_manipulation::count_of_trailing_ciphers_in_factorial_n::\\n               numberOfCiphersInFactorialN(977) == 242);\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 3rd test\\n    std::cout << \\\"3rd test \\\";\\n    assert(bit_manipulation::count_of_trailing_ciphers_in_factorial_n::\\n               numberOfCiphersInFactorialN(871) == 215);\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 4th test\\n    std::cout << \\\"4th test \\\";\\n    assert(bit_manipulation::count_of_trailing_ciphers_in_factorial_n::\\n               numberOfCiphersInFactorialN(239) == 57);\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 5th test\\n    std::cout << \\\"5th test \\\";\\n    assert(bit_manipulation::count_of_trailing_ciphers_in_factorial_n::\\n               numberOfCiphersInFactorialN(0) == 0);\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "hamming distance": "\"/**\\n * @file\\n * @brief Returns the [Hamming\\n * distance](https://en.wikipedia.org/wiki/Hamming_distance) between two\\n * integers\\n *\\n * @details\\n * To find hamming distance between two integers, we take their xor, which will\\n * have a set bit iff those bits differ in the two numbers.\\n * Hence, we return the number of such set bits.\\n *\\n * @author [Ravishankar Joshi](https://github.com/ravibitsgoa)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for io operations\\n\\n/**\\n * @namespace bit_manipulation\\n * @brief Bit Manipulation algorithms\\n */\\nnamespace bit_manipulation {\\n/**\\n * @namespace hamming_distance\\n * @brief Functions for [Hamming\\n * distance](https://en.wikipedia.org/wiki/Hamming_distance) implementation\\n */\\nnamespace hamming_distance {\\n/**\\n * This function returns the number of set bits in the given number.\\n * @param value the number of which we want to count the number of set bits.\\n * @returns the number of set bits in the given number.\\n */\\nuint64_t bitCount(uint64_t value) {\\n    uint64_t count = 0;\\n    while (value) {       // until all bits are zero\\n        if (value & 1) {  // check lower bit\\n            count++;\\n        }\\n        value >>= 1;  // shift bits, removing lower bit\\n    }\\n    return count;\\n}\\n\\n/**\\n * This function returns the hamming distance between two integers.\\n * @param a the first number\\n * @param b the second number\\n * @returns the number of bits differing between the two integers.\\n */\\nuint64_t hamming_distance(uint64_t a, uint64_t b) { return bitCount(a ^ b); }\\n\\n/**\\n * This function returns the hamming distance between two strings.\\n * @param a the first string\\n * @param b the second string\\n * @returns the number of characters differing between the two strings.\\n */\\nuint64_t hamming_distance(const std::string& a, const std::string& b) {\\n    assert(a.size() == b.size());\\n    size_t n = a.size();\\n    uint64_t count = 0;\\n    for (size_t i = 0; i < n; i++) {\\n        count += (b[i] != a[i]);\\n    }\\n    return count;\\n}\\n}  // namespace hamming_distance\\n}  // namespace bit_manipulation\\n\\n/**\\n * @brief Function to the test hamming distance.\\n * @returns void\\n */\\nstatic void test() {\\n    assert(bit_manipulation::hamming_distance::hamming_distance(11, 2) == 2);\\n    assert(bit_manipulation::hamming_distance::hamming_distance(2, 0) == 1);\\n    assert(bit_manipulation::hamming_distance::hamming_distance(11, 0) == 3);\\n\\n    assert(bit_manipulation::hamming_distance::hamming_distance(\\\"1101\\\",\\n                                                                \\\"1111\\\") == 1);\\n    assert(bit_manipulation::hamming_distance::hamming_distance(\\\"1111\\\",\\n                                                                \\\"1111\\\") == 0);\\n    assert(bit_manipulation::hamming_distance::hamming_distance(\\\"0000\\\",\\n                                                                \\\"1111\\\") == 4);\\n\\n    assert(bit_manipulation::hamming_distance::hamming_distance(\\\"alpha\\\",\\n                                                                \\\"alphb\\\") == 1);\\n    assert(bit_manipulation::hamming_distance::hamming_distance(\\\"abcd\\\",\\n                                                                \\\"abcd\\\") == 0);\\n    assert(bit_manipulation::hamming_distance::hamming_distance(\\\"dcba\\\",\\n                                                                \\\"abcd\\\") == 4);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();           // execute the tests\\n    uint64_t a = 11;  // 1011 in binary\\n    uint64_t b = 2;   // 0010 in binary\\n\\n    std::cout << \\\"Hamming distance between \\\" << a << \\\" and \\\" << b << \\\" is \\\"\\n              << bit_manipulation::hamming_distance::hamming_distance(a, b)\\n              << std::endl;\\n}\\n\"",
    "a1z26 cipher": "\"/**\\n * @file\\n * @brief Implementation of the [A1Z26\\n * cipher](https://www.dcode.fr/letter-number-cipher)\\n * @details The A1Z26 cipher is a simple substiution cipher where each letter is\\n * replaced by the number of the order they're in. For example, A corresponds to\\n * 1, B = 2, C = 3, etc.\\n *\\n * @author [Focusucof](https://github.com/Focusucof)\\n */\\n\\n#include <algorithm>  /// for std::transform and std::replace\\n#include <cassert>    /// for assert\\n#include <cstdint>    /// for uint8_t\\n#include <iostream>   /// for IO operations\\n#include <map>        /// for std::map\\n#include <sstream>    /// for std::stringstream\\n#include <string>     /// for std::string\\n#include <vector>     /// for std::vector\\n\\n/**\\n * @namespace ciphers\\n * @brief Algorithms for encryption and decryption\\n */\\nnamespace ciphers {\\n/**\\n * @namespace a1z26\\n * @brief Functions for [A1Z26](https://www.dcode.fr/letter-number-cipher)\\n * encryption and decryption implementation\\n */\\nnamespace a1z26 {\\n\\nstd::map<uint8_t, char> a1z26_decrypt_map = {\\n    {1, 'a'},  {2, 'b'},  {3, 'c'},  {4, 'd'},  {5, 'e'},  {6, 'f'},  {7, 'g'},\\n    {8, 'h'},  {9, 'i'},  {10, 'j'}, {11, 'k'}, {12, 'l'}, {13, 'm'}, {14, 'n'},\\n    {15, 'o'}, {16, 'p'}, {17, 'q'}, {18, 'r'}, {19, 's'}, {20, 't'}, {21, 'u'},\\n    {22, 'v'}, {23, 'w'}, {24, 'x'}, {25, 'y'}, {26, 'z'},\\n};\\n\\nstd::map<char, uint8_t> a1z26_encrypt_map = {\\n    {'a', 1},  {'b', 2},  {'c', 3},  {'d', 4},  {'e', 5},  {'f', 6},  {'g', 7},\\n    {'h', 8},  {'i', 9},  {'j', 10}, {'k', 11}, {'l', 12}, {'m', 13}, {'n', 14},\\n    {'o', 15}, {'p', 16}, {'q', 17}, {'r', 18}, {'s', 19}, {'t', 20}, {'u', 21},\\n    {'v', 22}, {'w', 23}, {'x', 24}, {'y', 25}, {'z', 26}};\\n\\n/**\\n * @brief a1z26 encryption implementation\\n * @param text is the plaintext input\\n * @returns encoded string with dashes to seperate letters\\n */\\nstd::string encrypt(std::string text) {\\n    std::string result;\\n    std::transform(text.begin(), text.end(), text.begin(),\\n                   ::tolower);  // convert string to lowercase\\n    std::replace(text.begin(), text.end(), ':', ' ');\\n    for (char letter : text) {\\n        if (letter != ' ') {\\n            result += std::to_string(\\n                a1z26_encrypt_map[letter]);  // convert int to string and append\\n                                             // to result\\n            result += \\\"-\\\";  // space out each set of numbers with spaces\\n        } else {\\n            result.pop_back();\\n            result += ' ';\\n        }\\n    }\\n    result.pop_back();  // remove leading dash\\n    return result;\\n}\\n\\n/**\\n * @brief a1z26 decryption implementation\\n * @param text is the encrypted text input\\n * @param bReturnUppercase is if the decoded string should be in uppercase or\\n * not\\n * @returns the decrypted string in all uppercase or all lowercase\\n */\\nstd::string decrypt(const std::string& text, bool bReturnUppercase = false) {\\n    std::string result;\\n\\n    // split words seperated by spaces into a vector array\\n    std::vector<std::string> word_array;\\n    std::stringstream sstream(text);\\n    std::string word;\\n    while (sstream >> word) {\\n        word_array.push_back(word);\\n    }\\n\\n    for (auto& i : word_array) {\\n        std::replace(i.begin(), i.end(), '-', ' ');\\n        std::vector<std::string> text_array;\\n\\n        std::stringstream ss(i);\\n        std::string res_text;\\n        while (ss >> res_text) {\\n            text_array.push_back(res_text);\\n        }\\n\\n        for (auto& i : text_array) {\\n            result += a1z26_decrypt_map[stoi(i)];\\n        }\\n\\n        result += ' ';\\n    }\\n    result.pop_back();  // remove any leading whitespace\\n\\n    if (bReturnUppercase) {\\n        std::transform(result.begin(), result.end(), result.begin(), ::toupper);\\n    }\\n    return result;\\n}\\n\\n}  // namespace a1z26\\n}  // namespace ciphers\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st test\\n    std::string input = \\\"Hello World\\\";\\n    std::string expected = \\\"8-5-12-12-15 23-15-18-12-4\\\";\\n    std::string output = ciphers::a1z26::encrypt(input);\\n\\n    std::cout << \\\"Input: \\\" << input << std::endl;\\n    std::cout << \\\"Expected: \\\" << expected << std::endl;\\n    std::cout << \\\"Output: \\\" << output << std::endl;\\n    assert(output == expected);\\n    std::cout << \\\"TEST PASSED\\\";\\n\\n    // 2nd test\\n    input = \\\"12-15-23-5-18-3-1-19-5\\\";\\n    expected = \\\"lowercase\\\";\\n    output = ciphers::a1z26::decrypt(input);\\n\\n    std::cout << \\\"Input: \\\" << input << std::endl;\\n    std::cout << \\\"Expected: \\\" << expected << std::endl;\\n    std::cout << \\\"Output: \\\" << output << std::endl;\\n    assert(output == expected);\\n    std::cout << \\\"TEST PASSED\\\";\\n\\n    // 3rd test\\n    input = \\\"21-16-16-5-18-3-1-19-5\\\";\\n    expected = \\\"UPPERCASE\\\";\\n    output = ciphers::a1z26::decrypt(input, true);\\n\\n    std::cout << \\\"Input: \\\" << input << std::endl;\\n    std::cout << \\\"Expected: \\\" << expected << std::endl;\\n    std::cout << \\\"Output: \\\" << output << std::endl;\\n    assert(output == expected);\\n    std::cout << \\\"TEST PASSED\\\";\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "atbash cipher": "\"/**\\r\\n * @file\\r\\n * @brief [Atbash Cipher](https://en.wikipedia.org/wiki/Atbash) implementation\\r\\n * @details The Atbash cipher is a subsitution cipher where the letters of the\\r\\n * alphabet are in reverse. For example, A is replaced with Z, B is replaced\\r\\n * with Y, etc.\\r\\n *\\r\\n * ### Algorithm\\r\\n * The algorithm takes a string, and looks up the corresponding reversed letter\\r\\n * for each letter in the word and replaces it. Spaces are ignored and case is\\r\\n * preserved.\\r\\n *\\r\\n * @author [Focusucof](https://github.com/Focusucof)\\r\\n */\\r\\n#include <cassert>   /// for assert\\r\\n#include <iostream>  /// for IO operations\\r\\n#include <map>       /// for std::map\\r\\n#include <string>    /// for std::string\\r\\n\\r\\n/** \\\\namespace ciphers\\r\\n * \\\\brief Algorithms for encryption and decryption\\r\\n */\\r\\nnamespace ciphers {\\r\\n/** \\\\namespace atbash\\r\\n * \\\\brief Functions for the [Atbash\\r\\n * Cipher](https://en.wikipedia.org/wiki/Atbash) implementation\\r\\n */\\r\\nnamespace atbash {\\r\\nstd::map<char, char> atbash_cipher_map = {\\r\\n    {'a', 'z'}, {'b', 'y'}, {'c', 'x'}, {'d', 'w'}, {'e', 'v'}, {'f', 'u'},\\r\\n    {'g', 't'}, {'h', 's'}, {'i', 'r'}, {'j', 'q'}, {'k', 'p'}, {'l', 'o'},\\r\\n    {'m', 'n'}, {'n', 'm'}, {'o', 'l'}, {'p', 'k'}, {'q', 'j'}, {'r', 'i'},\\r\\n    {'s', 'h'}, {'t', 'g'}, {'u', 'f'}, {'v', 'e'}, {'w', 'd'}, {'x', 'c'},\\r\\n    {'y', 'b'}, {'z', 'a'}, {'A', 'Z'}, {'B', 'Y'}, {'C', 'X'}, {'D', 'W'},\\r\\n    {'E', 'V'}, {'F', 'U'}, {'G', 'T'}, {'H', 'S'}, {'I', 'R'}, {'J', 'Q'},\\r\\n    {'K', 'P'}, {'L', 'O'}, {'M', 'N'}, {'N', 'M'}, {'O', 'L'}, {'P', 'K'},\\r\\n    {'Q', 'J'}, {'R', 'I'}, {'S', 'H'}, {'T', 'G'}, {'U', 'F'}, {'V', 'E'},\\r\\n    {'W', 'D'}, {'X', 'C'}, {'Y', 'B'}, {'Z', 'A'}, {' ', ' '}\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @brief atbash cipher encryption and decryption\\r\\n * @param text Plaintext to be encrypted\\r\\n * @returns encoded or decoded string\\r\\n */\\r\\nstd::string atbash_cipher(const std::string& text) {\\r\\n    std::string result;\\r\\n    for (char letter : text) {\\r\\n        result += atbash_cipher_map[letter];\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n\\r\\n}  // namespace atbash\\r\\n}  // namespace ciphers\\r\\n\\r\\n/**\\r\\n * @brief Self-test implementations\\r\\n * @returns void\\r\\n */\\r\\nstatic void test() {\\r\\n    // 1st test\\r\\n    std::string text = \\\"Hello World\\\";\\r\\n    std::string expected = \\\"Svool Dliow\\\";\\r\\n    std::string encrypted_text = ciphers::atbash::atbash_cipher(text);\\r\\n    std::string decrypted_text = ciphers::atbash::atbash_cipher(encrypted_text);\\r\\n    assert(expected == encrypted_text);\\r\\n    assert(text == decrypted_text);\\r\\n    std::cout << \\\"Original text: \\\" << text << std::endl;\\r\\n    std::cout << \\\", Expected text: \\\" << expected << std::endl;\\r\\n    std::cout << \\\", Encrypted text: \\\" << encrypted_text << std::endl;\\r\\n    std::cout << \\\", Decrypted text: \\\" << decrypted_text << std::endl;\\r\\n    std::cout << \\\"\\\\nAll tests have successfully passed!\\\\n\\\";\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @returns 0 on exit\\r\\n */\\r\\nint main() {\\r\\n    test();  // run self-test implementations\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "base64 encoding": "\"/**\\n * @brief [Base64 Encoding and\\n * Decoding](https://en.wikipedia.org/wiki/Base64)\\n * @details In programming, [Base64](https://en.wikipedia.org/wiki/Base64) is a\\n * group of binary-to-text encoding schemes that represent binary data (more\\n * specifically, a sequence of 8-bit bytes) in an ASCII string format by\\n * translating the data into a radix-64 representation. The term Base64\\n * originates from a specific MIME content transfer encoding. Each non-final\\n * Base64 digit represents exactly 6 bits of data. Three 8-bit bytes (i.e., a\\n * total of 24 bits) can therefore be represented by four 6-bit Base64\\n * digits.\\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\\n */\\n#include <array>     /// for `std::array`\\n#include <cassert>   /// for `assert` operations\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * @namespace ciphers\\n * @brief Cipher algorithms\\n */\\nnamespace ciphers {\\n/**\\n * @namespace base64_encoding\\n * @brief Functions for [Base64 Encoding and\\n * Decoding](https://en.wikipedia.org/wiki/Base64) implementation.\\n */\\nnamespace base64_encoding {\\n// chars denoting the format for encoding and decoding array.\\n// This array is already decided by\\n// [RFC4648](https://tools.ietf.org/html/rfc4648#section-4) standard\\nconst std::string chars =\\n    \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n/**\\n * @brief Base64 Encoder\\n * @details Converts the given string to Base64 equivalent.\\n * @param input Input as a string\\n * @returns Base64 encoded string\\n */\\nstd::string base64_encode(const std::string &input) {\\n    std::string base64_string;  /// Output of this function: base64 string\\n    // base64 deals with 6-bit chars encoded as per chars, so\\n    // we will always filter 6-bits from input.\\n    for (uint32_t i = 0; i < input.size(); i += 3) {\\n        char first_byte = input[i];  /// First byte of the iteration\\n        // Take first six bits of first character.\\n        // Encode the first six bits with character defined in string `chars`\\n        base64_string.push_back(chars[first_byte >> 2]);\\n\\n        if (i + 1 < input.size()) {\\n            char second_byte = input[i + 1];  /// Second byte of the iteration\\n            // Take remaining two bits of first character, and four first bits\\n            // from second character Combine two numbers as 6-bit digits and\\n            // encode by array chars (first two bits of first byte and next four\\n            // of second byte)\\n            base64_string.push_back(\\n                chars[(((first_byte & 3) << 4) | ((second_byte & 0xF0) >> 4))]);\\n\\n            if (i + 2 < input.size()) {\\n                char third_byte = input[i + 2];  /// Third byte of the iteration\\n                // Take remaining four bits of second character, and first two\\n                // bits from third character Combine two numbers as 6-bit digits\\n                // and encode by array chars (remaining four bits of second byte\\n                // and first two of third byte)\\n                base64_string.push_back(chars[((third_byte & 0xC0) >> 6) |\\n                                              ((second_byte & 0x0F) << 2)]);\\n                // Encode remaining 6-bit of third byte by array chars\\n                base64_string.push_back(chars[(third_byte & 0x3F)]);\\n            } else {\\n                // Take remaining four bits of second character as 6-bit number\\n                base64_string.push_back(chars[((second_byte & 0x0F) << 2)]);\\n                base64_string.push_back('=');  // padding characters\\n            }\\n        } else {\\n            // Take remaining two bits of first character as 6-bit number\\n            base64_string.push_back(chars[((first_byte & 3) << 4)]);\\n            base64_string.push_back('=');  // padding characters\\n            base64_string.push_back('=');  // padding characters\\n        }\\n    }\\n    return base64_string;\\n}\\n/**\\n * @brief Utility function for finding index\\n * @details Utility function for finding the position of a character in array\\n * `chars`\\n * @param c character to search in array `chars`\\n * @returns integer denoting position of character in array `chars`\\n */\\nuint8_t find_idx(const char c) {\\n    if (c >= 'A' && c <= 'Z') {\\n        return c - 'A';\\n    } else if (c >= 'a' && c <= 'z') {\\n        return c - 'a' + 26;\\n    } else if (c >= '0' && c <= '9') {\\n        return c - '0' + 52;\\n    } else if (c == '+') {\\n        return 62;\\n    } else if (c == '/') {\\n        return 63;\\n    }\\n    return -1;\\n}\\n/**\\n * @brief Base64 Decoder\\n * @details Decodes the Base64 string\\n * @param base64_str Input as a Base64 string\\n * @returns Base64 decoded string\\n */\\nstd::string base64_decode(const std::string &base64_str) {\\n    std::string\\n        base64_decoded;  /// Output of this function: base64 decoded string\\n    for (uint32_t i = 0; i < base64_str.size(); i += 4) {\\n        /// First 6-bit representation of Base64\\n        char first_byte = base64_str[i];\\n        /// Second 6-bit representation of Base64\\n        char second_byte = base64_str[i + 1];\\n        // Actual str characters are of 8 bits (or 1 byte):\\n        // :: 8 bits are decode by taking 6 bits from 1st byte of base64 string\\n        // and first 2 bits from 2nd byte of base64 string.\\n        char first_actual_byte = static_cast<char>(\\n            (find_idx(first_byte) << 2) | ((find_idx(second_byte)) >> 4));\\n        base64_decoded.push_back(first_actual_byte);\\n        if (i + 2 < base64_str.size() && base64_str[i + 2] != '=') {\\n            /// Third 6-bit representation of Base64\\n            char third_byte = base64_str[i + 2];\\n            // :: Next 8 bits are decode by taking remaining 4 bits from 2nd\\n            // byte of base64 string and first 4 bits from 3rd byte of base64\\n            // string.\\n            char second_actual_byte =\\n                static_cast<char>(((find_idx(second_byte) & 0x0F) << 4) |\\n                                  (find_idx(third_byte) >> 2));\\n            base64_decoded.push_back(second_actual_byte);\\n\\n            if (i + 3 < base64_str.size() && base64_str[i + 3] != '=') {\\n                /// Fourth 6-bit representation of Base64 string\\n                char fourth_byte = base64_str[i + 3];\\n                // :: Taking remaining 2 bits from 3rd byte of base64 string\\n                // and all 6 bits from 4th byte of base64 string.\\n                char third_actual_byte =\\n                    static_cast<char>(((find_idx(third_byte) & 0x03) << 6) |\\n                                      find_idx(fourth_byte));\\n                base64_decoded.push_back(third_actual_byte);\\n            }\\n        }\\n    }\\n    return base64_decoded;\\n}\\n}  // namespace base64_encoding\\n}  // namespace ciphers\\n\\n/**\\n * @brief Self test-implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st Test\\n    std::string str =\\n        \\\"To err is human, but to really foul things up you need a computer.\\\";\\n    std::string base64_str = ciphers::base64_encoding::base64_encode(str);\\n    std::string verify =\\n        \\\"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZW\\\"\\n        \\\"VkIGEgY29tcHV0ZXIu\\\";\\n    // verify encoding\\n    assert(base64_str == verify);\\n    std::string original_str =\\n        ciphers::base64_encoding::base64_decode(base64_str);\\n    // verify decoding\\n    assert(original_str == str);\\n\\n    // 2nd Test from [Wikipedia](https://en.wikipedia.org/wiki/Base64)\\n    str =\\n        \\\"Man is distinguished, not only by his reason, but by this singular \\\"\\n        \\\"passion from other animals, which is a lust of the mind, that by a \\\"\\n        \\\"perseverance of delight in the continued and indefatigable generation \\\"\\n        \\\"of knowledge, exceeds the short vehemence of any carnal pleasure.\\\";\\n\\n    base64_str = ciphers::base64_encoding::base64_encode(str);\\n    verify =\\n        \\\"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieS\\\"\\n        \\\"B0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBh\\\"\\n        \\\"IGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodC\\\"\\n        \\\"BpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25v\\\"\\n        \\\"d2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbG\\\"\\n        \\\"Vhc3VyZS4=\\\";\\n    // verify encoding\\n    assert(base64_str == verify);\\n    original_str = ciphers::base64_encoding::base64_decode(base64_str);\\n    // verify decoding\\n    assert(original_str == str);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "caesar cipher": "\"/**\\n * @file caesar_cipher.cpp\\n * @brief Implementation of [Caesar cipher](https://en.wikipedia.org/wiki/Caesar_cipher) algorithm.\\n *\\n * @details\\n * In cryptography, a Caesar cipher, also known as Caesar's cipher, the shift cipher, \\n * Caesar's code or Caesar shift, is one of the simplest and most widely known encryption \\n * techniques. It is a type of substitution cipher in which each letter in the plaintext \\n * is replaced by a letter some fixed number of positions down the alphabet. For example, \\n * with a left shift of 3, D would be replaced by A, E would become B, and so on. \\n * The method is named after Julius Caesar, who used it in his private correspondence.\\n *\\n * ### Algorithm\\n * The encryption can also be represented using modular arithmetic by first transforming \\n * the letters into numbers, according to the scheme, A → 0, B → 1, ..., Z → 25.\\n * Encryption of a letter x by a shift n can be described mathematically as,\\n * \\\\f[ E(x) = (x + n)\\\\;\\\\mbox{mod}\\\\; 26\\\\f]\\n * while decryption can be described as,\\n * \\\\f[ D(x) = (x - n) \\\\;\\\\mbox{mod}\\\\; 26\\\\f]\\n * \\n * \\\\note This program implements caesar cipher for only uppercase English alphabet characters (i.e. A-Z). \\n * \\n * @author [Deep Raval](https://github.com/imdeep2905)\\n */\\n#include <iostream>\\n#include <string>\\n#include <cassert>\\n\\n/** \\\\namespace ciphers\\n * \\\\brief Algorithms for encryption and decryption\\n */\\nnamespace ciphers {\\n    /** \\\\namespace caesar\\n     * \\\\brief Functions for [Caesar cipher](https://en.wikipedia.org/wiki/Caesar_cipher) algorithm.\\n     */\\n    namespace caesar {   \\n        namespace {\\n            /**\\n             * This function finds character for given value (i.e.A-Z)\\n             * @param x value for which we want character \\n             * @returns  corresponding character for perticular value\\n             */        \\n            inline char get_char(const int x) {\\n                // By adding 65 we are scaling 0-25 to 65-90. \\n                // Which are in fact ASCII values of A-Z. \\n                return char(x + 65); \\n            }\\n            /**\\n             * This function finds value for given character (i.e.0-25)\\n             * @param c character for which we want value\\n             * @returns returns corresponding value for perticular character\\n             */  \\n            inline int get_value(const char c) {\\n                // A-Z have ASCII values in range 65-90.\\n                // Hence subtracting 65 will scale them to 0-25.\\n                return int(c - 65);\\n            }\\n        } // Unnamed namespace\\n        /**\\n         * Encrypt given text using caesar cipher.\\n         * @param text text to be encrypted\\n         * @param shift number of shifts to be applied\\n         * @returns new encrypted text\\n         */\\n        std::string encrypt (const std::string &text, const int &shift) {\\n            std::string encrypted_text = \\\"\\\"; // Empty string to store encrypted text\\n            for (char c : text) { // Going through each character\\n                int place_value = get_value(c); // Getting value of character (i.e. 0-25)\\n                place_value = (place_value + shift) % 26; // Applying encryption formula\\n                char new_char = get_char(place_value); // Getting new character from new value (i.e. A-Z)\\n                encrypted_text += new_char; // Appending encrypted character\\n            }\\n            return encrypted_text; // Returning encrypted text\\n        }\\n        /**\\n         * Decrypt given text using caesar cipher.\\n         * @param text text to be decrypted\\n         * @param shift number of shifts to be applied\\n         * @returns new decrypted text\\n         */        \\n        std::string decrypt (const std::string &text, const int &shift) {\\n            std::string decrypted_text = \\\"\\\"; // Empty string to store decrypted text\\n            for (char c : text) { // Going through each character\\n                int place_value = get_value(c); // Getting value of character (i.e. 0-25)\\n                place_value = (place_value - shift) % 26;// Applying decryption formula\\n                if(place_value < 0) { // Handling case where remainder is negative \\n                    place_value = place_value + 26;\\n                }\\n                char new_char = get_char(place_value); // Getting original character from decrypted value (i.e. A-Z)\\n                decrypted_text += new_char; // Appending decrypted character\\n            }\\n            return decrypted_text; // Returning decrypted text\\n        }\\n    } // namespace caesar\\n} // namespace ciphers\\n\\n/**\\n * Function to test above algorithm\\n */\\nvoid test() {\\n    // Test 1\\n    std::string text1 = \\\"ALANTURING\\\";\\n    std::string encrypted1 = ciphers::caesar::encrypt(text1, 17);\\n    std::string decrypted1 = ciphers::caesar::decrypt(encrypted1, 17);\\n    assert(text1 == decrypted1);\\n    std::cout << \\\"Original text : \\\" << text1;\\n    std::cout << \\\" , Encrypted text (with shift = 21) : \\\" << encrypted1;\\n    std::cout << \\\" , Decrypted text : \\\"<< decrypted1 << std::endl;\\n    // Test 2\\n    std::string text2 = \\\"HELLOWORLD\\\";\\n    std::string encrypted2 = ciphers::caesar::encrypt(text2, 1729);\\n    std::string decrypted2 = ciphers::caesar::decrypt(encrypted2, 1729);\\n    assert(text2 == decrypted2);\\n    std::cout << \\\"Original text : \\\" << text2;\\n    std::cout << \\\" , Encrypted text (with shift = 1729) : \\\" << encrypted2;\\n    std::cout << \\\" , Decrypted text : \\\"<< decrypted2 << std::endl;\\n}\\n\\n/** Driver Code */\\nint main() {\\n    // Testing\\n    test();\\n    return 0;\\n}\\n\"",
    "elliptic curve key exchange": "\"/**\\n * @file\\n * @brief Implementation of [Elliptic Curve Diffie Hellman Key\\n * Exchange](https://cryptobook.nakov.com/asymmetric-key-ciphers/ecdh-key-exchange).\\n *\\n * @details\\n * The ECDH (Elliptic Curve Diffie–Hellman Key Exchange) is anonymous key\\n * agreement scheme, which allows two parties, each having an elliptic-curve\\n * public–private key pair, to establish a shared secret over an insecure\\n * channel.\\n * ECDH is very similar to the classical DHKE (Diffie–Hellman Key Exchange)\\n * algorithm, but it uses ECC point multiplication instead of modular\\n * exponentiations. ECDH is based on the following property of EC points:\\n * (a * G) * b = (b * G) * a\\n * If we have two secret numbers a and b (two private keys, belonging to Alice\\n * and Bob) and an ECC elliptic curve with generator point G, we can exchange\\n * over an insecure channel the values (a * G) and (b * G) (the public keys of\\n * Alice and Bob) and then we can derive a shared secret:\\n * secret = (a * G) * b = (b * G) * a.\\n * Pretty simple. The above equation takes the following form:\\n * alicePubKey * bobPrivKey = bobPubKey * alicePrivKey = secret\\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\\n */\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n\\n#include \\\"uint256_t.hpp\\\"  /// for 256-bit integer\\n\\n/**\\n * @namespace ciphers\\n * @brief Cipher algorithms\\n */\\nnamespace ciphers {\\n/**\\n * @brief namespace elliptic_curve_key_exchange\\n * @details Demonstration of [Elliptic Curve\\n * Diffie-Hellman](https://cryptobook.nakov.com/asymmetric-key-ciphers/ecdh-key-exchange)\\n * key exchange.\\n */\\nnamespace elliptic_curve_key_exchange {\\n\\n/**\\n * @brief Definition of struct Point\\n * @details Definition of Point in the curve.\\n */\\ntypedef struct Point {\\n    uint256_t x, y;  /// x and y co-ordinates\\n\\n    /**\\n     * @brief operator == for Point\\n     * @details check whether co-ordinates are equal to the given point\\n     * @param p given point to be checked with this\\n     * @returns true if x and y are both equal with Point p, else false\\n     */\\n    inline bool operator==(const Point &p) { return x == p.x && y == p.y; }\\n\\n    /**\\n     * @brief ostream operator for printing Point\\n     * @param op ostream operator\\n     * @param p Point to be printed on console\\n     * @returns op, the ostream object\\n     */\\n    friend std::ostream &operator<<(std::ostream &op, const Point &p) {\\n        op << p.x << \\\" \\\" << p.y;\\n        return op;\\n    }\\n} Point;\\n\\n/**\\n * @brief This function calculates number raised to exponent power under modulo\\n * mod using [Modular\\n * Exponentiation](https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_exponentiation.cpp).\\n * @param number integer base\\n * @param power unsigned integer exponent\\n * @param mod integer modulo\\n * @return number raised to power modulo mod\\n */\\nuint256_t exp(uint256_t number, uint256_t power, const uint256_t &mod) {\\n    if (!power) {\\n        return uint256_t(1);\\n    }\\n    uint256_t ans(1);\\n    number = number % mod;\\n    while (power) {\\n        if ((power & 1)) {\\n            ans = (ans * number) % mod;\\n        }\\n        power >>= 1;\\n        if (power) {\\n            number = (number * number) % mod;\\n        }\\n    }\\n    return ans;\\n}\\n\\n/**\\n * @brief Addition of points\\n * @details Add given point to generate third point. More description can be\\n * found\\n * [here](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Point_addition),\\n * and\\n * [here](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Point_doubling)\\n * @param a First point\\n * @param b Second point\\n * @param curve_a_coeff Coefficient `a` of the given curve (y^2 = x^3 + ax + b)\\n * % mod\\n * @param mod Given field\\n * @return the resultant point\\n */\\nPoint addition(Point a, Point b, const uint256_t &curve_a_coeff,\\n               uint256_t mod) {\\n    uint256_t lambda(0);  /// Slope\\n    uint256_t zero(0);    /// value zero\\n    lambda = zero = 0;\\n    uint256_t inf = ~zero;\\n    if (a.x != b.x || a.y != b.y) {\\n        // Slope being infinite.\\n        if (b.x == a.x) {\\n            return {inf, inf};\\n        }\\n        uint256_t num = (b.y - a.y + mod), den = (b.x - a.x + mod);\\n        lambda = (num * (exp(den, mod - 2, mod))) % mod;\\n    } else {\\n        /**\\n         *  slope when the line is tangent to curve. This operation is performed\\n         * while doubling. Taking derivative of `y^2 = x^3 + ax + b`\\n         * => `2y dy = (3 * x^2 + a)dx`\\n         * => `(dy/dx) = (3x^2 + a)/(2y)`\\n         */\\n        /**\\n         * if y co-ordinate is zero, the slope is infinite, return inf.\\n         * else calculate the slope (here % mod and store in lambda)\\n         */\\n        if (!a.y) {\\n            return {inf, inf};\\n        }\\n        uint256_t axsq = ((a.x * a.x)) % mod;\\n        // Mulitply by 3 adjustment\\n        axsq += (axsq << 1);\\n        axsq %= mod;\\n        // Mulitply by 2 adjustment\\n        uint256_t a_2 = (a.y << 1);\\n        lambda =\\n            (((axsq + curve_a_coeff) % mod) * exp(a_2, mod - 2, mod)) % mod;\\n    }\\n    Point c;\\n    // new point: x = ((lambda^2) - x1 - x2)\\n    // y = (lambda * (x1 - x)) - y1\\n    c.x = ((lambda * lambda) % mod + (mod << 1) - a.x - b.x) % mod;\\n    c.y = (((lambda * (a.x + mod - c.x)) % mod) + mod - a.y) % mod;\\n    return c;\\n}\\n\\n/**\\n * @brief multiply Point and integer\\n * @details Multiply Point by a scalar factor (here it is a private key p). The\\n * multiplication is called as [double and add\\n * method](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Double-and-add)\\n * @param a Point to multiply\\n * @param curve_a_coeff Coefficient of given curve (y^2 = x^3 + ax + b) % mod\\n * @param p The scalar value\\n * @param mod Given field\\n * @returns the resultant point\\n */\\nPoint multiply(const Point &a, const uint256_t &curve_a_coeff, uint256_t p,\\n               const uint256_t &mod) {\\n    Point N = a;\\n    N.x %= mod;\\n    N.y %= mod;\\n    uint256_t inf{};\\n    inf = ~uint256_t(0);\\n    Point Q = {inf, inf};\\n    while (p) {\\n        if ((p & 1)) {\\n            if (Q.x == inf && Q.y == inf) {\\n                Q.x = N.x;\\n                Q.y = N.y;\\n            } else {\\n                Q = addition(Q, N, curve_a_coeff, mod);\\n            }\\n        }\\n        p >>= 1;\\n        if (p) {\\n            N = addition(N, N, curve_a_coeff, mod);\\n        }\\n    }\\n    return Q;\\n}\\n}  // namespace elliptic_curve_key_exchange\\n}  // namespace ciphers\\n\\n/**\\n * @brief Function to test the\\n * uint128_t header\\n * @returns void\\n */\\nstatic void uint128_t_tests() {\\n    // 1st test: Operations test\\n    uint128_t a(\\\"122\\\"), b(\\\"2312\\\");\\n    assert(a + b == 2434);\\n    assert(b - a == 2190);\\n    assert(a * b == 282064);\\n    assert(b / a == 18);\\n    assert(b % a == 116);\\n    assert((a & b) == 8);\\n    assert((a | b) == 2426);\\n    assert((a ^ b) == 2418);\\n    assert((a << 64) == uint128_t(\\\"2250502776992565297152\\\"));\\n    assert((b >> 7) == 18);\\n\\n    // 2nd test: Operations test\\n    a = uint128_t(\\\"12321421424232142122\\\");\\n    b = uint128_t(\\\"23123212\\\");\\n    assert(a + b == uint128_t(\\\"12321421424255265334\\\"));\\n    assert(a - b == uint128_t(\\\"12321421424209018910\\\"));\\n    assert(a * b == uint128_t(\\\"284910839733861759501135864\\\"));\\n    assert(a / b == 532859423865LL);\\n    assert(a % b == 3887742);\\n    assert((a & b) == 18912520);\\n    assert((a | b) == uint128_t(\\\"12321421424236352814\\\"));\\n    assert((a ^ b) == uint128_t(\\\"12321421424217440294\\\"));\\n    assert((a << 64) == uint128_t(\\\"227290107637132170748078080907806769152\\\"));\\n}\\n\\n/**\\n * @brief Function to test the\\n * uint256_t header\\n * @returns void\\n */\\nstatic void uint256_t_tests() {\\n    // 1st test: Operations test\\n    uint256_t a(\\\"122\\\"), b(\\\"2312\\\");\\n    assert(a + b == 2434);\\n    assert(b - a == 2190);\\n    assert(a * b == 282064);\\n    assert(b / a == 18);\\n    assert(b % a == 116);\\n    assert((a & b) == 8);\\n    assert((a | b) == 2426);\\n    assert((a ^ b) == 2418);\\n    assert((a << 64) == uint256_t(\\\"2250502776992565297152\\\"));\\n    assert((b >> 7) == 18);\\n\\n    // 2nd test: Operations test\\n    a = uint256_t(\\\"12321423124513251424232142122\\\");\\n    b = uint256_t(\\\"23124312431243243215354315132413213212\\\");\\n    assert(a + b == uint256_t(\\\"23124312443564666339867566556645355334\\\"));\\n    // Since a < b, the value is greater\\n    assert(a - b == uint256_t(\\\"115792089237316195423570985008687907853246860353\\\"\\n                              \\\"221642219366742944204948568846\\\"));\\n    assert(a * b == uint256_t(\\\"284924437928789743312147393953938013677909398222\\\"\\n                              \\\"169728183872115864\\\"));\\n    assert(b / a == uint256_t(\\\"1876756621\\\"));\\n    assert(b % a == uint256_t(\\\"2170491202688962563936723450\\\"));\\n    assert((a & b) == uint256_t(\\\"3553901085693256462344\\\"));\\n    assert((a | b) == uint256_t(\\\"23124312443564662785966480863388892990\\\"));\\n    assert((a ^ b) == uint256_t(\\\"23124312443564659232065395170132430646\\\"));\\n    assert((a << 128) == uint256_t(\\\"4192763024643754272961909047609369343091683\\\"\\n                                   \\\"376561852756163540549632\\\"));\\n}\\n\\n/**\\n * @brief Function to test the\\n * provided algorithm above\\n * @returns void\\n */\\nstatic void test() {\\n    // demonstration of key exchange using curve secp112r1\\n\\n    // Equation of the form y^2 = (x^3 + ax + b) % P (here p is mod)\\n    uint256_t a(\\\"4451685225093714772084598273548424\\\"),\\n        b(\\\"2061118396808653202902996166388514\\\"),\\n        mod(\\\"4451685225093714772084598273548427\\\");\\n\\n    // Generator value: is pre-defined for the given curve\\n    ciphers::elliptic_curve_key_exchange::Point ptr = {\\n        uint256_t(\\\"188281465057972534892223778713752\\\"),\\n        uint256_t(\\\"3419875491033170827167861896082688\\\")};\\n\\n    // Shared key generation.\\n    // For alice\\n    std::cout << \\\"For alice:\\\\n\\\";\\n    // Alice's private key (can be generated randomly)\\n    uint256_t alice_private_key(\\\"164330438812053169644452143505618\\\");\\n    ciphers::elliptic_curve_key_exchange::Point alice_public_key =\\n        multiply(ptr, a, alice_private_key, mod);\\n    std::cout << \\\"\\\\tPrivate key: \\\" << alice_private_key << \\\"\\\\n\\\";\\n    std::cout << \\\"\\\\tPublic Key: \\\" << alice_public_key << std::endl;\\n\\n    // For Bob\\n    std::cout << \\\"For Bob:\\\\n\\\";\\n    // Bob's private key (can be generated randomly)\\n    uint256_t bob_private_key(\\\"1959473333748537081510525763478373\\\");\\n    ciphers::elliptic_curve_key_exchange::Point bob_public_key =\\n        multiply(ptr, a, bob_private_key, mod);\\n    std::cout << \\\"\\\\tPrivate key: \\\" << bob_private_key << \\\"\\\\n\\\";\\n    std::cout << \\\"\\\\tPublic Key: \\\" << bob_public_key << std::endl;\\n\\n    // After public key exchange, create a shared key for communication.\\n    // create shared key:\\n    ciphers::elliptic_curve_key_exchange::Point alice_shared_key = multiply(\\n                                                    bob_public_key, a,\\n                                                    alice_private_key, mod),\\n                                                bob_shared_key = multiply(\\n                                                    alice_public_key, a,\\n                                                    bob_private_key, mod);\\n\\n    std::cout << \\\"Shared keys:\\\\n\\\";\\n    std::cout << alice_shared_key << std::endl;\\n    std::cout << bob_shared_key << std::endl;\\n\\n    // Check whether shared keys are equal\\n    assert(alice_shared_key == bob_shared_key);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    uint128_t_tests();  // running predefined 128-bit unsigned integer tests\\n    uint256_t_tests();  // running predefined 256-bit unsigned integer tests\\n    test();             // running self-test implementations\\n    return 0;\\n}\\n\"",
    "hill cipher": "\"/**\\n * @file hill_cipher.cpp\\n * @brief Implementation of [Hill\\n * cipher](https://en.wikipedia.org/wiki/Hill_cipher) algorithm.\\n *\\n * Program to generate the encryption-decryption key and perform encryption and\\n * decryption of ASCII text using the famous block cipher algorithm. This is a\\n * powerful encryption algorithm that is relatively easy to implement with a\\n * given key. The strength of the algorithm depends on the size of the block\\n * encryption matrix key; the bigger the matrix, the stronger the encryption and\\n * more difficult to break it. However, the important requirement for the matrix\\n * is that:\\n * 1. matrix should be invertible - all inversion conditions should be satisfied\\n * and\\n * 2. its determinant must not have any common factors with the length of\\n * character set\\n * Due to this restriction, most implementations only implement with small 3x3\\n * encryption keys and a small subset of ASCII alphabets.\\n *\\n * In the current implementation, I present to you an implementation for\\n * generating larger encryption keys (I have attempted upto 10x10) and an ASCII\\n * character set of 97 printable characters. Hence, a typical ASCII text file\\n * could be easily encrypted with the module. The larger character set increases\\n * the modulo of cipher and hence the matrix determinants can get very large\\n * very quickly rendering them ill-defined.\\n *\\n * \\\\note This program uses determinant computation using LU decomposition from\\n * the file lu_decomposition.h\\n * \\\\note The matrix generation algorithm is very rudimentary and does not\\n * guarantee an invertible modulus matrix. \\\\todo Better matrix generation\\n * algorithm.\\n *\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n */\\n\\n#include <cassert>\\n#include <cmath>\\n#include <cstring>\\n#include <ctime>\\n#include <fstream>\\n#include <iomanip>\\n#include <iostream>\\n#include <string>\\n#ifdef _OPENMP\\n#include <omp.h>\\n#endif\\n\\n#include \\\"../numerical_methods/lu_decomposition.h\\\"\\n\\n/**\\n * operator to print a matrix\\n */\\ntemplate <typename T>\\nstatic std::ostream &operator<<(std::ostream &out, matrix<T> const &v) {\\n    const int width = 15;\\n    const char separator = ' ';\\n\\n    for (size_t row = 0; row < v.size(); row++) {\\n        for (size_t col = 0; col < v[row].size(); col++)\\n            out << std::left << std::setw(width) << std::setfill(separator)\\n                << v[row][col];\\n        out << std::endl;\\n    }\\n\\n    return out;\\n}\\n\\n/** \\\\namespace ciphers\\n * \\\\brief Algorithms for encryption and decryption\\n */\\nnamespace ciphers {\\n/** dictionary of characters that can be encrypted and decrypted */\\nstatic const char *STRKEY =\\n    \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&\\\"\\n    \\\"*()_+`-=[]{}|;':\\\\\\\",./<>?\\\\\\\\\\\\r\\\\n \\\\0\\\";\\n\\n/**\\n * @brief Implementation of [Hill\\n * Cipher](https://en.wikipedia.org/wiki/Hill_cipher) algorithm\\n */\\nclass HillCipher {\\n private:\\n    /**\\n     * @brief Function to generate a random integer in a given interval\\n     *\\n     * @param a lower limit of interval\\n     * @param b upper limit of interval\\n     * @tparam T type of output\\n     * @return random integer in the interval \\\\f$[a,b)\\\\f$\\n     */\\n    template <typename T1, typename T2>\\n    static const T2 rand_range(T1 a, T1 b) {\\n        // generate random number between 0 and 1\\n        long double r = static_cast<long double>(std::rand()) / RAND_MAX;\\n\\n        // scale and return random number as integer\\n        return static_cast<T2>(r * (b - a) + a);\\n    }\\n\\n    /**\\n     * @brief Function overload to fill a matrix with random integers in a given\\n     * interval\\n     *\\n     * @param M pointer to matrix to be filled with random numbers\\n     * @param a lower limit of interval\\n     * @param b upper limit of interval\\n     * @tparam T1 type of input range\\n     * @tparam T2 type of matrix\\n     * @return determinant of generated random matrix\\n     *\\n     * @warning There will need to be a balance between the matrix size and the\\n     * range of random numbers. If the matrix is large, the range of random\\n     * numbers must be small to have a well defined keys. Or if the matrix is\\n     * smaller, the random numbers range can be larger. For an 8x8 matrix, range\\n     * should be no more than \\\\f$[0,10]\\\\f$\\n     */\\n    template <typename T1, typename T2>\\n    static double rand_range(matrix<T2> *M, T1 a, T1 b) {\\n        for (size_t i = 0; i < M->size(); i++) {\\n            for (size_t j = 0; j < M[0][0].size(); j++) {\\n                M[0][i][j] = rand_range<T1, T2>(a, b);\\n            }\\n        }\\n\\n        return determinant_lu(*M);\\n    }\\n\\n    /**\\n     * @brief Compute\\n     * [GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor) of two\\n     * integers using Euler's algorithm\\n     *\\n     * @param a first number\\n     * @param b second number\\n     * @return GCD of \\\\f$a\\\\f$ and \\\\f$b\\\\f$\\n     */\\n    template <typename T>\\n    static const T gcd(T a, T b) {\\n        if (b > a)  // ensure always a < b\\n            std::swap(a, b);\\n\\n        while (b != 0) {\\n            T tmp = b;\\n            b = a % b;\\n            a = tmp;\\n        }\\n\\n        return a;\\n    }\\n\\n    /**\\n     * @brief helper function to perform vector multiplication with encryption\\n     * or decryption matrix\\n     *\\n     * @param vector vector to multiply\\n     * @param key encryption or decryption key matrix\\n     * @return corresponding encrypted or decrypted text\\n     */\\n    static const std::valarray<uint8_t> mat_mul(\\n        const std::valarray<uint8_t> &vector, const matrix<int> &key) {\\n        std::valarray<uint8_t> out(vector);  // make a copy\\n\\n        size_t L = std::strlen(STRKEY);\\n\\n        for (size_t i = 0; i < key.size(); i++) {\\n            int tmp = 0;\\n            for (size_t j = 0; j < vector.size(); j++) {\\n                tmp += key[i][j] * vector[j];\\n            }\\n            out[i] = static_cast<uint8_t>(tmp % L);\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * @brief Get the character at a given index in the ::STRKEY\\n     *\\n     * @param idx index value\\n     * @return character at the index\\n     */\\n    static inline char get_idx_char(const uint8_t idx) { return STRKEY[idx]; }\\n\\n    /**\\n     * @brief Get the index of a character in the ::STRKEY\\n     *\\n     * @param ch character to search\\n     * @return index of character\\n     */\\n    static inline uint8_t get_char_idx(const char ch) {\\n        size_t L = std::strlen(STRKEY);\\n\\n        for (size_t idx = 0; idx <= L; idx++)\\n            if (STRKEY[idx] == ch)\\n                return idx;\\n\\n        std::cerr << __func__ << \\\":\\\" << __LINE__ << \\\": (\\\" << ch\\n                  << \\\") Should not reach here!\\\\n\\\";\\n        return 0;\\n    }\\n\\n    /**\\n     * @brief Convenience function to perform block cipher operations. The\\n     * operations are identical for both encryption and decryption.\\n     *\\n     * @param text input text to encrypt or decrypt\\n     * @param key key for encryption or decryption\\n     * @return encrypted/decrypted output\\n     */\\n    static const std::string codec(const std::string &text,\\n                                   const matrix<int> &key) {\\n        size_t text_len = text.length();\\n        size_t key_len = key.size();\\n\\n        // length of output string must be a multiple of key_len\\n        // create output string and initialize with '\\\\0' character\\n        size_t L2 = text_len % key_len == 0\\n                        ? text_len\\n                        : text_len + key_len - (text_len % key_len);\\n        std::string coded_text(L2, '\\\\0');\\n\\n        // temporary array for batch processing\\n        int i;\\n#ifdef _OPENMP\\n#pragma parallel omp for private(i)\\n#endif\\n        for (i = 0; i < L2 - key_len + 1; i += key_len) {\\n            std::valarray<uint8_t> batch_int(key_len);\\n            for (size_t j = 0; j < key_len; j++) {\\n                batch_int[j] = get_char_idx(text[i + j]);\\n            }\\n\\n            batch_int = mat_mul(batch_int, key);\\n\\n            for (size_t j = 0; j < key_len; j++) {\\n                coded_text[i + j] =\\n                    STRKEY[batch_int[j]];  // get character at key\\n            }\\n        }\\n\\n        return coded_text;\\n    }\\n\\n    /**\\n     * Get matrix inverse using Row-transformations. Given matrix must\\n     * be a square and non-singular.\\n     * \\\\returns inverse matrix\\n     **/\\n    template <typename T>\\n    static matrix<double> get_inverse(matrix<T> const &A) {\\n        // Assuming A is square matrix\\n        size_t N = A.size();\\n\\n        matrix<double> inverse(N, std::valarray<double>(N));\\n        for (size_t row = 0; row < N; row++) {\\n            for (size_t col = 0; col < N; col++) {\\n                // create identity matrix\\n                inverse[row][col] = (row == col) ? 1.f : 0.f;\\n            }\\n        }\\n\\n        if (A.size() != A[0].size()) {\\n            std::cerr << \\\"A must be a square matrix!\\\" << std::endl;\\n            return inverse;\\n        }\\n\\n        // preallocate a temporary matrix identical to A\\n        matrix<double> temp(N, std::valarray<double>(N));\\n        for (size_t row = 0; row < N; row++) {\\n            for (size_t col = 0; col < N; col++)\\n                temp[row][col] = static_cast<double>(A[row][col]);\\n        }\\n\\n        // start transformations\\n        for (size_t row = 0; row < N; row++) {\\n            for (size_t row2 = row; row2 < N && temp[row][row] == 0; row2++) {\\n                // this to ensure diagonal elements are not 0\\n                temp[row] = temp[row] + temp[row2];\\n                inverse[row] = inverse[row] + inverse[row2];\\n            }\\n\\n            for (size_t col2 = row; col2 < N && temp[row][row] == 0; col2++) {\\n                // this to further ensure diagonal elements are not 0\\n                for (size_t row2 = 0; row2 < N; row2++) {\\n                    temp[row2][row] = temp[row2][row] + temp[row2][col2];\\n                    inverse[row2][row] =\\n                        inverse[row2][row] + inverse[row2][col2];\\n                }\\n            }\\n\\n            if (temp[row][row] == 0) {\\n                // Probably a low-rank matrix and hence singular\\n                std::cerr << \\\"Low-rank matrix, no inverse!\\\" << std::endl;\\n                return inverse;\\n            }\\n\\n            // set diagonal to 1\\n            double divisor = temp[row][row];\\n            temp[row] = temp[row] / divisor;\\n            inverse[row] = inverse[row] / divisor;\\n            // Row transformations\\n            for (size_t row2 = 0; row2 < N; row2++) {\\n                if (row2 == row)\\n                    continue;\\n                double factor = temp[row2][row];\\n                temp[row2] = temp[row2] - factor * temp[row];\\n                inverse[row2] = inverse[row2] - factor * inverse[row];\\n            }\\n        }\\n\\n        return inverse;\\n    }\\n\\n    static int modulo(int a, int b) {\\n        int ret = a % b;\\n        if (ret < 0)\\n            ret += b;\\n        return ret;\\n    }\\n\\n public:\\n    /**\\n     * @brief Generate encryption matrix of a given size. Larger size matrices\\n     * are difficult to generate but provide more security. Important conditions\\n     * are:\\n     * 1. matrix should be invertible\\n     * 2. determinant must not have any common factors with the length of\\n     * character key\\n     * There is no head-fast way to generate hte matrix under the given\\n     * numerical restrictions of the machine but the conditions added achieve\\n     * the goals. Bigger the matrix, greater is the probability of the matrix\\n     * being ill-defined.\\n     *\\n     * @param size size of matrix (typically \\\\f$\\\\text{size}\\\\le10\\\\f$)\\n     * @param limit1 lower limit of range of random elements (default=0)\\n     * @param limit2 upper limit of range of random elements (default=10)\\n     * @return Encryption martix\\n     */\\n    static matrix<int> generate_encryption_key(size_t size, int limit1 = 0,\\n                                               int limit2 = 10) {\\n        matrix<int> encrypt_key(size, std::valarray<int>(size));\\n        matrix<int> min_mat = encrypt_key;\\n        int mat_determinant = -1;  // because matrix has only ints, the\\n                                   // determinant will also be an int\\n        int L = std::strlen(STRKEY);\\n\\n        double dd;\\n        do {\\n            // keeping the random number range smaller generates better\\n            // defined matrices with more ease of cracking\\n            dd = rand_range(&encrypt_key, limit1, limit2);\\n            mat_determinant = static_cast<int>(dd);\\n\\n            if (mat_determinant < 0)\\n                mat_determinant = (mat_determinant % L);\\n        } while (std::abs(dd) > 1e3 ||  // while ill-defined\\n                 dd < 0.1 ||  // while singular or negative determinant\\n                 !std::isfinite(dd) ||  // while determinant is not finite\\n                 gcd(mat_determinant, L) != 1);  // while no common factors\\n        // std::cout <<\\n\\n        return encrypt_key;\\n    }\\n\\n    /**\\n     * @brief Generate decryption matrix from an encryption matrix key.\\n     *\\n     * @param encrypt_key encryption key for which to create a decrypt key\\n     * @return Decryption martix\\n     */\\n    static matrix<int> generate_decryption_key(matrix<int> const &encrypt_key) {\\n        size_t size = encrypt_key.size();\\n        int L = std::strlen(STRKEY);\\n\\n        matrix<int> decrypt_key(size, std::valarray<int>(size));\\n        int det_encrypt = static_cast<int>(determinant_lu(encrypt_key));\\n\\n        int mat_determinant = det_encrypt < 0 ? det_encrypt % L : det_encrypt;\\n\\n        matrix<double> tmp_inverse = get_inverse(encrypt_key);\\n        double d2 = determinant_lu(decrypt_key);\\n\\n        // find co-prime factor for inversion\\n        int det_inv = -1;\\n        for (int i = 0; i < L; i++) {\\n            if (modulo(mat_determinant * i, L) == 1) {\\n                det_inv = i;\\n                break;\\n            }\\n        }\\n\\n        if (det_inv == -1) {\\n            std::cerr << \\\"Could not find a co-prime for inversion\\\\n\\\";\\n            std::exit(EXIT_FAILURE);\\n        }\\n\\n        mat_determinant = det_inv * det_encrypt;\\n\\n        // perform modular inverse of encryption matrix\\n        int i;\\n#ifdef _OPENMP\\n#pragma parallel omp for private(i)\\n#endif\\n        for (i = 0; i < size; i++) {\\n            for (int j = 0; j < size; j++) {\\n                int temp = std::round(tmp_inverse[i][j] * mat_determinant);\\n                decrypt_key[i][j] = modulo(temp, L);\\n            }\\n        }\\n        return decrypt_key;\\n    }\\n\\n    /**\\n     * @brief Generate encryption and decryption key pair\\n     *\\n     * @param size size of matrix key (typically \\\\f$\\\\text{size}\\\\le10\\\\f$)\\n     * @param limit1 lower limit of range of random elements (default=0)\\n     * @param limit2 upper limit of range of random elements (default=10)\\n     * @return std::pair<matrix<int>, matrix<int>> encryption and decryption\\n     * keys as a pair\\n     *\\n     * @see ::generate_encryption_key\\n     */\\n    static std::pair<matrix<int>, matrix<int>> generate_keys(size_t size,\\n                                                             int limit1 = 0,\\n                                                             int limit2 = 10) {\\n        matrix<int> encrypt_key = generate_encryption_key(size);\\n        matrix<int> decrypt_key = generate_decryption_key(encrypt_key);\\n        double det2 = determinant_lu(decrypt_key);\\n        while (std::abs(det2) < 0.1 || std::abs(det2) > 1e3) {\\n            encrypt_key = generate_encryption_key(size, limit1, limit2);\\n            decrypt_key = generate_decryption_key(encrypt_key);\\n            det2 = determinant_lu(decrypt_key);\\n        }\\n        return std::make_pair(encrypt_key, decrypt_key);\\n    }\\n\\n    /**\\n     * @brief Encrypt a given text using a given key\\n     *\\n     * @param text string to encrypt\\n     * @param encrypt_key  key for encryption\\n     * @return encrypted text\\n     */\\n    static const std::string encrypt_text(const std::string &text,\\n                                          const matrix<int> &encrypt_key) {\\n        return codec(text, encrypt_key);\\n    }\\n\\n    /**\\n     * @brief Decrypt a given text using a given key\\n     *\\n     * @param text string to decrypt\\n     * @param decrypt_key  key for decryption\\n     * @return decrypted text\\n     */\\n    static const std::string decrypt_text(const std::string &text,\\n                                          const matrix<int> &decrypt_key) {\\n        return codec(text, decrypt_key);\\n    }\\n};\\n\\n}  // namespace ciphers\\n\\n/**\\n * @brief Self test 1 - using 3x3 randomly generated key\\n *\\n * @param text string to encrypt and decrypt\\n */\\nvoid test1(const std::string &text) {\\n    // std::string text = \\\"Hello world!\\\";\\n    std::cout << \\\"======Test 1 (3x3 key) ======\\\\nOriginal text:\\\\n\\\\t\\\" << text\\n              << std::endl;\\n\\n    std::pair<matrix<int>, matrix<int>> p =\\n        ciphers::HillCipher::generate_keys(3, 0, 100);\\n    matrix<int> ekey = p.first;\\n    matrix<int> dkey = p.second;\\n\\n    // matrix<int> ekey = {{22, 28, 25}, {5, 26, 15}, {14, 18, 9}};\\n    // std::cout << \\\"Encryption key: \\\\n\\\" << ekey;\\n    std::string gibberish = ciphers::HillCipher::encrypt_text(text, ekey);\\n    std::cout << \\\"Encrypted text:\\\\n\\\\t\\\" << gibberish << std::endl;\\n\\n    // matrix<int> dkey = ciphers::HillCipher::generate_decryption_key(ekey);\\n    // std::cout << \\\"Decryption key: \\\\n\\\" << dkey;\\n    std::string txt_back = ciphers::HillCipher::decrypt_text(gibberish, dkey);\\n    std::cout << \\\"Reconstruct text:\\\\n\\\\t\\\" << txt_back << std::endl;\\n\\n    std::ofstream out_file(\\\"hill_cipher_test1.txt\\\");\\n    out_file << \\\"Block size: \\\" << ekey.size() << \\\"\\\\n\\\";\\n    out_file << \\\"Encryption Key:\\\\n\\\" << ekey;\\n    out_file << \\\"\\\\nDecryption Key:\\\\n\\\" << dkey;\\n    out_file.close();\\n\\n    assert(txt_back == text);\\n    std::cout << \\\"Passed :)\\\\n\\\";\\n}\\n\\n/**\\n * @brief Self test 2 - using 8x8 randomly generated key\\n *\\n * @param text string to encrypt and decrypt\\n */\\nvoid test2(const std::string &text) {\\n    // std::string text = \\\"Hello world!\\\";\\n    std::cout << \\\"======Test 2 (8x8 key) ======\\\\nOriginal text:\\\\n\\\\t\\\" << text\\n              << std::endl;\\n\\n    std::pair<matrix<int>, matrix<int>> p =\\n        ciphers::HillCipher::generate_keys(8, 0, 3);\\n    matrix<int> ekey = p.first;\\n    matrix<int> dkey = p.second;\\n\\n    std::string gibberish = ciphers::HillCipher::encrypt_text(text, ekey);\\n    std::cout << \\\"Encrypted text:\\\\n\\\\t\\\" << gibberish << std::endl;\\n\\n    std::string txt_back = ciphers::HillCipher::decrypt_text(gibberish, dkey);\\n    std::cout << \\\"Reconstruct text:\\\\n\\\\t\\\" << txt_back << std::endl;\\n\\n    std::ofstream out_file(\\\"hill_cipher_test2.txt\\\");\\n    out_file << \\\"Block size: \\\" << ekey.size() << \\\"\\\\n\\\";\\n    out_file << \\\"Encryption Key:\\\\n\\\" << ekey;\\n    out_file << \\\"\\\\nDecryption Key:\\\\n\\\" << dkey;\\n    out_file.close();\\n\\n    assert(txt_back.compare(0, text.size(), text) == 0);\\n    std::cout << \\\"Passed :)\\\\n\\\";\\n}\\n\\n/** Main function */\\nint main() {\\n    std::srand(std::time(nullptr));\\n    std::cout << \\\"Key dictionary: (\\\" << std::strlen(ciphers::STRKEY) << \\\")\\\\n\\\\t\\\"\\n              << ciphers::STRKEY << \\\"\\\\n\\\";\\n\\n    std::string text = \\\"This is a simple text with numb3r5 and exclamat!0n.\\\";\\n\\n    test1(text);\\n    test2(text);\\n\\n    return 0;\\n}\\n\"",
    "morse code": "\"/**\\n * @file\\n * @author [Deep Raval](https://github.com/imdeep2905)\\n *\\n * @brief Implementation of [Morse Code]\\n * (https://en.wikipedia.org/wiki/Morse_code).\\n *\\n * @details\\n * Morse code is a method used in telecommunication to encode text characters\\n * as standardized sequences of two different signal durations, called dots\\n * and dashes or dits and dahs. Morse code is named after Samuel Morse, an\\n * inventor of the telegraph.\\n */\\n#include <cassert>\\n#include <iostream>\\n#include <string>\\n#include <vector>\\n\\n/** \\\\namespace ciphers\\n * \\\\brief Algorithms for encryption and decryption\\n */\\nnamespace ciphers {\\n/** \\\\namespace morse\\n * \\\\brief Functions for [Morse Code]\\n * (https://en.wikipedia.org/wiki/Morse_code).\\n */\\nnamespace morse {\\n/**\\n * Get the morse representation for given character.\\n * @param c Character\\n * @returns morse representation string of character\\n */\\nstd::string char_to_morse(const char &c) {\\n    // return corresponding morse code\\n    switch (c) {\\n        case 'a':\\n            return \\\".-\\\";\\n        case 'b':\\n            return \\\"-...\\\";\\n        case 'c':\\n            return \\\"-.-.\\\";\\n        case 'd':\\n            return \\\"-..\\\";\\n        case 'e':\\n            return \\\".\\\";\\n        case 'f':\\n            return \\\"..-.\\\";\\n        case 'g':\\n            return \\\"--.\\\";\\n        case 'h':\\n            return \\\"....\\\";\\n        case 'i':\\n            return \\\"..\\\";\\n        case 'j':\\n            return \\\".---\\\";\\n        case 'k':\\n            return \\\"-.-\\\";\\n        case 'l':\\n            return \\\".-..\\\";\\n        case 'm':\\n            return \\\"--\\\";\\n        case 'n':\\n            return \\\"-.\\\";\\n        case 'o':\\n            return \\\"---\\\";\\n        case 'p':\\n            return \\\".--.\\\";\\n        case 'q':\\n            return \\\"--.-\\\";\\n        case 'r':\\n            return \\\".-.\\\";\\n        case 's':\\n            return \\\"...\\\";\\n        case 't':\\n            return \\\"-\\\";\\n        case 'u':\\n            return \\\"..-\\\";\\n        case 'v':\\n            return \\\"...-\\\";\\n        case 'w':\\n            return \\\".--\\\";\\n        case 'x':\\n            return \\\"-..-\\\";\\n        case 'y':\\n            return \\\"-.--\\\";\\n        case 'z':\\n            return \\\"--..\\\";\\n        case '1':\\n            return \\\".----\\\";\\n        case '2':\\n            return \\\"..---\\\";\\n        case '3':\\n            return \\\"...--\\\";\\n        case '4':\\n            return \\\"....-\\\";\\n        case '5':\\n            return \\\".....\\\";\\n        case '6':\\n            return \\\"-....\\\";\\n        case '7':\\n            return \\\"--...\\\";\\n        case '8':\\n            return \\\"---..\\\";\\n        case '9':\\n            return \\\"----.\\\";\\n        case '0':\\n            return \\\"-----\\\";\\n        default:\\n            std::cerr << \\\"Found invalid character: \\\" << c << ' ' << std::endl;\\n            std::exit(0);\\n    }\\n}\\n/**\\n * Get character from the morse representation.\\n * @param s Morse representation\\n * @returns corresponding character\\n */\\nchar morse_to_char(const std::string &s) {\\n    // return corresponding character\\n    if (s == \\\".-\\\") {\\n        return 'a';\\n    } else if (s == \\\"-...\\\") {\\n        return 'b';\\n    } else if (s == \\\"-.-.\\\") {\\n        return 'c';\\n    } else if (s == \\\"-..\\\") {\\n        return 'd';\\n    } else if (s == \\\".\\\") {\\n        return 'e';\\n    } else if (s == \\\"..-.\\\") {\\n        return 'f';\\n    } else if (s == \\\"--.\\\") {\\n        return 'g';\\n    } else if (s == \\\"....\\\") {\\n        return 'h';\\n    } else if (s == \\\"..\\\") {\\n        return 'i';\\n    } else if (s == \\\".---\\\") {\\n        return 'j';\\n    } else if (s == \\\"-.-\\\") {\\n        return 'k';\\n    } else if (s == \\\".-..\\\") {\\n        return 'l';\\n    } else if (s == \\\"--\\\") {\\n        return 'm';\\n    } else if (s == \\\"-.\\\") {\\n        return 'n';\\n    } else if (s == \\\"---\\\") {\\n        return 'o';\\n    } else if (s == \\\".--.\\\") {\\n        return 'p';\\n    } else if (s == \\\"--.-\\\") {\\n        return 'q';\\n    } else if (s == \\\".-.\\\") {\\n        return 'r';\\n    } else if (s == \\\"...\\\") {\\n        return 's';\\n    } else if (s == \\\"-\\\") {\\n        return 't';\\n    } else if (s == \\\"..-\\\") {\\n        return 'u';\\n    } else if (s == \\\"...-\\\") {\\n        return 'v';\\n    } else if (s == \\\".--\\\") {\\n        return 'w';\\n    } else if (s == \\\"-..-\\\") {\\n        return 'x';\\n    } else if (s == \\\"-.--\\\") {\\n        return 'y';\\n    } else if (s == \\\"--..\\\") {\\n        return 'z';\\n    } else if (s == \\\".----\\\") {\\n        return '1';\\n    } else if (s == \\\"..---\\\") {\\n        return '2';\\n    } else if (s == \\\"...--\\\") {\\n        return '3';\\n    } else if (s == \\\"....-\\\") {\\n        return '4';\\n    } else if (s == \\\".....\\\") {\\n        return '5';\\n    } else if (s == \\\"-....\\\") {\\n        return '6';\\n    } else if (s == \\\"--...\\\") {\\n        return '7';\\n    } else if (s == \\\"---..\\\") {\\n        return '8';\\n    } else if (s == \\\"----.\\\") {\\n        return '9';\\n    } else if (s == \\\"-----\\\") {\\n        return '0';\\n    } else {\\n        std::cerr << \\\"Found invalid Morse code: \\\" << s << ' ' << std::endl;\\n        std::exit(0);\\n    }\\n}\\n/**\\n * Encrypt given text using morse code.\\n * @param text text to be encrypted\\n * @returns new encrypted text\\n */\\nstd::string encrypt(const std::string &text) {\\n    std::string encrypted_text = \\\"\\\";  // Empty string to store encrypted text\\n    // Going through each character of text and converting it\\n    // to morse representation\\n    for (const char &c : text) {\\n        encrypted_text += ciphers::morse::char_to_morse(c) + \\\" \\\";\\n    }\\n    return encrypted_text;  // Returning encrypted text\\n}\\n/**\\n * Decrypt given morse coded text.\\n * @param text text to be decrypted\\n * @returns new decrypted text\\n */\\nstd::string decrypt(const std::string &text) {\\n    // Going through each character of text and converting it\\n    // back to normal representation.\\n    std::string decrypted_text = \\\"\\\";  // Empty string to store decrypted text\\n    // Spliting string (with delimiter = \\\" \\\") and storing it\\n    // in vector\\n    std::size_t pos_start = 0, pos_end = 0, delim_len = 1;\\n    std::vector<std::string> splits;\\n    while ((pos_end = text.find(' ', pos_start)) != std::string::npos) {\\n        std::string token = text.substr(pos_start, pos_end - pos_start);\\n        pos_start = pos_end + delim_len;\\n        splits.push_back(token);\\n    }\\n\\n    // Traversing through each morse code string\\n    for (const std::string &s : splits) {\\n        // Add corresponding character\\n        decrypted_text += ciphers::morse::morse_to_char(s);\\n    }\\n\\n    return decrypted_text;  // Returning decrypted text\\n}\\n}  // namespace morse\\n}  // namespace ciphers\\n\\n/**\\n * @brief Function to test above algorithm\\n * @returns void\\n */\\nstatic void test() {\\n    // Test 1\\n    std::string text1 = \\\"01234567890\\\";\\n    std::string encrypted1 = ciphers::morse::encrypt(text1);\\n    std::string decrypted1 = ciphers::morse::decrypt(encrypted1);\\n    assert(text1 == decrypted1);\\n    std::cout << \\\"Original text : \\\" << text1 << std::endl;\\n    std::cout << \\\"Encrypted text : \\\" << encrypted1 << std::endl;\\n    std::cout << \\\"Decrypted text : \\\" << decrypted1 << std::endl;\\n    // Test 2\\n    std::string text2 = \\\"abcdefghijklmnopqrstuvwxyz\\\";\\n    std::string encrypted2 = ciphers::morse::encrypt(text2);\\n    std::string decrypted2 = ciphers::morse::decrypt(encrypted2);\\n    assert(text2 == decrypted2);\\n    std::cout << \\\"Original text : \\\" << text2 << std::endl;\\n    std::cout << \\\"Encrypted text : \\\" << encrypted2 << std::endl;\\n    std::cout << \\\"Decrypted text : \\\" << decrypted2 << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    // Testing\\n    test();\\n    return 0;\\n}\\n\"",
    "uint128 t": "\"/**\\n * @file\\n *\\n * @details Implementation of 128-bit unsigned integers.\\n * @note The implementation can be flagged as not completed. This header is used\\n * with enough operations as a part of bigger integer types 256-bit integer.\\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\\n */\\n\\n#include <algorithm>  /// for `std::reverse` and other operations\\n#include <ostream>    /// for `std::cout` overload\\n#include <string>     /// for `std::string`\\n#include <utility>    /// for `std::pair` library\\n\\n#ifdef _MSC_VER\\n#include <intrin.h>  /// for _BitScanForward64 and __BitScanReverse64 operation\\n#endif\\n\\n#ifndef CIPHERS_UINT128_T_HPP_\\n#define CIPHERS_UINT128_T_HPP_\\nclass uint128_t;\\n\\ntemplate <>\\nstruct std::is_integral<uint128_t> : std::true_type {};\\ntemplate <>\\nstruct std::is_arithmetic<uint128_t> : std::true_type {};\\ntemplate <>\\nstruct std::is_unsigned<uint128_t> : std::true_type {};\\n\\n/**\\n * @brief Adding two string\\n * @details Adds two long integer, only used for printing numbers\\n * @param first First integer string\\n * @param second Second integer string\\n * @returns string denoting the addition of both the strings\\n */\\nstd::string add(const std::string &first, const std::string &second) {\\n    std::string third;\\n    int16_t sum = 0, carry = 0;\\n    for (int32_t i = static_cast<int32_t>(first.size()) - 1,\\n                 j = static_cast<int32_t>(second.size()) - 1;\\n         i >= 0 || j >= 0; --i, --j) {\\n        sum = ((i >= 0 ? first[i] - '0' : 0) + (j >= 0 ? second[j] - '0' : 0) +\\n               carry);\\n        carry = sum / 10;\\n        sum %= 10;\\n        third.push_back(sum + '0');\\n    }\\n    if (carry) {\\n        third.push_back('1');\\n    }\\n    std::reverse(third.begin(), third.end());\\n    return third;\\n}\\n/**\\n * @class uint128_t\\n * @brief class for 128-bit unsigned integer\\n */\\nclass uint128_t {\\n    uint64_t f{}, s{};  /// First and second half of 128 bit number\\n\\n    /**\\n     * @brief Get integer from given string.\\n     * @details Create an integer from a given string\\n     * @param str integer string, can be hexadecimal (starting on 0x... or\\n     * number)\\n     * @returns void\\n     */\\n    void __get_integer_from_string(const std::string &str) {\\n        this->f = this->s = 0;\\n        if (str.size() > 1 && str[1] == 'x') {  // if hexadecimal\\n            for (auto i = 2; i < str.size(); ++i) {\\n                *this *= 16LL;\\n                if (str[i] >= '0' && str[i] <= '9') {\\n                    *this += (str[i] - '0');\\n                } else if (str[i] >= 'A' && str[i] <= 'F') {\\n                    *this += (str[i] - 'A' + 10);\\n                } else if (str[i] >= 'a' && str[i] <= 'f') {\\n                    *this += (str[i] - 'a' + 10);\\n                }\\n            }\\n        } else {  // if decimal\\n            for (auto &x : str) {\\n                *this *= 10LL;\\n                *this += (x - '0');\\n            }\\n        }\\n    }\\n\\n public:\\n    uint128_t() = default;\\n\\n    /**\\n     * @brief Parameterized constructor\\n     * @tparam T integral type\\n     * @param low lower part 8-bit unisgned integer\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    explicit uint128_t(T low) : s(low) {}\\n\\n    /**\\n     * @brief Parameterized constructor\\n     * @param str Integer string (hexadecimal starting with 0x.. or decimal)\\n     */\\n    explicit uint128_t(const std::string &str) {\\n        __get_integer_from_string(str);\\n    }\\n\\n    /**\\n     * @brief Parameterized constructor\\n     * @param high higher part 64-bit unsigned integer\\n     * @param low lower part 64-bit unsigned integer\\n     */\\n    uint128_t(const uint64_t high, const uint64_t low) : f(high), s(low) {}\\n\\n    /**\\n     * @brief Copy constructor\\n     * @param num 128-bit unsigned integer\\n     */\\n    uint128_t(const uint128_t &num) = default;\\n\\n    /**\\n     * @brief Move constructor\\n     * @param num 128-bit unsigned integer\\n     */\\n    uint128_t(uint128_t &&num) noexcept : f(num.f), s(num.s) {}\\n\\n    /**\\n     * @brief Destructor for uint128_t\\n     */\\n    ~uint128_t() = default;\\n\\n    /**\\n     * @brief Leading zeroes in binary\\n     * @details Calculates leading zeros in 128-bit integer\\n     * @returns Integer denoting leading zeroes\\n     */\\n    inline uint32_t _lez() {\\n#ifndef _MSC_VER\\n        if (f) {\\n            return __builtin_clzll(f);\\n        }\\n        return 64 + __builtin_clzll(s);\\n#else\\n        unsigned long r = 0;\\n        _BitScanForward64(&r, f);\\n        if (r == 64) {\\n            unsigned long l = 0;\\n            _BitScanForward64(&l, s);\\n            return 64 + l;\\n        }\\n        return r;\\n#endif\\n    }\\n\\n    /**\\n     * @brief Trailing zeroes in binary\\n     * @details Calculates leading zeros in 128-bit integer\\n     * @returns Integer denoting Trailing zeroes\\n     */\\n    inline uint32_t _trz() {\\n#ifndef _MSC_VER\\n        if (f) {\\n            return __builtin_ctzll(f);\\n        }\\n        return 64 + __builtin_ctzll(s);\\n#else\\n        unsigned long r = 0;\\n        _BitScanReverse64(&r, s);\\n        if (r == 64) {\\n            unsigned long l = 0;\\n            _BitScanReverse64(&l, f);\\n            return 64 + l;\\n        }\\n        return r;\\n#endif\\n    }\\n\\n    /**\\n     * @brief casting operator to boolean value\\n     * @returns true if value of this is non-zero, else false\\n     */\\n    inline explicit operator bool() const { return (f || s); }\\n\\n    /**\\n     * @brief casting operator to any integer valu\\n     * @tparam T any integer type\\n     * @returns integer value casted to mentioned type\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline explicit operator T() const {\\n        return static_cast<T>(s);\\n    }\\n\\n    /**\\n     * @brief returns lower 64-bit integer part\\n     * @returns returns lower 64-bit integer part\\n     */\\n    inline uint64_t lower() const { return s; }\\n\\n    /**\\n     * @brief returns upper 64-bit integer part\\n     * @returns returns upper 64-bit integer part\\n     */\\n    inline uint64_t upper() const { return f; }\\n\\n    /**\\n     * @brief operator = for other types\\n     * @tparam T denoting any integer type\\n     * @param p an integer to assign it's value\\n     * @returns this pointer with it's value equal to `p`\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t &operator=(const T &p) {\\n        this->s = p;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator = for type string\\n     * @param p a string to assign it's value to equivalent integer\\n     * @returns this pointer with it's value equal to `p`\\n     */\\n    inline uint128_t &operator=(const std::string &p) {\\n        this->__get_integer_from_string(p);\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator = for uint128_t\\n     * @param p an 128-bit integer to assign it's value\\n     * @returns this pointer with it's value equal to `p`\\n     */\\n    inline uint128_t &operator=(const uint128_t &p) = default;\\n\\n    /**\\n     * @brief Move assignment operator\\n     */\\n    inline uint128_t &operator=(uint128_t &&p) = default;\\n\\n    /**\\n     * @brief operator + for uint128_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns addition of this and p, returning uint128_t integer\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t operator+(const T p) {\\n        return uint128_t(f + (p + s < s), p + s);\\n    }\\n\\n    /**\\n     * @brief operator + for uint128_t and other integer types.\\n     * @param p 128-bit unsigned integer\\n     * @returns addition of this and p, returning uint128_t integer\\n     */\\n    inline uint128_t operator+(const uint128_t &p) {\\n        return uint128_t(f + (p.s + s < s) + p.f, p.s + s);\\n    }\\n\\n    /**\\n     * @brief operator += for uint128_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns addition of this and p, returning this\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t &operator+=(const T p) {\\n        bool app = p + s < s;\\n        this->f += app;\\n        this->s += p;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator += for uint128_t\\n     * @param p 128-bit unsigned integer\\n     * @returns addition of this and p, returning this\\n     */\\n    uint128_t &operator+=(const uint128_t &p) {\\n        bool app = p.s + s < s;\\n        f = f + app + p.f;\\n        s = p.s + s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief pre-increment operator\\n     * @returns incremented value of this.\\n     */\\n    inline uint128_t &operator++() {\\n        *this += 1;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief post-increment operator\\n     * @returns incremented value of this.\\n     */\\n    inline uint128_t operator++(int) {\\n        ++*this;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator - for uint128_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns subtraction of this and p, returning uint128_t integer\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t operator-(const T &p) {\\n        bool app = p > s;\\n        return uint128_t(f - app, s - p);\\n    }\\n\\n    /**\\n     * @brief operator - for uint128_t\\n     * @param p a type of integer variable\\n     * @returns subtraction of this and p, returning uint128_t integer\\n     */\\n    inline uint128_t operator-(const uint128_t &p) {\\n        bool app = p.s > s;\\n        return uint128_t(f - p.f - app, s - p.s);\\n    }\\n\\n    /**\\n     * @brief operator - using twos complement\\n     * @returns 2's complement of this.\\n     */\\n    inline uint128_t operator-() { return ~*this + uint128_t(1); }\\n\\n    /**\\n     * @brief operator -- (pre-decrement)\\n     * @returns decremented value of this\\n     */\\n    inline uint128_t &operator--() {\\n        *this -= 1;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator -- (post-decrement)\\n     * @returns decremented value of this\\n     */\\n    inline uint128_t operator--(int p) {\\n        --*this;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator -= for uint128_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns subtraction of this and p, returning this\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint128_t &operator-=(const T &p) {\\n        bool app = p > s;\\n        f -= app;\\n        s -= p;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator -= for uint128_t\\n     * @param p 128-bit unsigned integer\\n     * @returns subtraction of this and p, returning this\\n     */\\n    uint128_t &operator-=(const uint128_t &p) {\\n        bool app = p.s > s;\\n        f = f - p.f - app;\\n        s = s - p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator * for uint128_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns multiplication of this and p, returning uint128_t integer\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t operator*(const T p) {\\n        return *this * uint128_t(p);\\n    }\\n\\n    /**\\n     * @brief operator * for uint128_t and other integer types.\\n     * @param p 128-bit unsigned integer\\n     * @returns multiplication of this and p, returning uint128_t integer\\n     */\\n    uint128_t operator*(const uint128_t &p) {\\n        uint64_t f_first = s >> 32, f_second = s & 0xFFFFFFFF,\\n                 s_first = p.s >> 32, s_second = p.s & 0xFFFFFFFF;\\n        uint64_t fi = f_first * s_first, se = f_first * s_second,\\n                 th = s_first * f_second, fo = s_second * f_second;\\n        uint64_t tmp = ((se & 0xFFFFFFFF) << 32), tmp2 = (th & 0xFFFFFFFF)\\n                                                         << 32;\\n        int cc = (tmp + tmp2 < tmp);\\n        tmp += tmp2;\\n        cc += (tmp + fo < tmp);\\n        uint64_t carry = fi + (se >> 32) + (th >> 32);\\n        return uint128_t(this->f * p.s + this->s * p.f + carry + cc, tmp + fo);\\n    }\\n\\n    /**\\n     * @brief operator *= for uint128_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns multiplication of this and p, returning this\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t &operator*=(const T p) {\\n        *this *= uint128_t(p);\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator *= for uint128_t and other integer types.\\n     * @param p 128-bit unsigned integer\\n     * @returns multiplication of this and p, returning this\\n     */\\n    uint128_t &operator*=(const uint128_t &p) {\\n        uint64_t f_first = s >> 32, f_second = s & 0xFFFFFFFF,\\n                 s_first = p.s >> 32, s_second = p.s & 0xFFFFFFFF;\\n        uint64_t fi = f_first * s_first, se = f_first * s_second,\\n                 th = s_first * f_second, fo = s_second * f_second;\\n        uint64_t tmp = (se << 32), tmp2 = (th << 32);\\n        int cc = (tmp + tmp2 < tmp);\\n        tmp += tmp2;\\n        cc += (tmp + fo < tmp);\\n        uint64_t carry = fi + (se >> 32) + (th >> 32);\\n        f = this->f * p.s + this->s * p.f + carry + cc;\\n        s = tmp + fo;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief divide function for uint128_t and other integer types.\\n     * @details divide this value and\\n     * @param p 128-bit unsigned integer\\n     * @returns pair denoting quotient and remainder.\\n     */\\n    std::pair<uint128_t, uint128_t> divide(const uint128_t &p) {\\n        if (*this < p) {  // if this is less than divisor\\n            return {uint128_t(0), *this};\\n        } else if (*this == p) {  // if this is equal to divisor\\n            return {uint128_t(1), uint128_t(0)};\\n        }\\n        uint128_t tmp = p, tmp2 = *this;\\n        uint16_t left = tmp._lez() - _lez();\\n        tmp <<= left;\\n        uint128_t quotient(0);\\n        uint128_t zero(0);\\n        while (tmp2 >= p) {\\n            uint16_t shf = tmp2._lez() - tmp._lez();\\n            if (shf) {\\n                tmp >>= shf;\\n                quotient <<= shf;\\n                left -= shf;\\n            }\\n            if (tmp2 < tmp) {\\n                tmp >>= 1;\\n                quotient <<= 1;\\n                --left;\\n            }\\n            tmp2 -= tmp;\\n            ++quotient;\\n        }\\n        return {quotient << left, tmp2};\\n    }\\n\\n    /**\\n     * @brief operator / for uint128_t and other integer types.\\n     * @param p 128-bit unsigned integer\\n     * @returns unsigned 128-bit quotient.\\n     */\\n    inline uint128_t operator/(const uint128_t &p) { return divide(p).first; }\\n\\n    /**\\n     * @brief operator / for uint128_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns unsigned 128-bit quotient.\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t operator/(const T p) {\\n        uint128_t tmp = *this;\\n        tmp /= uint128_t(0, p);\\n        return tmp;\\n    }\\n\\n    /**\\n     * @brief operator /= for uint128_t\\n     * @param p 128-bit unsigned integer\\n     * @returns this set as unsigned 128-bit quotient.\\n     */\\n    inline uint128_t &operator/=(const uint128_t &p) {\\n        *this = divide(p).first;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator /= for uint128_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns this set as unsigned 128-bit quotient.\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t &operator/=(const T p) {\\n        *this /= uint128_t(0, p);\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator % for uint128_t\\n     * @param p 128-bit unsigned integer\\n     * @returns unsigned 128-bit remainder.\\n     */\\n    inline uint128_t operator%(const uint128_t &p) { return divide(p).second; }\\n\\n    /**\\n     * @brief operator % for uint128_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns unsigned 128-bit remainder.\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t operator%(const T &p) {\\n        return *this % uint128_t(p);\\n    }\\n\\n    /**\\n     * @brief operator %= for uint128_t\\n     * @param p 128-bit unsigned integer\\n     * @returns this set as unsigned 128-bit remainder.\\n     */\\n    inline uint128_t &operator%=(const uint128_t &p) {\\n        *this = divide(p).second;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator %= for uint128_t\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns this set as unsigned 128-bit remainder.\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t &operator%=(const T &p) {\\n        *this %= uint128_t(p);\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator < for uint128_t\\n     * @param other number to be compared with this\\n     * @returns true if this is less than other, else false\\n     */\\n    inline bool operator<(const uint128_t &other) {\\n        return f < other.f || (f == other.f && s < other.s);\\n    }\\n\\n    /**\\n     * @brief operator <= for uint128_t\\n     * @param other number to be compared with this\\n     * @returns true if this is less than or equal to other, else false\\n     */\\n    inline bool operator<=(const uint128_t &other) {\\n        return f < other.f || (f == other.f && s <= other.s);\\n    }\\n\\n    /**\\n     * @brief operator > for uint128_t\\n     * @param other number to be compared with this\\n     * @returns true if this is greater than other, else false\\n     */\\n    inline bool operator>(const uint128_t &other) {\\n        return f > other.f || (f == other.f && s > other.s);\\n    }\\n\\n    /**\\n     * @brief operator >= for uint128_t\\n     * @param other number to be compared with this\\n     * @returns true if this is greater than or equal than other, else false\\n     */\\n    inline bool operator>=(const uint128_t &other) {\\n        return (f > other.f) || (f == other.f && s >= other.s);\\n    }\\n\\n    /**\\n     * @brief operator == for uint128_t\\n     * @param other number to be compared with this\\n     * @returns true if this is equal than other, else false\\n     */\\n    inline bool operator==(const uint128_t &other) {\\n        return f == other.f && s == other.s;\\n    }\\n\\n    /**\\n     * @brief operator != for uint128_t\\n     * @param other number to be compared with this\\n     * @returns true if this is not equal than other, else false\\n     */\\n    inline bool operator!=(const uint128_t &other) {\\n        return f != other.f || s != other.s;\\n    }\\n\\n    /**\\n     * @brief operator ! for uint128_t\\n     * @returns true if this has zero value, else false\\n     */\\n    inline bool operator!() { return !f && !s; }\\n\\n    /**\\n     * @brief operator && for uint128_t\\n     * @param b number to be compared with this\\n     * @returns true if both of the values are not zero, else false\\n     */\\n    inline bool operator&&(const uint128_t &b) {\\n        return (s || f) && (b.s || b.f);\\n    }\\n\\n    /**\\n     * @brief operator || for uint128_t\\n     * @param b number to be compared with this\\n     * @returns true if one of the values are not zero, else false\\n     */\\n    inline bool operator||(const uint128_t &b) {\\n        return (s || f) || (b.s || b.f);\\n    }\\n\\n    /**\\n     * @brief operator () for uint128_t\\n     * @returns true if this value is non-zero, else false\\n     */\\n    inline bool operator()() { return s || f; }\\n\\n    /**\\n     * @brief operator < for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is less than other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline bool operator<(const T other) {\\n        return *this < uint128_t(other);\\n    }\\n\\n    /**\\n     * @brief operator <= for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is less than or equal to other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline bool operator<=(const T other) {\\n        return *this <= uint128_t(other);\\n    }\\n\\n    /**\\n     * @brief operator > for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is greater than other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline bool operator>(const T other) {\\n        return *this > uint128_t(other);\\n    }\\n\\n    /**\\n     * @brief operator >= for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is greater than or equal other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline bool operator>=(const T other) {\\n        return *this >= uint128_t(other);\\n    }\\n\\n    /**\\n     * @brief operator == for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is equal to other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline bool operator==(const T other) {\\n        return *this == uint128_t(other);\\n    }\\n\\n    /**\\n     * @brief operator != for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is not equal to other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline bool operator!=(const T other) {\\n        return *this != uint128_t(other);\\n    }\\n\\n    /**\\n     * @brief operator && for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is both values are non-zero, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline bool operator&&(const T b) {\\n        return (f || s) && b;\\n    }\\n\\n    /**\\n     * @brief operator || for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is either one of the values are non-zero, else\\n     * false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline bool operator||(const T b) {\\n        return (f || s) || b;\\n    }\\n\\n    /**\\n     * @brief operator ~ for uint128_t\\n     * @returns 1's complement of this number\\n     */\\n    uint128_t operator~() { return uint128_t(~this->f, ~this->s); }\\n\\n    /**\\n     * @brief operator << for uint128_t\\n     * @tparam T integral type\\n     * @param p number denoting number of shifts\\n     * @returns value of this shifted by p to left\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint128_t operator<<(const T p) {\\n        if (!p) {\\n            return uint128_t(f, s);\\n        } else if (p >= 64 && p <= 128) {\\n            return uint128_t((this->s << (p - 64)), 0);\\n        } else if (p < 64 && p > 0) {\\n            return uint128_t((this->f << p) + ((this->s >> (64 - p))),\\n                             this->s << p);\\n        }\\n        return uint128_t(0);\\n    }\\n\\n    /**\\n     * @brief operator <<= for uint128_t\\n     * @tparam T integral type\\n     * @param p number denoting number of shifts\\n     * @returns this shifted by p to left\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint128_t &operator<<=(const T p) {\\n        if (p) {\\n            if (p >= 64 && p <= 128) {\\n                this->f = (this->s << (p - 64));\\n                this->s = 0;\\n            } else {\\n                f = ((this->f << p) + (this->s >> (64 - p)));\\n                s = (this->s << p);\\n            }\\n        }\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator >> for uint128_t\\n     * @tparam T integral type\\n     * @param p number denoting number of shifts\\n     * @returns value of this shifted by p to right\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint128_t operator>>(const T p) {\\n        if (!p) {\\n            return uint128_t(this->f, this->s);\\n        } else if (p >= 64 && p <= 128) {\\n            return uint128_t(0, (this->f >> (p - 64)));\\n        } else if (p < 64 && p > 0) {\\n            return uint128_t((this->f >> p),\\n                             (this->s >> p) + (this->f << (64 - p)));\\n        }\\n        return uint128_t(0);\\n    }\\n\\n    /**\\n     * @brief operator >>= for uint128_t\\n     * @tparam T integral type\\n     * @param p number denoting number of shifts\\n     * @returns this shifted by p to right\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint128_t &operator>>=(const T p) {\\n        if (p) {\\n            if (p >= 64) {\\n                f = 0;\\n                s = (this->f >> (p - 64));\\n            } else {\\n                s = (this->s >> p) + (this->f << (64 - p));\\n                f = (this->f >> p);\\n            }\\n        }\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator & for uint128_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns value of this & p (& is bit-wise operator)\\n     */\\n    inline uint128_t operator&(const uint128_t &p) {\\n        return uint128_t(this->f & p.f, this->s & p.s);\\n    }\\n\\n    /**\\n     * @brief operator & for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns value of this & p (& is bit-wise operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint128_t operator&(const T p) {\\n        uint128_t tmp = *this;\\n        return tmp & uint128_t(p);\\n    }\\n\\n    /**\\n     * @brief operator &= for uint128_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns this = this & p (& is bit-wise operator)\\n     */\\n    uint128_t &operator&=(const uint128_t &p) {\\n        this->f &= p.f;\\n        this->s &= p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator &= for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns this = this & p (& is bit-wise operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint128_t &operator&=(const T p) {\\n        *this &= uint128_t(p);\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator | for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns value of this | p (| is bit-wise operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t operator|(const T p) {\\n        return uint128_t(p | s);\\n    }\\n\\n    /**\\n     * @brief operator | for uint128_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns value of this | p (| is bit-wise OR operator)\\n     */\\n    inline uint128_t operator|(const uint128_t &p) {\\n        return uint128_t(this->f | p.f, this->s | p.s);\\n    }\\n\\n    /**\\n     * @brief operator |= for uint128_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns this = this | p (| is bit-wise OR operator)\\n     */\\n    uint128_t &operator|=(const uint128_t &p) {\\n        f |= p.f;\\n        s |= p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator |= for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns this = this | p (| is bit-wise OR operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t &operator|=(const T p) {\\n        s |= p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator ^ for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns value of this ^ p (^ is bit-wise XOR operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t operator^(const T p) {\\n        return uint128_t(this->f, this->s ^ p);\\n    }\\n\\n    /**\\n     * @brief operator ^ for uint128_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns value of this ^ p (^ is bit-wise XOR operator)\\n     */\\n    inline uint128_t operator^(const uint128_t &p) {\\n        return uint128_t(this->f ^ p.f, this->s ^ p.s);\\n    }\\n\\n    /**\\n     * @brief operator ^= for uint128_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns this = this ^ p (^ is bit-wise XOR operator)\\n     */\\n    uint128_t &operator^=(const uint128_t &p) {\\n        f ^= p.f;\\n        s ^= p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator ^= for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns this = this ^ p (^ is bit-wise XOR operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint128_t &operator^=(const T &p) {\\n        s ^= p;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator << for printing uint128_t integer\\n     * @details Prints the uint128_t integer in decimal form\\n     * @note Note that this operator is costly since it uses strings to print\\n     * the value\\n     * @param op ostream object\\n     * @param p 128-bit integer\\n     * @returns op, ostream object.\\n     */\\n    friend std::ostream &operator<<(std::ostream &op, const uint128_t &p) {\\n        if (!p.f) {\\n            op << p.s;\\n        } else {\\n            std::string out = \\\"0\\\", p_2 = \\\"1\\\";\\n            for (int i = 0; i < 64; ++i) {\\n                if (p.s & (1LL << i)) {\\n                    out = add(out, p_2);\\n                }\\n                p_2 = add(p_2, p_2);\\n            }\\n            for (int i = 0; i < 64; ++i) {\\n                if (p.f & (1LL << i)) {\\n                    out = add(out, p_2);\\n                }\\n                p_2 = add(p_2, p_2);\\n            }\\n            op << out;\\n        }\\n        return op;\\n    }\\n};\\n\\n// Arithmetic operators\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint128_t operator+(const T &p, const uint128_t &q) {\\n    return uint128_t(p) + q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint128_t operator-(const T p, const uint128_t &q) {\\n    return uint128_t(p) - q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint128_t operator*(const T p, const uint128_t &q) {\\n    return uint128_t(p) * q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint128_t operator/(const T p, const uint128_t &q) {\\n    return uint128_t(p) / q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint128_t operator%(const T p, const uint128_t &q) {\\n    return uint128_t(p) % q;\\n}\\n\\n// Bitwise operators\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint128_t operator&(const T &p, const uint128_t &q) {\\n    return uint128_t(p) & q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint128_t operator|(const T p, const uint128_t &q) {\\n    return uint128_t(p) | q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint128_t operator^(const T p, const uint128_t &q) {\\n    return uint128_t(p) ^ q;\\n}\\n\\n// Boolean operators\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator&&(const T p, const uint128_t &q) {\\n    return uint128_t(p) && q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator||(const T p, const uint128_t &q) {\\n    return uint128_t(p) || q;\\n}\\n\\n// Comparison operators\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator==(const T p, const uint128_t &q) {\\n    return uint128_t(p) == q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator!=(const T p, const uint128_t &q) {\\n    return uint128_t(p) != q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator<(const T p, const uint128_t &q) {\\n    return uint128_t(p) < q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator<=(const T p, const uint128_t &q) {\\n    return uint128_t(p) <= q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator>(const T p, const uint128_t &q) {\\n    return uint128_t(p) > q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator>=(const T p, const uint128_t &q) {\\n    return uint128_t(p) >= q;\\n}\\n\\n#endif  // CIPHERS_UINT128_T_HPP_\\n\"",
    "uint256 t": "\"/**\\n * @file\\n *\\n * @details Implementation of 256-bit unsigned integers.\\n * @note The implementation can be flagged as not completed. This header is used\\n * with enough operations to demonstrate the usage of ECDH (Elliptic Curve\\n * Diffie-Hellman) Key exchange.\\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\\n */\\n#include <string>   /// for `std::string`\\n#include <utility>  /// for `std::pair` library\\n\\n#include \\\"uint128_t.hpp\\\"  /// for uint128_t integer\\n\\n#ifndef CIPHERS_UINT256_T_HPP_\\n#define CIPHERS_UINT256_T_HPP_\\n\\nclass uint256_t;\\n\\ntemplate <>\\nstruct std::is_integral<uint256_t> : std::true_type {};\\n\\ntemplate <>\\nstruct std::is_arithmetic<uint256_t> : std::true_type {};\\n\\ntemplate <>\\nstruct std::is_unsigned<uint256_t> : std::true_type {};\\n\\n/**\\n * @class uint256_t\\n * @brief class for 256-bit unsigned integer\\n */\\nclass uint256_t {\\n    uint128_t f{}, s{};  /// First and second half of 256 bit number\\n\\n    /**\\n     * @brief Get integer from given string.\\n     * @details Create an integer from a given string\\n     * @param str integer string, can be hexadecimal (starting on 0x... or\\n     * number)\\n     * @returns void\\n     */\\n    void __get_integer_from_string(const std::string &str) {\\n        this->f = this->s = uint128_t(0);\\n        if (str.size() > 1 && str[1] == 'x') {\\n            for (auto i = 2; i < str.size(); ++i) {\\n                *this *= 16LL;\\n                if (str[i] >= '0' && str[i] <= '9') {\\n                    *this += (str[i] - '0');\\n                } else if (str[i] >= 'A' && str[i] <= 'F') {\\n                    *this += (str[i] - 'A' + 10);\\n                } else if (str[i] >= 'a' && str[i] <= 'f') {\\n                    *this += (str[i] - 'a' + 10);\\n                }\\n            }\\n        } else {\\n            for (auto &x : str) {\\n                *this *= 10LL;\\n                *this += (x - '0');\\n            }\\n        }\\n    }\\n\\n public:\\n    // Constructors\\n    uint256_t() = default;\\n\\n    /**\\n     * @brief Parameterized constructor\\n     * @tparam T template for integer types\\n     * @param low Integer denoting lower 128-bits\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    explicit uint256_t(T low) : s(low), f(0) {}\\n\\n    /**\\n     * @brief Parameterized constructor\\n     * @param str Integer string (hexadecimal starting with 0x.. or decimal)\\n     */\\n    explicit uint256_t(const std::string &str) {\\n        __get_integer_from_string(str);\\n    }\\n\\n    /**\\n     * @brief Copy constructor\\n     * @param num 256-bit unsigned integer\\n     */\\n    uint256_t(const uint256_t &num) = default;\\n\\n    /**\\n     * @brief Move constructor\\n     * @param num 256-bit unsigned integer\\n     */\\n    uint256_t(uint256_t &&num) noexcept\\n        : f(std::move(num.f)), s(std::move(num.s)) {}\\n\\n    /**\\n     * @brief Parameterized constructor\\n     * @param high higher part 128-bit unsigned integer\\n     * @param low lower part 128-bit unsigned integer\\n     */\\n    uint256_t(uint128_t high, uint128_t low)\\n        : f(std::move(high)), s(std::move(low)) {}\\n\\n    /**\\n     * @brief Parameterized constructor\\n     * @param high higher part 64-bit unsigned integer\\n     * @param low lower part 64-bit unsigned integer\\n     */\\n    uint256_t(const uint64_t high, const uint64_t low) : f(high), s(low) {}\\n\\n    /**\\n     * @brief Destructor for uint256_t\\n     */\\n    ~uint256_t() = default;\\n\\n    /**\\n     * @brief Leading zeroes in binary\\n     * @details Calculates leading zeros in 256-bit integer\\n     * @returns Integer denoting leading zeroes\\n     */\\n    inline uint32_t _lez() {\\n        if (f) {\\n            return f._lez();\\n        }\\n        return 128 + s._lez();\\n    }\\n\\n    /**\\n     * @brief Trailing zeroes in binary\\n     * @details Calculates leading zeros in 256-bit integer\\n     * @returns Integer denoting Trailing zeroes\\n     */\\n    inline uint32_t _trz() {\\n        if (s) {\\n            return s._trz();\\n        }\\n        return 128 + f._trz();\\n    }\\n\\n    /**\\n     * @brief casting operator to boolean value\\n     * @returns true if value of this is non-zero, else false\\n     */\\n    inline explicit operator bool() const { return f || s; }\\n\\n    /**\\n     * @brief casting operator to any integer value\\n     * @tparam T any integer type\\n     * @returns integer value casted to mentioned type\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline explicit operator T() const {\\n        return static_cast<T>(s);\\n    }\\n\\n    /**\\n     * @brief casting operator to uint128_t\\n     * @returns returns lower 128-bit integer part\\n     */\\n    inline explicit operator uint128_t() const { return s; }\\n\\n    /**\\n     * @brief returns lower 128-bit integer part\\n     * @returns returns lower 128-bit integer part\\n     */\\n    inline uint128_t lower() const { return s; }\\n\\n    /**\\n     * @brief returns upper 128-bit integer part\\n     * @returns returns upper 128-bit integer part\\n     */\\n    inline uint128_t upper() const { return f; }\\n\\n    /**\\n     * @brief operator = for uint256_t\\n     * @param p an 256-bit integer to assign it's value\\n     * @returns this pointer with it's value equal to `p`\\n     */\\n    inline uint256_t &operator=(const uint256_t &p) = default;\\n\\n    /**\\n     * @brief operator = for other types\\n     * @tparam T denoting any integer type\\n     * @param p an integer to assign it's value\\n     * @returns this pointer with it's value equal to `p`\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t &operator=(const T &p) {\\n        this->s = p;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator = for type string\\n     * @param p a string to assign it's value to equivalent integer\\n     * @returns this pointer with it's value equal to `p`\\n     */\\n    inline uint256_t &operator=(const std::string &p) {\\n        __get_integer_from_string(p);\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief Move assignment operator\\n     */\\n    inline uint256_t &operator=(uint256_t &&p) = default;\\n\\n    /**\\n     * @brief operator + for uint256_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns addition of this and p, returning uint256_t integer\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t operator+(const T &p) {\\n        bool app = s + p < s;\\n        return uint256_t(f + app, s + p);\\n    }\\n\\n    /**\\n     * @brief operator + for uint256_t and other integer types.\\n     * @param p 256-bit unsigned integer\\n     * @returns addition of this and p, returning uint256_t integer\\n     */\\n    inline uint256_t operator+(const uint256_t &p) {\\n        bool app = (s + p.s < s);\\n        return {f + app + p.f, s + p.s};\\n    }\\n\\n    /**\\n     * @brief operator += for uint256_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns addition of this and p, returning this\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t &operator+=(const T &p) {\\n        bool app = (p + s < s);\\n        this->f += app;\\n        this->s += p;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator += for uint256_t\\n     * @param p 256-bit unsigned integer\\n     * @returns addition of this and p, returning this\\n     */\\n    inline uint256_t &operator+=(const uint256_t &p) {\\n        bool app = (s + p.s < s);\\n        f = f + app + p.f;\\n        s = s + p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief pre-increment operator\\n     * @returns incremented value of this.\\n     */\\n    inline uint256_t &operator++() {\\n        *this += 1;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief post-increment operator\\n     * @returns incremented value of this.\\n     */\\n    inline uint256_t operator++(int) {\\n        ++*this;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator - for uint256_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns subtraction of this and p, returning uint256_t integer\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t operator-(const T &p) {\\n        bool app = (p > s);\\n        return uint256_t(f - app, s - p);\\n    }\\n\\n    /**\\n     * @brief operator - for uint256_t\\n     * @param p a type of integer variable\\n     * @returns subtraction of this and p, returning uint256_t integer\\n     */\\n    inline uint256_t operator-(const uint256_t &p) {\\n        bool app = s < p.s;\\n        return {f - p.f - app, s - p.s};\\n    }\\n\\n    /**\\n     * @brief operator - using twos complement\\n     * @returns 2's complement of this.\\n     */\\n    inline uint256_t operator-() { return ~*this + uint256_t(1); }\\n\\n    /**\\n     * @brief operator -- (pre-decrement)\\n     * @returns decremented value of this\\n     */\\n    inline uint256_t &operator--() {\\n        *this -= 1;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator -- (post-decrement)\\n     * @returns decremented value of this\\n     */\\n    inline uint256_t operator--(int p) {\\n        --*this;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator -= for uint256_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns subtraction of this and p, returning this\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t operator-=(const T p) {\\n        bool app = (p > s);\\n        f = f - app;\\n        s = s - p;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator -= for uint256_t\\n     * @param p 256-bit unsigned integer\\n     * @returns subtraction of this and p, returning this\\n     */\\n    inline uint256_t &operator-=(const uint256_t &p) {\\n        bool app = s < p.s;\\n        f = f - app - p.f;\\n        s = s - p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator * for uint256_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns multiplication of this and p, returning uint256_t integer\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t operator*(const T &p) {\\n        return *this * uint256_t(p);\\n    }\\n\\n    /**\\n     * @brief operator * for uint256_t and other integer types.\\n     * @param p 256-bit unsigned integer\\n     * @returns multiplication of this and p, returning uint256_t integer\\n     */\\n    uint256_t operator*(const uint256_t &p) {\\n        uint128_t f_first(s.upper()), f_second(s.lower()), s_first(p.s.upper()),\\n            s_second(p.s.lower());\\n        uint128_t fi = f_first * s_first, se = f_first * s_second,\\n                  th = s_first * f_second, fo = s_second * f_second;\\n        uint128_t tmp = se << 64, tmp2 = th << 64;\\n        int cc = (tmp + tmp2 < tmp);\\n        tmp += tmp2;\\n        cc += (tmp + fo < tmp);\\n        return {f * p.s + s * p.f + fi + se.upper() + th.upper() + cc,\\n                tmp + fo};\\n    }\\n\\n    /**\\n     * @brief operator *= for uint256_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns multiplication of this and p, returning this\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t &operator*=(const T &p) {\\n        return (*this *= uint256_t(p));\\n    }\\n\\n    /**\\n     * @brief operator *= for uint256_t and other integer types.\\n     * @param p 256-bit unsigned integer\\n     * @returns multiplication of this and p, returning this\\n     */\\n    uint256_t &operator*=(const uint256_t &p) {\\n        uint128_t f_first(s.upper()), f_second(s.lower()), s_first(p.s.upper()),\\n            s_second(p.s.lower());\\n        uint128_t fi = f_first * s_first, se = f_first * s_second,\\n                  th = s_first * f_second, fo = s_second * f_second;\\n        uint128_t tmp = se << 64, tmp2 = th << 64;\\n        int cc = (tmp + tmp2 < tmp);\\n        tmp += tmp2;\\n        cc += (tmp + fo < tmp);\\n        f = f * p.s + s * p.f + fi + se.upper() + th.upper() + cc;\\n        s = tmp + fo;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief divide function for uint256_t and other integer types.\\n     * @details divide this value and\\n     * @param p 256-bit unsigned integer\\n     * @returns pair denoting quotient and remainder.\\n     */\\n    std::pair<uint256_t, uint256_t> divide(const uint256_t &p) {\\n        if (*this < p) {  // if this is less than divisor\\n            return {uint256_t(0), *this};\\n        } else if (*this == p) {  // if this is equal to divisor\\n            return {uint256_t(1), uint256_t(0)};\\n        }\\n        uint256_t tmp = p, tmp2 = *this;\\n        uint16_t left = tmp._lez() - _lez();\\n        tmp <<= left;\\n        uint256_t quotient(0);\\n        uint256_t zero(0);\\n        while (tmp2 >= p) {\\n            uint16_t shf = tmp2._lez() - tmp._lez();\\n            if (shf) {\\n                tmp >>= shf;\\n                quotient <<= shf;\\n                left -= shf;\\n            }\\n            if (tmp2 < tmp) {\\n                tmp >>= 1;\\n                quotient <<= 1;\\n                --left;\\n            }\\n            tmp2 -= tmp;\\n            ++quotient;\\n        }\\n        return {quotient << left, tmp2};\\n    }\\n\\n    /**\\n     * @brief operator / for uint256_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns unsigned 256-bit quotient.\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t operator/(const T &p) {\\n        uint256_t tmp = *this;\\n        tmp /= uint256_t(p);\\n        return tmp;\\n    }\\n\\n    /**\\n     * @brief operator / for uint256_t and other integer types.\\n     * @param p 256-bit unsigned integer\\n     * @returns unsigned 256-bit quotient.\\n     */\\n    inline uint256_t operator/(const uint256_t &p) { return divide(p).first; }\\n\\n    /**\\n     * @brief operator /= for uint256_t\\n     * @param p 256-bit unsigned integer\\n     * @returns this set as unsigned 256-bit quotient.\\n     */\\n    inline uint256_t &operator/=(const uint256_t &p) {\\n        *this = divide(p).first;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator /= for uint256_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns this set as unsigned 256-bit quotient.\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t &operator/=(const T &p) {\\n        *this /= uint256_t(p);\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator % for uint256_t\\n     * @param p 256-bit unsigned integer\\n     * @returns unsigned 256-bit remainder.\\n     */\\n    inline uint256_t operator%(const uint256_t &p) { return divide(p).second; }\\n\\n    /**\\n     * @brief operator % for uint256_t and other integer types.\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns unsigned 256-bit remainder.\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t operator%(const T &p) {\\n        uint256_t tmp = *this;\\n        tmp %= uint256_t(p);\\n        return tmp;\\n    }\\n\\n    /**\\n     * @brief operator %= for uint256_t\\n     * @param p 256-bit unsigned integer\\n     * @returns this set as unsigned 256-bit remainder.\\n     */\\n    inline uint256_t &operator%=(const uint256_t &p) {\\n        *this = divide(p).second;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator %= for uint256_t\\n     * @tparam T denoting integral type\\n     * @param p a type of integer variable\\n     * @returns this set as unsigned 256-bit remainder.\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t &operator%=(const T &p) {\\n        *this %= uint256_t(p);\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator < for uint256_t\\n     * @param other number to be compared with this\\n     * @returns true if this is less than other, else false\\n     */\\n    inline bool operator<(const uint256_t &other) {\\n        return f < other.f || (f == other.f && s < other.s);\\n    }\\n\\n    /**\\n     * @brief operator <= for uint256_t\\n     * @param other number to be compared with this\\n     * @returns true if this is less than or equal to other, else false\\n     */\\n    inline bool operator<=(const uint256_t &other) {\\n        return f < other.f || (f == other.f && s <= other.s);\\n    }\\n\\n    /**\\n     * @brief operator > for uint256_t\\n     * @param other number to be compared with this\\n     * @returns true if this is greater than other, else false\\n     */\\n    inline bool operator>(const uint256_t &other) {\\n        return f > other.f || (f == other.f && s > other.s);\\n    }\\n\\n    /**\\n     * @brief operator >= for uint256_t\\n     * @param other number to be compared with this\\n     * @returns true if this is greater than or equal than other, else false\\n     */\\n    inline bool operator>=(const uint256_t &other) {\\n        return (f > other.f) || (f == other.f && s >= other.s);\\n    }\\n\\n    /**\\n     * @brief operator == for uint256_t\\n     * @param other number to be compared with this\\n     * @returns true if this is equal than other, else false\\n     */\\n    inline bool operator==(const uint256_t &other) {\\n        return f == other.f && s == other.s;\\n    }\\n\\n    /**\\n     * @brief operator != for uint256_t\\n     * @param other number to be compared with this\\n     * @returns true if this is not equal than other, else false\\n     */\\n    inline bool operator!=(const uint256_t &other) {\\n        return !((*this) == other);\\n    }\\n\\n    /**\\n     * @brief operator ! for uint256_t\\n     * @returns true if this has zero value, else false\\n     */\\n    inline bool operator!() { return !f && !s; }\\n\\n    /**\\n     * @brief operator && for uint256_t\\n     * @param b number to be compared with this\\n     * @returns true if both of the values are not zero, else false\\n     */\\n    inline bool operator&&(const uint256_t &b) {\\n        return (s || f) && (b.s || b.f);\\n    }\\n\\n    /**\\n     * @brief operator || for uint256_t\\n     * @param b number to be compared with this\\n     * @returns true if one of the values are not zero, else false\\n     */\\n    inline bool operator||(const uint256_t &b) {\\n        return (s || f) || (b.s || b.f);\\n    }\\n\\n    /**\\n     * @brief operator () for uint256_t\\n     * @returns true if this value is non-zero, else false\\n     */\\n    inline bool operator()() { return s || f; }\\n\\n    /**\\n     * @brief operator < for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is less than other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    bool operator<(const T &other) {\\n        return *this < uint256_t(other);\\n    }\\n\\n    /**\\n     * @brief operator <= for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is less than or equal to other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    bool operator<=(const T &other) {\\n        return *this <= uint256_t(other);\\n    }\\n\\n    /**\\n     * @brief operator > for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is greater than other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    bool operator>(const T &other) {\\n        return *this > uint256_t(other);\\n    }\\n\\n    /**\\n     * @brief operator >= for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is greater than or equal other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    bool operator>=(const T &other) {\\n        return *this >= uint256_t(other);\\n    }\\n\\n    /**\\n     * @brief operator == for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is equal to other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    bool operator==(const T &other) {\\n        return *this == uint256_t(other);\\n    }\\n\\n    /**\\n     * @brief operator != for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is not equal to other, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    bool operator!=(const T &other) {\\n        return *this != uint256_t(other);\\n    }\\n\\n    /**\\n     * @brief operator && for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is both values are non-zero, else false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline bool operator&&(const T &b) {\\n        return (s || f) && (b);\\n    }\\n\\n    /**\\n     * @brief operator || for other types\\n     * @tparam T integral type\\n     * @param other number to be compared with this\\n     * @returns true if this is either one of the values are non-zero, else\\n     * false\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline bool operator||(const T &b) {\\n        return (s || f) || (b);\\n    }\\n\\n    /**\\n     * @brief operator ~ for uint256_t\\n     * @returns 1's complement of this number\\n     */\\n    inline uint256_t operator~() { return {~f, ~s}; }\\n\\n    /**\\n     * @brief operator << for uint256_t\\n     * @tparam T integral type\\n     * @param p number denoting number of shifts\\n     * @returns value of this shifted by p to left\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint256_t operator<<(const T &p) {\\n        if (!p) {\\n            return {this->f, this->s};\\n        } else if (p >= 128) {\\n            return uint256_t((this->s << (p - 128)), uint128_t(0));\\n        }\\n        return uint256_t((this->f << p) + (this->s >> (128 - p)),\\n                         (this->s << p));\\n    }\\n\\n    /**\\n     * @brief operator <<= for uint256_t\\n     * @tparam T integral type\\n     * @param p number denoting number of shifts\\n     * @returns this shifted by p to left\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint256_t &operator<<=(const T &p) {\\n        if (p) {\\n            if (p >= 128) {\\n                this->f = (this->s << (p - 128));\\n                this->s = uint128_t(0);\\n            } else {\\n                f = ((this->s >> (128 - p)) + (this->f << p));\\n                s = (this->s << p);\\n            }\\n        }\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator >> for uint256_t\\n     * @tparam T integral type\\n     * @param p number denoting number of shifts\\n     * @returns value of this shifted by p to right\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint256_t operator>>(const T &p) {\\n        if (!p) {\\n            return {this->f, this->s};\\n        } else if (p >= 128) {\\n            return uint256_t(uint128_t(0), (this->f >> (p - 128)));\\n        }\\n        return uint256_t((this->f >> p),\\n                         (this->s >> p) + (this->f << (128 - p)));\\n    }\\n\\n    /**\\n     * @brief operator >>= for uint256_t\\n     * @tparam T integral type\\n     * @param p number denoting number of shifts\\n     * @returns this shifted by p to right\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    uint256_t &operator>>=(const T &p) {\\n        if (p) {\\n            if (p >= 128) {\\n                f = uint128_t(0);\\n                s = (this->f >> (p - 128));\\n            } else {\\n                s = (this->s >> p) + (this->f << (128 - p));\\n                f = (this->f >> p);\\n            }\\n        }\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator & for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns value of this & p (& is bit-wise operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t operator&(const T &p) {\\n        return *this & uint256_t(p);\\n    }\\n\\n    /**\\n     * @brief operator & for uint256_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns value of this & p (& is bit-wise operator)\\n     */\\n    inline uint256_t operator&(const uint256_t &p) {\\n        return {f & p.f, s & p.s};\\n    }\\n\\n    /**\\n     * @brief operator &= for uint256_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns this = this & p (& is bit-wise operator)\\n     */\\n    inline uint256_t &operator&=(const uint256_t &p) {\\n        f &= p.f;\\n        s &= p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator &= for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns this = this & p (& is bit-wise operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t &operator&=(const T p) {\\n        s &= p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator | for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns value of this | p (| is bit-wise operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t operator|(const T &p) {\\n        return *this | uint256_t(p);\\n    }\\n\\n    /**\\n     * @brief operator | for uint256_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns value of this | p (| is bit-wise OR operator)\\n     */\\n    inline uint256_t operator|(const uint256_t &p) {\\n        return {this->f | p.f, this->s | p.s};\\n    }\\n\\n    /**\\n     * @brief operator |= for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns this = this | p (| is bit-wise OR operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t &operator|=(const T &p) {\\n        s |= p;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator |= for uint256_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns this = this | p (| is bit-wise OR operator)\\n     */\\n    inline uint256_t &operator|=(const uint256_t &p) {\\n        f |= p.f;\\n        s |= p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator ^ for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns value of this ^ p (^ is bit-wise XOR operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t operator^(const T &p) {\\n        return uint256_t(f, s ^ p);\\n    }\\n\\n    /**\\n     * @brief operator ^ for uint256_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns value of this ^ p (^ is bit-wise XOR operator)\\n     */\\n    inline uint256_t operator^(const uint256_t &p) {\\n        return {this->f ^ p.f, this->s ^ p.s};\\n    }\\n\\n    /**\\n     * @brief operator ^= for uint256_t (bitwise operator)\\n     * @param p number to be operated\\n     * @returns this = this ^ p (^ is bit-wise XOR operator)\\n     */\\n    inline uint256_t &operator^=(const uint256_t &p) {\\n        f ^= p.f;\\n        s ^= p.s;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator ^= for other types (bitwise operator)\\n     * @tparam T integral type\\n     * @param p number to be operated\\n     * @returns this = this ^ p (^ is bit-wise XOR operator)\\n     */\\n    template <typename T, typename = typename std::enable_if<\\n                              std::is_integral<T>::value, T>::type>\\n    inline uint256_t &operator^=(const T &p) {\\n        s ^= p;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief operator << for printing uint256_t integer\\n     * @details Prints the uint256_t integer in decimal form\\n     * @note Note that this operator is costly since it uses strings to print\\n     * the value\\n     * @param op ostream object\\n     * @param p 256-bit integer\\n     * @returns op, ostream object.\\n     */\\n    friend std::ostream &operator<<(std::ostream &op, uint256_t p) {\\n        if (!p.f) {\\n            op << p.s;\\n        } else {\\n            std::string out = \\\"0\\\", p_2 = \\\"1\\\";\\n            uint128_t L(1);\\n            for (uint64_t i = 0; i < 128; ++i) {\\n                if ((p.s & L)) {\\n                    out = add(out, p_2);\\n                }\\n                p_2 = add(p_2, p_2);\\n                L <<= 1;\\n            }\\n            L = uint128_t(1);\\n            for (int i = 0; i < 128; ++i) {\\n                if ((p.f & L)) {\\n                    out = add(out, p_2);\\n                }\\n                p_2 = add(p_2, p_2);\\n                L <<= 1;\\n            }\\n            op << out;\\n        }\\n        return op;\\n    }\\n};\\n\\n// Artihmetic\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint256_t operator+(const T p, const uint256_t &q) {\\n    return uint256_t(p) + q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint256_t operator-(const T p, const uint256_t &q) {\\n    return (uint256_t(p) - q);\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint256_t operator*(const T p, const uint256_t &q) {\\n    return uint256_t(p) * q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint256_t operator/(const T p, const uint256_t &q) {\\n    return uint256_t(p) / q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint256_t operator%(const T p, const uint256_t &q) {\\n    return uint256_t(p) % q;\\n}\\n\\n// Bitwise operators\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint256_t operator&(const T &p, const uint256_t &q) {\\n    return uint256_t(p) & q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint256_t operator|(const T p, const uint256_t &q) {\\n    return uint256_t(p) | q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline uint256_t operator^(const T p, const uint256_t &q) {\\n    return uint256_t(p) ^ q;\\n}\\n\\n// Boolean operators\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator&&(const T p, const uint256_t &q) {\\n    return uint256_t(p) && q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator||(const T p, const uint256_t &q) {\\n    return uint256_t(p) || q;\\n}\\n\\n// Comparison operators\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator==(const T p, const uint256_t &q) {\\n    return uint256_t(p) == q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator!=(const T p, const uint256_t &q) {\\n    return uint256_t(p) != q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator<(const T p, const uint256_t &q) {\\n    return uint256_t(p) < q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator<=(const T p, const uint256_t &q) {\\n    return uint256_t(p) <= q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator>(const T p, const uint256_t &q) {\\n    return uint256_t(p) > q;\\n}\\n\\ntemplate <typename T, typename = typename std::enable_if<\\n                          std::is_integral<T>::value, T>::type>\\ninline bool operator>=(const T p, const uint256_t &q) {\\n    return uint256_t(p) >= q;\\n}\\n\\n#endif  // CIPHERS_UINT256_T_HPP_\\n\"",
    "vigenere cipher": "\"/**\\n * @file vigenere_cipher.cpp\\n * @brief Implementation of [Vigenère cipher](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher) algorithm.\\n *\\n * @details\\n * The Vigenère cipher is a method of encrypting alphabetic text by using a series of interwoven vigenere \\n * ciphers, based on the letters of a keyword. It employs a form of polyalphabetic substitution. \\n *\\n * ### Algorithm\\n * The encryption can also be represented using modular arithmetic by first transforming \\n * the letters into numbers, according to the scheme, A → 0, B → 1, ..., Z → 25.\\n * Encryption of \\\\f$i^{th}\\\\f$ character in Message M by key K can be described mathematically as,\\n * \\n * \\\\f[ E_{K}(M_{i}) = (M_{i} + K_{i})\\\\;\\\\mbox{mod}\\\\; 26\\\\f]\\n * \\n * while decryption of \\\\f$i^{th}\\\\f$ character in Cipher C by key K can be described mathematically as,\\n *\\n * \\\\f[ D_{k}(C_{i}) = (C_{i} - K_{i} + 26)\\\\;\\\\mbox{mod}\\\\; 26\\\\f]\\n * \\n * Where \\\\f$K_{i}\\\\f$ denotes corresponding character in key. If \\\\f$|key| < |text|\\\\f$ than\\n * same key is repeated untill their lengths are equal.\\n * \\n * For Example,\\n * If M = \\\"ATTACKATDAWN\\\" and K = \\\"LEMON\\\" than K becomes \\\"LEMONLEMONLE\\\".\\n * \\n * \\\\note Rather than creating new key of equal length this program does this by using modular index for key\\n * (i.e. \\\\f$(j + 1) \\\\;\\\\mbox{mod}\\\\; |\\\\mbox{key}|\\\\f$)\\n * \\n * \\\\note This program implements Vigenère cipher for only uppercase English alphabet characters (i.e. A-Z). \\n * \\n * @author [Deep Raval](https://github.com/imdeep2905)\\n */\\n#include <iostream>\\n#include <string>\\n#include <cassert>\\n\\n/** \\\\namespace ciphers\\n * \\\\brief Algorithms for encryption and decryption\\n */\\nnamespace ciphers {\\n    /** \\\\namespace vigenere\\n     * \\\\brief Functions for [vigenère cipher](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher) algorithm.\\n     */\\n    namespace vigenere {   \\n        namespace {\\n            /**\\n             * This function finds character for given value (i.e.A-Z)\\n             * @param x value for which we want character \\n             * @return  corresponding character for perticular value\\n             */        \\n            inline char get_char(const int x) {\\n                // By adding 65 we are scaling 0-25 to 65-90. \\n                // Which are in fact ASCII values of A-Z. \\n                return char(x + 65); \\n            }\\n            /**\\n             * This function finds value for given character (i.e.0-25)\\n             * @param c character for which we want value\\n             * @return returns corresponding value for perticular character\\n             */  \\n            inline int get_value(const char c) {\\n                // A-Z have ASCII values in range 65-90.\\n                // Hence subtracting 65 will scale them to 0-25.\\n                return int(c - 65);\\n            }\\n        } // Unnamed namespace\\n        /**\\n         * Encrypt given text using vigenere cipher.\\n         * @param text text to be encrypted\\n         * @param key to be used for encryption\\n         * @return new encrypted text\\n         */\\n        std::string encrypt (const std::string &text, const std::string &key) {\\n            std::string encrypted_text = \\\"\\\"; // Empty string to store encrypted text\\n            // Going through each character of text and key\\n            // Note that key is visited in circular way hence  j = (j + 1) % |key|\\n            for(size_t i = 0, j = 0; i < text.length(); i++, j = (j + 1) % key.length()) {\\n                int place_value_text = get_value(text[i]); // Getting value of character in text\\n                int place_value_key = get_value(key[j]); // Getting value of character in key\\n                place_value_text = (place_value_text + place_value_key) % 26; // Applying encryption\\n                char encrypted_char = get_char(place_value_text); // Getting new character from encrypted value\\n                encrypted_text += encrypted_char; // Appending encrypted character\\n            }\\n            return encrypted_text; // Returning encrypted text\\n        }\\n        /**\\n         * Decrypt given text using vigenere cipher.\\n         * @param text text to be decrypted\\n         * @param key key to be used for decryption\\n         * @return new decrypted text\\n         */        \\n        std::string decrypt (const std::string &text, const std::string &key) {\\n            // Going through each character of text and key\\n            // Note that key is visited in circular way hence  j = (j + 1) % |key|\\n            std::string decrypted_text = \\\"\\\"; // Empty string to store decrypted text\\n            for(size_t i = 0, j = 0; i < text.length(); i++, j = (j + 1) % key.length()) {\\n                int place_value_text = get_value(text[i]); // Getting value of character in text\\n                int place_value_key = get_value(key[j]); // Getting value of character in key\\n                place_value_text = (place_value_text - place_value_key + 26) % 26; // Applying decryption\\n                char decrypted_char = get_char(place_value_text); // Getting new character from decrypted value\\n                decrypted_text += decrypted_char; // Appending decrypted character\\n            }        \\n            return decrypted_text; // Returning decrypted text\\n        }\\n    } // namespace vigenere\\n} // namespace ciphers\\n\\n/**\\n * Function to test above algorithm\\n */\\nvoid test() {\\n    // Test 1\\n    std::string text1 = \\\"NIKOLATESLA\\\";\\n    std::string encrypted1 = ciphers::vigenere::encrypt(text1, \\\"TESLA\\\");\\n    std::string decrypted1 = ciphers::vigenere::decrypt(encrypted1, \\\"TESLA\\\");\\n    assert(text1 == decrypted1);\\n    std::cout << \\\"Original text : \\\" << text1;\\n    std::cout << \\\" , Encrypted text (with key = TESLA) : \\\" << encrypted1;\\n    std::cout << \\\" , Decrypted text : \\\"<< decrypted1 << std::endl;\\n    // Test 2\\n    std::string text2 = \\\"GOOGLEIT\\\";\\n    std::string encrypted2 = ciphers::vigenere::encrypt(text2, \\\"REALLY\\\");\\n    std::string decrypted2 = ciphers::vigenere::decrypt(encrypted2, \\\"REALLY\\\");\\n    assert(text2 == decrypted2);\\n    std::cout << \\\"Original text : \\\" << text2;\\n    std::cout << \\\" , Encrypted text (with key = REALLY) : \\\" << encrypted2;\\n    std::cout << \\\" , Decrypted text : \\\"<< decrypted2 << std::endl;\\n}\\n\\n/** Driver Code */\\nint main() {\\n    // Testing\\n    test();\\n    return 0;\\n}\\n\"",
    "xor cipher": "\"/**\\n * @file xor_cipher.cpp\\n * @brief Implementation of [XOR cipher](https://en.wikipedia.org/wiki/XOR_cipher) algorithm.\\n *\\n * @details\\n * In cryptography, the simple XOR cipher is a type of additive cipher, an encryption \\n * algorithm that operates according to the principles: \\n *\\n * * \\\\f$A {\\\\oplus} 0 = A\\\\f$\\n * * \\\\f$A {\\\\oplus} A = 0\\\\f$\\n * * \\\\f$ (A {\\\\oplus} B) {\\\\oplus} C = A {\\\\oplus} (B {\\\\oplus} C)\\\\f$\\n * * \\\\f$ (B {\\\\oplus} A) {\\\\oplus} B = B {\\\\oplus} 0 = B \\\\f$\\n * \\n * \\n * where \\\\f$\\\\oplus\\\\f$ symbol denotes the exclusive disjunction (XOR) operation.\\n * This operation is sometimes called modulus 2 addition (or subtraction, which is identical).\\n * With this logic, a string of text can be encrypted by applying the bitwise XOR operator to\\n * every character using a given key. To decrypt the output, merely reapplying the XOR function \\n * with the key will remove the cipher.\\n * \\n * ### Algorithm\\n * Choose the key for encryption and apply XOR operation to each character of a string. \\n * Reapplying XOR operation to each character of encrypted string will give original string back.\\n * \\n * \\\\note This program implements XOR Cipher for string with ASCII characters. \\n * \\n * @author [Deep Raval](https://github.com/imdeep2905)\\n */\\n#include <iostream>\\n#include <string>\\n#include <cassert>\\n\\n/** \\\\namespace ciphers\\n * \\\\brief Algorithms for encryption and decryption\\n */\\nnamespace ciphers {\\n    /** \\\\namespace XOR\\n     * \\\\brief Functions for [XOR cipher](https://en.wikipedia.org/wiki/XOR_cipher) algorithm.\\n     */\\n    namespace XOR {   \\n        /**\\n         * Encrypt given text using XOR cipher.\\n         * @param text text to be encrypted\\n         * @param key to be used for encyption\\n         * @return new encrypted text\\n         */\\n        std::string encrypt (const std::string &text, const int &key) {\\n            std::string encrypted_text = \\\"\\\"; // Empty string to store encrypted text\\n            for (auto &c: text) { // Going through each character\\n                char encrypted_char = char(c ^ key); // Applying encyption\\n                encrypted_text += encrypted_char; // Appending encrypted character\\n            }\\n            return encrypted_text; // Returning encrypted text\\n        }\\n        /**\\n         * Decrypt given text using XOR cipher.\\n         * @param text text to be encrypted\\n         * @param key to be used for decryption\\n         * @return new decrypted text\\n         */        \\n        std::string decrypt (const std::string &text, const int &key) {\\n            std::string decrypted_text = \\\"\\\"; // Empty string to store decrypted text\\n            for (auto &c : text) { // Going through each character\\n                char decrypted_char = char(c ^ key); // Applying decryption\\n                decrypted_text += decrypted_char; // Appending decrypted character\\n            }\\n            return decrypted_text; // Returning decrypted text\\n        }\\n    } // namespace XOR\\n} // namespace ciphers\\n\\n/**\\n * Function to test above algorithm\\n */\\nvoid test() {\\n    // Test 1\\n    std::string text1 = \\\"Whipalsh! : Do watch this movie...\\\";\\n    std::string encrypted1 = ciphers::XOR::encrypt(text1, 17);\\n    std::string decrypted1 = ciphers::XOR::decrypt(encrypted1, 17);\\n    assert(text1 == decrypted1);\\n    std::cout << \\\"Original text : \\\" << text1;\\n    std::cout << \\\" , Encrypted text (with key = 17) : \\\" << encrypted1;\\n    std::cout << \\\" , Decrypted text : \\\"<< decrypted1 << std::endl;\\n    // Test 2\\n    std::string text2 = \\\"->Valar M0rghulis<-\\\";\\n    std::string encrypted2 = ciphers::XOR::encrypt(text2, 29);\\n    std::string decrypted2 = ciphers::XOR::decrypt(encrypted2, 29);\\n    assert(text2 == decrypted2);\\n    std::cout << \\\"Original text : \\\" << text2;\\n    std::cout << \\\" , Encrypted text (with key = 29) : \\\" << encrypted2;\\n    std::cout << \\\" , Decrypted text : \\\"<< decrypted2 << std::endl;\\n}\\n\\n/** Driver Code */\\nint main() {\\n    // Testing\\n    test();\\n    return 0;\\n}\\n\"",
    "fcfs scheduling": "\"/**\\n * @file\\n * @brief Implementation of FCFS CPU scheduling algorithm\\n * @details\\n * FCFS is a non-preemptive CPU scheduling algorithm in which whichever process\\n * arrives first, gets executed first. If two or more processes arrive\\n * simultaneously, the process with smaller process ID gets executed first.\\n * @link https://bit.ly/3ABNXOC\\n * @author [Pratyush Vatsa](https://github.com/Pratyush219)\\n */\\n\\n#include <algorithm>      /// for sorting\\n#include <cassert>        /// for assert\\n#include <cstdlib>        /// random number generation\\n#include <ctime>          /// for time\\n#include <iomanip>        /// for formatting the output\\n#include <iostream>       /// for IO operations\\n#include <queue>          /// for std::priority_queue\\n#include <unordered_set>  /// for std::unordered_set\\n#include <vector>         /// for std::vector\\n\\nusing std::cin;\\nusing std::cout;\\nusing std::endl;\\nusing std::get;\\nusing std::left;\\nusing std::make_tuple;\\nusing std::priority_queue;\\nusing std::rand;\\nusing std::srand;\\nusing std::tuple;\\nusing std::unordered_set;\\nusing std::vector;\\n/**\\n * @brief Comparator function for sorting a vector\\n * @tparam S Data type of Process ID\\n * @tparam T Data type of Arrival time\\n * @tparam E Data type of Burst time\\n * @param t1 First tuple\\n * @param t2 Second tuple\\n * @returns true if t1 and t2 are in the CORRECT order\\n * @returns false if t1 and t2 are in the INCORRECT order\\n */\\ntemplate <typename S, typename T, typename E>\\nbool sortcol(tuple<S, T, E>& t1, tuple<S, T, E>& t2) {\\n    if (get<1>(t1) < get<1>(t2)) {\\n        return true;\\n    } else if (get<1>(t1) == get<1>(t2) && get<0>(t1) < get<0>(t2)) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\n/**\\n * @class Compare\\n * @brief Comparator class for priority queue\\n * @tparam S Data type of Process ID\\n * @tparam T Data type of Arrival time\\n * @tparam E Data type of Burst time\\n */\\ntemplate <typename S, typename T, typename E>\\nclass Compare {\\n public:\\n    /**\\n     * @param t1 First tuple\\n     * @param t2 Second tuple\\n     * @brief A comparator function that checks whether to swap the two tuples\\n     * or not.\\n     * @link Refer to\\n     * https://www.geeksforgeeks.org/comparator-class-in-c-with-examples/ for\\n     * detailed description of comparator\\n     * @returns true if the tuples SHOULD be swapped\\n     * @returns false if the tuples SHOULDN'T be swapped\\n     */\\n    bool operator()(tuple<S, T, E, double, double, double>& t1,\\n                    tuple<S, T, E, double, double, double>& t2) {\\n        // Compare arrival times\\n        if (get<1>(t2) < get<1>(t1)) {\\n            return true;\\n        }\\n        // If arrival times are same, then compare Process IDs\\n        else if (get<1>(t2) == get<1>(t1)) {\\n            return get<0>(t2) < get<0>(t1);\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * @class FCFS\\n * @brief Class which implements the FCFS scheduling algorithm\\n * @tparam S Data type of Process ID\\n * @tparam T Data type of Arrival time\\n * @tparam E Data type of Burst time\\n */\\ntemplate <typename S, typename T, typename E>\\nclass FCFS {\\n    /**\\n     * Priority queue of schedules(stored as tuples) of processes.\\n     * In each tuple\\n     * 1st element: Process ID\\n     * 2nd element: Arrival Time\\n     * 3rd element: Burst time\\n     * 4th element: Completion time\\n     * 5th element: Turnaround time\\n     * 6th element: Waiting time\\n     */\\n    priority_queue<tuple<S, T, E, double, double, double>,\\n                   vector<tuple<S, T, E, double, double, double>>,\\n                   Compare<S, T, E>>\\n        schedule;\\n\\n    // Stores final status of all the processes after completing the execution.\\n    vector<tuple<S, T, E, double, double, double>> result;\\n\\n    // Stores process IDs. Used for confirming absence of a process while adding\\n    // it.\\n    unordered_set<S> idList;\\n\\n public:\\n    /**\\n     * @brief Adds the process to the ready queue if it isn't already there\\n     * @param id Process ID\\n     * @param arrival Arrival time of the process\\n     * @param burst Burst time of the process\\n     * @returns void\\n     *\\n     */\\n    void addProcess(S id, T arrival, E burst) {\\n        // Add if a process with process ID as id is not found in idList.\\n        if (idList.find(id) == idList.end()) {\\n            tuple<S, T, E, double, double, double> t =\\n                make_tuple(id, arrival, burst, 0, 0, 0);\\n            schedule.push(t);\\n            idList.insert(id);\\n        }\\n    }\\n\\n    /**\\n     * @brief Algorithm for scheduling CPU processes according to the First Come\\n     * First Serve(FCFS) scheduling algorithm.\\n     *\\n     * @details FCFS is a non-preemptive algorithm in which the process which\\n     * arrives first gets executed first. If two or more processes arrive\\n     * together then the process with smaller process ID runs first (each\\n     * process has a unique proces ID).\\n     *\\n     * I used a min priority queue of tuples to accomplish this task. The\\n     * processes are ordered by their arrival times. If arrival times of some\\n     * processes are equal, then they are ordered by their process ID.\\n     *\\n     * @returns void\\n     */\\n    vector<tuple<S, T, E, double, double, double>> scheduleForFcfs() {\\n        // Variable to keep track of time elapsed so far\\n        double timeElapsed = 0;\\n\\n        while (!schedule.empty()) {\\n            tuple<S, T, E, double, double, double> cur = schedule.top();\\n\\n            // If the current process arrived at time t2, the last process\\n            // completed its execution at time t1, and t2 > t1.\\n            if (get<1>(cur) > timeElapsed) {\\n                timeElapsed += get<1>(cur) - timeElapsed;\\n            }\\n\\n            // Add Burst time to time elapsed\\n            timeElapsed += get<2>(cur);\\n\\n            // Completion time of the current process will be same as time\\n            // elapsed so far\\n            get<3>(cur) = timeElapsed;\\n\\n            // Turnaround time = Completion time - Arrival time\\n            get<4>(cur) = get<3>(cur) - get<1>(cur);\\n\\n            // Waiting time = Turnaround time - Burst time\\n            get<5>(cur) = get<4>(cur) - get<2>(cur);\\n\\n            result.push_back(cur);\\n            schedule.pop();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @brief Utility function for printing the status of each process after\\n     * execution\\n     * @returns void\\n     */\\n    void printResult() {\\n        cout << \\\"Status of all the proceses post completion is as follows:\\\"\\n             << endl;\\n\\n        cout << std::setw(17) << left << \\\"Process ID\\\" << std::setw(17) << left\\n             << \\\"Arrival Time\\\" << std::setw(17) << left << \\\"Burst Time\\\"\\n             << std::setw(17) << left << \\\"Completion Time\\\" << std::setw(17)\\n             << left << \\\"Turnaround Time\\\" << std::setw(17) << left\\n             << \\\"Waiting Time\\\" << endl;\\n\\n        for (size_t i{}; i < result.size(); i++) {\\n            cout << std::setprecision(2) << std::fixed << std::setw(17) << left\\n                 << get<0>(result[i]) << std::setw(17) << left\\n                 << get<1>(result[i]) << std::setw(17) << left\\n                 << get<2>(result[i]) << std::setw(17) << left\\n                 << get<3>(result[i]) << std::setw(17) << left\\n                 << get<4>(result[i]) << std::setw(17) << left\\n                 << get<5>(result[i]) << endl;\\n        }\\n    }\\n};\\n\\n/**\\n * @brief Function to be used for testing purposes. This function guarantees the\\n * correct solution for FCFS scheduling algorithm.\\n * @param input the input data\\n * @details Sorts the input vector according to arrival time. Processes whose\\n * arrival times are same get sorted according to process ID For each process,\\n * completion time, turnaround time and completion time are calculated, inserted\\n * in a tuple, which is added to the vector result.\\n * @returns A vector of tuples consisting of process ID, arrival time, burst\\n * time, completion time, turnaround time and waiting time for each process.\\n */\\ntemplate <typename S, typename T, typename E>\\nvector<tuple<S, T, E, double, double, double>> get_final_status(\\n    vector<tuple<uint32_t, uint32_t, uint32_t>> input) {\\n    sort(input.begin(), input.end(), sortcol<S, T, E>);\\n    vector<tuple<S, T, E, double, double, double>> result(input.size());\\n    double timeElapsed = 0;\\n    for (size_t i{}; i < input.size(); i++) {\\n        T arrival = get<1>(input[i]);\\n        E burst = get<2>(input[i]);\\n\\n        if (arrival > timeElapsed) {\\n            timeElapsed += arrival - timeElapsed;\\n        }\\n        timeElapsed += burst;\\n        double completion = timeElapsed;\\n        double turnaround = completion - arrival;\\n        double waiting = turnaround - burst;\\n\\n        get<0>(result[i]) = get<0>(input[i]);\\n        get<1>(result[i]) = arrival;\\n        get<2>(result[i]) = burst;\\n        get<3>(result[i]) = completion;\\n        get<4>(result[i]) = turnaround;\\n        get<5>(result[i]) = waiting;\\n    }\\n    return result;\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    for (int i{}; i < 1000; i++) {\\n        srand(time(nullptr));\\n        uint32_t n = 1 + rand() % 1000;\\n        FCFS<uint32_t, uint32_t, uint32_t> readyQueue;\\n        vector<tuple<uint32_t, uint32_t, uint32_t>> input(n);\\n\\n        for (uint32_t i{}; i < n; i++) {\\n            get<0>(input[i]) = i;\\n            srand(time(nullptr));\\n            get<1>(input[i]) = 1 + rand() % 10000;\\n            srand(time(nullptr));\\n            get<2>(input[i]) = 1 + rand() % 10000;\\n        }\\n\\n        for (uint32_t i{}; i < n; i++) {\\n            readyQueue.addProcess(get<0>(input[i]), get<1>(input[i]),\\n                                  get<2>(input[i]));\\n        }\\n        vector<tuple<uint32_t, uint32_t, uint32_t, double, double, double>>\\n            res = get_final_status<uint32_t, uint32_t, uint32_t>(input);\\n        assert(res == readyQueue.scheduleForFcfs());\\n        // readyQueue.printResult();\\n    }\\n    cout << \\\"All the tests have successfully passed!\\\" << endl;\\n}\\n\\n/**\\n * @brief Entry point of the program\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "avltree": "\"/**\\n * \\\\file\\n * \\\\brief A simple tree implementation using nodes\\n *\\n * \\\\todo update code to use C++ STL library features and OO structure\\n * \\\\warning This program is a poor implementation and does not utilize any of\\n * the C++ STL features.\\n */\\n#include <algorithm>\\n#include <iostream>\\n#include <queue>\\n\\ntypedef struct node {\\n    int data;\\n    int height;\\n    struct node *left;\\n    struct node *right;\\n} node;\\n\\n/** Create and return a new Node */\\nnode *createNode(int data) {\\n    node *nn = new node();\\n    nn->data = data;\\n    nn->height = 0;\\n    nn->left = NULL;\\n    nn->right = NULL;\\n    return nn;\\n}\\n\\n/** Returns height of tree */\\nint height(node *root) {\\n    if (root == NULL)\\n        return 0;\\n    return 1 + std::max(height(root->left), height(root->right));\\n}\\n\\n/** Returns difference between height of left and right subtree */\\nint getBalance(node *root) { return height(root->left) - height(root->right); }\\n\\n/** Returns Node after Right Rotation */\\nnode *rightRotate(node *root) {\\n    node *t = root->left;\\n    node *u = t->right;\\n    t->right = root;\\n    root->left = u;\\n    return t;\\n}\\n\\n/** Returns Node after Left Rotation */\\nnode *leftRotate(node *root) {\\n    node *t = root->right;\\n    node *u = t->left;\\n    t->left = root;\\n    root->right = u;\\n    return t;\\n}\\n\\n/** Returns node with minimum value in the tree */\\nnode *minValue(node *root) {\\n    if (root->left == NULL)\\n        return root;\\n    return minValue(root->left);\\n}\\n\\n/** Balanced Insertion */\\nnode *insert(node *root, int item) {\\n    node *nn = createNode(item);\\n    if (root == NULL)\\n        return nn;\\n    if (item < root->data)\\n        root->left = insert(root->left, item);\\n    else\\n        root->right = insert(root->right, item);\\n    int b = getBalance(root);\\n    if (b > 1) {\\n        if (getBalance(root->left) < 0)\\n            root->left = leftRotate(root->left);  // Left-Right Case\\n        return rightRotate(root);                 // Left-Left Case\\n    } else if (b < -1) {\\n        if (getBalance(root->right) > 0)\\n            root->right = rightRotate(root->right);  // Right-Left Case\\n        return leftRotate(root);                     // Right-Right Case\\n    }\\n    return root;\\n}\\n\\n/** Balanced Deletion */\\nnode *deleteNode(node *root, int key) {\\n    if (root == NULL)\\n        return root;\\n    if (key < root->data)\\n        root->left = deleteNode(root->left, key);\\n    else if (key > root->data)\\n        root->right = deleteNode(root->right, key);\\n\\n    else {\\n        // Node to be deleted is leaf node or have only one Child\\n        if (!root->right) {\\n            node *temp = root->left;\\n            delete (root);\\n            root = NULL;\\n            return temp;\\n        } else if (!root->left) {\\n            node *temp = root->right;\\n            delete (root);\\n            root = NULL;\\n            return temp;\\n        }\\n        // Node to be deleted have both left and right subtrees\\n        node *temp = minValue(root->right);\\n        root->data = temp->data;\\n        root->right = deleteNode(root->right, temp->data);\\n    }\\n    // Balancing Tree after deletion\\n    return root;\\n}\\n\\n/** LevelOrder (Breadth First Search) */\\nvoid levelOrder(node *root) {\\n    std::queue<node *> q;\\n    q.push(root);\\n    while (!q.empty()) {\\n        root = q.front();\\n        std::cout << root->data << \\\" \\\";\\n        q.pop();\\n        if (root->left)\\n            q.push(root->left);\\n        if (root->right)\\n            q.push(root->right);\\n    }\\n}\\n\\n/** Main function */\\nint main() {\\n    // Testing AVL Tree\\n    node *root = NULL;\\n    int i;\\n    for (i = 1; i <= 7; i++) root = insert(root, i);\\n    std::cout << \\\"LevelOrder: \\\";\\n    levelOrder(root);\\n    root = deleteNode(root, 1);  // Deleting key with value 1\\n    std::cout << \\\"\\\\nLevelOrder: \\\";\\n    levelOrder(root);\\n    root = deleteNode(root, 4);  // Deletin key with value 4\\n    std::cout << \\\"\\\\nLevelOrder: \\\";\\n    levelOrder(root);\\n    return 0;\\n}\\n\"",
    "binaryheap": "\"/**\\n * \\\\file\\n * \\\\brief A C++ program to demonstrate common Binary Heap Operations\\n */\\n#include <climits>\\n#include <iostream>\\n#include <utility>\\n\\n/** A class for Min Heap */\\nclass MinHeap {\\n    int *harr;      ///< pointer to array of elements in heap\\n    int capacity;   ///< maximum possible size of min heap\\n    int heap_size;  ///< Current number of elements in min heap\\n\\n public:\\n    /** Constructor: Builds a heap from a given array a[] of given size\\n     * \\\\param[in] capacity initial heap capacity\\n     */\\n    explicit MinHeap(int cap) {\\n        heap_size = 0;\\n        capacity = cap;\\n        harr = new int[cap];\\n    }\\n\\n    /** to heapify a subtree with the root at given index */\\n    void MinHeapify(int);\\n\\n    int parent(int i) { return (i - 1) / 2; }\\n\\n    /** to get index of left child of node at index i */\\n    int left(int i) { return (2 * i + 1); }\\n\\n    /** to get index of right child of node at index i */\\n    int right(int i) { return (2 * i + 2); }\\n\\n    /** to extract the root which is the minimum element */\\n    int extractMin();\\n\\n    /** Decreases key value of key at index i to new_val */\\n    void decreaseKey(int i, int new_val);\\n\\n    /** Returns the minimum key (key at root) from min heap */\\n    int getMin() { return harr[0]; }\\n\\n    /** Deletes a key stored at index i */\\n    void deleteKey(int i);\\n\\n    /** Inserts a new key 'k' */\\n    void insertKey(int k);\\n\\n    ~MinHeap() { delete[] harr; }\\n};\\n\\n// Inserts a new key 'k'\\nvoid MinHeap::insertKey(int k) {\\n    if (heap_size == capacity) {\\n        std::cout << \\\"\\\\nOverflow: Could not insertKey\\\\n\\\";\\n        return;\\n    }\\n\\n    // First insert the new key at the end\\n    heap_size++;\\n    int i = heap_size - 1;\\n    harr[i] = k;\\n\\n    // Fix the min heap property if it is violated\\n    while (i != 0 && harr[parent(i)] > harr[i]) {\\n        std::swap(harr[i], harr[parent(i)]);\\n        i = parent(i);\\n    }\\n}\\n\\n/** Decreases value of key at index 'i' to new_val.  It is assumed that new_val\\n * is smaller than harr[i].\\n */\\nvoid MinHeap::decreaseKey(int i, int new_val) {\\n    harr[i] = new_val;\\n    while (i != 0 && harr[parent(i)] > harr[i]) {\\n        std::swap(harr[i], harr[parent(i)]);\\n        i = parent(i);\\n    }\\n}\\n\\n// Method to remove minimum element (or root) from min heap\\nint MinHeap::extractMin() {\\n    if (heap_size <= 0)\\n        return INT_MAX;\\n    if (heap_size == 1) {\\n        heap_size--;\\n        return harr[0];\\n    }\\n\\n    // Store the minimum value, and remove it from heap\\n    int root = harr[0];\\n    harr[0] = harr[heap_size - 1];\\n    heap_size--;\\n    MinHeapify(0);\\n\\n    return root;\\n}\\n\\n/** This function deletes key at index i. It first reduced value to minus\\n * infinite, then calls extractMin()\\n */\\nvoid MinHeap::deleteKey(int i) {\\n    decreaseKey(i, INT_MIN);\\n    extractMin();\\n}\\n\\n/** A recursive method to heapify a subtree with the root at given index\\n *  This method assumes that the subtrees are already heapified\\n */\\nvoid MinHeap::MinHeapify(int i) {\\n    int l = left(i);\\n    int r = right(i);\\n    int smallest = i;\\n    if (l < heap_size && harr[l] < harr[i])\\n        smallest = l;\\n    if (r < heap_size && harr[r] < harr[smallest])\\n        smallest = r;\\n    if (smallest != i) {\\n        std::swap(harr[i], harr[smallest]);\\n        MinHeapify(smallest);\\n    }\\n}\\n\\n// Driver program to test above functions\\nint main() {\\n    MinHeap h(11);\\n    h.insertKey(3);\\n    h.insertKey(2);\\n    h.deleteKey(1);\\n    h.insertKey(15);\\n    h.insertKey(5);\\n    h.insertKey(4);\\n    h.insertKey(45);\\n    std::cout << h.extractMin() << \\\" \\\";\\n    std::cout << h.getMin() << \\\" \\\";\\n    h.decreaseKey(2, 1);\\n    std::cout << h.getMin();\\n    return 0;\\n}\\n\"",
    "binary search tree": "\"/**\\n * \\\\file\\n * \\\\brief A simple tree implementation using structured nodes\\n *\\n * \\\\todo update code to use C++ STL library features and OO structure\\n * \\\\warning This program is a poor implementation - C style - and does not\\n * utilize any of the C++ STL features.\\n */\\n#include <iostream>\\n\\nstruct node {\\n    int val;\\n    node *left;\\n    node *right;\\n};\\n\\nstruct Queue {\\n    node *t[100];\\n    int front;\\n    int rear;\\n};\\n\\nQueue queue;\\n\\nvoid enqueue(node *n) { queue.t[queue.rear++] = n; }\\n\\nnode *dequeue() { return (queue.t[queue.front++]); }\\n\\nvoid Insert(node *n, int x) {\\n    if (x < n->val) {\\n        if (n->left == NULL) {\\n            node *temp = new node;\\n            temp->val = x;\\n            temp->left = NULL;\\n            temp->right = NULL;\\n            n->left = temp;\\n        } else {\\n            Insert(n->left, x);\\n        }\\n    } else {\\n        if (n->right == NULL) {\\n            node *temp = new node;\\n            temp->val = x;\\n            temp->left = NULL;\\n            temp->right = NULL;\\n            n->right = temp;\\n        } else {\\n            Insert(n->right, x);\\n        }\\n    }\\n}\\n\\nint findMaxInLeftST(node *n) {\\n    while (n->right != NULL) {\\n        n = n->right;\\n    }\\n    return n->val;\\n}\\n\\nvoid Remove(node *p, node *n, int x) {\\n    if (n->val == x) {\\n        if (n->right == NULL && n->left == NULL) {\\n            if (x < p->val) {\\n                p->right = NULL;\\n            } else {\\n                p->left = NULL;\\n            }\\n        } else if (n->right == NULL) {\\n            if (x < p->val) {\\n                p->right = n->left;\\n            } else {\\n                p->left = n->left;\\n            }\\n        } else if (n->left == NULL) {\\n            if (x < p->val) {\\n                p->right = n->right;\\n            } else {\\n                p->left = n->right;\\n            }\\n        } else {\\n            int y = findMaxInLeftST(n->left);\\n            n->val = y;\\n            Remove(n, n->right, y);\\n        }\\n    } else if (x < n->val) {\\n        Remove(n, n->left, x);\\n    } else {\\n        Remove(n, n->right, x);\\n    }\\n}\\n\\nvoid BFT(node *n) {\\n    if (n != NULL) {\\n        std::cout << n->val << \\\"  \\\";\\n        enqueue(n->left);\\n        enqueue(n->right);\\n        BFT(dequeue());\\n    }\\n}\\n\\nvoid Pre(node *n) {\\n    if (n != NULL) {\\n        std::cout << n->val << \\\"  \\\";\\n        Pre(n->left);\\n        Pre(n->right);\\n    }\\n}\\n\\nvoid In(node *n) {\\n    if (n != NULL) {\\n        In(n->left);\\n        std::cout << n->val << \\\"  \\\";\\n        In(n->right);\\n    }\\n}\\n\\nvoid Post(node *n) {\\n    if (n != NULL) {\\n        Post(n->left);\\n        Post(n->right);\\n        std::cout << n->val << \\\"  \\\";\\n    }\\n}\\n\\nint main() {\\n    queue.front = 0;\\n    queue.rear = 0;\\n    int value;\\n    int ch;\\n    node *root = new node;\\n    std::cout << \\\"\\\\nEnter the value of root node :\\\";\\n    std::cin >> value;\\n    root->val = value;\\n    root->left = NULL;\\n    root->right = NULL;\\n    do {\\n        std::cout << \\\"\\\\n1. Insert\\\"\\n                  << \\\"\\\\n2. Delete\\\"\\n                  << \\\"\\\\n3. Breadth First\\\"\\n                  << \\\"\\\\n4. Preorder Depth First\\\"\\n                  << \\\"\\\\n5. Inorder Depth First\\\"\\n                  << \\\"\\\\n6. Postorder Depth First\\\";\\n\\n        std::cout << \\\"\\\\nEnter Your Choice : \\\";\\n        std::cin >> ch;\\n        int x;\\n        switch (ch) {\\n        case 1:\\n            std::cout << \\\"\\\\nEnter the value to be Inserted : \\\";\\n            std::cin >> x;\\n            Insert(root, x);\\n            break;\\n        case 2:\\n            std::cout << \\\"\\\\nEnter the value to be Deleted : \\\";\\n            std::cin >> x;\\n            Remove(root, root, x);\\n            break;\\n        case 3:\\n            BFT(root);\\n            break;\\n        case 4:\\n            Pre(root);\\n            break;\\n        case 5:\\n            In(root);\\n            break;\\n        case 6:\\n            Post(root);\\n            break;\\n        }\\n    } while (ch != 0);\\n\\n    return 0;\\n}\\n\"",
    "binary search tree2": "\"/**\\n * @file\\n * @brief A generic [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree) implementation.\\n * @see binary_search_tree.cpp\\n */\\n\\n#include <cassert>\\n#include <functional>\\n#include <iostream>\\n#include <memory>\\n#include <vector>\\n\\n/**\\n * @brief The Binary Search Tree class.\\n *\\n * @tparam T The type of the binary search tree key.\\n */\\ntemplate <class T>\\nclass binary_search_tree {\\n private:\\n    /**\\n    * @brief A struct to represent a node in the Binary Search Tree.\\n    */\\n    struct bst_node {\\n        T value; /**< The value/key of the node. */\\n        std::unique_ptr<bst_node> left; /**< Pointer to left subtree. */\\n        std::unique_ptr<bst_node> right; /**< Pointer to right subtree. */\\n\\n        /**\\n        * Constructor for bst_node, used to simplify node construction and\\n        * smart pointer construction.\\n        * @param _value The value of the constructed node.\\n        */\\n        explicit bst_node(T _value) {\\n            value = _value;\\n            left = nullptr;\\n            right = nullptr;\\n        }\\n    };\\n\\n    std::unique_ptr<bst_node> root_; /**< Pointer to the root of the BST. */\\n    std::size_t size_ = 0; /**< Number of elements/nodes in the BST. */\\n\\n    /**\\n     * @brief Recursive function to find the maximum value in the BST.\\n     *\\n     * @param node The node to search from.\\n     * @param ret_value Variable to hold the maximum value.\\n     * @return true If the maximum value was successfully found.\\n     * @return false Otherwise.\\n     */\\n    bool find_max(std::unique_ptr<bst_node>& node, T& ret_value) {\\n        if (!node) {\\n            return false;\\n        } else if (!node->right) {\\n            ret_value = node->value;\\n            return true;\\n        }\\n        return find_max(node->right, ret_value);\\n    }\\n\\n    /**\\n     * @brief Recursive function to find the minimum value in the BST.\\n     *\\n     * @param node The node to search from.\\n     * @param ret_value Variable to hold the minimum value.\\n     * @return true If the minimum value was successfully found.\\n     * @return false Otherwise.\\n     */\\n    bool find_min(std::unique_ptr<bst_node>& node, T& ret_value) {\\n        if (!node) {\\n            return false;\\n        } else if (!node->left) {\\n            ret_value = node->value;\\n            return true;\\n        }\\n\\n        return find_min(node->left, ret_value);\\n    }\\n\\n    /**\\n     * @brief Recursive function to insert a value into the BST.\\n     *\\n     * @param node The node to search from.\\n     * @param new_value The value to insert.\\n     * @return true If the insert operation was successful.\\n     * @return false Otherwise.\\n     */\\n    bool insert(std::unique_ptr<bst_node>& node, T new_value) {\\n        if (root_ == node && !root_) {\\n            root_ = std::unique_ptr<bst_node>(new bst_node(new_value));\\n            return true;\\n        }\\n\\n        if (new_value < node->value) {\\n            if (!node->left) {\\n                node->left = std::unique_ptr<bst_node>(new bst_node(new_value));\\n                return true;\\n            } else {\\n                return insert(node->left, new_value);\\n            }\\n        } else if (new_value > node->value) {\\n            if (!node->right) {\\n                node->right =\\n                    std::unique_ptr<bst_node>(new bst_node(new_value));\\n                return true;\\n            } else {\\n                return insert(node->right, new_value);\\n            }\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @brief Recursive function to remove a value from the BST.\\n     *\\n     * @param parent The parent node of node.\\n     * @param node The node to search from.\\n     * @param rm_value The value to remove.\\n     * @return true If the removal operation was successful.\\n     * @return false Otherwise.\\n     */\\n    bool remove(std::unique_ptr<bst_node>& parent,\\n                std::unique_ptr<bst_node>& node, T rm_value) {\\n        if (!node) {\\n            return false;\\n        }\\n\\n        if (node->value == rm_value) {\\n            if (node->left && node->right) {\\n                T successor_node_value{};\\n                find_max(node->left, successor_node_value);\\n                remove(root_, root_, successor_node_value);\\n                node->value = successor_node_value;\\n                return true;\\n            } else if (node->left || node->right) {\\n                std::unique_ptr<bst_node>& non_null =\\n                    (node->left ? node->left : node->right);\\n\\n                if (node == root_) {\\n                    root_ = std::move(non_null);\\n                } else if (rm_value < parent->value) {\\n                    parent->left = std::move(non_null);\\n                } else {\\n                    parent->right = std::move(non_null);\\n                }\\n\\n                return true;\\n            } else {\\n                if (node == root_) {\\n                    root_.reset(nullptr);\\n                } else if (rm_value < parent->value) {\\n                    parent->left.reset(nullptr);\\n                } else {\\n                    parent->right.reset(nullptr);\\n                }\\n\\n                return true;\\n            }\\n        } else if (rm_value < node->value) {\\n            return remove(node, node->left, rm_value);\\n        } else {\\n            return remove(node, node->right, rm_value);\\n        }\\n    }\\n\\n    /**\\n     * @brief Recursive function to check if a value is in the BST.\\n     *\\n     * @param node The node to search from.\\n     * @param value The value to find.\\n     * @return true If the value was found in the BST.\\n     * @return false Otherwise.\\n     */\\n    bool contains(std::unique_ptr<bst_node>& node, T value) {\\n        if (!node) {\\n            return false;\\n        }\\n\\n        if (value < node->value) {\\n            return contains(node->left, value);\\n        } else if (value > node->value) {\\n            return contains(node->right, value);\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @brief Recursive function to traverse the tree in in-order order.\\n     *\\n     * @param callback Function that is called when a value needs to processed.\\n     * @param node The node to traverse from.\\n     */\\n    void traverse_inorder(std::function<void(T)> callback,\\n                          std::unique_ptr<bst_node>& node) {\\n        if (!node) {\\n            return;\\n        }\\n\\n        traverse_inorder(callback, node->left);\\n        callback(node->value);\\n        traverse_inorder(callback, node->right);\\n    }\\n\\n    /**\\n     * @brief Recursive function to traverse the tree in pre-order order.\\n     *\\n     * @param callback Function that is called when a value needs to processed.\\n     * @param node The node to traverse from.\\n     */\\n    void traverse_preorder(std::function<void(T)> callback,\\n                           std::unique_ptr<bst_node>& node) {\\n        if (!node) {\\n            return;\\n        }\\n\\n        callback(node->value);\\n        traverse_preorder(callback, node->left);\\n        traverse_preorder(callback, node->right);\\n    }\\n\\n    /**\\n     * @brief Recursive function to traverse the tree in post-order order.\\n     *\\n     * @param callback Function that is called when a value needs to processed.\\n     * @param node The node to traverse from.\\n     */\\n    void traverse_postorder(std::function<void(T)> callback,\\n                            std::unique_ptr<bst_node>& node) {\\n        if (!node) {\\n            return;\\n        }\\n\\n        traverse_postorder(callback, node->left);\\n        traverse_postorder(callback, node->right);\\n        callback(node->value);\\n    }\\n\\n public:\\n    /**\\n     * @brief Construct a new Binary Search Tree object.\\n     *\\n     */\\n    binary_search_tree() {\\n        root_ = nullptr;\\n        size_ = 0;\\n    }\\n\\n    /**\\n     * @brief Insert a new value into the BST.\\n     *\\n     * @param new_value The value to insert into the BST.\\n     * @return true If the insertion was successful.\\n     * @return false Otherwise.\\n     */\\n    bool insert(T new_value) {\\n        bool result = insert(root_, new_value);\\n        if (result) {\\n            size_++;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @brief Remove a specified value from the BST.\\n     *\\n     * @param rm_value The value to remove.\\n     * @return true If the removal was successful.\\n     * @return false Otherwise.\\n     */\\n    bool remove(T rm_value) {\\n        bool result = remove(root_, root_, rm_value);\\n        if (result) {\\n            size_--;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @brief Check if a value is in the BST.\\n     *\\n     * @param value The value to find.\\n     * @return true If value is in the BST.\\n     * @return false Otherwise.\\n     */\\n    bool contains(T value) { return contains(root_, value); }\\n\\n    /**\\n     * @brief Find the smallest value in the BST.\\n     *\\n     * @param ret_value Variable to hold the minimum value.\\n     * @return true If minimum value was successfully found.\\n     * @return false Otherwise.\\n     */\\n    bool find_min(T& ret_value) { return find_min(root_, ret_value); }\\n\\n    /**\\n     * @brief Find the largest value in the BST.\\n     *\\n     * @param ret_value Variable to hold the maximum value.\\n     * @return true If maximum value was successfully found.\\n     * @return false Otherwise.\\n     */\\n    bool find_max(T& ret_value) { return find_max(root_, ret_value); }\\n\\n    /**\\n     * @brief Get the number of values in the BST.\\n     *\\n     * @return std::size_t Number of values in the BST.\\n     */\\n    std::size_t size() { return size_; }\\n\\n    /**\\n     * @brief Get all values of the BST in in-order order.\\n     *\\n     * @return std::vector<T> List of values, sorted in in-order order.\\n     */\\n    std::vector<T> get_elements_inorder() {\\n        std::vector<T> result;\\n        traverse_inorder([&](T node_value) { result.push_back(node_value); },\\n                         root_);\\n        return result;\\n    }\\n\\n    /**\\n     * @brief Get all values of the BST in pre-order order.\\n     *\\n     * @return std::vector<T> List of values, sorted in pre-order order.\\n     */\\n    std::vector<T> get_elements_preorder() {\\n        std::vector<T> result;\\n        traverse_preorder([&](T node_value) { result.push_back(node_value); },\\n                          root_);\\n        return result;\\n    }\\n\\n    /**\\n     * @brief Get all values of the BST in post-order order.\\n     *\\n     * @return std::vector<T> List of values, sorted in post-order order.\\n     */\\n    std::vector<T> get_elements_postorder() {\\n        std::vector<T> result;\\n        traverse_postorder([&](T node_value) { result.push_back(node_value); },\\n                           root_);\\n        return result;\\n    }\\n};\\n\\n/**\\n * @brief Function for testing insert().\\n * \\n * @returns `void`\\n */\\nstatic void test_insert() {\\n    std::cout << \\\"Testing BST insert...\\\";\\n\\n    binary_search_tree<int> tree;\\n    bool res = tree.insert(5);\\n    int min = -1, max = -1;\\n    assert(res);\\n    assert(tree.find_max(max));\\n    assert(tree.find_min(min));\\n    assert(max == 5);\\n    assert(min == 5);\\n    assert(tree.size() == 1);\\n\\n    tree.insert(4);\\n    tree.insert(3);\\n    tree.insert(6);\\n    assert(tree.find_max(max));\\n    assert(tree.find_min(min));\\n    assert(max == 6);\\n    assert(min == 3);\\n    assert(tree.size() == 4);\\n\\n    bool fail_res = tree.insert(4);\\n    assert(!fail_res);\\n    assert(tree.size() == 4);\\n\\n    std::cout << \\\"ok\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Function for testing remove().\\n * \\n * @returns `void`\\n */\\nstatic void test_remove() {\\n    std::cout << \\\"Testing BST remove...\\\";\\n\\n    binary_search_tree<int> tree;\\n    tree.insert(5);\\n    tree.insert(4);\\n    tree.insert(3);\\n    tree.insert(6);\\n\\n    bool res = tree.remove(5);\\n    int min = -1, max = -1;\\n    assert(res);\\n    assert(tree.find_max(max));\\n    assert(tree.find_min(min));\\n    assert(max == 6);\\n    assert(min == 3);\\n    assert(tree.size() == 3);\\n    assert(tree.contains(5) == false);\\n\\n    tree.remove(4);\\n    tree.remove(3);\\n    tree.remove(6);\\n    assert(tree.size() == 0);\\n    assert(tree.contains(6) == false);\\n\\n    bool fail_res = tree.remove(5);\\n    assert(!fail_res);\\n    assert(tree.size() == 0);\\n\\n    std::cout << \\\"ok\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Function for testing contains().\\n * \\n * @returns `void`\\n */\\nstatic void test_contains() {\\n    std::cout << \\\"Testing BST contains...\\\";\\n\\n    binary_search_tree<int> tree;\\n    tree.insert(5);\\n    tree.insert(4);\\n    tree.insert(3);\\n    tree.insert(6);\\n\\n    assert(tree.contains(5));\\n    assert(tree.contains(4));\\n    assert(tree.contains(3));\\n    assert(tree.contains(6));\\n    assert(!tree.contains(999));\\n\\n    std::cout << \\\"ok\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Function for testing find_min().\\n * \\n * @returns `void`\\n */\\nstatic void test_find_min() {\\n    std::cout << \\\"Testing BST find_min...\\\";\\n\\n    int min = 0;\\n    binary_search_tree<int> tree;\\n    assert(!tree.find_min(min));\\n\\n    tree.insert(5);\\n    tree.insert(4);\\n    tree.insert(3);\\n    tree.insert(6);\\n\\n    assert(tree.find_min(min));\\n    assert(min == 3);\\n\\n    std::cout << \\\"ok\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Function for testing find_max().\\n * \\n * @returns `void`\\n */\\nstatic void test_find_max() {\\n    std::cout << \\\"Testing BST find_max...\\\";\\n\\n    int max = 0;\\n    binary_search_tree<int> tree;\\n    assert(!tree.find_max(max));\\n\\n    tree.insert(5);\\n    tree.insert(4);\\n    tree.insert(3);\\n    tree.insert(6);\\n\\n    assert(tree.find_max(max));\\n    assert(max == 6);\\n\\n    std::cout << \\\"ok\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Function for testing get_elements_inorder().\\n * \\n * @returns `void`\\n */\\nstatic void test_get_elements_inorder() {\\n    std::cout << \\\"Testing BST get_elements_inorder...\\\";\\n\\n    binary_search_tree<int> tree;\\n    tree.insert(5);\\n    tree.insert(4);\\n    tree.insert(3);\\n    tree.insert(6);\\n\\n    std::vector<int> expected = {3, 4, 5, 6};\\n    std::vector<int> actual = tree.get_elements_inorder();\\n    assert(actual == expected);\\n\\n    std::cout << \\\"ok\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Function for testing get_elements_preorder().\\n * \\n * @returns `void`\\n */\\nstatic void test_get_elements_preorder() {\\n    std::cout << \\\"Testing BST get_elements_preorder...\\\";\\n\\n    binary_search_tree<int> tree;\\n    tree.insert(5);\\n    tree.insert(4);\\n    tree.insert(3);\\n    tree.insert(6);\\n\\n    std::vector<int> expected = {5, 4, 3, 6};\\n    std::vector<int> actual = tree.get_elements_preorder();\\n    assert(actual == expected);\\n\\n    std::cout << \\\"ok\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Function for testing get_elements_postorder().\\n * \\n * @returns `void`\\n */\\nstatic void test_get_elements_postorder() {\\n    std::cout << \\\"Testing BST get_elements_postorder...\\\";\\n\\n    binary_search_tree<int> tree;\\n    tree.insert(5);\\n    tree.insert(4);\\n    tree.insert(3);\\n    tree.insert(6);\\n\\n    std::vector<int> expected = {3, 4, 6, 5};\\n    std::vector<int> actual = tree.get_elements_postorder();\\n    assert(actual == expected);\\n\\n    std::cout << \\\"ok\\\" << std::endl;\\n}\\n\\nint main() {\\n    test_insert();\\n    test_remove();\\n    test_contains();\\n    test_find_max();\\n    test_find_min();\\n    test_get_elements_inorder();\\n    test_get_elements_preorder();\\n    test_get_elements_postorder();\\n}\\n\"",
    "circular queue using linked list": "\"#include <iostream>\\n\\nstruct node {\\n    int data;\\n    struct node* next;\\n};\\nclass Queue {\\n    node* front=nullptr;\\n    node* rear=nullptr;\\n\\npublic:\\n    Queue() = default; \\n    void createNode(int val) {\\n        auto* nn = new node;\\n        nn->data = val;\\n        nn->next = nullptr;\\n        front = nn;\\n        rear = nn;\\n    }\\n    void enqueue(int val) {\\n        if (front == nullptr || rear == nullptr) {\\n            createNode(val);\\n        }\\n        else {\\n            node* nn;\\n            nn = new node;\\n            nn->data = val;\\n            rear->next = nn;\\n            nn->next = front;\\n            rear = nn;\\n        }\\n    }\\n    void dequeue() {\\n        node* n;\\n        n = front;\\n        if (n) {\\n            front = front->next;\\n            delete n;\\n        }\\n    }\\n    void traverse() {\\n        node* ptr;\\n        ptr = front;\\n        if (ptr) {\\n            do {\\n                std::cout << ptr->data << \\\" \\\";\\n                ptr = ptr->next;\\n            } while (ptr != rear->next);\\n            std::cout << front->data << std::endl;\\n        }\\n    }\\n};\\nint main(void) {\\n    Queue q;\\n    q.enqueue(10);\\n    q.enqueue(20);\\n    q.enqueue(30);\\n    q.enqueue(40);\\n    q.enqueue(50);\\n    q.enqueue(60);\\n    q.enqueue(70);\\n    q.traverse();\\n    q.dequeue();\\n    q.traverse();\\n    return 0;\\n}\"",
    "disjoint set": "\"/**\\n *\\n * \\\\file\\n * \\\\brief [Disjoint Sets Data Structure\\n * (Disjoint Sets)](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)\\n *\\n * \\\\author [leoyang429](https://github.com/leoyang429)\\n *\\n * \\\\details\\n * A disjoint set data structure (also called union find or merge find set)\\n * is a data structure that tracks a set of elements partitioned into a number\\n * of disjoint (non-overlapping) subsets.\\n * Some situations where disjoint sets can be used are-\\n * to find connected components of a graph, kruskal's algorithm for finding\\n * Minimum Spanning Tree etc.\\n * There are two operation which we perform on disjoint sets -\\n * 1) Union\\n * 2) Find\\n *\\n */\\n\\n#include <iostream>\\n#include <vector>\\n\\nusing std::cout;\\nusing std::endl;\\nusing std::vector;\\n\\nvector<int> root, rank;\\n\\n/**\\n *\\n * Function to create a set\\n * @param n number of element\\n *\\n */\\nvoid CreateSet(int n) {\\n    root = vector<int>(n + 1);\\n    rank = vector<int>(n + 1, 1);\\n    for (int i = 1; i <= n; ++i) {\\n        root[i] = i;\\n    }\\n}\\n\\n/**\\n *\\n * Find operation takes a number x and returns the set to which this number\\n * belongs to.\\n * @param x element of some set\\n * @return set to which x belongs to\\n *\\n */\\nint Find(int x) {\\n    if (root[x] == x) {\\n        return x;\\n    }\\n    return root[x] = Find(root[x]);\\n}\\n\\n/**\\n *\\n * A utility function to check if x and y are from same set or not\\n * @param x element of some set\\n * @param y element of some set\\n *\\n */\\nbool InSameUnion(int x, int y) { return Find(x) == Find(y); }\\n\\n/**\\n *\\n * Union operation combines two disjoint sets to make a single set\\n * in this union function we pass two elements and check if they are\\n * from different sets then combine those sets\\n * @param x element of some set\\n * @param y element of some set\\n *\\n */\\nvoid Union(int x, int y) {\\n    int a = Find(x), b = Find(y);\\n    if (a != b) {\\n        if (rank[a] < rank[b]) {\\n            root[a] = b;\\n        } else if (rank[a] > rank[b]) {\\n            root[b] = a;\\n        } else {\\n            root[a] = b;\\n            ++rank[b];\\n        }\\n    }\\n}\\n\\n/** Main function */\\nint main() {\\n    // tests CreateSet & Find\\n    int n = 100;\\n    CreateSet(n);\\n    for (int i = 1; i <= 100; ++i) {\\n        if (root[i] != i) {\\n            cout << \\\"Fail\\\" << endl;\\n            break;\\n        }\\n    }\\n    // tests InSameUnion & Union\\n    cout << \\\"1 and 2 are initially not in the same subset\\\" << endl;\\n    if (InSameUnion(1, 2)) {\\n        cout << \\\"Fail\\\" << endl;\\n    }\\n    Union(1, 2);\\n    cout << \\\"1 and 2 are now in the same subset\\\" << endl;\\n    if (!InSameUnion(1, 2)) {\\n        cout << \\\"Fail\\\" << endl;\\n    }\\n    return 0;\\n}\\n\"",
    "doubly linked list": "\"#include <cstdio>\\n#include <cstdlib>\\n#include <iostream>\\n\\nstruct node {\\n    int val;\\n    node *prev;\\n    node *next;\\n} * start;\\n\\nclass double_linked_list {\\n public:\\n    double_linked_list() { start = NULL; }\\n    void insert(int x);\\n    void remove(int x);\\n    void search(int x);\\n    void show();\\n    void reverseShow();\\n};\\n\\nvoid double_linked_list::insert(int x) {\\n    node *t = start;\\n    if (start != NULL) {\\n        while (t->next != NULL) {\\n            t = t->next;\\n        }\\n        node *n = new node;\\n        t->next = n;\\n        n->prev = t;\\n        n->val = x;\\n        n->next = NULL;\\n    } else {\\n        node *n = new node;\\n        n->val = x;\\n        n->prev = NULL;\\n        n->next = NULL;\\n        start = n;\\n    }\\n}\\n\\nvoid double_linked_list::remove(int x) {\\n    node *t = start;\\n    while (t != NULL && t->val != x) {\\n        t = t->next;\\n    }\\n    if (t == NULL) {\\n        return;\\n    }\\n    if (t->prev == NULL) {\\n        if (t->next == NULL) {\\n            start = NULL;\\n        } else {\\n            start = t->next;\\n            start->prev = NULL;\\n        }\\n    } else if (t->next == NULL) {\\n        t->prev->next = NULL;\\n    } else {\\n        t->prev->next = t->next;\\n        t->next->prev = t->prev;\\n    }\\n    delete t;\\n}\\n\\nvoid double_linked_list::search(int x) {\\n    node *t = start;\\n    int found = 0;\\n    while (t != NULL) {\\n        if (t->val == x) {\\n            std::cout << \\\"\\\\nFound\\\";\\n            found = 1;\\n            break;\\n        }\\n        t = t->next;\\n    }\\n    if (found == 0) {\\n        std::cout << \\\"\\\\nNot Found\\\";\\n    }\\n}\\n\\nvoid double_linked_list::show() {\\n    node *t = start;\\n    while (t != NULL) {\\n        std::cout << t->val << \\\"\\\\t\\\";\\n        t = t->next;\\n    }\\n}\\n\\nvoid double_linked_list::reverseShow() {\\n    node *t = start;\\n    while (t != NULL && t->next != NULL) {\\n        t = t->next;\\n    }\\n    while (t != NULL) {\\n        std::cout << t->val << \\\"\\\\t\\\";\\n        t = t->prev;\\n    }\\n}\\n\\nint main() {\\n    int choice, x;\\n    double_linked_list ob;\\n    do {\\n        std::cout << \\\"\\\\n1. Insert\\\";\\n        std::cout << \\\"\\\\n2. Delete\\\";\\n        std::cout << \\\"\\\\n3. Search\\\";\\n        std::cout << \\\"\\\\n4. Forward print\\\";\\n        std::cout << \\\"\\\\n5. Reverse print\\\";\\n        std::cout << \\\"\\\\n\\\\nEnter you choice : \\\";\\n        std::cin >> choice;\\n        switch (choice) {\\n        case 1:\\n            std::cout << \\\"\\\\nEnter the element to be inserted : \\\";\\n            std::cin >> x;\\n            ob.insert(x);\\n            break;\\n        case 2:\\n            std::cout << \\\"\\\\nEnter the element to be removed : \\\";\\n            std::cin >> x;\\n            ob.remove(x);\\n            break;\\n        case 3:\\n            std::cout << \\\"\\\\nEnter the element to be searched : \\\";\\n            std::cin >> x;\\n            ob.search(x);\\n            break;\\n        case 4:\\n            ob.show();\\n            break;\\n        case 5:\\n            ob.reverseShow();\\n            break;\\n        }\\n    } while (choice != 0);\\n    return 0;\\n}\\n\"",
    "dsu path compression": "\"/**\\n * @file\\n * @brief [DSU (Disjoint\\n * sets)](https://en.wikipedia.org/wiki/Disjoint-set-data_structure)\\n * @details\\n * It is a very powerful data structure that keeps track of different\\n * clusters(sets) of elements, these sets are disjoint(doesnot have a common\\n * element). Disjoint sets uses cases : for finding connected components in a\\n * graph, used in Kruskal's algorithm for finding Minimum Spanning tree.\\n * Operations that can be performed:\\n * 1) UnionSet(i,j): add(element i and j to the set)\\n * 2) findSet(i): returns the representative of the set to which i belogngs to.\\n * 3) get_max(i),get_min(i) : returns the maximum and minimum\\n * Below is the class-based approach which uses the heuristic of path\\n * compression. Using path compression in findSet(i),we are able to get to the\\n * representative of i in O(1) time.\\n * @author [AayushVyasKIIT](https://github.com/AayushVyasKIIT)\\n * @see dsu_union_rank.cpp\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\nusing std::cout;\\nusing std::endl;\\nusing std::vector;\\n\\n/**\\n * @brief Disjoint sets union data structure, class based representation.\\n * @param n number of elements\\n */\\nclass dsu {\\n private:\\n    vector<uint64_t> p;           ///< keeps track of the parent of ith element\\n    vector<uint64_t> depth;       ///< tracks the depth(rank) of i in the tree\\n    vector<uint64_t> setSize;     ///< size of each chunk(set)\\n    vector<uint64_t> maxElement;  ///< maximum of each set to which i belongs to\\n    vector<uint64_t> minElement;  ///< minimum of each set to which i belongs to\\n public:\\n    /**\\n     * @brief contructor for initialising all data members.\\n     * @param n number of elements\\n     */\\n    explicit dsu(uint64_t n) {\\n        p.assign(n, 0);\\n        /// initially, all of them are their own parents\\n        for (uint64_t i = 0; i < n; i++) {\\n            p[i] = i;\\n        }\\n        /// initially all have depth are equals to zero\\n        depth.assign(n, 0);\\n        maxElement.assign(n, 0);\\n        minElement.assign(n, 0);\\n        for (uint64_t i = 0; i < n; i++) {\\n            depth[i] = 0;\\n            maxElement[i] = i;\\n            minElement[i] = i;\\n        }\\n        setSize.assign(n, 0);\\n        /// initially set size will be equals to one\\n        for (uint64_t i = 0; i < n; i++) {\\n            setSize[i] = 1;\\n        }\\n    }\\n\\n    /**\\n     * @brief Method to find the representative of the set to which i belongs\\n     * to, T(n) = O(1)\\n     * @param i element of some set\\n     * @returns representative of the set to which i belongs to.\\n     */\\n    uint64_t findSet(uint64_t i) {\\n        /// using path compression\\n        if (p[i] == i) {\\n            return i;\\n        }\\n        return (p[i] = findSet(p[i]));\\n    }\\n    /**\\n     * @brief Method that combines two disjoint sets to which i and j belongs to\\n     * and make a single set having a common representative.\\n     * @param i element of some set\\n     * @param j element of some set\\n     * @returns void\\n     */\\n    void UnionSet(uint64_t i, uint64_t j) {\\n        /// check if both belongs to the same set or not\\n        if (isSame(i, j)) {\\n            return;\\n        }\\n\\n        // we find the representative of the i and j\\n        uint64_t x = findSet(i);\\n        uint64_t y = findSet(j);\\n\\n        /// always keeping the min as x\\n        /// shallow tree\\n        if (depth[x] > depth[y]) {\\n            std::swap(x, y);\\n        }\\n        /// making the shallower root's parent the deeper root\\n        p[x] = y;\\n\\n        /// if same depth, then increase one's depth\\n        if (depth[x] == depth[y]) {\\n            depth[y]++;\\n        }\\n        /// total size of the resultant set\\n        setSize[y] += setSize[x];\\n        /// changing the maximum elements\\n        maxElement[y] = std::max(maxElement[x], maxElement[y]);\\n        minElement[y] = std::min(minElement[x], minElement[y]);\\n    }\\n    /**\\n     * @brief A utility function which check whether i and j belongs to\\n     * same set or not\\n     * @param i element of some set\\n     * @param j element of some set\\n     * @returns `true` if element `i` and `j` ARE in the same set\\n     * @returns `false` if element `i` and `j` are NOT in same set\\n     */\\n    bool isSame(uint64_t i, uint64_t j) {\\n        if (findSet(i) == findSet(j)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    /**\\n     * @brief prints the minimum, maximum and size of the set to which i belongs\\n     * to\\n     * @param i element of some set\\n     * @returns void\\n     */\\n    vector<uint64_t> get(uint64_t i) {\\n        vector<uint64_t> ans;\\n        ans.push_back(get_min(i));\\n        ans.push_back(get_max(i));\\n        ans.push_back(size(i));\\n        return ans;\\n    }\\n    /**\\n     * @brief A utility function that returns the size of the set to which i\\n     * belongs to\\n     * @param i element of some set\\n     * @returns size of the set to which i belongs to\\n     */\\n    uint64_t size(uint64_t i) { return setSize[findSet(i)]; }\\n    /**\\n     * @brief A utility function that returns the max element of the set to\\n     * which i belongs to\\n     * @param i element of some set\\n     * @returns maximum of the set to which i belongs to\\n     */\\n    uint64_t get_max(uint64_t i) { return maxElement[findSet(i)]; }\\n    /**\\n     * @brief A utility function that returns the min element of the set to\\n     * which i belongs to\\n     * @param i element of some set\\n     * @returns minimum of the set to which i belongs to\\n     */\\n    uint64_t get_min(uint64_t i) { return minElement[findSet(i)]; }\\n};\\n\\n/**\\n * @brief Self-test implementations, 1st test\\n * @returns void\\n */\\nstatic void test1() {\\n    // the minimum, maximum, and size of the set\\n    uint64_t n = 10;  ///< number of items\\n    dsu d(n + 1);     ///< object of class disjoint sets\\n    // set 1\\n    d.UnionSet(1, 2);  // performs union operation on 1 and 2\\n    d.UnionSet(1, 4);  // performs union operation on 1 and 4\\n    vector<uint64_t> ans = {1, 4, 3};\\n    for (uint64_t i = 0; i < ans.size(); i++) {\\n        assert(d.get(4).at(i) == ans[i]);  // makes sure algorithm works fine\\n    }\\n    cout << \\\"1st test passed!\\\" << endl;\\n}\\n/**\\n * @brief Self-implementations, 2nd test\\n * @returns void\\n */\\nstatic void test2() {\\n    // the minimum, maximum, and size of the set\\n    uint64_t n = 10;  ///< number of items\\n    dsu d(n + 1);     ///< object of class disjoint sets\\n    // set 1\\n    d.UnionSet(3, 5);\\n    d.UnionSet(5, 6);\\n    d.UnionSet(5, 7);\\n    vector<uint64_t> ans = {3, 7, 4};\\n    for (uint64_t i = 0; i < ans.size(); i++) {\\n        assert(d.get(3).at(i) == ans[i]);  // makes sure algorithm works fine\\n    }\\n    cout << \\\"2nd test passed!\\\" << endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n * */\\nint main() {\\n    uint64_t n = 10;  ///< number of items\\n    dsu d(n + 1);     ///< object of class disjoint sets\\n\\n    test1();  // run 1st test case\\n    test2();  // run 2nd test case\\n\\n    return 0;\\n}\\n\"",
    "dsu union rank": "\"/**\\n * @file\\n * @brief [DSU (Disjoint\\n * sets)](https://en.wikipedia.org/wiki/Disjoint-set-data_structure)\\n * @details\\n * dsu : It is a very powerful data structure which keeps track of different\\n * clusters(sets) of elements, these sets are disjoint(doesnot have a common\\n * element). Disjoint sets uses cases : for finding connected components in a\\n * graph, used in Kruskal's algorithm for finding Minimum Spanning tree.\\n * Operations that can be performed:\\n * 1) UnionSet(i,j): add(element i and j to the set)\\n * 2) findSet(i): returns the representative of the set to which i belogngs to.\\n * 3) getParents(i): prints the parent of i and so on and so forth.\\n * Below is the class-based approach which uses the heuristic of union-ranks.\\n * Using union-rank in findSet(i),we are able to get to the representative of i\\n * in slightly delayed O(logN) time but it allows us to keep tracks of the\\n * parent of i.\\n * @author [AayushVyasKIIT](https://github.com/AayushVyasKIIT)\\n * @see dsu_path_compression.cpp\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\nusing std::cout;\\nusing std::endl;\\nusing std::vector;\\n\\n/**\\n * @brief Disjoint sets union data structure, class based representation.\\n * @param n number of elements\\n */\\nclass dsu {\\n private:\\n    vector<uint64_t> p;        ///< keeps track of the parent of ith element\\n    vector<uint64_t> depth;    ///< tracks the depth(rank) of i in the tree\\n    vector<uint64_t> setSize;  ///< size of each chunk(set)\\n public:\\n    /**\\n     * @brief constructor for initialising all data members\\n     * @param n number of elements\\n     */\\n    explicit dsu(uint64_t n) {\\n        p.assign(n, 0);\\n        /// initially all of them are their own parents\\n        depth.assign(n, 0);\\n        setSize.assign(n, 0);\\n        for (uint64_t i = 0; i < n; i++) {\\n            p[i] = i;\\n            depth[i] = 0;\\n            setSize[i] = 1;\\n        }\\n    }\\n    /**\\n     * @brief Method to find the representative of the set to which i belongs\\n     * to, T(n) = O(logN)\\n     * @param i element of some set\\n     * @returns representative of the set to which i belongs to\\n     */\\n    uint64_t findSet(uint64_t i) {\\n        /// using union-rank\\n        while (i != p[i]) {\\n            i = p[i];\\n        }\\n        return i;\\n    }\\n    /**\\n     * @brief Method that combines two disjoint sets to which i and j belongs to\\n     * and make a single set having a common representative.\\n     * @param i element of some set\\n     * @param j element of some set\\n     * @returns void\\n     */\\n    void unionSet(uint64_t i, uint64_t j) {\\n        /// checks if both belongs to same set or not\\n        if (isSame(i, j)) {\\n            return;\\n        }\\n        /// we find representative of the i and j\\n        uint64_t x = findSet(i);\\n        uint64_t y = findSet(j);\\n\\n        /// always keeping the min as x\\n        /// in order to create a shallow tree\\n        if (depth[x] > depth[y]) {\\n            std::swap(x, y);\\n        }\\n        /// making the shallower tree, root parent of the deeper root\\n        p[x] = y;\\n\\n        /// if same depth, then increase one's depth\\n        if (depth[x] == depth[y]) {\\n            depth[y]++;\\n        }\\n        /// total size of the resultant set\\n        setSize[y] += setSize[x];\\n    }\\n    /**\\n     * @brief A utility function which check whether i and j belongs to same set\\n     * or not\\n     * @param i element of some set\\n     * @param j element of some set\\n     * @returns `true` if element i and j are in same set\\n     * @returns `false` if element i and j are not in same set\\n     */\\n    bool isSame(uint64_t i, uint64_t j) {\\n        if (findSet(i) == findSet(j)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    /**\\n     * @brief Method to print all the parents of i, or the path from i to\\n     * representative.\\n     * @param i element of some set\\n     * @returns void\\n     */\\n    vector<uint64_t> getParents(uint64_t i) {\\n        vector<uint64_t> ans;\\n        while (p[i] != i) {\\n            ans.push_back(i);\\n            i = p[i];\\n        }\\n        ans.push_back(i);\\n        return ans;\\n    }\\n};\\n/**\\n * @brief Self-implementations, 1st test\\n * @returns void\\n */\\nstatic void test1() {\\n    /* checks the parents in the resultant structures */\\n    uint64_t n = 10;   ///< number of elements\\n    dsu d(n + 1);      ///< object of class disjoint sets\\n    d.unionSet(2, 1);  ///< performs union operation on 1 and 2\\n    d.unionSet(1, 4);\\n    d.unionSet(8, 1);\\n    d.unionSet(3, 5);\\n    d.unionSet(5, 6);\\n    d.unionSet(5, 7);\\n    d.unionSet(9, 10);\\n    d.unionSet(2, 10);\\n    // keeping track of the changes using parent pointers\\n    vector<uint64_t> ans = {7, 5};\\n    for (uint64_t i = 0; i < ans.size(); i++) {\\n        assert(d.getParents(7).at(i) ==\\n               ans[i]);  // makes sure algorithm works fine\\n    }\\n    cout << \\\"1st test passed!\\\" << endl;\\n}\\n/**\\n * @brief Self-implementations, 2nd test\\n * @returns void\\n */\\nstatic void test2() {\\n    // checks the parents in the resultant structures\\n    uint64_t n = 10;   ///< number of elements\\n    dsu d(n + 1);      ///< object of class disjoint sets\\n    d.unionSet(2, 1);  /// performs union operation on 1 and 2\\n    d.unionSet(1, 4);\\n    d.unionSet(8, 1);\\n    d.unionSet(3, 5);\\n    d.unionSet(5, 6);\\n    d.unionSet(5, 7);\\n    d.unionSet(9, 10);\\n    d.unionSet(2, 10);\\n\\n    /// keeping track of the changes using parent pointers\\n    vector<uint64_t> ans = {2, 1, 10};\\n    for (uint64_t i = 0; i < ans.size(); i++) {\\n        assert(d.getParents(2).at(i) ==\\n               ans[i]);  /// makes sure algorithm works fine\\n    }\\n    cout << \\\"2nd test passed!\\\" << endl;\\n}\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test1();  // run 1st test case\\n    test2();  // run 2nd test case\\n\\n    return 0;\\n}\\n\"",
    "linkedlist implentation usingarray": "\"/**\\n * \\\\file\\n * \\\\brief Linked list implementation using Arrays\\n *\\n * The difference between the pointer implementation of linked list and array\\n * implementation of linked list:\\n * 1. The NULL is represented by -1;\\n * 2. Limited size. (in the following case it is 100 nodes at max). But we can\\n * reuse the nodes that are to be deleted by again linking it bacj to the list.\\n */\\n\\n#include <iostream>\\n\\nstruct Node {\\n    int data;\\n    int next;\\n};\\n\\nNode AvailArray[100];  ///< array that will act as nodes of a linked list.\\n\\nint head = -1;\\nint avail = 0;\\nvoid initialise_list() {\\n    for (int i = 0; i <= 98; i++) {\\n        AvailArray[i].next = i + 1;\\n    }\\n    AvailArray[99].next = -1;  // indicating the end of the linked list.\\n}\\n\\n/** This will return the index of the first free node present in the avail list\\n */\\nint getnode() {\\n    int NodeIndexToBeReturned = avail;\\n    avail = AvailArray[avail].next;\\n    return NodeIndexToBeReturned;\\n}\\n\\n/** This function when called will delete the node with\\n * the index presented as an argument, and will put\\n * back that node into the array.\\n */\\nvoid freeNode(int nodeToBeDeleted) {\\n    AvailArray[nodeToBeDeleted].next = avail;\\n    avail = nodeToBeDeleted;\\n}\\n\\n/** The function will insert the given data\\n * into the front of the linked list.\\n */\\nvoid insertAtTheBeginning(int data) {\\n    int newNode = getnode();\\n    AvailArray[newNode].data = data;\\n    AvailArray[newNode].next = head;\\n    head = newNode;\\n}\\n\\nvoid insertAtTheEnd(int data) {\\n    int newNode = getnode();\\n    int temp = head;\\n    while (AvailArray[temp].next != -1) {\\n        temp = AvailArray[temp].next;\\n    }\\n    // temp is now pointing to the end node.\\n    AvailArray[newNode].data = data;\\n    AvailArray[newNode].next = -1;\\n    AvailArray[temp].next = newNode;\\n}\\n\\nvoid display() {\\n    int temp = head;\\n    while (temp != -1) {\\n        std::cout << AvailArray[temp].data << \\\"->\\\";\\n        temp = AvailArray[temp].next;\\n    }\\n    std::cout << \\\"-1\\\" << std::endl;\\n}\\n\\n/** Main function */\\nint main() {\\n    initialise_list();\\n    int x, y, z;\\n    for (;;) {\\n        std::cout << \\\"1. Insert At The Beginning\\\" << std::endl;\\n        std::cout << \\\"2. Insert At The End\\\" << std::endl;\\n        std::cout << \\\"3. Display\\\" << std::endl;\\n        std::cout << \\\"4.Exit\\\" << std::endl;\\n        std::cout << \\\"Enter Your choice\\\" << std::endl;\\n        std::cin >> z;\\n        switch (z) {\\n        case 1:\\n            std::cout << \\\"Enter the number you want to enter\\\" << std::endl;\\n            std::cin >> x;\\n            insertAtTheBeginning(x);\\n            break;\\n        case 2:\\n            std::cout << \\\"Enter the number you want to enter\\\" << std::endl;\\n            std::cin >> y;\\n            insertAtTheEnd(y);\\n            break;\\n        case 3:\\n            std::cout\\n                << \\\"The linked list contains the following element in order\\\"\\n                << std::endl;\\n            display();\\n            break;\\n        case 4:\\n            return 0;\\n        default:\\n            std::cout << \\\"The entered choice is not correct\\\" << std::endl;\\n        }\\n    }\\n\\n    return 0;\\n}\\n\"",
    "linked list": "\"/**\\n * @file\\n * @brief Implementation of singly linked list algorithm.\\n * @details\\n * The linked list is a data structure used for holding a sequence of\\n * values, which can be added, removed and displayed.\\n * ### Algorithm\\n * Values can be added by iterating to the end of a list(by following\\n * the pointers) starting from the first link. Whichever link points to null\\n * is considered the last link and is pointed to the new value.\\n *\\n * Values can be removed by also iterating through the list. When the node\\n * containing the value is found, the node pointing to the current node is made\\n * to point to the node that the current node is pointing to, and then returning\\n * the current node to heap store.\\n */\\n#include <iostream>\\n#include <memory>\\n#include <string>\\n\\n/**\\n * @namespace data_structures\\n * @brief Data Structures algorithms\\n */\\nnamespace data_structures {\\n\\n/**\\n * @namespace linked_list\\n * @brief Functions for singly linked list algorithm\\n */\\nnamespace linked_list {\\n\\n/**\\n * This function checks if the string passed consists\\n * of only digits.\\n * @param s To be checked if s contains only integers\\n * @returns true if there are only digits present in the string\\n * @returns false if any other character is found\\n */\\nbool isDigit(const std::string& s) {\\n    // function statements here\\n    for (char i : s) {\\n        if (!isdigit(i)) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * A link class containing a value and pointer to another link\\n */\\nclass link {\\n private:\\n    int pvalue;                   ///< value of the current link\\n    std::shared_ptr<link> psucc;  ///< pointer to the next value on the list\\n\\n public:\\n    /**\\n     * function returns the integer value stored in the link.\\n     * @returns the integer value stored in the link.\\n     */\\n    int val() { return pvalue; }\\n\\n    /**\\n     * function returns the pointer to next link\\n     * @returns the pointer to the next link\\n     * */\\n    std::shared_ptr<link>& succ() { return psucc; }\\n\\n    /**\\n     * Creates link with provided value and pointer to next link\\n     * @param value is the integer stored in the link\\n     */\\n    explicit link(int value = 0) : pvalue(value), psucc(nullptr) {}\\n};\\n\\n/**\\n * A list class containing a sequence of links\\n */\\nclass list {\\n private:\\n    std::shared_ptr<link> first;  ///< link before the actual first element\\n    std::shared_ptr<link> last;   ///< last link on the list\\n public:\\n    /**\\n     * List constructor. Initializes the first and last link.\\n     */\\n    list() {\\n        // Initialize the first link\\n        first = std::make_shared<link>();\\n        // Initialize the last link with the first link\\n        last = nullptr;\\n    }\\n\\n    bool isEmpty();\\n\\n    void push_back(int new_elem);\\n    void push_front(int new_elem);\\n    void erase(int old_elem);\\n    void display();\\n    std::shared_ptr<link> search(int find_elem);\\n    void reverse();\\n};\\n\\n/**\\n * function checks if list is empty\\n * @returns true if list is empty\\n * @returns false if list is not empty\\n */\\nbool list::isEmpty() {\\n    if (last == nullptr) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\n/**\\n * function adds new element to the end of the list\\n * @param new_elem to be added to the end of the list\\n */\\nvoid list::push_back(int new_elem) {\\n    if (isEmpty()) {\\n        first->succ() = std::make_shared<link>(new_elem);\\n        last = first->succ();\\n    } else {\\n        last->succ() = std::make_shared<link>(new_elem);\\n        last = last->succ();\\n    }\\n}\\n\\n/**\\n * function adds new element to the beginning of the list\\n * @param new_elem to be added to front of the list\\n */\\nvoid list::push_front(int new_elem) {\\n    if (isEmpty()) {\\n        first->succ() = std::make_shared<link>(new_elem);\\n        last = first->succ();\\n    } else {\\n        std::shared_ptr<link> t = std::make_shared<link>(new_elem);\\n        t->succ() = first->succ();\\n        first->succ() = t;\\n    }\\n}\\n\\n/**\\n * function erases old element from the list\\n * @param old_elem to be erased from the list\\n */\\nvoid list::erase(int old_elem) {\\n    if (isEmpty()) {\\n        std::cout << \\\"List is Empty!\\\";\\n        return;\\n    }\\n    std::shared_ptr<link> t = first;\\n    std::shared_ptr<link> to_be_removed = nullptr;\\n    while (t != last && t->succ()->val() != old_elem) {\\n        t = t->succ();\\n    }\\n    if (t == last) {\\n        std::cout << \\\"Element not found\\\\n\\\";\\n        return;\\n    }\\n    to_be_removed = t->succ();\\n    t->succ() = t->succ()->succ();\\n    to_be_removed.reset();\\n    if (t->succ() == nullptr) {\\n        last = t;\\n    }\\n    if (first == last){\\n        last = nullptr;\\n    }\\n}\\n\\n/**\\n * function displays all the elements in the list\\n * @returns 'void'\\n */\\nvoid list::display() {\\n    if (isEmpty()) {\\n        std::cout << \\\"List is Empty!\\\";\\n        return;\\n    }\\n    std::shared_ptr<link> t = first;\\n    while (t->succ() != nullptr) {\\n        std::cout << t->succ()->val() << \\\"\\\\t\\\";\\n        t = t->succ();\\n    }\\n}\\n\\n/**\\n * function searchs for @param find_elem in the list\\n * @param find_elem to be searched for in the list\\n */\\nstd::shared_ptr<link> list::search(int find_elem) {\\n    if (isEmpty()) {\\n        std::cout << \\\"List is Empty!\\\";\\n        return nullptr;\\n    }\\n    std::shared_ptr<link> t = first;\\n    while (t != last && t->succ()->val() != find_elem) {\\n        t = t->succ();\\n    }\\n    if (t == last) {\\n        std::cout << \\\"Element not found\\\\n\\\";\\n        return nullptr;\\n    }\\n    std::cout << \\\"Element was found\\\\n\\\";\\n    return t->succ();\\n}\\n}  // namespace linked_list\\n}  // namespace data_structures\\n\\n/**\\n * Main function:\\n * Allows the user add and delete values from the list.\\n * Also allows user to search for and display values in the list.\\n * @returns 0 on exit\\n */\\nint main() {\\n    data_structures::linked_list::list l;\\n    int choice = 0;\\n    int x = 0;\\n    std::string s;\\n    do {\\n        std::cout << \\\"\\\\n1. Insert\\\";\\n        std::cout << \\\"\\\\n2. Delete\\\";\\n        std::cout << \\\"\\\\n3. Search\\\";\\n        std::cout << \\\"\\\\n4. Print\\\";\\n        std::cout << \\\"\\\\n0. Exit\\\";\\n        std::cout << \\\"\\\\n\\\\nEnter you choice : \\\";\\n        std::cin >> choice;\\n        switch (choice) {\\n            case 1:\\n                std::cout << \\\"\\\\nEnter the element to be inserted : \\\";\\n                std::cin >> s;\\n\\n                if (data_structures::linked_list::isDigit(s)) {\\n                    x = std::stoi(s);\\n                    l.push_back(x);\\n                } else {\\n                    std::cout << \\\"Wrong Input!\\\\n\\\";\\n                }\\n                break;\\n            case 2:\\n                std::cout << \\\"\\\\nEnter the element to be removed : \\\";\\n                std::cin >> s;\\n                if (data_structures::linked_list::isDigit(s)) {\\n                    x = std::stoi(s);\\n                    l.erase(x);\\n                } else {\\n                    std::cout << \\\"Wrong Input!\\\\n\\\";\\n                }\\n                break;\\n            case 3:\\n                std::cout << \\\"\\\\nEnter the element to be searched : \\\";\\n                std::cin >> s;\\n                if (data_structures::linked_list::isDigit(s)) {\\n                    x = std::stoi(s);\\n                    std::shared_ptr<data_structures::linked_list::link> found =\\n                        l.search(x);\\n                } else {\\n                    std::cout << \\\"Wrong Input!\\\\n\\\";\\n                }\\n                break;\\n            case 4:\\n                l.display();\\n                std::cout << \\\"\\\\n\\\";\\n                break;\\n            default:\\n                std::cout << \\\"Invalid Input\\\\n\\\" << std::endl;\\n                break;\\n        }\\n    } while (choice != 0);\\n    return 0;\\n}\\n\"",
    "list array": "\"/**\\n * @file\\n * @brief [Dynamic Array](https://en.wikipedia.org/wiki/Dynamic_array)\\n *\\n * @details\\n * The list_array is the implementation of list represented using array.\\n * We can perform basic CRUD operations as well as other operations like sorting etc.\\n *\\n * ### Algorithm\\n * It implements various method like insert, sort, search etc. efficiently.\\n * You can select the operation and methods will do the rest work for you.\\n * You can insert element, sort them in order, search efficiently, delete values and print the list.\\n */\\n\\n#include <iostream> /// for io operations\\n#include <array>   /// for std::array\\n#include <cassert> /// for assert\\n\\n/**\\n * @namespace data_structures\\n * @brief Algorithms with data structures\\n */\\nnamespace data_structures {\\n/**\\n * @namespace list_array\\n * @brief Functions for [Dynamic Array](https://en.wikipedia.org/wiki/Dynamic_array) algorithm\\n */\\nnamespace list_array {\\n    /**\\n     * @brief Structure of List with supporting methods.\\n     */\\n    struct list {\\n        std::array<uint64_t, 50> data{}; // Array that implement list\\n        uint64_t top = 0; // Pointer to the last element\\n        bool isSorted = false; // indicator whether list is sorted or not\\n        /**\\n         * @brief Search an element in the list using binarySearch.\\n         * @param dataArr list\\n         * @param first pointer to the first element in the remaining list\\n         * @param last pointer to the last element in the remaining list\\n         * @param val element that will be searched\\n         * @return index of element in the list if present else -1\\n         */\\n        uint64_t BinarySearch(const std::array<uint64_t, 50> &dataArr, const uint64_t &first, const uint64_t &last,\\n                              const uint64_t &val) {\\n            // If both pointer cross each other means no element present in the list which is equal to the val\\n            if (last < first) {\\n                return -1;\\n            }\\n            uint64_t mid = (first + last) / 2;\\n            // check whether current mid pointer value is equal to element or not\\n            if (dataArr[mid] == val)\\n                return mid;\\n                // if current mid value is greater than  element we have to search in first half\\n            else if (val < dataArr[mid])\\n                return (BinarySearch(dataArr, first, mid - 1, val));\\n                // if current mid value is greater than  element we have to search in second half\\n            else if (val > dataArr[mid])\\n                return (BinarySearch(dataArr, mid + 1, last, val));\\n\\n            std::cerr << __func__ << \\\":\\\" << __LINE__ << \\\": Undefined condition\\\\n\\\";\\n            return -1;\\n        }\\n\\n        /**\\n         * @brief Search an element using linear search\\n         * @param dataArr list\\n         * @param val element that will be searched\\n         * @return index of element in the list if present else -1\\n         */\\n        uint64_t LinearSearch(const std::array<uint64_t, 50> &dataArr, const uint64_t &val) const {\\n            // Going through each element in the list\\n            for (uint64_t i = 0; i < top; i++) {\\n                if (dataArr[i] == val) {\\n                    return i; // element found at ith index\\n                }\\n            }\\n            // element is not present in the list\\n            return -1;\\n        }\\n\\n        /*\\n         * @brief Parent function of binarySearch and linearSearch methods\\n         * @param val element that will be searched\\n         * @return index of element in the list if present else -1\\n         */\\n        uint64_t search(const uint64_t &val) {\\n            uint64_t pos; // pos variable to store index value of element.\\n            // if list is sorted, binary search works efficiently else linear search is the only option\\n            if (isSorted) {\\n                pos = BinarySearch(data, 0, top - 1, val);\\n            } else {\\n                pos = LinearSearch(data, val);\\n            }\\n            // if index is equal to -1 means element does not present\\n            // else print the index of that element\\n            if (pos != -1) {\\n                std::cout << \\\"\\\\nElement found at position : \\\" << pos;\\n            } else {\\n                std::cout << \\\"\\\\nElement not found\\\";\\n            }\\n            // return the index of element or -1.\\n            return pos;\\n        }\\n\\n        /**\\n         * @brief Sort the list\\n         * @returns void\\n         */\\n        void sort() {\\n            //Going through each element in the list\\n            for (uint64_t i = 0; i < top; i++) {\\n                uint64_t min_idx = i; // Initialize the min variable\\n                for (uint64_t j = i + 1; j < top; j++) {\\n                    // check whether any element less than current min value\\n                    if (data[j] < data[min_idx]) {\\n                        min_idx = j; // update index accordingly\\n                    }\\n                }\\n                // swap min value and element at the ith index\\n                std::swap(data[min_idx], data[i]);\\n            }\\n            // mark isSorted variable as true\\n            isSorted = true;\\n        }\\n\\n        /**\\n         * @brief Insert the new element in the list\\n         * @param val element that will be inserted\\n         * @returns void\\n         */\\n        void insert(const uint64_t &val) {\\n            // overflow check\\n            if (top == 49) {\\n                std::cout << \\\"\\\\nOverflow\\\";\\n                return;\\n            }\\n            // if list is not sorted, insert at the last\\n            // otherwise place it to correct position\\n            if (!isSorted) {\\n                data[top] = val;\\n                top++;\\n            } else {\\n                uint64_t pos = 0; // Initialize the index variable\\n                // Going through each element and find correct position for element\\n                for (uint64_t i = 0; i < top - 1; i++) {\\n                    // check for the correct position\\n                    if (data[i] <= val && val <= data[i + 1]) {\\n                        pos = i + 1; // assign correct pos to the index var\\n                        break; // to get out from the loop\\n                    }\\n                }\\n                // if all elements are smaller than the element\\n                if (pos == 0) {\\n                    pos = top - 1;\\n                }\\n                // shift all element to make a room for new element\\n                for (uint64_t i = top; i > pos; i--) {\\n                    data[i] = data[i - 1];\\n                }\\n                top++; // Increment the value of top.\\n                data[pos] = val; // Assign the value to the correct index in the array\\n            }\\n        }\\n\\n        /**\\n         * @brief To remove the element from the list\\n         * @param val element that will be removed\\n         * @returns void\\n         */\\n        void remove(const uint64_t &val) {\\n            uint64_t pos = search(val); // search the index of the value\\n            // if search returns -1, element does not present in the list\\n            if (pos == -1) {\\n                std::cout << \\\"\\\\n Element does not present in the list \\\";\\n                return;\\n            }\\n            std::cout << \\\"\\\\n\\\" << data[pos] << \\\" deleted\\\"; // print the appropriate message\\n            // shift all the element 1 left to fill vacant space\\n            for (uint64_t i = pos; i < top; i++) {\\n                data[i] = data[i + 1];\\n            }\\n            top--; // decrement the top variable to maintain last index\\n        }\\n\\n        /**\\n         * @brief Utility function to print array\\n         * @returns void\\n         */\\n        void show() {\\n            // Going through each element in the list\\n            std::cout << '\\\\n';\\n            for (uint64_t i = 0; i < top; i++) {\\n                std::cout << data[i] << \\\" \\\"; // print the element\\n            }\\n        }\\n    }; // structure list\\n} // namespace list_array\\n} // namespace data_structures\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    data_structures::list_array::list L;\\n\\n    // Insert testing\\n    L.insert(11);\\n    L.insert(12);\\n    assert(L.top == 2);\\n    L.insert(15);\\n    L.insert(10);\\n    L.insert(12);\\n    L.insert(20);\\n    L.insert(18);\\n    assert(L.top == 7);\\n    L.show(); // To print the array\\n\\n    // Remove testing\\n    L.remove(12); // Remove Duplicate value in the list\\n    L.remove(15); // Remove the existing value in the list\\n    assert(L.top == 5);\\n    L.remove(50); // Try to remove the non-existing value in the list\\n    assert(L.top == 5);\\n\\n    // LinearSearch testing\\n    assert(L.search(11) == 0); // search for the existing element\\n    assert(L.search(12) == 2);\\n    assert(L.search(50) == -1); // search for the non-existing element\\n\\n    // Sort testing\\n    L.sort();\\n    assert(L.isSorted == true);\\n    L.show();\\n\\n    // BinarySearch testing\\n    assert(L.search(11) == 1); // search for the existing element\\n    assert(L.search(12) == 2);\\n    assert(L.search(50) == -1); // search for the non-existing element\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test(); // Execute the tests\\n    return 0;\\n}\\n\"",
    "morrisinorder": "\"#include <iostream>\\n#include <queue>\\n\\n/**************************\\n    @author shrutisheoran\\n**************************/\\n\\nusing namespace std;\\n\\nstruct Btree {\\n    int data;\\n    struct Btree *left;   // Pointer to left subtree\\n    struct Btree *right;  // Pointer to right subtree\\n};\\n\\nvoid insert(Btree **root, int d) {\\n    Btree *nn = new Btree();  // Creating new node\\n    nn->data = d;\\n    nn->left = NULL;\\n    nn->right = NULL;\\n    if (*root == NULL) {\\n        *root = nn;\\n        return;\\n    } else {\\n        queue<Btree *> q;\\n        // Adding root node to queue\\n        q.push(*root);\\n        while (!q.empty()) {\\n            Btree *node = q.front();\\n            // Removing parent node from queue\\n            q.pop();\\n            if (node->left)\\n                // Adding left child of removed node to queue\\n                q.push(node->left);\\n            else {\\n                // Adding new node if no left child is present\\n                node->left = nn;\\n                return;\\n            }\\n            if (node->right)\\n                // Adding right child of removed node to queue\\n                q.push(node->right);\\n            else {\\n                // Adding new node if no right child is present\\n                node->right = nn;\\n                return;\\n            }\\n        }\\n    }\\n}\\n\\nvoid morrisInorder(Btree *root) {\\n    Btree *curr = root;\\n    Btree *temp;\\n    while (curr) {\\n        if (curr->left == NULL) {\\n            cout << curr->data << \\\" \\\";\\n            // If left of current node is NULL then curr is shifted to right\\n            curr = curr->right;\\n        } else {\\n            // Left of current node is stored in temp\\n            temp = curr->left;\\n            // Moving to extreme right of temp\\n            while (temp->right && temp->right != curr) temp = temp->right;\\n            // If extreme right is null it is made to point to currrent node\\n            // (will be used for backtracking)\\n            if (temp->right == NULL) {\\n                temp->right = curr;\\n                // current node is made to point its left subtree\\n                curr = curr->left;\\n            }\\n            // If extreme right already points to currrent node it it set to\\n            // null\\n            else if (temp->right == curr) {\\n                cout << curr->data << \\\" \\\";\\n                temp->right = NULL;\\n                // current node is made to point its right subtree\\n                curr = curr->right;\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    // Testing morrisInorder funtion\\n    Btree *root = NULL;\\n    int i;\\n    for (i = 1; i <= 7; i++) insert(&root, i);\\n    cout << \\\"Morris Inorder: \\\";\\n    morrisInorder(root);\\n    return 0;\\n}\\n\"",
    "queue": "\"/* This class specifies the basic operation on a queue as a linked list */\\n#ifndef DATA_STRUCTURES_QUEUE_H_\\n#define DATA_STRUCTURES_QUEUE_H_\\n\\n#include <cassert>\\n#include <iostream>\\n\\n/** Definition of the node */\\ntemplate <class Kind>\\nstruct node {\\n    Kind data;\\n    node<Kind> *next;\\n};\\n\\n/** Definition of the queue class */\\ntemplate <class Kind>\\nclass queue {\\n public:\\n    /** Show queue */\\n    void display() {\\n        node<Kind> *current = queueFront;\\n        std::cout << \\\"Front --> \\\";\\n        while (current != NULL) {\\n            std::cout << current->data << \\\"    \\\";\\n            current = current->next;\\n        }\\n        std::cout << std::endl;\\n        std::cout << \\\"Size of queue: \\\" << size << std::endl;\\n    }\\n\\n    /** Default constructor*/\\n    queue() {\\n        queueFront = NULL;\\n        queueRear = NULL;\\n        size = 0;\\n    }\\n\\n    /** Destructor */\\n    ~queue() {}\\n\\n    /** Determine whether the queue is empty */\\n    bool isEmptyQueue() { return (queueFront == NULL); }\\n\\n    /** Add new item to the queue */\\n    void enQueue(Kind item) {\\n        node<Kind> *newNode;\\n        newNode = new node<Kind>;\\n        newNode->data = item;\\n        newNode->next = NULL;\\n        if (queueFront == NULL) {\\n            queueFront = newNode;\\n            queueRear = newNode;\\n        } else {\\n            queueRear->next = newNode;\\n            queueRear = queueRear->next;\\n        }\\n        size++;\\n    }\\n\\n    /** Return the first element of the queue */\\n    Kind front() {\\n        assert(queueFront != NULL);\\n        return queueFront->data;\\n    }\\n\\n    /** Remove the top element of the queue */\\n    void deQueue() {\\n        node<Kind> *temp;\\n        if (!isEmptyQueue()) {\\n            temp = queueFront;\\n            queueFront = queueFront->next;\\n            delete temp;\\n            size--;\\n        } else {\\n            std::cout << \\\"Queue is empty !\\\" << std::endl;\\n        }\\n    }\\n\\n    /** Clear queue */\\n    void clear() { queueFront = NULL; }\\n\\n private:\\n    node<Kind> *queueFront; /**< Pointer to the front of the queue */\\n    node<Kind> *queueRear;  /**< Pointer to the rear of the queue  */\\n    int size;\\n};\\n\\n#endif  // DATA_STRUCTURES_QUEUE_H_\\n\"",
    "queue using array": "\"/**\\n * @file\\n * @brief Implementation of Linear [Queue using array]\\n * (https://www.geeksforgeeks.org/array-implementation-of-queue-simple/).\\n * @details\\n * The Linear Queue is a data structure used for holding a sequence of\\n * values, which can be added to the end line (enqueue), removed from\\n * head of line (dequeue) and displayed.\\n * ### Algorithm\\n * Values can be added by increasing the `rear` variable by 1 (which points to\\n * the end of the array), then assigning new value to `rear`'s element of the\\n * array.\\n *\\n * Values can be removed by increasing the `front` variable by 1 (which points\\n * to the first of the array), so it cannot reached any more.\\n *\\n * @author [Pooja](https://github.com/pooja-git11)\\n * @author [Farbod Ahmadian](https://github.com/farbodahm)\\n */\\n#include <array>     /// for std::array\\n#include <iostream>  /// for io operations\\n\\nconstexpr uint16_t max_size{10};  ///< Maximum size of the queue\\n\\n/**\\n * @namespace data_structures\\n * @brief Algorithms with data structures\\n */\\nnamespace data_structures {\\n\\n/**\\n * @namespace queue_using_array\\n * @brief Functions for [Queue using Array]\\n * (https://www.geeksforgeeks.org/array-implementation-of-queue-simple/)\\n * implementation.\\n */\\nnamespace queue_using_array {\\n\\n/**\\n * @brief Queue_Array class containing the main data and also index of head and\\n * tail of the array.\\n */\\nclass Queue_Array {\\n public:\\n    void enqueue(const int16_t&);  ///< Add element to the first of the queue\\n    int dequeue();                 ///< Delete element from back of the queue\\n    void display() const;          ///< Show all saved data\\n private:\\n    int8_t front{-1};                     ///< Index of head of the array\\n    int8_t rear{-1};                      ///< Index of tail of the array\\n    std::array<int16_t, max_size> arr{};  ///< All stored data\\n};\\n\\n/**\\n * @brief Adds new element to the end of the queue\\n * @param ele to be added to the end of the queue\\n */\\nvoid Queue_Array::enqueue(const int16_t& ele) {\\n    if (rear == arr.size() - 1) {\\n        std::cout << \\\"\\\\nStack is full\\\";\\n    } else if (front == -1 && rear == -1) {\\n        front = 0;\\n        rear = 0;\\n        arr[rear] = ele;\\n    } else if (rear < arr.size()) {\\n        ++rear;\\n        arr[rear] = ele;\\n    }\\n}\\n\\n/**\\n * @brief Remove element that is located at the first of the queue\\n * @returns data that is deleted if queue is not empty\\n */\\nint Queue_Array::dequeue() {\\n    int8_t d{0};\\n    if (front == -1) {\\n        std::cout << \\\"\\\\nstack is empty \\\";\\n        return 0;\\n    } else if (front == rear) {\\n        d = arr.at(front);\\n        front = rear = -1;\\n    } else {\\n        d = arr.at(front++);\\n    }\\n\\n    return d;\\n}\\n\\n/**\\n * @brief Utility function to show all elements in the queue\\n */\\nvoid Queue_Array::display() const {\\n    if (front == -1) {\\n        std::cout << \\\"\\\\nStack is empty\\\";\\n    } else {\\n        for (int16_t i{front}; i <= rear; ++i) std::cout << arr.at(i) << \\\" \\\";\\n    }\\n}\\n\\n}  // namespace queue_using_array\\n}  // namespace data_structures\\n\\n/**\\n * @brief Main function\\n * @details\\n * Allows the user to add and delete values from the queue.\\n * Also allows user to display values in the queue.\\n * @returns 0 on exit\\n */\\nint main() {\\n    int op{0}, data{0};\\n    data_structures::queue_using_array::Queue_Array ob;\\n\\n    std::cout << \\\"\\\\n1. enqueue(Insertion) \\\";\\n    std::cout << \\\"\\\\n2. dequeue(Deletion)\\\";\\n    std::cout << \\\"\\\\n3. Display\\\";\\n    std::cout << \\\"\\\\n4. Exit\\\";\\n    while (true) {\\n        std::cout << \\\"\\\\nEnter your choice \\\";\\n        std::cin >> op;\\n        if (op == 1) {\\n            std::cout << \\\"Enter data  \\\";\\n            std::cin >> data;\\n            ob.enqueue(data);\\n        } else if (op == 2) {\\n            data = ob.dequeue();\\n            std::cout << \\\"\\\\ndequeue element is:\\\\t\\\" << data;\\n        } else if (op == 3) {\\n            ob.display();\\n        } else if (op == 4) {\\n            exit(0);\\n        } else {\\n            std::cout << \\\"\\\\nWrong choice \\\";\\n        }\\n    }\\n\\n    return 0;\\n}\\n\"",
    "queue using array2": "\"#include <iostream>\\nusing namespace std;\\n\\nint queue[10];\\nint front = 0;\\nint rear = 0;\\n\\nvoid Enque(int x) {\\n    if (rear == 10) {\\n        cout << \\\"\\\\nOverflow\\\";\\n    } else {\\n        queue[rear++] = x;\\n    }\\n}\\n\\nvoid Deque() {\\n    if (front == rear) {\\n        cout << \\\"\\\\nUnderflow\\\";\\n    }\\n\\n    else {\\n        cout << \\\"\\\\n\\\" << queue[front++] << \\\" deleted\\\";\\n        for (int i = front; i < rear; i++) {\\n            queue[i - front] = queue[i];\\n        }\\n        rear = rear - front;\\n        front = 0;\\n    }\\n}\\n\\nvoid show() {\\n    for (int i = front; i < rear; i++) {\\n        cout << queue[i] << \\\"\\\\t\\\";\\n    }\\n}\\n\\nint main() {\\n    int ch, x;\\n    do {\\n        cout << \\\"\\\\n1. Enque\\\";\\n        cout << \\\"\\\\n2. Deque\\\";\\n        cout << \\\"\\\\n3. Print\\\";\\n        cout << \\\"\\\\nEnter Your Choice : \\\";\\n        cin >> ch;\\n        if (ch == 1) {\\n            cout << \\\"\\\\nInsert : \\\";\\n            cin >> x;\\n            Enque(x);\\n        } else if (ch == 2) {\\n            Deque();\\n        } else if (ch == 3) {\\n            show();\\n        }\\n    } while (ch != 0);\\n\\n    return 0;\\n}\\n\"",
    "queue using linkedlist": "\"/*\\n    Write a program to implement Queue using linkedlist.\\n*/\\n#include <iostream>\\n\\nstruct linkedlist {\\n    int data;\\n    linkedlist *next;\\n};\\nclass stack_linkedList {\\n public:\\n    linkedlist *front;\\n    linkedlist *rear;\\n\\n    stack_linkedList() { front = rear = NULL; }\\n    void enqueue(int);\\n    int dequeue();\\n    void display();\\n};\\nvoid stack_linkedList::enqueue(int ele) {\\n    linkedlist *temp = new linkedlist();\\n    temp->data = ele;\\n    temp->next = NULL;\\n\\n    if (front == NULL)\\n        front = rear = temp;\\n    else {\\n        rear->next = temp;\\n        rear = temp;\\n    }\\n}\\nint stack_linkedList::dequeue() {\\n    linkedlist *temp;\\n    int ele;\\n    if (front == NULL)\\n        std::cout << \\\"\\\\nStack is empty\\\";\\n    else {\\n        temp = front;\\n        ele = temp->data;\\n        if (front == rear)  // if length of queue is 1;\\n            rear = rear->next;\\n        front = front->next;\\n        delete (temp);\\n    }\\n    return ele;\\n}\\nvoid stack_linkedList::display() {\\n    if (front == NULL)\\n        std::cout << \\\"\\\\nStack is empty\\\";\\n\\n    else {\\n        linkedlist *temp;\\n        temp = front;\\n        while (temp != NULL) {\\n            std::cout << temp->data << \\\" \\\";\\n            temp = temp->next;\\n        }\\n    }\\n}\\n\\nint main() {\\n    int op, data;\\n    stack_linkedList ob;\\n    std::cout << \\\"\\\\n1. enqueue(Insertion) \\\";\\n    std::cout << \\\"\\\\n2. dequeue(Deletion)\\\";\\n    std::cout << \\\"\\\\n3. Display\\\";\\n    std::cout << \\\"\\\\n4. Exit\\\";\\n\\n    while (1) {\\n        std::cout << \\\"\\\\nEnter your choice \\\";\\n        std::cin >> op;\\n        if (op == 1) {\\n            std::cout << \\\"Enter data \\\";\\n            std::cin >> data;\\n            ob.enqueue(data);\\n        } else if (op == 2)\\n            data = ob.dequeue();\\n        else if (op == 3)\\n            ob.display();\\n        else if (op == 4)\\n            exit(0);\\n        else\\n            std::cout << \\\"\\\\nWrong choice \\\";\\n    }\\n    return 0;\\n}\\n\"",
    "queue using linked list": "\"#include <iostream>\\nusing namespace std;\\n\\nstruct node {\\n    int val;\\n    node *next;\\n};\\n\\nnode *front, *rear;\\n\\nvoid Enque(int x) {\\n    if (rear == NULL) {\\n        node *n = new node;\\n        n->val = x;\\n        n->next = NULL;\\n        rear = n;\\n        front = n;\\n    }\\n\\n    else {\\n        node *n = new node;\\n        n->val = x;\\n        n->next = NULL;\\n        rear->next = n;\\n        rear = n;\\n    }\\n}\\n\\nvoid Deque() {\\n    if (rear == NULL && front == NULL) {\\n        cout << \\\"\\\\nUnderflow\\\";\\n    } else {\\n        node *t = front;\\n        cout << \\\"\\\\n\\\" << t->val << \\\" deleted\\\";\\n        front = front->next;\\n        delete t;\\n        if (front == NULL)\\n            rear = NULL;\\n    }\\n}\\n\\nvoid show() {\\n    node *t = front;\\n    while (t != NULL) {\\n        cout << t->val << \\\"\\\\t\\\";\\n        t = t->next;\\n    }\\n}\\n\\nint main() {\\n    int ch, x;\\n    do {\\n        cout << \\\"\\\\n1. Enque\\\";\\n        cout << \\\"\\\\n2. Deque\\\";\\n        cout << \\\"\\\\n3. Print\\\";\\n        cout << \\\"\\\\nEnter Your Choice : \\\";\\n        cin >> ch;\\n        if (ch == 1) {\\n            cout << \\\"\\\\nInsert : \\\";\\n            cin >> x;\\n            Enque(x);\\n        } else if (ch == 2) {\\n            Deque();\\n        } else if (ch == 3) {\\n            show();\\n        }\\n    } while (ch != 0);\\n\\n    return 0;\\n}\\n\"",
    "queue using two stacks": "\"/**\\n * @author [shoniavika](https://github.com/shoniavika)\\n * @file\\n *\\n * Implementation of a Queue using two Stacks.\\n */\\n\\n#include <cassert>\\n#include <iostream>\\n#include <stack>\\n\\nnamespace {\\n/**\\n * @brief Queue data structure. Stores elements in FIFO\\n * (first-in-first-out) manner.\\n * @tparam T datatype to store in the queue\\n */\\ntemplate <typename T>\\nclass MyQueue {\\n private:\\n    std::stack<T> s1, s2;\\n\\n public:\\n    /**\\n     * Constructor for queue.\\n     */\\n    MyQueue() = default;\\n\\n    /**\\n     * Pushes x to the back of queue.\\n     */\\n    void push(T x);\\n\\n    /**\\n     * Removes an element from the front of the queue.\\n     */\\n    const T& pop();\\n\\n    /**\\n     * Returns first element, without removing it.\\n     */\\n    const T& peek() const;\\n\\n    /**\\n     * Returns whether the queue is empty.\\n     */\\n    bool empty() const;\\n};\\n\\n/**\\n * Appends element to the end of the queue\\n */\\ntemplate <typename T>\\nvoid MyQueue<T>::push(T x) {\\n    while (!s2.empty()) {\\n        s1.push(s2.top());\\n        s2.pop();\\n    }\\n    s2.push(x);\\n    while (!s1.empty()) {\\n        s2.push(s1.top());\\n        s1.pop();\\n    }\\n}\\n\\n/**\\n * Removes element from the front of the queue\\n */\\ntemplate <typename T>\\nconst T& MyQueue<T>::pop() {\\n    const T& temp = MyQueue::peek();\\n    s2.pop();\\n    return temp;\\n}\\n\\n/**\\n * Returns element in the front.\\n * Does not remove it.\\n */\\ntemplate <typename T>\\nconst T& MyQueue<T>::peek() const {\\n    if (!empty()) {\\n        return s2.top();\\n    }\\n    std::cerr << \\\"Queue is empty\\\" << std::endl;\\n    exit(0);\\n}\\n\\n/**\\n * Checks whether a queue is empty\\n */\\ntemplate <typename T>\\nbool MyQueue<T>::empty() const {\\n    return s2.empty() && s1.empty();\\n}\\n}  // namespace\\n\\n/**\\n * Testing function\\n */\\nvoid queue_test() {\\n    MyQueue<int> que;\\n    std::cout << \\\"Test #1\\\\n\\\";\\n    que.push(2);\\n    que.push(5);\\n    que.push(0);\\n    assert(que.peek() == 2);\\n    assert(que.pop() == 2);\\n    assert(que.peek() == 5);\\n    assert(que.pop() == 5);\\n    assert(que.peek() == 0);\\n    assert(que.pop() == 0);\\n    assert(que.empty() == true);\\n    std::cout << \\\"PASSED\\\\n\\\";\\n\\n    std::cout << \\\"Test #2\\\\n\\\";\\n    que.push(-1);\\n    assert(que.empty() == false);\\n    assert(que.peek() == -1);\\n    assert(que.pop() == -1);\\n    std::cout << \\\"PASSED\\\\n\\\";\\n\\n    MyQueue<double> que2;\\n    std::cout << \\\"Test #3\\\\n\\\";\\n    que2.push(2.31223);\\n    que2.push(3.1415926);\\n    que2.push(2.92);\\n\\n    assert(que2.peek() == 2.31223);\\n    assert(que2.pop() == 2.31223);\\n    assert(que2.peek() == 3.1415926);\\n    assert(que2.pop() == 3.1415926);\\n    assert(que2.peek() == 2.92);\\n    assert(que2.pop() == 2.92);\\n    std::cout << \\\"PASSED\\\\n\\\";\\n}\\n\\n/**\\n * Main function, calls testing function\\n */\\nint main() {\\n    queue_test();\\n    return 0;\\n}\\n\"",
    "rb tree": "\"#include<iostream>\\n\\nusing namespace std;\\n\\nstruct node\\n{\\n\\tint key;\\n\\tnode *parent;\\n\\tchar color;\\n\\tnode *left;\\n\\tnode *right;\\n};\\nclass RBtree\\n{\\n\\tnode *root;\\n\\tnode *q;\\npublic:\\n\\tRBtree()\\n\\t{\\n\\t\\tq = NULL;\\n\\t\\troot = NULL;\\n\\t}\\n\\tvoid insert();\\n\\tvoid insertfix(node *);\\n\\tvoid leftrotate(node *);\\n\\tvoid rightrotate(node *);\\n\\tvoid del();\\n\\tnode* successor(node *);\\n\\tvoid delfix(node *);\\n\\tvoid disp();\\n\\tvoid display(node *);\\n\\tvoid search();\\n};\\nvoid RBtree::insert()\\n{\\n\\tint z, i = 0;\\n\\tcout << \\\"\\\\nEnter key of the node to be inserted: \\\";\\n\\tcin >> z;\\n\\tnode *p, *q;\\n\\tnode *t = new node;\\n\\tt->key = z;\\n\\tt->left = NULL;\\n\\tt->right = NULL;\\n\\tt->color = 'r';\\n\\tp = root;\\n\\tq = NULL;\\n\\tif (root == NULL)\\n\\t{\\n\\t\\troot = t;\\n\\t\\tt->parent = NULL;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\twhile (p != NULL)\\n\\t\\t{\\n\\t\\t\\tq = p;\\n\\t\\t\\tif (p->key < t->key)\\n\\t\\t\\t\\tp = p->right;\\n\\t\\t\\telse\\n\\t\\t\\t\\tp = p->left;\\n\\t\\t}\\n\\t\\tt->parent = q;\\n\\t\\tif (q->key < t->key)\\n\\t\\t\\tq->right = t;\\n\\t\\telse\\n\\t\\t\\tq->left = t;\\n\\t}\\n\\tinsertfix(t);\\n}\\nvoid RBtree::insertfix(node *t)\\n{\\n\\tnode *u;\\n\\tif (root == t)\\n\\t{\\n\\t\\tt->color = 'b';\\n\\t\\treturn;\\n\\t}\\n\\twhile (t->parent != NULL && t->parent->color == 'r')\\n\\t{\\n\\t\\tnode *g = t->parent->parent;\\n\\t\\tif (g->left == t->parent)\\n\\t\\t{\\n\\t\\t\\tif (g->right != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tu = g->right;\\n\\t\\t\\t\\tif (u->color == 'r')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt->parent->color = 'b';\\n\\t\\t\\t\\t\\tu->color = 'b';\\n\\t\\t\\t\\t\\tg->color = 'r';\\n\\t\\t\\t\\t\\tt = g;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (t->parent->right == t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt = t->parent;\\n\\t\\t\\t\\t\\tleftrotate(t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tt->parent->color = 'b';\\n\\t\\t\\t\\tg->color = 'r';\\n\\t\\t\\t\\trightrotate(g);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (g->left != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tu = g->left;\\n\\t\\t\\t\\tif (u->color == 'r')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt->parent->color = 'b';\\n\\t\\t\\t\\t\\tu->color = 'b';\\n\\t\\t\\t\\t\\tg->color = 'r';\\n\\t\\t\\t\\t\\tt = g;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (t->parent->left == t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt = t->parent;\\n\\t\\t\\t\\t\\trightrotate(t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tt->parent->color = 'b';\\n\\t\\t\\t\\tg->color = 'r';\\n\\t\\t\\t\\tleftrotate(g);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\troot->color = 'b';\\n\\t}\\n}\\n\\nvoid RBtree::del()\\n{\\n\\tif (root == NULL)\\n\\t{\\n\\t\\tcout << \\\"\\\\nEmpty Tree.\\\";\\n\\t\\treturn;\\n\\t}\\n\\tint x;\\n\\tcout << \\\"\\\\nEnter the key of the node to be deleted: \\\";\\n\\tcin >> x;\\n\\tnode *p;\\n\\tp = root;\\n\\tnode *y = NULL;\\n\\tnode *q = NULL;\\n\\tint found = 0;\\n\\twhile (p != NULL && found == 0)\\n\\t{\\n\\t\\tif (p->key == x)\\n\\t\\t\\tfound = 1;\\n\\t\\tif (found == 0)\\n\\t\\t{\\n\\t\\t\\tif (p->key < x)\\n\\t\\t\\t\\tp = p->right;\\n\\t\\t\\telse\\n\\t\\t\\t\\tp = p->left;\\n\\t\\t}\\n\\t}\\n\\tif (found == 0)\\n\\t{\\n\\t\\tcout << \\\"\\\\nElement Not Found.\\\";\\n\\t\\treturn;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tcout << \\\"\\\\nDeleted Element: \\\" << p->key;\\n\\t\\tcout << \\\"\\\\nColour: \\\";\\n\\t\\tif (p->color == 'b')\\n\\t\\t\\tcout << \\\"Black\\\\n\\\";\\n\\t\\telse\\n\\t\\t\\tcout << \\\"Red\\\\n\\\";\\n\\n\\t\\tif (p->parent != NULL)\\n\\t\\t\\tcout << \\\"\\\\nParent: \\\" << p->parent->key;\\n\\t\\telse\\n\\t\\t\\tcout << \\\"\\\\nThere is no parent of the node.  \\\";\\n\\t\\tif (p->right != NULL)\\n\\t\\t\\tcout << \\\"\\\\nRight Child: \\\" << p->right->key;\\n\\t\\telse\\n\\t\\t\\tcout << \\\"\\\\nThere is no right child of the node.  \\\";\\n\\t\\tif (p->left != NULL)\\n\\t\\t\\tcout << \\\"\\\\nLeft Child: \\\" << p->left->key;\\n\\t\\telse\\n\\t\\t\\tcout << \\\"\\\\nThere is no left child of the node.  \\\";\\n\\t\\tcout << \\\"\\\\nNode Deleted.\\\";\\n\\t\\tif (p->left == NULL || p->right == NULL)\\n\\t\\t\\ty = p;\\n\\t\\telse\\n\\t\\t\\ty = successor(p);\\n\\t\\tif (y->left != NULL)\\n\\t\\t\\tq = y->left;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (y->right != NULL)\\n\\t\\t\\t\\tq = y->right;\\n\\t\\t\\telse\\n\\t\\t\\t\\tq = NULL;\\n\\t\\t}\\n\\t\\tif (q != NULL)\\n\\t\\t\\tq->parent = y->parent;\\n\\t\\tif (y->parent == NULL)\\n\\t\\t\\troot = q;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (y == y->parent->left)\\n\\t\\t\\t\\ty->parent->left = q;\\n\\t\\t\\telse\\n\\t\\t\\t\\ty->parent->right = q;\\n\\t\\t}\\n\\t\\tif (y != p)\\n\\t\\t{\\n\\t\\t\\tp->color = y->color;\\n\\t\\t\\tp->key = y->key;\\n\\t\\t}\\n\\t\\tif (y->color == 'b')\\n\\t\\t\\tdelfix(q);\\n\\t}\\n}\\n\\nvoid RBtree::delfix(node *p)\\n{\\n\\tnode *s;\\n\\twhile (p != root && p->color == 'b')\\n\\t{\\n\\t\\tif (p->parent->left == p)\\n\\t\\t{\\n\\t\\t\\ts = p->parent->right;\\n\\t\\t\\tif (s->color == 'r')\\n\\t\\t\\t{\\n\\t\\t\\t\\ts->color = 'b';\\n\\t\\t\\t\\tp->parent->color = 'r';\\n\\t\\t\\t\\tleftrotate(p->parent);\\n\\t\\t\\t\\ts = p->parent->right;\\n\\t\\t\\t}\\n\\t\\t\\tif (s->right->color == 'b'&&s->left->color == 'b')\\n\\t\\t\\t{\\n\\t\\t\\t\\ts->color = 'r';\\n\\t\\t\\t\\tp = p->parent;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (s->right->color == 'b')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts->left->color = 'b';\\n\\t\\t\\t\\t\\ts->color = 'r';\\n\\t\\t\\t\\t\\trightrotate(s);\\n\\t\\t\\t\\t\\ts = p->parent->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ts->color = p->parent->color;\\n\\t\\t\\t\\tp->parent->color = 'b';\\n\\t\\t\\t\\ts->right->color = 'b';\\n\\t\\t\\t\\tleftrotate(p->parent);\\n\\t\\t\\t\\tp = root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ts = p->parent->left;\\n\\t\\t\\tif (s->color == 'r')\\n\\t\\t\\t{\\n\\t\\t\\t\\ts->color = 'b';\\n\\t\\t\\t\\tp->parent->color = 'r';\\n\\t\\t\\t\\trightrotate(p->parent);\\n\\t\\t\\t\\ts = p->parent->left;\\n\\t\\t\\t}\\n\\t\\t\\tif (s->left->color == 'b'&&s->right->color == 'b')\\n\\t\\t\\t{\\n\\t\\t\\t\\ts->color = 'r';\\n\\t\\t\\t\\tp = p->parent;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (s->left->color == 'b')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts->right->color = 'b';\\n\\t\\t\\t\\t\\ts->color = 'r';\\n\\t\\t\\t\\t\\tleftrotate(s);\\n\\t\\t\\t\\t\\ts = p->parent->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ts->color = p->parent->color;\\n\\t\\t\\t\\tp->parent->color = 'b';\\n\\t\\t\\t\\ts->left->color = 'b';\\n\\t\\t\\t\\trightrotate(p->parent);\\n\\t\\t\\t\\tp = root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tp->color = 'b';\\n\\t\\troot->color = 'b';\\n\\t}\\n}\\n\\nvoid RBtree::leftrotate(node *p)\\n{\\n\\tif (p->right == NULL)\\n\\t\\treturn;\\n\\telse\\n\\t{\\n\\t\\tnode *y = p->right;\\n\\t\\tif (y->left != NULL)\\n\\t\\t{\\n\\t\\t\\tp->right = y->left;\\n\\t\\t\\ty->left->parent = p;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tp->right = NULL;\\n\\t\\tif (p->parent != NULL)\\n\\t\\t\\ty->parent = p->parent;\\n\\t\\tif (p->parent == NULL)\\n\\t\\t\\troot = y;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (p == p->parent->left)\\n\\t\\t\\t\\tp->parent->left = y;\\n\\t\\t\\telse\\n\\t\\t\\t\\tp->parent->right = y;\\n\\t\\t}\\n\\t\\ty->left = p;\\n\\t\\tp->parent = y;\\n\\t}\\n}\\nvoid RBtree::rightrotate(node *p)\\n{\\n\\tif (p->left == NULL)\\n\\t\\treturn;\\n\\telse\\n\\t{\\n\\t\\tnode *y = p->left;\\n\\t\\tif (y->right != NULL)\\n\\t\\t{\\n\\t\\t\\tp->left = y->right;\\n\\t\\t\\ty->right->parent = p;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tp->left = NULL;\\n\\t\\tif (p->parent != NULL)\\n\\t\\t\\ty->parent = p->parent;\\n\\t\\tif (p->parent == NULL)\\n\\t\\t\\troot = y;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (p == p->parent->left)\\n\\t\\t\\t\\tp->parent->left = y;\\n\\t\\t\\telse\\n\\t\\t\\t\\tp->parent->right = y;\\n\\t\\t}\\n\\t\\ty->right = p;\\n\\t\\tp->parent = y;\\n\\t}\\n}\\n\\nnode* RBtree::successor(node *p)\\n{\\n\\tnode *y = NULL;\\n\\tif (p->left != NULL)\\n\\t{\\n\\t\\ty = p->left;\\n\\t\\twhile (y->right != NULL)\\n\\t\\t\\ty = y->right;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\ty = p->right;\\n\\t\\twhile (y->left != NULL)\\n\\t\\t\\ty = y->left;\\n\\t}\\n\\treturn y;\\n}\\n\\nvoid RBtree::disp()\\n{\\n\\tdisplay(root);\\n}\\nvoid RBtree::display(node *p)\\n{\\n\\tif (root == NULL)\\n\\t{\\n\\t\\tcout << \\\"\\\\nEmpty Tree.\\\";\\n\\t\\treturn;\\n\\t}\\n\\tif (p != NULL)\\n\\t{\\n\\t\\tcout << \\\"\\\\n\\\\t NODE: \\\";\\n\\t\\tcout << \\\"\\\\n Key: \\\" << p->key;\\n\\t\\tcout << \\\"\\\\n Colour: \\\";\\n\\t\\tif (p->color == 'b')\\n\\t\\t\\tcout << \\\"Black\\\";\\n\\t\\telse\\n\\t\\t\\tcout << \\\"Red\\\";\\n\\t\\tif (p->parent != NULL)\\n\\t\\t\\tcout << \\\"\\\\n Parent: \\\" << p->parent->key;\\n\\t\\telse\\n\\t\\t\\tcout << \\\"\\\\n There is no parent of the node.  \\\";\\n\\t\\tif (p->right != NULL)\\n\\t\\t\\tcout << \\\"\\\\n Right Child: \\\" << p->right->key;\\n\\t\\telse\\n\\t\\t\\tcout << \\\"\\\\n There is no right child of the node.  \\\";\\n\\t\\tif (p->left != NULL)\\n\\t\\t\\tcout << \\\"\\\\n Left Child: \\\" << p->left->key;\\n\\t\\telse\\n\\t\\t\\tcout << \\\"\\\\n There is no left child of the node.  \\\";\\n\\t\\tcout << endl;\\n\\t\\tif (p->left)\\n\\t\\t{\\n\\t\\t\\tcout << \\\"\\\\n\\\\nLeft:\\\\n\\\";\\n\\t\\t\\tdisplay(p->left);\\n\\t\\t}\\n\\t\\t/*else\\n\\t\\t cout<<\\\"\\\\nNo Left Child.\\\\n\\\";*/\\n\\t\\tif (p->right)\\n\\t\\t{\\n\\t\\t\\tcout << \\\"\\\\n\\\\nRight:\\\\n\\\";\\n\\t\\t\\tdisplay(p->right);\\n\\t\\t}\\n\\t\\t/*else\\n\\t\\t cout<<\\\"\\\\nNo Right Child.\\\\n\\\"*/\\n\\t}\\n}\\nvoid RBtree::search()\\n{\\n\\tif (root == NULL)\\n\\t{\\n\\t\\tcout << \\\"\\\\nEmpty Tree\\\\n\\\";\\n\\t\\treturn;\\n\\t}\\n\\tint x;\\n\\tcout << \\\"\\\\n Enter key of the node to be searched: \\\";\\n\\tcin >> x;\\n\\tnode *p = root;\\n\\tint found = 0;\\n\\twhile (p != NULL && found == 0)\\n\\t{\\n\\t\\tif (p->key == x)\\n\\t\\t\\tfound = 1;\\n\\t\\tif (found == 0)\\n\\t\\t{\\n\\t\\t\\tif (p->key < x)\\n\\t\\t\\t\\tp = p->right;\\n\\t\\t\\telse\\n\\t\\t\\t\\tp = p->left;\\n\\t\\t}\\n\\t}\\n\\tif (found == 0)\\n\\t\\tcout << \\\"\\\\nElement Not Found.\\\";\\n\\telse\\n\\t{\\n\\t\\tcout << \\\"\\\\n\\\\t FOUND NODE: \\\";\\n\\t\\tcout << \\\"\\\\n Key: \\\" << p->key;\\n\\t\\tcout << \\\"\\\\n Colour: \\\";\\n\\t\\tif (p->color == 'b')\\n\\t\\t\\tcout << \\\"Black\\\";\\n\\t\\telse\\n\\t\\t\\tcout << \\\"Red\\\";\\n\\t\\tif (p->parent != NULL)\\n\\t\\t\\tcout << \\\"\\\\n Parent: \\\" << p->parent->key;\\n\\t\\telse\\n\\t\\t\\tcout << \\\"\\\\n There is no parent of the node.  \\\";\\n\\t\\tif (p->right != NULL)\\n\\t\\t\\tcout << \\\"\\\\n Right Child: \\\" << p->right->key;\\n\\t\\telse\\n\\t\\t\\tcout << \\\"\\\\n There is no right child of the node.  \\\";\\n\\t\\tif (p->left != NULL)\\n\\t\\t\\tcout << \\\"\\\\n Left Child: \\\" << p->left->key;\\n\\t\\telse\\n\\t\\t\\tcout << \\\"\\\\n There is no left child of the node.  \\\";\\n\\t\\tcout << endl;\\n\\n\\t}\\n}\\nint main()\\n{\\n\\tint ch, y = 0;\\n\\tRBtree obj;\\n\\tdo\\n\\t{\\n\\t\\tcout << \\\"\\\\n\\\\t RED BLACK TREE \\\";\\n\\t\\tcout << \\\"\\\\n 1. Insert in the tree \\\";\\n\\t\\tcout << \\\"\\\\n 2. Delete a node from the tree\\\";\\n\\t\\tcout << \\\"\\\\n 3. Search for an element in the tree\\\";\\n\\t\\tcout << \\\"\\\\n 4. Display the tree \\\";\\n\\t\\tcout << \\\"\\\\n 5. Exit \\\";\\n\\t\\tcout << \\\"\\\\nEnter Your Choice: \\\";\\n\\t\\tcin >> ch;\\n\\t\\tswitch (ch)\\n\\t\\t{\\n\\t\\tcase 1: obj.insert();\\n\\t\\t\\tcout << \\\"\\\\nNode Inserted.\\\\n\\\";\\n\\t\\t\\tbreak;\\n\\t\\tcase 2: obj.del();\\n\\t\\t\\tbreak;\\n\\t\\tcase 3: obj.search();\\n\\t\\t\\tbreak;\\n\\t\\tcase 4: obj.disp();\\n\\t\\t\\tbreak;\\n\\t\\tcase 5: y = 1;\\n\\t\\t\\tbreak;\\n\\t\\tdefault: cout << \\\"\\\\nEnter a Valid Choice.\\\";\\n\\t\\t}\\n\\t\\tcout << endl;\\n\\n\\t} while (y != 1);\\n\\treturn 1;\\n}\\n\"",
    "reverse a linked list": "\"/**\\n * @file\\n * @brief Implementation of [Reversing\\n * a single linked list](https://simple.wikipedia.org/wiki/Linked_list)\\n * @details\\n * The linked list is a data structure used for holding a sequence of\\n * values, which can be added, displayed, reversed, or removed.\\n * ### Algorithm\\n * Values can be added by iterating to the end of a list (by following\\n * the pointers) starting from the first link. Whichever link points to null\\n * is considered the last link and is pointed to the new value.\\n *\\n * Linked List can be reversed by using 3 pointers: current, previous, and\\n * next_node; we keep iterating until the last node. Meanwhile, before changing\\n * to the next of current, we store it in the next_node pointer, now we store\\n * the prev pointer in the current of next, this is where the actual reversal\\n * happens. And then we move the prev and current pointers one step forward.\\n * Then the head node is made to point to the last node (prev pointer) after\\n * completion of an iteration.\\n\\n * [A graphic explanation and view of what's happening behind the\\n *scenes](https://drive.google.com/file/d/1pM5COF0wx-wermnNy_svtyZquaCUP2xS/view?usp=sharing)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for I/O operations\\n#include <memory>    /// for dynamic memory\\n#include <new>       /// for managing  dynamic storage\\n\\n/**\\n * @namespace data_structures\\n * @brief Data Structures algorithms\\n */\\nnamespace data_structures {\\n/**\\n * @namespace linked_list\\n * @brief Functions for singly linked list algorithm\\n */\\nnamespace linked_list {\\n/**\\n * A Node class containing a value and pointer to another link\\n */\\nclass Node {\\n public:\\n    int32_t val;  /// value of the current link\\n    Node *next;   /// pointer to the next value on the list\\n};\\n\\n/**\\n * A list class containing a sequence of links\\n */\\nclass list {\\n private:\\n    Node *head;  // link before the actual first element\\n public:\\n    /**\\n     * List constructor. Initializes the first link.\\n     */\\n    list() {\\n        head = nullptr;  // Initialize the first link\\n    }\\n    bool isEmpty();\\n    void insert(int32_t new_elem);\\n    void reverseList();\\n    void display();\\n    int32_t top();\\n    int32_t last();\\n    int32_t traverse(int32_t index);\\n};\\n\\n/**\\n * @brief Utility function that checks if the list is empty\\n * @returns true if the list is empty\\n * @returns false if the list is not empty\\n */\\nbool list::isEmpty() { return head == nullptr; }\\n\\n/**\\n * @brief Utility function that adds a new element at the end of the list\\n * @param new_elem element be added at the end of the list\\n */\\nvoid list::insert(int32_t n) {\\n    try {\\n        Node *new_node = new Node();\\n        Node *temp = nullptr;\\n        new_node->val = n;\\n        new_node->next = nullptr;\\n        if (isEmpty()) {\\n            head = new_node;\\n        } else {\\n            temp = head;\\n            while (temp->next != nullptr) {\\n                temp = temp->next;\\n            }\\n            temp->next = new_node;\\n        }\\n    } catch (std::bad_alloc &exception) {\\n        std::cerr << \\\"bad_alloc detected: \\\" << exception.what() << \\\"\\\\n\\\";\\n    }\\n}\\n\\n/**\\n * @brief Utility function for reversing a list\\n * @brief Using the current, previous, and next pointer.\\n * @returns void\\n */\\nvoid list::reverseList() {\\n    Node *curr = head;\\n    Node *prev = nullptr, *next_node = nullptr;\\n    while (curr != nullptr) {\\n        next_node = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next_node;\\n    }\\n    head = prev;\\n}\\n\\n/**\\n * @brief Utility function to find the top element of the list\\n * @returns the top element of the list\\n */\\nint32_t list::top() {\\n    if (!isEmpty()) {\\n        return head->val;\\n    } else {\\n        throw std::logic_error(\\\"List is empty\\\");\\n    }\\n}\\n/**\\n *  @brief Utility function to find the last element of the list\\n *  @returns the last element of the list\\n */\\nint32_t list::last() {\\n    if (!isEmpty()) {\\n        Node *t = head;\\n        while (t->next != nullptr) {\\n            t = t->next;\\n        }\\n        return t->val;\\n    } else {\\n        throw std::logic_error(\\\"List is empty\\\");\\n    }\\n}\\n/**\\n *  @brief Utility function to find the i th element of the list\\n *  @returns the i th element of the list\\n */\\nint32_t list::traverse(int index) {\\n    Node *current = head;\\n\\n    int count = 0;\\n    while (current != nullptr) {\\n        if (count == index) {\\n            return (current->val);\\n        }\\n        count++;\\n        current = current->next;\\n    }\\n\\n    /* if we get to this line,the caller was asking for a non-existent element\\n    so we assert fail */\\n    exit(1);\\n}\\n\\n}  // namespace linked_list\\n}  // namespace data_structures\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    data_structures::linked_list::list L;\\n    // 1st test\\n    L.insert(11);\\n    L.insert(12);\\n    L.insert(15);\\n    L.insert(10);\\n    L.insert(-12);\\n    L.insert(-20);\\n    L.insert(18);\\n    assert(L.top() == 11);\\n    assert(L.last() == 18);\\n    L.reverseList();\\n    // Reversal Testing\\n    assert(L.top() == 18);\\n    assert(L.traverse(1) == -20);\\n    assert(L.traverse(2) == -12);\\n    assert(L.traverse(3) == 10);\\n    assert(L.traverse(4) == 15);\\n    assert(L.traverse(5) == 12);\\n    assert(L.last() == 11);\\n    std::cout << \\\"All tests have successfully passed!\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "skip list": "\"/**\\n * @file skip_list.cpp\\n * @brief Data structure for fast searching and insertion in \\\\f$O(\\\\log n)\\\\f$\\n * time\\n * @details\\n * A skip list is a data structure that is used for storing a sorted list of\\n * items with a help of hierarchy of linked lists that connect increasingly\\n * sparse subsequences of the items\\n *\\n * References used: [GeeksForGeek](https://www.geeksforgeeks.org/skip-list/),\\n * [OpenGenus](https://iq.opengenus.org/skip-list) for PseudoCode and Code\\n * @author [enqidu](https://github.com/enqidu)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n */\\n\\n#include <array>\\n#include <cstring>\\n#include <ctime>\\n#include <iostream>\\n#include <memory>\\n#include <vector>\\n\\n/** \\\\namespace data_structures\\n * \\\\brief Data-structure algorithms\\n */\\nnamespace data_structures {\\nconstexpr int MAX_LEVEL = 2;        ///< Maximum level of skip list\\nconstexpr float PROBABILITY = 0.5;  ///< Current probability for \\\"coin toss\\\"\\n\\n/**\\n *  Node structure [Key][Node*, Node*...]\\n */\\nstruct Node {\\n    int key;      ///< key integer\\n    void* value;  ///< pointer of value\\n    std::vector<std::shared_ptr<Node>>\\n        forward;  ///< nodes of the given one in all levels\\n\\n    /**\\n     * Creates node with provided key, level and value\\n     * @param key is number that is used for comparision\\n     * @param level is the maximum level node's going to added\\n     */\\n    Node(int key, int level, void* value = nullptr) : key(key), value(value) {\\n        // Initialization of forward vector\\n        for (int i = 0; i < (level + 1); i++) {\\n            forward.push_back(nullptr);\\n        }\\n    }\\n};\\n\\n/**\\n * SkipList class implementation with basic methods\\n */\\nclass SkipList {\\n    int level;                     ///< Maximum level of the skiplist\\n    std::shared_ptr<Node> header;  ///< Pointer to the header node\\n\\n public:\\n    /**\\n     * Skip List constructor. Initializes header, start\\n     * Node for searching in the list\\n     */\\n    SkipList() {\\n        level = 0;\\n        // Header initialization\\n        header = std::make_shared<Node>(-1, MAX_LEVEL);\\n    }\\n\\n    /**\\n     * Returns random level of the skip list.\\n     * Every higher level is 2 times less likely.\\n     * @return random level for skip list\\n     */\\n    int randomLevel() {\\n        int lvl = 0;\\n        while (static_cast<float>(std::rand()) / RAND_MAX < PROBABILITY &&\\n               lvl < MAX_LEVEL) {\\n            lvl++;\\n        }\\n        return lvl;\\n    }\\n\\n    /**\\n     * Inserts elements with given key and value;\\n     * It's level is computed by randomLevel() function.\\n     * @param key is number that is used for comparision\\n     * @param value pointer to a value, that can be any type\\n     */\\n    void insertElement(int key, void* value) {\\n        std::cout << \\\"Inserting\\\" << key << \\\"...\\\";\\n        std::shared_ptr<Node> x = header;\\n        std::array<std::shared_ptr<Node>, MAX_LEVEL + 1> update;\\n        update.fill(nullptr);\\n\\n        for (int i = level; i >= 0; i--) {\\n            while (x->forward[i] != nullptr && x->forward[i]->key < key) {\\n                x = x->forward[i];\\n            }\\n            update[i] = x;\\n        }\\n\\n        x = x->forward[0];\\n\\n        bool doesnt_exist = (x == nullptr || x->key != key);\\n        if (doesnt_exist) {\\n            int rlevel = randomLevel();\\n\\n            if (rlevel > level) {\\n                for (int i = level + 1; i < rlevel + 1; i++) update[i] = header;\\n\\n                // Update current level\\n                level = rlevel;\\n            }\\n\\n            std::shared_ptr<Node> n =\\n                std::make_shared<Node>(key, rlevel, value);\\n            for (int i = 0; i <= rlevel; i++) {\\n                n->forward[i] = update[i]->forward[i];\\n                update[i]->forward[i] = n;\\n            }\\n            std::cout << \\\"Inserted\\\" << std::endl;\\n\\n        } else {\\n            std::cout << \\\"Exists\\\" << std::endl;\\n        }\\n    }\\n\\n    /**\\n     * Deletes an element by key and prints if has been removed successfully\\n     * @param key is number that is used for comparision.\\n     */\\n    void deleteElement(int key) {\\n        std::shared_ptr<Node> x = header;\\n\\n        std::array<std::shared_ptr<Node>, MAX_LEVEL + 1> update;\\n        update.fill(nullptr);\\n\\n        for (int i = level; i >= 0; i--) {\\n            while (x->forward[i] != nullptr && x->forward[i]->key < key) {\\n                x = x->forward[i];\\n            }\\n            update[i] = x;\\n        }\\n\\n        x = x->forward[0];\\n\\n        bool doesnt_exist = (x == nullptr || x->key != key);\\n\\n        if (!doesnt_exist) {\\n            for (int i = 0; i <= level; i++) {\\n                if (update[i]->forward[i] != x) {\\n                    break;\\n                }\\n                update[i]->forward[i] = x->forward[i];\\n            }\\n            /* Remove empty levels*/\\n            while (level > 0 && header->forward[level] == nullptr) level--;\\n            std::cout << \\\"Deleted\\\" << std::endl;\\n        } else {\\n            std::cout << \\\"Doesn't exist\\\" << std::endl;\\n        }\\n    }\\n\\n    /**\\n     * Searching element in skip list structure\\n     * @param key is number that is used for comparision\\n     * @return pointer to the value of the node\\n     */\\n    void* searchElement(int key) {\\n        std::shared_ptr<Node> x = header;\\n        std::cout << \\\"Searching for \\\" << key << std::endl;\\n\\n        for (int i = level; i >= 0; i--) {\\n            while (x->forward[i] && x->forward[i]->key < key) x = x->forward[i];\\n        }\\n\\n        x = x->forward[0];\\n        if (x && x->key == key) {\\n            std::cout << \\\"Found\\\" << std::endl;\\n            return x->value;\\n        } else {\\n            std::cout << \\\"Not Found\\\" << std::endl;\\n            return nullptr;\\n        }\\n    }\\n\\n    /**\\n     * Display skip list level\\n     */\\n    void displayList() {\\n        std::cout << \\\"Displaying list:\\\\n\\\";\\n        for (int i = 0; i <= level; i++) {\\n            std::shared_ptr<Node> node = header->forward[i];\\n            std::cout << \\\"Level \\\" << (i) << \\\": \\\";\\n            while (node != nullptr) {\\n                std::cout << node->key << \\\" \\\";\\n                node = node->forward[i];\\n            }\\n            std::cout << std::endl;\\n        }\\n    }\\n};\\n\\n}  // namespace data_structures\\n\\n/**\\n * Main function:\\n * Creates and inserts random 2^[number of levels]\\n * elements into the skip lists and than displays it\\n */\\nint main() {\\n    std::srand(std::time(nullptr));\\n\\n    data_structures::SkipList lst;\\n\\n    for (int j = 0; j < (1 << (data_structures::MAX_LEVEL + 1)); j++) {\\n        int k = (std::rand() % (1 << (data_structures::MAX_LEVEL + 2)) + 1);\\n        lst.insertElement(k, &j);\\n    }\\n\\n    lst.displayList();\\n\\n    return 0;\\n}\\n\"",
    "sparse table": "\"/**\\n * @file sparse_table.cpp\\n * @brief Implementation of [Sparse Table](https://en.wikipedia.org/wiki/Range_minimum_query) data structure\\n *\\n * @details\\n * Sparse Table is a data structure, that allows answering range queries.\\n * It can answer most range queries in O(logn), but its true power is answering range minimum queries\\n * or equivalent range maximum queries). For those queries it can compute the answer in O(1) time.\\n *\\n * * Running Time Complexity \\\\n\\n * * Build : O(NlogN) \\\\n\\n * * Range Query : O(1) \\\\n\\n*/\\n\\n#include <vector>\\n#include <cassert>\\n#include <iostream>\\n#include <algorithm>\\n\\n/**\\n * @namespace range_queries\\n * @brief Range Queries algorithms\\n */\\nnamespace range_queries {\\n/**\\n * @namespace sparse_table\\n * @brief Range queries using sparse-tables\\n */\\n namespace sparse_table {\\n/**\\n * This function precomputes intial log table for further use.\\n * @param n value of the size of the input array\\n * @return corresponding vector of the log table\\n */\\ntemplate<typename T>\\nstd::vector<T> computeLogs(const std::vector<T>& A) {\\n    int n = A.size();\\n    std::vector<T> logs(n);\\n    logs[1] = 0;\\n    for (int i = 2 ; i < n ; i++) {\\n        logs[i] = logs[i/2] + 1;\\n    }\\n    return logs;\\n}\\n\\n/**\\n * This functions builds the primary data structure sparse table\\n * @param n value of the size of the input array\\n * @param A array of the input integers\\n * @param logs array of the log table\\n * @return created sparse table data structure\\n */\\ntemplate<typename T>\\nstd::vector<std::vector<T> > buildTable(const std::vector<T>& A, const std::vector<T>& logs) {\\n    int n = A.size();\\n    std::vector<std::vector<T> > table(20, std::vector<T>(n+5, 0));\\n    int curLen = 0;\\n    for (int i = 0 ; i <= logs[n] ; i++) {\\n        curLen = 1 << i;\\n        for (int j = 0 ; j + curLen < n ; j++) {\\n            if (curLen == 1) {\\n                table[i][j] = A[j];\\n            }\\n            else {\\n                table[i][j] = std::min(table[i-1][j], table[i-1][j + curLen/2]);\\n            }\\n        }\\n    }\\n    return table;\\n}\\n\\n/**\\n * This function is the query function to get the range minimum value\\n * @param beg beginning index of the query range\\n * @param end ending index of the query range\\n * @param logs array of the log table\\n * @param table sparse table data structure for the input array\\n * @return minimum value for the [beg, end] range for the input array\\n */\\ntemplate<typename T>\\nint getMinimum(int beg, int end, const std::vector<T>& logs, const std::vector<std::vector<T> >& table) {\\n    int p = logs[end - beg + 1];\\n    int pLen = 1 << p;\\n    return std::min(table[p][beg], table[p][end - pLen + 1]);\\n}\\n}\\n} // namespace range_queries\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    std::vector<int> A{1, 2, 0, 3, 9};\\n    std::vector<int> logs = range_queries::sparse_table::computeLogs(A);\\n    std::vector<std::vector<int> >  table = range_queries::sparse_table::buildTable(A, logs);\\n    assert(range_queries::sparse_table::getMinimum(0, 0, logs, table) == 1);\\n    assert(range_queries::sparse_table::getMinimum(0, 4, logs, table) == 0);\\n    assert(range_queries::sparse_table::getMinimum(2, 4, logs, table) == 0);\\n    return 0;\\n}\\n\\n\"",
    "stack": "\"/**\\n * @file stack.h\\n * @author danghai\\n * @brief  This class specifies the basic operation on a stack as a linked list\\n **/\\n#ifndef DATA_STRUCTURES_STACK_H_\\n#define DATA_STRUCTURES_STACK_H_\\n\\n#include <cassert>\\n#include <iostream>\\n\\n/** Definition of the node as a linked-list\\n * \\\\tparam Type type of data nodes of the linked list should contain\\n */\\ntemplate <class Type>\\nstruct node {\\n    Type data;         ///< data at current node\\n    node<Type> *next;  ///< pointer to the next ::node instance\\n};\\n\\n/** Definition of the stack class\\n * \\\\tparam Type type of data nodes of the linked list in the stack should\\n * contain\\n */\\ntemplate <class Type>\\nclass stack {\\n public:\\n    /** Show stack */\\n    void display() {\\n        node<Type> *current = stackTop;\\n        std::cout << \\\"Top --> \\\";\\n        while (current != nullptr) {\\n            std::cout << current->data << \\\"  \\\";\\n            current = current->next;\\n        }\\n        std::cout << std::endl;\\n        std::cout << \\\"Size of stack: \\\" << size << std::endl;\\n    }\\n\\n    /** Default constructor*/\\n    stack() {\\n        stackTop = nullptr;\\n        size = 0;\\n    }\\n\\n    /** Copy constructor*/\\n    explicit stack(const stack<Type> &otherStack) {\\n        node<Type> *newNode, *current, *last;\\n\\n        /* If stack is no empty, make it empty */\\n        if (stackTop != nullptr) {\\n            stackTop = nullptr;\\n        }\\n        if (otherStack.stackTop == nullptr) {\\n            stackTop = nullptr;\\n        } else {\\n            current = otherStack.stackTop;\\n            stackTop = new node<Type>;\\n            stackTop->data = current->data;\\n            stackTop->next = nullptr;\\n            last = stackTop;\\n            current = current->next;\\n            /* Copy the remaining stack */\\n            while (current != nullptr) {\\n                newNode = new node<Type>;\\n                newNode->data = current->data;\\n                newNode->next = nullptr;\\n                last->next = newNode;\\n                last = newNode;\\n                current = current->next;\\n            }\\n        }\\n        size = otherStack.size;\\n    }\\n\\n    /** Destructor */\\n    ~stack() {}\\n\\n    /** Determine whether the stack is empty */\\n    bool isEmptyStack() { return (stackTop == nullptr); }\\n\\n    /** Add new item to the stack */\\n    void push(Type item) {\\n        node<Type> *newNode;\\n        newNode = new node<Type>;\\n        newNode->data = item;\\n        newNode->next = stackTop;\\n        stackTop = newNode;\\n        size++;\\n    }\\n\\n    /** Return the top element of the stack */\\n    Type top() {\\n        assert(stackTop != nullptr);\\n        return stackTop->data;\\n    }\\n\\n    /** Remove the top element of the stack */\\n    void pop() {\\n        node<Type> *temp;\\n        if (!isEmptyStack()) {\\n            temp = stackTop;\\n            stackTop = stackTop->next;\\n            delete temp;\\n            size--;\\n        } else {\\n            std::cout << \\\"Stack is empty !\\\" << std::endl;\\n        }\\n    }\\n\\n    /** Clear stack */\\n    void clear() { stackTop = nullptr; }\\n\\n    /** Overload \\\"=\\\" the assignment operator */\\n    stack<Type> &operator=(const stack<Type> &otherStack) {\\n        node<Type> *newNode, *current, *last;\\n\\n        /* If stack is no empty, make it empty */\\n        if (stackTop != nullptr) {\\n            stackTop = nullptr;\\n        }\\n        if (otherStack.stackTop == nullptr) {\\n            stackTop = nullptr;\\n        } else {\\n            current = otherStack.stackTop;\\n            stackTop = new node<Type>;\\n            stackTop->data = current->data;\\n            stackTop->next = nullptr;\\n            last = stackTop;\\n            current = current->next;\\n            /* Copy the remaining stack */\\n            while (current != nullptr) {\\n                newNode = new node<Type>;\\n                newNode->data = current->data;\\n                newNode->next = nullptr;\\n                last->next = newNode;\\n                last = newNode;\\n                current = current->next;\\n            }\\n        }\\n        size = otherStack.size;\\n        return *this;\\n    }\\n\\n private:\\n    node<Type> *stackTop; /**< Pointer to the stack */\\n    int size;             ///< size of stack\\n};\\n\\n#endif  // DATA_STRUCTURES_STACK_H_\\n\"",
    "stack using array": "\"#include <iostream>\\n\\nint *stack;\\nint stack_idx = 0, stack_size;\\n\\nvoid push(int x) {\\n    if (stack_idx == stack_size) {\\n        std::cout << \\\"\\\\nOverflow\\\";\\n    } else {\\n        stack[stack_idx++] = x;\\n    }\\n}\\n\\nvoid pop() {\\n    if (stack_idx == 0) {\\n        std::cout << \\\"\\\\nUnderflow\\\";\\n    } else {\\n        std::cout << \\\"\\\\n\\\" << stack[--stack_idx] << \\\" deleted\\\";\\n    }\\n}\\n\\nvoid show() {\\n    for (int i = 0; i < stack_idx; i++) {\\n        std::cout << stack[i] << \\\"\\\\n\\\";\\n    }\\n}\\n\\nvoid topmost() { std::cout << \\\"\\\\nTopmost element: \\\" << stack[stack_idx - 1]; }\\nvoid bottom() { std::cout << \\\"\\\\nBottom element: \\\" << stack[0]; } // If we need access to first element without using pop command \\nint main() {\\n    std::cout << \\\"\\\\nEnter stack_size of stack : \\\";\\n    std::cin >> stack_size;\\n    stack = new int[stack_size];\\n    int ch, x;\\n    do {\\n        std::cout << \\\"\\\\n0. Exit\\\";\\n        std::cout << \\\"\\\\n1. Push\\\";\\n        std::cout << \\\"\\\\n2. Pop\\\";\\n        std::cout << \\\"\\\\n3. Print\\\";\\n        std::cout << \\\"\\\\n4. Print topmost element:\\\";\\n        std::cout << \\\"\\\\n5. Print Bottom element:\\\";\\n        std::cout << \\\"\\\\nEnter Your Choice : \\\";\\n        std::cin >> ch;\\n        if (ch == 1) {\\n            std::cout << \\\"\\\\nInsert : \\\";\\n            std::cin >> x;\\n            push(x);\\n        } else if (ch == 2) {\\n            pop();\\n        } else if (ch == 3) {\\n            show();\\n        } else if (ch == 4) {\\n            topmost();\\n        } else if(ch == 5) {\\n            bottom();\\n        }\\n    } while (ch != 0);\\n\\n    delete[] stack;\\n\\n    return 0;\\n}\\n\"",
    "stack using linked list": "\"#include <iostream>\\n\\nstruct node {\\n    int val;\\n    node *next;\\n};\\n\\nnode *top_var;\\n\\nvoid push(int x) {\\n    node *n = new node;\\n    n->val = x;\\n    n->next = top_var;\\n    top_var = n;\\n}\\n\\nvoid pop() {\\n    if (top_var == nullptr) {\\n        std::cout << \\\"\\\\nUnderflow\\\";\\n    } else {\\n        node *t = top_var;\\n        std::cout << \\\"\\\\n\\\" << t->val << \\\" deleted\\\";\\n        top_var = top_var->next;\\n        delete t;\\n    }\\n}\\n\\nvoid show() {\\n    node *t = top_var;\\n    while (t != nullptr) {\\n        std::cout << t->val << \\\"\\\\n\\\";\\n        t = t->next;\\n    }\\n}\\n\\nint main() {\\n    int ch = 0, x = 0;\\n    do {\\n        std::cout << \\\"\\\\n0. Exit or Ctrl+C\\\";\\n        std::cout << \\\"\\\\n1. Push\\\";\\n        std::cout << \\\"\\\\n2. Pop\\\";\\n        std::cout << \\\"\\\\n3. Print\\\";\\n        std::cout << \\\"\\\\nEnter Your Choice: \\\";\\n        std::cin >> ch;\\n        switch (ch) {\\n            case 0:\\n                break;\\n            case 1:\\n                std::cout << \\\"\\\\nInsert : \\\";\\n                std::cin >> x;\\n                push(x);\\n                break;\\n            case 2:\\n                pop();\\n                break;\\n            case 3:\\n                show();\\n                break;\\n            default:\\n                std::cout << \\\"Invalid option!\\\\n\\\";\\n                break;\\n        }\\n    } while (ch != 0);\\n\\n    return 0;\\n}\\n\"",
    "stack using queue": "\"/**\\n * @brief Stack Data Structure Using the Queue Data Structure\\n * @details\\n * Using 2 Queues inside the Stack class, we can easily implement Stack\\n * data structure with heavy computation in push function.\\n *\\n * References used:\\n * [StudyTonight](https://www.studytonight.com/data-structures/stack-using-queue)\\n * @author [tushar2407](https://github.com/tushar2407)\\n */\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <queue>     /// for queue data structure\\n\\n/**\\n * @namespace data_strcutres\\n * @brief Data structures algorithms\\n */\\nnamespace data_structures {\\n/**\\n * @namespace stack_using_queue\\n * @brief Functions for the [Stack Using\\n * Queue](https://www.studytonight.com/data-structures/stack-using-queue)\\n * implementation\\n */\\nnamespace stack_using_queue {\\n/**\\n * @brief Stack Class implementation for basic methods of Stack Data Structure.\\n */\\nstruct Stack {\\n    std::queue<int64_t> main_q;       ///< stores the current state of the stack\\n    std::queue<int64_t> auxiliary_q;  ///< used to carry out intermediate\\n                                      ///< operations to implement stack\\n    uint32_t current_size = 0;        ///< stores the current size of the stack\\n\\n    /**\\n     * Returns the top most element of the stack\\n     * @returns top element of the queue\\n     */\\n    int top() { return main_q.front(); }\\n\\n    /**\\n     * @brief Inserts an element to the top of the stack.\\n     * @param val the element that will be inserted into the stack\\n     * @returns void\\n     */\\n    void push(int val) {\\n        auxiliary_q.push(val);\\n        while (!main_q.empty()) {\\n            auxiliary_q.push(main_q.front());\\n            main_q.pop();\\n        }\\n        swap(main_q, auxiliary_q);\\n        current_size++;\\n    }\\n\\n    /**\\n     * @brief Removes the topmost element from the stack\\n     * @returns void\\n     */\\n    void pop() {\\n        if (main_q.empty()) {\\n            return;\\n        }\\n        main_q.pop();\\n        current_size--;\\n    }\\n\\n    /**\\n     * @brief Utility function to return the current size of the stack\\n     * @returns current size of stack\\n     */\\n    int size() { return current_size; }\\n};\\n}  // namespace stack_using_queue\\n}  // namespace data_structures\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    data_structures::stack_using_queue::Stack s;\\n    s.push(1);  /// insert an element into the stack\\n    s.push(2);  /// insert an element into the stack\\n    s.push(3);  /// insert an element into the stack\\n\\n    assert(s.size() == 3);  /// size should be 3\\n\\n    assert(s.top() == 3);  /// topmost element in the stack should be 3\\n\\n    s.pop();               /// remove the topmost element from the stack\\n    assert(s.top() == 2);  /// topmost element in the stack should now be 2\\n\\n    s.pop();  /// remove the topmost element from the stack\\n    assert(s.top() == 1);\\n\\n    s.push(5);             /// insert an element into the stack\\n    assert(s.top() == 5);  /// topmost element in the stack should now be 5\\n\\n    s.pop();               /// remove the topmost element from the stack\\n    assert(s.top() == 1);  /// topmost element in the stack should now be 1\\n\\n    assert(s.size() == 1);  /// size should be 1\\n}\\n\\n/**\\n * @brief Main function\\n * Creates a stack and pushed some value into it.\\n * Through a series of push and pop functions on stack,\\n * it demostrates the functionality of the custom stack\\n * declared above.\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "student": "\"3.4 Tom\\n3.2 Kathy\\n2.5 Hoang\\n3.4 Tom\\n3.8 Randy\\n3.9 Kingston\\n3.8 Mickey\\n3.6 Peter\\n3.5 Donald\\n3.8 Cindy\\n3.7 Dome\\n3.9 Andy\\n3.8 Hai\\n3.9 Minnie\\n2.7 Gilda\\n3.9 Vinay\\n3.4 Hiral\\n\"",
    "test queue": "\"#include <iostream>\\n#include <string>\\n\\n#include \\\"./queue.h\\\"\\n\\nint main() {\\n    queue<std::string> q;\\n    std::cout << \\\"---------------------- Test construct ----------------------\\\"\\n              << std::endl;\\n    q.display();\\n    std::cout\\n        << \\\"---------------------- Test isEmptyQueue ----------------------\\\"\\n        << std::endl;\\n    if (q.isEmptyQueue())\\n        std::cout << \\\"PASS\\\" << std::endl;\\n    else\\n        std::cout << \\\"FAIL\\\" << std::endl;\\n    std::cout << \\\"---------------------- Test enQueue ----------------------\\\"\\n              << std::endl;\\n    std::cout << \\\"After Hai, Jeff, Tom, Jkingston go into queue: \\\" << std::endl;\\n    q.enQueue(\\\"Hai\\\");\\n    q.enQueue(\\\"Jeff\\\");\\n    q.enQueue(\\\"Tom\\\");\\n    q.enQueue(\\\"Jkingston\\\");\\n    q.display();\\n    std::cout << \\\"---------------------- Test front ----------------------\\\"\\n              << std::endl;\\n    std::string value = q.front();\\n    if (value == \\\"Hai\\\")\\n        std::cout << \\\"PASS\\\" << std::endl;\\n    else\\n        std::cout << \\\"FAIL\\\" << std::endl;\\n    std::cout << \\\"---------------------- Test deQueue ----------------------\\\"\\n              << std::endl;\\n    q.display();\\n    q.deQueue();\\n    q.deQueue();\\n    std::cout << \\\"After Hai, Jeff left the queue: \\\" << std::endl;\\n    q.display();\\n    return 0;\\n}\\n\"",
    "test stack": "\"#include <iostream>\\n\\n#include \\\"./stack.h\\\"\\n\\nint main() {\\n    stack<int> stk;\\n    std::cout << \\\"---------------------- Test construct ----------------------\\\"\\n              << std::endl;\\n    stk.display();\\n    std::cout\\n        << \\\"---------------------- Test isEmptyStack ----------------------\\\"\\n        << std::endl;\\n    if (stk.isEmptyStack())\\n        std::cout << \\\"PASS\\\" << std::endl;\\n    else\\n        std::cout << \\\"FAIL\\\" << std::endl;\\n    std::cout << \\\"---------------------- Test push ----------------------\\\"\\n              << std::endl;\\n    std::cout << \\\"After pushing 10 20 30 40 into stack: \\\" << std::endl;\\n    stk.push(10);\\n    stk.push(20);\\n    stk.push(30);\\n    stk.push(40);\\n    stk.display();\\n    std::cout << \\\"---------------------- Test top ----------------------\\\"\\n              << std::endl;\\n    int value = stk.top();\\n    if (value == 40)\\n        std::cout << \\\"PASS\\\" << std::endl;\\n    else\\n        std::cout << \\\"FAIL\\\" << std::endl;\\n    std::cout << \\\"---------------------- Test pop ----------------------\\\"\\n              << std::endl;\\n    stk.display();\\n    stk.pop();\\n    stk.pop();\\n    std::cout << \\\"After popping 2 times: \\\" << std::endl;\\n    stk.display();\\n    std::cout << \\\"---------------------- Test overload = operator \\\"\\n                 \\\"----------------------\\\"\\n              << std::endl;\\n    stack<int> stk1;\\n    std::cout << \\\"stk current: \\\" << std::endl;\\n    stk.display();\\n    std::cout << std::endl << \\\"Assign stk1 = stk \\\" << std::endl;\\n    stk1 = stk;\\n    stk1.display();\\n    std::cout << std::endl << \\\"After pushing 8 9 10 into stk1:\\\" << std::endl;\\n    stk1.push(8);\\n    stk1.push(9);\\n    stk1.push(10);\\n    stk1.display();\\n    std::cout << std::endl << \\\"stk current: \\\" << std::endl;\\n    stk.display();\\n    std::cout << \\\"Assign back stk = stk1:\\\" << std::endl;\\n    stk = stk1;\\n    stk.display();\\n    return 0;\\n}\\n\"",
    "test stack students": "\"/*\\n * This program reads a data file consisting of students' GPAs\\n * followed by their names. The program then prints the highest\\n * GPA and the names of the students with the highest GPA.\\n * It uses stack to store the names of the students\\n * Run:\\n *     make all\\n *     ./main student.txt\\n ************************************************************\\n * */\\n#include <cassert>\\n#include <fstream>\\n#include <iomanip>\\n#include <iostream>\\n#include <string>\\n\\n#include \\\"./stack.h\\\"\\n\\nint main(int argc, char* argv[]) {\\n    double GPA;\\n    double highestGPA;\\n    std::string name;\\n\\n    assert(argc == 2);\\n    std::ifstream infile;\\n    stack<std::string> stk;\\n\\n    infile.open(argv[1]);\\n    std::cout << std::fixed << std::showpoint;\\n    std::cout << std::setprecision(2);\\n    infile >> GPA >> name;\\n    highestGPA = GPA;\\n\\n    while (infile) {\\n        if (GPA > highestGPA) {\\n            stk.clear();\\n            stk.push(name);\\n            highestGPA = GPA;\\n        } else if (GPA == highestGPA) {\\n            stk.push(name);\\n        }\\n        infile >> GPA >> name;\\n    }\\n    std::cout << \\\"Highest GPA: \\\" << highestGPA << std::endl;\\n    std::cout << \\\"Students the highest GPA are: \\\" << std::endl;\\n    while (!stk.isEmptyStack()) {\\n        std::cout << stk.top() << std::endl;\\n        stk.pop();\\n    }\\n    std::cout << std::endl;\\n    return 0;\\n}\\n\"",
    "tree": "\"#include <iostream>\\n#include <list>\\nusing namespace std;\\n\\nstruct node {\\n    int val;\\n    node *left;\\n    node *right;\\n};\\n\\nvoid CreateTree(node *curr, node *n, int x, char pos) {\\n    if (n != NULL) {\\n        char ch;\\n        cout << \\\"\\\\nLeft or Right of \\\" << n->val << \\\" : \\\";\\n        cin >> ch;\\n        if (ch == 'l')\\n            CreateTree(n, n->left, x, ch);\\n        else if (ch == 'r')\\n            CreateTree(n, n->right, x, ch);\\n    } else {\\n        node *t = new node;\\n        t->val = x;\\n        t->left = NULL;\\n        t->right = NULL;\\n        if (pos == 'l') {\\n            curr->left = t;\\n        } else if (pos == 'r') {\\n            curr->right = t;\\n        }\\n    }\\n}\\n\\nvoid BFT(node *n) {\\n    list<node *> queue;\\n\\n    queue.push_back(n);\\n\\n    while (!queue.empty()) {\\n        n = queue.front();\\n        cout << n->val << \\\"  \\\";\\n        queue.pop_front();\\n\\n        if (n->left != NULL)\\n            queue.push_back(n->left);\\n        if (n->right != NULL)\\n            queue.push_back(n->right);\\n    }\\n}\\n\\nvoid Pre(node *n) {\\n    if (n != NULL) {\\n        cout << n->val << \\\"  \\\";\\n        Pre(n->left);\\n        Pre(n->right);\\n    }\\n}\\n\\nvoid In(node *n) {\\n    if (n != NULL) {\\n        In(n->left);\\n        cout << n->val << \\\"  \\\";\\n        In(n->right);\\n    }\\n}\\n\\nvoid Post(node *n) {\\n    if (n != NULL) {\\n        Post(n->left);\\n        Post(n->right);\\n        cout << n->val << \\\"  \\\";\\n    }\\n}\\n\\nint main() {\\n    int value;\\n    int ch;\\n    node *root = new node;\\n    cout << \\\"\\\\nEnter the value of root node :\\\";\\n    cin >> value;\\n    root->val = value;\\n    root->left = NULL;\\n    root->right = NULL;\\n    do {\\n        cout << \\\"\\\\n1. Insert\\\";\\n        cout << \\\"\\\\n2. Breadth First\\\";\\n        cout << \\\"\\\\n3. Preorder Depth First\\\";\\n        cout << \\\"\\\\n4. Inorder Depth First\\\";\\n        cout << \\\"\\\\n5. Postorder Depth First\\\";\\n\\n        cout << \\\"\\\\nEnter Your Choice : \\\";\\n        cin >> ch;\\n        switch (ch) {\\n        case 1:\\n            int x;\\n            char pos;\\n            cout << \\\"\\\\nEnter the value to be Inserted : \\\";\\n            cin >> x;\\n            cout << \\\"\\\\nLeft or Right of Root : \\\";\\n            cin >> pos;\\n            if (pos == 'l')\\n                CreateTree(root, root->left, x, pos);\\n            else if (pos == 'r')\\n                CreateTree(root, root->right, x, pos);\\n            break;\\n        case 2:\\n            BFT(root);\\n            break;\\n        case 3:\\n            Pre(root);\\n            break;\\n        case 4:\\n            In(root);\\n            break;\\n        case 5:\\n            Post(root);\\n            break;\\n        }\\n    } while (ch != 0);\\n}\\n\"",
    "tree 234": "\"/**\\n * @file\\n * @brief A demo 2-3-4 tree implementation\\n * @details\\n * 2–3–4 tree is a self-balancing data structure that is an isometry of\\n * red–black trees. Though we seldom use them in practice, we study them\\n * to understand the theory behind Red-Black tree. Please read following\\n * links for more infomation.\\n * [2–3–4 tree](https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree)\\n * [2-3-4 Trees: A Visual\\nIntroduction](https://www.educative.io/page/5689413791121408/80001)\\n * We Only implement some basic and complicated operations in this demo.\\n * Other operations should be easy to be added.\\n * @author [liuhuan](https://github.com/fedom)\\n */\\n#include <array>     /// for std::array\\n#include <cassert>   /// for assert\\n#include <fstream>   /// for std::ofstream\\n#include <iostream>  /// for std::cout\\n#include <memory>    /// for std::unique_ptr\\n#include <queue>     /// for std::queue\\n#include <string>    /// for std::to_string\\n\\n/**\\n * @namespace data_structures\\n * @brief Algorithms with data structures\\n */\\nnamespace data_structures {\\n/**\\n * @namespace tree_234\\n * @brief Functions for [2–3–4 tree](https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree)\\n */\\nnamespace tree_234 {\\n/** @brief 2-3-4 tree node class */\\nclass Node {\\n public:\\n    /**\\n     * @brief Node constructor\\n     * @param item the first value we insert to the node\\n     */\\n    explicit Node(int64_t item)\\n        : count(1),\\n          items({{item, 0, 0}}),\\n          children({{nullptr, nullptr, nullptr, nullptr}}) {}\\n\\n    /**\\n     * @brief Get the item count that current saved in the node\\n     * @return item count\\n     */\\n    int8_t GetCount() { return count; }\\n\\n    /**\\n     * @brief Set the item count of the node\\n     *\\n     * This is only used when we spliting and merging node where we need to do\\n     * some raw operation manually. In common inserting and removing operation\\n     * the count is maintained automatically.\\n     *\\n     * @param c the count to set\\n     */\\n    void SetCount(int8_t c) { count = c; }\\n\\n    /**\\n     * @brief Check if node is a leaf\\n     * @return true if node is leaf, false otherwise\\n     */\\n    bool IsLeaf() { return children[0] == nullptr; }\\n\\n    /**\\n     * @brief Check if node is a full (4-node)\\n     * @return true if node is full (4-node), false otherwise\\n     */\\n    bool IsFull() { return count == 3; }\\n\\n    /**\\n     * @brief Check if node is a 2-node\\n     * @return true if node is 2-node, otherwise false\\n     */\\n    bool Is2Node() { return count == 1; }\\n\\n    /** @brief Check if node is a 3-node or 4-node, this is useful when we\\n     * delete item from 2-3-4 tree\\n     * @return true if node is 3-node or 4-node, false otherwise\\n     */\\n    bool Is34Node() { return count == 2 || count == 3; }\\n\\n    /**\\n     * @brief Check if item is in the node\\n     * @param item item to check\\n     * @return true if item in the node, otherwise false\\n     */\\n    bool Contains(int64_t item) {\\n        for (int8_t i = 0; i < count; i++) {\\n            if (item == items[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @brief Get the index of the item in the node, 0-based\\n     * @param item item to check\\n     * @return 0-based index of the item in the node, if not in the node, -1 is\\n     * returned\\n     */\\n    int8_t GetItemIndex(int64_t item) {\\n        for (int8_t i = 0; i < count; i++) {\\n            if (items[i] == item) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    /**\\n     * @brief Get max item (rightmost) in the current node\\n     * @return max item\\n     */\\n    int64_t GetMaxItem() { return items[count - 1]; }\\n\\n    /**\\n     * @brief get min item (leftmost) in the current node\\n     * @return min item\\n     */\\n    int64_t GetMinItem() { return items[0]; }\\n\\n    /**\\n     * @brief Get item of the \\\\index index\\n     * @param index the item index to get\\n     * @return the item\\n     */\\n    int64_t GetItem(int8_t index) { return items[index]; }\\n\\n    /**\\n     * @brief Set item value at position of index\\n     * @param index the index of the item to set\\n     * @param new_item item value\\n     */\\n    void SetItem(int8_t index, int64_t new_item) {\\n        assert(index >= 0 && index <= 2);\\n\\n        items[index] = new_item;\\n    }\\n\\n    /**\\n     * @brief Insert item to the proper position of the node and return the\\n     * position index.\\n     *\\n     * This is a helper function we use during insertion. Please mind that when\\n     * insert a item, we aslo need to take care of two child pointers. One is\\n     * the original child pointer at the insertion position. It can be placed as\\n     * new item's either left child or right child. And the other is the new\\n     * child that should be added. For our dedicated situation here, we choose\\n     * to use the original child as the new item's left child, and add a null\\n     * pointer to its right child. So after use the function, please update\\n     * these two children pointer manually.\\n     *\\n     * @param item value to be inserted to the node\\n     * @return index where item is inserted, caller can use this\\n     * index to update its left and right child\\n     */\\n    int InsertItem(int item) {\\n        assert(!IsFull());\\n\\n        if (Contains(item)) {\\n            return -1;\\n        }\\n\\n        int8_t i = 0;\\n        for (i = 0; i < count; i++) {\\n            if (items[i] > item) {\\n                break;\\n            }\\n        }\\n\\n        InsertItemByIndex(i, item, nullptr, true);\\n        return i;\\n    }\\n\\n    /**\\n     * @brief Insert a value to the index position\\n     * @param index index where to insert item\\n     * @param item  value to insert\\n     * @param with_child new added child pointer\\n     * @param to_left true indicate adding with_child to new item's left child,\\n     * otherwise to right child\\n     */\\n    void InsertItemByIndex(int8_t index, int64_t item, Node *with_child,\\n                           bool to_left = true) {\\n        assert(count < 3 && index >= 0 && index < 3);\\n\\n        for (int8_t i = count - 1; i >= index; i--) {\\n            items[i + 1] = items[i];\\n        }\\n\\n        items[index] = item;\\n\\n        int8_t start_index = to_left ? index : index + 1;\\n\\n        for (int8_t i = count; i >= start_index; i--) {\\n            children[i + 1] = children[i];\\n        }\\n\\n        children[start_index] = with_child;\\n\\n        count++;\\n    }\\n\\n    /**\\n     * @brief Insert a value to the index position\\n     * @param index index of the item to remove\\n     * @param keep_left which child of the item to keep, true keep the left\\n     * child, false keep the right child\\n     * @return the removed child pointer\\n     */\\n    Node *RemoveItemByIndex(int8_t index, bool keep_left) {\\n        assert(index >= 0 && index < count);\\n        Node *removed_child = keep_left ? children[index + 1] : children[index];\\n        for (int8_t i = index; i < count - 1; i++) {\\n            items[i] = items[i + 1];\\n        }\\n\\n        for (int8_t i = keep_left ? index + 1 : index; i < count; i++) {\\n            children[i] = children[i + 1];\\n        }\\n\\n        count--;\\n        return removed_child;\\n    }\\n\\n    /**\\n     * @brief Get the child's index of the children array\\n     * @param child child pointer of which to get the index\\n     * @return the index of child\\n     */\\n    int8_t GetChildIndex(Node *child) {\\n        for (int8_t i = 0; i < count + 1; i++) {\\n            if (children[i] == child) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    /**\\n     * @brief Get the child pointer at position of index\\n     * @param index index of child to get\\n     * @return the child pointer\\n     */\\n    Node *GetChild(int8_t index) { return children[index]; }\\n\\n    /**\\n     * @brief Set child pointer to the position of index\\n     * @param index children index\\n     * @param child pointer to set\\n     */\\n    void SetChild(int8_t index, Node *child) { children[index] = child; }\\n\\n    /**\\n     * @brief Get rightmose child of the current node\\n     * @return the rightmost child\\n     */\\n    Node *GetRightmostChild() { return children[count]; }\\n\\n    /**\\n     * @brief Get leftmose child of the current node\\n     * @return the leftmost child\\n     */\\n    Node *GetLeftmostChild() { return children[0]; }\\n\\n    /**\\n     * @brief Get left child of item at item_index\\n     * @param item_index  index of the item whose left child to be get\\n     * @return left child of items[index]'s\\n     */\\n    Node *GetItemLeftChild(int8_t item_index) {\\n        if (item_index < 0 || item_index > count - 1) {\\n            return nullptr;\\n        }\\n\\n        return children[item_index];\\n    }\\n\\n    /**\\n     * @brief Get right child of item at item_index\\n     * @param item_index  index of the item whose right child to be get\\n     * @return right child of items[index]'s\\n     */\\n    Node *GetItemRightChild(int8_t item_index) {\\n        if (item_index < 0 || item_index > count - 1) {\\n            return nullptr;\\n        }\\n\\n        return children[item_index + 1];\\n    }\\n\\n    /**\\n     * @brief Get next node which is possibly contains item\\n     * @param item item to search\\n     * @return the next node that possibly contains item\\n     */\\n    Node *GetNextPossibleChild(int64_t item) {\\n        int i = 0;\\n        for (i = 0; i < count; i++) {\\n            if (items[i] > item) {\\n                break;\\n            }\\n        }\\n        return children[i];\\n    }\\n\\n private:\\n    std::array<int64_t, 3> items;  ///< store items\\n\\n    std::array<Node *, 4> children;  ///< store the children pointers\\n\\n    int8_t count = 0;  ///< track the current item count\\n};\\n\\n/** @brief 2-3-4 tree class */\\nclass Tree234 {\\n public:\\n    Tree234() = default;\\n    Tree234(const Tree234 &) = delete;\\n    Tree234(const Tree234 &&) = delete;\\n    Tree234 &operator=(const Tree234 &) = delete;\\n    Tree234 &operator=(const Tree234 &&) = delete;\\n\\n    ~Tree234();\\n\\n    /**\\n     * @brief Insert item to tree\\n     * @param item item to insert\\n     */\\n    void Insert(int64_t item);\\n\\n    /**\\n     * @brief Remove item from tree\\n     * @param item item to remove\\n     * @return true if item found and removed, false otherwise\\n     */\\n    bool Remove(int64_t item);\\n\\n    /** @brief In-order traverse */\\n    void Traverse();\\n\\n    /**\\n     * @brief Print tree into a dot file\\n     * @param file_name output file name, if nullptr then use \\\"out.dot\\\" as\\n     * default\\n     */\\n    void Print(const char *file_name = nullptr);\\n\\n private:\\n    /**\\n     * @brief A insert implementation of pre-split\\n     * @param item item to insert\\n     */\\n    void InsertPreSplit(int64_t item);\\n\\n    /**\\n     * @brief A insert implementation of post-merge\\n     * @param item item to insert\\n     */\\n    void InsertPostMerge(int64_t item);\\n\\n    /**\\n     * @brief A helper function used by post-merge insert\\n     * @param tree tree where to insert item\\n     * @param item item to insert\\n     * @return the node that split as the parent when overflow happen\\n     */\\n    Node *Insert(Node *tree, int64_t item);\\n\\n    /**\\n     * @brief A helper function used during post-merge insert\\n     *\\n     * When the inserting leads to overflow, it will split the node to 1 parent\\n     * and 2 children. The parent will be merged to its origin parent after\\n     * that. This is the function to complete this task. So the param node is\\n     * always a 2-node.\\n     *\\n     * @param dst_node the target node we will merge node to, can be type of\\n     * 2-node, 3-node or 4-node\\n     * @param node the source node we will merge from, type must be 2-node\\n     * @return overflow node of this level\\n     */\\n    Node *MergeNode(Node *dst_node, Node *node);\\n\\n    /**\\n     * @brief Merge node to a not-full target node\\n     *\\n     * Since the target node is not-full, no overflow will happen. So we have\\n     * nothing to return.\\n     *\\n     * @param dst_node the target not-full node, that is the type is either\\n     * 2-node or 3-node, but not 4-node\\n     * @param node the source node we will merge from, type must be 2-node\\n     */\\n    void MergeNodeNotFull(Node *dst_node, Node *node);\\n\\n    /**\\n     * @brief Split a 4-node to 1 parent and 2 children, and return the parent\\n     * node\\n     * @param node the node to split, it must be a 4-node\\n     * @return split parent node\\n     */\\n    Node *SplitNode(Node *node);\\n\\n    /**\\n     * @brief Get the max item of the tree\\n     * @param tree the tree we will get item from\\n     * @return max item of the tree\\n     */\\n    int64_t GetTreeMaxItem(Node *tree);\\n\\n    /**\\n     * @brief Get the min item of the tree\\n     * @param tree the tree we will get item from\\n     * @return min item of the tree\\n     */\\n    int64_t GetTreeMinItem(Node *tree);\\n\\n    /**\\n     * @brief A handy function to try if we can do a left rotate to the target\\n     * node\\n     *\\n     * Given two node, the parent and the target child, the left rotate\\n     * operation is uniquely identified. The source node must be the right\\n     * sibling of the target child. The operation can be successfully done if\\n     * the to_child has a right sibling and its right sibling is not 2-node.\\n     *\\n     * @param parent the parent node in this left rotate operation\\n     * @param to_child the target child of this left rotate operation. In our\\n     * case, this node is always 2-node\\n     * @return true if we successfully do the rotate. false if the\\n     * requirements are not fulfilled.\\n     */\\n    bool TryLeftRotate(Node *parent, Node *to_child);\\n\\n    /**\\n     * @brief A handy function to try if we can do a right rotate to the target\\n     * node\\n     *\\n     * Given two node, the parent and the target child, the right rotate\\n     * operation is uniquely identified. The source node must be the left\\n     * sibling of the target child. The operation can be successfully done if\\n     * the to_child has a left sibling and its left sibling is not 2-node.\\n     *\\n     * @param parent the parent node in this right rotate operation\\n     * @param to_child the target child of this right rotate operation. In our\\n     * case, it is always 2-node\\n     * @return true if we successfully do the rotate. false if the\\n     * requirements are not fulfilled.\\n     */\\n    bool TryRightRotate(Node *parent, Node *to_child);\\n\\n    /**\\n     * @brief Do the actual right rotate operation\\n     *\\n     * Given parent node, and the pivot item index, the right rotate operation\\n     * is uniquely identified. The function assume the requirements are\\n     * fulfilled and won't do any extra check. This function is call by\\n     * TryRightRotate(), and the condition checking should be done before call\\n     * it.\\n     *\\n     * @param parent the parent node in this right rotate operation\\n     * @param index the pivot item index of this right rotate operation.\\n     */\\n    void RightRotate(Node *parent, int8_t index);\\n\\n    /**\\n     * @brief Do the actual left rotate operation\\n     *\\n     * Given parent node, and the pivot item index, the left rotate operation is\\n     * uniquely identified. The function assume the requirements are fulfilled\\n     * and won't do any extra check. This function is call by TryLeftRotate(),\\n     * and the condition checking should be done before call it.\\n     *\\n     * @param parent the parent node in this right rotate operation\\n     * @param index the pivot item index of this right rotate operation.\\n     */\\n    void LeftRotate(Node *parent, int8_t index);\\n\\n    /**\\n     * @brief Main function implement the pre-merge remove operation\\n     * @param node the tree to remove item from\\n     * @param item item to remove\\n     * @return true if remove success, false otherwise\\n     * */\\n    bool RemovePreMerge(Node *node, int64_t item);\\n\\n    /**\\n     * @brief Merge the item at index of the parent node, and its left and right\\n     * child\\n     *\\n     * the left and right child node must be 2-node. The 3 items will be merged\\n     * into a 4-node. In our case the parent can be a 2-node iff it is the root.\\n     * Otherwise, it must be 3-node or 4-node.\\n     *\\n     * @param parent the parent node in the merging operation\\n     * @param index the item index of the parent node that involved in the\\n     * merging\\n     * @return the merged 4-node\\n     */\\n    Node *Merge(Node *parent, int8_t index);\\n\\n    /**\\n     * @brief Recursive release the tree\\n     * @param tree root node of the tree to delete\\n     */\\n    void DeleteNode(Node *tree);\\n\\n    /**\\n     * @brief In-order traverse the tree, print items\\n     * @param tree tree to traverse\\n     */\\n    void Traverse(Node *tree);\\n\\n    /**\\n     * @brief Print the tree to a dot file. You can convert it to picture with\\n     * graphviz\\n     * @param ofs output file stream to print to\\n     * @param node current node to print\\n     * @param parent_index current node's parent node index, this is used to\\n     * draw the link from parent to current node\\n     * @param index current node's index of level order which is used to name\\n     * the node in dot file\\n     * @param parent_child_index the index that current node in parent's\\n     * children array, range in [0,4), help to locate the start position of the\\n     * link between nodes\\n     */\\n    void PrintNode(std::ofstream &ofs, Node *node, int64_t parent_index,\\n                   int64_t index, int8_t parent_child_index);\\n\\n    Node *root_{nullptr};  ///< root node of the tree\\n};\\n\\nTree234::~Tree234() { DeleteNode(root_); }\\n\\n/**\\n * @brief Recursive release the tree\\n * @param tree root node of the tree to delete\\n */\\nvoid Tree234::DeleteNode(Node *tree) {\\n    if (!tree) {\\n        return;\\n    }\\n    for (int8_t i = 0; i <= tree->GetCount(); i++) {\\n        DeleteNode(tree->GetChild(i));\\n    }\\n\\n    delete tree;\\n}\\n\\n/**\\n * @brief In-order traverse the tree, print items\\n * @param tree tree to traverse\\n */\\nvoid Tree234::Traverse() {\\n    Traverse(root_);\\n    std::cout << std::endl;\\n}\\n\\nvoid Tree234::Traverse(Node *node) {\\n    if (!node) {\\n        return;\\n    }\\n\\n    int8_t i = 0;\\n    for (i = 0; i < node->GetCount(); i++) {\\n        Traverse(node->GetChild(i));\\n        std::cout << node->GetItem(i) << \\\", \\\";\\n    }\\n\\n    Traverse(node->GetChild(i));\\n}\\n\\n/**\\n * @brief A insert implementation of pre-split\\n * @param item item to insert\\n */\\nvoid Tree234::InsertPreSplit(int64_t item) {\\n    if (!root_) {\\n        root_ = new Node(item);\\n        return;\\n    }\\n\\n    Node *parent = nullptr;\\n    Node *node = root_;\\n\\n    while (true) {\\n        if (!node) {\\n            std::unique_ptr<Node> tmp(new Node(item));\\n            MergeNodeNotFull(parent, tmp.get());\\n            return;\\n        }\\n\\n        if (node->Contains(item)) {\\n            return;\\n        }\\n\\n        if (node->IsFull()) {\\n            node = SplitNode(node);\\n\\n            Node *cur_node = nullptr;\\n\\n            if (item < node->GetItem(0)) {\\n                cur_node = node->GetChild(0);\\n            } else {\\n                cur_node = node->GetChild(1);\\n            }\\n\\n            if (!parent) {\\n                // for the root node parent is nullptr, we simply assign the\\n                // split parent to root_\\n                root_ = node;\\n            } else {\\n                // merge the split parent to its origin parent\\n                MergeNodeNotFull(parent, node);\\n            }\\n\\n            node = cur_node;\\n        }\\n\\n        parent = node;\\n        node = parent->GetNextPossibleChild(item);\\n    }\\n}\\n\\n/**\\n * @brief A insert implementation of post-merge\\n * @param item item to insert\\n */\\nvoid Tree234::InsertPostMerge(int64_t item) {\\n    if (!root_) {\\n        root_ = new Node(item);\\n        return;\\n    }\\n\\n    Node *split_node = Insert(root_, item);\\n\\n    // if root has split, then update root_\\n    if (split_node) {\\n        root_ = split_node;\\n    }\\n}\\n\\n/**\\n * @brief Insert item to tree\\n * @param item item to insert\\n */\\nvoid Tree234::Insert(int64_t item) { InsertPreSplit(item); }\\n\\n/**\\n * @brief A helper function used by post-merge insert\\n * @param tree tree where to insert item\\n * @param item item to insert\\n * @return the node that split as the parent when overflow happen\\n */\\nNode *Tree234::Insert(Node *tree, int64_t item) {\\n    assert(tree != nullptr);\\n\\n    std::unique_ptr<Node> split_node;\\n\\n    if (tree->Contains(item)) {\\n        // return nullptr indicate current node not overflow\\n        return nullptr;\\n    }\\n\\n    Node *next_node = tree->GetNextPossibleChild(item);\\n    if (next_node) {\\n        split_node.reset(Insert(next_node, item));\\n    } else {\\n        split_node.reset(new Node(item));\\n    }\\n\\n    if (split_node) {\\n        return MergeNode(tree, split_node.get());\\n    }\\n\\n    return nullptr;\\n}\\n\\n/**\\n * @brief A helper function used during post-merge insert\\n *\\n * When the inserting leads to overflow, it will split the node to 1 parent\\n * and 2 children. The parent will be merged to its origin parent after\\n * that. This is the function to complete this task. So the param node is\\n * always a 2-node.\\n *\\n * @param dst_node the target node we will merge node to, can be type of\\n * 2-node, 3-node or 4-node\\n * @param node the source node we will merge from, type must be 2-node\\n * @return overflow node of this level\\n */\\nNode *Tree234::MergeNode(Node *dst_node, Node *node) {\\n    assert(dst_node != nullptr && node != nullptr);\\n\\n    if (!dst_node->IsFull()) {\\n        MergeNodeNotFull(dst_node, node);\\n        return nullptr;\\n    }\\n\\n    dst_node = SplitNode(dst_node);\\n\\n    if (node->GetItem(0) < dst_node->GetItem(0)) {\\n        MergeNodeNotFull(dst_node->GetChild(0), node);\\n\\n    } else {\\n        MergeNodeNotFull(dst_node->GetChild(1), node);\\n    }\\n\\n    return dst_node;\\n}\\n\\n/**\\n * @brief Merge node to a not-full target node\\n *\\n * Since the target node is not-full, no overflow will happen. So we have\\n * nothing to return.\\n *\\n * @param dst_node the target not-full node, that is the type is either\\n * 2-node or 3-node, but not 4-node\\n * @param node the source node we will merge from, type must be 2-node\\n */\\nvoid Tree234::MergeNodeNotFull(Node *dst_node, Node *node) {\\n    assert(dst_node && node && !dst_node->IsFull() && node->Is2Node());\\n\\n    int8_t i = dst_node->InsertItem(node->GetItem(0));\\n\\n    dst_node->SetChild(i, node->GetChild(0));\\n    dst_node->SetChild(i + 1, node->GetChild(1));\\n}\\n\\n/**\\n * @brief Split a 4-node to 1 parent and 2 children, and return the parent\\n * node\\n * @param node the node to split, it must be a 4-node\\n * @return split parent node\\n */\\nNode *Tree234::SplitNode(Node *node) {\\n    assert(node->GetCount() == 3);\\n\\n    Node *left = node;\\n\\n    Node *right = new Node(node->GetItem(2));\\n    right->SetChild(0, node->GetChild(2));\\n    right->SetChild(1, node->GetChild(3));\\n\\n    Node *parent = new Node(node->GetItem(1));\\n    parent->SetChild(0, left);\\n    parent->SetChild(1, right);\\n\\n    left->SetCount(1);\\n\\n    return parent;\\n}\\n\\n/**\\n * @brief A handy function to try if we can do a left rotate to the target\\n * node\\n *\\n * Given two node, the parent and the target child, the left rotate\\n * operation is uniquely identified. The source node must be the right\\n * sibling of the target child. The operation can be successfully done if\\n * the to_child has a right sibling and its right sibling is not 2-node.\\n *\\n * @param parent the parent node in this left rotate operation\\n * @param to_child the target child of this left rotate operation. In our\\n * case, this node is always 2-node\\n * @return true if we successfully do the rotate. false if the\\n * requirements are not fulfilled.\\n */\\nbool Tree234::TryLeftRotate(Node *parent, Node *to_child) {\\n    int to_child_index = parent->GetChildIndex(to_child);\\n\\n    // child is right most, can not do left rotate to it\\n    if (to_child_index >= parent->GetCount()) {\\n        return false;\\n    }\\n\\n    Node *right_sibling = parent->GetChild(to_child_index + 1);\\n\\n    // right sibling is 2-node. can not do left rotate.\\n    if (right_sibling->Is2Node()) {\\n        return false;\\n    }\\n\\n    LeftRotate(parent, to_child_index);\\n\\n    return true;\\n}\\n\\n/**\\n * @brief A handy function to try if we can do a right rotate to the target\\n * node\\n *\\n * Given two node, the parent and the target child, the right rotate\\n * operation is uniquely identified. The source node must be the left\\n * sibling of the target child. The operation can be successfully done if\\n * the to_child has a left sibling and its left sibling is not 2-node.\\n *\\n * @param parent the parent node in this right rotate operation\\n * @param to_child the target child of this right rotate operation. In our\\n * case, it is always 2-node\\n * @return true if we successfully do the rotate. false if the\\n * requirements are not fulfilled.\\n */\\nbool Tree234::TryRightRotate(Node *parent, Node *to_child) {\\n    int8_t to_child_index = parent->GetChildIndex(to_child);\\n\\n    // child is left most, can not do right rotate to it\\n    if (to_child_index <= 0) {\\n        return false;\\n    }\\n\\n    Node *left_sibling = parent->GetChild(to_child_index - 1);\\n\\n    // right sibling is 2-node. can not do left rotate.\\n    if (left_sibling->Is2Node()) {\\n        return false;\\n    }\\n\\n    RightRotate(parent, to_child_index - 1);\\n\\n    return true;\\n}\\n\\n/**\\n * @brief Do the actual right rotate operation\\n *\\n * Given parent node, and the pivot item index, the right rotate operation\\n * is uniquely identified. The function assume the requirements are\\n * fulfilled and won't do any extra check. This function is call by\\n * TryRightRotate(), and the condition checking should be done before call\\n * it.\\n *\\n * @param parent the parent node in this right rotate operation\\n * @param index the pivot item index of this right rotate operation.\\n */\\nvoid Tree234::RightRotate(Node *parent, int8_t index) {\\n    Node *left = parent->GetItemLeftChild(index);\\n    Node *right = parent->GetItemRightChild(index);\\n\\n    assert(left && left->Is34Node());\\n    assert(right && right->Is2Node());\\n\\n    right->InsertItemByIndex(0, parent->GetItem(index),\\n                             left->GetRightmostChild(), true);\\n    parent->SetItem(index, left->GetMaxItem());\\n    left->RemoveItemByIndex(left->GetCount() - 1, true);\\n}\\n\\n/**\\n * @brief Do the actual left rotate operation\\n *\\n * Given parent node, and the pivot item index, the left rotate operation is\\n * uniquely identified. The function assume the requirements are fulfilled\\n * and won't do any extra check. This function is call by TryLeftRotate(),\\n * and the condition checking should be done before call it.\\n *\\n * @param parent the parent node in this right rotate operation\\n * @param index the pivot item index of this right rotate operation.\\n */\\nvoid Tree234::LeftRotate(Node *parent, int8_t index) {\\n    Node *left = parent->GetItemLeftChild(index);\\n    Node *right = parent->GetItemRightChild(index);\\n\\n    assert(right && right->Is34Node());\\n    assert(left && left->Is2Node());\\n\\n    left->InsertItemByIndex(left->GetCount(), parent->GetItem(index),\\n                            right->GetLeftmostChild(), false);\\n    parent->SetItem(index, right->GetMinItem());\\n    right->RemoveItemByIndex(0, false);\\n}\\n\\n/**\\n * @brief Merge the item at index of the parent node, and its left and right\\n * child\\n *\\n * the left and right child node must be 2-node. The 3 items will be merged\\n * into a 4-node. In our case the parent can be a 2-node iff it is the root.\\n * Otherwise, it must be 3-node or 4-node.\\n *\\n * @param parent the parent node in the merging operation\\n * @param index the item index of the parent node that involved in the\\n * merging\\n * @return the merged 4-node\\n */\\nNode *Tree234::Merge(Node *parent, int8_t index) {\\n    assert(parent);\\n\\n    // bool is_parent_2node = parent->Is2Node();\\n\\n    Node *left_child = parent->GetItemLeftChild(index);\\n    Node *right_child = parent->GetItemRightChild(index);\\n\\n    assert(left_child->Is2Node() && right_child->Is2Node());\\n\\n    int64_t item = parent->GetItem(index);\\n\\n    // 1. merge parent's item and right child to left child\\n    left_child->SetItem(1, item);\\n    left_child->SetItem(2, right_child->GetItem(0));\\n    left_child->SetChild(2, right_child->GetChild(0));\\n    left_child->SetChild(3, right_child->GetChild(1));\\n\\n    left_child->SetCount(3);\\n\\n    // 2. remove the parent's item\\n    parent->RemoveItemByIndex(index, true);\\n\\n    // 3. delete the unused right child\\n    delete right_child;\\n\\n    return left_child;\\n}\\n\\n/**\\n * @brief Remove item from tree\\n * @param item item to remove\\n * @return true if item found and removed, false otherwise\\n */\\nbool Tree234::Remove(int64_t item) { return RemovePreMerge(root_, item); }\\n\\n/**\\n * @brief Main function implement the pre-merge remove operation\\n * @param node the tree to remove item from\\n * @param item item to remove\\n * @return true if remove success, false otherwise\\n */\\nbool Tree234::RemovePreMerge(Node *node, int64_t item) {\\n    while (node) {\\n        if (node->IsLeaf()) {\\n            if (node->Contains(item)) {\\n                if (node->Is2Node()) {\\n                    // node must be root\\n                    delete node;\\n                    root_ = nullptr;\\n                } else {\\n                    node->RemoveItemByIndex(node->GetItemIndex(item), true);\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        // node is internal\\n        if (node->Contains(item)) {\\n            int8_t index = node->GetItemIndex(item);\\n\\n            // Here is important!!! What we do next depend on its children's\\n            // state. Why?\\n            Node *left_child = node->GetItemLeftChild(index);\\n            Node *right_child = node->GetItemRightChild(index);\\n            assert(left_child && right_child);\\n\\n            if (left_child->Is2Node() && right_child->Is2Node()) {\\n                // both left and right child are 2-node,we should not modify\\n                // current node in this situation. Because we are going to do\\n                // merge with its children which will move target item to next\\n                // layer. so if we replace the item with successor or\\n                // predecessor now, when we do the recursive remove with\\n                // successor or predecessor, we will result in removing the just\\n                // replaced one in the merged node. That's not what we want.\\n\\n                // we need to convert the child 2-node to 3-node or 4-node\\n                // first. First we try to see if any of them can convert to\\n                // 3-node by rotate. By using rotate we keep the empty house for\\n                // the future insertion which will be more efficient than merge.\\n                //\\n                //            | ? | node | ? |\\n                //           /    |      |    \\\\\\n                //          /     |      |     \\\\\\n                //         /      |      |      \\\\\\n                //        /       |      |       \\\\\\n                //       /        |      |        \\\\\\n                //      /         |      |         \\\\\\n                //     ?  left_child  right_child   ?\\n                //\\n\\n                // node must be the root\\n                if (node->Is2Node()) {\\n                    // this means we can't avoid merging the target item into\\n                    // next layer, and this will cause us do different process\\n                    // compared with other cases\\n                    Node *new_root = Merge(node, index);\\n                    delete root_;\\n                    root_ = new_root;\\n                    node = root_;\\n\\n                    // now node point to the\\n                    continue;\\n                }\\n\\n                // here means we can avoid merging the target item into next\\n                // layer. So we convert one of its left or right child to 3-node\\n                // and then do the successor or predecessor swap and recursive\\n                // remove the next layer will successor or predecessor.\\n                do {\\n                    if (index > 0) {\\n                        // left_child has left-sibling, we check if we can do a\\n                        // rotate\\n                        Node *left_sibling = node->GetItemLeftChild(index - 1);\\n                        if (left_sibling->Is34Node()) {\\n                            RightRotate(node, index - 1);\\n                            break;\\n                        }\\n                    }\\n\\n                    if (index < node->GetCount() - 1) {\\n                        // right_child has right-sibling, we check if we can do\\n                        // a rotate\\n                        Node *right_sibling =\\n                            node->GetItemRightChild(index + 1);\\n                        if (right_sibling->Is34Node()) {\\n                            LeftRotate(node, index + 1);\\n                            break;\\n                        }\\n                    }\\n\\n                    // we do a merge. We avoid merging the target item, which\\n                    // may trigger another merge in the recursion process.\\n                    if (index > 0) {\\n                        Merge(node, index - 1);\\n                        break;\\n                    }\\n\\n                    Merge(node, index + 1);\\n\\n                } while (false);\\n            }\\n\\n            // refresh the left_child and right_child since they may be invalid\\n            // because of merge\\n            left_child = node->GetItemLeftChild(index);\\n            right_child = node->GetItemRightChild(index);\\n\\n            if (left_child->Is34Node()) {\\n                int64_t predecessor_item = GetTreeMaxItem(left_child);\\n                node->SetItem(node->GetItemIndex(item), predecessor_item);\\n\\n                node = left_child;\\n                item = predecessor_item;\\n                continue;\\n            }\\n\\n            if (right_child->Is34Node()) {\\n                int64_t successor_item = GetTreeMinItem(right_child);\\n                node->SetItem(node->GetItemIndex(item), successor_item);\\n                node = right_child;\\n                item = successor_item;\\n                continue;\\n            }\\n        }\\n\\n        Node *next_node = node->GetNextPossibleChild(item);\\n\\n        if (next_node->Is34Node()) {\\n            node = next_node;\\n            continue;\\n        }\\n\\n        if (TryRightRotate(node, next_node)) {\\n            node = next_node;\\n            continue;\\n        }\\n\\n        if (TryLeftRotate(node, next_node)) {\\n            node = next_node;\\n            continue;\\n        }\\n\\n        // get here means both left sibling and right sibling of next_node is\\n        // 2-node, so we do merge\\n        int8_t child_index = node->GetChildIndex(next_node);\\n        if (child_index > 0) {\\n            node = Merge(node, child_index - 1);\\n        } else {\\n            node = Merge(node, child_index);\\n        }\\n\\n    }  // while\\n\\n    return false;\\n}\\n\\n/**\\n * @brief Get the max item of the tree\\n * @param tree the tree we will get item from\\n * @return max item of the tree\\n */\\nint64_t Tree234::GetTreeMaxItem(Node *tree) {\\n    assert(tree);\\n    int64_t max = 0;\\n\\n    while (tree) {\\n        max = tree->GetMaxItem();\\n        tree = tree->GetRightmostChild();\\n    }\\n\\n    return max;\\n}\\n\\n/**\\n * @brief Get the min item of the tree\\n * @param tree the tree we will get item from\\n * @return min item of the tree\\n */\\nint64_t Tree234::GetTreeMinItem(Node *tree) {\\n    assert(tree);\\n    int64_t min = 0;\\n\\n    while (tree) {\\n        min = tree->GetMinItem();\\n        tree = tree->GetLeftmostChild();\\n    }\\n\\n    return min;\\n}\\n\\n/**\\n * @brief Print tree into a dot file\\n * @param file_name output file name, if nullptr then use \\\"out.dot\\\" as default\\n */\\nvoid Tree234::Print(const char *file_name) {\\n    if (!file_name) {\\n        file_name = \\\"out.dot\\\";\\n    }\\n\\n    std::ofstream ofs;\\n\\n    ofs.open(file_name);\\n    if (!ofs) {\\n        std::cout << \\\"create tree dot file failed, \\\" << file_name << std::endl;\\n        return;\\n    }\\n\\n    ofs << \\\"digraph G {\\\\n\\\";\\n    ofs << \\\"node [shape=record]\\\\n\\\";\\n\\n    int64_t index = 0;\\n\\n    /** @brief This is a helper structure to do a level order traversal to print\\n     * the tree. */\\n    struct NodeInfo {\\n        Node *node;     ///< tree node\\n        int64_t index;  ///< node index of level order that used when draw the\\n                        ///< link between child and parent\\n    };\\n\\n    std::queue<NodeInfo> q;\\n\\n    if (root_) {\\n        // print root node\\n        PrintNode(ofs, root_, -1, index, 0);\\n\\n        NodeInfo ni{};\\n        ni.node = root_;\\n        ni.index = index;\\n\\n        q.push(ni);\\n\\n        while (!q.empty()) {\\n            NodeInfo node_info = q.front();\\n            q.pop();\\n\\n            assert(node_info.node->GetCount() > 0);\\n\\n            if (!node_info.node->IsLeaf()) {\\n                if (node_info.node->GetCount() > 0) {\\n                    PrintNode(ofs, node_info.node->GetChild(0), node_info.index,\\n                              ++index, 0);\\n                    ni.node = node_info.node->GetChild(0);\\n                    ni.index = index;\\n                    q.push(ni);\\n\\n                    PrintNode(ofs, node_info.node->GetChild(1), node_info.index,\\n                              ++index, 1);\\n                    ni.node = node_info.node->GetChild(1);\\n                    ni.index = index;\\n                    q.push(ni);\\n                }\\n\\n                if (node_info.node->GetCount() > 1) {\\n                    PrintNode(ofs, node_info.node->GetChild(2), node_info.index,\\n                              ++index, 2);\\n                    ni.node = node_info.node->GetChild(2);\\n                    ni.index = index;\\n                    q.push(ni);\\n                }\\n\\n                if (node_info.node->GetCount() > 2) {\\n                    PrintNode(ofs, node_info.node->GetChild(3), node_info.index,\\n                              ++index, 3);\\n                    ni.node = node_info.node->GetChild(3);\\n                    ni.index = index;\\n                    q.push(ni);\\n                }\\n            }\\n        }\\n    }\\n\\n    ofs << \\\"}\\\\n\\\";\\n    ofs.close();\\n}\\n\\n/**\\n * @brief Print the tree to a dot file. You can convert it to picture with\\n * graphviz\\n * @param ofs output file stream to print to\\n * @param node current node to print\\n * @param parent_index current node's parent node index, this is used to draw\\n * the link from parent to current node\\n * @param index current node's index of level order which is used to name the\\n * node in dot file\\n * @param parent_child_index the index that current node in parent's children\\n * array, range in [0,4), help to locate the start position of the link between\\n * nodes\\n */\\nvoid Tree234::PrintNode(std::ofstream &ofs, Node *node, int64_t parent_index,\\n                        int64_t index, int8_t parent_child_index) {\\n    assert(node);\\n\\n    switch (node->GetCount()) {\\n        case 1:\\n            ofs << \\\"node_\\\" << index << \\\" [label=\\\\\\\"<f0> \\\" << node->GetItem(0)\\n                << \\\"\\\\\\\"]\\\\n\\\";\\n            break;\\n        case 2:\\n            ofs << \\\"node_\\\" << index << \\\" [label=\\\\\\\"<f0> \\\" << node->GetItem(0)\\n                << \\\" | <f1> \\\" << node->GetItem(1) << \\\"\\\\\\\"]\\\\n\\\";\\n            break;\\n        case 3:\\n            ofs << \\\"node_\\\" << index << \\\" [label=\\\\\\\"<f0> \\\" << node->GetItem(0)\\n                << \\\" | <f1> \\\" << node->GetItem(1) << \\\"| <f2> \\\"\\n                << node->GetItem(2) << \\\"\\\\\\\"]\\\\n\\\";\\n            break;\\n\\n        default:\\n            break;\\n    }\\n\\n    // draw the edge\\n    if (parent_index >= 0) {\\n        ofs << \\\"node_\\\" << parent_index << \\\":f\\\"\\n            << (parent_child_index == 0 ? 0 : parent_child_index - 1) << \\\":\\\"\\n            << (parent_child_index == 0 ? \\\"sw\\\" : \\\"se\\\") << \\\" -> node_\\\" << index\\n            << \\\"\\\\n\\\";\\n    }\\n}\\n}  // namespace tree_234\\n}  // namespace data_structures\\n\\n\\n/** @brief simple test to insert a given array and delete some item, and print\\n * the tree*/\\nstatic void test1() {\\n    std::array<int16_t, 13> arr = {3, 1, 5, 4, 2, 9, 10, 8, 7, 6, 16, 13, 14};\\n    data_structures::tree_234::Tree234 tree;\\n\\n    for (auto i : arr) {\\n        tree.Insert(i);\\n    }\\n\\n    // tree.Remove(10);\\n    tree.Remove(5);\\n    tree.Print();\\n}\\n\\n/**\\n * @brief simple test to insert continuous number of range [0, n), and print\\n * the tree\\n * @param n upper bound of the range number to insert\\n */\\nstatic void test2(int64_t n) {\\n    data_structures::tree_234::Tree234 tree;\\n\\n    for (int64_t i = 0; i < n; i++) {\\n        tree.Insert(i);\\n    }\\n\\n    tree.Traverse();\\n    tree.Print((std::to_string(n) + \\\".dot\\\").c_str());\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, char *argv[]) {\\n    if (argc < 2) {\\n        test1();  // execute 1st test\\n    } else {\\n        test2(std::stoi(argv[1]));  // execute 2nd test\\n    }\\n\\n    return 0;\\n}\\n\"",
    "trie modern": "\"/**\\n * @file\\n *\\n * @author Anmol3299\\n * \\\\brief A basic implementation of trie class to store only lower-case strings.\\n */\\n#include <iostream>  // for io operations\\n#include <memory>    // for std::shared_ptr<>\\n#include <string>    // for std::string class\\n\\n/**\\n * A basic implementation of trie class to store only lower-case strings.\\n * You can extend the implementation to all the ASCII characters by changing the\\n * value of @ ALPHABETS to 128.\\n */\\nclass Trie {\\n private:\\n    static constexpr size_t ALPHABETS = 26;\\n\\n    /**\\n     * Structure of trie node.\\n     * This struct doesn't need a constructor as we are initializing using\\n     * intializer list which is more efficient than if we had done so with\\n     * constructor.\\n     */\\n    struct TrieNode {\\n        // An array of pointers of size 26 which tells if a character of word is\\n        // present or not.\\n        std::shared_ptr<TrieNode> character[ALPHABETS]{nullptr};\\n\\n        bool isEndOfWord{false};\\n    };\\n\\n    /**\\n     * Function to check if a node has some children which can form words.\\n     * @param node whose character array of pointers need to be checked for\\n     * children.\\n     * @return `true` if a child is found\\n     * @return `false` if a child is not found\\n     */\\n    inline static bool hasChildren(std::shared_ptr<TrieNode> node) {\\n        for (size_t i = 0; i < ALPHABETS; i++) {\\n            if (node->character[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * A recursive helper function to remove a word from the trie. First, it\\n     * recursively traverses to the location of last character of word in the\\n     * trie. However, if the word is not found, the function returns a runtime\\n     * error. Upon successfully reaching the last character of word in trie, if\\n     * sets the isEndOfWord to false and deletes the node if and only if it has\\n     * no children, else it returns the current node.\\n     * @param word is the string which needs to be removed from trie.\\n     * @param curr is the current node we are at.\\n     * @param index is the index of the @word we are at.\\n     * @return if current node has childern, it returns @ curr, else it returns\\n     * nullptr.\\n     * @throw a runtime error in case @ word is not found in the trie.\\n     */\\n    std::shared_ptr<TrieNode> removeWordHelper(const std::string& word,\\n                                               std::shared_ptr<TrieNode> curr,\\n                                               size_t index) {\\n        if (word.size() == index) {\\n            if (curr->isEndOfWord) {\\n                curr->isEndOfWord = false;\\n            }\\n            if (hasChildren(curr)) {\\n                return curr;\\n            }\\n            return nullptr;\\n        }\\n\\n        size_t idx = word[index] - 'a';\\n\\n        // Throw a runtime error in case the user enters a word which is not\\n        // present in the trie.\\n        if (!curr->character[idx]) {\\n            throw std::runtime_error(std::move(std::string(\\\"Word not found.\\\")));\\n        }\\n\\n        curr->character[idx] =\\n            removeWordHelper(word, curr->character[idx], index + 1);\\n\\n        // This if condition checks if the node has some childern.\\n        // The 1st if check, i.e. (curr->character[idx]) is checked specifically\\n        // because if the older string is a prefix of some other string, then,\\n        // there would be no need to check all 26 characters. Example- str1 =\\n        // abbey, str2 = abbex and we want to delete string \\\"abbey\\\", then in\\n        // this case, there would be no need to check all characters for the\\n        // chars a,b,b.\\n        if (curr->character[idx] || hasChildren(curr)) {\\n            return curr;\\n        }\\n        return nullptr;\\n    }\\n\\n public:\\n    /// constructor to initialise the root of the trie.\\n    Trie() : m_root(std::make_shared<TrieNode>()) {}\\n\\n    /**\\n     * Insert a word into the trie.\\n     * @param word which needs to be inserted into the string.\\n     */\\n    void insert(const std::string& word) {\\n        auto curr = m_root;\\n        for (char ch : word) {\\n            size_t index = ch - 'a';\\n\\n            // if a node for current word is not already present in trie, create\\n            // a new node for it.\\n            if (!curr->character[index]) {\\n                curr->character[index] = std::make_shared<TrieNode>();\\n            }\\n\\n            curr = curr->character[index];\\n        }\\n        curr->isEndOfWord = true;\\n    }\\n\\n    /**\\n     * Search if a word is present in trie or not.\\n     * @param word which is needed to be searched in the trie.\\n     * @return True if the word is found in trie and isEndOfWord is set to true.\\n     * @return False if word is not found in trie or isEndOfWord is set to\\n     * false.\\n     */\\n    bool search(const std::string& word) {\\n        auto curr = m_root;\\n        for (char ch : word) {\\n            size_t index = ch - 'a';\\n\\n            // if any node for a character is not found, then return that the\\n            // word cannot be formed.\\n            if (!curr->character[index]) {\\n                return false;\\n            }\\n            curr = curr->character[index];\\n        }\\n        return curr->isEndOfWord;\\n    }\\n\\n    // Function to remove the word which calls the helper function.\\n    void removeWord(const std::string& word) {\\n        m_root = removeWordHelper(word, m_root, 0);\\n    }\\n\\n private:\\n    // data member to store the root of the trie.\\n    std::shared_ptr<TrieNode> m_root;\\n};\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    Trie trie;\\n    trie.insert(\\\"hel\\\");\\n    trie.insert(\\\"hello\\\");\\n    trie.removeWord(\\\"hel\\\");\\n    std::cout << trie.search(\\\"hello\\\") << '\\\\n';\\n\\n    return 0;\\n}\\n\"",
    "trie tree": "\"/**\\n * @file\\n * @author [@Arctic2333](https://github.com/Arctic2333)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Implementation of [Trie](https://en.wikipedia.org/wiki/Trie) data\\n * structure for English alphabets in small characters.\\n * @note the function ::data_structure::trie::deleteString might be erroneous\\n * @see trie_modern.cpp\\n */\\n#include <array>\\n#include <cassert>\\n#include <iostream>\\n#include <memory>\\n#include <string>\\n#include <vector>\\n\\n/** \\\\namespace data_structures\\n * \\\\brief Data-structure algorithms\\n */\\nnamespace data_structures {\\n/**\\n * @brief [Trie](https://en.wikipedia.org/wiki/Trie) implementation for\\n * small-case English alphabets `a-z`\\n */\\nclass trie {\\n private:\\n    static constexpr uint8_t NUM_CHARS = 26;  ///< Number of alphabets\\n    /** @brief Recursive tree nodes as an array of shared-pointers */\\n    std::array<std::shared_ptr<trie>, NUM_CHARS << 1> arr;\\n    bool isEndofWord = false;  ///< identifier if a node is terminal node\\n\\n    /**\\n     * @brief Convert a character to integer for indexing\\n     *\\n     * @param ch character to index\\n     * @return unsigned integer index\\n     */\\n    uint8_t char_to_int(const char& ch) const {\\n        if (ch >= 'A' && ch <= 'Z') {\\n            return ch - 'A';\\n        } else if (ch >= 'a' && ch <= 'z') {\\n            return ch - 'a' + NUM_CHARS;\\n        }\\n\\n        std::cerr << \\\"Invalid character present. Exiting...\\\";\\n        std::exit(EXIT_FAILURE);\\n        return 0;\\n    }\\n\\n    /** search a string exists inside a given root trie\\n     * @param str string to search for\\n     * @param index start index to search from\\n     * @returns `true` if found\\n     * @returns `false` if not found\\n     */\\n    bool search(const std::shared_ptr<trie>& root, const std::string& str,\\n                int index) {\\n        if (index == str.length()) {\\n            if (!root->isEndofWord) {\\n                return false;\\n            }\\n            return true;\\n        }\\n        int j = char_to_int(str[index]);\\n        if (!root->arr[j]) {\\n            return false;\\n        }\\n        return search(root->arr[j], str, index + 1);\\n    }\\n\\n public:\\n    trie() = default;  ///< Class default constructor\\n\\n    /** insert string into the trie\\n     * @param str String to insert in the tree\\n     */\\n    void insert(const std::string& str) {\\n        std::shared_ptr<trie> root(nullptr);\\n\\n        for (const char& ch : str) {\\n            int j = char_to_int(ch);\\n            if (root) {\\n                if (root->arr[j]) {\\n                    root = root->arr[j];\\n                } else {\\n                    std::shared_ptr<trie> temp(new trie());\\n                    root->arr[j] = temp;\\n                    root = temp;\\n                }\\n            } else if (arr[j]) {\\n                root = arr[j];\\n            } else {\\n                std::shared_ptr<trie> temp(new trie());\\n                arr[j] = temp;\\n                root = temp;\\n            }\\n        }\\n        root->isEndofWord = true;\\n    }\\n\\n    /** search a string exists inside the trie\\n     * @param str string to search for\\n     * @param index start index to search from\\n     * @returns `true` if found\\n     * @returns `false` if not found\\n     */\\n    bool search(const std::string& str, int index) {\\n        if (index == str.length()) {\\n            if (!isEndofWord) {\\n                return false;\\n            }\\n            return true;\\n        }\\n        int j = char_to_int(str[index]);\\n        if (!arr[j]) {\\n            return false;\\n        }\\n        return search(arr[j], str, index + 1);\\n    }\\n\\n    /**\\n     * removes the string if it is not a prefix of any  other\\n     * string, if it is then just sets the ::data_structure::trie::isEndofWord\\n     * to false, else removes the given string\\n     * @note the function ::data_structure::trie::deleteString might be\\n     * erroneous\\n     * @todo review the function ::data_structure::trie::deleteString and the\\n     * commented lines\\n     * @param str string to remove\\n     * @param index index to remove from\\n     * @returns `true` if successful\\n     * @returns `false` if unsuccessful\\n     */\\n    bool deleteString(const std::string& str, int index) {\\n        if (index == str.length()) {\\n            if (!isEndofWord) {\\n                return false;\\n            }\\n            isEndofWord = false;\\n            // following lines - possible source of error?\\n            // for (int i = 0; i < NUM_CHARS; i++)\\n            //     if (!arr[i])\\n            //         return false;\\n            return true;\\n        }\\n        int j = char_to_int(str[index]);\\n        if (!arr[j]) {\\n            return false;\\n        }\\n        bool var = deleteString(str, index + 1);\\n        if (var) {\\n            arr[j].reset();\\n            if (isEndofWord) {\\n                return false;\\n            } else {\\n                int i = 0;\\n                for (i = 0; i < NUM_CHARS; i++) {\\n                    if (arr[i]) {\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n\\n        /* should not return here */\\n        std::cout << __func__ << \\\":\\\" << __LINE__\\n                  << \\\"Should not reach this line\\\\n\\\";\\n        return false;\\n    }\\n};\\n}  // namespace data_structures\\n\\n/**\\n * @brief Testing function\\n * @returns void\\n */\\nstatic void test() {\\n    data_structures::trie root;\\n    root.insert(\\\"Hello\\\");\\n    root.insert(\\\"World\\\");\\n\\n    assert(!root.search(\\\"hello\\\", 0));\\n    std::cout << \\\"hello - \\\" << root.search(\\\"hello\\\", 0) << \\\"\\\\n\\\";\\n\\n    assert(root.search(\\\"Hello\\\", 0));\\n    std::cout << \\\"Hello - \\\" << root.search(\\\"Hello\\\", 0) << \\\"\\\\n\\\";\\n\\n    assert(!root.search(\\\"Word\\\", 0));\\n    std::cout << \\\"Word - \\\" << root.search(\\\"Word\\\", 0) << \\\"\\\\n\\\";\\n\\n    assert(root.search(\\\"World\\\", 0));\\n    std::cout << \\\"World - \\\" << root.search(\\\"World\\\", 0) << \\\"\\\\n\\\";\\n\\n    // Following lines of code give erroneous output\\n    // root.deleteString(\\\"hello\\\", 0);\\n    // assert(!root.search(\\\"hello\\\", 0));\\n    // std::cout << \\\"hello - \\\" << root.search(\\\"world\\\", 0) << \\\"\\\\n\\\";\\n}\\n\\n/**\\n * @brief Main function\\n * @return 0 on exit\\n */\\nint main() {\\n    test();\\n\\n    return 0;\\n}\\n\"",
    "trie using hashmap": "\"/**\\n * @file\\n * @author [Venkata Bharath](https://github.com/bharath000)\\n * @brief Implementation of [Trie](https://en.wikipedia.org/wiki/Trie) data\\n * structure using HashMap for different characters and method for predicting\\n * words based on prefix.\\n * @details The Trie data structure is implemented using unordered map to use\\n * memory optimally, predict_words method is developed to recommend words based\\n * on a given prefix along with other methods insert, delete, search, startwith\\n * in trie.\\n * @see trie_modern.cpp for difference\\n */\\n#include <cassert>        /// for assert\\n#include <iostream>       /// for IO operations\\n#include <memory>         /// for std::shared_ptr\\n#include <stack>          /// for std::stack\\n#include <unordered_map>  /// for std::unordered_map\\n#include <vector>         /// for std::vector\\n\\n/**\\n * @namespace data_structures\\n * @brief Data structures algorithms\\n */\\nnamespace data_structures {\\n\\n/**\\n * @namespace trie_using_hashmap\\n * @brief Functions for [Trie](https://en.wikipedia.org/wiki/Trie) data\\n * structure using hashmap implementation\\n */\\nnamespace trie_using_hashmap {\\n\\n/**\\n * @brief Trie class, implementation of trie using hashmap in each trie node\\n * for all the characters of char16_t(UTF-16)type with methods to insert,\\n * delete, search, start with and to recommend words based on a given\\n * prefix.\\n */\\nclass Trie {\\n private:\\n    /**\\n     * @brief struct representing a trie node.\\n     */\\n    struct Node {\\n        std::unordered_map<char16_t, std::shared_ptr<Node>>\\n            children;  ///< unordered map with key type char16_t and value is a\\n                       ///< shared pointer type of Node\\n        bool word_end = false;  ///< boolean variable to represent the node end\\n    };\\n\\n    std::shared_ptr<Node> root_node =\\n        std::make_shared<Node>();  ///< declaring root node of trie\\n\\n public:\\n    ///< Constructor\\n    Trie() = default;\\n\\n    /**\\n     * @brief insert the string into the trie\\n     * @param word string to insert in the trie\\n     */\\n    void insert(const std::string& word) {\\n        std::shared_ptr<Node> curr = root_node;\\n        for (char ch : word) {\\n            if (curr->children.find(ch) == curr->children.end()) {\\n                curr->children[ch] = std::make_shared<Node>();\\n            }\\n            curr = curr->children[ch];\\n        }\\n\\n        if (!curr->word_end && curr != root_node) {\\n            curr->word_end = true;\\n        }\\n    }\\n\\n    /**\\n     * @brief search a word/string inside the trie\\n     * @param word string to search for\\n     * @returns `true` if found\\n     * @returns `false` if not found\\n     */\\n    bool search(const std::string& word) {\\n        std::shared_ptr<Node> curr = root_node;\\n        for (char ch : word) {\\n            if (curr->children.find(ch) == curr->children.end()) {\\n                return false;\\n            }\\n            curr = curr->children[ch];\\n            if (!curr) {\\n                return false;\\n            }\\n        }\\n\\n        if (curr->word_end) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @brief search a word/string that starts with a given prefix\\n     * @param prefix string to search for\\n     * @returns `true` if found\\n     * @returns `false` if not found\\n     */\\n    bool startwith(const std::string& prefix) {\\n        std::shared_ptr<Node> curr = root_node;\\n        for (char ch : prefix) {\\n            if (curr->children.find(ch) == curr->children.end()) {\\n                return false;\\n            }\\n            curr = curr->children[ch];\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @brief delete a word/string from a trie\\n     * @param word string to delete from trie\\n     */\\n    void delete_word(std::string word) {\\n        std::shared_ptr<Node> curr = root_node;\\n        std::stack<std::shared_ptr<Node>> nodes;\\n        int cnt = 0;\\n        for (char ch : word) {\\n            if (curr->children.find(ch) == curr->children.end()) {\\n                return;\\n            }\\n            if (curr->word_end) {\\n                cnt++;\\n            }\\n\\n            nodes.push(curr->children[ch]);\\n            curr = curr->children[ch];\\n        }\\n        // Delete only when it's a word, and it has children after\\n        // or prefix in the line\\n        if (nodes.top()->word_end) {\\n            nodes.top()->word_end = false;\\n        }\\n        // Delete only when it has no children after\\n        // and also no prefix in the line\\n        while (!(nodes.top()->word_end) && nodes.top()->children.empty()) {\\n            nodes.pop();\\n            nodes.top()->children.erase(word.back());\\n            word.pop_back();\\n        }\\n    }\\n\\n    /**\\n     * @brief helper function to predict/recommend words that starts with a\\n     * given prefix from the end of prefix's node iterate through all the child\\n     * nodes by recursively appending all the possible words below the trie\\n     * @param prefix string to recommend the words\\n     * @param element node at the end of the given prefix\\n     * @param results list to store the all possible words\\n     * @returns list of recommended words\\n     */\\n    std::vector<std::string> get_all_words(std::vector<std::string> results,\\n                                           const std::shared_ptr<Node>& element,\\n                                           std::string prefix) {\\n        if (element->word_end) {\\n            results.push_back(prefix);\\n        }\\n        if (element->children.empty()) {\\n            return results;\\n        }\\n        for (auto const& x : element->children) {\\n            std::string key = \\\"\\\";\\n            key = x.first;\\n            prefix += key;\\n\\n            results =\\n                get_all_words(results, element->children[x.first], prefix);\\n\\n            prefix.pop_back();\\n        }\\n\\n        return results;\\n    }\\n\\n    /**\\n     * @brief predict/recommend a word that starts with a given prefix\\n     * @param prefix string to search for\\n     * @returns list of recommended words\\n     */\\n    std::vector<std::string> predict_words(const std::string& prefix) {\\n        std::vector<std::string> result;\\n        std::shared_ptr<Node> curr = root_node;\\n        // traversing until the end of the given prefix in trie\\n\\n        for (char ch : prefix) {\\n            if (curr->children.find(ch) == curr->children.end()) {\\n                return result;\\n            }\\n\\n            curr = curr->children[ch];\\n        }\\n\\n        // if the given prefix is the only word without children\\n        if (curr->word_end && curr->children.empty()) {\\n            result.push_back(prefix);\\n            return result;\\n        }\\n\\n        result = get_all_words(\\n            result, curr,\\n            prefix);  ///< iteratively and recursively get the recommended words\\n\\n        return result;\\n    }\\n};\\n}  // namespace trie_using_hashmap\\n}  // namespace data_structures\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    data_structures::trie_using_hashmap::Trie obj;\\n    // Inserting data into trie using the insert\\n    // method and testing it with search method\\n    obj.insert(\\\"app\\\");\\n    obj.insert(\\\"abscond\\\");\\n    obj.insert(\\\"about\\\");\\n    obj.insert(\\\"apps\\\");\\n    obj.insert(\\\"apen\\\");\\n    obj.insert(\\\"apples\\\");\\n    obj.insert(\\\"apple\\\");\\n    obj.insert(\\\"approach\\\");\\n    obj.insert(\\\"bus\\\");\\n    obj.insert(\\\"buses\\\");\\n    obj.insert(\\\"Apple\\\");\\n    obj.insert(\\\"Bounce\\\");\\n\\n    assert(!obj.search(\\\"appy\\\"));\\n    std::cout << \\\"appy is not a word in trie\\\" << std::endl;\\n\\n    assert(!obj.search(\\\"car\\\"));\\n    std::cout << \\\"car is not a word in trie\\\" << std::endl;\\n    assert(obj.search(\\\"app\\\"));\\n    assert(obj.search(\\\"apple\\\"));\\n    assert(obj.search(\\\"apples\\\"));\\n    assert(obj.search(\\\"apps\\\"));\\n    assert(obj.search(\\\"apen\\\"));\\n    assert(obj.search(\\\"approach\\\"));\\n    assert(obj.search(\\\"about\\\"));\\n    assert(obj.search(\\\"abscond\\\"));\\n    assert(obj.search(\\\"bus\\\"));\\n    assert(obj.search(\\\"buses\\\"));\\n    assert(obj.search(\\\"Bounce\\\"));\\n    assert(obj.search(\\\"Apple\\\"));\\n\\n    std::cout << \\\"All the Inserted words are present in the trie\\\" << std::endl;\\n\\n    // test for startwith prefix method\\n    assert(!obj.startwith(\\\"approachs\\\"));\\n    assert(obj.startwith(\\\"approach\\\"));\\n    assert(obj.startwith(\\\"about\\\"));\\n    assert(!obj.startwith(\\\"appy\\\"));\\n    assert(obj.startwith(\\\"abscond\\\"));\\n    assert(obj.startwith(\\\"bus\\\"));\\n    assert(obj.startwith(\\\"buses\\\"));\\n    assert(obj.startwith(\\\"Bounce\\\"));\\n    assert(obj.startwith(\\\"Apple\\\"));\\n    assert(obj.startwith(\\\"abs\\\"));\\n    assert(obj.startwith(\\\"b\\\"));\\n    assert(obj.startwith(\\\"bus\\\"));\\n    assert(obj.startwith(\\\"Bo\\\"));\\n    assert(obj.startwith(\\\"A\\\"));\\n    assert(!obj.startwith(\\\"Ca\\\"));\\n\\n    assert(!obj.startwith(\\\"C\\\"));\\n\\n    std::cout << \\\"All the tests passed for startwith method\\\" << std::endl;\\n\\n    // test for predict_words/recommendation of words based on a given prefix\\n\\n    std::vector<std::string> pred_words = obj.predict_words(\\\"a\\\");\\n\\n    for (const std::string& str : obj.predict_words(\\\"a\\\")) {\\n        std::cout << str << std::endl;\\n    }\\n    assert(pred_words.size() == 8);\\n    std::cout << \\\"Returned all words that start with prefix a \\\" << std::endl;\\n    pred_words = obj.predict_words(\\\"app\\\");\\n\\n    for (const std::string& str : pred_words) {\\n        std::cout << str << std::endl;\\n    }\\n\\n    assert(pred_words.size() == 5);\\n    std::cout << \\\"Returned all words that start with prefix app \\\" << std::endl;\\n    pred_words = obj.predict_words(\\\"A\\\");\\n\\n    for (const std::string& str : pred_words) {\\n        std::cout << str << std::endl;\\n    }\\n\\n    assert(pred_words.size() == 1);\\n    std::cout << \\\"Returned all words that start with prefix A \\\" << std::endl;\\n    pred_words = obj.predict_words(\\\"bu\\\");\\n\\n    for (const std::string& str : pred_words) {\\n        std::cout << str << std::endl;\\n    }\\n\\n    assert(pred_words.size() == 2);\\n    std::cout << \\\"Returned all words that start with prefix bu \\\" << std::endl;\\n\\n    // tests for delete method\\n\\n    obj.delete_word(\\\"app\\\");\\n    assert(!obj.search(\\\"app\\\"));\\n    std::cout << \\\"word app is deleted sucessful\\\" << std::endl;\\n\\n    pred_words = obj.predict_words(\\\"app\\\");\\n    for (const std::string& str : pred_words) {\\n        std::cout << str << std::endl;\\n    }\\n    assert(pred_words.size() == 4);\\n    std::cout << \\\"app is deleted sucessful\\\" << std::endl;\\n\\n    // test case for Chinese language\\n\\n    obj.insert(\\\"苹果\\\");\\n    assert(obj.startwith(\\\"苹\\\"));\\n    pred_words = obj.predict_words(\\\"h\\\");\\n\\n    assert(pred_words.size() == 0);\\n    std::cout << \\\"No word starts with prefix h in trie\\\" << std::endl;\\n\\n    std::cout << \\\"All tests passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementaions\\n    return 0;\\n}\\n\"",
    "karatsuba algorithm for fast multiplication": "\"/**\\n * @file\\n * @brief Implementation of the [Karatsuba algorithm for fast\\n * multiplication](https://en.wikipedia.org/wiki/Karatsuba_algorithm)\\n * @details\\n * Given two strings in binary notation we want to multiply them and return the\\n * value Simple approach is to multiply bits one by one which will give the time\\n * complexity of around O(n^2). To make it more efficient we will be using\\n * Karatsuba' algorithm to find the product which will solve the problem\\n * O(nlogn) of time.\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <cstring>   /// for string\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace divide_and_conquer\\n * @brief Divide and Conquer algorithms\\n */\\nnamespace divide_and_conquer {\\n/**\\n * @namespace karatsuba_algorithm\\n * @brief Functions for the [Karatsuba algorithm for fast\\n * multiplication](https://en.wikipedia.org/wiki/Karatsuba_algorithm)\\n */\\nnamespace karatsuba_algorithm {\\n/**\\n * @brief Helper function for the main function, that implements Karatsuba's\\n * algorithm for fast multiplication\\n * @param first the input string 1\\n * @param second the input string 2\\n * @returns the concatenated string\\n */\\nstd::string addStrings(std::string first, std::string second) {\\n    std::string result;  // To store the resulting sum bits\\n\\n    int64_t len1 = first.size();\\n    int64_t len2 = second.size();\\n    int64_t length = std::max(len1, len2);\\n    std::string zero = \\\"0\\\";\\n    if (len1 < len2)  // make the string lengths equal\\n    {\\n        for (int64_t i = 0; i < len2 - len1; i++) {\\n            zero += first;\\n            first = zero;\\n        }\\n    } else if (len1 > len2) {\\n        zero = \\\"0\\\";\\n        for (int64_t i = 0; i < len1 - len2; i++) {\\n            zero += second;\\n            second = zero;\\n        }\\n    }\\n    int64_t carry = 0;\\n    for (int64_t i = length - 1; i >= 0; i--) {\\n        int64_t firstBit = first.at(i) - '0';\\n        int64_t secondBit = second.at(i) - '0';\\n\\n        int64_t sum = (firstBit ^ secondBit ^ carry) + '0';  // sum of 3 bits\\n        std::string temp;\\n        temp = std::to_string(sum);\\n        temp += result;\\n        result = temp;\\n\\n        carry = (firstBit & secondBit) | (secondBit & carry) |\\n                (firstBit & carry);  // sum of 3 bits\\n    }\\n\\n    if (carry) {\\n        result = '1' + result;  // adding 1 incase of overflow\\n    }\\n    return result;\\n}\\n/**\\n * @brief The main function implements Karatsuba's algorithm for fast\\n * multiplication\\n * @param str1 the input string 1\\n * @param str2 the input string 2\\n * @returns the multiplicative number value\\n */\\nint64_t karatsuba_algorithm(std::string str1, std::string str2) {\\n    int64_t len1 = str1.size();\\n    int64_t len2 = str2.size();\\n    int64_t n = std::max(len1, len2);\\n    std::string zero = \\\"0\\\";\\n    if (len1 < len2) {\\n        for (int64_t i = 0; i < len2 - len1; i++) {\\n            zero += str1;\\n            str1 = zero;\\n        }\\n    } else if (len1 > len2) {\\n        zero = \\\"0\\\";\\n        for (int64_t i = 0; i < len1 - len2; i++) {\\n            zero += str2;\\n            str2 = zero;\\n        }\\n    }\\n    if (n == 0) {\\n        return 0;\\n    }\\n    if (n == 1) {\\n        return (str1[0] - '0') * (str2[0] - '0');\\n    }\\n    int64_t fh = n / 2;     // first half of string\\n    int64_t sh = (n - fh);  // second half of string\\n\\n    std::string Xl = str1.substr(0, fh);   // first half of first string\\n    std::string Xr = str1.substr(fh, sh);  // second half of first string\\n\\n    std::string Yl = str2.substr(0, fh);   // first half of second string\\n    std::string Yr = str2.substr(fh, sh);  // second half of second string\\n\\n    // Calculating the three products of inputs of size n/2 recursively\\n    int64_t product1 = karatsuba_algorithm(Xl, Yl);\\n    int64_t product2 = karatsuba_algorithm(Xr, Yr);\\n    int64_t product3 = karatsuba_algorithm(\\n        divide_and_conquer::karatsuba_algorithm::addStrings(Xl, Xr),\\n        divide_and_conquer::karatsuba_algorithm::addStrings(Yl, Yr));\\n\\n    return product1 * (1 << (2 * sh)) +\\n           (product3 - product1 - product2) * (1 << sh) +\\n           product2;  // combining the three products to get the final result.\\n}\\n}  // namespace karatsuba_algorithm\\n}  // namespace divide_and_conquer\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st test\\n    std::string s11 = \\\"1\\\";\\n    std::string s12 = \\\"1010\\\";\\n    std::cout << \\\"1st test... \\\";\\n    assert(divide_and_conquer::karatsuba_algorithm::karatsuba_algorithm(\\n               s11, s12) == 10);  // here the multiplication is 10\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 2nd test\\n    std::string s21 = \\\"11\\\";\\n    std::string s22 = \\\"1010\\\";\\n    std::cout << \\\"2nd test... \\\";\\n    assert(divide_and_conquer::karatsuba_algorithm::karatsuba_algorithm(\\n               s21, s22) == 30);  // here the multiplication is 30\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 3rd test\\n    std::string s31 = \\\"110\\\";\\n    std::string s32 = \\\"1010\\\";\\n    std::cout << \\\"3rd test... \\\";\\n    assert(divide_and_conquer::karatsuba_algorithm::karatsuba_algorithm(\\n               s31, s32) == 60);  // here the multiplication is 60\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "0 1 knapsack": "\"/**\\n * @file\\n * @brief Implementation of [0-1 Knapsack Problem]\\n * (https://en.wikipedia.org/wiki/Knapsack_problem)\\n *\\n * @details\\n * Given weights and values of n items, put these items in a knapsack of\\n * capacity `W` to get the maximum total value in the knapsack. In other words,\\n * given two integer arrays `val[0..n-1]` and `wt[0..n-1]` which represent\\n * values and weights associated with n items respectively. Also given an\\n * integer W which represents knapsack capacity, find out the maximum value\\n * subset of `val[]` such that sum of the weights of this subset is smaller than\\n * or equal to W. You cannot break an item, either pick the complete item or\\n * don’t pick it (0-1 property)\\n *\\n * ### Algorithm\\n * The idea is to consider all subsets of items and calculate the total weight\\n * and value of all subsets. Consider the only subsets whose total weight is\\n * smaller than `W`. From all such subsets, pick the maximum value subset.\\n *\\n * @author [Anmol](https://github.com/Anmol3299)\\n * @author [Pardeep](https://github.com/Pardeep009)\\n */\\n\\n#include <array>\\n#include <cassert>\\n#include <iostream>\\n#include <vector>\\n\\n/**\\n * @namespace dynamic_programming\\n * @brief Dynamic Programming algorithms\\n */\\nnamespace dynamic_programming {\\n/**\\n * @namespace Knapsack\\n * @brief Implementation of 0-1 Knapsack problem\\n */\\nnamespace knapsack {\\n/**\\n * @brief Picking up all those items whose combined weight is below\\n * given capacity and calculating value of those picked items.Trying all\\n * possible combinations will yield the maximum knapsack value.\\n * @tparam n size of the weight and value array\\n * @param capacity capacity of the carrying bag\\n * @param weight array representing weight of items\\n * @param value array representing value of items\\n * @return maximum value obtainable with given capacity.\\n */\\ntemplate <size_t n>\\nint maxKnapsackValue(const int capacity, const std::array<int, n> &weight,\\n                     const std::array<int, n> &value) {\\n    std::vector<std::vector<int> > maxValue(n + 1,\\n                                            std::vector<int>(capacity + 1, 0));\\n    // outer loop will select no of items allowed\\n    // inner loop will select capcity of knapsack bag\\n    int items = sizeof(weight) / sizeof(weight[0]);\\n    for (size_t i = 0; i < items + 1; ++i) {\\n        for (size_t j = 0; j < capacity + 1; ++j) {\\n            if (i == 0 || j == 0) {\\n                // if no of items is zero or capacity is zero, then maxValue\\n                // will be zero\\n                maxValue[i][j] = 0;\\n            } else if (weight[i - 1] <= j) {\\n                // if the ith item's weight(in actual array it will be at i-1)\\n                // is less than or equal to the allowed weight i.e. j then we\\n                // can pick that item for our knapsack. maxValue will be the\\n                // obtained either by picking the current item or by not picking\\n                // current item\\n\\n                // picking current item\\n                int profit1 = value[i - 1] + maxValue[i - 1][j - weight[i - 1]];\\n\\n                // not picking current item\\n                int profit2 = maxValue[i - 1][j];\\n\\n                maxValue[i][j] = std::max(profit1, profit2);\\n            } else {\\n                // as weight of current item is greater than allowed weight, so\\n                // maxProfit will be profit obtained by excluding current item.\\n                maxValue[i][j] = maxValue[i - 1][j];\\n            }\\n        }\\n    }\\n\\n    // returning maximum value\\n    return maxValue[items][capacity];\\n}\\n}  // namespace knapsack\\n}  // namespace dynamic_programming\\n\\n/**\\n * @brief Function to test above algorithm\\n * @returns void\\n */\\nstatic void test() {\\n    // Test 1\\n    const int n1 = 3;                             // number of items\\n    std::array<int, n1> weight1 = {10, 20, 30};   // weight of each item\\n    std::array<int, n1> value1 = {60, 100, 120};  // value of each item\\n    const int capacity1 = 50;                     // capacity of carrying bag\\n    const int max_value1 = dynamic_programming::knapsack::maxKnapsackValue(\\n        capacity1, weight1, value1);\\n    const int expected_max_value1 = 220;\\n    assert(max_value1 == expected_max_value1);\\n    std::cout << \\\"Maximum Knapsack value with \\\" << n1 << \\\" items is \\\"\\n              << max_value1 << std::endl;\\n\\n    // Test 2\\n    const int n2 = 4;                               // number of items\\n    std::array<int, n2> weight2 = {24, 10, 10, 7};  // weight of each item\\n    std::array<int, n2> value2 = {24, 18, 18, 10};  // value of each item\\n    const int capacity2 = 25;                       // capacity of carrying bag\\n    const int max_value2 = dynamic_programming::knapsack::maxKnapsackValue(\\n        capacity2, weight2, value2);\\n    const int expected_max_value2 = 36;\\n    assert(max_value2 == expected_max_value2);\\n    std::cout << \\\"Maximum Knapsack value with \\\" << n2 << \\\" items is \\\"\\n              << max_value2 << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    // Testing\\n    test();\\n    return 0;\\n}\\n\"",
    "abbreviation": "\"/**\\n * @file\\n * @brief Implementation of\\n * [Abbrievation](https://www.hackerrank.com/challenges/abbr/problem)\\n *\\n * @details\\n * Given two strings, `a` and `b`, determine if it's possible to make `a` equal\\n * to `b` You can perform the following operations on the string `a`:\\n * 1. Capitalize zero or more of `a`'s lowercase letters.\\n * 2. Delete all of the remaining lowercase letters in `a`.\\n *\\n * ### Algorithm\\n * The idea is in the problem statement itself: iterate through characters of\\n * string `a` and `b` (for character indexes `i` and `j` respectively):\\n * 1. If `a[i]` and `b[j]` are equal, then move to next position\\n * 2. If `a[i]` is lowercase of `b[j]`, then explore two possibilities:\\n * a. Capitalize `a[i]` or\\n * b. Skip `a[i]`\\n * 3. If the `a[i]` is not uppercase, just discard that character, else return\\n * `false`\\n *\\n * Time Complexity: (O(|a|*|b|)) where `|a|` => length of string `a`\\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\\n */\\n\\n#include <cassert>   /// for `assert`\\n#include <iostream>  /// for IO operations\\n#include <string>    /// for `std::string` library\\n#include <vector>    /// for `std::vector` STL library\\n/**\\n * @namespace dynamic_programming\\n * @brief Dynamic Programming Algorithms\\n */\\nnamespace dynamic_programming {\\n/**\\n * @namespace abbreviation\\n * @brief Functions for\\n * [Abbreviation](https://www.hackerrank.com/challenges/abbr/problem)\\n * implementation\\n */\\nnamespace abbreviation {\\n/**\\n * @brief\\n * Recursive Dynamic Programming function\\n * @details\\n * Returns whether `s` can be converted to `t` with following rules:\\n * a. Capitalize zero or more of a's lowercase letters from string `s`\\n * b. remove all other lowercase letters from string `s`\\n * @param memo To store the result\\n * @param visited boolean to check if the result is already computed\\n * @param str given string, which might not be abbreivated\\n * @param result resultant abbreivated string\\n * @param str_idx index for string `str`, helpful for transitions\\n * @param result_idx index for string `result`, helpful for transitions\\n * @returns `false` if string `str` cannot be converted to `result`\\n * @returns `true` if string `str` can be converted to `result`\\n */\\nbool abbreviation_recursion(std::vector<std::vector<bool>> *memo,\\n                            std::vector<std::vector<bool>> *visited,\\n                            const std::string &str, const std::string &result,\\n                            uint32_t str_idx = 0, uint32_t result_idx = 0) {\\n    bool ans = memo->at(str_idx).at(result_idx);\\n    if (str_idx == str.size() && result_idx == result.size()) {\\n        return true;\\n    } else if (str_idx == str.size() && result_idx != result.size()) {\\n        // result `t` is not converted, return false\\n        return false;\\n    } else if (!visited->at(str_idx).at(result_idx)) {\\n        /**\\n         * `(str[i] == result[j])`: if str char at position i is equal to\\n         * `result` char at position j, then s character is a capitalized one,\\n         * move on to next character `str[i] - 32 == result[j]`:\\n         * if `str[i]` character is lowercase of `result[j]` then explore two\\n         * possibilites:\\n         * 1. convert it to capitalized letter and move both to next pointer\\n         * `(i + 1, j + 1)`\\n         * 2. Discard the character `(str[i])` and move to next char `(i + 1,\\n         * j)`\\n         */\\n        if (str[str_idx] == result[result_idx]) {\\n            ans = abbreviation_recursion(memo, visited, str, result,\\n                                         str_idx + 1, result_idx + 1);\\n        } else if (str[str_idx] - 32 == result[result_idx]) {\\n            ans = abbreviation_recursion(memo, visited, str, result,\\n                                         str_idx + 1, result_idx + 1) ||\\n                  abbreviation_recursion(memo, visited, str, result,\\n                                         str_idx + 1, result_idx);\\n        } else {\\n            // if `str[i]` is uppercase, then cannot be converted, return\\n            // `false`\\n            // else `str[i]` is lowercase, only option is to discard this\\n            // character\\n            if (str[str_idx] >= 'A' && str[str_idx] <= 'Z') {\\n                ans = false;\\n            } else {\\n                ans = abbreviation_recursion(memo, visited, str, result,\\n                                             str_idx + 1, result_idx);\\n            }\\n        }\\n    }\\n    (*memo)[str_idx][result_idx] = ans;\\n    (*visited)[str_idx][result_idx] = true;\\n    return (*memo)[str_idx][result_idx];\\n}\\n/**\\n * @brief\\n * Iterative Dynamic Programming function\\n * @details\\n * Returns whether `s` can be converted to `t` with following rules:\\n * a. Capitalize zero or more of s's lowercase letters from string `s`\\n * b. remove all other lowercase letters from string `s`\\n * Note: The transition states for iterative is similar to recursive as well\\n * @param str given string, which might not be abbreivated\\n * @param result resultant abbreivated string\\n * @returns `false` if string `str` cannot be converted to `result`\\n * @returns `true` if string `str` can be converted to `result`\\n */\\nbool abbreviation(const std::string &str, const std::string &result) {\\n    std::vector<std::vector<bool>> memo(\\n        str.size() + 1, std::vector<bool>(result.size() + 1, false));\\n\\n    for (uint32_t i = 0; i <= str.size(); ++i) {\\n        memo[i][0] = true;\\n    }\\n    for (uint32_t i = 1; i <= result.size(); ++i) {\\n        memo[0][i] = false;\\n    }\\n    for (uint32_t i = 1; i <= str.size(); ++i) {\\n        for (uint32_t j = 1; j <= result.size(); ++j) {\\n            if (str[i - 1] == result[j - 1]) {\\n                memo[i][j] = memo[i - 1][j - 1];\\n            } else if (str[i - 1] - 32 == result[j - 1]) {\\n                memo[i][j] = (memo[i - 1][j - 1] || memo[i - 1][j]);\\n            } else {\\n                if (str[i - 1] >= 'A' && str[i - 1] <= 'Z') {\\n                    memo[i][j] = false;\\n                } else {\\n                    memo[i][j] = memo[i - 1][j];\\n                }\\n            }\\n        }\\n    }\\n    return memo.back().back();\\n}\\n}  // namespace abbreviation\\n}  // namespace dynamic_programming\\n\\n/**\\n * @brief Self test-implementations\\n * @returns void\\n */\\nstatic void test() {\\n    std::string s = \\\"daBcd\\\", t = \\\"ABC\\\";\\n    std::vector<std::vector<bool>> memo(s.size() + 1,\\n                                        std::vector<bool>(t.size() + 1, false)),\\n        visited(s.size() + 1, std::vector<bool>(t.size() + 1, false));\\n\\n    assert(dynamic_programming::abbreviation::abbreviation_recursion(\\n               &memo, &visited, s, t) == true);\\n    assert(dynamic_programming::abbreviation::abbreviation(s, t) == true);\\n    s = \\\"XXVVnDEFYgYeMXzWINQYHAQKKOZEYgSRCzLZAmUYGUGILjMDET\\\";\\n    t = \\\"XXVVDEFYYMXWINQYHAQKKOZEYSRCLZAUYGUGILMDETQVWU\\\";\\n    memo = std::vector<std::vector<bool>>(\\n        s.size() + 1, std::vector<bool>(t.size() + 1, false));\\n\\n    visited = std::vector<std::vector<bool>>(\\n        s.size() + 1, std::vector<bool>(t.size() + 1, false));\\n\\n    assert(dynamic_programming::abbreviation::abbreviation_recursion(\\n               &memo, &visited, s, t) == false);\\n    assert(dynamic_programming::abbreviation::abbreviation(s, t) == false);\\n\\n    s = \\\"DRFNLZZVHLPZWIupjwdmqafmgkg\\\";\\n    t = \\\"DRFNLZZVHLPZWI\\\";\\n\\n    memo = std::vector<std::vector<bool>>(\\n        s.size() + 1, std::vector<bool>(t.size() + 1, false));\\n\\n    visited = std::vector<std::vector<bool>>(\\n        s.size() + 1, std::vector<bool>(t.size() + 1, false));\\n\\n    assert(dynamic_programming::abbreviation::abbreviation_recursion(\\n               &memo, &visited, s, t) == true);\\n    assert(dynamic_programming::abbreviation::abbreviation(s, t) == true);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "armstrong number": "\"/**\\n * @file\\n * \\\\brief Program to check if a number is an [Armstrong/Narcissistic\\n * number](https://en.wikipedia.org/wiki/Narcissistic_number) in decimal system.\\n *\\n * \\\\details\\n * Armstrong number or [Narcissistic\\n * number](https://en.wikipedia.org/wiki/Narcissistic_number) is a number that\\n * is the sum of its own digits raised to the power of the number of digits.\\n * @author iamnambiar\\n */\\n#include <cassert>\\n#include <cmath>\\n#include <iostream>\\n\\n/**\\n * Function to calculate the total number of digits in the number.\\n * @param num Number\\n * @return Total number of digits.\\n */\\nint number_of_digits(int num) {\\n    int total_digits = 0;\\n    while (num > 0) {\\n        num = num / 10;\\n        ++total_digits;\\n    }\\n    return total_digits;\\n}\\n\\n/**\\n * Function to check whether the number is armstrong number or not.\\n * @param num Number\\n * @return `true` if the number is armstrong.\\n * @return `false` if the number is not armstrong.\\n */\\nbool is_armstrong(int number) {\\n    // If the number is less than 0, then it is not a armstrong number.\\n    if (number < 0) {\\n        return false;\\n    }\\n    int sum = 0;\\n    int temp = number;\\n    // Finding the total number of digits in the number\\n    int total_digits = number_of_digits(number);\\n    while (temp > 0) {\\n        int rem = temp % 10;\\n        // Finding each digit raised to the power total digit and add it to the\\n        // total sum\\n        sum = sum + std::pow(rem, total_digits);\\n        temp = temp / 10;\\n    }\\n    return number == sum;\\n}\\n\\n/**\\n * Function for testing the is_armstrong() function\\n * with all the test cases.\\n */\\nvoid test() {\\n    // is_armstrong(370) returns true.\\n    assert(is_armstrong(370) == true);\\n    // is_armstrong(225) returns false.\\n    assert(is_armstrong(225) == false);\\n    // is_armstrong(-23) returns false.\\n    assert(is_armstrong(-23) == false);\\n    // is_armstrong(153) returns true.\\n    assert(is_armstrong(153) == true);\\n    // is_armstrong(0) returns true.\\n    assert(is_armstrong(0) == true);\\n    // is_armstrong(12) returns false.\\n    assert(is_armstrong(12) == false);\\n}\\n\\n/**\\n * Main Function\\n */\\nint main() {\\n    test();\\n    return 0;\\n}\\n\"",
    "bellman ford": "\"#include <limits.h>\\n#include <iostream>\\n\\nusing namespace std;\\n\\n// Wrapper class for storing an edge\\nclass Edge {\\n public:\\n    int src, dst, weight;\\n};\\n\\n// Wrapper class for storing a graph\\nclass Graph {\\n public:\\n    int vertexNum, edgeNum;\\n    Edge *edges;\\n\\n    // Constructs a graph with V vertices and E edges\\n    Graph(int V, int E) {\\n        this->vertexNum = V;\\n        this->edgeNum = E;\\n        this->edges = (Edge *)malloc(E * sizeof(Edge));\\n    }\\n\\n    // Adds the given edge to the graph\\n    void addEdge(int src, int dst, int weight) {\\n        static int edgeInd = 0;\\n        if (edgeInd < this->edgeNum) {\\n            Edge newEdge;\\n            newEdge.src = src;\\n            newEdge.dst = dst;\\n            newEdge.weight = weight;\\n            this->edges[edgeInd++] = newEdge;\\n        }\\n    }\\n};\\n\\n// Utility function to print distances\\nvoid print(int dist[], int V) {\\n    cout << \\\"\\\\nVertex  Distance\\\" << endl;\\n    for (int i = 0; i < V; i++) {\\n        if (dist[i] != INT_MAX)\\n            cout << i << \\\"\\\\t\\\" << dist[i] << endl;\\n        else\\n            cout << i << \\\"\\\\tINF\\\" << endl;\\n    }\\n}\\n\\n// The main function that finds the shortest path from given source\\n// to all other vertices using Bellman-Ford.It also detects negative\\n// weight cycle\\nvoid BellmanFord(Graph graph, int src) {\\n    int V = graph.vertexNum;\\n    int E = graph.edgeNum;\\n    int dist[V];\\n\\n    // Initialize distances array as INF for all except source\\n    // Intialize source as zero\\n    for (int i = 0; i < V; i++) dist[i] = INT_MAX;\\n    dist[src] = 0;\\n\\n    // Calculate shortest path distance from source to all edges\\n    // A path can contain maximum (|V|-1) edges\\n    for (int i = 0; i <= V - 1; i++)\\n        for (int j = 0; j < E; j++) {\\n            int u = graph.edges[j].src;\\n            int v = graph.edges[j].dst;\\n            int w = graph.edges[j].weight;\\n\\n            if (dist[u] != INT_MAX && dist[u] + w < dist[v])\\n                dist[v] = dist[u] + w;\\n        }\\n\\n    // Iterate inner loop once more to check for negative cycle\\n    for (int j = 0; j < E; j++) {\\n        int u = graph.edges[j].src;\\n        int v = graph.edges[j].dst;\\n        int w = graph.edges[j].weight;\\n\\n        if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {\\n            cout << \\\"Graph contains negative weight cycle. Hence, shortest \\\"\\n                    \\\"distance not guaranteed.\\\"\\n                 << endl;\\n            return;\\n        }\\n    }\\n\\n    print(dist, V);\\n\\n    return;\\n}\\n\\n// Driver Function\\nint main() {\\n    int V, E, gsrc;\\n    int src, dst, weight;\\n    cout << \\\"Enter number of vertices: \\\";\\n    cin >> V;\\n    cout << \\\"Enter number of edges: \\\";\\n    cin >> E;\\n    Graph G(V, E);\\n    for (int i = 0; i < E; i++) {\\n        cout << \\\"\\\\nEdge \\\" << i + 1 << \\\"\\\\nEnter source: \\\";\\n        cin >> src;\\n        cout << \\\"Enter destination: \\\";\\n        cin >> dst;\\n        cout << \\\"Enter weight: \\\";\\n        cin >> weight;\\n        G.addEdge(src, dst, weight);\\n    }\\n    cout << \\\"\\\\nEnter source: \\\";\\n    cin >> gsrc;\\n    BellmanFord(G, gsrc);\\n\\n    return 0;\\n}\\n\"",
    "catalan numbers": "\"/** Print all the Catalan numbers from 0 to n, n being the user input.\\n\\n * A Catalan number satifies the following two properties:\\n * C(0) = C(1) = 1; C(n) = sum(C(i).C(n-i-1)), from i = 0 to n-1\\n * Read more about Catalan numbers here:\\n    https://en.wikipedia.org/wiki/Catalan_number\\n */\\n\\n#include <iostream>\\nusing namespace std;\\n\\nint *cat;  // global array to hold catalan numbers\\n\\nunsigned long int catalan_dp(int n) {\\n    /** Using the tabulation technique in dynamic programming,\\n        this function computes the first `n+1` Catalan numbers\\n\\n        Parameter\\n        ---------\\n        n: The number of catalan numbers to be computed.\\n\\n        Returns\\n        -------\\n        cat[n]: An array containing the first `n+1` Catalan numbers\\n    */\\n\\n    // By definition, the first two Catalan numbers are 1\\n    cat[0] = cat[1] = 1;\\n\\n    // Compute the remaining numbers from index 2 to index n, using tabulation\\n    for (int i = 2; i <= n; i++) {\\n        cat[i] = 0;\\n        for (int j = 0; j < i; j++)\\n            cat[i] += cat[j] * cat[i - j - 1];  // applying the definition here\\n    }\\n\\n    // Return the result\\n    return cat[n];\\n}\\n\\nint main(int argc, char *argv[]) {\\n    int n;\\n    cout << \\\"Enter n: \\\";\\n    cin >> n;\\n\\n    cat = new int[n + 1];\\n\\n    cout << \\\"Catalan numbers from 0 to \\\" << n << \\\" are:\\\\n\\\";\\n    for (int i = 0; i <= n; i++) {\\n        cout << \\\"catalan (\\\" << i << \\\") = \\\" << catalan_dp(i) << endl;\\n        // NOTE: Since `cat` is a global array, calling `catalan_dp`\\n        // repeatedly will not recompute the the values already computed\\n        // as in case of pre-computed values, the array will simply return them,\\n        // instead of recomputing them.\\n    }\\n\\n    return 0;\\n}\\n\\n/** Sample Test Case:\\n\\n$ cd \\\"Dynamic Programming\\\"\\n$ g++ Catalan-Numbers.cpp\\n$ ./a.exe\\n\\nEnter n: 5\\nCatalan numbers from 0 to 5 are:\\ncatalan (0) = 1\\ncatalan (1) = 1\\ncatalan (2) = 2\\ncatalan (3) = 5\\ncatalan (4) = 14\\ncatalan (5) = 42\\n\\n*/\\n\"",
    "coin change": "\"#include <climits>\\n#include <iostream>\\nusing namespace std;\\n\\n// Function to find the Minimum number of coins required to get Sum S\\nint findMinCoins(int arr[], int n, int N) {\\n    // dp[i] = no of coins required to get a total of i\\n    int dp[N + 1];\\n\\n    // 0 coins are needed for 0 sum\\n\\n    dp[0] = 0;\\n\\n    for (int i = 1; i <= N; i++) {\\n        // initialize minimum number of coins needed to infinity\\n        dp[i] = INT_MAX;\\n        int res = INT_MAX;\\n\\n        // do for each coin\\n        for (int c = 0; c < n; c++) {\\n            if (i - arr[c] >=\\n                0)  // check if coins doesn't become negative by including it\\n                res = dp[i - arr[c]];\\n\\n            // if total can be reached by including current coin c,\\n            // update minimum number of coins needed dp[i]\\n            if (res != INT_MAX)\\n                dp[i] = min(dp[i], res + 1);\\n        }\\n    }\\n\\n    // The Minimum No of Coins Required for N = dp[N]\\n    return dp[N];\\n}\\n\\nint main() {\\n    // No of Coins We Have\\n    int arr[] = {1, 2, 3, 4};\\n    int n = sizeof(arr) / sizeof(arr[0]);\\n\\n    // Total Change Required\\n    int N = 15;\\n\\n    cout << \\\"Minimum Number of Coins Required \\\" << findMinCoins(arr, n, N)\\n         << \\\"\\\\n\\\";\\n\\n    return 0;\\n}\"",
    "coin change topdown": "\"/**\\n * @file\\n * @brief [Minimum coins](https://leetcode.com/problems/coin-change/) change\\n * problem is a problem used to find the minimum number of coins required to\\n * completely reach a target amount.\\n *\\n * @details\\n * This problem can be solved using 2 methods:\\n * 1. Top down approach\\n * 2. Bottom up appraoch\\n * Top down approach involves a vector with all elements initialised to 0.\\n * It is based on optimal substructure and overlapping subproblems.\\n * Overall time complexity of coin change problem is O(n*t)\\n * For example: example 1:-\\n * Coins: {1,7,10}\\n * Target:15\\n * Therfore minimum number of coins required = 3 of denomination 1,7 and 7.\\n * @author [Divyansh Kushwaha](https://github.com/webdesignbydivyansh)\\n */\\n\\n#include <cassert>   // for assert\\n#include <climits>   // for INT_MAX\\n#include <iostream>  // for io operations\\n#include <vector>    // for std::vector\\n\\n/**\\n * @namespace dynamic_programming\\n * @brief Dynamic Programming algorithm\\n */\\nnamespace dynamic_programming {\\n/**\\n * @namespace mincoins_topdown\\n * @brief Functions for [minimum coin\\n * exchange](https://leetcode.com/problems/coin-change/) problem\\n */\\nnamespace mincoins_topdown {\\n/**\\n * @brief This implementation is for finding minimum number of coins .\\n * @param T template-type to use any kind of value\\n * @param n amount to be reached\\n * @param coins vector of coins\\n * @param t deontes the number of coins\\n * @param dp initilised to 0\\n * @returns minimum number of coins\\n */\\ntemplate <typename T>\\nint64_t mincoins(const T &n, const std::vector<T> &coins, const int16_t &t,\\n                 std::vector<T> dp) {\\n    if (n == 0) {\\n        return 0;\\n    }\\n    if (dp[n] != 0) {\\n        return dp[n];\\n    }\\n    int ans = INT_MAX;  // variable to store min coins\\n    for (int i = 0; i < t; i++) {\\n        if (n - coins[i] >= 0) {  // if after subtracting the current\\n                                  // denomination is it greater than 0 or not\\n            int sub = mincoins(n - coins[i], coins, t, dp);\\n            ans = std::min(ans, sub + 1);\\n        }\\n    }\\n    dp[n] = ans;\\n    return dp[n];  // returns minimum number of coins\\n}\\n\\n}  // namespace mincoins_topdown\\n}  // namespace dynamic_programming\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // example 1: number of coins=3 and minimum coins required=3(7,7,1)\\n    const int64_t n1 = 15;\\n    const int8_t t1 = 3, a1 = 0;\\n    std::cout << \\\"\\\\nTest 1...\\\";\\n    std::vector<int64_t> arr1{1, 7, 10};\\n    std::vector<int64_t> dp1(n1 + 1);\\n    fill(dp1.begin(), dp1.end(), a1);\\n    assert(dynamic_programming::mincoins_topdown::mincoins(n1, arr1, t1, dp1) ==\\n           3);\\n    std::cout << \\\"Passed\\\\n\\\";\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // execute the test\\n    return 0;\\n}\\n\"",
    "cut rod": "\"/**\\n * @file\\n * @brief Implementation of cutting a rod problem\\n *\\n * @details\\n * Given a rod of length n inches and an array of prices that\\n * contains prices of all pieces of size<=n. Determine\\n * the maximum profit obtainable by cutting up the rod and selling\\n * the pieces.\\n *\\n * ### Algorithm\\n * The idea is to break the given rod into every smaller piece as possible\\n * and then check profit for each piece, by calculating maximum profit for\\n * smaller pieces we will build the solution for larger pieces in bottom-up\\n * manner.\\n *\\n * @author [Anmol](https://github.com/Anmol3299)\\n * @author [Pardeep](https://github.com/Pardeep009)\\n */\\n\\n#include <array>\\n#include <cassert>\\n#include <climits>\\n#include <iostream>\\n/**\\n * @namespace dynamic_programming\\n * @brief Dynamic Programming algorithms\\n */\\nnamespace dynamic_programming {\\n/**\\n * @namespace cut_rod\\n * @brief Implementation of cutting a rod problem\\n */\\nnamespace cut_rod {\\n/**\\n * @brief Cuts the rod in different pieces and\\n * stores the maximum profit for each piece of the rod.\\n * @tparam T size of the price array\\n * @param n size of the rod in inches\\n * @param price an array of prices that contains prices of all pieces of size<=n\\n * @return maximum profit obtainable for @param n inch rod.\\n */\\ntemplate <size_t T>\\nint maxProfitByCuttingRod(const std::array<int, T> &price, const uint64_t &n) {\\n    int *profit =\\n        new int[n + 1];  // profit[i] will hold maximum profit for i inch rod\\n\\n    profit[0] = 0;  // if length of rod is zero, then no profit\\n\\n    // outer loop will select size of rod, starting from 1 inch to n inch rod.\\n    // inner loop will evaluate the maximum profit we can get for i inch rod by\\n    // making every possible cut on it and will store it in profit[i].\\n    for (size_t i = 1; i <= n; i++) {\\n        int q = INT_MIN;\\n        for (size_t j = 1; j <= i; j++) {\\n            q = std::max(q, price[j - 1] + profit[i - j]);\\n        }\\n        profit[i] = q;\\n    }\\n    const int16_t ans = profit[n];\\n    delete[] profit;\\n    return ans;  // returning maximum profit\\n}\\n}  // namespace cut_rod\\n}  // namespace dynamic_programming\\n\\n/**\\n * @brief Function to test above algorithm\\n * @returns void\\n */\\nstatic void test() {\\n    // Test 1\\n    const int16_t n1 = 8;                                        // size of rod\\n    std::array<int32_t, n1> price1 = {1,2,4,6,8,45,21,9};  // price array\\n    const int64_t max_profit1 =\\n        dynamic_programming::cut_rod::maxProfitByCuttingRod(price1, n1);\\n    const int64_t expected_max_profit1 = 47;\\n    assert(max_profit1 == expected_max_profit1);\\n    std::cout << \\\"Maximum profit with \\\" << n1 << \\\" inch road is \\\" << max_profit1\\n              << std::endl;\\n\\n    // Test 2\\n    const int16_t n2 = 30;  // size of rod\\n    std::array<int32_t, n2> price2 = {\\n        1,  5,  8,  9,  10, 17, 17, 20, 24, 30,  // price array\\n        31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\\n        41, 42, 43, 44, 45, 46, 47, 48, 49, 50};\\n\\n    const int64_t max_profit2=\\n        dynamic_programming::cut_rod::maxProfitByCuttingRod(price2, n2);\\n    const int32_t expected_max_profit2 = 90;\\n    assert(max_profit2 == expected_max_profit2);\\n    std::cout << \\\"Maximum profit with \\\" << n2 << \\\" inch road is \\\" << max_profit2\\n              << std::endl;\\n     // Test 3\\n    const int16_t n3 = 5;                                        // size of rod\\n    std::array<int32_t, n3> price3 = {2,9,17,23,45};  // price array\\n    const int64_t max_profit3 =\\n        dynamic_programming::cut_rod::maxProfitByCuttingRod(price3, n3);\\n    const int64_t expected_max_profit3 = 45;\\n    assert(max_profit3 == expected_max_profit3);\\n    std::cout << \\\"Maximum profit with \\\" << n3 << \\\" inch road is \\\" << max_profit3\\n              << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    // Testing\\n    test();\\n    return 0;\\n}\\n\"",
    "edit distance": "\"/* Given two strings str1 & str2\\n * and below operations that can\\n * be performed on str1. Find\\n * minimum number of edits\\n * (operations) required to convert\\n * 'str1' into 'str2'/\\n * a. Insert\\n * b. Remove\\n * c. Replace\\n * All of the above operations are\\n * of equal cost\\n */\\n\\n#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nint min(int x, int y, int z) { return min(min(x, y), z); }\\n\\n/* A Naive recursive C++ program to find\\n * minimum number of operations to convert\\n * str1 to str2.\\n * O(3^m)\\n */\\nint editDist(string str1, string str2, int m, int n) {\\n    if (m == 0)\\n        return n;\\n    if (n == 0)\\n        return m;\\n\\n    // If last characters are same then continue\\n    // for the rest of them.\\n    if (str1[m - 1] == str2[n - 1])\\n        return editDist(str1, str2, m - 1, n - 1);\\n\\n    // If last not same, then 3 possibilities\\n    // a.Insert b.Remove c. Replace\\n    // Get min of three and continue for rest.\\n    return 1 + min(editDist(str1, str2, m, n - 1),\\n                   editDist(str1, str2, m - 1, n),\\n                   editDist(str1, str2, m - 1, n - 1));\\n}\\n\\n/* A DP based program\\n * O(m x n)\\n */\\nint editDistDP(string str1, string str2, int m, int n) {\\n    // Create Table for SubProblems\\n    int dp[m + 1][n + 1];\\n\\n    // Fill d[][] in bottom up manner\\n    for (int i = 0; i <= m; i++) {\\n        for (int j = 0; j <= n; j++) {\\n            // If str1 empty. Then add all of str2\\n            if (i == 0)\\n                dp[i][j] = j;\\n\\n            // If str2 empty. Then add all of str1\\n            else if (j == 0)\\n                dp[i][j] = i;\\n\\n            // If character same. Recur for remaining\\n            else if (str1[i - 1] == str2[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1];\\n\\n            else\\n                dp[i][j] = 1 + min(dp[i][j - 1],     // Insert\\n                                   dp[i - 1][j],     // Remove\\n                                   dp[i - 1][j - 1]  // Replace\\n                               );\\n        }\\n    }\\n\\n    return dp[m][n];\\n}\\n\\nint main() {\\n    string str1 = \\\"sunday\\\";\\n    string str2 = \\\"saturday\\\";\\n\\n    cout << editDist(str1, str2, str1.length(), str2.length()) << endl;\\n    cout << editDistDP(str1, str2, str1.length(), str2.length()) << endl;\\n\\n    return 0;\\n}\\n\"",
    "egg dropping puzzle": "\"/* Function to get minimun number of trials needed\\n * in worst case with n eggs and k floors\\n */\\n\\n#include <climits>\\n#include <iostream>\\nusing namespace std;\\n\\nint eggDrop(int n, int k) {\\n    int eggFloor[n + 1][k + 1];\\n    int result;\\n\\n    for (int i = 1; i <= n; i++) {\\n        eggFloor[i][1] = 1;  // n eggs..1 Floor\\n        eggFloor[i][0] = 0;  // n eggs..0 Floor\\n    }\\n\\n    // Only one egg available\\n    for (int j = 1; j <= k; j++) {\\n        eggFloor[1][j] = j;\\n    }\\n\\n    for (int i = 2; i <= n; i++) {\\n        for (int j = 2; j <= k; j++) {\\n            eggFloor[i][j] = INT_MAX;\\n            for (int x = 1; x <= j; x++) {\\n                // 1+max(eggBreak[one less egg, lower floors],\\n                //       eggDoesntBreak[same # of eggs, upper floors]);\\n                result = 1 + max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);\\n                if (result < eggFloor[i][j])\\n                    eggFloor[i][j] = result;\\n            }\\n        }\\n    }\\n\\n    return eggFloor[n][k];\\n}\\n\\nint main() {\\n    int n, k;\\n    cout << \\\"Enter number of eggs and floors: \\\";\\n    cin >> n >> k;\\n    cout << \\\"Minimum number of trials in worst case: \\\" << eggDrop(n, k) << endl;\\n    return 0;\\n}\\n\"",
    "fibonacci bottom up": "\"#include <iostream>\\nusing namespace std;\\nint fib(int n) {\\n    int res[3];\\n    res[0] = 0;\\n    res[1] = 1;\\n    for (int i = 2; i <= n; i++) {\\n        res[2] = res[1] + res[0];\\n        res[0] = res[1];\\n        res[1] = res[2];\\n    }\\n    return res[1];\\n}\\nint main(int argc, char const *argv[]) {\\n    int n;\\n    cout << \\\"Enter n: \\\";\\n    cin >> n;\\n    cout << \\\"Fibonacci number is \\\";\\n    cout << fib(n) << endl;\\n    return 0;\\n}\\n\"",
    "floyd warshall": "\"#include <climits>\\n#include <iostream>\\n#include <string>\\n\\nusing std::cin;\\nusing std::cout;\\nusing std::endl;\\n\\n// Wrapper class for storing a graph\\nclass Graph {\\n public:\\n    int vertexNum;\\n    int **edges;\\n\\n    // Constructs a graph with V vertices and E edges\\n    Graph(int V) {\\n        this->vertexNum = V;\\n        this->edges = new int *[V];\\n        for (int i = 0; i < V; i++) {\\n            this->edges[i] = new int[V];\\n            for (int j = 0; j < V; j++) this->edges[i][j] = INT_MAX;\\n            this->edges[i][i] = 0;\\n        }\\n    }\\n\\n    ~Graph() {\\n        for (int i = 0; i < vertexNum; i++) delete[] edges[i];\\n        delete[] edges;\\n    }\\n\\n    // Adds the given edge to the graph\\n    void addEdge(int src, int dst, int weight) {\\n        this->edges[src][dst] = weight;\\n    }\\n};\\n\\n// Utility function to print distances\\nvoid print(int dist[], int V) {\\n    cout << \\\"\\\\nThe Distance matrix for Floyd - Warshall\\\" << endl;\\n    for (int i = 0; i < V; i++) {\\n        for (int j = 0; j < V; j++) {\\n            if (dist[i * V + j] != INT_MAX)\\n                cout << dist[i * V + j] << \\\"\\\\t\\\";\\n            else\\n                cout << \\\"INF\\\"\\n                     << \\\"\\\\t\\\";\\n        }\\n        cout << endl;\\n    }\\n}\\n\\n// The main function that finds the shortest path from a vertex\\n// to all other vertices using Floyd-Warshall Algorithm.\\nvoid FloydWarshall(Graph graph) {\\n    int V = graph.vertexNum;\\n    int dist[V][V];\\n\\n    // Initialise distance array\\n    for (int i = 0; i < V; i++)\\n        for (int j = 0; j < V; j++) dist[i][j] = graph.edges[i][j];\\n\\n    // Calculate distances\\n    for (int k = 0; k < V; k++)\\n        // Choose an intermediate vertex\\n\\n        for (int i = 0; i < V; i++)\\n            // Choose a source vertex for given intermediate\\n\\n            for (int j = 0; j < V; j++)\\n                // Choose a destination vertex for above source vertex\\n\\n                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX &&\\n                    dist[i][k] + dist[k][j] < dist[i][j])\\n                    // If the distance through intermediate vertex is less than\\n                    // direct edge then update value in distance array\\n                    dist[i][j] = dist[i][k] + dist[k][j];\\n\\n    // Convert 2d array to 1d array for print\\n    int dist1d[V * V];\\n    for (int i = 0; i < V; i++)\\n        for (int j = 0; j < V; j++) dist1d[i * V + j] = dist[i][j];\\n\\n    print(dist1d, V);\\n}\\n\\n// Driver Function\\nint main() {\\n    int V, E;\\n    int src, dst, weight;\\n    cout << \\\"Enter number of vertices: \\\";\\n    cin >> V;\\n    cout << \\\"Enter number of edges: \\\";\\n    cin >> E;\\n    Graph G(V);\\n    for (int i = 0; i < E; i++) {\\n        cout << \\\"\\\\nEdge \\\" << i + 1 << \\\"\\\\nEnter source: \\\";\\n        cin >> src;\\n        cout << \\\"Enter destination: \\\";\\n        cin >> dst;\\n        cout << \\\"Enter weight: \\\";\\n        cin >> weight;\\n        G.addEdge(src, dst, weight);\\n    }\\n    FloydWarshall(G);\\n\\n    return 0;\\n}\\n\"",
    "house robber": "\"/**\\n * @file\\n * @brief Implementation of [House Robber\\n * Problem](https://labuladong.gitbook.io/algo-en/i.-dynamic-programming/houserobber)\\n * algorithm\\n * @details\\n * Solution of House robber problem uses a dynamic programming concept that\\n * works in \\\\f$O(n)\\\\f$ time and works in \\\\f$O(1)\\\\f$ space.\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <climits>   /// for std::max\\n#include <iostream>  /// for io operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace dynamic_programming\\n * @brief Dynamic Programming algorithms\\n */\\nnamespace dynamic_programming {\\n/**\\n * @namespace house_robber\\n * @brief Functions for the [House\\n * Robber](https://labuladong.gitbook.io/algo-en/i.-dynamic-programming/houserobber)\\n * algorithm\\n */\\nnamespace house_robber {\\n/**\\n * @brief The main function that implements the House Robber algorithm using\\n * dynamic programming\\n * @param money array containing money in the ith house\\n * @param n size of array\\n * @returns maximum amount of money that can be robbed\\n */\\nstd::uint32_t houseRobber(const std::vector<uint32_t> &money,\\n                          const uint32_t &n) {\\n    if (n == 0) {  // if there is no house\\n        return 0;\\n    }\\n    if (n == 1) {  // if there is only one house\\n        return money[0];\\n    }\\n    if (n == 2) {  // if there are two houses, one with the maximum amount of\\n                   // money will be robbed\\n        return std::max(money[0], money[1]);\\n    }\\n    uint32_t max_value = 0;  // contains maximum stolen value at the end\\n    uint32_t value1 = money[0];\\n    uint32_t value2 = std::max(money[0], money[1]);\\n    for (uint32_t i = 2; i < n; i++) {\\n        max_value = std::max(money[i] + value1, value2);\\n        value1 = value2;\\n        value2 = max_value;\\n    }\\n\\n    return max_value;\\n}\\n}  // namespace house_robber\\n}  // namespace dynamic_programming\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // Test 1\\n    // [1, 2, 3, 1] return 4\\n    std::vector<uint32_t> array1 = {1, 2, 3, 1};\\n    std::cout << \\\"Test 1... \\\";\\n    assert(\\n        dynamic_programming::house_robber::houseRobber(array1, array1.size()) ==\\n        4);  // here the two non-adjacent houses that are robbed are first and\\n             // third with total sum money as 4\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // Test 2\\n    // [6, 7, 1, 3, 8, 2, 4] return 19\\n    std::vector<uint32_t> array2 = {6, 7, 1, 3, 8, 2, 4};\\n    std::cout << \\\"Test 2... \\\";\\n    assert(\\n        dynamic_programming::house_robber::houseRobber(array2, array2.size()) ==\\n        19);  // here the four non-adjacent houses that are robbed are first,\\n              // third, fifth and seventh with total sum money as 19\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // Test 3\\n    // [] return 0\\n    std::vector<uint32_t> array3 = {};\\n    std::cout << \\\"Test 3... \\\";\\n    assert(\\n        dynamic_programming::house_robber::houseRobber(array3, array3.size()) ==\\n        0);  // since there is no house no money can be robbed\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // Test 4\\n    // [2,7,9,3,1] return 12\\n    std::vector<uint32_t> array4 = {2, 7, 9, 3, 1};\\n    std::cout << \\\"Test 4... \\\";\\n    assert(\\n        dynamic_programming::house_robber::houseRobber(array4, array4.size()) ==\\n        12);  // here the three non-adjacent houses that are robbed are first,\\n              // third and fifth with total sum money as 12\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "kadane": "\"#include <climits>\\n#include <iostream>\\n\\nint maxSubArraySum(int a[], int size) {\\n    int max_so_far = INT_MIN, max_ending_here = 0;\\n\\n    for (int i = 0; i < size; i++) {\\n        max_ending_here = max_ending_here + a[i];\\n        if (max_so_far < max_ending_here)\\n            max_so_far = max_ending_here;\\n\\n        if (max_ending_here < 0)\\n            max_ending_here = 0;\\n    }\\n    return max_so_far;\\n}\\n\\nint main() {\\n    int n, i;\\n    std::cout << \\\"Enter the number of elements \\\\n\\\";\\n    std::cin >> n;\\n    int a[n];  // NOLINT\\n    for (i = 0; i < n; i++) {\\n        std::cin >> a[i];\\n    }\\n    int max_sum = maxSubArraySum(a, n);\\n    std::cout << \\\"Maximum contiguous sum is \\\" << max_sum;\\n    return 0;\\n}\\n\"",
    "kadane2": "\"/**\\n * @file\\n * @brief Implementation of [Kadane\\n * Algorithm] (https://en.wikipedia.org/wiki/Kadane%27s_algorithm)\\n *\\n * @details\\n * Kadane algorithm is used to find the maximum sum subarray in an array and\\n * maximum sum subarray problem is the task of finding a contiguous subarray\\n * with the largest sum\\n *\\n * ### Algorithm\\n * The simple idea of the algorithm is to search for all positive\\n * contiguous segments of the array and keep track of maximum sum contiguous\\n * segment among all positive segments(curr_sum is used for this)\\n * Each time we get a positive sum we compare it with max_sum and update max_sum\\n * if it is greater than curr_sum\\n *\\n * @author [Ayush Singh](https://github.com/ayush523)\\n */\\n#include <array>\\n#include <climits>\\n#include <iostream>\\n/**\\n * @namespace dynamic_programming\\n * @brief Dynamic Programming algorithms\\n */\\nnamespace dynamic_programming {\\n/**\\n * @namespace kadane\\n * @brief Functions for\\n * [Kadane](https://en.wikipedia.org/wiki/Kadane%27s_algorithm) algorithm.\\n */\\nnamespace kadane {\\n/**\\n * @brief maxSubArray function is used to calculate the maximum sum subarray\\n * and returns the value of maximum sum which is stored in the variable max_sum\\n * @tparam N number of array size\\n * @param n array where numbers are saved\\n * @returns the value of maximum subarray sum\\n */\\ntemplate <size_t N>\\nint maxSubArray(const std::array<int, N> &n) {\\n    int curr_sum =\\n        0;  // declaring a variable named as curr_sum and initialized it to 0\\n    int max_sum = INT_MIN;  // Initialized max_sum to INT_MIN\\n    for (int i : n) {  // for loop to iterate over the elements of the array\\n        curr_sum += n[i];\\n        max_sum = std::max(max_sum, curr_sum);  // getting the maximum value\\n        curr_sum = std::max(curr_sum, 0);  // updating the value of curr_sum\\n    }\\n    return max_sum;  // returning the value of max_sum\\n}\\n}  // namespace kadane\\n}  // namespace dynamic_programming\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    const int N = 5;\\n    std::array<int, N> n{};  // declaring array\\n                             // taking values of elements from user\\n    for (int i = 0; i < n.size(); i++) {\\n        std::cout << \\\"Enter value of n[\\\" << i << \\\"]\\\"\\n                  << \\\"\\\\n\\\";\\n        std::cin >> n[i];\\n    }\\n    int max_sum = dynamic_programming::kadane::maxSubArray<N>(\\n        n);  // calling maxSubArray function\\n    std::cout << \\\"Maximum subarray sum is \\\" << max_sum;  // Printing the answer\\n\\n    return 0;\\n}\\n\"",
    "longest common string": "\"#include <iosrteam>\\nusing namespace std;\\n\\nint max(int a, int b) { return (a > b) ? a : b; }\\n\\nint main() {\\n    char str1[] = \\\"DEFBCD\\\";\\n    char str2[] = \\\"ABDEFJ\\\";\\n    int i, j, k;\\n    int n = strlen(str1) + 1;\\n    int m = strlen(str2) + 1;\\n    // cout<<n<<\\\" \\\"<<m<<\\\"\\\\n\\\";\\n    int a[m][n];\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++) {\\n            if (i == 0 || j == 0)\\n                a[i][j] = 0;\\n\\n            else if (str1[i - 1] == str2[j - 1])\\n                a[i][j] = a[i - 1][j - 1] + 1;\\n\\n            else\\n                a[i][j] = 0;\\n        }\\n    }\\n\\n    /*for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n                cout<<a[i][j]<<\\\" \\\";\\n            cout<<\\\"\\\\n\\\";\\n        }*/\\n\\n    int ma = -1;\\n    int indi, indj;\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++) {\\n            if (a[i][j] > ma) {\\n                ma = a[i][j];\\n                indi = i;\\n                indj = j;\\n            }\\n        }\\n    }\\n\\n    cout << str1 << \\\"\\\\n\\\";\\n    cout << str2 << \\\"\\\\n\\\";\\n\\n    cout << \\\"longest string size = \\\" << ma /*<<\\\" \\\"<<indi<<\\\" \\\"<<indj*/ << \\\"\\\\n\\\";\\n    for (i = indi - 3; i < indi; i++) cout << str1[i];\\n    cout << \\\"\\\\n\\\";\\n}\\n\"",
    "longest common subsequence": "\"// Longest common subsequence - Dynamic Programming\\n#include <iostream>\\nusing namespace std;\\n\\nvoid Print(int trace[20][20], int m, int n, string a) {\\n    if (m == 0 || n == 0) {\\n        return;\\n    }\\n    if (trace[m][n] == 1) {\\n        Print(trace, m - 1, n - 1, a);\\n        cout << a[m - 1];\\n    } else if (trace[m][n] == 2) {\\n        Print(trace, m - 1, n, a);\\n    } else if (trace[m][n] == 3) {\\n        Print(trace, m, n - 1, a);\\n    }\\n}\\n\\nint lcs(string a, string b) {\\n    int m = a.length(), n = b.length();\\n    int res[m + 1][n + 1];\\n    int trace[20][20];\\n\\n    // fills up the arrays with zeros.\\n    for (int i = 0; i < m + 1; i++) {\\n        for (int j = 0; j < n + 1; j++) {\\n            res[i][j] = 0;\\n            trace[i][j] = 0;\\n        }\\n    }\\n\\n    for (int i = 0; i < m + 1; ++i) {\\n        for (int j = 0; j < n + 1; ++j) {\\n            if (i == 0 || j == 0) {\\n                res[i][j] = 0;\\n                trace[i][j] = 0;\\n            }\\n\\n            else if (a[i - 1] == b[j - 1]) {\\n                res[i][j] = 1 + res[i - 1][j - 1];\\n                trace[i][j] = 1;  // 1 means trace the matrix in upper left\\n                                  // diagonal direction.\\n            } else {\\n                if (res[i - 1][j] > res[i][j - 1]) {\\n                    res[i][j] = res[i - 1][j];\\n                    trace[i][j] =\\n                        2;  // 2 means trace the matrix in upwards direction.\\n                } else {\\n                    res[i][j] = res[i][j - 1];\\n                    trace[i][j] =\\n                        3;  //  means trace the matrix in left direction.\\n                }\\n            }\\n        }\\n    }\\n    Print(trace, m, n, a);\\n    return res[m][n];\\n}\\n\\nint main() {\\n    string a, b;\\n    cin >> a >> b;\\n    cout << lcs(a, b);\\n    return 0;\\n}\\n\"",
    "longest increasing subsequence": "\"/**\\n * @file\\n * @brief Calculate the length of the [longest increasing\\n * subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) in\\n * an array\\n *\\n * @details\\n * In computer science, the longest increasing subsequence problem is to find a\\n * subsequence of a given sequence in which the subsequence's elements are in\\n * sorted order, lowest to highest, and in which the subsequence is as long as\\n * possible. This subsequence is not necessarily contiguous, or unique. Longest\\n * increasing subsequences are studied in the context of various disciplines\\n * related to mathematics, including algorithmics, random matrix theory,\\n * representation theory, and physics. The longest increasing subsequence\\n * problem is solvable in time O(n log n), where n denotes the length of the\\n * input sequence.\\n *\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @author [David Leal](https://github.com/Panquesito7)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <climits>   /// for std::max\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace dynamic_programming\\n * @brief Dynamic Programming algorithms\\n */\\nnamespace dynamic_programming {\\n/**\\n * @brief Calculate the longest increasing subsequence for the specified numbers\\n * @param a the array used to calculate the longest increasing subsequence\\n * @param n the size used for the arrays\\n * @returns the length of the longest increasing\\n * subsequence in the `a` array of size `n`\\n */\\nuint64_t LIS(const std::vector<uint64_t> &a, const uint32_t &n) {\\n    std::vector<int> lis(n);\\n    for (int i = 0; i < n; ++i) {\\n        lis[i] = 1;\\n    }\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j < i; ++j) {\\n            if (a[i] > a[j] && lis[i] < lis[j] + 1) {\\n                lis[i] = lis[j] + 1;\\n            }\\n        }\\n    }\\n    int res = 0;\\n    for (int i = 0; i < n; ++i) {\\n        res = std::max(res, lis[i]);\\n    }\\n    return res;\\n}\\n}  // namespace dynamic_programming\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    std::vector<uint64_t> a = {15, 21, 2, 3, 4, 5, 8, 4, 1, 1};\\n    uint32_t n = a.size();\\n\\n    uint32_t result = dynamic_programming::LIS(a, n);\\n    assert(result ==\\n           5);  ///< The longest increasing subsequence is `{2,3,4,5,8}`\\n\\n    std::cout << \\\"Self-test implementations passed!\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, char const *argv[]) {\\n    uint32_t n = 0;\\n\\n    std::cout << \\\"Enter size of array: \\\";\\n    std::cin >> n;\\n\\n    std::vector<uint64_t> a(n);\\n\\n    std::cout << \\\"Enter array elements: \\\";\\n    for (int i = 0; i < n; ++i) {\\n        std::cin >> a[i];\\n    }\\n\\n    std::cout << \\\"\\\\nThe result is: \\\" << dynamic_programming::LIS(a, n)\\n              << std::endl;\\n    test();  // run self-test implementations\\n\\n    return 0;\\n}\\n\"",
    "longest increasing subsequence (nlogn)": "\"// Program to calculate length of longest increasing subsequence in an array\\n// in O(n log n)\\n// tested on : https://cses.fi/problemset/task/1145/\\n\\n#include <iostream>\\n\\nusing namespace std;\\nint LIS(int arr[], int n) {\\n    set<int> active;  // The current built LIS.\\n    active.insert(arr[0]);\\n    // Loop through every element.\\n    for (int i = 1; i < n; ++i) {\\n        auto get = active.lower_bound(arr[i]);\\n        if (get == active.end()) {\\n            active.insert(arr[i]);\\n        }  // current element is the greatest so LIS increases by 1.\\n        else {\\n            int val = *get;  // we find the position where arr[i] will be in the\\n                             // LIS. If it is in the LIS already we do nothing\\n            if (val > arr[i]) {\\n                // else we remove the bigger element and add a smaller element\\n                // (which is arr[i]) and continue;\\n                active.erase(get);\\n                active.insert(arr[i]);\\n            }\\n        }\\n    }\\n    return active.size();  // size of the LIS.\\n}\\nint main(int argc, char const* argv[]) {\\n    int n;\\n    cout << \\\"Enter size of array: \\\";\\n    cin >> n;\\n    int a[n];\\n    cout << \\\"Enter array elements: \\\";\\n    for (int i = 0; i < n; ++i) {\\n        cin >> a[i];\\n    }\\n    cout << LIS(a, n) << endl;\\n    return 0;\\n}\\n\"",
    "longest palindromic subsequence": "\"/**\\r\\n * @file\\r\\n * @brief Program to find the Longest Palindormic\\r\\n * Subsequence of a string\\r\\n *\\r\\n * @details\\r\\n * [Palindrome](https://en.wikipedia.org/wiki/Palindrome) string sequence of\\r\\n * characters which reads the same backward as forward\\r\\n * [Subsequence](https://en.wikipedia.org/wiki/Subsequence)  is a sequence that\\r\\n * can be derived from another sequence by deleting some or no elements without\\r\\n * changing the order of the remaining elements.\\r\\n\\r\\n * @author [Anjali Jha](https://github.com/anjali1903)\\r\\n */\\r\\n\\r\\n#include <algorithm>\\r\\n#include <cassert>\\r\\n#include <iostream>\\r\\n#include <vector>\\r\\n\\r\\n/**\\r\\n * Function that returns the longest palindromic\\r\\n * subsequence of a string\\r\\n */\\r\\nstd::string lps(std::string a) {\\r\\n    std::string b = a;\\r\\n    reverse(b.begin(), b.end());\\r\\n    int m = a.length();\\r\\n    std::vector<std::vector<int> > res(m + 1);\\r\\n\\r\\n    // Finding the length of the longest\\r\\n    // palindromic subsequence and storing\\r\\n    // in a 2D array in bottoms-up manner\\r\\n    for (int i = 0; i <= m; i++) {\\r\\n        for (int j = 0; j <= m; j++) {\\r\\n            if (i == 0 || j == 0) {\\r\\n                res[i][j] = 0;\\r\\n            } else if (a[i - 1] == b[j - 1]) {\\r\\n                res[i][j] = res[i - 1][j - 1] + 1;\\r\\n            } else {\\r\\n                res[i][j] = std::max(res[i - 1][j], res[i][j - 1]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    // Length of longest palindromic subsequence\\r\\n    int idx = res[m][m];\\r\\n    // Creating string of index+1 length\\r\\n    std::string ans(idx + 1, '\\\\0');\\r\\n    int i = m, j = m;\\r\\n\\r\\n    // starting from right-most bottom-most corner\\r\\n    // and storing them one by one in ans\\r\\n    while (i > 0 && j > 0) {\\r\\n        // if current characters in a and b are same\\r\\n        // then it is a part of the ans\\r\\n        if (a[i - 1] == b[j - 1]) {\\r\\n            ans[idx - 1] = a[i - 1];\\r\\n            i--;\\r\\n            j--;\\r\\n            idx--;\\r\\n        }\\r\\n        // If they are not same, find the larger of the\\r\\n        // two and move in that direction\\r\\n        else if (res[i - 1][j] > res[i][j - 1]) {\\r\\n            i--;\\r\\n        } else {\\r\\n            j--;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return ans;\\r\\n}\\r\\n\\r\\n/** Test function */\\r\\nvoid test() {\\r\\n    // lps(\\\"radar\\\") return \\\"radar\\\"\\r\\n    assert(lps(\\\"radar\\\") == \\\"radar\\\");\\r\\n    // lps(\\\"abbcbaa\\\") return \\\"abcba\\\"\\r\\n    assert(lps(\\\"abbcbaa\\\") == \\\"abcba\\\");\\r\\n    // lps(\\\"bbbab\\\") return \\\"bbbb\\\"\\r\\n    assert(lps(\\\"bbbab\\\") == \\\"bbbb\\\");\\r\\n}\\r\\n\\r\\n/**\\r\\n * Main Function\\r\\n */\\r\\nint main() {\\r\\n    test();  // execute the tests\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "matrix chain multiplication": "\"#include <climits>\\n#include <iostream>\\nusing namespace std;\\n\\n#define MAX 10\\n\\n// dp table to store the solution for already computed sub problems\\nint dp[MAX][MAX];\\n\\n// Function to find the most efficient way to multiply the given sequence of\\n// matrices\\nint MatrixChainMultiplication(int dim[], int i, int j) {\\n    // base case: one matrix\\n    if (j <= i + 1)\\n        return 0;\\n\\n    // stores minimum number of scalar multiplications (i.e., cost)\\n    // needed to compute the matrix M[i+1]...M[j] = M[i..j]\\n    int min = INT_MAX;\\n\\n    // if dp[i][j] is not calculated (calculate it!!)\\n\\n    if (dp[i][j] == 0) {\\n        // take the minimum over each possible position at which the\\n        // sequence of matrices can be split\\n\\n        for (int k = i + 1; k <= j - 1; k++) {\\n            // recur for M[i+1]..M[k] to get a i x k matrix\\n            int cost = MatrixChainMultiplication(dim, i, k);\\n\\n            // recur for M[k+1]..M[j] to get a k x j matrix\\n            cost += MatrixChainMultiplication(dim, k, j);\\n\\n            // cost to multiply two (i x k) and (k x j) matrix\\n            cost += dim[i] * dim[k] * dim[j];\\n\\n            if (cost < min)\\n                min = cost;  // store the minimum cost\\n        }\\n        dp[i][j] = min;\\n    }\\n\\n    // return min cost to multiply M[j+1]..M[j]\\n    return dp[i][j];\\n}\\n\\n// main function\\nint main() {\\n    // Matrix i has Dimensions dim[i-1] & dim[i] for i=1..n\\n    // input is 10 x 30 matrix, 30 x 5 matrix, 5 x 60 matrix\\n    int dim[] = {10, 30, 5, 60};\\n    int n = sizeof(dim) / sizeof(dim[0]);\\n\\n    // Function Calling: MatrixChainMultiplications(dimensions_array, starting,\\n    // ending);\\n\\n    cout << \\\"Minimum cost is \\\" << MatrixChainMultiplication(dim, 0, n - 1)\\n         << \\\"\\\\n\\\";\\n\\n    return 0;\\n}\"",
    "minimum edit distance": "\"/**\\r\\n * @file\\r\\n * @brief Implementation of [Minimum Edit Distance](https://en.wikipedia.org/wiki/Edit_distance) using Dynamic Programing\\r\\n *\\r\\n * @details\\r\\n *\\r\\n * Given two strings str1 & str2 and we have to calculate the minimum\\r\\n * number of operations (Insert, Remove, Replace) required to convert\\r\\n * str1 to str2.\\r\\n *\\r\\n * ### Algorithm\\r\\n *\\r\\n * We will solve this problem using Naive recursion. But as we are\\r\\n * approaching with a DP solution. So, we will take a DP array to\\r\\n * store the solution of all sub-problems so that we don't have to\\r\\n * perform recursion again and again. Now to solve the problem, We\\r\\n * can traverse all characters from either right side of the strings\\r\\n * or left side. Suppose we will do it from the right side. So, there\\r\\n * are two possibilities for every pair of characters being traversed.\\r\\n * 1. If the last characters of two strings are the same, Ignore\\r\\n * the characters and get the count for the remaining string.\\r\\n * So, we get the solution for lengths m-1 and n-1 in a DP array.\\r\\n *\\r\\n * 2. Else, (If last characters are not the same), we will consider all\\r\\n * three operations (Insert, Remove, Replace) on the last character of\\r\\n * the first string and compute the minimum cost for all three operations\\r\\n * and take the minimum of three values in the DP array.\\r\\n * For Insert: Recur for m and n-1\\r\\n * For Remove: Recur for for m-1 and n\\r\\n * For Replace: Recur for for m-1 and n-1\\r\\n *\\r\\n * @author [Nirjas Jakilim](github.com/nirzak)\\r\\n */\\r\\n\\r\\n#include <cassert>     /// for assert\\r\\n#include <iostream>   /// for IO operations\\r\\n#include <vector>    /// for std::vector\\r\\n/**\\r\\n * @namespace dynamic_programming\\r\\n * @brief Dynamic Programming algorithms\\r\\n */\\r\\n\\r\\nnamespace dynamic_programming {\\r\\n\\r\\n/**\\r\\n * @namespace Minimum Edit Distance\\r\\n * @brief Implementation of [Minimum Edit Distance](https://en.wikipedia.org/wiki/Edit_distance) algorithm\\r\\n */\\r\\n\\r\\nnamespace minimum_edit_distance {\\r\\n\\r\\n/**\\r\\n * @brief Takes input of the cost of\\r\\n * three operations: Insert, Replace and Delete\\r\\n * and return the minimum cost among them.\\r\\n * @param x used to pass minimum cost of Insert operations\\r\\n * @param y used to pass minimum cost of Replace operations\\r\\n * @param z used to pass minimum cost of Delete operations\\r\\n * @returns x if `x` is the minimum value\\r\\n * @returns y if `y` is the minimum value\\r\\n * @returns z if `z` is the minimum value\\r\\n */\\r\\nuint64_t min(uint64_t x, uint64_t y, uint64_t z) {\\r\\n  if (x <= y && x <= z) {\\r\\n    return x; /// returns x, if x is the minimum value\\r\\n  }\\r\\n  if (y <= x && y <= z) {\\r\\n    return y; /// returns y, if y is the minimum value\\r\\n  }\\r\\n  else {\\r\\n    return z; /// returns z if z is the minimum value\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Calculates and stores the result\\r\\n * of all the sub-problems, so that we don't have to recur to compute\\r\\n * the minimum cost of a particular operation if it is already\\r\\n * computed and stored in the `dp` vector.\\r\\n * @param dp vector to store the computed minimum costs\\r\\n * @param str1 to pass the 1st string\\r\\n * @param str2 to pass the 2nd string\\r\\n * @param m the length of str1\\r\\n * @param n the length of str2\\r\\n * @returns dp[m][n] the minimum cost of operations\\r\\n * needed to convert str1 to str2\\r\\n */\\r\\nuint64_t editDistDP(std::string str1, std::string str2, uint64_t m, uint64_t n) {\\r\\n  /// Create a table to store results of subproblems\\r\\n  std::vector<std::vector<uint64_t>>dp(m+1, std::vector<uint64_t>(n+1)); /// creasting 2D vector dp to store the results of subproblems\\r\\n\\r\\n  /// Fill d[][] in bottom up manner\\r\\n  for (uint64_t i = 0; i <= m; i++) {\\r\\n    for (uint64_t j = 0; j <= n; j++) {\\r\\n      /// If first string is empty, only option is to\\r\\n      /// insert all characters of second string\\r\\n      if (i == 0) {\\r\\n        dp[i][j] = j; /// Minimum operations = j\\r\\n      }\\r\\n\\r\\n      /// If second string is empty, only option is to\\r\\n      /// remove all characters of second string\\r\\n      else if (j == 0) {\\r\\n        dp[i][j] = i; /// Minimum operations = i\\r\\n      }\\r\\n\\r\\n      /// If last characters are same, ignore last char\\r\\n      /// and recur for remaining string\\r\\n      else if (str1[i - 1] == str2[j - 1]) {\\r\\n        dp[i][j] = dp[i - 1][j - 1];\\r\\n      }\\r\\n\\r\\n      /// If the last character is different, consider all\\r\\n      /// possibilities and find the minimum\\r\\n      else {\\r\\n        dp[i][j] = 1 + min(dp[i][j - 1],      // Insert\\r\\n                           dp[i - 1][j],      // Remove\\r\\n                           dp[i - 1][j - 1]); // Replace\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return dp[m][n]; /// returning the minimum cost of operations needed to convert str1 to str2\\r\\n}\\r\\n}  // namespace minimum_edit_distance\\r\\n}  // namespace dynamic_programming\\r\\n\\r\\n/**\\r\\n * @brief Self-test implementations\\r\\n * @returns void\\r\\n */\\r\\nstatic void test() {\\r\\n  // 1st test\\r\\n  std::string str1 = \\\"INTENTION\\\"; // Sample input of 1st string\\r\\n  std::string str2 = \\\"EXECUTION\\\"; // Sample input of 2nd string\\r\\n  uint64_t expected_output1 = 5; // Expected minimum cost\\r\\n  uint64_t output1 = dynamic_programming::minimum_edit_distance::editDistDP(\\r\\n      str1, str2, str1.length(), str2.length()); // calling the editDistDP function and storing the result on output1\\r\\n  assert(output1 == expected_output1); // comparing the output with the expected output\\r\\n  std::cout << \\\"Minimum Number of Operations Required: \\\" << output1\\r\\n            << std::endl;\\r\\n\\r\\n  // 2nd test\\r\\n  std::string str3 = \\\"SATURDAY\\\";\\r\\n  std::string str4 = \\\"SUNDAY\\\";\\r\\n  uint64_t expected_output2 = 3;\\r\\n  uint64_t output2 = dynamic_programming::minimum_edit_distance::editDistDP(\\r\\n      str3, str4, str3.length(), str4.length());\\r\\n  assert(output2 == expected_output2);\\r\\n  std::cout << \\\"Minimum Number of Operations Required: \\\" << output2\\r\\n            << std::endl;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief main function\\r\\n * @param argc commandline argument count (ignored)\\r\\n * @param argv commandline array of arguments (ignored)\\r\\n * @returns 0 on exit\\r\\n */\\r\\nint main(int argc, char *argv[]) {\\r\\n  test();  // run self-test implementations\\r\\n  return 0;\\r\\n}\\r\\n\"",
    "palindrome partitioning": "\"/**\\n * @file\\n * @brief Implements [Palindrome\\n * Partitioning](https://leetcode.com/problems/palindrome-partitioning-ii/)\\n * algorithm, giving you the minimum number of partitions you need to make\\n *\\n * @details\\n * palindrome partitioning uses dynamic programming and goes to all the possible\\n * partitions to find the minimum you are given a string and you need to give\\n * minimum number of partitions needed to divide it into a number of palindromes\\n * [Palindrome Partitioning]\\n * (https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/) overall time\\n * complexity O(n^2) For example: example 1:- String : \\\"nitik\\\" Output : 2 => \\\"n\\n * | iti | k\\\" For example: example 2:- String : \\\"ababbbabbababa\\\" Output : 3 =>\\n * \\\"aba | b | bbabb | ababa\\\"\\n * @author [Sujay Kaushik] (https://github.com/sujaykaushik008)\\n */\\n\\n#include <algorithm>  // for std::min\\n#include <cassert>    // for std::assert\\n#include <climits>    // for INT_MAX\\n#include <iostream>   // for io operations\\n#include <vector>     // for std::vector\\n\\n/**\\n * @namespace dynamic_programming\\n * @brief Dynamic Programming algorithms\\n */\\nnamespace dynamic_programming {\\n\\n/**\\n * @namespace palindrome_partitioning\\n * @brief Functions for [Palindrome\\n * Partitioning](https://leetcode.com/problems/palindrome-partitioning-ii/)\\n * algorithm\\n */\\nnamespace palindrome_partitioning {\\n\\n/**\\n * Function implementing palindrome partitioning algorithm using lookup table\\n * method.\\n * @param str input string\\n * @returns minimum number of partitions\\n */\\nint pal_part(const std::string &str) {\\n    int n = str.size();\\n\\n    // creating lookup table for minimum number of cuts\\n    std::vector<std::vector<int> > cuts(n, std::vector<int>(n, 0));\\n\\n    // creating lookup table for palindrome checking\\n    std::vector<std::vector<bool> > is_palindrome(n,\\n                                                  std::vector<bool>(n, false));\\n\\n    // initialization\\n    for (int i = 0; i < n; i++) {\\n        is_palindrome[i][i] = true;\\n        cuts[i][i] = 0;\\n    }\\n\\n    for (int len = 2; len <= n; len++) {\\n        for (int start_index = 0; start_index < n - len + 1; start_index++) {\\n            int end_index = start_index + len - 1;\\n\\n            if (len == 2) {\\n                is_palindrome[start_index][end_index] =\\n                    (str[start_index] == str[end_index]);\\n            } else {\\n                is_palindrome[start_index][end_index] =\\n                    (str[start_index] == str[end_index]) &&\\n                    is_palindrome[start_index + 1][end_index - 1];\\n            }\\n\\n            if (is_palindrome[start_index][end_index]) {\\n                cuts[start_index][end_index] = 0;\\n            } else {\\n                cuts[start_index][end_index] = INT_MAX;\\n                for (int partition = start_index; partition <= end_index - 1;\\n                     partition++) {\\n                    cuts[start_index][end_index] =\\n                        std::min(cuts[start_index][end_index],\\n                                 cuts[start_index][partition] +\\n                                     cuts[partition + 1][end_index] + 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    return cuts[0][n - 1];\\n}\\n}  // namespace palindrome_partitioning\\n}  // namespace dynamic_programming\\n\\n/**\\n * @brief Test Function\\n * @return void\\n */\\nstatic void test() {\\n    // custom input vector\\n    std::vector<std::string> custom_input{\\\"nitik\\\", \\\"ababbbabbababa\\\", \\\"abdc\\\"};\\n\\n    // calculated output vector by pal_part Function\\n    std::vector<int> calculated_output(3);\\n\\n    for (int i = 0; i < 3; i++) {\\n        calculated_output[i] =\\n            dynamic_programming::palindrome_partitioning::pal_part(\\n                custom_input[i]);\\n    }\\n\\n    // expected output vector\\n    std::vector<int> expected_output{2, 3, 3};\\n\\n    // Testing implementation via assert function\\n    // It will throw error if any of the expected test fails\\n    // Else it will give nothing\\n    for (int i = 0; i < 3; i++) {\\n        assert(expected_output[i] == calculated_output[i]);\\n    }\\n\\n    std::cout << \\\"All tests passed successfully!\\\\n\\\";\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // execute the test\\n    return 0;\\n}\\n\"",
    "partition problem": "\"/******************************************************************************\\n * @file\\n * @brief Implementation of the [Partition\\n * Problem](https://en.wikipedia.org/wiki/Partition_problem )\\n * @details\\n * The partition problem, or number partitioning, is the task of deciding\\n * whether a given multiset S of positive integers can be partitioned into two\\n * subsets S1 and S2 such that the sum of the numbers in S1 equals the sum of\\n * the numbers in S2. Although the partition problem is NP-complete, there is a\\n * pseudo-polynomial time dynamic programming solution, and there are heuristics\\n * that solve the problem in many instances, either optimally or approximately.\\n * For this reason, it has been called \\\"the easiest hard problem\\\".\\n *\\n * The worst case time complexity of Jarvis’s Algorithm is O(n^2). Using\\n * Graham’s scan algorithm, we can find Convex Hull in O(nLogn) time.\\n *\\n * ### Implementation\\n *\\n * Step 1\\n * Calculate sum of the array. If sum is odd, there can not be two subsets with\\n * equal sum, so return false.\\n *\\n * Step 2\\n * If sum of array elements is even, calculate sum/2 and find a subset of array\\n * with sum equal to sum/2.\\n *\\n * @author [Lajat Manekar](https://github.com/Lazeeez)\\n *\\n *******************************************************************************/\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO Operations\\n#include <numeric>   /// for std::accumulate\\n#include <vector>    /// for std::vector\\n\\n/******************************************************************************\\n * @namespace dp\\n * @brief Dynamic programming algorithms\\n *******************************************************************************/\\nnamespace dp {\\n\\n/******************************************************************************\\n * @namespace partitionProblem\\n * @brief Partition problem algorithm\\n *******************************************************************************/\\nnamespace partitionProblem {\\n\\n/******************************************************************************\\n * @brief Returns true if arr can be partitioned in two subsets of equal sum,\\n * otherwise false\\n * @param arr vector containing elements\\n * @param size Size of the vector.\\n * @returns @param bool whether the vector can be partitioned or not.\\n *******************************************************************************/\\nbool findPartiion(const std::vector<uint64_t> &arr, uint64_t size) {\\n    uint64_t sum = std::accumulate(arr.begin(), arr.end(),\\n                                   0);  // Calculate sum of all elements\\n\\n    if (sum % 2 != 0) {\\n        return false;  // if sum is odd, it cannot be divided into two equal sum\\n    }\\n    std::vector<bool> part;\\n    // bool part[sum / 2 + 1];\\n\\n    // Initialize the part array as 0\\n    for (uint64_t it = 0; it <= sum / 2; ++it) {\\n        part.push_back(false);\\n    }\\n\\n    // Fill the partition table in bottom up manner\\n    for (uint64_t it = 0; it < size; ++it) {\\n        // The element to be included in the sum cannot be greater than the sum\\n        for (uint64_t it2 = sum / 2; it2 >= arr[it];\\n             --it2) {  // Check if sum - arr[i]\\n            // ould be formed from a subset using elements before index i\\n            if (part[it2 - arr[it]] == 1 || it2 == arr[it]) {\\n                part[it2] = true;\\n            }\\n        }\\n    }\\n    return part[sum / 2];\\n}\\n}  // namespace partitionProblem\\n}  // namespace dp\\n\\n/*******************************************************************************\\n * @brief Self-test implementations\\n * @returns void\\n *******************************************************************************/\\nstatic void test() {\\n    std::vector<uint64_t> arr = {{1, 3, 3, 2, 3, 2}};\\n    uint64_t n = arr.size();\\n    bool expected_result = true;\\n    bool derived_result = dp::partitionProblem::findPartiion(arr, n);\\n    std::cout << \\\"1st test: \\\";\\n    assert(expected_result == derived_result);\\n    std::cout << \\\"Passed!\\\" << std::endl;\\n}\\n\\n/*******************************************************************************\\n * @brief Main function\\n * @returns 0 on exit\\n *******************************************************************************/\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "searching of element in dynamic array": "\"/*\\n *this program is use to find any elemet in any row with variable array size\\n *aplication of pointer is use in it\\n *important point start from here to:\\n *the index value of array can be go to 1 to 100000\\n *check till array[1000]\\n *end here\\n *how to work example:\\n **Question:\\n ***number of array 2\\n ***quarry 3\\n ***array 1 is {1 2 3 4 5}\\n ***array 2 is {6 7}\\n ****i) what is 2nd element in 1st array\\n ****ii) what is 1st element in 2nd array\\n ****iii) what is 5th element in 1st array\\n *****output:\\n *****Enter Number of array you want to Store : 2\\n *****Enter Number of Question or Quary you want to do Related to Array : 3\\n *****Enter number of element in 1 rows : 5\\n *****Enter the element of Array 1 2 3 4 5\\n *****Enter number of element in 2 rows : 2\\n *****Enter the element of Array 6 7\\n *****enter the number of row which element You want to find : 1\\n *****enter the position of element which You want to find : 2\\n *****The element is 2\\n *****enter the number of row which element You want to find : 2\\n *****enter the position of element which You want to find : 1\\n *****The element is 6\\n *****enter the number of row which element You want to find : 1\\n *****enter the position of element which You want to find : 5\\n *****The element is 5\\n */\\n#include <iostream>\\n\\n// this is main fuction\\n// ***\\nint main() {\\n    int64_t r, mr = 0, x, q, i, z;\\n    std::cout << \\\"Enter Number of array you want to Store :\\\";\\n    std::cin >> x;\\n    std::cout << \\\"Enter Number of \\\";\\n    std::cout << \\\"Question or Quary you \\\";\\n    std::cout << \\\"want to do Related to Array :\\\";\\n    std::cin >> q;\\n    // create a Array in run time because use can\\n    // change the size of each array which he/she is going to store\\n    // create a 2D array\\n    int** ar = new int*[x]();\\n    // this for loop is use for entering different variable size array\\n    // ***\\n    for (r = 0; r < x; r++) {\\n        std::cout << \\\"Enter number of element in \\\" << r + 1 << \\\" rows :\\\";\\n        std::cin >> mr;\\n        // creating a 1D array\\n        int* ac = new int[mr]();\\n        std::cout << \\\"Enter the element of Array \\\";\\n        // this for loop is use for storing values in array\\n        // ***\\n        for (i = 0; i < mr; i++) {\\n            // entering the value of rows in array in Horizontal\\n            std::cin >> ac[i];\\n        }\\n        // Change the position of Array so that new arrays entery will be done\\n        ar[r] = ac;\\n    }\\n    // this for loop is use for display result of querry\\n    // ***\\n    for (z = 0; z < q; z++) {\\n        int64_t r1 = 0, q1 = 0;\\n        std::cout << \\\"enter the number of row which element you want to find :\\\";\\n        std::cin >> r1;\\n        r1 = r1 - 1;\\n        std::cout << \\\"enter the position of element which you want to find :\\\";\\n        std::cin >> q1;\\n        q1 = q1 - 1;\\n        // use this to find desire position of element in desire array\\n        std::cout << \\\"The element is \\\" << ar[r1][q1] << std::endl;\\n    }\\n}\\n\"",
    "shortest common supersequence": "\"/**\\n * @file\\n * @brief SCS is a string Z which is the shortest supersequence of strings X and Y (may not be continuous in Z, but order is maintained).\\n *\\n * @details\\n * The idea is to use lookup table method as used in LCS.\\n * For example: example 1:-\\n * X: 'ABCXYZ', Y: 'ABZ' then Z will be 'ABCXYZ' (y is not continuous but in order)\\n * \\n * For example: example 2:-\\n * X: 'AGGTAB', Y: 'GXTXAYB' then Z will be 'AGGXTXAYB'\\n * @author [Ridhish Jain](https://github.com/ridhishjain)\\n * @see more on [SCS](https://en.wikipedia.org/wiki/Shortest_common_supersequence_problem)\\n * @see related problem [Leetcode](https://leetcode.com/problems/shortest-common-supersequence/)\\n*/\\n\\n// header files\\n#include <iostream>\\n#include <string>\\n#include <vector>\\n#include <algorithm>\\n#include <cassert>\\n\\n/**\\n * @namespace dynamic_programming\\n * @brief Dynamic Programming algorithms\\n*/\\nnamespace dynamic_programming {\\n\\n    /**\\n    * @namespace shortest_common_supersequence\\n    * @brief Shortest Common Super Sequence algorithm\\n    */\\n    namespace shortest_common_supersequence {\\n        \\n        /**\\n         * Function implementing Shortest Common Super-Sequence algorithm using look-up table method.\\n         * @param str1 first string 'X'\\n         * @param str2 second string 'Y'\\n         * @returns string 'Z', superSequence of X and Y \\n        */\\n        std::string scs(const std::string &str1, const std::string &str2) {\\n\\n            // Edge cases\\n            // If either str1 or str2 or both are empty\\n            if(str1.empty() && str2.empty()) {\\n                return \\\"\\\";\\n            }\\n            else if(str1.empty()) {\\n                return str2;\\n            }\\n            else if(str2.empty()) {\\n                return str1;\\n            }\\n\\n            // creating lookup table\\n            std::vector <std::vector <int>> lookup(str1.length() + 1, std::vector <int> (str2.length() + 1, 0));\\n      \\n            for(int i=1; i <= str1.length(); i++) {\\n                for(int j=1; j <= str2.length(); j++) {\\n                    if(str1[i-1] == str2[j-1]) {\\n                        lookup[i][j] = lookup[i-1][j-1] + 1;\\n                    }\\n                    else {\\n                        lookup[i][j] = std::max(lookup[i-1][j], lookup[i][j-1]);\\n                    }\\n                }\\n            }\\n\\n            // making supersequence\\n            // i and j are initially pointed towards end of strings\\n            // Super-sequence will be constructed backwards\\n            int i=str1.length();\\n            int j=str2.length();\\n            std::string s;\\n      \\n            while(i>0 && j>0) {\\n\\n                // If the characters at i and j of both strings are same\\n                // We only need to add them once in s\\n                if(str1[i-1] == str2[j-1]) {\\n                    s.push_back(str1[i-1]);\\n                    i--;\\n                    j--;\\n                }\\n                // otherwise we check lookup table for recurrences of characters\\n                else {\\n                    if(lookup[i-1][j] > lookup[i][j-1]) {\\n                        s.push_back(str1[i-1]);\\n                        i--;\\n                    }\\n                    else {\\n                        s.push_back(str2[j-1]);\\n                        j--;\\n                    }\\n                }\\n            }\\n\\n            // copying remaining elements\\n            // if j becomes 0 before i\\n            while(i > 0) {\\n                s.push_back(str1[i-1]);\\n                i--;\\n            }\\n\\n            // if i becomes 0 before j\\n            while(j > 0) {\\n                s.push_back(str2[j-1]);\\n                j--;\\n            }\\n\\n            // As the super sequence is constructd backwards\\n            // reversing the string before returning gives us the correct output  \\n            reverse(s.begin(), s.end());\\n            return s;\\n        }\\n    } // namespace shortest_common_supersequence\\n} // namespace dynamic_programming\\n\\n/** \\n * Test Function\\n * @return void \\n*/\\nstatic void test() {\\n    // custom input vector\\n    std::vector <std::vector <std::string>> scsStrings {\\n        {\\\"ABCXYZ\\\", \\\"ABZ\\\"},\\n        {\\\"ABZ\\\", \\\"ABCXYZ\\\"},\\n        {\\\"AGGTAB\\\", \\\"GXTXAYB\\\"},\\n        {\\\"X\\\", \\\"Y\\\"},\\n    };\\n\\n    // calculated output vector by scs function\\n    std::vector <std::string> calculatedOutput(4, \\\"\\\");\\n    int i=0;\\n    for(auto & scsString : scsStrings) {\\n        \\n        calculatedOutput[i] = dynamic_programming::shortest_common_supersequence::scs(\\n            scsString[0], scsString[1]\\n        );\\n        i++;\\n    }\\n\\n    // expected output vector acc to problem statement\\n    std::vector <std::string> expectedOutput {\\n        \\\"ABCXYZ\\\",\\n        \\\"ABCXYZ\\\",\\n        \\\"AGGXTXAYB\\\",\\n        \\\"XY\\\"\\n    };\\n\\n    // Testing implementation via assert function\\n    // It will throw error if any of the expected test fails\\n    // Else it will give nothing\\n    for(int i=0; i < scsStrings.size(); i++) {\\n        assert(expectedOutput[i] == calculatedOutput[i]);\\n    }\\n\\n    std::cout << \\\"All tests passed successfully!\\\\n\\\";\\n    return;\\n}\\n\\n/** Main function (driver code)*/\\nint main() {\\n    // test for implementation\\n    test();\\n\\n    // user input\\n    std::string s1, s2;\\n    std::cin >> s1;\\n    std::cin >> s2;\\n\\n    std::string ans;\\n\\n    // user output\\n    ans = dynamic_programming::shortest_common_supersequence::scs(s1, s2);\\n    std::cout << ans;\\n    return 0;\\n}\\n\"",
    "tree height": "\"// C++ Program to find height of the tree using bottom-up dynamic programming.\\n\\n/*\\n * Given a rooted tree with node 1.\\n * Task is to find the height of the tree.\\n * Example: -\\n * 4\\n * 1 2\\n * 1 3\\n * 2 4\\n * which can be represented as\\n *   1\\n *  / \\\\\\n * 2   3\\n * |\\n * 4\\n *\\n * Height of the tree : - 2\\n */\\n\\n#include <iostream>\\n#include <vector>\\n\\n// global declarations\\n// no of nodes max limit.\\nconst int MAX = 1e5;\\n// adjacency list\\nstd::vector<int> adj[MAX];\\nstd::vector<bool> visited;\\nstd::vector<int> dp;\\n\\nvoid depth_first_search(int u) {\\n    visited[u] = true;\\n    int child_height = 1;\\n    for (int v : adj[u]) {\\n        if (!visited[v]) {\\n            depth_first_search(v);\\n\\n            // select maximum sub-tree height from all children.\\n            child_height = std::max(child_height, dp[v] + 1);\\n        }\\n    }\\n    // assigned the max child height to current visited node.\\n    dp[u] = child_height;\\n}\\n\\nint main() {\\n    // number of nodes\\n    int number_of_nodes;\\n    std::cout << \\\"Enter number of nodes of the tree : \\\" << std::endl;\\n    std::cin >> number_of_nodes;\\n\\n    // u, v denotes an undirected edge of tree.\\n    int u, v;\\n    // Tree contains exactly n-1 edges where n denotes the number of nodes.\\n    std::cout << \\\"Enter edges of the tree : \\\" << std::endl;\\n    for (int i = 0; i < number_of_nodes - 1; i++) {\\n        std::cin >> u >> v;\\n        // undirected tree u -> v and v -> u.\\n        adj[u].push_back(v);\\n        adj[v].push_back(u);\\n    }\\n    // initialize all nodes as unvisited.\\n    visited.assign(number_of_nodes + 1, false);\\n    // initialize depth of all nodes to 0.\\n    dp.assign(number_of_nodes + 1, 0);\\n    // function call which will initialize the height of all nodes.\\n    depth_first_search(1);\\n    std::cout << \\\"Height of the Tree : \\\" << dp[1] << std::endl;\\n}\\n\"",
    "word break": "\"/**\\n * @file\\n * @brief [Word Break Problem](https://leetcode.com/problems/word-break/)\\n * @details\\n * Given a non-empty string s and a dictionary wordDict containing a list of\\n * non-empty words, determine if s can be segmented into a space-separated\\n * sequence of one or more dictionary words.\\n *\\n * Note:\\n * The same word in the dictionary may be reused multiple times in the\\n * segmentation. You may assume the dictionary does not contain duplicate words.\\n *\\n * Example 1:\\n * Input: s = \\\"leetcode\\\", wordDict = [\\\"leet\\\", \\\"code\\\"]\\n * Output: true\\n * Explanation: Return true because \\\"leetcode\\\" can be segmented as \\\"leet code\\\".\\n *\\n * Example 2:\\n * Input: s = \\\"applepenapple\\\", wordDict = [\\\"apple\\\", \\\"pen\\\"]\\n * Output: true\\n * Explanation: Return true because \\\"applepenapple\\\" can be segmented as \\\"apple\\n * pen apple\\\". Note that you are allowed to reuse a dictionary word.\\n *\\n * Example 3:\\n * Input: s = \\\"catsandog\\\", wordDict = [\\\"cats\\\", \\\"dog\\\", \\\"sand\\\", \\\"and\\\", \\\"cat\\\"]\\n * Output: false\\n *\\n * @author [Akshay Anand] (https://github.com/axayjha)\\n */\\n\\n#include <cassert>\\n#include <climits>\\n#include <iostream>\\n#include <string>\\n#include <unordered_set>\\n#include <vector>\\n\\n/**\\n * @namespace dynamic_programming\\n * @brief Dynamic programming algorithms\\n */\\nnamespace dynamic_programming {\\n\\n/**\\n * @namespace word_break\\n * @brief Functions for [Word Break](https://leetcode.com/problems/word-break/)\\n * problem\\n */\\nnamespace word_break {\\n\\n/**\\n * @brief Function that checks if the string passed in param is present in\\n * the the unordered_set passed\\n *\\n * @param str the string to be searched\\n * @param strSet unordered set of string, that is to be looked into\\n * @returns `true` if str is present in strSet\\n * @returns `false` if str is not present in strSet\\n */\\nbool exists(const std::string &str,\\n            const std::unordered_set<std::string> &strSet) {\\n    return strSet.find(str) != strSet.end();\\n}\\n\\n/**\\n * @brief Function that checks if the string passed in param can be\\n * segmented from position 'pos', and then correctly go on to segment the\\n * rest of the string correctly as well to reach a solution\\n *\\n * @param s the complete string to be segmented\\n * @param strSet unordered set of string, that is to be used as the\\n * reference dictionary\\n * @param pos the index value at which we will segment string and test\\n * further if it is correctly segmented at pos\\n * @param dp the vector to memoize solution for each position\\n * @returns `true` if a valid solution/segmentation is possible by segmenting at\\n * index pos\\n * @returns `false` otherwise\\n */\\nbool check(const std::string &s, const std::unordered_set<std::string> &strSet,\\n           int pos, std::vector<int> *dp) {\\n    if (pos == s.length()) {\\n        // if we have reached till the end of the string, means we have\\n        // segmented throughout correctly hence we have a solution, thus\\n        // returning true\\n        return true;\\n    }\\n\\n    if (dp->at(pos) != INT_MAX) {\\n        // if dp[pos] is not INT_MAX, means we must have saved a solution\\n        // for the position pos; then return if the solution at pos is true\\n        // or not\\n        return dp->at(pos) == 1;\\n    }\\n\\n    std::string wordTillNow =\\n        \\\"\\\";  // string to save the prefixes of word till different positons\\n\\n    for (int i = pos; i < s.length(); i++) {\\n        // Loop starting from pos to end, to check valid set of\\n        // segmentations if any\\n        wordTillNow +=\\n            std::string(1, s[i]);  // storing the prefix till the position i\\n\\n        // if the prefix till current position is present in the dictionary\\n        // and the remaining substring can also be segmented legally, then\\n        // set solution at position pos in the memo, and return true\\n        if (exists(wordTillNow, strSet) and check(s, strSet, i + 1, dp)) {\\n            dp->at(pos) = 1;\\n            return true;\\n        }\\n    }\\n    // if function has still not returned, then there must be no legal\\n    // segmentation possible after segmenting at pos\\n    dp->at(pos) = 0;  // so set solution at pos as false\\n    return false;     // and return no solution at position pos\\n}\\n\\n/**\\n * @brief Function that checks if the string passed in param can be\\n * segmented into the strings present in the vector.\\n * In others words, it checks if any permutation of strings in\\n * the vector can be concatenated to form the final string.\\n *\\n * @param s the complete string to be segmented\\n * @param wordDict a vector of words to be used as dictionary to look into\\n * @returns `true` if s can be formed by a combination of strings present in\\n * wordDict\\n * @return `false` otherwise\\n */\\nbool wordBreak(const std::string &s, const std::vector<std::string> &wordDict) {\\n    // unordered set to store words in the dictionary for constant time\\n    // search\\n    std::unordered_set<std::string> strSet;\\n    for (const auto &s : wordDict) {\\n        strSet.insert(s);\\n    }\\n    // a vector to be used for memoization, whose value at index i will\\n    // tell if the string s can be segmented (correctly) at position i.\\n    // initializing it with INT_MAX (which will denote no solution)\\n    std::vector<int> dp(s.length(), INT_MAX);\\n\\n    // calling check method with position = 0, to check from left\\n    // from where can be start segmenting the complete string in correct\\n    // manner\\n    return check(s, strSet, 0, &dp);\\n}\\n\\n}  // namespace word_break\\n}  // namespace dynamic_programming\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // the complete string\\n    const std::string s = \\\"applepenapple\\\";\\n    // the dictionary to be used\\n    const std::vector<std::string> wordDict = {\\\"apple\\\", \\\"pen\\\"};\\n\\n    assert(dynamic_programming::word_break::wordBreak(s, wordDict));\\n\\n    // should return true, as applepenapple can be segmented as apple + pen +\\n    // apple\\n    std::cout << dynamic_programming::word_break::wordBreak(s, wordDict)\\n              << std::endl;\\n    std::cout << \\\"Test implementation passed!\\\\n\\\";\\n}\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // call the test function :)\\n\\n    // the complete string\\n    const std::string s = \\\"applepenapple\\\";\\n    // the dictionary to be used\\n    const std::vector<std::string> wordDict = {\\\"apple\\\", \\\"pen\\\"};\\n\\n    // should return true, as applepenapple can be segmented as apple + pen +\\n    // apple\\n    std::cout << dynamic_programming::word_break::wordBreak(s, wordDict)\\n              << std::endl;\\n}\\n\"",
    "graham scan algorithm": "\"/******************************************************************************\\n * @file\\n * @brief Implementation of the [Convex\\n * Hull](https://en.wikipedia.org/wiki/Convex_hull) implementation using [Graham\\n * Scan](https://en.wikipedia.org/wiki/Graham_scan)\\n * @details\\n * In geometry, the convex hull or convex envelope or convex closure of a shape\\n * is the smallest convex set that contains it. The convex hull may be defined\\n * either as the intersection of all convex sets containing a given subset of a\\n * Euclidean space, or equivalently as the set of all convex combinations of\\n * points in the subset. For a bounded subset of the plane, the convex hull may\\n * be visualized as the shape enclosed by a rubber band stretched around the\\n * subset.\\n *\\n * The worst case time complexity of Jarvis’s Algorithm is O(n^2). Using\\n * Graham’s scan algorithm, we can find Convex Hull in O(nLogn) time.\\n *\\n * ### Implementation\\n *\\n * Sort points\\n * We first find the bottom-most point. The idea is to pre-process\\n * points be sorting them with respect to the bottom-most point. Once the points\\n * are sorted, they form a simple closed path.\\n * The sorting criteria is to use the orientation to compare angles without\\n * actually computing them (See the compare() function below) because\\n * computation of actual angles would be inefficient since trigonometric\\n * functions are not simple to evaluate.\\n *\\n * Accept or Reject Points\\n * Once we have the closed path, the next step is to traverse the path and\\n * remove concave points on this path using orientation. The first two points in\\n * sorted array are always part of Convex Hull. For remaining points, we keep\\n * track of recent three points, and find the angle formed by them. Let the\\n * three points be prev(p), curr(c) and next(n). If the orientation of these\\n * points (considering them in the same order) is not counterclockwise, we\\n * discard c, otherwise we keep it.\\n *\\n * @author [Lajat Manekar](https://github.com/Lazeeez)\\n *\\n *******************************************************************************/\\n#include <cassert>   /// for std::assert\\n#include <iostream>  /// for IO Operations\\n#include <vector>    /// for std::vector\\n\\n#include \\\"./graham_scan_functions.hpp\\\"  /// for all the functions used\\n\\n/*******************************************************************************\\n * @brief Self-test implementations\\n * @returns void\\n *******************************************************************************/\\nstatic void test() {\\n    std::vector<geometry::grahamscan::Point> points = {\\n        {0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}};\\n    std::vector<geometry::grahamscan::Point> expected_result = {\\n        {0, 3}, {4, 4}, {3, 1}, {0, 0}};\\n    std::vector<geometry::grahamscan::Point> derived_result;\\n    std::vector<geometry::grahamscan::Point> res;\\n\\n    derived_result = geometry::grahamscan::convexHull(points, points.size());\\n\\n    std::cout << \\\"1st test: \\\";\\n    for (int i = 0; i < expected_result.size(); i++) {\\n        assert(derived_result[i].x == expected_result[i].x);\\n        assert(derived_result[i].y == expected_result[i].y);\\n    }\\n    std::cout << \\\"passed!\\\" << std::endl;\\n}\\n\\n/*******************************************************************************\\n * @brief Main function\\n * @returns 0 on exit\\n *******************************************************************************/\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "graham scan functions": "\"/******************************************************************************\\n * @file\\n * @brief Implementation of the [Convex\\n * Hull](https://en.wikipedia.org/wiki/Convex_hull) implementation using [Graham\\n * Scan](https://en.wikipedia.org/wiki/Graham_scan)\\n * @details\\n * In geometry, the convex hull or convex envelope or convex closure of a shape\\n * is the smallest convex set that contains it. The convex hull may be defined\\n * either as the intersection of all convex sets containing a given subset of a\\n * Euclidean space, or equivalently as the set of all convex combinations of\\n * points in the subset. For a bounded subset of the plane, the convex hull may\\n * be visualized as the shape enclosed by a rubber band stretched around the\\n * subset.\\n *\\n * The worst case time complexity of Jarvis’s Algorithm is O(n^2). Using\\n * Graham’s scan algorithm, we can find Convex Hull in O(nLogn) time.\\n *\\n * ### Implementation\\n *\\n * Sort points\\n * We first find the bottom-most point. The idea is to pre-process\\n * points be sorting them with respect to the bottom-most point. Once the points\\n * are sorted, they form a simple closed path.\\n * The sorting criteria is to use the orientation to compare angles without\\n * actually computing them (See the compare() function below) because\\n * computation of actual angles would be inefficient since trigonometric\\n * functions are not simple to evaluate.\\n *\\n * Accept or Reject Points\\n * Once we have the closed path, the next step is to traverse the path and\\n * remove concave points on this path using orientation. The first two points in\\n * sorted array are always part of Convex Hull. For remaining points, we keep\\n * track of recent three points, and find the angle formed by them. Let the\\n * three points be prev(p), curr(c) and next(n). If orientation of these points\\n * (considering them in same order) is not counterclockwise, we discard c,\\n * otherwise we keep it.\\n *\\n * @author [Lajat Manekar](https://github.com/Lazeeez)\\n *\\n *******************************************************************************/\\n#include <algorithm>  /// for std::swap\\n#include <cstdlib>    /// for mathematics and datatype conversion\\n#include <iostream>   /// for IO operations\\n#include <stack>      /// for std::stack\\n#include <vector>     /// for std::vector\\n\\n/******************************************************************************\\n * @namespace geometry\\n * @brief geometric algorithms\\n *******************************************************************************/\\nnamespace geometry {\\n\\n/******************************************************************************\\n * @namespace graham scan\\n * @brief convex hull algorithm\\n *******************************************************************************/\\nnamespace grahamscan {\\n\\n/******************************************************************************\\n * @struct Point\\n * @brief for X and Y co-ordinates of the co-ordinate.\\n *******************************************************************************/\\nstruct Point {\\n    int x, y;\\n};\\n\\n// A global point needed for sorting points with reference\\n// to  the first point Used in compare function of qsort()\\n\\nPoint p0;\\n\\n/******************************************************************************\\n * @brief A utility function to find next to top in a stack.\\n * @param S Stack to be used for the process.\\n * @returns @param Point Co-ordinates of the Point <int, int>\\n *******************************************************************************/\\nPoint nextToTop(std::stack<Point> *S) {\\n    Point p = S->top();\\n    S->pop();\\n    Point res = S->top();\\n    S->push(p);\\n    return res;\\n}\\n\\n/******************************************************************************\\n * @brief A utility function to return square of distance between p1 and p2.\\n * @param p1 Co-ordinates of Point 1 <int, int>.\\n * @param p2 Co-ordinates of Point 2 <int, int>.\\n * @returns @param int distance between p1 and p2.\\n *******************************************************************************/\\nint distSq(Point p1, Point p2) {\\n    return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\\n}\\n\\n/******************************************************************************\\n * @brief To find orientation of ordered triplet (p, q, r).\\n * @param p Co-ordinates of Point p <int, int>.\\n * @param q Co-ordinates of Point q <int, int>.\\n * @param r Co-ordinates of Point r <int, int>.\\n * @returns @param int 0 --> p, q and r are collinear, 1 --> Clockwise,\\n * 2 --> Counterclockwise\\n *******************************************************************************/\\nint orientation(Point p, Point q, Point r) {\\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n\\n    if (val == 0) {\\n        return 0;  // collinear\\n    }\\n    return (val > 0) ? 1 : 2;  // clock or counter-clock wise\\n}\\n\\n/******************************************************************************\\n * @brief A function used by library function qsort() to sort an array of\\n * points with respect to the first point\\n * @param vp1 Co-ordinates of Point 1 <int, int>.\\n * @param vp2 Co-ordinates of Point 2 <int, int>.\\n * @returns @param int distance between p1 and p2.\\n *******************************************************************************/\\nint compare(const void *vp1, const void *vp2) {\\n    auto *p1 = static_cast<const Point *>(vp1);\\n    auto *p2 = static_cast<const Point *>(vp2);\\n\\n    // Find orientation\\n    int o = orientation(p0, *p1, *p2);\\n    if (o == 0) {\\n        return (distSq(p0, *p2) >= distSq(p0, *p1)) ? -1 : 1;\\n    }\\n\\n    return (o == 2) ? -1 : 1;\\n}\\n\\n/******************************************************************************\\n * @brief Prints convex hull of a set of n points.\\n * @param points vector of Point<int, int> with co-ordinates.\\n * @param size Size of the vector.\\n * @returns @param vector vector of Conver Hull.\\n *******************************************************************************/\\nstd::vector<Point> convexHull(std::vector<Point> points, uint64_t size) {\\n    // Find the bottom-most point\\n    int ymin = points[0].y, min = 0;\\n    for (int i = 1; i < size; i++) {\\n        int y = points[i].y;\\n\\n        // Pick the bottom-most or chose the left-most point in case of tie\\n        if ((y < ymin) || (ymin == y && points[i].x < points[min].x)) {\\n            ymin = points[i].y, min = i;\\n        }\\n    }\\n\\n    // Place the bottom-most point at first position\\n    std::swap(points[0], points[min]);\\n\\n    // Sort n-1 points with respect to the first point. A point p1 comes\\n    // before p2 in sorted output if p2 has larger polar angle\\n    // (in counterclockwise direction) than p1.\\n    p0 = points[0];\\n    qsort(&points[1], size - 1, sizeof(Point), compare);\\n\\n    // If two or more points make same angle with p0, Remove all but the one\\n    // that is farthest from p0 Remember that, in above sorting, our criteria\\n    // was to keep the farthest point at the end when more than one points have\\n    // same angle.\\n    int m = 1;  // Initialize size of modified array\\n    for (int i = 1; i < size; i++) {\\n        // Keep removing i while angle of i and i+1 is same with respect to p0\\n        while (i < size - 1 && orientation(p0, points[i], points[i + 1]) == 0) {\\n            i++;\\n        }\\n\\n        points[m] = points[i];\\n        m++;  // Update size of modified array\\n    }\\n\\n    // If modified array of points has less than 3 points, convex hull is not\\n    // possible\\n    if (m < 3) {\\n        return {};\\n    };\\n\\n    // Create an empty stack and push first three points to it.\\n    std::stack<Point> St;\\n    St.push(points[0]);\\n    St.push(points[1]);\\n    St.push(points[2]);\\n\\n    // Process remaining n-3 points\\n    for (int i = 3; i < m; i++) {\\n        // Keep removing top while the angle formed by\\n        // points next-to-top, top, and points[i] makes\\n        // a non-left turn\\n        while (St.size() > 1 &&\\n               orientation(nextToTop(&St), St.top(), points[i]) != 2) {\\n            St.pop();\\n        }\\n        St.push(points[i]);\\n    }\\n\\n    std::vector<Point> result;\\n    // Now stack has the output points, push them into the resultant vector\\n    while (!St.empty()) {\\n        Point p = St.top();\\n        result.push_back(p);\\n        St.pop();\\n    }\\n\\n    return result;  // return resultant vector with Convex Hull co-ordinates.\\n}\\n}  // namespace grahamscan\\n}  // namespace geometry\\n\"",
    "jarvis algorithm": "\"/**\\n * @file\\n * @brief Implementation of [Jarvis’s](https://en.wikipedia.org/wiki/Gift_wrapping_algorithm) algorithm.\\n *\\n * @details\\n * Given a set of points in the plane. the convex hull of the set\\n * is the smallest convex polygon that contains all the points of it.\\n *\\n * ### Algorithm\\n * The idea of Jarvis’s Algorithm is simple, we start from the leftmost point\\n * (or point with minimum x coordinate value) and we\\n * keep wrapping points in counterclockwise direction.\\n *\\n * The idea is to use orientation() here. Next point is selected as the\\n * point that beats all other points at counterclockwise orientation, i.e.,\\n * next point is q if for any other point r,\\n * we have “orientation(p, q, r) = counterclockwise”.\\n *\\n * For Example,\\n * If points = {{0, 3}, {2, 2}, {1, 1}, {2, 1},\\n                      {3, 0}, {0, 0}, {3, 3}};\\n *\\n * then the convex hull is\\n * (0, 3), (0, 0), (3, 0), (3, 3)\\n *\\n * @author [Rishabh Agarwal](https://github.com/rishabh-997)\\n */\\n\\n#include <vector>\\n#include <cassert>\\n#include <iostream>\\n\\n/**\\n *  @namespace geometry\\n *  @brief Geometry algorithms\\n */\\nnamespace geometry {\\n    /**\\n     * @namespace jarvis\\n     * @brief Functions for [Jarvis’s](https://en.wikipedia.org/wiki/Gift_wrapping_algorithm) algorithm\\n     */\\n    namespace jarvis {\\n        /**\\n         * Structure defining the x and y co-ordinates of the given\\n         * point in space\\n         */\\n        struct Point {\\n            int x, y;\\n        };\\n\\n        /**\\n         * Class which can be called from main and is globally available\\n         * throughout the code\\n         */\\n        class Convexhull {\\n            std::vector<Point> points;\\n            int size;\\n\\n        public:\\n            /**\\n             * Constructor of given class\\n             *\\n             * @param pointList list of all points in the space\\n             * @param n number of points in space\\n             */\\n            explicit Convexhull(const std::vector<Point> &pointList) {\\n                points = pointList;\\n                size = points.size();\\n            }\\n\\n            /**\\n             * Creates convex hull of a set of n points.\\n             * There must be 3 points at least for the convex hull to exist\\n             *\\n             * @returns an vector array containing points in space\\n             * which enclose all given points thus forming a hull\\n             */\\n            std::vector<Point> getConvexHull() const {\\n                // Initialize Result\\n                std::vector<Point> hull;\\n\\n                // Find the leftmost point\\n                int leftmost_point = 0;\\n                for (int i = 1; i < size; i++) {\\n                    if (points[i].x < points[leftmost_point].x) {\\n                        leftmost_point = i;\\n                    }\\n                }\\n                // Start from leftmost point, keep moving counterclockwise\\n                // until reach the start point again.  This loop runs O(h)\\n                // times where h is number of points in result or output.\\n                int p = leftmost_point, q = 0;\\n                do {\\n                    // Add current point to result\\n                    hull.push_back(points[p]);\\n\\n                    // Search for a point 'q' such that orientation(p, x, q)\\n                    // is counterclockwise for all points 'x'. The idea\\n                    // is to keep track of last visited most counter clock-\\n                    // wise point in q. If any point 'i' is more counter clock-\\n                    // wise than q, then update q.\\n                    q = (p + 1) % size;\\n                    for (int i = 0; i < size; i++) {\\n                        // If i is more counterclockwise than current q, then\\n                        // update q\\n                        if (orientation(points[p], points[i], points[q]) == 2) {\\n                            q = i;\\n                        }\\n                    }\\n\\n                    // Now q is the most counterclockwise with respect to p\\n                    // Set p as q for next iteration, so that q is added to\\n                    // result 'hull'\\n                    p = q;\\n\\n                } while (p != leftmost_point);        // While we don't come to first point\\n\\n                return hull;\\n            }\\n\\n            /**\\n             * This function returns the geometric orientation for the three points\\n             * in a space, ie, whether they are linear ir clockwise or\\n             * anti-clockwise\\n             * @param p first point selected\\n             * @param q adjacent point for q\\n             * @param r adjacent point for q\\n             *\\n             * @returns 0 -> Linear\\n             * @returns 1 -> Clock Wise\\n             * @returns 2 -> Anti Clock Wise\\n             */\\n            static int orientation(const Point &p, const Point &q, const Point &r) {\\n                int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n\\n                if (val == 0) {\\n                    return 0;\\n                }\\n                return (val > 0) ? 1 : 2;\\n            }\\n\\n        };\\n\\n    } // namespace jarvis\\n} // namespace geometry\\n\\n/**\\n * Test function\\n * @returns void\\n */\\nstatic void test() {\\n    std::vector<geometry::jarvis::Point> points = {{0, 3},\\n                                                   {2, 2},\\n                                                   {1, 1},\\n                                                   {2, 1},\\n                                                   {3, 0},\\n                                                   {0, 0},\\n                                                   {3, 3}\\n    };\\n    geometry::jarvis::Convexhull hull(points);\\n    std::vector<geometry::jarvis::Point> actualPoint;\\n    actualPoint = hull.getConvexHull();\\n\\n    std::vector<geometry::jarvis::Point> expectedPoint = {{0, 3},\\n                                                          {0, 0},\\n                                                          {3, 0},\\n                                                          {3, 3}};\\n    for (int i = 0; i < expectedPoint.size(); i++) {\\n        assert(actualPoint[i].x == expectedPoint[i].x);\\n        assert(actualPoint[i].y == expectedPoint[i].y);\\n    }\\n    std::cout << \\\"Test implementations passed!\\\\n\\\";\\n}\\n\\n/** Driver Code */\\nint main() {\\n    test();\\n    return 0;\\n}\\n\"",
    "line segment intersection": "\"/**\\n * @file\\n * @brief check whether two line segments intersect each other\\n * or not.\\n */\\n#include <algorithm>\\n#include <iostream>\\n\\n/**\\n * Define a Point.\\n */\\nstruct Point {\\n    int x;  /// Point respect to x coordinate\\n    int y;  /// Point respect to y coordinate\\n};\\n\\n/**\\n * intersect returns true if segments of two line intersects and\\n * false if they do not. It calls the subroutines direction\\n * which computes the orientation.\\n */\\nstruct SegmentIntersection {\\n    inline bool intersect(Point first_point, Point second_point,\\n                          Point third_point, Point forth_point) {\\n        int direction1 = direction(third_point, forth_point, first_point);\\n        int direction2 = direction(third_point, forth_point, second_point);\\n        int direction3 = direction(first_point, second_point, third_point);\\n        int direction4 = direction(first_point, second_point, forth_point);\\n\\n        if ((direction1 < 0 || direction2 > 0) &&\\n            (direction3 < 0 || direction4 > 0))\\n            return true;\\n\\n        else if (direction1 == 0 &&\\n                 on_segment(third_point, forth_point, first_point))\\n            return true;\\n\\n        else if (direction2 == 0 &&\\n                 on_segment(third_point, forth_point, second_point))\\n            return true;\\n\\n        else if (direction3 == 0 &&\\n                 on_segment(first_point, second_point, third_point))\\n            return true;\\n\\n        else if (direction3 == 0 &&\\n                 on_segment(first_point, second_point, forth_point))\\n            return true;\\n\\n        else\\n            return false;\\n    }\\n\\n    /**\\n     * We will find direction of line here respect to @first_point.\\n     * Here @second_point and @third_point is first and second points\\n     * of the line respectively. we want a method to determine which way a\\n     * given angle these three points turns. If returned number is negative,\\n     * then the angle is counter-clockwise. That means the line is going to\\n     * right to left. We will fount angle as clockwise if the method returns\\n     * positive number.\\n     */\\n    inline int direction(Point first_point, Point second_point,\\n                         Point third_point) {\\n        return ((third_point.x - first_point.x) *\\n                (second_point.y - first_point.y)) -\\n               ((second_point.x - first_point.x) *\\n                (third_point.y - first_point.y));\\n    }\\n\\n    /**\\n     * This method determines whether a point known to be colinear\\n     * with a segment lies on that segment.\\n     */\\n    inline bool on_segment(Point first_point, Point second_point,\\n                           Point third_point) {\\n        if (std::min(first_point.x, second_point.x) <= third_point.x &&\\n            third_point.x <= std::max(first_point.x, second_point.x) &&\\n            std::min(first_point.y, second_point.y) <= third_point.y &&\\n            third_point.y <= std::max(first_point.y, second_point.y))\\n            return true;\\n\\n        else\\n            return false;\\n    }\\n};\\n\\n/**\\n * This is the main function to test whether the algorithm is\\n * working well.\\n */\\nint main() {\\n    SegmentIntersection segment;\\n    Point first_point, second_point, third_point, forth_point;\\n\\n    std::cin >> first_point.x >> first_point.y;\\n    std::cin >> second_point.x >> second_point.y;\\n    std::cin >> third_point.x >> third_point.y;\\n    std::cin >> forth_point.x >> forth_point.y;\\n\\n    printf(\\\"%d\\\", segment.intersect(first_point, second_point, third_point,\\n                                   forth_point));\\n    std::cout << std::endl;\\n}\\n\"",
    "bidirectional dijkstra": "\"/**\\n * @file\\n * @brief [Bidirectional Dijkstra Shortest Path Algorithm]\\n * (https://www.coursera.org/learn/algorithms-on-graphs/lecture/7ml18/bidirectional-dijkstra)\\n *\\n * @author [Marinovksy](http://github.com/Marinovsky)\\n *\\n * @details\\n * This is basically the same Dijkstra Algorithm but faster because it goes from\\n * the source to the target and from target to the source and stops when\\n * finding a vertex visited already by the direct search or the reverse one.\\n * Here some simulations of it:\\n * https://www.youtube.com/watch?v=DINCL5cd_w0&t=24s\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for io operations\\n#include <limits>    /// for variable INF\\n#include <queue>     /// for the priority_queue of distances\\n#include <utility>   /// for make_pair function\\n#include <vector>    /// for store the graph, the distances, and the path\\n\\nconstexpr int64_t INF = std::numeric_limits<int64_t>::max();\\n\\n/**\\n * @namespace graph\\n * @brief Graph Algorithms\\n */\\nnamespace graph {\\n/**\\n * @namespace bidirectional_dijkstra\\n * @brief Functions for [Bidirectional Dijkstra Shortest Path]\\n * (https://www.coursera.org/learn/algorithms-on-graphs/lecture/7ml18/bidirectional-dijkstra)\\n * algorithm\\n */\\nnamespace bidirectional_dijkstra {\\n/**\\n * @brief Function that add edge between two nodes or vertices of graph\\n *\\n * @param adj1 adjacency list for the direct search\\n * @param adj2 adjacency list for the reverse search\\n * @param u any node or vertex of graph\\n * @param v any node or vertex of graph\\n */\\nvoid addEdge(std::vector<std::vector<std::pair<uint64_t, uint64_t>>> *adj1,\\n             std::vector<std::vector<std::pair<uint64_t, uint64_t>>> *adj2,\\n             uint64_t u, uint64_t v, uint64_t w) {\\n    (*adj1)[u - 1].push_back(std::make_pair(v - 1, w));\\n    (*adj2)[v - 1].push_back(std::make_pair(u - 1, w));\\n    // (*adj)[v - 1].push_back(std::make_pair(u - 1, w));\\n}\\n/**\\n * @brief This function returns the shortest distance from the source\\n * to the target if there is path between vertices 's' and 't'.\\n *\\n * @param workset_ vertices visited in the search\\n * @param distance_ vector of distances from the source to the target and\\n * from the target to the source\\n *\\n */\\nuint64_t Shortest_Path_Distance(\\n    const std::vector<uint64_t> &workset_,\\n    const std::vector<std::vector<uint64_t>> &distance_) {\\n    int64_t distance = INF;\\n    for (uint64_t i : workset_) {\\n        if (distance_[0][i] + distance_[1][i] < distance) {\\n            distance = distance_[0][i] + distance_[1][i];\\n        }\\n    }\\n    return distance;\\n}\\n\\n/**\\n * @brief Function runs the dijkstra algorithm for some source vertex and\\n * target vertex in the graph and returns the shortest distance of target\\n * from the source.\\n *\\n * @param adj1 input graph\\n * @param adj2 input graph reversed\\n * @param s source vertex\\n * @param t target vertex\\n *\\n * @return shortest distance if target is reachable from source else -1 in\\n * case if target is not reachable from source.\\n */\\nint Bidijkstra(std::vector<std::vector<std::pair<uint64_t, uint64_t>>> *adj1,\\n               std::vector<std::vector<std::pair<uint64_t, uint64_t>>> *adj2,\\n               uint64_t s, uint64_t t) {\\n    /// n denotes the number of vertices in graph\\n    uint64_t n = adj1->size();\\n\\n    /// setting all the distances initially to INF\\n    std::vector<std::vector<uint64_t>> dist(2, std::vector<uint64_t>(n, INF));\\n\\n    /// creating a a vector of min heap using priority queue\\n    /// pq[0] contains the min heap for the direct search\\n    /// pq[1] contains the min heap for the reverse search\\n\\n    /// first element of pair contains the distance\\n    /// second element of pair contains the vertex\\n    std::vector<\\n        std::priority_queue<std::pair<uint64_t, uint64_t>,\\n                            std::vector<std::pair<uint64_t, uint64_t>>,\\n                            std::greater<std::pair<uint64_t, uint64_t>>>>\\n        pq(2);\\n    /// vector for store the nodes or vertices in the shortest path\\n    std::vector<uint64_t> workset(n);\\n    /// vector for store the nodes or vertices visited\\n    std::vector<bool> visited(n);\\n\\n    /// pushing the source vertex 's' with 0 distance in pq[0] min heap\\n    pq[0].push(std::make_pair(0, s));\\n\\n    /// marking the distance of source as 0\\n    dist[0][s] = 0;\\n\\n    /// pushing the target vertex 't' with 0 distance in pq[1] min heap\\n    pq[1].push(std::make_pair(0, t));\\n\\n    /// marking the distance of target as 0\\n    dist[1][t] = 0;\\n\\n    while (true) {\\n        /// direct search\\n\\n        // If pq[0].size() is equal to zero then the node/ vertex is not\\n        // reachable from s\\n        if (pq[0].size() == 0) {\\n            break;\\n        }\\n        /// second element of pair denotes the node / vertex\\n        uint64_t currentNode = pq[0].top().second;\\n\\n        /// first element of pair denotes the distance\\n        uint64_t currentDist = pq[0].top().first;\\n\\n        pq[0].pop();\\n\\n        /// for all the reachable vertex from the currently exploring vertex\\n        /// we will try to minimize the distance\\n        for (std::pair<int, int> edge : (*adj1)[currentNode]) {\\n            /// minimizing distances\\n            if (currentDist + edge.second < dist[0][edge.first]) {\\n                dist[0][edge.first] = currentDist + edge.second;\\n                pq[0].push(std::make_pair(dist[0][edge.first], edge.first));\\n            }\\n        }\\n        // store the processed node/ vertex\\n        workset.push_back(currentNode);\\n\\n        /// check if currentNode has already been visited\\n        if (visited[currentNode] == 1) {\\n            return Shortest_Path_Distance(workset, dist);\\n        }\\n        visited[currentNode] = true;\\n        /// reversed search\\n\\n        // If pq[1].size() is equal to zero then the node/ vertex is not\\n        // reachable from t\\n        if (pq[1].size() == 0) {\\n            break;\\n        }\\n        /// second element of pair denotes the node / vertex\\n        currentNode = pq[1].top().second;\\n\\n        /// first element of pair denotes the distance\\n        currentDist = pq[1].top().first;\\n\\n        pq[1].pop();\\n\\n        /// for all the reachable vertex from the currently exploring vertex\\n        /// we will try to minimize the distance\\n        for (std::pair<int, int> edge : (*adj2)[currentNode]) {\\n            /// minimizing distances\\n            if (currentDist + edge.second < dist[1][edge.first]) {\\n                dist[1][edge.first] = currentDist + edge.second;\\n                pq[1].push(std::make_pair(dist[1][edge.first], edge.first));\\n            }\\n        }\\n        // store the processed node/ vertex\\n        workset.push_back(currentNode);\\n\\n        /// check if currentNode has already been visited\\n        if (visited[currentNode] == 1) {\\n            return Shortest_Path_Distance(workset, dist);\\n        }\\n        visited[currentNode] = true;\\n    }\\n    return -1;\\n}\\n}  // namespace bidirectional_dijkstra\\n}  // namespace graph\\n\\n/**\\n * @brief Function to test the\\n * provided algorithm above\\n * @returns void\\n */\\nstatic void tests() {\\n    std::cout << \\\"Initiatinig Predefined Tests...\\\" << std::endl;\\n    std::cout << \\\"Initiating Test 1...\\\" << std::endl;\\n    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj1_1(\\n        4, std::vector<std::pair<uint64_t, uint64_t>>());\\n    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj1_2(\\n        4, std::vector<std::pair<uint64_t, uint64_t>>());\\n    graph::bidirectional_dijkstra::addEdge(&adj1_1, &adj1_2, 1, 2, 1);\\n    graph::bidirectional_dijkstra::addEdge(&adj1_1, &adj1_2, 4, 1, 2);\\n    graph::bidirectional_dijkstra::addEdge(&adj1_1, &adj1_2, 2, 3, 2);\\n    graph::bidirectional_dijkstra::addEdge(&adj1_1, &adj1_2, 1, 3, 5);\\n\\n    uint64_t s = 1, t = 3;\\n    assert(graph::bidirectional_dijkstra::Bidijkstra(&adj1_1, &adj1_2, s - 1,\\n                                                     t - 1) == 3);\\n    std::cout << \\\"Test 1 Passed...\\\" << std::endl;\\n\\n    s = 4, t = 3;\\n    std::cout << \\\"Initiating Test 2...\\\" << std::endl;\\n    assert(graph::bidirectional_dijkstra::Bidijkstra(&adj1_1, &adj1_2, s - 1,\\n                                                     t - 1) == 5);\\n    std::cout << \\\"Test 2 Passed...\\\" << std::endl;\\n\\n    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj2_1(\\n        5, std::vector<std::pair<uint64_t, uint64_t>>());\\n    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj2_2(\\n        5, std::vector<std::pair<uint64_t, uint64_t>>());\\n    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 1, 2, 4);\\n    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 1, 3, 2);\\n    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 2, 3, 2);\\n    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 3, 2, 1);\\n    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 2, 4, 2);\\n    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 3, 5, 4);\\n    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 5, 4, 1);\\n    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 2, 5, 3);\\n    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 3, 4, 4);\\n\\n    s = 1, t = 5;\\n    std::cout << \\\"Initiating Test 3...\\\" << std::endl;\\n    assert(graph::bidirectional_dijkstra::Bidijkstra(&adj2_1, &adj2_2, s - 1,\\n                                                     t - 1) == 6);\\n    std::cout << \\\"Test 3 Passed...\\\" << std::endl;\\n    std::cout << \\\"All Test Passed...\\\" << std::endl << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    tests();  // running predefined tests\\n    uint64_t vertices = uint64_t();\\n    uint64_t edges = uint64_t();\\n    std::cout << \\\"Enter the number of vertices : \\\";\\n    std::cin >> vertices;\\n    std::cout << \\\"Enter the number of edges : \\\";\\n    std::cin >> edges;\\n\\n    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj1(\\n        vertices, std::vector<std::pair<uint64_t, uint64_t>>());\\n    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj2(\\n        vertices, std::vector<std::pair<uint64_t, uint64_t>>());\\n\\n    uint64_t u = uint64_t(), v = uint64_t(), w = uint64_t();\\n    std::cout << \\\"Enter the edges by three integers in this form: u v w \\\"\\n              << std::endl;\\n    std::cout << \\\"Example: if there is and edge between node 1 and node 4 with \\\"\\n                 \\\"weight 7 enter: 1 4 7, and then press enter\\\"\\n              << std::endl;\\n    while (edges--) {\\n        std::cin >> u >> v >> w;\\n        graph::bidirectional_dijkstra::addEdge(&adj1, &adj2, u, v, w);\\n        if (edges != 0) {\\n            std::cout << \\\"Enter the next edge\\\" << std::endl;\\n        }\\n    }\\n\\n    uint64_t s = uint64_t(), t = uint64_t();\\n    std::cout\\n        << \\\"Enter the source node and the target node separated by a space\\\"\\n        << std::endl;\\n    std::cout << \\\"Example: If the source node is 5 and the target node is 6 \\\"\\n                 \\\"enter: 5 6 and press enter\\\"\\n              << std::endl;\\n    std::cin >> s >> t;\\n    int dist =\\n        graph::bidirectional_dijkstra::Bidijkstra(&adj1, &adj2, s - 1, t - 1);\\n    if (dist == -1) {\\n        std::cout << \\\"Target not reachable from source\\\" << std::endl;\\n    } else {\\n        std::cout << \\\"Shortest Path Distance : \\\" << dist << std::endl;\\n    }\\n\\n    return 0;\\n}\\n\"",
    "breadth first search": "\"/**\\n *\\n * \\\\file\\n * \\\\brief [Breadth First Search Algorithm\\n * (Breadth First Search)](https://en.wikipedia.org/wiki/Breadth-first_search)\\n *\\n * \\\\author [Ayaan Khan](https://github.com/ayaankhan98)\\n * \\\\author [Aman Kumar Pandey](https://github.com/gpamangkp)\\n *\\n *\\n * \\\\details\\n * Breadth First Search also quoted as BFS is a Graph Traversal Algorithm.\\n * Time Complexity O(|V| + |E|) where V are the number of vertices and E\\n * are the number of edges in the graph.\\n *\\n * Applications of Breadth First Search are\\n *\\n * 1. Finding shortest path between two vertices say u and v, with path\\n *    length measured by number of edges (an advantage over depth first\\n *    search algorithm)\\n * 2. Ford-Fulkerson Method for computing the maximum flow in a flow network.\\n * 3. Testing bipartiteness of a graph.\\n * 4. Cheney's Algorithm, Copying garbage collection.\\n *\\n * And there are many more...\\n *\\n * <h4>working</h4>\\n * In the implementation below we first created a graph using the adjacency\\n * list representation of graph.\\n * Breadth First Search Works as follows\\n * it requires a vertex as a start vertex, Start vertex is that vertex\\n * from where you want to start traversing the graph.\\n * We maintain a bool array or a vector to keep track of the vertices\\n * which we have visited so that we do not traverse the visited vertices\\n * again and again and eventually fall into an infinite loop. Along with this\\n * boolen array we use a Queue.\\n *\\n * 1. First we mark the start vertex as visited.\\n * 2. Push this visited vertex in the Queue.\\n * 3. while the queue is not empty we repeat the following steps\\n *\\n *      1. Take out an element from the front of queue\\n *      2. Explore the adjacency list of this vertex\\n *         if element in the adjacency list is not visited then we\\n *         push that element into the queue and mark this as visited\\n *\\n */\\n#include <algorithm>\\n#include <cassert>\\n#include <iostream>\\n#include <list>\\n#include <map>\\n#include <queue>\\n#include <string>\\n#include <vector>\\n\\n/**\\n * \\\\namespace graph\\n * \\\\brief Graph algorithms\\n */\\nnamespace graph {\\n/* Class Graph definition */\\ntemplate <typename T>\\nclass Graph {\\n    /**\\n     *  adjacency_list maps every vertex to the list of its neighbours in the\\n     * order in which they are added.\\n     */\\n    std::map<T, std::list<T> > adjacency_list;\\n\\n public:\\n    Graph() = default;\\n    ;\\n    void add_edge(T u, T v, bool bidir = true) {\\n        /**\\n         *  add_edge(u,v,bidir) is used to add an edge between node u and\\n         * node v by default , bidir is made true , i.e graph is\\n         * bidirectional . It means if edge(u,v) is added then u-->v  and\\n         * v-->u both edges exist.\\n         *\\n         *  to make the graph unidirectional pass the third parameter of\\n         * add_edge as false which will\\n         */\\n        adjacency_list[u].push_back(v);  // u-->v edge added\\n        if (bidir == true) {\\n            // if graph is bidirectional\\n            adjacency_list[v].push_back(u);  // v-->u edge added\\n        }\\n    }\\n\\n    /**\\n     *  this function performs the breadth first search on graph and return a\\n     *  mapping which maps the nodes to a boolean value representing whether the\\n     *  node was traversed or not.\\n     */\\n    std::map<T, bool> breadth_first_search(T src) {\\n        /// mapping to keep track of all visited nodes\\n        std::map<T, bool> visited;\\n        /// initialise every possible vertex to map to false\\n        /// initially none of the vertices are unvisited\\n        for (auto const &adjlist : adjacency_list) {\\n            visited[adjlist.first] = false;\\n            for (auto const &node : adjacency_list[adjlist.first]) {\\n                visited[node] = false;\\n            }\\n        }\\n\\n        /// queue to store the nodes which are yet to be traversed\\n        std::queue<T> tracker;\\n\\n        /// push the source vertex to queue to begin traversing\\n        tracker.push(src);\\n        /// mark the source vertex as visited\\n        visited[src] = true;\\n        while (!tracker.empty()) {\\n            /// traverse the graph till no connected vertex are left\\n            /// extract a node from queue for further traversal\\n            T node = tracker.front();\\n            /// remove the node from the queue\\n            tracker.pop();\\n            for (T const &neighbour : adjacency_list[node]) {\\n                /// check every vertex connected to the node which are still\\n                /// unvisited\\n                if (!visited[neighbour]) {\\n                    /// if the neighbour is unvisited , push it into the queue\\n                    tracker.push(neighbour);\\n                    /// mark the neighbour as visited\\n                    visited[neighbour] = true;\\n                }\\n            }\\n        }\\n        return visited;\\n    }\\n};\\n/* Class definition ends */\\n}  // namespace graph\\n\\n/** Test function */\\nstatic void tests() {\\n    /// Test 1 Begin\\n    graph::Graph<int> g;\\n    std::map<int, bool> correct_result;\\n    g.add_edge(0, 1);\\n    g.add_edge(1, 2);\\n    g.add_edge(2, 3);\\n    correct_result[0] = true;\\n    correct_result[1] = true;\\n    correct_result[2] = true;\\n    correct_result[3] = true;\\n\\n    std::map<int, bool> returned_result = g.breadth_first_search(2);\\n\\n    assert(returned_result == correct_result);\\n    std::cout << \\\"Test 1 Passed...\\\" << std::endl;\\n\\n    /// Test 2 Begin\\n    returned_result = g.breadth_first_search(0);\\n\\n    assert(returned_result == correct_result);\\n    std::cout << \\\"Test 2 Passed...\\\" << std::endl;\\n\\n    /// Test 3 Begins\\n    graph::Graph<std::string> g2;\\n\\n    g2.add_edge(\\\"Gorakhpur\\\", \\\"Lucknow\\\", false);\\n    g2.add_edge(\\\"Gorakhpur\\\", \\\"Kanpur\\\", false);\\n    g2.add_edge(\\\"Lucknow\\\", \\\"Agra\\\", false);\\n    g2.add_edge(\\\"Kanpur\\\", \\\"Agra\\\", false);\\n    g2.add_edge(\\\"Lucknow\\\", \\\"Prayagraj\\\", false);\\n    g2.add_edge(\\\"Agra\\\", \\\"Noida\\\", false);\\n\\n    std::map<std::string, bool> correct_res;\\n    std::map<std::string, bool> returned_res =\\n        g2.breadth_first_search(\\\"Kanpur\\\");\\n    correct_res[\\\"Gorakhpur\\\"] = false;\\n    correct_res[\\\"Lucknow\\\"] = false;\\n    correct_res[\\\"Kanpur\\\"] = true;\\n    correct_res[\\\"Agra\\\"] = true;\\n    correct_res[\\\"Prayagraj\\\"] = false;\\n    correct_res[\\\"Noida\\\"] = true;\\n    assert(correct_res == returned_res);\\n    std::cout << \\\"Test 3 Passed...\\\" << std::endl;\\n}\\n\\n/** Main function */\\nint main() {\\n    tests();\\n    size_t edges = 0;\\n    std::cout << \\\"Enter the number of edges: \\\";\\n    std::cin >> edges;\\n\\n    graph::Graph<int> g;\\n\\n    std::cout << \\\"Enter space-separated pairs of vertices that form edges: \\\"\\n              << std::endl;\\n    while (edges--) {\\n        int u = 0, v = 0;\\n        std::cin >> u >> v;\\n        g.add_edge(u, v);\\n    }\\n\\n    g.breadth_first_search(0);\\n    return 0;\\n}\\n\"",
    "bridge finding with tarjan algorithm": "\"/*\\n *  Copyright : 2020 , MIT\\n *  Author : Amit Kumar (offamitkumar)\\n *  Last Modified Date: May 24, 2020\\n *\\n */\\n#include <algorithm>  //  for min & max\\n#include <iostream>   //  for cout\\n#include <vector>     //  for std::vector\\n\\nclass Solution {\\n    std::vector<std::vector<int>> graph;\\n    std::vector<int> in_time, out_time;\\n    int timer = 0;\\n    std::vector<std::vector<int>> bridge;\\n    std::vector<bool> visited;\\n    void dfs(int current_node, int parent) {\\n        visited.at(current_node) = true;\\n        in_time[current_node] = out_time[current_node] = timer++;\\n        for (auto& itr : graph[current_node]) {\\n            if (itr == parent) {\\n                continue;\\n            }\\n            if (!visited[itr]) {\\n                dfs(itr, current_node);\\n                if (out_time[itr] > in_time[current_node]) {\\n                    bridge.push_back({itr, current_node});\\n                }\\n            }\\n            out_time[current_node] =\\n                std::min(out_time[current_node], out_time[itr]);\\n        }\\n    }\\n\\n public:\\n    std::vector<std::vector<int>> search_bridges(\\n        int n, const std::vector<std::vector<int>>& connections) {\\n        timer = 0;\\n        graph.resize(n);\\n        in_time.assign(n, 0);\\n        visited.assign(n, false);\\n        out_time.assign(n, 0);\\n        for (auto& itr : connections) {\\n            graph.at(itr[0]).push_back(itr[1]);\\n            graph.at(itr[1]).push_back(itr[0]);\\n        }\\n        dfs(0, -1);\\n        return bridge;\\n    }\\n};\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    Solution s1;\\n    int number_of_node = 5;\\n    std::vector<std::vector<int>> node;\\n    node.push_back({0, 1});\\n    node.push_back({1, 3});\\n    node.push_back({1, 2});\\n    node.push_back({2, 4});\\n    /*\\n     *     0 <--> 1 <---> 2\\n     *            ^       ^\\n     *            |       |\\n     *            |       |\\n     *            \\\\/     \\\\/\\n     *            3       4\\n     *\\n     *    In this graph there are 4 bridges [0,2] , [2,4] , [3,5] , [1,2]\\n     *\\n     *    I assumed that the graph is bi-directional and connected.\\n     *\\n     */\\n    std::vector<std::vector<int>> bridges =\\n        s1.search_bridges(number_of_node, node);\\n    std::cout << bridges.size() << \\\" bridges found!\\\\n\\\";\\n    for (auto& itr : bridges) {\\n        std::cout << itr[0] << \\\" --> \\\" << itr[1] << '\\\\n';\\n    }\\n    return 0;\\n}\\n\"",
    "connected components": "\"/**\\n *\\n * \\\\file\\n * \\\\brief [Graph Connected Components\\n * (Connected Components)]\\n * (https://en.wikipedia.org/wiki/Component_(graph_theory))\\n *\\n * \\\\author [Ayaan Khan](http://github.com/ayaankhan98)\\n *\\n * \\\\details\\n * A graph is a collection of nodes also called vertices and these vertices\\n * are connected by edges. A connected component in a graph refers to a set of\\n * vertices which are reachable form one another.\\n *\\n * <pre>\\n * Example - Here is graph with 3 connected components\\n *\\n *      1   4           5               8\\n *     / \\\\ /           / \\\\             / \\\\\\n *    2---3           6   7           9   10\\n *\\n *    first          second           third\\n *    component      component        component\\n * </pre>\\n *\\n */\\n\\n#include <algorithm>\\n#include <cassert>\\n#include <iostream>\\n#include <vector>\\n\\n/**\\n * @namespace graph\\n * @brief Graph Algorithms\\n */\\n\\nnamespace graph {\\n/**\\n * @brief Function that add edge between two nodes or vertices of graph\\n *\\n * @param adj adjacency list of graph.\\n * @param u any node or vertex of graph.\\n * @param v any node or vertex of graph.\\n */\\nvoid addEdge(std::vector<std::vector<int>> *adj, int u, int v) {\\n    (*adj)[u - 1].push_back(v - 1);\\n    (*adj)[v - 1].push_back(u - 1);\\n}\\n\\n/**\\n * @brief Utility function for depth first seach algorithm\\n * this function explores the vertex which is passed into.\\n *\\n * @param adj adjacency list of graph.\\n * @param u vertex or node to be explored.\\n * @param visited already visited vertices.\\n */\\nvoid explore(const std::vector<std::vector<int>> *adj, int u,\\n             std::vector<bool> *visited) {\\n    (*visited)[u] = true;\\n    for (auto v : (*adj)[u]) {\\n        if (!(*visited)[v]) {\\n            explore(adj, v, visited);\\n        }\\n    }\\n}\\n\\n/**\\n * @brief Function that perfoms depth first search algorithm on graph\\n * and calculated the number of connected components.\\n *\\n * @param adj adjacency list of graph.\\n *\\n * @return connected_components number of connected components in graph.\\n */\\nint getConnectedComponents(const std::vector<std::vector<int>> *adj) {\\n    int n = adj->size();\\n    int connected_components = 0;\\n    std::vector<bool> visited(n, false);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (!visited[i]) {\\n            explore(adj, i, &visited);\\n            connected_components++;\\n        }\\n    }\\n    return connected_components;\\n}\\n}  // namespace graph\\n\\n/** Function to test the algorithm */\\nvoid tests() {\\n    std::cout << \\\"Running predefined tests...\\\" << std::endl;\\n    std::cout << \\\"Initiating Test 1...\\\" << std::endl;\\n    std::vector<std::vector<int>> adj1(9, std::vector<int>());\\n    graph::addEdge(&adj1, 1, 2);\\n    graph::addEdge(&adj1, 1, 3);\\n    graph::addEdge(&adj1, 3, 4);\\n    graph::addEdge(&adj1, 5, 7);\\n    graph::addEdge(&adj1, 5, 6);\\n    graph::addEdge(&adj1, 8, 9);\\n\\n    assert(graph::getConnectedComponents(&adj1) == 3);\\n    std::cout << \\\"Test 1 Passed...\\\" << std::endl;\\n\\n    std::cout << \\\"Innitiating Test 2...\\\" << std::endl;\\n    std::vector<std::vector<int>> adj2(10, std::vector<int>());\\n    graph::addEdge(&adj2, 1, 2);\\n    graph::addEdge(&adj2, 1, 3);\\n    graph::addEdge(&adj2, 1, 4);\\n    graph::addEdge(&adj2, 2, 3);\\n    graph::addEdge(&adj2, 3, 4);\\n    graph::addEdge(&adj2, 4, 8);\\n    graph::addEdge(&adj2, 4, 10);\\n    graph::addEdge(&adj2, 8, 10);\\n    graph::addEdge(&adj2, 8, 9);\\n    graph::addEdge(&adj2, 5, 7);\\n    graph::addEdge(&adj2, 5, 6);\\n    graph::addEdge(&adj2, 6, 7);\\n\\n    assert(graph::getConnectedComponents(&adj2) == 2);\\n    std::cout << \\\"Test 2 Passed...\\\" << std::endl;\\n}\\n\\n/** Main function */\\nint main() {\\n    /// running predefined tests\\n    tests();\\n\\n    int vertices = int(), edges = int();\\n    std::cout << \\\"Enter the number of vertices : \\\";\\n    std::cin >> vertices;\\n    std::cout << \\\"Enter the number of edges : \\\";\\n    std::cin >> edges;\\n\\n    std::vector<std::vector<int>> adj(vertices, std::vector<int>());\\n\\n    int u = int(), v = int();\\n    while (edges--) {\\n        std::cin >> u >> v;\\n        graph::addEdge(&adj, u, v);\\n    }\\n\\n    int cc = graph::getConnectedComponents(&adj);\\n    std::cout << cc << std::endl;\\n    return 0;\\n}\\n\"",
    "connected components with dsu": "\"/**\\n * @file\\n * @brief [Disjoint union](https://en.wikipedia.org/wiki/Disjoint_union)\\n *\\n * @details\\n * The Disjoint union is the technique to find connected component in graph efficiently.\\n *\\n * ### Algorithm\\n * In Graph, if you have to find out the number of connected components, there are 2 options\\n * 1. Depth first search\\n * 2. Disjoint union\\n * 1st option is inefficient, Disjoint union is the most optimal way to find this.\\n *\\n * @author Unknown author\\n * @author [Sagar Pandya](https://github.com/sagarpandyansit)\\n */\\n#include <iostream> /// for IO operations\\n#include <set>    /// for std::set\\n#include <vector> /// for std::vector\\n\\n/**\\n * @namespace graph\\n * @brief Graph Algorithms\\n */\\nnamespace graph {\\n/**\\n * @namespace disjoint_union\\n * @brief Functions for [Disjoint union](https://en.wikipedia.org/wiki/Disjoint_union) implementation\\n */\\nnamespace disjoint_union {\\nuint32_t number_of_nodes = 0;                // denotes number of nodes\\nstd::vector<int64_t> parent{};               // parent of each node\\nstd::vector<uint32_t> connected_set_size{};  // size of each set\\n/**\\n * @brief function the initialize every node as it's own parent\\n * @returns void\\n */\\nvoid make_set() {\\n    for (uint32_t i = 1; i <= number_of_nodes; i++) {\\n        parent[i] = i;\\n        connected_set_size[i] = 1;\\n    }\\n}\\n/**\\n * @brief Find the component where following node belongs to\\n * @param val parent of val should be found\\n * @return parent of val\\n */\\nint64_t find_set(int64_t val) {\\n    while (parent[val] != val) {\\n        parent[val] = parent[parent[val]];\\n        val = parent[val];\\n    }\\n    return val;\\n}\\n/**\\n * @brief Merge 2 components to become one\\n * @param node1 1st component\\n * @param node2 2nd component\\n * @returns void\\n */\\nvoid union_sets(int64_t node1, int64_t node2) {\\n    node1 = find_set(node1);  // find the parent of node1\\n    node2 = find_set(node2);  // find the parent of node2\\n\\n    // If parents of both nodes are not same, combine them\\n    if (node1 != node2) {\\n        if (connected_set_size[node1] < connected_set_size[node2]) {\\n            std::swap(node1, node2);  // swap both components\\n        }\\n        parent[node2] = node1;  // make node1 as parent of node2.\\n        connected_set_size[node1] +=\\n            connected_set_size[node2];  // sum the size of both as they combined\\n    }\\n}\\n/**\\n * @brief Find total no. of connected components\\n * @return Number of connected components\\n */\\nuint32_t no_of_connected_components() {\\n    std::set<int64_t> temp;  // temp set to count number of connected components\\n    for (uint32_t i = 1; i <= number_of_nodes; i++) temp.insert(find_set(i));\\n    return temp.size();  // return the size of temp set\\n}\\n}  // namespace disjoint_union\\n}  // namespace graph\\n\\n/**\\n * @brief Test Implementations\\n * @returns void\\n */\\nstatic void test() {\\n    namespace dsu = graph::disjoint_union;\\n    std::cin >> dsu::number_of_nodes;\\n    dsu::parent.resize(dsu::number_of_nodes + 1);\\n    dsu::connected_set_size.resize(dsu::number_of_nodes + 1);\\n    dsu::make_set();\\n    uint32_t edges = 0;\\n    std::cin >> edges;  // no of edges in the graph\\n    while (edges--) {\\n        int64_t node_a = 0, node_b = 0;\\n        std::cin >> node_a >> node_b;\\n        dsu::union_sets(node_a, node_b);\\n    }\\n    std::cout << dsu::no_of_connected_components() << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // Execute the tests\\n    return 0;\\n}\\n\"",
    "cycle check directed graph": "\"/**\\n * @file cycle_check_directed graph.cpp\\n *\\n * @brief BFS and DFS algorithms to check for cycle in a directed graph.\\n *\\n * @author [Anmol3299](mailto:mittalanmol22@gmail.com)\\n *\\n */\\n\\n#include <iostream>     // for std::cout\\n#include <map>          // for std::map\\n#include <queue>        // for std::queue\\n#include <stdexcept>    // for throwing errors\\n#include <type_traits>  // for std::remove_reference\\n#include <utility>      // for std::move\\n#include <vector>       // for std::vector\\n\\n/**\\n * Implementation of non-weighted directed edge of a graph.\\n *\\n * The source vertex of the edge is labelled \\\"src\\\" and destination vertex is\\n * labelled \\\"dest\\\".\\n */\\nstruct Edge {\\n    unsigned int src;\\n    unsigned int dest;\\n\\n    Edge() = delete;\\n    ~Edge() = default;\\n    Edge(Edge&&) = default;\\n    Edge& operator=(Edge&&) = default;\\n    Edge(Edge const&) = default;\\n    Edge& operator=(Edge const&) = default;\\n\\n    /** Set the source and destination of the vertex.\\n     *\\n     * @param source is the source vertex of the edge.\\n     * @param destination is the destination vertex of the edge.\\n     */\\n    Edge(unsigned int source, unsigned int destination)\\n        : src(source), dest(destination) {}\\n};\\n\\nusing AdjList = std::map<unsigned int, std::vector<unsigned int>>;\\n\\n/**\\n * Implementation of graph class.\\n *\\n * The graph will be represented using Adjacency List representation.\\n * This class contains 2 data members \\\"m_vertices\\\" & \\\"m_adjList\\\" used to\\n * represent the number of vertices and adjacency list of the graph\\n * respectively. The vertices are labelled 0 - (m_vertices - 1).\\n */\\nclass Graph {\\n public:\\n    Graph() : m_adjList({}) {}\\n    ~Graph() = default;\\n    Graph(Graph&&) = default;\\n    Graph& operator=(Graph&&) = default;\\n    Graph(Graph const&) = default;\\n    Graph& operator=(Graph const&) = default;\\n\\n    /** Create a graph from vertices and adjacency list.\\n     *\\n     * @param vertices specify the number of vertices the graph would contain.\\n     * @param adjList is the adjacency list representation of graph.\\n     */\\n    Graph(unsigned int vertices, AdjList adjList)\\n        : m_vertices(vertices), m_adjList(std::move(adjList)) {}\\n\\n    /** Create a graph from vertices and adjacency list.\\n     *\\n     * @param vertices specify the number of vertices the graph would contain.\\n     * @param adjList is the adjacency list representation of graph.\\n     */\\n    Graph(unsigned int vertices, AdjList&& adjList)\\n        : m_vertices(vertices), m_adjList(std::move(adjList)) {}\\n\\n    /** Create a graph from vertices and a set of edges.\\n     *\\n     * Adjacency list of the graph would be created from the set of edges. If\\n     * the source or destination of any edge has a value greater or equal to\\n     * number of vertices, then it would throw a range_error.\\n     *\\n     * @param vertices specify the number of vertices the graph would contain.\\n     * @param edges is a vector of edges.\\n     */\\n    Graph(unsigned int vertices, std::vector<Edge> const& edges)\\n        : m_vertices(vertices) {\\n        for (auto const& edge : edges) {\\n            if (edge.src >= vertices || edge.dest >= vertices) {\\n                throw std::range_error(\\n                    \\\"Either src or dest of edge out of range\\\");\\n            }\\n            m_adjList[edge.src].emplace_back(edge.dest);\\n        }\\n    }\\n\\n    /** Return a const reference of the adjacency list.\\n     *\\n     * @return const reference to the adjacency list\\n     */\\n    std::remove_reference<AdjList>::type const& getAdjList() const {\\n        return m_adjList;\\n    }\\n\\n    /**\\n     * @return number of vertices in the graph.\\n     */\\n    unsigned int getVertices() const { return m_vertices; }\\n\\n    /** Add vertices in the graph.\\n     *\\n     * @param num is the number of vertices to be added. It adds 1 vertex by\\n     * default.\\n     *\\n     */\\n    void addVertices(unsigned int num = 1) { m_vertices += num; }\\n\\n    /** Add an edge in the graph.\\n     *\\n     * @param edge that needs to be added.\\n     */\\n    void addEdge(Edge const& edge) {\\n        if (edge.src >= m_vertices || edge.dest >= m_vertices) {\\n            throw std::range_error(\\\"Either src or dest of edge out of range\\\");\\n        }\\n        m_adjList[edge.src].emplace_back(edge.dest);\\n    }\\n\\n    /** Add an Edge in the graph\\n     *\\n     * @param source is source vertex of the edge.\\n     * @param destination is the destination vertex of the edge.\\n     */\\n    void addEdge(unsigned int source, unsigned int destination) {\\n        if (source >= m_vertices || destination >= m_vertices) {\\n            throw std::range_error(\\n                \\\"Either source or destination of edge out of range\\\");\\n        }\\n        m_adjList[source].emplace_back(destination);\\n    }\\n\\n private:\\n    unsigned int m_vertices = 0;\\n    AdjList m_adjList;\\n};\\n\\n/**\\n * Check if a directed graph has a cycle or not.\\n *\\n * This class provides 2 methods to check for cycle in a directed graph:\\n * isCyclicDFS & isCyclicBFS.\\n *\\n * - isCyclicDFS uses DFS traversal method to check for cycle in a graph.\\n * - isCyclidBFS used BFS traversal method to check for cycle in a graph.\\n */\\nclass CycleCheck {\\n private:\\n    enum nodeStates : uint8_t { not_visited = 0, in_stack, visited };\\n\\n    /** Helper function of \\\"isCyclicDFS\\\".\\n     *\\n     * @param adjList is the adjacency list representation of some graph.\\n     * @param state is the state of the nodes of the graph.\\n     * @param node is the node being evaluated.\\n     *\\n     * @return true if graph has a cycle, else false.\\n     */\\n    static bool isCyclicDFSHelper(AdjList const& adjList,\\n                                  std::vector<nodeStates>* state,\\n                                  unsigned int node) {\\n        // Add node \\\"in_stack\\\" state.\\n        (*state)[node] = in_stack;\\n\\n        // If the node has children, then recursively visit all children of the\\n        // node.\\n        auto const it = adjList.find(node);\\n        if (it != adjList.end()) {\\n            for (auto child : it->second) {\\n                // If state of child node is \\\"not_visited\\\", evaluate that child\\n                // for presence of cycle.\\n                auto state_of_child = (*state)[child];\\n                if (state_of_child == not_visited) {\\n                    if (isCyclicDFSHelper(adjList, state, child)) {\\n                        return true;\\n                    }\\n                } else if (state_of_child == in_stack) {\\n                    // If child node was \\\"in_stack\\\", then that means that there\\n                    // is a cycle in the graph. Return true for presence of the\\n                    // cycle.\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        // Current node has been evaluated for the presence of cycle and had no\\n        // cycle. Mark current node as \\\"visited\\\".\\n        (*state)[node] = visited;\\n        // Return that current node didn't result in any cycles.\\n        return false;\\n    }\\n\\n public:\\n    /** Driver function to check if a graph has a cycle.\\n     *\\n     * This function uses DFS to check for cycle in the graph.\\n     *\\n     * @param graph which needs to be evaluated for the presence of cycle.\\n     * @return true if a cycle is detected, else false.\\n     */\\n    static bool isCyclicDFS(Graph const& graph) {\\n        auto vertices = graph.getVertices();\\n\\n        /** State of the node.\\n         *\\n         * It is a vector of \\\"nodeStates\\\" which represents the state node is in.\\n         * It can take only 3 values: \\\"not_visited\\\", \\\"in_stack\\\", and \\\"visited\\\".\\n         *\\n         * Initially, all nodes are in \\\"not_visited\\\" state.\\n         */\\n        std::vector<nodeStates> state(vertices, not_visited);\\n\\n        // Start visiting each node.\\n        for (unsigned int node = 0; node < vertices; node++) {\\n            // If a node is not visited, only then check for presence of cycle.\\n            // There is no need to check for presence of cycle for a visited\\n            // node as it has already been checked for presence of cycle.\\n            if (state[node] == not_visited) {\\n                // Check for cycle.\\n                if (isCyclicDFSHelper(graph.getAdjList(), &state, node)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        // All nodes have been safely traversed, that means there is no cycle in\\n        // the graph. Return false.\\n        return false;\\n    }\\n\\n    /** Check if a graph has cycle or not.\\n     *\\n     * This function uses BFS to check if a graph is cyclic or not.\\n     *\\n     * @param graph which needs to be evaluated for the presence of cycle.\\n     * @return true if a cycle is detected, else false.\\n     */\\n    static bool isCyclicBFS(Graph const& graph) {\\n        auto graphAjdList = graph.getAdjList();\\n        auto vertices = graph.getVertices();\\n\\n        std::vector<unsigned int> indegree(vertices, 0);\\n        // Calculate the indegree i.e. the number of incident edges to the node.\\n        for (auto const& list : graphAjdList) {\\n            auto children = list.second;\\n            for (auto const& child : children) {\\n                indegree[child]++;\\n            }\\n        }\\n\\n        std::queue<unsigned int> can_be_solved;\\n        for (unsigned int node = 0; node < vertices; node++) {\\n            // If a node doesn't have any input edges, then that node will\\n            // definately not result in a cycle and can be visited safely.\\n            if (!indegree[node]) {\\n                can_be_solved.emplace(node);\\n            }\\n        }\\n\\n        // Vertices that need to be traversed.\\n        auto remain = vertices;\\n        // While there are safe nodes that we can visit.\\n        while (!can_be_solved.empty()) {\\n            auto solved = can_be_solved.front();\\n            // Visit the node.\\n            can_be_solved.pop();\\n            // Decrease number of nodes that need to be traversed.\\n            remain--;\\n\\n            // Visit all the children of the visited node.\\n            auto it = graphAjdList.find(solved);\\n            if (it != graphAjdList.end()) {\\n                for (auto child : it->second) {\\n                    // Check if we can visited the node safely.\\n                    if (--indegree[child] == 0) {\\n                        // if node can be visited safely, then add that node to\\n                        // the visit queue.\\n                        can_be_solved.emplace(child);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // If there are still nodes that we can't visit, then it means that\\n        // there is a cycle and return true, else return false.\\n        return !(remain == 0);\\n    }\\n};\\n\\n/**\\n * Main function.\\n */\\nint main() {\\n    // Instantiate the graph.\\n    Graph g(7, std::vector<Edge>{{0, 1}, {1, 2}, {2, 0}, {2, 5}, {3, 5}});\\n    // Check for cycle using BFS method.\\n    std::cout << CycleCheck::isCyclicBFS(g) << '\\\\n';\\n\\n    // Check for cycle using DFS method.\\n    std::cout << CycleCheck::isCyclicDFS(g) << '\\\\n';\\n    return 0;\\n}\\n\"",
    "depth first search": "\"/**\\n *\\n * \\\\file\\n * \\\\brief [Depth First Search Algorithm\\n * (Depth First Search)](https://en.wikipedia.org/wiki/Depth-first_search)\\n *\\n * \\\\author [Ayaan Khan](http://github.com/ayaankhan98)\\n *\\n * \\\\details\\n * Depth First Search also quoted as DFS is a Graph Traversal Algorithm.\\n * Time Complexity O(|V| + |E|) where V is number of vertices and E\\n * is number of edges in graph.\\n *\\n * Application of Depth First Search are\\n *\\n * 1. Finding connected components\\n * 2. Finding 2-(edge or vertex)-connected components.\\n * 3. Finding 3-(edge or vertex)-connected components.\\n * 4. Finding the bridges of a graph.\\n * 5. Generating words in order to plot the limit set of a group.\\n * 6. Finding strongly connected components.\\n *\\n * And there are many more...\\n *\\n * <h4>Working</h4>\\n * 1. Mark all vertices as unvisited first\\n * 2. start exploring from some starting vertex.\\n *\\n *      While exploring vertex we mark the vertex as visited\\n *      and start exploring the vertices connected to this\\n *      vertex in recursive way.\\n *\\n */\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n\\n/**\\n *\\n * \\\\namespace graph\\n * \\\\brief Graph Algorithms\\n *\\n */\\nnamespace graph {\\n/**\\n * \\\\brief\\n * Adds and edge between two vertices of graph say u and v in this\\n * case.\\n *\\n * @param adj Adjacency list representation of graph\\n * @param u first vertex\\n * @param v second vertex\\n *\\n */\\nvoid addEdge(std::vector<std::vector<size_t>> *adj, size_t u, size_t v) {\\n    /*\\n     *\\n     * Here we are considering undirected graph that's the\\n     * reason we are adding v to the adjacency list representation of u\\n     * and also adding u to the adjacency list representation of v\\n     *\\n     */\\n    (*adj)[u - 1].push_back(v - 1);\\n    (*adj)[v - 1].push_back(u - 1);\\n}\\n\\n/**\\n *\\n * \\\\brief\\n * Explores the given vertex, exploring a vertex means traversing\\n * over all the vertices which are connected to the vertex that is\\n * currently being explored.\\n *\\n * @param adj garph\\n * @param v vertex to be explored\\n * @param visited already visited vertices\\n *\\n */\\nvoid explore(const std::vector<std::vector<size_t>> &adj, size_t v,\\n             std::vector<bool> *visited) {\\n    std::cout << v + 1 << \\\" \\\";\\n    (*visited)[v] = true;\\n    for (auto x : adj[v]) {\\n        if (!(*visited)[x]) {\\n            explore(adj, x, visited);\\n        }\\n    }\\n}\\n\\n/**\\n * \\\\brief\\n * initiates depth first search algorithm.\\n *\\n * @param adj adjacency list of graph\\n * @param start vertex from where DFS starts traversing.\\n *\\n */\\nvoid depth_first_search(const std::vector<std::vector<size_t>> &adj,\\n                        size_t start) {\\n    size_t vertices = adj.size();\\n\\n    std::vector<bool> visited(vertices, false);\\n    explore(adj, start, &visited);\\n}\\n}  // namespace graph\\n\\n/** Main function */\\nint main() {\\n    size_t vertices = 0, edges = 0;\\n    std::cout << \\\"Enter the Vertices : \\\";\\n    std::cin >> vertices;\\n    std::cout << \\\"Enter the Edges : \\\";\\n    std::cin >> edges;\\n\\n    /// creating graph\\n    std::vector<std::vector<size_t>> adj(vertices, std::vector<size_t>());\\n\\n    /// taking input for edges\\n    std::cout << \\\"Enter the vertices which have edges between them : \\\"\\n              << std::endl;\\n    while (edges--) {\\n        size_t u = 0, v = 0;\\n        std::cin >> u >> v;\\n        graph::addEdge(&adj, u, v);\\n    }\\n\\n    /// running depth first search over graph\\n    graph::depth_first_search(adj, 2);\\n\\n    std::cout << std::endl;\\n    return 0;\\n}\\n\"",
    "depth first search with stack": "\"/**\\n *\\n * @file\\n * @brief [Depth First Search Algorithm using Stack\\n * (Depth First Search Algorithm)](https://en.wikipedia.org/wiki/Depth-first_search)\\n *\\n * @author [Ayaan Khan](http://github.com/ayaankhan98)\\n * @author [Saurav Uppoor](https://github.com/sauravUppoor)\\n *\\n * @details\\n * Depth First Search also quoted as DFS is a Graph Traversal Algorithm.\\n * Time Complexity O(|V| + |E|) where V is number of vertices and E\\n * is number of edges in graph.\\n *\\n * Application of Depth First Search are\\n *\\n * 1. Finding connected components\\n * 2. Finding 2-(edge or vertex)-connected components.\\n * 3. Finding 3-(edge or vertex)-connected components.\\n * 4. Finding the bridges of a graph.\\n * 5. Generating words in order to plot the limit set of a group.\\n * 6. Finding strongly connected components.\\n *\\n * <h4>Working</h4>\\n * 1. Mark all vertices as unvisited (colour it WHITE).\\n * 2. Push starting vertex into the stack and colour it GREY.\\n * 3. Once a node is popped out of the stack and is coloured GREY, we colour it BLACK.\\n * 4. Push all its neighbours which are not coloured BLACK.\\n * 5. Repeat steps 4 and 5 until the stack is empty.\\n */\\n\\n#include <iostream> \\t /// for IO operations\\n#include <stack>    \\t /// header for std::stack\\n#include <vector>   \\t /// header for std::vector\\n#include <cassert>  \\t /// header for preprocessor macro assert() \\n#include <limits>   \\t /// header for limits of integral types\\n\\nconstexpr int WHITE = 0; /// indicates the node hasn't been explored\\nconstexpr int GREY = 1;\\t /// indicates node is in stack waiting to be explored\\nconstexpr int BLACK = 2; /// indicates node has already been explored\\nconstexpr int64_t INF = std::numeric_limits<int16_t>::max();\\n\\n\\n/**\\n * @namespace graph\\n * @brief Graph algorithms\\n */\\nnamespace graph {\\n/**\\n * @namespace depth_first_search\\n * @brief Functions for [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search) algorithm\\n */\\nnamespace depth_first_search {\\n/**\\n * @brief\\n * Adds and edge between two vertices of graph say u and v in this\\n * case.\\n *\\n * @param adj Adjacency list representation of graph\\n * @param u first vertex\\n * @param v second vertex\\n *\\n */\\nvoid addEdge(std::vector<std::vector<size_t>> *adj, size_t u, size_t v) {\\n\\t/*\\n\\t*\\n\\t* Here we are considering undirected graph that's the\\n\\t* reason we are adding v to the adjacency list representation of u\\n\\t* and also adding u to the adjacency list representation of v\\n\\t*\\n\\t*/\\n\\t(*adj)[u - 1].push_back(v - 1);\\n}\\n\\n/**\\n *\\n * @brief\\n * Explores the given vertex, exploring a vertex means traversing\\n * over all the vertices which are connected to the vertex that is\\n * currently being explored and push it onto the stack.\\n *\\n * @param adj graph\\n * @param start starting vertex for DFS\\n * @return vector with nodes stored in the order of DFS traversal\\n *\\n */\\nstd::vector<size_t> dfs(const std::vector<std::vector<size_t> > &graph, size_t start) {\\n    /// checked[i] stores the status of each node\\n    std::vector<size_t> checked(graph.size(), WHITE), traversed_path;\\n\\n    checked[start] = GREY;\\n    std::stack<size_t> stack;\\n    stack.push(start);\\n\\n    /// while stack is not empty we keep exploring the node on top of stack\\n    while (!stack.empty()) {\\n        int act = stack.top();\\n        stack.pop();\\n\\n        if (checked[act] == GREY) {\\n            /// push the node to the final result vector\\n            traversed_path.push_back(act + 1);\\n\\n            /// exploring the neighbours of the current node\\n            for (auto it : graph[act]) {\\n                stack.push(it);\\n                if (checked[it] != BLACK) {\\n                    checked[it] = GREY;\\n                }\\n            }\\n            checked[act] = BLACK;  /// Node has been explored\\n        }\\n    }\\n    return traversed_path;\\n}\\n}  // namespace depth_first_search\\n}  // namespace graph\\n\\n/**\\n * Self-test implementations\\n * @returns none\\n */\\nstatic void tests() {\\n\\tsize_t start_pos;\\n\\n\\t/// Test 1\\n\\tstd::cout << \\\"Case 1: \\\" << std::endl;\\n\\tstart_pos = 1;\\n\\tstd::vector<std::vector<size_t> > g1(3, std::vector<size_t>());\\n\\n\\tgraph::depth_first_search::addEdge(&g1, 1, 2);\\n\\tgraph::depth_first_search::addEdge(&g1, 2, 3);\\n\\tgraph::depth_first_search::addEdge(&g1, 3, 1);\\n\\n\\tstd::vector<size_t> expected1 {1, 2, 3}; /// for the above sample data, this is the expected output\\n\\tassert(graph::depth_first_search::dfs(g1, start_pos - 1) == expected1);\\n\\tstd::cout << \\\"Passed\\\" << std::endl;\\n\\n\\t/// Test 2\\n\\tstd::cout << \\\"Case 2: \\\" << std::endl;\\n\\tstart_pos = 1;\\n\\tstd::vector<std::vector<size_t> > g2(4, std::vector<size_t>());\\n\\n\\tgraph::depth_first_search::addEdge(&g2, 1, 2);\\n\\tgraph::depth_first_search::addEdge(&g2, 1, 3);\\n\\tgraph::depth_first_search::addEdge(&g2, 2, 4);\\n\\tgraph::depth_first_search::addEdge(&g2, 4, 1);\\n\\n\\tstd::vector<size_t> expected2 {1, 3, 2, 4}; /// for the above sample data, this is the expected output\\n\\tassert(graph::depth_first_search::dfs(g2, start_pos - 1) == expected2);\\n\\tstd::cout << \\\"Passed\\\" << std::endl;\\n\\n\\t/// Test 3\\n\\tstd::cout << \\\"Case 3: \\\" << std::endl;\\n\\tstart_pos = 2;\\n\\tstd::vector<std::vector<size_t> > g3(4, std::vector<size_t>());\\n\\n\\tgraph::depth_first_search::addEdge(&g3, 1, 2);\\n\\tgraph::depth_first_search::addEdge(&g3, 1, 3);\\n\\tgraph::depth_first_search::addEdge(&g3, 2, 4);\\n\\tgraph::depth_first_search::addEdge(&g3, 4, 1);\\n\\n\\tstd::vector<size_t> expected3 {2, 4, 1, 3}; /// for the above sample data, this is the expected output\\n\\tassert(graph::depth_first_search::dfs(g3, start_pos - 1) == expected3);\\n\\tstd::cout << \\\"Passed\\\" << std::endl;\\n\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    tests();  // execute the tests\\n\\n    size_t vertices = 0, edges = 0, start_pos = 1;\\n\\tstd::vector<size_t> traversal;\\n\\n    std::cout << \\\"Enter the Vertices : \\\";\\n\\tstd::cin >> vertices;\\n\\tstd::cout << \\\"Enter the Edges : \\\";\\n\\tstd::cin >> edges;\\n\\n    /// creating a graph\\n    std::vector<std::vector<size_t> > adj(vertices, std::vector<size_t>());\\n\\n    /// taking input for the edges\\n    std::cout << \\\"Enter the vertices which have edges between them : \\\" << std::endl;\\n\\twhile (edges--) {\\n\\t\\tsize_t u = 0, v = 0;\\n\\t\\tstd::cin >> u >> v;\\n\\t\\tgraph::depth_first_search::addEdge(&adj, u, v);\\n\\t}\\n\\n    /// taking input for the starting position\\n    std::cout << \\\"Enter the starting vertex [1,n]: \\\" << std::endl;\\n\\tstd::cin >> start_pos;\\n\\tstart_pos -= 1;\\n\\ttraversal = graph::depth_first_search::dfs(adj, start_pos);\\n\\n    /// Printing the order of traversal\\n    for (auto x : traversal) {\\n\\t\\tstd::cout << x << ' ';\\n\\t}\\n\\n    return 0;\\n}\\n\"",
    "dijkstra": "\"#include <limits.h>\\n#include <iostream>\\n\\nusing namespace std;\\n\\n// Wrapper class for storing a graph\\nclass Graph {\\n public:\\n    int vertexNum;\\n    int **edges;\\n\\n    // Constructs a graph with V vertices and E edges\\n    Graph(const int V) {\\n        // initializes the array edges.\\n        this->edges = new int *[V];\\n        for (int i = 0; i < V; i++) {\\n            edges[i] = new int[V];\\n        }\\n\\n        // fills the array with zeros.\\n        for (int i = 0; i < V; i++) {\\n            for (int j = 0; j < V; j++) {\\n                edges[i][j] = 0;\\n            }\\n        }\\n\\n        this->vertexNum = V;\\n    }\\n\\n    // Adds the given edge to the graph\\n    void addEdge(int src, int dst, int weight) {\\n        this->edges[src][dst] = weight;\\n    }\\n};\\n// Utility function to find minimum distance vertex in mdist\\nint minDistance(int mdist[], bool vset[], int V) {\\n    int minVal = INT_MAX, minInd = 0;\\n    for (int i = 0; i < V; i++) {\\n        if (!vset[i] && (mdist[i] < minVal)) {\\n            minVal = mdist[i];\\n            minInd = i;\\n        }\\n    }\\n\\n    return minInd;\\n}\\n\\n// Utility function to print distances\\nvoid print(int dist[], int V) {\\n    cout << \\\"\\\\nVertex  Distance\\\" << endl;\\n    for (int i = 0; i < V; i++) {\\n        if (dist[i] < INT_MAX)\\n            cout << i << \\\"\\\\t\\\" << dist[i] << endl;\\n        else\\n            cout << i << \\\"\\\\tINF\\\" << endl;\\n    }\\n}\\n\\n// The main function that finds the shortest path from given source\\n// to all other vertices using Dijkstra's Algorithm.It doesn't work on negative\\n// weights\\nvoid Dijkstra(Graph graph, int src) {\\n    int V = graph.vertexNum;\\n    int mdist[V];  // Stores updated distances to vertex\\n    bool vset[V];  // vset[i] is true if the vertex i included\\n    // in the shortest path tree\\n\\n    // Initialise mdist and vset. Set distance of source as zero\\n    for (int i = 0; i < V; i++) {\\n        mdist[i] = INT_MAX;\\n        vset[i] = false;\\n    }\\n\\n    mdist[src] = 0;\\n\\n    // iterate to find shortest path\\n    for (int count = 0; count < V - 1; count++) {\\n        int u = minDistance(mdist, vset, V);\\n\\n        vset[u] = true;\\n\\n        for (int v = 0; v < V; v++) {\\n            if (!vset[v] && graph.edges[u][v] &&\\n                mdist[u] + graph.edges[u][v] < mdist[v]) {\\n                mdist[v] = mdist[u] + graph.edges[u][v];\\n            }\\n        }\\n    }\\n\\n    print(mdist, V);\\n}\\n\\n// Driver Function\\nint main() {\\n    int V, E, gsrc;\\n    int src, dst, weight;\\n    cout << \\\"Enter number of vertices: \\\";\\n    cin >> V;\\n    cout << \\\"Enter number of edges: \\\";\\n    cin >> E;\\n    Graph G(V);\\n    for (int i = 0; i < E; i++) {\\n        cout << \\\"\\\\nEdge \\\" << i + 1 << \\\"\\\\nEnter source: \\\";\\n        cin >> src;\\n        cout << \\\"Enter destination: \\\";\\n        cin >> dst;\\n        cout << \\\"Enter weight: \\\";\\n        cin >> weight;\\n\\n        // makes sure source and destionation are in the proper bounds.\\n        if (src >= 0 && src < V && dst >= 0 && dst < V) {\\n            G.addEdge(src, dst, weight);\\n        } else {\\n            cout << \\\"source and/or destination out of bounds\\\" << endl;\\n            i--;\\n            continue;\\n        }\\n    }\\n    cout << \\\"\\\\nEnter source:\\\";\\n    cin >> gsrc;\\n    Dijkstra(G, gsrc);\\n\\n    return 0;\\n}\\n\"",
    "hamiltons cycle": "\"/**\\n * @file\\n * @brief The implementation of [Hamilton's\\n * cycle](https://en.wikipedia.org/wiki/Hamiltonian_path) dynamic solution for\\n * vertices number less than 20.\\n * @details\\n * I use \\\\f$2^n\\\\times n\\\\f$ matrix and for every \\\\f$[i, j]\\\\f$ (\\\\f$i < 2^n\\\\f$ and\\n * \\\\f$j < n\\\\f$) in the matrix I store `true` if it is possible to get to all\\n * vertices on which position in `i`'s binary representation is `1` so as\\n * \\\\f$j\\\\f$ would be the last one.\\n *\\n * In the the end if any cell in \\\\f$(2^n - 1)^{\\\\mbox{th}}\\\\f$ row is `true` there\\n * exists hamiltonian cycle.\\n *\\n * @author [vakhokoto](https://github.com/vakhokoto)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#include <cassert>\\n#include <iostream>\\n#include <vector>\\n\\n/**\\n * The function determines if there is a hamilton's cycle in the graph\\n *\\n * @param routes nxn boolean matrix of \\\\f$[i, j]\\\\f$ where \\\\f$[i, j]\\\\f$ is `true`\\n * if there is a road from \\\\f$i\\\\f$ to \\\\f$j\\\\f$\\n * @return `true` if there is Hamiltonian cycle in the graph\\n * @return `false` if there is no Hamiltonian cycle in the graph\\n */\\nbool hamilton_cycle(const std::vector<std::vector<bool>> &routes) {\\n    const size_t n = routes.size();\\n    // height of dp array which is 2^n\\n    const size_t height = 1 << n;\\n    std::vector<std::vector<bool>> dp(height, std::vector<bool>(n, false));\\n\\n    // to fill in the [2^i, i] cells with true\\n    for (size_t i = 0; i < n; ++i) {\\n        dp[1 << i][i] = true;\\n    }\\n    for (size_t i = 1; i < height; i++) {\\n        std::vector<size_t> zeros, ones;\\n        // finding positions with 1s and 0s and separate them\\n        for (size_t pos = 0; pos < n; ++pos) {\\n            if ((1 << pos) & i) {\\n                ones.push_back(pos);\\n            } else {\\n                zeros.push_back(pos);\\n            }\\n        }\\n\\n        for (auto &o : ones) {\\n            if (!dp[i][o]) {\\n                continue;\\n            }\\n\\n            for (auto &z : zeros) {\\n                if (!routes[o][z]) {\\n                    continue;\\n                }\\n                dp[i + (1 << z)][z] = true;\\n            }\\n        }\\n    }\\n\\n    bool is_cycle = false;\\n    for (size_t i = 0; i < n; i++) {\\n        is_cycle |= dp[height - 1][i];\\n        if (is_cycle) {  // if true, all subsequent loop will be true. hence\\n                         // break\\n            break;\\n        }\\n    }\\n    return is_cycle;\\n}\\n\\n/**\\n * this test is testing if ::hamilton_cycle returns `true` for\\n * graph: `1 -> 2 -> 3 -> 4`\\n * @return None\\n */\\nstatic void test1() {\\n    std::vector<std::vector<bool>> arr{\\n        std::vector<bool>({true, true, false, false}),\\n        std::vector<bool>({false, true, true, false}),\\n        std::vector<bool>({false, false, true, true}),\\n        std::vector<bool>({false, false, false, true})};\\n\\n    bool ans = hamilton_cycle(arr);\\n    std::cout << \\\"Test 1... \\\";\\n    assert(ans);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/**\\n * this test is testing if ::hamilton_cycle returns `false` for\\n * \\\\n graph:<pre>\\n *  1 -> 2 -> 3\\n *       |\\n *       V\\n *       4</pre>\\n * @return None\\n */\\nstatic void test2() {\\n    std::vector<std::vector<bool>> arr{\\n        std::vector<bool>({true, true, false, false}),\\n        std::vector<bool>({false, true, true, true}),\\n        std::vector<bool>({false, false, true, false}),\\n        std::vector<bool>({false, false, false, true})};\\n\\n    bool ans = hamilton_cycle(arr);\\n\\n    std::cout << \\\"Test 2... \\\";\\n    assert(!ans);  // not a cycle\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/**\\n * this test is testing if ::hamilton_cycle returns `true` for\\n * clique with 4 vertices\\n * @return None\\n */\\nstatic void test3() {\\n    std::vector<std::vector<bool>> arr{\\n        std::vector<bool>({true, true, true, true}),\\n        std::vector<bool>({true, true, true, true}),\\n        std::vector<bool>({true, true, true, true}),\\n        std::vector<bool>({true, true, true, true})};\\n\\n    bool ans = hamilton_cycle(arr);\\n\\n    std::cout << \\\"Test 3... \\\";\\n    assert(ans);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/**\\n * Main function\\n *\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n */\\nint main(int argc, char **argv) {\\n    test1();\\n    test2();\\n    test3();\\n    return 0;\\n}\\n\"",
    "hopcroft karp": "\"/**\\n * @file \\n * @brief  Implementation of [Hopcroft–Karp](https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm) algorithm.\\n * @details \\n * The Hopcroft–Karp algorithm is an algorithm that takes as input a bipartite graph \\n * and produces as output a maximum cardinality matching, it runs in O(E√V) time in worst case.\\n * \\n * ### Bipartite graph\\n * A bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint \\n * and independent sets U and V such that every edge connects a vertex in U to one in V. \\n * Vertex sets U and V are usually called the parts of the graph. \\n * Equivalently, a bipartite graph is a graph that does not contain any odd-length cycles.\\n * \\n * ### Matching and Not-Matching edges\\n * Given a matching M, edges that are part of matching are called Matching edges and edges that are not part \\n * of M (or connect free nodes) are called Not-Matching edges.\\n * \\n * ### Maximum cardinality matching\\n * Given a bipartite graphs G = ( V = ( X , Y ) , E ) whose partition has the parts X and Y, \\n * with E denoting the edges of the graph, the goal is to find a matching with as many edges as possible. \\n * Equivalently, a matching that covers as many vertices as possible.\\n * \\n * ### Augmenting paths\\n * Given a matching M, an augmenting path is an alternating path that starts from and ends on free vertices. \\n * All single edge paths that start and end with free vertices are augmenting paths.\\n * \\n * \\n * ### Concept\\n * A matching M is not maximum if there exists an augmenting path. It is also true other way,\\n * i.e, a matching is maximum if no augmenting path exists.\\n * \\n * \\n * ### Algorithm\\n * 1) Initialize the Maximal Matching M as empty.\\n * 2) While there exists an Augmenting Path P\\n *   Remove matching edges of P from M and add not-matching edges of P to M\\n *   (This increases size of M by 1 as P starts and ends with a free vertex\\n *   i.e. a node that is not part of matching.)\\n * 3) Return M. \\n * \\n * \\n *\\n * @author [Krishna Pal Deora](https://github.com/Krishnapal4050)\\n * \\n */\\n\\n\\n#include <iostream>\\n#include <cstdlib> \\n#include <queue>\\n#include <list>\\n#include <climits>\\n#include <memory>\\n#include <cassert>\\n\\n/**\\n * @namespace graph \\n * @brief Graph algorithms\\n */\\n namespace graph { \\n\\n/**\\n * @brief Represents Bipartite graph for\\n * Hopcroft Karp implementation\\n */\\nclass HKGraph\\n{\\n    int m{};  ///< m is the number of vertices on left side of Bipartite Graph\\n    int n{};  ///< n is the number of vertices on right side of Bipartite Graph\\n    const int NIL{0};\\n    const int INF{INT_MAX};\\n\\n    std::vector<std::list<int> >adj;  ///< adj[u] stores adjacents of left side and 0 is used for dummy vertex\\n\\n    std::vector<int> pair_u; ///< value of vertex 'u' ranges from 1 to m\\n    std::vector<int> pair_v; ///< value of vertex 'v' ranges from 1 to n\\n    std::vector<int> dist;   ///< dist represents the distance between vertex 'u' and vertex 'v'\\n\\npublic:\\n    HKGraph();\\t\\t       // Default Constructor\\n    HKGraph(int m, int n);     // Constructor\\n    void addEdge(int u, int v); // To add edge\\n    \\n    bool bfs(); // Returns true if there is an augmenting path    \\n    bool dfs(int u); // Adds augmenting path if there is one beginning with u  \\n\\t\\n    int hopcroftKarpAlgorithm();  // Returns size of maximum matching\\n};\\n\\n\\n/**\\n * @brief This function counts the number of augmenting paths between left and right sides of the Bipartite graph\\n * @returns size of maximum matching\\n */\\nint HKGraph::hopcroftKarpAlgorithm()\\n{\\n\\n    // pair_u[u] stores pair of u in matching on left side of Bipartite Graph.\\n    // If u doesn't have any pair, then pair_u[u] is NIL\\n    pair_u = std::vector<int>(m + 1,NIL); \\n\\n    // pair_v[v] stores pair of v in matching on right side of Biparite Graph.\\n    // If v doesn't have any pair, then pair_u[v] is NIL\\n    pair_v = std::vector<int>(n + 1,NIL); \\n\\n    dist = std::vector<int>(m + 1);  // dist[u] stores distance of left side vertices\\n\\n    int result = 0;  // Initialize result\\n\\n    // Keep updating the result while there is an augmenting path possible.\\n    while (bfs())\\n    {\\n        // Find a free vertex to check for a matching\\n        for (int u = 1; u <= m; u++){\\n\\n            // If current vertex is free and there is\\n            // an augmenting path from current vertex\\n            // then increment the result\\n            if (pair_u[u] == NIL && dfs(u)){\\n                result++;\\n\\t    }\\n\\t}\\n    }\\n    return result;\\n}\\n\\n\\n/**\\n * @brief This function checks for the possibility of augmented path availability \\n * @returns `true` if there is an augmenting path available\\n * @returns `false` if there is no augmenting path available\\n */\\nbool HKGraph::bfs()\\n{\\n    std::queue<int> q; // an integer queue for bfs\\n\\n    // First layer of vertices (set distance as 0)\\n    for (int u = 1; u <= m; u++)\\n    {\\n        // If this is a free vertex, add it to queue\\n        if (pair_u[u] == NIL){\\n            \\n            dist[u] = 0; // u is not matched so distance is 0\\n            q.push(u);\\n        }\\n\\n        else{\\n            dist[u] = INF; // set distance as infinite so that this vertex is considered next time for availibility\\n\\t}\\n    }\\n\\n    \\n    dist[NIL] = INF; // Initialize distance to NIL as infinite\\n\\n    // q is going to contain vertices of left side only.\\n    while (!q.empty())\\n    {\\n        int u = q.front();  // dequeue a vertex\\n        q.pop();\\n\\n        // If this node is not NIL and can provide a shorter path to NIL then\\n        if (dist[u] < dist[NIL])\\n        {\\n            // Get all the adjacent vertices of the dequeued vertex u\\n            std::list<int>::iterator it;\\n            for (it = adj[u].begin(); it != adj[u].end(); ++it)\\n            {\\n                int v = *it;\\n\\n                // If pair of v is not considered so far i.e. (v, pair_v[v]) is not yet explored edge.\\n                if (dist[pair_v[v]] == INF)\\n                {\\n                    dist[pair_v[v]] = dist[u] + 1; \\n                    q.push(pair_v[v]);    // Consider the pair and push it to queue\\n                }\\n            }\\n        }\\n    }\\n\\n   \\n   \\n    return (dist[NIL] != INF);   // If we could come back to NIL using alternating path of distinct vertices then there is an augmenting path available\\n}\\n\\n/**\\n * @brief This functions checks whether an augmenting path is available exists beginning with free vertex u\\n * @param u represents position of vertex\\n * @returns `true` if there is an augmenting path beginning with free vertex u\\n * @returns `false` if there is no augmenting path beginning with free vertex u\\n */\\nbool HKGraph::dfs(int u)\\n{\\n    if (u != NIL)\\n    {\\n        std::list<int>::iterator it;\\n        for (it = adj[u].begin(); it != adj[u].end(); ++it)\\n        {\\n            \\n            int v = *it; // Adjacent vertex of u\\n\\n            // Follow the distances set by BFS search\\n            if (dist[pair_v[v]] == dist[u] + 1)\\n            {\\n                // If dfs for pair of v also return true then new matching possible, store the matching\\n                if (dfs(pair_v[v]) == true)\\n                {   \\n                    pair_v[v] = u;\\n                    pair_u[u] = v;\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        \\n        dist[u] = INF; // If there is no augmenting path beginning with u then set distance to infinite.\\n        return false;\\n    }\\n    return true;\\n}\\n\\n/**\\n * @brief Default Constructor for initialization\\n */\\nHKGraph::HKGraph() = default;\\n\\n/**\\n * @brief Constructor for initialization\\n * @param m is the number of vertices on left side of Bipartite Graph\\n * @param n is the number of vertices on right side of Bipartite Graph\\n */\\nHKGraph::HKGraph(int m, int n) {\\n    this->m = m;\\n    this->n = n;\\n    adj = std::vector<std::list<int> >(m + 1);\\n}\\n\\n/**\\n * @brief function to add edge from u to v\\n * @param u is the position of first vertex\\n * @param v is the position of second vertex\\n */\\nvoid HKGraph::addEdge(int u, int v)\\n{\\n    adj[u].push_back(v); // Add v to u’s list.\\n}\\n\\n} // namespace graph\\n\\nusing graph::HKGraph;\\n\\n/**\\n * Self-test implementation\\n * @returns none\\n */\\nvoid tests(){\\n     // Sample test case 1\\n\\t     int v1a = 3, v1b = 5, e1 = 2;  // vertices of left side, right side and edges\\n\\t     HKGraph g1(v1a, v1b); // execute the algorithm \\n\\n\\t     g1.addEdge(0,1);\\n\\t     g1.addEdge(1,4);\\n\\n\\t     int expected_res1 = 0; // for the above sample data, this is the expected output\\n\\t     int res1 = g1.hopcroftKarpAlgorithm();\\n\\n\\t     assert(res1 == expected_res1); // assert check to ensure that the algorithm executed correctly for test 1\\n\\t\\n     // Sample test case 2\\n     \\t     int v2a = 4, v2b = 4, e2 = 6;  // vertices of left side, right side and edges\\n\\t     HKGraph g2(v2a, v2b); // execute the algorithm \\n\\n             g2.addEdge(1,1);\\n\\t     g2.addEdge(1,3);\\n\\t     g2.addEdge(2,3);\\n\\t     g2.addEdge(3,4);\\n\\t     g2.addEdge(4,3);\\n             g2.addEdge(4,2);\\n\\t\\n\\t     int expected_res2 = 0; // for the above sample data, this is the expected output\\n\\t     int res2 = g2.hopcroftKarpAlgorithm();\\n\\n\\t     assert(res2 == expected_res2); // assert check to ensure that the algorithm executed correctly for test 2\\n\\t\\n      // Sample test case 3\\n     \\t     int v3a = 6, v3b = 6, e3 = 4;  // vertices of left side, right side and edges\\n\\t     HKGraph g3(v3a, v3b); // execute the algorithm \\n\\n             g3.addEdge(0,1);\\n\\t     g3.addEdge(1,4);\\n\\t     g3.addEdge(1,5);\\n\\t     g3.addEdge(5,0);\\n\\n\\t     int expected_res3 = 0; // for the above sample data, this is the expected output\\n\\t     int res3 = g3.hopcroftKarpAlgorithm();\\n\\n\\t     assert(res3 == expected_res3); // assert check to ensure that the algorithm executed correctly for test 3\\n\\t\\n\\t\\n    \\t\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    tests();  // perform self-tests\\n\\n    int v1 = 0, v2 = 0, e = 0;\\n    std::cin >> v1 >> v2 >> e; // vertices of left side, right side and edges\\n    HKGraph g(v1, v2);  \\n    int u = 0, v = 0;\\n    for (int i = 0; i < e; ++i)\\n    {\\n        std::cin >> u >> v;\\n        g.addEdge(u, v);\\n    }\\n  \\n    int res = g.hopcroftKarpAlgorithm();\\n    std::cout << \\\"Maximum matching is \\\" << res <<\\\"\\\\n\\\";\\n\\n    return 0;\\n\\n}\\n\"",
    "is graph bipartite": "\"/**\\n * @file\\n *\\n * @brief Algorithm to check whether a graph is\\n * [bipartite](https://en.wikipedia.org/wiki/Bipartite_graph)\\n *\\n * @details\\n * A graph is a collection of nodes also called vertices and these vertices\\n * are connected by edges. A graph is bipartite if its vertices can be\\n * divided into two disjoint and independent sets U and V such that every edge\\n * connects a vertex in U to one in V.\\n *\\n * The algorithm implemented in this file determines whether the given graph\\n * is bipartite or not.\\n *\\n * <pre>\\n *  Example - Here is a graph g1 with 5 vertices and is bipartite\\n *\\n *     1   4\\n *    / \\\\ / \\\\\\n *   2   3   5\\n *\\n * Example - Here is a graph G2 with 3 vertices and is not bipartite\\n *\\n *   1 --- 2\\n *    \\\\   /\\n *      3\\n *\\n * </pre>\\n *\\n * @author [Akshat Vaya](https://github.com/AkVaya)\\n *\\n */\\n#include <iostream>\\n#include <queue>\\n#include <vector>\\n\\n/**\\n * @namespace graph\\n * @brief Graph algorithms\\n */\\nnamespace graph {\\n/**\\n * @namespace is_graph_bipartite\\n * @brief Functions for checking whether a graph is bipartite or not\\n */\\nnamespace is_graph_bipartite {\\n/**\\n * @brief Class for representing graph as an adjacency list.\\n */\\nclass Graph {\\n private:\\n    int n;  ///< size of the graph\\n\\n    std::vector<std::vector<int> >\\n        adj;  ///< adj stores the graph as an adjacency list\\n\\n    std::vector<int> side;  ///< stores the side of the vertex\\n\\n public:\\n    /**\\n     * @brief Constructor that initializes the graph on creation\\n     * @param size number of vertices of the graph\\n     */\\n    explicit Graph(int size) {\\n        n = size;\\n        adj.resize(n);\\n        side.resize(n, -1);\\n    }\\n\\n    void addEdge(int u, int v);  /// function to add edges to our graph\\n\\n    bool\\n    is_bipartite();  /// function to check whether the graph is bipartite or not\\n};\\n\\n/**\\n * @brief Function that add an edge between two nodes or vertices of graph\\n *\\n * @param u is a node or vertex of graph\\n * @param v is a node or vertex of graph\\n */\\nvoid Graph::addEdge(int u, int v) {\\n    adj[u - 1].push_back(v - 1);\\n    adj[v - 1].push_back(u - 1);\\n}\\n\\n/**\\n * @brief function that checks whether the graph is bipartite or not\\n * the function returns true if the graph is a bipartite graph\\n * the function returns false if the graph is not a bipartite graph\\n *\\n * @details\\n * Here, side refers to the two disjoint subsets of the bipartite graph.\\n * Initially, the values of side are set to -1 which is an unassigned state. A\\n * for loop is run for every vertex of the graph. If the current edge has no\\n * side assigned to it, then a Breadth First Search operation is performed. If\\n * two neighbours have the same side then the graph will not be bipartite and\\n * the value of check becomes false. If and only if each pair of neighbours have\\n * different sides, the value of check will be true and hence the graph\\n * bipartite.\\n *\\n * @returns `true` if th graph is bipartite\\n * @returns `false` otherwise\\n */\\nbool Graph::is_bipartite() {\\n    bool check = true;\\n    std::queue<int> q;\\n    for (int current_edge = 0; current_edge < n; ++current_edge) {\\n        if (side[current_edge] == -1) {\\n            q.push(current_edge);\\n            side[current_edge] = 0;\\n            while (q.size()) {\\n                int current = q.front();\\n                q.pop();\\n                for (auto neighbour : adj[current]) {\\n                    if (side[neighbour] == -1) {\\n                        side[neighbour] = (1 ^ side[current]);\\n                        q.push(neighbour);\\n                    } else {\\n                        check &= (side[neighbour] != side[current]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return check;\\n}\\n}  // namespace is_graph_bipartite\\n}  // namespace graph\\n\\n/**\\n * Function to test the above algorithm\\n * @returns none\\n */\\nstatic void test() {\\n    graph::is_graph_bipartite::Graph G1(\\n        5);  /// creating graph G1 with 5 vertices\\n    /// adding edges to the graphs as per the illustrated example\\n    G1.addEdge(1, 2);\\n    G1.addEdge(1, 3);\\n    G1.addEdge(3, 4);\\n    G1.addEdge(4, 5);\\n\\n    graph::is_graph_bipartite::Graph G2(\\n        3);  /// creating graph G2 with 3 vertices\\n    /// adding edges to the graphs as per the illustrated example\\n    G2.addEdge(1, 2);\\n    G2.addEdge(1, 3);\\n    G2.addEdge(2, 3);\\n\\n    /// checking whether the graphs are bipartite or not\\n    if (G1.is_bipartite()) {\\n        std::cout << \\\"The given graph G1 is a bipartite graph\\\\n\\\";\\n    } else {\\n        std::cout << \\\"The given graph G1 is not a bipartite graph\\\\n\\\";\\n    }\\n    if (G2.is_bipartite()) {\\n        std::cout << \\\"The given graph G2 is a bipartite graph\\\\n\\\";\\n    } else {\\n        std::cout << \\\"The given graph G2 is not a bipartite graph\\\\n\\\";\\n    }\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    test();  /// Testing\\n    return 0;\\n}\\n\"",
    "is graph bipartite2": "\"/**\\n * @brief Check whether a given graph is bipartite or not\\n * @details\\n * A bipartite graph is the one whose nodes can be divided into two\\n * disjoint sets in such a way that the nodes in a set are not\\n * connected to each other at all, i.e. no intra-set connections.\\n * The only connections that exist are that of inter-set,\\n * i.e. the nodes from one set are connected to a subset of nodes\\n * in the other set.\\n * In this implementation, using a graph in the form of adjacency\\n * list, check whether the given graph is a bipartite or not.\\n *\\n * References used:\\n * [GeeksForGeeks](https://www.geeksforgeeks.org/bipartite-graph/)\\n * @author [tushar2407](https://github.com/tushar2407)\\n */\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <queue>     /// for queue data structure\\n#include <vector>    /// for vector data structure\\n\\n/**\\n * @namespace graph\\n * @brief Graphical algorithms\\n */\\nnamespace graph {\\n/**\\n * @brief function to check whether the passed graph is bipartite or not\\n * @param graph is a 2D matrix whose rows or the first index signify the node\\n * and values in that row signify the nodes it is connected to\\n * @param index is the valus of the node currently under observation\\n * @param visited is the vector which stores whether a given node has been\\n * traversed or not yet\\n * @returns boolean\\n */\\nbool checkBipartite(const std::vector<std::vector<int64_t>> &graph,\\n                    int64_t index, std::vector<int64_t> *visited) {\\n    std::queue<int64_t> q;  ///< stores the neighbouring node indexes in squence\\n                            /// of being reached\\n    q.push(index);          /// insert the current node into the queue\\n    (*visited)[index] = 1;  /// mark the current node as travelled\\n    while (q.size()) {\\n        int64_t u = q.front();\\n        q.pop();\\n        for (uint64_t i = 0; i < graph[u].size(); i++) {\\n            int64_t v =\\n                graph[u][i];     ///< stores the neighbour of the current node\\n            if (!(*visited)[v])  /// check whether the neighbour node is\\n                                 /// travelled already or not\\n            {\\n                (*visited)[v] =\\n                    ((*visited)[u] == 1)\\n                        ? -1\\n                        : 1;  /// colour the neighbouring node with\\n                              /// different colour than the current node\\n                q.push(v);    /// insert the neighbouring node into the queue\\n            } else if ((*visited)[v] ==\\n                       (*visited)[u])  /// if both the current node and its\\n                                       /// neighbour has the same state then it\\n                                       /// is not a bipartite graph\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;  /// return true when all the connected nodes of the current\\n                  /// nodes are travelled and satisify all the above conditions\\n}\\n/**\\n * @brief returns true if the given graph is bipartite else returns false\\n * @param graph is a 2D matrix whose rows or the first index signify the node\\n * and values in that row signify the nodes it is connected to\\n * @returns booleans\\n */\\nbool isBipartite(const std::vector<std::vector<int64_t>> &graph) {\\n    std::vector<int64_t> visited(\\n        graph.size());  ///< stores boolean values\\n                        /// which signify whether that node had been visited or\\n                        /// not\\n\\n    for (uint64_t i = 0; i < graph.size(); i++) {\\n        if (!visited[i])  /// if the current node is not visited then check\\n                          /// whether the sub-graph of that node is a bipartite\\n                          /// or not\\n        {\\n            if (!checkBipartite(graph, i, &visited)) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n}  // namespace graph\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    std::vector<std::vector<int64_t>> graph = {{1, 3}, {0, 2}, {1, 3}, {0, 2}};\\n\\n    assert(graph::isBipartite(graph) ==\\n           true);  /// check whether the above\\n                   /// defined graph is indeed bipartite\\n\\n    std::vector<std::vector<int64_t>> graph_not_bipartite = {\\n        {1, 2, 3}, {0, 2}, {0, 1, 3}, {0, 2}};\\n\\n    assert(graph::isBipartite(graph_not_bipartite) ==\\n           false);  /// check whether\\n                    /// the above defined graph is indeed bipartite\\n    std::cout << \\\"All tests have successfully passed!\\\\n\\\";\\n}\\n/**\\n * @brief Main function\\n * Instantitates a dummy graph of a small size with\\n * a few edges between random nodes.\\n * On applying the algorithm, it checks if the instantiated\\n * graph is bipartite or not.\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "kosaraju": "\"/* Implementation of Kosaraju's Algorithm to find out the strongly connected\\n   components (SCCs) in a graph. Author:Anirban166\\n*/\\n\\n#include <iostream>\\n#include <stack>\\n#include <vector>\\n\\n/**\\n * Iterative function/method to print graph:\\n * @param a adjacency list representation of the graph\\n * @param V number of vertices\\n * @return void\\n **/\\nvoid print(const std::vector<std::vector<int> > &a, int V) {\\n    for (int i = 0; i < V; i++) {\\n        if (!a[i].empty()) {\\n            std::cout << \\\"i=\\\" << i << \\\"-->\\\";\\n        }\\n        for (int j : a[i]) {\\n            std::cout << j << \\\" \\\";\\n        }\\n        if (!a[i].empty()) {\\n            std::cout << std::endl;\\n        }\\n    }\\n}\\n\\n/**\\n * //Recursive function/method to push vertices into stack passed as parameter:\\n * @param v vertices\\n * @param st stack passed by reference\\n * @param vis array to keep track of visited nodes (boolean type)\\n * @param adj adjacency list representation of the graph\\n * @return void\\n **/\\nvoid push_vertex(int v, std::stack<int> *st, std::vector<bool> *vis,\\n                 const std::vector<std::vector<int> > &adj) {\\n    (*vis)[v] = true;\\n    for (auto i = adj[v].begin(); i != adj[v].end(); i++) {\\n        if ((*vis)[*i] == false) {\\n            push_vertex(*i, st, vis, adj);\\n        }\\n    }\\n    st->push(v);\\n}\\n\\n/**\\n * //Recursive function/method to implement depth first traversal(dfs):\\n * @param v vertices\\n * @param vis array to keep track of visited nodes (boolean type)\\n * @param grev graph with reversed edges\\n * @return void\\n **/\\nvoid dfs(int v, std::vector<bool> *vis,\\n         const std::vector<std::vector<int> > &grev) {\\n    (*vis)[v] = true;\\n    // cout<<v<<\\\" \\\";\\n    for (auto i = grev[v].begin(); i != grev[v].end(); i++) {\\n        if ((*vis)[*i] == false) {\\n            dfs(*i, vis, grev);\\n        }\\n    }\\n}\\n\\n// function/method to implement Kosaraju's Algorithm:\\n/**\\n* Info about the method\\n* @param V vertices in graph\\n* @param adj array of vectors that represent a graph (adjacency list/array)\\n* @return int ( 0, 1, 2..and so on, only unsigned values as either there can be\\nno SCCs i.e. none(0) or there will be x no. of SCCs (x>0)) i.e. it returns the\\ncount of (number of) strongly connected components (SCCs) in the graph.\\n(variable 'count_scc' within function)\\n**/\\nint kosaraju(int V, const std::vector<std::vector<int> > &adj) {\\n    std::vector<bool> vis(V, false);\\n    std::stack<int> st;\\n    for (int v = 0; v < V; v++) {\\n        if (vis[v] == false) {\\n            push_vertex(v, &st, &vis, adj);\\n        }\\n    }\\n    // making new graph (grev) with reverse edges as in adj[]:\\n    std::vector<std::vector<int> > grev(V);\\n    for (int i = 0; i < V + 1; i++) {\\n        for (auto j = adj[i].begin(); j != adj[i].end(); j++) {\\n            grev[*j].push_back(i);\\n        }\\n    }\\n    // cout<<\\\"grev=\\\"<<endl; ->debug statement\\n    // print(grev,V);       ->debug statement\\n    // reinitialise visited to 0\\n    for (int i = 0; i < V; i++) vis[i] = false;\\n    int count_scc = 0;\\n    while (!st.empty()) {\\n        int t = st.top();\\n        st.pop();\\n        if (vis[t] == false) {\\n            dfs(t, &vis, grev);\\n            count_scc++;\\n        }\\n    }\\n    // cout<<\\\"count_scc=\\\"<<count_scc<<endl; //in case you want to print here\\n    // itself, uncomment & change return type of function to void.\\n    return count_scc;\\n}\\n\\n// All critical/corner cases have been taken care of.\\n// Input your required values: (not hardcoded)\\nint main() {\\n    int t = 0;\\n    std::cin >> t;\\n    while (t--) {\\n        int a = 0, b = 0;  // a->number of nodes, b->directed edges.\\n        std::cin >> a >> b;\\n        int m = 0, n = 0;\\n        std::vector<std::vector<int> > adj(a + 1);\\n        for (int i = 0; i < b; i++)  // take total b inputs of 2 vertices each\\n                                     // required to form an edge.\\n        {\\n            std::cin >> m >> n;  // take input m,n denoting edge from m->n.\\n            adj[m].push_back(n);\\n        }\\n        // pass number of nodes and adjacency array as parameters to function:\\n        std::cout << kosaraju(a, adj) << std::endl;\\n    }\\n    return 0;\\n}\\n\"",
    "kruskal": "\"#include <algorithm>\\n#include <array>\\n#include <iostream>\\n#include <vector>\\n//#include <boost/multiprecision/cpp_int.hpp>\\n// using namespace boost::multiprecision;\\nconst int mx = 1e6 + 5;\\nusing ll = int64_t;\\n\\nstd::array<ll, mx> parent;\\nll node, edge;\\nstd::vector<std::pair<ll, std::pair<ll, ll>>> edges;\\nvoid initial() {\\n    for (int i = 0; i < node + edge; ++i) {\\n        parent[i] = i;\\n    }\\n}\\n\\nint root(int i) {\\n    while (parent[i] != i) {\\n        parent[i] = parent[parent[i]];\\n        i = parent[i];\\n    }\\n    return i;\\n}\\n\\nvoid join(int x, int y) {\\n    int root_x = root(x);  // Disjoint set union by rank\\n    int root_y = root(y);\\n    parent[root_x] = root_y;\\n}\\n\\nll kruskal() {\\n    ll mincost = 0;\\n    for (int i = 0; i < edge; ++i) {\\n        ll x = edges[i].second.first;\\n        ll y = edges[i].second.second;\\n        if (root(x) != root(y)) {\\n            mincost += edges[i].first;\\n            join(x, y);\\n        }\\n    }\\n    return mincost;\\n}\\n\\nint main() {\\n    while (true) {\\n        int from = 0, to = 0, cost = 0, totalcost = 0;\\n        std::cin >> node >> edge;  // Enter the nodes and edges\\n        if (node == 0 && edge == 0) {\\n            break;  // Enter 0 0 to break out\\n        }\\n        initial();  // Initialise the parent array\\n        for (int i = 0; i < edge; ++i) {\\n            std::cin >> from >> to >> cost;\\n            edges.emplace_back(make_pair(cost, std::make_pair(from, to)));\\n            totalcost += cost;\\n        }\\n        sort(edges.begin(), edges.end());\\n        std::cout << kruskal() << std::endl;\\n        edges.clear();\\n    }\\n    return 0;\\n}\\n\"",
    "lowest common ancestor": "\"/**\\n *\\n * \\\\file\\n *\\n * \\\\brief Data structure for finding the lowest common ancestor\\n * of two vertices in a rooted tree using binary lifting.\\n *\\n * \\\\details\\n * Algorithm: https://cp-algorithms.com/graph/lca_binary_lifting.html\\n *\\n * Complexity:\\n *   - Precomputation: \\\\f$O(N \\\\log N)\\\\f$ where \\\\f$N\\\\f$ is the number of vertices\\n * in the tree\\n *   - Query: \\\\f$O(\\\\log N)\\\\f$\\n *   - Space: \\\\f$O(N \\\\log N)\\\\f$\\n *\\n * Example:\\n * <br/>  Tree:\\n * <pre>\\n *             _  3  _\\n *          /     |     \\\\\\n *        1       6       4\\n *      / |     /   \\\\       \\\\\\n *    7   5   2       8       0\\n *            |\\n *            9\\n * </pre>\\n *\\n * <br/>  lowest_common_ancestor(7, 4) = 3\\n * <br/>  lowest_common_ancestor(9, 6) = 6\\n * <br/>  lowest_common_ancestor(0, 0) = 0\\n * <br/>  lowest_common_ancestor(8, 2) = 6\\n *\\n *   The query is symmetrical, therefore\\n *     lowest_common_ancestor(x, y) = lowest_common_ancestor(y, x)\\n */\\n\\n#include <cassert>\\n#include <iostream>\\n#include <queue>\\n#include <utility>\\n#include <vector>\\n\\n/**\\n * \\\\namespace graph\\n * \\\\brief Graph algorithms\\n */\\nnamespace graph {\\n/**\\n * Class for representing a graph as an adjacency list.\\n * Its vertices are indexed 0, 1, ..., N - 1.\\n */\\nclass Graph {\\n public:\\n    /**\\n     * \\\\brief Populate the adjacency list for each vertex in the graph.\\n     * Assumes that evey edge is a pair of valid vertex indices.\\n     *\\n     * @param N number of vertices in the graph\\n     * @param undirected_edges list of graph's undirected edges\\n     */\\n    Graph(size_t N, const std::vector<std::pair<int, int> > &undirected_edges) {\\n        neighbors.resize(N);\\n        for (auto &edge : undirected_edges) {\\n            neighbors[edge.first].push_back(edge.second);\\n            neighbors[edge.second].push_back(edge.first);\\n        }\\n    }\\n\\n    /**\\n     * Function to get the number of vertices in the graph\\n     * @return the number of vertices in the graph.\\n     */\\n    int number_of_vertices() const { return neighbors.size(); }\\n\\n    /** \\\\brief for each vertex it stores a list indicies of its neighbors */\\n    std::vector<std::vector<int> > neighbors;\\n};\\n\\n/**\\n * Representation of a rooted tree. For every vertex its parent is\\n * precalculated.\\n */\\nclass RootedTree : public Graph {\\n public:\\n    /**\\n     * \\\\brief Constructs the tree by calculating parent for every vertex.\\n     * Assumes a valid description of a tree is provided.\\n     *\\n     * @param undirected_edges list of graph's undirected edges\\n     * @param root_ index of the root vertex\\n     */\\n    RootedTree(const std::vector<std::pair<int, int> > &undirected_edges,\\n               int root_)\\n        : Graph(undirected_edges.size() + 1, undirected_edges), root(root_) {\\n        populate_parents();\\n    }\\n\\n    /**\\n     * \\\\brief Stores parent of every vertex and for root its own index.\\n     * The root is technically not its own parent, but it's very practical\\n     * for the lowest common ancestor algorithm.\\n     */\\n    std::vector<int> parent;\\n    /** \\\\brief Stores the distance from the root. */\\n    std::vector<int> level;\\n    /** \\\\brief Index of the root vertex. */\\n    int root;\\n\\n protected:\\n    /**\\n     * \\\\brief Calculate the parents for all the vertices in the tree.\\n     * Implements the breadth first search algorithm starting from the root\\n     * vertex searching the entire tree and labeling parents for all vertices.\\n     * @returns none\\n     */\\n    void populate_parents() {\\n        // Initialize the vector with -1 which indicates the vertex\\n        // wasn't yet visited.\\n        parent = std::vector<int>(number_of_vertices(), -1);\\n        level = std::vector<int>(number_of_vertices());\\n        parent[root] = root;\\n        level[root] = 0;\\n        std::queue<int> queue_of_vertices;\\n        queue_of_vertices.push(root);\\n        while (!queue_of_vertices.empty()) {\\n            int vertex = queue_of_vertices.front();\\n            queue_of_vertices.pop();\\n            for (int neighbor : neighbors[vertex]) {\\n                // As long as the vertex was not yet visited.\\n                if (parent[neighbor] == -1) {\\n                    parent[neighbor] = vertex;\\n                    level[neighbor] = level[vertex] + 1;\\n                    queue_of_vertices.push(neighbor);\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * A structure that holds a rooted tree and allow for effecient\\n * queries of the lowest common ancestor of two given vertices in the tree.\\n */\\nclass LowestCommonAncestor {\\n public:\\n    /**\\n     * \\\\brief Stores the tree and precomputs \\\"up lifts\\\".\\n     * @param tree_ rooted tree.\\n     */\\n    explicit LowestCommonAncestor(const RootedTree &tree_) : tree(tree_) {\\n        populate_up();\\n    }\\n\\n    /**\\n     * \\\\brief Query the structure to find the lowest common ancestor.\\n     * Assumes that the provided numbers are valid indices of vertices.\\n     * Iterativelly modifies (\\\"lifts\\\") u an v until it finnds their lowest\\n     * common ancestor.\\n     * @param u index of one of the queried vertex\\n     * @param v index of the other queried vertex\\n     * @return index of the vertex which is the lowet common ancestor of u and v\\n     */\\n    int lowest_common_ancestor(int u, int v) const {\\n        // Ensure u is the deeper (higher level) of the two vertices\\n        if (tree.level[v] > tree.level[u]) {\\n            std::swap(u, v);\\n        }\\n\\n        // \\\"Lift\\\" u to the same level as v.\\n        int level_diff = tree.level[u] - tree.level[v];\\n        for (int i = 0; (1 << i) <= level_diff; ++i) {\\n            if (level_diff & (1 << i)) {\\n                u = up[u][i];\\n            }\\n        }\\n        assert(tree.level[u] == tree.level[v]);\\n\\n        if (u == v) {\\n            return u;\\n        }\\n\\n        // \\\"Lift\\\" u and v to their 2^i th ancestor if they are different\\n        for (int i = static_cast<int>(up[u].size()) - 1; i >= 0; --i) {\\n            if (up[u][i] != up[v][i]) {\\n                u = up[u][i];\\n                v = up[v][i];\\n            }\\n        }\\n\\n        // As we regressed u an v such that they cannot further be lifted so\\n        // that their ancestor would be different, the only logical\\n        // consequence is that their parent is the sought answer.\\n        assert(up[u][0] == up[v][0]);\\n        return up[u][0];\\n    }\\n\\n    /* \\\\brief reference to the rooted tree this structure allows to query */\\n    const RootedTree &tree;\\n    /**\\n     * \\\\brief for every vertex stores a list of its ancestors by powers of two\\n     * For each vertex, the first element of the corresponding list contains\\n     * the index of its parent. The i-th element of the list is an index of\\n     * the (2^i)-th ancestor of the vertex.\\n     */\\n    std::vector<std::vector<int> > up;\\n\\n protected:\\n    /**\\n     * Populate the \\\"up\\\" structure. See above.\\n     */\\n    void populate_up() {\\n        up.resize(tree.number_of_vertices());\\n        for (int vertex = 0; vertex < tree.number_of_vertices(); ++vertex) {\\n            up[vertex].push_back(tree.parent[vertex]);\\n        }\\n        for (int level = 0; (1 << level) < tree.number_of_vertices(); ++level) {\\n            for (int vertex = 0; vertex < tree.number_of_vertices(); ++vertex) {\\n                // up[vertex][level + 1] = 2^(level + 1) th ancestor of vertex =\\n                // = 2^level th ancestor of 2^level th ancestor of vertex =\\n                // = 2^level th ancestor of up[vertex][level]\\n                up[vertex].push_back(up[up[vertex][level]][level]);\\n            }\\n        }\\n    }\\n};\\n\\n}  // namespace graph\\n\\n/**\\n * Unit tests\\n * @returns none\\n */\\nstatic void tests() {\\n    /**\\n     *             _  3  _\\n     *          /     |     \\\\\\n     *        1       6       4\\n     *      / |     /   \\\\       \\\\\\n     *    7   5   2       8       0\\n     *            |\\n     *            9\\n     */\\n    std::vector<std::pair<int, int> > edges = {\\n        {7, 1}, {1, 5}, {1, 3}, {3, 6}, {6, 2}, {2, 9}, {6, 8}, {4, 3}, {0, 4}};\\n    graph::RootedTree t(edges, 3);\\n    graph::LowestCommonAncestor lca(t);\\n    assert(lca.lowest_common_ancestor(7, 4) == 3);\\n    assert(lca.lowest_common_ancestor(9, 6) == 6);\\n    assert(lca.lowest_common_ancestor(0, 0) == 0);\\n    assert(lca.lowest_common_ancestor(8, 2) == 6);\\n}\\n\\n/** Main function */\\nint main() {\\n    tests();\\n    return 0;\\n}\\n\"",
    "max flow with ford fulkerson and edmond karp algo": "\"/*\\n * Author: Amit Kumar\\n * Created: May 24, 2020\\n * Copyright: 2020, Open-Source\\n * Last Modified: May 25, 2020\\n */\\n#include <algorithm>\\n#include <bitset>\\n#include <cstring>\\n#include <iostream>\\n#include <limits>\\n#include <queue>\\n#include <tuple>\\n#include <utility>\\n#include <vector>\\n// std::max capacity of node in graph\\nconst int MAXN = 505;\\nclass Graph {\\n    std::vector<std::vector<int> > residual_capacity, capacity;\\n    int total_nodes = 0;\\n    int total_edges = 0, source = 0, sink = 0;\\n    std::vector<int> parent;\\n    std::vector<std::tuple<int, int, int> > edge_participated;\\n    std::bitset<MAXN> visited;\\n    int max_flow = 0;\\n    bool bfs(int source, int sink) {  //  to find the augmented - path\\n        visited.reset();\\n        std::queue<int> q;\\n        q.push(source);\\n        bool is_path_found = false;\\n        while (q.empty() == false && is_path_found == false) {\\n            int current_node = q.front();\\n            visited.set(current_node);\\n            q.pop();\\n            for (int i = 0; i < total_nodes; ++i) {\\n                if (residual_capacity[current_node][i] > 0 && !visited[i]) {\\n                    visited.set(i);\\n                    parent[i] = current_node;\\n                    if (i == sink) {\\n                        return true;\\n                    }\\n                    q.push(i);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n public:\\n    void set_graph() {\\n        std::cin >> total_nodes >> total_edges >> source >> sink;\\n        parent = std::vector<int>(total_nodes, -1);\\n        capacity = residual_capacity = std::vector<std::vector<int> >(\\n            total_nodes, std::vector<int>(total_nodes));\\n        for (int start = 0, destination = 0, capacity_ = 0, i = 0;\\n             i < total_edges; ++i) {\\n            std::cin >> start >> destination >> capacity_;\\n            residual_capacity[start][destination] = capacity_;\\n            capacity[start][destination] = capacity_;\\n        }\\n    }\\n    void ford_fulkerson() {\\n        while (bfs(source, sink)) {\\n            int current_node = sink;\\n            int flow = std::numeric_limits<int>::max();\\n            while (current_node != source) {\\n                int parent_ = parent[current_node];\\n                flow = std::min(flow, residual_capacity[parent_][current_node]);\\n                current_node = parent_;\\n            }\\n            current_node = sink;\\n            max_flow += flow;\\n            while (current_node != source) {\\n                int parent_ = parent[current_node];\\n                residual_capacity[parent_][current_node] -= flow;\\n                residual_capacity[current_node][parent_] += flow;\\n                current_node = parent_;\\n            }\\n        }\\n    }\\n    void print_flow_info() {\\n        for (int i = 0; i < total_nodes; ++i) {\\n            for (int j = 0; j < total_nodes; ++j) {\\n                if (capacity[i][j] &&\\n                    residual_capacity[i][j] < capacity[i][j]) {\\n                    edge_participated.emplace_back(std::make_tuple(\\n                        i, j, capacity[i][j] - residual_capacity[i][j]));\\n                }\\n            }\\n        }\\n        std::cout << \\\"\\\\nNodes : \\\" << total_nodes << \\\"\\\\nMax flow: \\\" << max_flow\\n                  << \\\"\\\\nEdge present in flow: \\\" << edge_participated.size()\\n                  << '\\\\n';\\n        std::cout << \\\"\\\\nSource\\\\tDestination\\\\tCapacity\\\\total_nodes\\\";\\n        for (auto& edge_data : edge_participated) {\\n            int source = 0, destination = 0, capacity_ = 0;\\n            std::tie(source, destination, capacity_) = edge_data;\\n            std::cout << source << \\\"\\\\t\\\" << destination << \\\"\\\\t\\\\t\\\" << capacity_\\n                      << '\\\\t';\\n        }\\n    }\\n};\\nint main() {\\n    /*\\n       Input Graph: (for testing )\\n        4 5 0 3\\n        0 1 10\\n        1 2 1\\n        1 3 1\\n        0 2 1\\n        2 3 10\\n     */\\n    Graph graph;\\n    graph.set_graph();\\n    graph.ford_fulkerson();\\n    graph.print_flow_info();\\n    return 0;\\n}\\n\"",
    "prim": "\"// C++ program to implement Prim's Algorithm\\n#include <iostream>\\n#include <queue>\\n#include <vector>\\n\\nusing PII = std::pair<int, int>;\\n\\nint prim(int x, const std::vector<std::vector<PII> > &graph) {\\n    // priority queue to maintain edges with respect to weights\\n    std::priority_queue<PII, std::vector<PII>, std::greater<PII> > Q;\\n    std::vector<bool> marked(graph.size(), false);\\n    int minimum_cost = 0;\\n\\n    Q.push(std::make_pair(0, x));\\n    while (!Q.empty()) {\\n        // Select the edge with minimum weight\\n        PII p = Q.top();\\n        Q.pop();\\n        x = p.second;\\n        // Checking for cycle\\n        if (marked[x] == true) {\\n            continue;\\n        }\\n        minimum_cost += p.first;\\n        marked[x] = true;\\n        for (const PII &neighbor : graph[x]) {\\n            int y = neighbor.second;\\n            if (marked[y] == false) {\\n                Q.push(neighbor);\\n            }\\n        }\\n    }\\n    return minimum_cost;\\n}\\n\\nint main() {\\n    int nodes = 0, edges = 0;\\n    std::cin >> nodes >> edges;  // number of nodes & edges in graph\\n    if (nodes == 0 || edges == 0) {\\n        return 0;\\n    }\\n\\n    std::vector<std::vector<PII> > graph(nodes);\\n\\n    // Edges with their nodes & weight\\n    for (int i = 0; i < edges; ++i) {\\n        int x = 0, y = 0, weight = 0;\\n        std::cin >> x >> y >> weight;\\n        graph[x].push_back(std::make_pair(weight, y));\\n        graph[y].push_back(std::make_pair(weight, x));\\n    }\\n\\n    // Selecting 1 as the starting node\\n    int minimum_cost = prim(1, graph);\\n    std::cout << minimum_cost << std::endl;\\n    return 0;\\n}\\n\"",
    "topological sort": "\"#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n\\nint number_of_vertices,\\n    number_of_edges;  // For number of Vertices (V) and number of edges (E)\\nstd::vector<std::vector<int>> graph;\\nstd::vector<bool> visited;\\nstd::vector<int> topological_order;\\n\\nvoid dfs(int v) {\\n    visited[v] = true;\\n    for (int u : graph[v]) {\\n        if (!visited[u]) {\\n            dfs(u);\\n        }\\n    }\\n    topological_order.push_back(v);\\n}\\n\\nvoid topological_sort() {\\n    visited.assign(number_of_vertices, false);\\n    topological_order.clear();\\n    for (int i = 0; i < number_of_vertices; ++i) {\\n        if (!visited[i]) {\\n            dfs(i);\\n        }\\n    }\\n    reverse(topological_order.begin(), topological_order.end());\\n}\\nint main() {\\n    std::cout\\n        << \\\"Enter the number of vertices and the number of directed edges\\\\n\\\";\\n    std::cin >> number_of_vertices >> number_of_edges;\\n    int x = 0, y = 0;\\n    graph.resize(number_of_vertices, std::vector<int>());\\n    for (int i = 0; i < number_of_edges; ++i) {\\n        std::cin >> x >> y;\\n        x--, y--;  // to convert 1-indexed to 0-indexed\\n        graph[x].push_back(y);\\n    }\\n    topological_sort();\\n    std::cout << \\\"Topological Order : \\\\n\\\";\\n    for (int v : topological_order) {\\n        std::cout << v + 1\\n                  << ' ';  // converting zero based indexing back to one based.\\n    }\\n    std::cout << '\\\\n';\\n    return 0;\\n}\\n\"",
    "topological sort by kahns algo": "\"#include <cstdio>\\n#include <cstring>\\n#include <iostream>\\n#include <queue>\\n#include <vector>\\n\\nstd::vector<int> topoSortKahn(int N, const std::vector<std::vector<int> > &adj);\\n\\nint main() {\\n    int nodes = 0, edges = 0;\\n    std::cin >> edges >> nodes;\\n    if (edges == 0 || nodes == 0) {\\n        return 0;\\n    }\\n    int u = 0, v = 0;\\n\\n    std::vector<std::vector<int> > graph(nodes);\\n    // create graph\\n    // example\\n    // 6 6\\n    // 5 0 5 2 2 3 4 0 4 1 1 3\\n\\n    for (int i = 0; i < edges; i++) {\\n        std::cin >> u >> v;\\n        graph[u].push_back(v);\\n    }\\n\\n    std::vector<int> topo = topoSortKahn(nodes, graph);\\n    // topologically sorted nodes\\n    for (int i = 0; i < nodes; i++) {\\n        std::cout << topo[i] << \\\" \\\";\\n    }\\n}\\n\\nstd::vector<int> topoSortKahn(int V,\\n                              const std::vector<std::vector<int> > &adj) {\\n    std::vector<bool> vis(V + 1, false);\\n    std::vector<int> deg(V + 1, 0);\\n    for (int i = 0; i < V; i++) {\\n        for (int j : adj[i]) {\\n            deg[j]++;\\n        }\\n    }\\n    std::queue<int> q;\\n    for (int i = 0; i < V; i++) {\\n        if (deg[i] == 0) {\\n            q.push(i);\\n            vis[i] = true;\\n        }\\n    }\\n    std::vector<int> arr(V + 1, 0);\\n    int count = 0;\\n    while (!q.empty()) {\\n        int cur = q.front();\\n        q.pop();\\n        arr[count++] = cur;\\n        for (int i : adj[cur]) {\\n            if (!vis[i]) {\\n                deg[i]--;\\n                if (deg[i] == 0) {\\n                    q.push(i);\\n                    vis[i] = true;\\n                }\\n            }\\n        }\\n    }\\n    return arr;\\n}\\n\"",
    "travelling salesman problem": "\"/**\\n * @file\\n * @brief [Travelling Salesman Problem]\\n * (https://en.wikipedia.org/wiki/Travelling_salesman_problem) implementation\\n *\\n * @author [Mayank Mamgain](http://github.com/Mayank17M)\\n *\\n * @details\\n * Travelling salesman problem asks:\\n * Given a list of cities and the distances between each pair of cities, what is\\n * the shortest possible route that visits each city exactly once and returns to\\n * the origin city?\\n * TSP can be modeled as an undirected weighted graph, such that cities are the\\n * graph's vertices, paths are the graph's edges, and a path's distance is the\\n * edge's weight. It is a minimization problem starting and finishing at a\\n * specified vertex after having visited each other vertex exactly once.\\n * This is the naive implementation of the problem.\\n */\\n\\n#include <algorithm>  /// for std::min\\n#include <cassert>    /// for assert\\n#include <iostream>   /// for IO operations\\n#include <limits>     /// for limits of integral types\\n#include <vector>     /// for std::vector\\n\\n/**\\n * @namespace graph\\n * @brief Graph Algorithms\\n */\\nnamespace graph {\\n/**\\n * @brief Function calculates the minimum path distance that will cover all the\\n * cities starting from the source.\\n *\\n * @param cities matrix representation of cities\\n * @param src Point from where salesman is starting\\n * @param V number of vertices in the graph\\n *\\n */\\nint TravellingSalesmanProblem(std::vector<std::vector<uint32_t>> *cities,\\n                              int32_t src, uint32_t V) {\\n    //// vtx stores the vertexs of the graph\\n    std::vector<uint32_t> vtx;\\n    for (uint32_t i = 0; i < V; i++) {\\n        if (i != src) {\\n            vtx.push_back(i);\\n        }\\n    }\\n\\n    //// store minimum weight Hamiltonian Cycle.\\n    int32_t min_path = 2147483647;\\n    do {\\n        //// store current Path weight(cost)\\n        int32_t curr_weight = 0;\\n\\n        //// compute current path weight\\n        int k = src;\\n        for (int i : vtx) {\\n            curr_weight += (*cities)[k][i];\\n            k = i;\\n        }\\n        curr_weight += (*cities)[k][src];\\n\\n        //// update minimum\\n        min_path = std::min(min_path, curr_weight);\\n\\n    } while (next_permutation(vtx.begin(), vtx.end()));\\n\\n    return min_path;\\n}\\n}  // namespace graph\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void tests() {\\n    std::cout << \\\"Initiatinig Predefined Tests...\\\" << std::endl;\\n    std::cout << \\\"Initiating Test 1...\\\" << std::endl;\\n    std::vector<std::vector<uint32_t>> cities = {\\n        {0, 20, 42, 35}, {20, 0, 30, 34}, {42, 30, 0, 12}, {35, 34, 12, 0}};\\n    uint32_t V = cities.size();\\n    assert(graph::TravellingSalesmanProblem(&cities, 0, V) == 97);\\n    std::cout << \\\"1st test passed...\\\" << std::endl;\\n\\n    std::cout << \\\"Initiating Test 2...\\\" << std::endl;\\n    cities = {{0, 5, 10, 15}, {5, 0, 20, 30}, {10, 20, 0, 35}, {15, 30, 35, 0}};\\n    V = cities.size();\\n    assert(graph::TravellingSalesmanProblem(&cities, 0, V) == 75);\\n    std::cout << \\\"2nd test passed...\\\" << std::endl;\\n\\n    std::cout << \\\"Initiating Test 3...\\\" << std::endl;\\n    cities = {\\n        {0, 10, 15, 20}, {10, 0, 35, 25}, {15, 35, 0, 30}, {20, 25, 30, 0}};\\n    V = cities.size();\\n    assert(graph::TravellingSalesmanProblem(&cities, 0, V) == 80);\\n    std::cout << \\\"3rd test passed...\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    tests();  // run self-test implementations\\n    std::vector<std::vector<uint32_t>> cities = {\\n        {0, 5, 10, 15}, {5, 0, 20, 30}, {10, 20, 0, 35}, {15, 30, 35, 0}};\\n    uint32_t V = cities.size();\\n    std::cout << graph::TravellingSalesmanProblem(&cities, 0, V) << std::endl;\\n    return 0;\\n}\\n\"",
    "spirograph": "\"/**\\n * @file\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Implementation of\\n * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)\\n *\\n * @details\\n * Implementation of the program is based on the geometry shown in the figure\\n * below:\\n *\\n * <a\\n * href=\\\"https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg\\\"><img\\n * src=\\\"https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg\\\"\\n * alt=\\\"Spirograph geometry from Wikipedia\\\" style=\\\"width: 250px\\\"/></a>\\n */\\n#ifdef USE_GLUT\\n#ifdef __APPLE__\\n#include <GLUT/glut.h>  // include path on Macs is different\\n#else\\n#include <GL/glut.h>\\n#endif  // __APPLE__\\n#endif\\n#define _USE_MATH_DEFINES /**< required for MSVC compiler */\\n#include <array>\\n#include <cmath>\\n#include <cstdlib>\\n#include <ctime>\\n#include <fstream>\\n#include <iomanip>\\n#include <iostream>\\n#include <sstream>\\n#ifdef _OPENMP\\n#include <omp.h>\\n#endif\\n\\n/**\\n * @namespace spirograph Functions related to spirograph.cpp\\n */\\nnamespace spirograph {\\n/** Generate spirograph curve into arrays `x` and `y` such that the i^th point\\n * in 2D is represented by `(x[i],y[i])`. The generating function is given by:\\n * \\\\f{eqnarray*}{\\n * x &=& R\\\\left[ (1-k) \\\\cos (t) + l\\\\cdot k\\\\cdot\\\\cos \\\\left(\\\\frac{1-k}{k}t\\\\right)\\n * \\\\right]\\\\\\\\\\n * y &=& R\\\\left[ (1-k) \\\\sin (t) - l\\\\cdot k\\\\cdot\\\\sin \\\\left(\\\\frac{1-k}{k}t\\\\right)\\n * \\\\right] \\\\f}\\n * where\\n * * \\\\f$R\\\\f$ is the scaling parameter that we will consider \\\\f$=1\\\\f$\\n * * \\\\f$l=\\\\frac{\\\\rho}{r}\\\\f$ is the relative distance of marker from the centre\\n * of inner circle and \\\\f$0\\\\le l\\\\le1\\\\f$\\n * * \\\\f$\\\\rho\\\\f$ is physical distance of marker from centre of inner circle\\n * * \\\\f$r\\\\f$ is the radius of inner circle\\n * * \\\\f$k=\\\\frac{r}{R}\\\\f$ is the ratio of radius of inner circle to outer circle\\n * and \\\\f$0<k<1\\\\f$\\n * * \\\\f$R\\\\f$ is the radius of outer circle\\n * * \\\\f$t\\\\f$ is the angle of rotation of the point i.e., represents the time\\n * parameter\\n *\\n * Since we are considering ratios, the actual values of \\\\f$r\\\\f$ and\\n * \\\\f$R\\\\f$ are immaterial.\\n *\\n * @tparam N number of points = size of array\\n * @param [out] points Array of 2D points represented as std::pair\\n * @param l the relative distance of marker from the centre of\\n * inner circle and \\\\f$0\\\\le l\\\\le1\\\\f$\\n * @param k the ratio of radius of inner circle to outer circle and \\\\f$0<k<1\\\\f$\\n * @param rot the number of rotations to perform (can be fractional value)\\n */\\ntemplate <std::size_t N>\\nvoid spirograph(std::array<std::pair<double, double>, N> *points, double l,\\n                double k, double rot) {\\n    double dt = rot * 2.f * M_PI / N;\\n    double R = 1.f;\\n    const double k1 = 1.f - k;\\n    int32_t step = 0;\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (step = 0; step < N; step++) {\\n        double t = dt * step;\\n        double first = R * (k1 * std::cos(t) + l * k * std::cos(k1 * t / k));\\n        double second = R * (k1 * std::sin(t) - l * k * std::sin(k1 * t / k));\\n        points[0][step].first = first;\\n        points[0][step].second = second;\\n    }\\n}\\n\\n/**\\n * @brief Test function to save resulting points to a CSV file.\\n *\\n */\\nvoid test() {\\n    const size_t N = 500;\\n    double l = 0.3, k = 0.75, rot = 10.;\\n    std::stringstream fname;\\n    fname << std::setw(3) << \\\"spirograph_\\\" << l << \\\"_\\\" << k << \\\"_\\\" << rot\\n          << \\\".csv\\\";\\n    std::ofstream fp(fname.str());\\n    if (!fp.is_open()) {\\n        perror(fname.str().c_str());\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    std::array<std::pair<double, double>, N> points;\\n\\n    spirograph(&points, l, k, rot);\\n\\n    for (size_t i = 0; i < N; i++) {\\n        fp << points[i].first << \\\",\\\" << points[i].first;\\n        if (i < N - 1) {\\n            fp << '\\\\n';\\n        }\\n    }\\n\\n    fp.close();\\n}\\n\\n#ifdef USE_GLUT\\nstatic bool paused = 0; /**< flag to set pause/unpause animation */\\nstatic const int animation_speed = 25; /**< animation delate in ms */\\n\\nstatic const double step = 0.01;   /**< animation step size */\\nstatic double l_ratio = step * 10; /**< the l-ratio defined in docs */\\nstatic double k_ratio = step;      /**< the k-ratio defined in docs */\\nstatic const double num_rot = 20.; /**< number of rotations to simulate */\\n\\n/** A wrapper that is not available in all GLUT implementations.\\n */\\nstatic inline void glutBitmapString(void *font, char *message) {\\n    for (char *ch = message; *ch != '\\\\0'; ch++) glutBitmapCharacter(font, *ch);\\n}\\n\\n/**\\n * @brief Function to graph (x,y) points on the OpenGL graphics window.\\n *\\n * @tparam N number of points = size of array\\n * @param [in] points Array of 2D points represented as std::pair\\n * @param l the relative distance of marker from the centre of\\n * inner circle and \\\\f$0\\\\le l\\\\le1\\\\f$ to display info\\n * @param k the ratio of radius of inner circle to outer circle and \\\\f$0<k<1\\\\f$\\n * to display info\\n */\\ntemplate <size_t N>\\nvoid display_graph(const std::array<std::pair<double, double>, N> &points,\\n                   double l, double k) {\\n    glClearColor(1.0f, 1.0f, 1.0f,\\n                 0.0f);            // Set background color to white and opaque\\n    glClear(GL_COLOR_BUFFER_BIT);  // Clear the color buffer (background)\\n\\n    glBegin(GL_LINES);         // draw line segments\\n    glColor3f(0.f, 0.f, 1.f);  // blue\\n    glPointSize(2.f);          // point size in pixels\\n\\n    for (size_t i = 1; i < N; i++) {\\n        glVertex2f(points[i - 1].first, points[i - 1].second);  // line from\\n        glVertex2f(points[i].first, points[i].second);          // line to\\n    }\\n    glEnd();\\n\\n    glColor3f(0.f, 0.f, 0.f);\\n    std::stringstream buffer;\\n    buffer << std::setw(3) << \\\"l = \\\" << l;\\n    glRasterPos2f(-.85, .85);\\n    glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24,\\n                     const_cast<char *>(buffer.str().c_str()));\\n    buffer.str(\\\"\\\");\\n    buffer.clear();\\n    buffer << std::setw(3) << \\\"k = \\\" << k;\\n    glRasterPos2f(-.85, .70);\\n    glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24,\\n                     const_cast<char *>(buffer.str().c_str()));\\n\\n    glutSwapBuffers();\\n}\\n\\n/**\\n * @brief Test function with animation\\n *\\n */\\nvoid test2() {\\n    const size_t N = 5000;  // number of samples\\n\\n    static bool direction1 = true;  // increment if true, otherwise decrement\\n    static bool direction2 = true;  // increment if true, otherwise decrement\\n\\n    std::array<std::pair<double, double>, N> points;\\n\\n    spirograph(&points, l_ratio, k_ratio, num_rot);\\n    display_graph(points, l_ratio, k_ratio);\\n\\n    if (paused)\\n        // if paused, do not update l_ratio and k_ratio\\n        return;\\n\\n    if (direction1) {                 // increment k_ratio\\n        if (k_ratio >= (1.f - step))  // maximum limit\\n            direction1 = false;       // reverse direction of k_ratio\\n        else\\n            k_ratio += step;\\n    } else {                    // decrement k_ratio\\n        if (k_ratio <= step) {  // minimum limit\\n            direction1 = true;  // reverse direction of k_ratio\\n\\n            if (direction2) {                 // increment l_ratio\\n                if (l_ratio >= (1.f - step))  // max limit of l_ratio\\n                    direction2 = false;       // reverse direction of l_ratio\\n                else\\n                    l_ratio += step;\\n            } else {                    // decrement l_ratio\\n                if (l_ratio <= step)    // minimum limit of l_ratio\\n                    direction2 = true;  // reverse direction of l_ratio\\n                else\\n                    l_ratio -= step;\\n            }\\n        } else {  // no min limit of k_ratio\\n            k_ratio -= step;\\n        }\\n    }\\n}\\n\\n/**\\n * @brief GLUT timer callback function to add animation delay.\\n */\\nvoid timer_cb(int t) {\\n    glutTimerFunc(animation_speed, timer_cb, 0);\\n    glutPostRedisplay();\\n}\\n\\n/**\\n * @brief Keypress event call back function.\\n *\\n * @param key ID of the key pressed\\n * @param x mouse pointer position at event\\n * @param y mouse pointer position at event\\n */\\nvoid keyboard_cb(unsigned char key, int x, int y) {\\n    switch (key) {\\n        case ' ':              // spacebar toggles pause\\n            paused = !paused;  // toggle\\n            break;\\n        case GLUT_KEY_UP:\\n        case '+':  // up arrow key\\n            k_ratio += step;\\n            break;\\n        case GLUT_KEY_DOWN:\\n        case '_':  // down arrow key\\n            k_ratio -= step;\\n            break;\\n        case GLUT_KEY_RIGHT:\\n        case '=':  // left arrow key\\n            l_ratio += step;\\n            break;\\n        case GLUT_KEY_LEFT:\\n        case '-':  // right arrow key\\n            l_ratio -= step;\\n            break;\\n        case 0x1B:  // escape key exits\\n            exit(EXIT_SUCCESS);\\n        default:\\n            return;\\n    }\\n}\\n#endif\\n}  // namespace spirograph\\n\\n/** Main function */\\nint main(int argc, char **argv) {\\n    spirograph::test();\\n\\n#ifdef USE_GLUT\\n    glutInit(&argc, argv);\\n    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);\\n    glutCreateWindow(\\\"Spirograph\\\");\\n    glutInitWindowSize(400, 400);\\n    // glutIdleFunc(glutPostRedisplay);\\n    glutTimerFunc(spirograph::animation_speed, spirograph::timer_cb, 0);\\n    glutKeyboardFunc(spirograph::keyboard_cb);\\n    glutDisplayFunc(spirograph::test2);\\n    glutMainLoop();\\n#endif\\n\\n    return 0;\\n}\\n\"",
    "huffman": "\"// C++ program for Huffman Coding\\n#include <iostream>\\n#include <queue>\\nusing namespace std;\\n\\n// A Huffman tree node\\nstruct MinHeapNode {\\n    // One of the input characters\\n    char data;\\n\\n    // Frequency of the character\\n    unsigned freq;\\n\\n    // Left and right child\\n    MinHeapNode *left, *right;\\n\\n    MinHeapNode(char data, unsigned freq)\\n\\n    {\\n        left = right = NULL;\\n        this->data = data;\\n        this->freq = freq;\\n    }\\n};\\n\\n// For comparison of\\n// two heap nodes (needed in min heap)\\nstruct compare {\\n    bool operator()(MinHeapNode* l, MinHeapNode* r)\\n\\n    {\\n        return (l->freq > r->freq);\\n    }\\n};\\n\\n// Prints huffman codes from\\n// the root of Huffman Tree.\\nvoid printCodes(struct MinHeapNode* root, string str) {\\n    if (!root)\\n        return;\\n\\n    if (root->data != '$')\\n        cout << root->data << \\\": \\\" << str << \\\"\\\\n\\\";\\n\\n    printCodes(root->left, str + \\\"0\\\");\\n    printCodes(root->right, str + \\\"1\\\");\\n}\\n\\n// The main function that builds a Huffman Tree and\\n// print codes by traversing the built Huffman Tree\\nvoid HuffmanCodes(char data[], int freq[], int size) {\\n    struct MinHeapNode *left, *right, *top;\\n\\n    // Create a min heap & inserts all characters of data[]\\n    priority_queue<MinHeapNode*, vector<MinHeapNode*>, compare> minHeap;\\n\\n    for (int i = 0; i < size; ++i)\\n        minHeap.push(new MinHeapNode(data[i], freq[i]));\\n\\n    // Iterate while size of heap doesn't become 1\\n    while (minHeap.size() != 1) {\\n        // Extract the two minimum\\n        // freq items from min heap\\n        left = minHeap.top();\\n        minHeap.pop();\\n\\n        right = minHeap.top();\\n        minHeap.pop();\\n\\n        // Create a new internal node with\\n        // frequency equal to the sum of the\\n        // two nodes frequencies. Make the\\n        // two extracted node as left and right children\\n        // of this new node. Add this node\\n        // to the min heap '$' is a special value\\n        // for internal nodes, not used\\n        top = new MinHeapNode('$', left->freq + right->freq);\\n\\n        top->left = left;\\n        top->right = right;\\n\\n        minHeap.push(top);\\n    }\\n\\n    // Print Huffman codes using\\n    // the Huffman tree built above\\n    printCodes(minHeap.top(), \\\"\\\");\\n}\\n\\n// Driver program to test above functions\\nint main() {\\n    char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'};\\n    int freq[] = {5, 9, 12, 13, 16, 45};\\n\\n    int size = sizeof(arr) / sizeof(arr[0]);\\n\\n    HuffmanCodes(arr, freq, size);\\n\\n    return 0;\\n}\\n\"",
    "jumpgame": "\"/**\\n * @file\\n * @brief Implementation of an algorithm to solve the [jumping game]((https://leetcode.com/problems/jump-game/)) problem\\n * @details\\n * **Problem statement:** Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.\\n * This solution takes in input as a vector and output as a boolean to check if you can reach the last position.\\n * We name the indices good and bad based on whether we can reach the destination if we start at that position.\\n * We initialize the last index as lastPos.\\n * Here, we start from the end of the array and check if we can ever reach the first index.\\n * We check if the sum of the index and the maximum jump count given is greater than or equal to the lastPos.\\n * If yes, then that is the last position you can reach starting from the back.\\n * After the end of the loop, if we reach the lastPos as 0, then the destination can be reached from the start position.\\n * @author [Rakshaa Viswanathan](https://github.com/rakshaa2000)\\n*/\\n\\n#include <vector>\\n#include <iostream>\\n#include <cassert>\\n\\n\\n /**\\n * @brief This function implements the above algorithm\\n * @param array of numbers containing the maximum jump (in steps) from that index\\n * @returns bool value whether final index can be reached or not\\n */  \\nbool canJump(const std::vector<int> &nums) {\\n    auto lastPos = nums.size() - 1;\\n    for (auto i = nums.size() - 1; i >= 0; i--) {\\n        if (i + nums[i] >= lastPos) {\\n            lastPos = i;\\n        }\\n    }\\n    return lastPos == 0;\\n}\\n\\n\\n/**\\n * @brief Function to test above algorithm\\n * @returns void\\n */\\nstatic void test(){\\n  // Test 1\\n  std::vector<int> num1={4,3,1,0,5};\\n  assert(canJump(num1)==true);\\n  std::cout<<\\\"Input: \\\";\\n  for(auto i: num1){\\n    std::cout<<i<<\\\" \\\";\\n  }\\n  std::cout<<\\\"Output: true\\\"<<std::endl;\\n  // Test 2\\n  std::vector<int> num2={3,2,1,0,4};\\n  assert(canJump(num2)==false);\\n  std::cout<<\\\"Input: \\\";\\n  for(auto i: num2){\\n    std::cout<<i<<\\\" \\\";\\n  }\\n  std::cout<<\\\"Output: false\\\"<<std::endl;\\n}\\n\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main(){\\n    test();\\n    return 0;\\n}\\n\"",
    "knapsack": "\"#include <iostream>\\nusing namespace std;\\n\\nstruct Item {\\n    int weight;\\n    int profit;\\n};\\n\\nfloat profitPerUnit(Item x) { return (float)x.profit / (float)x.weight; }\\n\\nint partition(Item arr[], int low, int high) {\\n    Item pivot = arr[high];  // pivot\\n    int i = (low - 1);       // Index of smaller element\\n\\n    for (int j = low; j < high; j++) {\\n        // If current element is smaller than or\\n        // equal to pivot\\n        if (profitPerUnit(arr[j]) <= profitPerUnit(pivot)) {\\n            i++;  // increment index of smaller element\\n            Item temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n        }\\n    }\\n    Item temp = arr[i + 1];\\n    arr[i + 1] = arr[high];\\n    arr[high] = temp;\\n    return (i + 1);\\n}\\n\\nvoid quickSort(Item arr[], int low, int high) {\\n    if (low < high) {\\n        int p = partition(arr, low, high);\\n\\n        quickSort(arr, low, p - 1);\\n        quickSort(arr, p + 1, high);\\n    }\\n}\\n\\nint main() {\\n    cout << \\\"\\\\nEnter the capacity of the knapsack : \\\";\\n    float capacity;\\n    cin >> capacity;\\n    cout << \\\"\\\\n Enter the number of Items : \\\";\\n    int n;\\n    cin >> n;\\n    Item itemArray[n];\\n    for (int i = 0; i < n; i++) {\\n        cout << \\\"\\\\nEnter the weight and profit of item \\\" << i + 1 << \\\" : \\\";\\n        cin >> itemArray[i].weight;\\n        cin >> itemArray[i].profit;\\n    }\\n\\n    quickSort(itemArray, 0, n - 1);\\n\\n    // show(itemArray, n);\\n\\n    float maxProfit = 0;\\n    int i = n;\\n    while (capacity > 0 && --i >= 0) {\\n        if (capacity >= itemArray[i].weight) {\\n            maxProfit += itemArray[i].profit;\\n            capacity -= itemArray[i].weight;\\n            cout << \\\"\\\\n\\\\t\\\" << itemArray[i].weight << \\\"\\\\t\\\"\\n                 << itemArray[i].profit;\\n        } else {\\n            maxProfit += profitPerUnit(itemArray[i]) * capacity;\\n            cout << \\\"\\\\n\\\\t\\\" << capacity << \\\"\\\\t\\\"\\n                 << profitPerUnit(itemArray[i]) * capacity;\\n            capacity = 0;\\n            break;\\n        }\\n    }\\n\\n    cout << \\\"\\\\nMax Profit : \\\" << maxProfit;\\n\\n    return 0;\\n}\\n\"",
    "kruskals minimum spanning tree": "\"#include <array>\\n#include <iostream>\\n\\nvoid findMinimumEdge(int INFINITY, std::array<std::array<int, 6>, 6> graph) {\\n    for (int i = 0; i < graph.size(); i++) {\\n        int min = INFINITY;\\n        int minIndex = 0;\\n        for (int j = 0; j < graph.size(); j++) {\\n            if (graph[i][j] != 0 && graph[i][j] < min) {\\n                min = graph[i][j];\\n                minIndex = j;\\n            }\\n        }\\n        std::cout << i << \\\"  -  \\\" << minIndex << \\\"\\\\t\\\" << graph[i][minIndex]\\n                  << std::endl;\\n    }\\n}\\n\\nint main() {\\n    constexpr int INFINITY = 99999;\\n    std::array<std::array<int, 6>, 6> graph{\\n        0,        4,        1,        4,        INFINITY, INFINITY,\\n        4,        0,        3,        8,        3,        INFINITY,\\n        1,        3,        0,        INFINITY, 1,        INFINITY,\\n        4,        8,        INFINITY, 0,        5,        7,\\n        INFINITY, 3,        1,        5,        0,        INFINITY,\\n        INFINITY, INFINITY, INFINITY, 7,        INFINITY, 0};\\n\\n    findMinimumEdge(INFINITY, graph);\\n    return 0;\\n}\\n\"",
    "prims minimum spanning tree": "\"#include <iostream>\\nusing namespace std;\\n\\n#define V 4\\n#define INFINITY 99999\\n\\nint graph[V][V] = {{0, 5, 1, 2}, {5, 0, 3, 3}, {1, 3, 0, 4}, {2, 3, 4, 0}};\\n\\nstruct mst {\\n    bool visited;\\n    int key;\\n    int near;\\n};\\n\\nmst MST_Array[V];\\n\\nvoid initilize() {\\n    for (int i = 0; i < V; i++) {\\n        MST_Array[i].visited = false;\\n        MST_Array[i].key = INFINITY;  // considering INFINITY as inifinity\\n        MST_Array[i].near = i;\\n    }\\n\\n    MST_Array[0].key = 0;\\n}\\n\\nvoid updateNear() {\\n    for (int v = 0; v < V; v++) {\\n        int min = INFINITY;\\n        int minIndex = 0;\\n        for (int i = 0; i < V; i++) {\\n            if (MST_Array[i].key < min && MST_Array[i].visited == false &&\\n                MST_Array[i].key != INFINITY) {\\n                min = MST_Array[i].key;\\n                minIndex = i;\\n            }\\n        }\\n\\n        MST_Array[minIndex].visited = true;\\n\\n        for (int i = 0; i < V; i++) {\\n            if (graph[minIndex][i] != 0 && graph[minIndex][i] < INFINITY) {\\n                if (graph[minIndex][i] < MST_Array[i].key) {\\n                    MST_Array[i].key = graph[minIndex][i];\\n                    MST_Array[i].near = minIndex;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nvoid show() {\\n    for (int i = 0; i < V; i++) {\\n        cout << i << \\\"  -  \\\" << MST_Array[i].near << \\\"\\\\t\\\"\\n             << graph[i][MST_Array[i].near] << \\\"\\\\n\\\";\\n    }\\n}\\n\\nint main() {\\n    initilize();\\n    updateNear();\\n    show();\\n    return 0;\\n}\\n\"",
    "chaining": "\"/**\\n * @file chaining.cpp\\n * @author [vasutomar](https://github.com/vasutomar)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Implementation of [hash\\n * chains](https://en.wikipedia.org/wiki/Hash_chain).\\n */\\n#include <cmath>\\n#include <iostream>\\n#include <memory>\\n#include <vector>\\n\\n/**\\n * @brief Chain class with a given modulus\\n */\\nclass hash_chain {\\n private:\\n    /**\\n     * @brief Define a linked node\\n     */\\n    using Node = struct Node {\\n        int data{};                         ///< data stored in the node\\n        std::shared_ptr<struct Node> next;  ///< pointer to the next node\\n    };\\n\\n    std::vector<std::shared_ptr<Node>> head;  ///< array of nodes\\n    int _mod;                                 ///< modulus of the class\\n\\n public:\\n    /**\\n     * @brief Construct a new chain object\\n     *\\n     * @param mod modulus of the chain\\n     */\\n    explicit hash_chain(int mod) : _mod(mod) {\\n        while (mod--) head.push_back(nullptr);\\n    }\\n\\n    /**\\n     * @brief create and add a new node with a give value and at a given height\\n     *\\n     * @param x value at the new node\\n     * @param h height of the node\\n     */\\n    void add(int x, int h) {\\n        std::shared_ptr<Node> curr;\\n        std::shared_ptr<Node> temp(new Node);\\n        temp->data = x;\\n        temp->next = nullptr;\\n        if (!head[h]) {\\n            head[h] = temp;\\n            curr = head[h];\\n        } else {\\n            curr = head[h];\\n            while (curr->next) curr = curr->next;\\n            curr->next = temp;\\n        }\\n    }\\n\\n    /**\\n     * @brief Display the chain\\n     */\\n    void display() {\\n        std::shared_ptr<Node> temp = nullptr;\\n        int i = 0;\\n        for (i = 0; i < _mod; i++) {\\n            if (!head[i]) {\\n                std::cout << \\\"Key \\\" << i << \\\" is empty\\\" << std::endl;\\n            } else {\\n                std::cout << \\\"Key \\\" << i << \\\" has values = \\\" << std::endl;\\n                temp = head[i];\\n                while (temp->next) {\\n                    std::cout << temp->data << \\\" \\\" << std::endl;\\n                    temp = temp->next;\\n                }\\n                std::cout << temp->data;\\n                std::cout << std::endl;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @brief Compute the hash of a value for current chain\\n     *\\n     * @param x value to compute modulus of\\n     * @return modulus of `x`\\n     * @note declared as a\\n     * [`virtual`](https://en.cppreference.com/w/cpp/language/virtual) so that\\n     * custom implementations of the class can modify the hash function.\\n     */\\n    virtual int hash(int x) const { return x % _mod; }\\n\\n    /**\\n     * @brief Find if a value and corresponding hash exist\\n     *\\n     * @param x value to search for\\n     * @param h corresponding hash key\\n     * @returns `true` if element found\\n     * @returns `false` if element not found\\n     */\\n    bool find(int x, int h) const {\\n        std::shared_ptr<Node> temp = head[h];\\n        if (!head[h]) {\\n            // index does not exist!\\n            std::cout << \\\"Element not found\\\" << std::endl;\\n            return false;\\n        }\\n\\n        // scan for data value\\n        while (temp->data != x && temp->next) temp = temp->next;\\n\\n        if (temp->next) {\\n            std::cout << \\\"Element found\\\" << std::endl;\\n            return true;\\n        }\\n\\n        // implicit else condition\\n        // i.e., temp->next == nullptr\\n        if (temp->data == x) {\\n            std::cout << \\\"Element found\\\" << std::endl;\\n            return true;\\n        }\\n\\n        // further implicit else condition\\n        std::cout << \\\"Element not found\\\" << std::endl;\\n        return false;\\n    }\\n};\\n\\n/** Main function\\n * @returns `0` always\\n */\\nint main() {\\n    int c = 0, x = 0, mod = 0, h = 0;\\n    std::cout << \\\"Enter the size of Hash Table. = \\\" << std::endl;\\n    std::cin >> mod;\\n\\n    hash_chain mychain(mod);\\n\\n    bool loop = true;\\n    while (loop) {\\n        std::cout << std::endl;\\n        std::cout << \\\"PLEASE CHOOSE -\\\" << std::endl;\\n        std::cout << \\\"1. Add element.\\\" << std::endl;\\n        std::cout << \\\"2. Find element.\\\" << std::endl;\\n        std::cout << \\\"3. Generate Hash.\\\" << std::endl;\\n        std::cout << \\\"4. Display Hash table.\\\" << std::endl;\\n        std::cout << \\\"5. Exit.\\\" << std::endl;\\n        std::cin >> c;\\n        switch (c) {\\n            case 1:\\n                std::cout << \\\"Enter element to add = \\\" << std::endl;\\n                std::cin >> x;\\n                h = mychain.hash(x);\\n                h = std::abs(h);\\n                mychain.add(x, h);\\n                break;\\n            case 2:\\n                std::cout << \\\"Enter element to search = \\\" << std::endl;\\n                std::cin >> x;\\n                h = mychain.hash(x);\\n                mychain.find(x, h);\\n                break;\\n            case 3:\\n                std::cout << \\\"Enter element to generate hash = \\\" << std::endl;\\n                std::cin >> x;\\n                std::cout << \\\"Hash of \\\" << x << \\\" is = \\\" << mychain.hash(x)\\n                          << std::endl;\\n                break;\\n            case 4:\\n                mychain.display();\\n                break;\\n            default:\\n                loop = false;\\n                break;\\n        }\\n        std::cout << std::endl;\\n    }\\n    /*add(1,&head1);\\n    add(2,&head1);\\n    add(3,&head2);\\n    add(5,&head1);\\n    display(&head1);\\n    display(&head2);*/\\n    return 0;\\n}\\n\"",
    "double hash hash table": "\"/**\\n * @file double_hash_hash_table.cpp\\n * @author [achance6](https://github.com/achance6)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Storage mechanism using [double-hashed\\n * keys](https://en.wikipedia.org/wiki/Double_hashing).\\n * @note The implementation can be optimized by using OOP style.\\n */\\n#include <iostream>\\n#include <memory>\\n#include <vector>\\n\\n/**\\n * @addtogroup open_addressing Open Addressing\\n * @{\\n * @namespace double_hashing\\n * @brief An implementation of hash table using [double\\n * hashing](https://en.wikipedia.org/wiki/Double_hashing) algorithm.\\n */\\nnamespace double_hashing {\\n// fwd declarations\\nusing Entry = struct Entry;\\nbool putProber(const Entry& entry, int key);\\nbool searchingProber(const Entry& entry, int key);\\nvoid add(int key);\\n\\n// Undocumented globals\\nint notPresent;\\nstd::vector<Entry> table;\\nint totalSize;\\nint tomb = -1;\\nint size;\\nbool rehashing;\\n\\n/** Node object that holds key */\\nstruct Entry {\\n    explicit Entry(int key = notPresent) : key(key) {}  ///< constructor\\n    int key;                                            ///< key value\\n};\\n\\n/**\\n * @brief Hash a key. Uses the STL library's `std::hash()` function.\\n *\\n * @param key value to hash\\n * @return hash value of the key\\n */\\nsize_t hashFxn(int key) {\\n    std::hash<int> hash;\\n    return hash(key);\\n}\\n\\n/**\\n * @brief Used for second hash function\\n *\\n * @param key key value to hash\\n * @return  hash value of the key\\n */\\nsize_t otherHashFxn(int key) {\\n    std::hash<int> hash;\\n    return 1 + (7 - (hash(key) % 7));\\n}\\n\\n/**\\n * @brief Performs double hashing to resolve collisions\\n *\\n * @param key key value to apply double-hash on\\n * @param searching `true` to check for conflicts\\n * @return Index of key when found\\n * @return new hash if no conflicts present\\n */\\nint doubleHash(int key, bool searching) {\\n    int hash = static_cast<int>(hashFxn(key));\\n    int i = 0;\\n    Entry entry;\\n    do {\\n        int index =\\n            static_cast<int>(hash + (i * otherHashFxn(key))) % totalSize;\\n        entry = table[index];\\n        if (searching) {\\n            if (entry.key == notPresent) {\\n                return notPresent;\\n            }\\n            if (searchingProber(entry, key)) {\\n                std::cout << \\\"Found key!\\\" << std::endl;\\n                return index;\\n            }\\n            std::cout << \\\"Found tombstone or equal hash, checking next\\\"\\n                      << std::endl;\\n            i++;\\n        } else {\\n            if (putProber(entry, key)) {\\n                if (!rehashing) {\\n                    std::cout << \\\"Spot found!\\\" << std::endl;\\n                }\\n                return index;\\n            }\\n            if (!rehashing) {\\n                std::cout << \\\"Spot taken, looking at next (next index:\\\"\\n                          << \\\" \\\"\\n                          << static_cast<int>(hash + (i * otherHashFxn(key))) %\\n                                 totalSize\\n                          << \\\")\\\" << std::endl;\\n            }\\n            i++;\\n        }\\n        if (i == totalSize * 100) {\\n            std::cout << \\\"DoubleHash probe failed\\\" << std::endl;\\n            return notPresent;\\n        }\\n    } while (entry.key != notPresent);\\n    return notPresent;\\n}\\n\\n/** Finds empty spot in a vector\\n * @param entry vector to search in\\n * @param key key to search for\\n * @returns `true` if key is not present or is a `toumb`\\n * @returns `false` is already occupied\\n */\\nbool putProber(const Entry& entry, int key) {\\n    if (entry.key == notPresent || entry.key == tomb) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\n/** Looks for a matching key\\n * @param entry vector to search in\\n * @param key key value to search\\n * @returns `true` if found\\n * @returns `false` if not found\\n */\\nbool searchingProber(const Entry& entry, int key) {\\n    if (entry.key == key) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\n/** Displays the table\\n * @returns None\\n */\\nvoid display() {\\n    for (int i = 0; i < totalSize; i++) {\\n        if (table[i].key == notPresent) {\\n            std::cout << \\\" Empty \\\";\\n        } else if (table[i].key == tomb) {\\n            std::cout << \\\" Tomb \\\";\\n        } else {\\n            std::cout << \\\" \\\";\\n            std::cout << table[i].key;\\n            std::cout << \\\" \\\";\\n        }\\n    }\\n    std::cout << std::endl;\\n}\\n\\n/** Rehashes the table into a bigger table\\n * @returns None\\n */\\nvoid rehash() {\\n    // Necessary so wall of add info isn't printed all at once\\n    rehashing = true;\\n    int oldSize = totalSize;\\n    std::vector<Entry> oldTable(table);\\n    // Really this should use the next prime number greater than totalSize * 2\\n    table = std::vector<Entry>(totalSize * 2);\\n    totalSize *= 2;\\n    for (int i = 0; i < oldSize; i++) {\\n        if (oldTable[i].key != -1 && oldTable[i].key != notPresent) {\\n            size--;  // Size stays the same (add increments size)\\n            add(oldTable[i].key);\\n        }\\n    }\\n    // delete[] oldTable;\\n    // oldTable.reset();\\n\\n    rehashing = false;\\n    std::cout << \\\"Table was rehashed, new size is: \\\" << totalSize << std::endl;\\n}\\n\\n/** Checks for load factor here\\n * @param key key value to add to the table\\n */\\nvoid add(int key) {\\n    // auto* entry = new Entry();\\n    // entry->key = key;\\n    int index = doubleHash(key, false);\\n    table[index].key = key;\\n    // Load factor greater than 0.5 causes resizing\\n    if (++size / static_cast<double>(totalSize) >= 0.5) {\\n        rehash();\\n    }\\n}\\n\\n/** Removes key. Leaves tombstone upon removal.\\n * @param key key value to remove\\n */\\nvoid remove(int key) {\\n    int index = doubleHash(key, true);\\n    if (index == notPresent) {\\n        std::cout << \\\"key not found\\\" << std::endl;\\n    }\\n    table[index].key = tomb;\\n    std::cout << \\\"Removal successful, leaving tombstone\\\" << std::endl;\\n    size--;\\n}\\n\\n/** Information about the adding process\\n * @param key key value to add to table\\n */\\nvoid addInfo(int key) {\\n    std::cout << \\\"Initial table: \\\";\\n    display();\\n    std::cout << std::endl;\\n    std::cout << \\\"hash of \\\" << key << \\\" is \\\" << hashFxn(key) << \\\" % \\\"\\n              << totalSize << \\\" == \\\" << hashFxn(key) % totalSize;\\n    std::cout << std::endl;\\n    add(key);\\n    std::cout << \\\"New table: \\\";\\n    display();\\n}\\n\\n/** Information about removal process\\n * @param key key value to remove from table\\n */\\nvoid removalInfo(int key) {\\n    std::cout << \\\"Initial table: \\\";\\n    display();\\n    std::cout << std::endl;\\n    std::cout << \\\"hash of \\\" << key << \\\" is \\\" << hashFxn(key) << \\\" % \\\"\\n              << totalSize << \\\" == \\\" << hashFxn(key) % totalSize;\\n    std::cout << std::endl;\\n    remove(key);\\n    std::cout << \\\"New table: \\\";\\n    display();\\n}\\n}  // namespace double_hashing\\n/**\\n * @}\\n */\\n\\nusing double_hashing::Entry;\\nusing double_hashing::table;\\nusing double_hashing::totalSize;\\n\\n/** Main program\\n * @returns 0 on success\\n */\\nint main() {\\n    int cmd = 0, hash = 0, key = 0;\\n    std::cout << \\\"Enter the initial size of Hash Table. = \\\";\\n    std::cin >> totalSize;\\n    table = std::vector<Entry>(totalSize);\\n    bool loop = true;\\n    while (loop) {\\n        std::cout << std::endl;\\n        std::cout << \\\"PLEASE CHOOSE -\\\" << std::endl;\\n        std::cout << \\\"1. Add key. (Numeric only)\\\" << std::endl;\\n        std::cout << \\\"2. Remove key.\\\" << std::endl;\\n        std::cout << \\\"3. Find key.\\\" << std::endl;\\n        std::cout << \\\"4. Generate Hash. (Numeric only)\\\" << std::endl;\\n        std::cout << \\\"5. Display Hash table.\\\" << std::endl;\\n        std::cout << \\\"6. Exit.\\\" << std::endl;\\n        std::cin >> cmd;\\n        switch (cmd) {\\n            case 1:\\n                std::cout << \\\"Enter key to add = \\\";\\n                std::cin >> key;\\n                double_hashing::addInfo(key);\\n                break;\\n            case 2:\\n                std::cout << \\\"Enter key to remove = \\\";\\n                std::cin >> key;\\n                double_hashing::removalInfo(key);\\n                break;\\n            case 3: {\\n                std::cout << \\\"Enter key to search = \\\";\\n                std::cin >> key;\\n                Entry entry = table[double_hashing::doubleHash(key, true)];\\n                if (entry.key == double_hashing::notPresent) {\\n                    std::cout << \\\"Key not present\\\";\\n                }\\n                break;\\n            }\\n            case 4:\\n                std::cout << \\\"Enter element to generate hash = \\\";\\n                std::cin >> key;\\n                std::cout << \\\"Hash of \\\" << key\\n                          << \\\" is = \\\" << double_hashing::hashFxn(key);\\n                break;\\n            case 5:\\n                double_hashing::display();\\n                break;\\n            default:\\n                loop = false;\\n                break;\\n                // delete[] table;\\n        }\\n        std::cout << std::endl;\\n    }\\n    return 0;\\n}\\n\"",
    "linear probing hash table": "\"/**\\n * @file\\n * @author [achance6](https://github.com/achance6)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Storage mechanism using [linear probing\\n * hash](https://en.wikipedia.org/wiki/Linear_probing) keys.\\n * @note The implementation can be optimized by using OOP style.\\n */\\n#include <iostream>\\n#include <vector>\\n\\n/**\\n * @addtogroup open_addressing Open Addressing\\n * @{\\n * @namespace linear_probing\\n * @brief An implementation of hash table using [linear\\n * probing](https://en.wikipedia.org/wiki/Linear_probing) algorithm.\\n */\\nnamespace linear_probing {\\n// fwd declarations\\nusing Entry = struct Entry;\\nbool putProber(const Entry& entry, int key);\\nbool searchingProber(const Entry& entry, int key);\\nvoid add(int key);\\n\\n// Undocumented globals\\nint notPresent;\\nstd::vector<Entry> table;\\nint totalSize;\\nint tomb = -1;\\nint size;\\nbool rehashing;\\n\\n/** Node object that holds key */\\nstruct Entry {\\n    explicit Entry(int key = notPresent) : key(key) {}  ///< constructor\\n    int key;                                            ///< key value\\n};\\n\\n/**\\n * @brief Hash a key. Uses the STL library's `std::hash()` function.\\n *\\n * @param key value to hash\\n * @return hash value of the key\\n */\\nsize_t hashFxn(int key) {\\n    std::hash<int> hash;\\n    return hash(key);\\n}\\n\\n/** Performs linear probing to resolve collisions\\n * @param key key value to hash\\n * @return hash value of the key\\n */\\nint linearProbe(int key, bool searching) {\\n    int hash = static_cast<int>(hashFxn(key));\\n    int i = 0;\\n    Entry entry;\\n    do {\\n        int index = static_cast<int>((hash + i) % totalSize);\\n        entry = table[index];\\n        if (searching) {\\n            if (entry.key == notPresent) {\\n                return notPresent;\\n            }\\n            if (searchingProber(entry, key)) {\\n                std::cout << \\\"Found key!\\\" << std::endl;\\n                return index;\\n            }\\n            std::cout << \\\"Found tombstone or equal hash, checking next\\\"\\n                      << std::endl;\\n            i++;\\n        } else {\\n            if (putProber(entry, key)) {\\n                if (!rehashing) {\\n                    std::cout << \\\"Spot found!\\\" << std::endl;\\n                }\\n                return index;\\n            }\\n            if (!rehashing) {\\n                std::cout << \\\"Spot taken, looking at next\\\" << std::endl;\\n            }\\n            i++;\\n        }\\n        if (i == totalSize) {\\n            std::cout << \\\"Linear probe failed\\\" << std::endl;\\n            return notPresent;\\n        }\\n    } while (entry.key != notPresent);\\n    return notPresent;\\n}\\n\\n/** Finds empty spot\\n * @param entry instance to check in\\n * @param key key value to hash\\n * @return hash value of the key\\n */\\nbool putProber(const Entry& entry, int key) {\\n    if (entry.key == notPresent || entry.key == tomb) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\n/** Looks for a matching key\\n * @param entry instance to check in\\n * @param key key value to hash\\n * @return hash value of the key\\n */\\nbool searchingProber(const Entry& entry, int key) {\\n    if (entry.key == key) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\n/** Function to displays the table\\n * @returns none\\n */\\nvoid display() {\\n    for (int i = 0; i < totalSize; i++) {\\n        if (table[i].key == notPresent) {\\n            std::cout << \\\" Empty \\\";\\n        } else if (table[i].key == tomb) {\\n            std::cout << \\\" Tomb \\\";\\n        } else {\\n            std::cout << \\\" \\\";\\n            std::cout << table[i].key;\\n            std::cout << \\\" \\\";\\n        }\\n    }\\n    std::cout << std::endl;\\n}\\n\\n/** Rehashes the table into a bigger table\\n * @returns None\\n */\\nvoid rehash() {\\n    // Necessary so wall of add info isn't printed all at once\\n    rehashing = true;\\n    int oldSize = totalSize;\\n    std::vector<Entry> oldTable(table);\\n    // Really this should use the next prime number greater than totalSize *\\n    // 2\\n    totalSize *= 2;\\n    table = std::vector<Entry>(totalSize);\\n    for (int i = 0; i < oldSize; i++) {\\n        if (oldTable[i].key != -1 && oldTable[i].key != notPresent) {\\n            size--;  // Size stays the same (add increments size)\\n            add(oldTable[i].key);\\n        }\\n    }\\n    // delete[] oldTable;\\n    rehashing = false;\\n    std::cout << \\\"Table was rehashed, new size is: \\\" << totalSize << std::endl;\\n}\\n\\n/** Adds entry using linear probing. Checks for load factor here\\n * @param key key value to hash and add\\n */\\nvoid add(int key) {\\n    int index = linearProbe(key, false);\\n    table[index].key = key;\\n    // Load factor greater than 0.5 causes resizing\\n    if (++size / static_cast<double>(totalSize) >= 0.5) {\\n        rehash();\\n    }\\n}\\n\\n/** Removes key. Leaves tombstone upon removal.\\n * @param key key value to hash and remove\\n */\\nvoid remove(int key) {\\n    int index = linearProbe(key, true);\\n    if (index == notPresent) {\\n        std::cout << \\\"key not found\\\" << std::endl;\\n    }\\n    std::cout << \\\"Removal Successful, leaving tomb\\\" << std::endl;\\n    table[index].key = tomb;\\n    size--;\\n}\\n\\n/** Information about the adding process\\n * @param key key value to hash and add\\n */\\nvoid addInfo(int key) {\\n    std::cout << \\\"Initial table: \\\";\\n    display();\\n    std::cout << std::endl;\\n    std::cout << \\\"hash of \\\" << key << \\\" is \\\" << hashFxn(key) << \\\" % \\\"\\n              << totalSize << \\\" == \\\" << hashFxn(key) % totalSize;\\n    std::cout << std::endl;\\n    add(key);\\n    std::cout << \\\"New table: \\\";\\n    display();\\n}\\n\\n/** Information about removal process\\n * @param key key value to hash and remove\\n */\\nvoid removalInfo(int key) {\\n    std::cout << \\\"Initial table: \\\";\\n    display();\\n    std::cout << std::endl;\\n    std::cout << \\\"hash of \\\" << key << \\\" is \\\" << hashFxn(key) << \\\" % \\\"\\n              << totalSize << \\\" == \\\" << hashFxn(key) % totalSize;\\n    std::cout << std::endl;\\n    remove(key);\\n    std::cout << \\\"New table: \\\";\\n    display();\\n}\\n}  // namespace linear_probing\\n/**\\n * @}\\n */\\n\\nusing linear_probing::Entry;\\nusing linear_probing::table;\\nusing linear_probing::totalSize;\\n\\n/** Main function\\n * @returns 0 on success\\n */\\nint main() {\\n    int cmd = 0, hash = 0, key = 0;\\n    std::cout << \\\"Enter the initial size of Hash Table. = \\\";\\n    std::cin >> totalSize;\\n    table = std::vector<Entry>(totalSize);\\n    bool loop = true;\\n    while (loop) {\\n        std::cout << std::endl;\\n        std::cout << \\\"PLEASE CHOOSE -\\\" << std::endl;\\n        std::cout << \\\"1. Add key. (Numeric only)\\\" << std::endl;\\n        std::cout << \\\"2. Remove key.\\\" << std::endl;\\n        std::cout << \\\"3. Find key.\\\" << std::endl;\\n        std::cout << \\\"4. Generate Hash. (Numeric only)\\\" << std::endl;\\n        std::cout << \\\"5. Display Hash table.\\\" << std::endl;\\n        std::cout << \\\"6. Exit.\\\" << std::endl;\\n        std::cin >> cmd;\\n        switch (cmd) {\\n            case 1:\\n                std::cout << \\\"Enter key to add = \\\";\\n                std::cin >> key;\\n                linear_probing::addInfo(key);\\n                break;\\n            case 2:\\n                std::cout << \\\"Enter key to remove = \\\";\\n                std::cin >> key;\\n                linear_probing::removalInfo(key);\\n                break;\\n            case 3: {\\n                std::cout << \\\"Enter key to search = \\\";\\n                std::cin >> key;\\n                Entry entry = table[linear_probing::linearProbe(key, true)];\\n                if (entry.key == linear_probing::notPresent) {\\n                    std::cout << \\\"Key not present\\\";\\n                }\\n                break;\\n            }\\n            case 4:\\n                std::cout << \\\"Enter element to generate hash = \\\";\\n                std::cin >> key;\\n                std::cout << \\\"Hash of \\\" << key\\n                          << \\\" is = \\\" << linear_probing::hashFxn(key);\\n                break;\\n            case 5:\\n                linear_probing::display();\\n                break;\\n            default:\\n                loop = false;\\n                break;\\n                // delete[] table;\\n        }\\n        std::cout << std::endl;\\n    }\\n    return 0;\\n}\\n\"",
    "md5": "\"/**\\n * @file\\n * @author [tGautot](https://github.com/tGautot)\\n * @brief Simple C++ implementation of the [MD5 Hashing\\n * Algorithm](https://en.wikipedia.org/wiki/MD5)\\n * @details\\n * The [MD5 Algorithm](https://en.wikipedia.org/wiki/MD5) is a\\n * hashing algorithm which was designed in 1991 by [Ronal\\n * Rivest](https://en.wikipedia.org/wiki/Ron_Rivest).\\n *\\n * MD5 is one of the most used hashing algorithm there is. Some of its\\n * use cases are:\\n *  1. Providing checksum for downloaded software\\n *  2. Store salted password\\n *\\n * However MD5 has be know to be cryptographically weak for quite some\\n * time, yet it is still widely used. This weakness was exploited by the\\n * [Flame Malware](https://en.wikipedia.org/wiki/Flame_(malware)) in 2012\\n *\\n * ### Algorithm\\n * First of all, all values are expected to be in [little endian]\\n * (https://en.wikipedia.org/wiki/Endianness). This is especially important\\n * when using part of the bytestring as an integer.\\n *\\n * The first step of the algorithm is to pad the message for its length to\\n * be a multiple of 64 (bytes). This is done by first adding 0x80 (10000000)\\n * and then only zeroes until the last 8 bytes must be filled, where then the\\n * 64 bit size of the input will be added\\n *\\n * Once this is done, the algo breaks down this padded message\\n * into 64 bytes chunks. Each chunk is used for one *round*, a round\\n * breaks the chunk into 16 blocks of 4 bytes. During these rounds\\n * the algorithm will update its 128 bit state (represented by 4 ints: A,B,C,D)\\n * For more precisions on these operations please see the [Wikipedia\\n * aritcle](https://en.wikipedia.org/wiki/MD5#Algorithm).\\n * The signature given by MD5 is its 128 bit state once all rounds are done.\\n * @note This is a simple implementation for a byte string but\\n * some implmenetations can work on bytestream, messages of unknown length.\\n */\\n\\n#include <algorithm>  /// Used for std::copy\\n#include <array>      /// Used for std::array\\n#include <cassert>    /// Used for assert\\n#include <cstring>    /// Used for std::memcopy\\n#include <iostream>   /// Used for IO operations\\n#include <string>     /// Used for strings\\n#include <vector>     /// Used for std::vector\\n\\n/**\\n * @namespace hashing\\n * @brief Hashing algorithms\\n */\\nnamespace hashing {\\n/**\\n * @namespace MD5\\n * @brief Functions for the [MD5](https://en.wikipedia.org/wiki/MD5) algorithm\\n * implementation\\n */\\nnamespace md5 {\\n/**\\n * @brief Rotates the bits of a 32-bit unsigned integer\\n * @param n Integer to rotate\\n * @param rotate How many bits for the rotation\\n * @return uint32_t The rotated integer\\n */\\nuint32_t leftRotate32bits(uint32_t n, std::size_t rotate) {\\n    return (n << rotate) | (n >> (32 - rotate));\\n}\\n/**\\n * @brief Checks whether integers are stored as big endian or not\\n * @note Taken from [this](https://stackoverflow.com/a/1001373) StackOverflow\\n * post\\n * @return true IF integers are detected to work as big-endian\\n * @return false IF integers are detected to work as little-endian\\n */\\nbool isBigEndian() {\\n    union {\\n        uint32_t i;\\n        std::array<char, 4> c;\\n    } bint = {0x01020304};\\n\\n    return bint.c[0] == 1;\\n}\\n/**\\n * @brief Sets 32-bit integer to little-endian if needed\\n * @param n Number to set to little-endian (uint32_t)\\n * @return uint32_t param n with binary representation as little-endian\\n */\\nuint32_t toLittleEndian32(uint32_t n) {\\n    if (!isBigEndian()) {\\n        return ((n << 24) & 0xFF000000) | ((n << 8) & 0x00FF0000) |\\n               ((n >> 8) & 0x0000FF00) | ((n >> 24) & 0x000000FF);\\n    }\\n    // Machine works on little endian, no need to change anything\\n    return n;\\n}\\n/**\\n * @brief Sets 64-bit integer to little-endian if needed\\n * @param n Number to set to little-endian (uint64_t)\\n * @return uint64_t param n with binary representation as little-endian\\n */\\nuint64_t toLittleEndian64(uint64_t n) {\\n    if (!isBigEndian()) {\\n        return ((n << 56) & 0xFF00000000000000) |\\n               ((n << 40) & 0x00FF000000000000) |\\n               ((n << 24) & 0x0000FF0000000000) |\\n               ((n << 8) & 0x000000FF00000000) |\\n               ((n >> 8) & 0x00000000FF000000) |\\n               ((n >> 24) & 0x0000000000FF0000) |\\n               ((n >> 40) & 0x000000000000FF00) |\\n               ((n >> 56) & 0x00000000000000FF);\\n        ;\\n    }\\n    // Machine works on little endian, no need to change anything\\n    return n;\\n}\\n/**\\n * @brief Transforms the 128-bit MD5 signature into a 32 char hex string\\n * @param sig The MD5 signature (Expected 16 bytes)\\n * @return std::string The hex signature\\n */\\nstd::string sig2hex(void* sig) {\\n    const char* hexChars = \\\"0123456789abcdef\\\";\\n    auto* intsig = static_cast<uint8_t*>(sig);\\n    std::string hex = \\\"\\\";\\n    for (uint8_t i = 0; i < 16; i++) {\\n        hex.push_back(hexChars[(intsig[i] >> 4) & 0xF]);\\n        hex.push_back(hexChars[(intsig[i]) & 0xF]);\\n    }\\n    return hex;\\n}\\n/**\\n * @brief The MD5 algorithm itself, taking in a bytestring\\n * @param input_bs The bytestring to hash\\n * @param input_size The size (in BYTES) of the input\\n * @return void* Pointer to the 128-bit signature\\n */\\nvoid* hash_bs(const void* input_bs, uint64_t input_size) {\\n    auto* input = static_cast<const uint8_t*>(input_bs);\\n\\n    // Step 0: Initial Data (Those are decided in the MD5 protocol)\\n    // s is the shift used in the leftrotate each round\\n    std::array<uint32_t, 64> s = {\\n        7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\\n        5, 9,  14, 20, 5, 9,  14, 20, 5, 9,  14, 20, 5, 9,  14, 20,\\n        4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\\n        6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};\\n    // K is pseudo-random values used each round\\n    // The values can be obtained by the following python code:\\n\\n    /**\\n     * @brief Values of K are pseudo-random and used to \\\"salt\\\" each round\\n     * The values can be obtained by the following python code\\n     * @code{.py}\\n     * from math import floor, sin\\n     *\\n     * for i in range(64):\\n     *     print(floor(2**32 * abs(sin(i+1))))\\n     * @endcode\\n     */\\n    std::array<uint32_t, 64> K = {\\n        3614090360, 3905402710, 606105819,  3250441966, 4118548399, 1200080426,\\n        2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134,\\n        1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664,\\n        643717713,  3921069994, 3593408605, 38016083,   3634488961, 3889429448,\\n        568446438,  3275163606, 4107603335, 1163531501, 2850285829, 4243563512,\\n        1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740,\\n        2763975236, 1272893353, 4139469664, 3200236656, 681279174,  3936430074,\\n        3572445317, 76029189,   3654602809, 3873151461, 530742520,  3299628645,\\n        4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690,\\n        4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649,\\n        4149444226, 3174756917, 718787259,  3951481745};\\n\\n    // The initial 128-bit state\\n    uint32_t a0 = 0x67452301, A = 0;\\n    uint32_t b0 = 0xefcdab89, B = 0;\\n    uint32_t c0 = 0x98badcfe, C = 0;\\n    uint32_t d0 = 0x10325476, D = 0;\\n\\n    // Step 1: Processing the bytestring\\n\\n    // First compute the size the padded message will have\\n    // so it is possible to allocate the right amount of memory\\n    uint64_t padded_message_size = 0;\\n    if (input_size % 64 < 56) {\\n        padded_message_size = input_size + 64 - (input_size % 64);\\n    } else {\\n        padded_message_size = input_size + 128 - (input_size % 64);\\n    }\\n\\n    std::vector<uint8_t> padded_message(padded_message_size);\\n\\n    // Beginning of the padded message is the original message\\n    std::copy(input, input + input_size, padded_message.begin());\\n\\n    // Afterwards comes a single 1 bit and then only zeroes\\n    padded_message[input_size] = 1 << 7;  // 10000000\\n    for (uint64_t i = input_size; i % 64 != 56; i++) {\\n        if (i == input_size) {\\n            continue;  // pass first iteration\\n        }\\n        padded_message[i] = 0;\\n    }\\n\\n    // We then have to add the 64-bit size of the message at the end\\n    // When there is a conversion from int to bytestring or vice-versa\\n    // We always need to make sure it is little endian\\n    uint64_t input_bitsize_le = toLittleEndian64(input_size * 8);\\n    for (uint8_t i = 0; i < 8; i++) {\\n        padded_message[padded_message_size - 8 + i] =\\n            (input_bitsize_le >> (56 - 8 * i)) & 0xFF;\\n    }\\n\\n    // Already allocate memory for blocks\\n    std::array<uint32_t, 16> blocks{};\\n\\n    // Rounds\\n    for (uint64_t chunk = 0; chunk * 64 < padded_message_size; chunk++) {\\n        // First, build the 16 32-bits blocks from the chunk\\n        for (uint8_t bid = 0; bid < 16; bid++) {\\n            blocks[bid] = 0;\\n\\n            // Having to build a 32-bit word from 4-bit words\\n            // Add each and shift them to the left\\n            for (uint8_t cid = 0; cid < 4; cid++) {\\n                blocks[bid] = (blocks[bid] << 8) +\\n                              padded_message[chunk * 64 + bid * 4 + cid];\\n            }\\n        }\\n\\n        A = a0;\\n        B = b0;\\n        C = c0;\\n        D = d0;\\n\\n        // Main \\\"hashing\\\" loop\\n        for (uint8_t i = 0; i < 64; i++) {\\n            uint32_t F = 0, g = 0;\\n            if (i < 16) {\\n                F = (B & C) | ((~B) & D);\\n                g = i;\\n            } else if (i < 32) {\\n                F = (D & B) | ((~D) & C);\\n                g = (5 * i + 1) % 16;\\n            } else if (i < 48) {\\n                F = B ^ C ^ D;\\n                g = (3 * i + 5) % 16;\\n            } else {\\n                F = C ^ (B | (~D));\\n                g = (7 * i) % 16;\\n            }\\n\\n            // Update the accumulators\\n            F += A + K[i] + toLittleEndian32(blocks[g]);\\n\\n            A = D;\\n            D = C;\\n            C = B;\\n            B += leftRotate32bits(F, s[i]);\\n        }\\n        // Update the state with this chunk's hash\\n        a0 += A;\\n        b0 += B;\\n        c0 += C;\\n        d0 += D;\\n    }\\n\\n    // Build signature from state\\n    // Note, any type could be used for the signature\\n    // uint8_t was used to make the 16 bytes obvious\\n    // The sig needs to be little endian\\n    auto* sig = new uint8_t[16];\\n    for (uint8_t i = 0; i < 4; i++) {\\n        sig[i] = (a0 >> (8 * i)) & 0xFF;\\n        sig[i + 4] = (b0 >> (8 * i)) & 0xFF;\\n        sig[i + 8] = (c0 >> (8 * i)) & 0xFF;\\n        sig[i + 12] = (d0 >> (8 * i)) & 0xFF;\\n    }\\n\\n    return sig;\\n}\\n/**\\n * @brief Converts the string to bytestring and calls the main algorithm\\n * @param message Plain character message to hash\\n * @return void* Pointer to the MD5 signature\\n */\\nvoid* hash(const std::string& message) {\\n    return hash_bs(&message[0], message.size());\\n}\\n}  // namespace md5\\n}  // namespace hashing\\n\\n/**\\n * @brief Self-test implementations of well-known MD5 hashes\\n * @returns void\\n */\\nstatic void test() {\\n    // Hashes empty string and stores signature\\n    void* sig = hashing::md5::hash(\\\"\\\");\\n    std::cout << \\\"Hashing empty string\\\" << std::endl;\\n    // Prints signature hex representation\\n    std::cout << hashing::md5::sig2hex(sig) << std::endl << std::endl;\\n    // Test with cassert whether sig is correct from the expected value\\n    assert(hashing::md5::sig2hex(sig).compare(\\n               \\\"d41d8cd98f00b204e9800998ecf8427e\\\") == 0);\\n\\n    // Hashes \\\"The quick brown fox jumps over the lazy dog\\\" and stores signature\\n    void* sig2 =\\n        hashing::md5::hash(\\\"The quick brown fox jumps over the lazy dog\\\");\\n    std::cout << \\\"Hashing The quick brown fox jumps over the lazy dog\\\"\\n              << std::endl;\\n    // Prints signature hex representation\\n    std::cout << hashing::md5::sig2hex(sig2) << std::endl << std::endl;\\n    // Test with cassert whether sig is correct from the expected value\\n    assert(hashing::md5::sig2hex(sig2).compare(\\n               \\\"9e107d9d372bb6826bd81d3542a419d6\\\") == 0);\\n\\n    // Hashes \\\"The quick brown fox jumps over the lazy dog.\\\" (notice the\\n    // additional period) and stores signature\\n    void* sig3 =\\n        hashing::md5::hash(\\\"The quick brown fox jumps over the lazy dog.\\\");\\n    std::cout << \\\"Hashing \\\"\\n                 \\\"The quick brown fox jumps over the lazy dog.\\\"\\n              << std::endl;\\n    // Prints signature hex representation\\n    std::cout << hashing::md5::sig2hex(sig3) << std::endl << std::endl;\\n    // Test with cassert whether sig is correct from the expected value\\n    assert(hashing::md5::sig2hex(sig3).compare(\\n               \\\"e4d909c290d0fb1ca068ffaddf22cbd0\\\") == 0);\\n\\n    // Hashes \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\"\\n    // and stores signature\\n    void* sig4 = hashing::md5::hash(\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\");\\n    std::cout\\n        << \\\"Hashing \\\"\\n           \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\"\\n        << std::endl;\\n    // Prints signature hex representation\\n    std::cout << hashing::md5::sig2hex(sig4) << std::endl << std::endl;\\n    // Test with cassert whether sig is correct from the expected value\\n    assert(hashing::md5::sig2hex(sig4).compare(\\n               \\\"d174ab98d277d9f5a5611c2c9f419d9f\\\") == 0);\\n}\\n\\n/**\\n * @brief Puts user in a loop where inputs can be given and MD5 hash will be\\n * computed and printed\\n * @returns void\\n */\\nstatic void interactive() {\\n    while (true) {\\n        std::string input;\\n        std::cout << \\\"Enter a message to be hashed (Ctrl-C to exit): \\\"\\n                  << std::endl;\\n        std::getline(std::cin, input);\\n        void* sig = hashing::md5::hash(input);\\n        std::cout << \\\"Hash is: \\\" << hashing::md5::sig2hex(sig) << std::endl;\\n\\n        while (true) {\\n            std::cout << \\\"Want to enter another message? (y/n) \\\";\\n            std::getline(std::cin, input);\\n            if (input.compare(\\\"y\\\") == 0) {\\n                break;\\n            } else if (input.compare(\\\"n\\\") == 0) {\\n                return;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n\\n    // Launch interactive mode where user can input messages and see\\n    // their hash\\n    interactive();\\n    return 0;\\n}\\n\"",
    "quadratic probing hash table": "\"/**\\n * @file\\n * @author [achance6](https://github.com/achance6)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Storage mechanism using [quadratic probing\\n * hash](https://en.wikipedia.org/wiki/Quadratic_probing) keys.\\n * @note The implementation can be optimized by using OOP style.\\n */\\n#include <cmath>\\n#include <iostream>\\n#include <vector>\\n\\n/**\\n * @addtogroup open_addressing Open Addressing\\n * @{\\n * @namespace quadratic_probing\\n * @brief An implementation of hash table using [quadratic\\n * probing](https://en.wikipedia.org/wiki/Quadratic_probing) algorithm.\\n */\\nnamespace quadratic_probing {\\n// fwd declarations\\nusing Entry = struct Entry;\\nbool putProber(const Entry& entry, int key);\\nbool searchingProber(const Entry& entry, int key);\\nvoid add(int key);\\n\\n// globals\\nint notPresent;\\nstd::vector<Entry> table;\\nint totalSize;\\nint tomb = -1;\\nint size;\\nbool rehashing;\\n\\n/** Node that holds key\\n */\\nstruct Entry {\\n    explicit Entry(int key = notPresent) : key(key) {}  ///< constructor\\n    int key;                                            ///< key value\\n};\\n\\n/** Hash a key\\n * @param key key value to hash\\n * @returns hash of the key\\n */\\nsize_t hashFxn(int key) {\\n    std::hash<int> hash;\\n    return hash(key);\\n}\\n\\n/** Performs quadratic probing to resolve collisions\\n * @param key key value to search/probe\\n * @param searching `true` if only searching, `false1 if assigning\\n * @returns value of `notPresent`.\\n */\\nint quadraticProbe(int key, bool searching) {\\n    int hash = static_cast<int>(hashFxn(key));\\n    int i = 0;\\n    Entry entry;\\n    do {\\n        size_t index =\\n            (hash + static_cast<size_t>(std::round(std::pow(i, 2)))) %\\n            totalSize;\\n        entry = table[index];\\n        if (searching) {\\n            if (entry.key == notPresent) {\\n                return notPresent;\\n            }\\n            if (searchingProber(entry, key)) {\\n                std::cout << \\\"Found key!\\\" << std::endl;\\n                return index;\\n            }\\n            std::cout << \\\"Found tombstone or equal hash, checking next\\\"\\n                      << std::endl;\\n            i++;\\n        } else {\\n            if (putProber(entry, key)) {\\n                if (!rehashing) {\\n                    std::cout << \\\"Spot found!\\\" << std::endl;\\n                }\\n                return index;\\n            }\\n            if (!rehashing) {\\n                std::cout << \\\"Spot taken, looking at next (next index = \\\"\\n                          << (hash + static_cast<size_t>(\\n                                         std::round(std::pow(i + 1, 2)))) %\\n                                 totalSize\\n                          << std::endl;\\n            }\\n            i++;\\n        }\\n        if (i == totalSize * 100) {\\n            std::cout << \\\"Quadratic probe failed (infinite loop)\\\" << std::endl;\\n            return notPresent;\\n        }\\n    } while (entry.key != notPresent);\\n    return notPresent;\\n}\\n\\n/** Finds empty spot\\n * @param entry Instance of table entry\\n * @param key key value to search/probe\\n * @returns `true` if key is present\\n * @returns `false` if key is absent\\n */\\nbool putProber(const Entry& entry, int key) {\\n    if (entry.key == notPresent || entry.key == tomb) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\n/** Looks for a matching key\\n * @param entry Instance of table entry\\n * @param key key value to search/probe\\n * @returns `true` if key matches the entry\\n * @returns `false` if key does not match the entry\\n */\\nbool searchingProber(const Entry& entry, int key) {\\n    if (entry.key == key) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\n/** Get the entry instance corresponding to a key\\n * @param key key value to search/probe\\n * @returns if present, the entry instance\\n * @returns if not present, a new instance\\n */\\nEntry find(int key) {\\n    int index = quadraticProbe(key, true);\\n    if (index == notPresent) {\\n        return Entry();\\n    }\\n    return table[index];\\n}\\n\\n/** Displays the table\\n * @returns None\\n */\\nvoid display() {\\n    for (int i = 0; i < totalSize; i++) {\\n        if (table[i].key == notPresent) {\\n            std::cout << \\\" Empty \\\";\\n        } else if (table[i].key == tomb) {\\n            std::cout << \\\" Tomb \\\";\\n        } else {\\n            std::cout << \\\" \\\";\\n            std::cout << table[i].key;\\n            std::cout << \\\" \\\";\\n        }\\n    }\\n    std::cout << std::endl;\\n}\\n\\n/** Rehashes the table into a bigger table\\n * @returns none\\n */\\nvoid rehash() {\\n    // Necessary so wall of add info isn't printed all at once\\n    rehashing = true;\\n    int oldSize = totalSize;\\n    std::vector<Entry> oldTable(table);\\n    // Really this should use the next prime number greater than totalSize * 2\\n    totalSize *= 2;\\n    table = std::vector<Entry>(totalSize);\\n    for (int i = 0; i < oldSize; i++) {\\n        if (oldTable[i].key != -1 && oldTable[i].key != notPresent) {\\n            size--;  // Size stays the same (add increments size)\\n            add(oldTable[i].key);\\n        }\\n    }\\n    // delete[] oldTable;\\n    rehashing = false;\\n    std::cout << \\\"Table was rehashed, new size is: \\\" << totalSize << std::endl;\\n}\\n\\n/** Checks for load factor here\\n * @param key  key value to hash and add to table\\n */\\nvoid add(int key) {\\n    int index = quadraticProbe(key, false);\\n    table[index].key = key;\\n    // Load factor greater than 0.5 causes resizing\\n    if (++size / static_cast<double>(totalSize) >= 0.5) {\\n        rehash();\\n    }\\n}\\n\\n/** Removes key. Leaves tombstone upon removal.\\n * @param key  key value to hash and remove from table\\n */\\nvoid remove(int key) {\\n    int index = quadraticProbe(key, true);\\n    if (index == notPresent) {\\n        std::cout << \\\"key not found\\\" << std::endl;\\n    }\\n    table[index].key = tomb;\\n    std::cout << \\\"Removal successful, leaving tombstone\\\" << std::endl;\\n    size--;\\n}\\n\\n/** Information about the adding process\\n * @param key  key value to hash and add to table\\n */\\nvoid addInfo(int key) {\\n    std::cout << \\\"Initial table: \\\";\\n    display();\\n    std::cout << std::endl;\\n    std::cout << \\\"hash of \\\" << key << \\\" is \\\" << hashFxn(key) << \\\" % \\\"\\n              << totalSize << \\\" == \\\" << hashFxn(key) % totalSize;\\n    std::cout << std::endl;\\n    add(key);\\n    std::cout << \\\"New table: \\\";\\n    display();\\n}\\n\\n/** Information about removal process\\n * @param key  key value to hash and remove from table\\n */\\nvoid removalInfo(int key) {\\n    std::cout << \\\"Initial table: \\\";\\n    display();\\n    std::cout << std::endl;\\n    std::cout << \\\"hash of \\\" << key << \\\" is \\\" << hashFxn(key) << \\\" % \\\"\\n              << totalSize << \\\" == \\\" << hashFxn(key) % totalSize;\\n    std::cout << std::endl;\\n    remove(key);\\n    std::cout << \\\"New table: \\\";\\n    display();\\n}\\n\\n}  // namespace quadratic_probing\\n/**\\n * @}\\n */\\n\\nusing quadratic_probing::Entry;\\nusing quadratic_probing::table;\\nusing quadratic_probing::totalSize;\\n\\n/** Main function\\n * @returns None\\n */\\nint main() {\\n    int cmd = 0, hash = 0, key = 0;\\n    std::cout << \\\"Enter the initial size of Hash Table. = \\\";\\n    std::cin >> totalSize;\\n    table = std::vector<Entry>(totalSize);\\n    bool loop = true;\\n    while (loop) {\\n        std::cout << std::endl;\\n        std::cout << \\\"PLEASE CHOOSE -\\\" << std::endl;\\n        std::cout << \\\"1. Add key. (Numeric only)\\\" << std::endl;\\n        std::cout << \\\"2. Remove key.\\\" << std::endl;\\n        std::cout << \\\"3. Find key.\\\" << std::endl;\\n        std::cout << \\\"4. Generate Hash. (Numeric only)\\\" << std::endl;\\n        std::cout << \\\"5. Display Hash table.\\\" << std::endl;\\n        std::cout << \\\"6. Exit.\\\" << std::endl;\\n        std::cin >> cmd;\\n        switch (cmd) {\\n            case 1:\\n                std::cout << \\\"Enter key to add = \\\";\\n                std::cin >> key;\\n                quadratic_probing::addInfo(key);\\n                break;\\n            case 2:\\n                std::cout << \\\"Enter key to remove = \\\";\\n                std::cin >> key;\\n                quadratic_probing::removalInfo(key);\\n                break;\\n            case 3: {\\n                std::cout << \\\"Enter key to search = \\\";\\n                std::cin >> key;\\n                quadratic_probing::Entry entry =\\n                    quadratic_probing::table[quadratic_probing::quadraticProbe(\\n                        key, true)];\\n                if (entry.key == quadratic_probing::notPresent) {\\n                    std::cout << \\\"Key not present\\\";\\n                }\\n                break;\\n            }\\n            case 4:\\n                std::cout << \\\"Enter element to generate hash = \\\";\\n                std::cin >> key;\\n                std::cout << \\\"Hash of \\\" << key\\n                          << \\\" is = \\\" << quadratic_probing::hashFxn(key);\\n                break;\\n            case 5:\\n                quadratic_probing::display();\\n                break;\\n            default:\\n                loop = false;\\n                break;\\n                // delete[] table;\\n        }\\n        std::cout << std::endl;\\n    }\\n    return 0;\\n}\\n\"",
    "sha1": "\"/**\\n * @file\\n * @author [tGautot](https://github.com/tGautot)\\n * @brief Simple C++ implementation of the [SHA-1 Hashing\\n * Algorithm](https://en.wikipedia.org/wiki/SHA-1)\\n *\\n * @details\\n * [SHA-1](https://en.wikipedia.org/wiki/SHA-1) is a cryptographic hash function\\n * that was developped by the\\n * [NSA](https://en.wikipedia.org/wiki/National_Security_Agency) 1995.\\n * SHA-1 is not considered secure since around 2010.\\n *\\n * ### Algorithm\\n * The first step of the algorithm is to pad the message for its length to\\n * be a multiple of 64 (bytes). This is done by first adding 0x80 (10000000)\\n * and then only zeroes until the last 8 bytes must be filled, where then the\\n * 64 bit size of the input will be added\\n *\\n * Once this is done, the algo breaks down this padded message\\n * into 64 bytes chunks. Each chunk is used for one *round*, a round\\n * breaks the chunk into 16 blocks of 4 bytes. These 16 blocks are then extended\\n * to 80 blocks using XOR operations on existing blocks (see code for more\\n * details). The algorithm will then update its 160-bit state (here represented\\n * used 5 32-bits integer) using partial hashes computed using special functions\\n * on the blocks previously built. Please take a look at the [wikipedia\\n * article](https://en.wikipedia.org/wiki/SHA-1#SHA-1_pseudocode) for more\\n * precision on these operations\\n * @note This is a simple implementation for a byte string but\\n * some implmenetations can work on bytestream, messages of unknown length.\\n */\\n\\n#include <algorithm>  /// For std::copy\\n#include <array>      /// For std::array\\n#include <cassert>    /// For assert\\n#include <cstring>    /// For std::memcopy\\n#include <iostream>   /// For IO operations\\n#include <string>     /// For strings\\n#include <vector>     /// For std::vector\\n\\n/**\\n * @namespace hashing\\n * @brief Hashing algorithms\\n */\\nnamespace hashing {\\n/**\\n * @namespace SHA-1\\n * @brief Functions for the [SHA-1](https://en.wikipedia.org/wiki/SHA-1)\\n * algorithm implementation\\n */\\nnamespace sha1 {\\n/**\\n * @brief Rotates the bits of a 32-bit unsigned integer\\n * @param n Integer to rotate\\n * @param rotate How many bits for the rotation\\n * @return uint32_t The rotated integer\\n */\\nuint32_t leftRotate32bits(uint32_t n, std::size_t rotate) {\\n    return (n << rotate) | (n >> (32 - rotate));\\n}\\n\\n/**\\n * @brief Transforms the 160-bit SHA-1 signature into a 40 char hex string\\n * @param sig The SHA-1 signature (Expected 20 bytes)\\n * @return std::string The hex signature\\n */\\nstd::string sig2hex(void* sig) {\\n    const char* hexChars = \\\"0123456789abcdef\\\";\\n    auto* intsig = static_cast<uint8_t*>(sig);\\n    std::string hex = \\\"\\\";\\n    for (uint8_t i = 0; i < 20; i++) {\\n        hex.push_back(hexChars[(intsig[i] >> 4) & 0xF]);\\n        hex.push_back(hexChars[(intsig[i]) & 0xF]);\\n    }\\n    return hex;\\n}\\n\\n/**\\n * @brief The SHA-1 algorithm itself, taking in a bytestring\\n * @param input_bs The bytestring to hash\\n * @param input_size The size (in BYTES) of the input\\n * @return void* Pointer to the 160-bit signature\\n */\\nvoid* hash_bs(const void* input_bs, uint64_t input_size) {\\n    auto* input = static_cast<const uint8_t*>(input_bs);\\n\\n    // Step 0: The initial 160-bit state\\n    uint32_t h0 = 0x67452301, a = 0;\\n    uint32_t h1 = 0xEFCDAB89, b = 0;\\n    uint32_t h2 = 0x98BADCFE, c = 0;\\n    uint32_t h3 = 0x10325476, d = 0;\\n    uint32_t h4 = 0xC3D2E1F0, e = 0;\\n\\n    // Step 1: Processing the bytestring\\n    // First compute the size the padded message will have\\n    // so it is possible to allocate the right amount of memory\\n    uint64_t padded_message_size = 0;\\n    if (input_size % 64 < 56) {\\n        padded_message_size = input_size + 64 - (input_size % 64);\\n    } else {\\n        padded_message_size = input_size + 128 - (input_size % 64);\\n    }\\n\\n    // Allocate the memory for the padded message\\n    std::vector<uint8_t> padded_message(padded_message_size);\\n\\n    // Beginning of the padded message is the original message\\n    std::copy(input, input + input_size, padded_message.begin());\\n\\n    // Afterwards comes a single 1 bit and then only zeroes\\n    padded_message[input_size] = 1 << 7;  // 10000000\\n    for (uint64_t i = input_size; i % 64 != 56; i++) {\\n        if (i == input_size) {\\n            continue;  // pass first iteration\\n        }\\n        padded_message[i] = 0;\\n    }\\n\\n    // We then have to add the 64-bit size of the message in bits (hence the\\n    // times 8) in the last 8 bytes\\n    uint64_t input_bitsize = input_size * 8;\\n    for (uint8_t i = 0; i < 8; i++) {\\n        padded_message[padded_message_size - 8 + i] =\\n            (input_bitsize >> (56 - 8 * i)) & 0xFF;\\n    }\\n\\n    // Already allocate memory for blocks\\n    std::array<uint32_t, 80> blocks{};\\n\\n    // Rounds\\n    for (uint64_t chunk = 0; chunk * 64 < padded_message_size; chunk++) {\\n        // First, build 16 32-bits blocks from the chunk\\n        for (uint8_t bid = 0; bid < 16; bid++) {\\n            blocks[bid] = 0;\\n\\n            // Having to build a 32-bit word from 4-bit words\\n            // Add each and shift them to the left\\n            for (uint8_t cid = 0; cid < 4; cid++) {\\n                blocks[bid] = (blocks[bid] << 8) +\\n                              padded_message[chunk * 64 + bid * 4 + cid];\\n            }\\n\\n            // Extend the 16 32-bit words into 80 32-bit words\\n            for (uint8_t i = 16; i < 80; i++) {\\n                blocks[i] =\\n                    leftRotate32bits(blocks[i - 3] ^ blocks[i - 8] ^\\n                                         blocks[i - 14] ^ blocks[i - 16],\\n                                     1);\\n            }\\n        }\\n\\n        a = h0;\\n        b = h1;\\n        c = h2;\\n        d = h3;\\n        e = h4;\\n\\n        // Main \\\"hashing\\\" loop\\n        for (uint8_t i = 0; i < 80; i++) {\\n            uint32_t F = 0, g = 0;\\n            if (i < 20) {\\n                F = (b & c) | ((~b) & d);\\n                g = 0x5A827999;\\n            } else if (i < 40) {\\n                F = b ^ c ^ d;\\n                g = 0x6ED9EBA1;\\n            } else if (i < 60) {\\n                F = (b & c) | (b & d) | (c & d);\\n                g = 0x8F1BBCDC;\\n            } else {\\n                F = b ^ c ^ d;\\n                g = 0xCA62C1D6;\\n            }\\n\\n            // Update the accumulators\\n            uint32_t temp = leftRotate32bits(a, 5) + F + e + g + blocks[i];\\n            e = d;\\n            d = c;\\n            c = leftRotate32bits(b, 30);\\n            b = a;\\n            a = temp;\\n        }\\n        // Update the state with this chunk's hash\\n        h0 += a;\\n        h1 += b;\\n        h2 += c;\\n        h3 += d;\\n        h4 += e;\\n    }\\n\\n    // Build signature from state\\n    // Note, any type could be used for the signature\\n    // uint8_t was used to make the 20 bytes obvious\\n    auto* sig = new uint8_t[20];\\n    for (uint8_t i = 0; i < 4; i++) {\\n        sig[i] = (h0 >> (24 - 8 * i)) & 0xFF;\\n        sig[i + 4] = (h1 >> (24 - 8 * i)) & 0xFF;\\n        sig[i + 8] = (h2 >> (24 - 8 * i)) & 0xFF;\\n        sig[i + 12] = (h3 >> (24 - 8 * i)) & 0xFF;\\n        sig[i + 16] = (h4 >> (24 - 8 * i)) & 0xFF;\\n    }\\n\\n    return sig;\\n}\\n\\n/**\\n * @brief Converts the string to bytestring and calls the main algorithm\\n * @param message Plain character message to hash\\n * @return void* Pointer to the SHA-1 signature\\n */\\nvoid* hash(const std::string& message) {\\n    return hash_bs(&message[0], message.size());\\n}\\n}  // namespace sha1\\n}  // namespace hashing\\n\\n/**\\n * @brief Self-test implementations of well-known SHA-1 hashes\\n * @returns void\\n */\\nstatic void test() {\\n    // Hashes empty string and stores signature\\n    void* sig = hashing::sha1::hash(\\\"\\\");\\n    std::cout << \\\"Hashing empty string\\\" << std::endl;\\n    // Prints signature hex representation\\n    std::cout << hashing::sha1::sig2hex(sig) << std::endl << std::endl;\\n    // Test with cassert wether sig is correct from expected value\\n    assert(hashing::sha1::sig2hex(sig).compare(\\n               \\\"da39a3ee5e6b4b0d3255bfef95601890afd80709\\\") == 0);\\n\\n    // Hashes \\\"The quick brown fox jumps over the lazy dog\\\" and stores signature\\n    void* sig2 =\\n        hashing::sha1::hash(\\\"The quick brown fox jumps over the lazy dog\\\");\\n    std::cout << \\\"Hashing The quick brown fox jumps over the lazy dog\\\"\\n              << std::endl;\\n    // Prints signature hex representation\\n    std::cout << hashing::sha1::sig2hex(sig2) << std::endl << std::endl;\\n    // Test with cassert wether sig is correct from expected value\\n    assert(hashing::sha1::sig2hex(sig2).compare(\\n               \\\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\\\") == 0);\\n\\n    // Hashes \\\"The quick brown fox jumps over the lazy dog.\\\" (notice the\\n    // additional period) and stores signature\\n    void* sig3 =\\n        hashing::sha1::hash(\\\"The quick brown fox jumps over the lazy dog.\\\");\\n    std::cout << \\\"Hashing \\\"\\n                 \\\"The quick brown fox jumps over the lazy dog.\\\"\\n              << std::endl;\\n    // Prints signature hex representation\\n    std::cout << hashing::sha1::sig2hex(sig3) << std::endl << std::endl;\\n    // Test with cassert wether sig is correct from expected value\\n    assert(hashing::sha1::sig2hex(sig3).compare(\\n               \\\"408d94384216f890ff7a0c3528e8bed1e0b01621\\\") == 0);\\n\\n    // Hashes \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\"\\n    // and stores signature\\n    void* sig4 = hashing::sha1::hash(\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\");\\n    std::cout\\n        << \\\"Hashing \\\"\\n           \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\"\\n        << std::endl;\\n    // Prints signature hex representation\\n    std::cout << hashing::sha1::sig2hex(sig4) << std::endl << std::endl;\\n    // Test with cassert wether sig is correct from expected value\\n    assert(hashing::sha1::sig2hex(sig4).compare(\\n               \\\"761c457bf73b14d27e9e9265c46f4b4dda11f940\\\") == 0);\\n}\\n\\n/**\\n * @brief Puts user in a loop where inputs can be given and SHA-1 hash will be\\n * computed and printed\\n * @returns void\\n */\\nstatic void interactive() {\\n    while (true) {\\n        std::string input;\\n        std::cout << \\\"Enter a message to be hashed (Ctrl-C to exit): \\\"\\n                  << std::endl;\\n        std::getline(std::cin, input);\\n        void* sig = hashing::sha1::hash(input);\\n        std::cout << \\\"Hash is: \\\" << hashing::sha1::sig2hex(sig) << std::endl;\\n\\n        while (true) {\\n            std::cout << \\\"Want to enter another message? (y/n) \\\";\\n            std::getline(std::cin, input);\\n            if (input.compare(\\\"y\\\") == 0) {\\n                break;\\n            } else if (input.compare(\\\"n\\\") == 0) {\\n                return;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n\\n    // Launch interactive mode where user can input messages and see\\n    // their hash\\n    interactive();\\n    return 0;\\n}\\n\"",
    "gram schmidt": "\"/**\\n * @file\\n * @brief [Gram Schmidt Orthogonalisation\\n * Process](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process)\\n *\\n * @details\\n * Takes the input of Linearly Independent Vectors,\\n * returns vectors orthogonal to each other.\\n *\\n * ### Algorithm\\n * Take the first vector of given LI vectors as first vector of Orthogonal\\n * vectors. Take projection of second input vector on the first vector of\\n * Orthogonal vector and subtract it from the 2nd LI vector. Take projection of\\n * third vector on the second vector of Othogonal vectors and subtract it from\\n * the 3rd LI vector. Keep repeating the above process until all the vectors in\\n * the given input array are exhausted.\\n *\\n * For Example:\\n * In R2,\\n * Input LI Vectors={(3,1),(2,2)}\\n * then Orthogonal Vectors= {(3, 1),(-0.4, 1.2)}\\n *\\n *  Have defined maximum dimension of vectors to be 10 and number of vectors\\n *  taken is 20.\\n *  Please do not give linearly dependent vectors\\n *\\n *\\n * @author [Akanksha Gupta](https://github.com/Akanksha-Gupta920)\\n */\\n\\n#include <array>     /// for std::array\\n#include <cassert>   /// for assert\\n#include <cmath>     /// for fabs\\n#include <iostream>  /// for io operations\\n\\n#include \\\"math.h\\\"\\n\\n/**\\n * @namespace linear_algebra\\n * @brief Linear Algebra algorithms\\n */\\nnamespace linear_algebra {\\n/**\\n * @namespace gram_schmidt\\n * @brief Functions for [Gram Schmidt Orthogonalisation\\n * Process](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process)\\n */\\nnamespace gram_schmidt {\\n/**\\n * Dot product function.\\n * Takes 2 vectors along with their dimension as input and returns the dot\\n * product.\\n * @param x vector 1\\n * @param y vector 2\\n * @param c dimension of the vectors\\n *\\n * @returns sum\\n */\\ndouble dot_product(const std::array<double, 10>& x,\\n                   const std::array<double, 10>& y, const int& c) {\\n    double sum = 0;\\n    for (int i = 0; i < c; ++i) {\\n        sum += x[i] * y[i];\\n    }\\n    return sum;\\n}\\n\\n/**\\n * Projection Function\\n * Takes input of 2 vectors along with their dimension and evaluates their\\n * projection in temp\\n *\\n * @param x Vector 1\\n * @param y Vector 2\\n * @param c dimension of each vector\\n *\\n * @returns factor\\n */\\ndouble projection(const std::array<double, 10>& x,\\n                  const std::array<double, 10>& y, const int& c) {\\n    double dot =\\n        dot_product(x, y, c);  /// The dot product of two vectors is taken\\n    double anorm =\\n        dot_product(y, y, c);  /// The norm of the second vector is taken.\\n    double factor =\\n        dot /\\n        anorm;  /// multiply that factor with every element in a 3rd vector,\\n                /// whose initial values are same as the 2nd vector.\\n    return factor;\\n}\\n\\n/**\\n * Function to print the orthogonalised vector\\n *\\n * @param r number of vectors\\n * @param c dimenaion of vectors\\n * @param B stores orthogonalised vectors\\n *\\n * @returns void\\n */\\nvoid display(const int& r, const int& c,\\n             const std::array<std::array<double, 10>, 20>& B) {\\n    for (int i = 0; i < r; ++i) {\\n        std::cout << \\\"Vector \\\" << i + 1 << \\\": \\\";\\n        for (int j = 0; j < c; ++j) {\\n            std::cout << B[i][j] << \\\" \\\";\\n        }\\n        std::cout << '\\\\n';\\n    }\\n}\\n\\n/**\\n * Function for the process of Gram Schimdt Process\\n * @param r number of vectors\\n * @param c dimension of vectors\\n * @param A stores input of given LI vectors\\n * @param B stores orthogonalised vectors\\n *\\n * @returns void\\n */\\nvoid gram_schmidt(int r, const int& c,\\n                  const std::array<std::array<double, 10>, 20>& A,\\n                  std::array<std::array<double, 10>, 20> B) {\\n    if (c < r) {  /// we check whether appropriate dimensions are given or not.\\n        std::cout << \\\"Dimension of vector is less than number of vector, hence \\\"\\n                     \\\"\\\\n first \\\"\\n                  << c << \\\" vectors are orthogonalised\\\\n\\\";\\n        r = c;\\n    }\\n\\n    int k = 1;\\n\\n    while (k <= r) {\\n        if (k == 1) {\\n            for (int j = 0; j < c; j++)\\n                B[0][j] = A[0][j];  /// First vector is copied as it is.\\n        }\\n\\n        else {\\n            std::array<double, 10>\\n                all_projection{};  /// array to store projections\\n            for (int i = 0; i < c; ++i) {\\n                all_projection[i] = 0;  /// First initialised to zero\\n            }\\n\\n            int l = 1;\\n            while (l < k) {\\n                std::array<double, 10>\\n                    temp{};           /// to store previous projected array\\n                double factor = NAN;  /// to store the factor by which the\\n                                      /// previous array will change\\n                factor = projection(A[k - 1], B[l - 1], c);\\n                for (int i = 0; i < c; ++i) {\\n                    temp[i] = B[l - 1][i] * factor;  /// projected array created\\n                }\\n                for (int j = 0; j < c; ++j) {\\n                    all_projection[j] =\\n                        all_projection[j] +\\n                        temp[j];  /// we take the projection with all the\\n                                  /// previous vector and add them.\\n                }\\n                l++;\\n            }\\n            for (int i = 0; i < c; ++i) {\\n                B[k - 1][i] =\\n                    A[k - 1][i] -\\n                    all_projection[i];  /// subtract total projection vector\\n                                        /// from the input vector\\n            }\\n        }\\n        k++;\\n    }\\n    display(r, c, B);  // for displaying orthogoanlised vectors\\n}\\n}  // namespace gram_schmidt\\n}  // namespace linear_algebra\\n/**\\n * Test Function. Process has been tested for 3 Sample Inputs\\n * @returns void\\n */\\nstatic void test() {\\n    std::array<std::array<double, 10>, 20> a1 = {\\n        {{1, 0, 1, 0}, {1, 1, 1, 1}, {0, 1, 2, 1}}};\\n    std::array<std::array<double, 10>, 20> b1 = {{0}};\\n    double dot1 = 0;\\n    linear_algebra::gram_schmidt::gram_schmidt(3, 4, a1, b1);\\n    int flag = 1;\\n    for (int i = 0; i < 2; ++i) {\\n        for (int j = i + 1; j < 3; ++j) {\\n            dot1 = fabs(\\n                linear_algebra::gram_schmidt::dot_product(b1[i], b1[j], 4));\\n            if (dot1 > 0.1) {\\n                flag = 0;\\n                break;\\n            }\\n        }\\n    }\\n    if (flag == 0)\\n        std::cout << \\\"Vectors are linearly dependent\\\\n\\\";\\n    assert(flag == 1);\\n    std::cout << \\\"Passed Test Case 1\\\\n \\\";\\n\\n    std::array<std::array<double, 10>, 20> a2 = {{{3, 1}, {2, 2}}};\\n    std::array<std::array<double, 10>, 20> b2 = {{0}};\\n    double dot2 = 0;\\n    linear_algebra::gram_schmidt::gram_schmidt(2, 2, a2, b2);\\n    flag = 1;\\n    for (int i = 0; i < 1; ++i) {\\n        for (int j = i + 1; j < 2; ++j) {\\n            dot2 = fabs(\\n                linear_algebra::gram_schmidt::dot_product(b2[i], b2[j], 2));\\n            if (dot2 > 0.1) {\\n                flag = 0;\\n                break;\\n            }\\n        }\\n    }\\n    if (flag == 0)\\n        std::cout << \\\"Vectors are linearly dependent\\\\n\\\";\\n    assert(flag == 1);\\n    std::cout << \\\"Passed Test Case 2\\\\n\\\";\\n\\n    std::array<std::array<double, 10>, 20> a3 = {{{1, 2, 2}, {-4, 3, 2}}};\\n    std::array<std::array<double, 10>, 20> b3 = {{0}};\\n    double dot3 = 0;\\n    linear_algebra::gram_schmidt::gram_schmidt(2, 3, a3, b3);\\n    flag = 1;\\n    for (int i = 0; i < 1; ++i) {\\n        for (int j = i + 1; j < 2; ++j) {\\n            dot3 = fabs(\\n                linear_algebra::gram_schmidt::dot_product(b3[i], b3[j], 3));\\n            if (dot3 > 0.1) {\\n                flag = 0;\\n                break;\\n            }\\n        }\\n    }\\n    if (flag == 0)\\n        std::cout << \\\"Vectors are linearly dependent\\\\n\\\";\\n    assert(flag == 1);\\n    std::cout << \\\"Passed Test Case 3\\\\n\\\";\\n}\\n\\n/**\\n * @brief Main Function\\n * @return 0 on exit\\n */\\nint main() {\\n    int r = 0, c = 0;\\n    test();  // perform self tests\\n    std::cout << \\\"Enter the dimension of your vectors\\\\n\\\";\\n    std::cin >> c;\\n    std::cout << \\\"Enter the number of vectors you will enter\\\\n\\\";\\n    std::cin >> r;\\n\\n    std::array<std::array<double, 10>, 20>\\n        A{};  /// a 2-D array for storing all vectors\\n    std::array<std::array<double, 10>, 20> B = {\\n        {0}};  /// a 2-D array for storing orthogonalised vectors\\n    /// storing vectors in array A\\n    for (int i = 0; i < r; ++i) {\\n        std::cout << \\\"Enter vector \\\" << i + 1\\n                  << '\\\\n';  /// Input of vectors is taken\\n        for (int j = 0; j < c; ++j) {\\n            std::cout << \\\"Value \\\" << j + 1 << \\\"th of vector: \\\";\\n            std::cin >> A[i][j];\\n        }\\n        std::cout << '\\\\n';\\n    }\\n\\n    linear_algebra::gram_schmidt::gram_schmidt(r, c, A, B);\\n\\n    double dot = 0;\\n    int flag = 1;  /// To check whether vectors are orthogonal or  not\\n    for (int i = 0; i < r - 1; ++i) {\\n        for (int j = i + 1; j < r; ++j) {\\n            dot =\\n                fabs(linear_algebra::gram_schmidt::dot_product(B[i], B[j], c));\\n            if (dot > 0.1)  /// take make the process numerically stable, upper\\n                            /// bound for the dot product take 0.1\\n            {\\n                flag = 0;\\n                break;\\n            }\\n        }\\n    }\\n    if (flag == 0)\\n        std::cout << \\\"Vectors are linearly dependent\\\\n\\\";\\n    return 0;\\n}\\n\"",
    "adaline learning": "\"/**\\n * \\\\addtogroup machine_learning Machine Learning Algorithms\\n * @{\\n * \\\\file\\n * \\\\brief [Adaptive Linear Neuron\\n * (ADALINE)](https://en.wikipedia.org/wiki/ADALINE) implementation\\n *\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n *\\n * \\\\details\\n * <a href=\\\"https://commons.wikimedia.org/wiki/File:Adaline_flow_chart.gif\\\"><img\\n * src=\\\"https://upload.wikimedia.org/wikipedia/commons/b/be/Adaline_flow_chart.gif\\\"\\n * alt=\\\"Structure of an ADALINE network. Source: Wikipedia\\\"\\n * style=\\\"width:200px; float:right;\\\"></a>\\n *\\n * ADALINE is one of the first and simplest single layer artificial neural\\n * network. The algorithm essentially implements a linear function\\n * \\\\f[ f\\\\left(x_0,x_1,x_2,\\\\ldots\\\\right) =\\n * \\\\sum_j x_jw_j+\\\\theta\\n * \\\\f]\\n * where \\\\f$x_j\\\\f$ are the input features of a sample, \\\\f$w_j\\\\f$ are the\\n * coefficients of the linear function and \\\\f$\\\\theta\\\\f$ is a constant. If we\\n * know the \\\\f$w_j\\\\f$, then for any given set of features, \\\\f$y\\\\f$ can be\\n * computed. Computing the \\\\f$w_j\\\\f$ is a supervised learning algorithm wherein\\n * a set of features and their corresponding outputs are given and weights are\\n * computed using stochastic gradient descent method.\\n */\\n\\n#include <array>\\n#include <cassert>\\n#include <climits>\\n#include <cmath>\\n#include <cstdlib>\\n#include <ctime>\\n#include <iostream>\\n#include <numeric>\\n#include <vector>\\n\\n/** Maximum number of iterations to learn */\\nconstexpr int MAX_ITER = 500;  // INT_MAX\\n\\n/** \\\\namespace machine_learning\\n * \\\\brief Machine learning algorithms\\n */\\nnamespace machine_learning {\\nclass adaline {\\n public:\\n    /**\\n     * Default constructor\\n     * \\\\param[in] num_features number of features present\\n     * \\\\param[in] eta learning rate (optional, default=0.1)\\n     * \\\\param[in] convergence accuracy (optional,\\n     * default=\\\\f$1\\\\times10^{-5}\\\\f$)\\n     */\\n    explicit adaline(int num_features, const double eta = 0.01f,\\n                     const double accuracy = 1e-5)\\n        : eta(eta), accuracy(accuracy) {\\n        if (eta <= 0) {\\n            std::cerr << \\\"learning rate should be positive and nonzero\\\"\\n                      << std::endl;\\n            std::exit(EXIT_FAILURE);\\n        }\\n\\n        weights = std::vector<double>(\\n            num_features +\\n            1);  // additional weight is for the constant bias term\\n\\n        // initialize with random weights in the range [-50, 49]\\n        for (double &weight : weights) weight = 1.f;\\n        // weights[i] = (static_cast<double>(std::rand() % 100) - 50);\\n    }\\n\\n    /**\\n     * Operator to print the weights of the model\\n     */\\n    friend std::ostream &operator<<(std::ostream &out, const adaline &ada) {\\n        out << \\\"<\\\";\\n        for (int i = 0; i < ada.weights.size(); i++) {\\n            out << ada.weights[i];\\n            if (i < ada.weights.size() - 1) {\\n                out << \\\", \\\";\\n            }\\n        }\\n        out << \\\">\\\";\\n        return out;\\n    }\\n\\n    /**\\n     * predict the output of the model for given set of features\\n     * \\\\param[in] x input vector\\n     * \\\\param[out] out optional argument to return neuron output before\\n     * applying activation function (optional, `nullptr` to ignore) \\\\returns\\n     * model prediction output\\n     */\\n    int predict(const std::vector<double> &x, double *out = nullptr) {\\n        if (!check_size_match(x)) {\\n            return 0;\\n        }\\n\\n        double y = weights.back();  // assign bias value\\n\\n        // for (int i = 0; i < x.size(); i++) y += x[i] * weights[i];\\n        y = std::inner_product(x.begin(), x.end(), weights.begin(), y);\\n\\n        if (out != nullptr) {  // if out variable is provided\\n            *out = y;\\n        }\\n\\n        return activation(y);  // quantizer: apply ADALINE threshold function\\n    }\\n\\n    /**\\n     * Update the weights of the model using supervised learning for one\\n     * feature vector\\n     * \\\\param[in] x feature vector\\n     * \\\\param[in] y known output value\\n     * \\\\returns correction factor\\n     */\\n    double fit(const std::vector<double> &x, const int &y) {\\n        if (!check_size_match(x)) {\\n            return 0;\\n        }\\n\\n        /* output of the model with current weights */\\n        int p = predict(x);\\n        int prediction_error = y - p;  // error in estimation\\n        double correction_factor = eta * prediction_error;\\n\\n        /* update each weight, the last weight is the bias term */\\n        for (int i = 0; i < x.size(); i++) {\\n            weights[i] += correction_factor * x[i];\\n        }\\n        weights[x.size()] += correction_factor;  // update bias\\n\\n        return correction_factor;\\n    }\\n\\n    /**\\n     * Update the weights of the model using supervised learning for an\\n     * array of vectors.\\n     * \\\\param[in] X array of feature vector\\n     * \\\\param[in] y known output value for each feature vector\\n     */\\n    template <size_t N>\\n    void fit(std::array<std::vector<double>, N> const &X,\\n             std::array<int, N> const &Y) {\\n        double avg_pred_error = 1.f;\\n\\n        int iter = 0;\\n        for (iter = 0; (iter < MAX_ITER) && (avg_pred_error > accuracy);\\n             iter++) {\\n            avg_pred_error = 0.f;\\n\\n            // perform fit for each sample\\n            for (int i = 0; i < N; i++) {\\n                double err = fit(X[i], Y[i]);\\n                avg_pred_error += std::abs(err);\\n            }\\n            avg_pred_error /= N;\\n\\n            // Print updates every 200th iteration\\n            // if (iter % 100 == 0)\\n            std::cout << \\\"\\\\tIter \\\" << iter << \\\": Training weights: \\\" << *this\\n                      << \\\"\\\\tAvg error: \\\" << avg_pred_error << std::endl;\\n        }\\n\\n        if (iter < MAX_ITER) {\\n            std::cout << \\\"Converged after \\\" << iter << \\\" iterations.\\\"\\n                      << std::endl;\\n        } else {\\n            std::cout << \\\"Did not converge after \\\" << iter << \\\" iterations.\\\"\\n                      << std::endl;\\n        }\\n    }\\n\\n    /** Defines activation function as Heaviside's step function.\\n     * \\\\f[\\n     * f(x) = \\\\begin{cases}\\n     * -1 & \\\\forall x \\\\le 0\\\\\\\\\\n     *  1 & \\\\forall x > 0\\n     * \\\\end{cases}\\n     * \\\\f]\\n     * @param x input value to apply activation on\\n     * @return activation output\\n     */\\n    int activation(double x) { return x > 0 ? 1 : -1; }\\n\\n private:\\n    /**\\n     * convenient function to check if input feature vector size matches the\\n     * model weights size\\n     * \\\\param[in] x fecture vector to check\\n     * \\\\returns `true` size matches\\n     * \\\\returns `false` size does not match\\n     */\\n    bool check_size_match(const std::vector<double> &x) {\\n        if (x.size() != (weights.size() - 1)) {\\n            std::cerr << __func__ << \\\": \\\"\\n                      << \\\"Number of features in x does not match the feature \\\"\\n                         \\\"dimension in model!\\\"\\n                      << std::endl;\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    const double eta;             ///< learning rate of the algorithm\\n    const double accuracy;        ///< model fit convergence accuracy\\n    std::vector<double> weights;  ///< weights of the neural network\\n};\\n\\n}  // namespace machine_learning\\n\\nusing machine_learning::adaline;\\n\\n/** @} */\\n\\n/**\\n * test function to predict points in a 2D coordinate system above the line\\n * \\\\f$x=y\\\\f$ as +1 and others as -1.\\n * Note that each point is defined by 2 values or 2 features.\\n * \\\\param[in] eta learning rate (optional, default=0.01)\\n */\\nvoid test1(double eta = 0.01) {\\n    adaline ada(2, eta);  // 2 features\\n\\n    const int N = 10;  // number of sample points\\n\\n    std::array<std::vector<double>, N> X = {\\n        std::vector<double>({0, 1}),   std::vector<double>({1, -2}),\\n        std::vector<double>({2, 3}),   std::vector<double>({3, -1}),\\n        std::vector<double>({4, 1}),   std::vector<double>({6, -5}),\\n        std::vector<double>({-7, -3}), std::vector<double>({-8, 5}),\\n        std::vector<double>({-9, 2}),  std::vector<double>({-10, -15})};\\n    std::array<int, N> y = {1,  -1, 1, -1, -1,\\n                            -1, 1,  1, 1,  -1};  // corresponding y-values\\n\\n    std::cout << \\\"------- Test 1 -------\\\" << std::endl;\\n    std::cout << \\\"Model before fit: \\\" << ada << std::endl;\\n\\n    ada.fit<N>(X, y);\\n    std::cout << \\\"Model after fit: \\\" << ada << std::endl;\\n\\n    int predict = ada.predict({5, -3});\\n    std::cout << \\\"Predict for x=(5,-3): \\\" << predict;\\n    assert(predict == -1);\\n    std::cout << \\\" ...passed\\\" << std::endl;\\n\\n    predict = ada.predict({5, 8});\\n    std::cout << \\\"Predict for x=(5,8): \\\" << predict;\\n    assert(predict == 1);\\n    std::cout << \\\" ...passed\\\" << std::endl;\\n}\\n\\n/**\\n * test function to predict points in a 2D coordinate system above the line\\n * \\\\f$x+3y=-1\\\\f$ as +1 and others as -1.\\n * Note that each point is defined by 2 values or 2 features.\\n * The function will create random sample points for training and test purposes.\\n * \\\\param[in] eta learning rate (optional, default=0.01)\\n */\\nvoid test2(double eta = 0.01) {\\n    adaline ada(2, eta);  // 2 features\\n\\n    const int N = 50;  // number of sample points\\n\\n    std::array<std::vector<double>, N> X;\\n    std::array<int, N> Y{};  // corresponding y-values\\n\\n    // generate sample points in the interval\\n    // [-range2/100 , (range2-1)/100]\\n    int range = 500;          // sample points full-range\\n    int range2 = range >> 1;  // sample points half-range\\n    for (int i = 0; i < N; i++) {\\n        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\\n        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\\n        X[i] = std::vector<double>({x0, x1});\\n        Y[i] = (x0 + 3. * x1) > -1 ? 1 : -1;\\n    }\\n\\n    std::cout << \\\"------- Test 2 -------\\\" << std::endl;\\n    std::cout << \\\"Model before fit: \\\" << ada << std::endl;\\n\\n    ada.fit(X, Y);\\n    std::cout << \\\"Model after fit: \\\" << ada << std::endl;\\n\\n    int N_test_cases = 5;\\n    for (int i = 0; i < N_test_cases; i++) {\\n        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\\n        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\\n\\n        int predict = ada.predict({x0, x1});\\n\\n        std::cout << \\\"Predict for x=(\\\" << x0 << \\\",\\\" << x1 << \\\"): \\\" << predict;\\n\\n        int expected_val = (x0 + 3. * x1) > -1 ? 1 : -1;\\n        assert(predict == expected_val);\\n        std::cout << \\\" ...passed\\\" << std::endl;\\n    }\\n}\\n\\n/**\\n * test function to predict points in a 3D coordinate system lying within the\\n * sphere of radius 1 and centre at origin as +1 and others as -1. Note that\\n * each point is defined by 3 values but we use 6 features. The function will\\n * create random sample points for training and test purposes.\\n * The sphere centred at origin and radius 1 is defined as:\\n * \\\\f$x^2+y^2+z^2=r^2=1\\\\f$ and if the \\\\f$r^2<1\\\\f$, point lies within the sphere\\n * else, outside.\\n *\\n * \\\\param[in] eta learning rate (optional, default=0.01)\\n */\\nvoid test3(double eta = 0.01) {\\n    adaline ada(6, eta);  // 2 features\\n\\n    const int N = 100;  // number of sample points\\n\\n    std::array<std::vector<double>, N> X;\\n    std::array<int, N> Y{};  // corresponding y-values\\n\\n    // generate sample points in the interval\\n    // [-range2/100 , (range2-1)/100]\\n    int range = 200;          // sample points full-range\\n    int range2 = range >> 1;  // sample points half-range\\n    for (int i = 0; i < N; i++) {\\n        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\\n        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\\n        double x2 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\\n        X[i] = std::vector<double>({x0, x1, x2, x0 * x0, x1 * x1, x2 * x2});\\n        Y[i] = ((x0 * x0) + (x1 * x1) + (x2 * x2)) <= 1.f ? 1 : -1;\\n    }\\n\\n    std::cout << \\\"------- Test 3 -------\\\" << std::endl;\\n    std::cout << \\\"Model before fit: \\\" << ada << std::endl;\\n\\n    ada.fit(X, Y);\\n    std::cout << \\\"Model after fit: \\\" << ada << std::endl;\\n\\n    int N_test_cases = 5;\\n    for (int i = 0; i < N_test_cases; i++) {\\n        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\\n        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\\n        double x2 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\\n\\n        int predict = ada.predict({x0, x1, x2, x0 * x0, x1 * x1, x2 * x2});\\n\\n        std::cout << \\\"Predict for x=(\\\" << x0 << \\\",\\\" << x1 << \\\",\\\" << x2\\n                  << \\\"): \\\" << predict;\\n\\n        int expected_val = ((x0 * x0) + (x1 * x1) + (x2 * x2)) <= 1.f ? 1 : -1;\\n        assert(predict == expected_val);\\n        std::cout << \\\" ...passed\\\" << std::endl;\\n    }\\n}\\n\\n/** Main function */\\nint main(int argc, char **argv) {\\n    std::srand(std::time(nullptr));  // initialize random number generator\\n\\n    double eta = 0.1;  // default value of eta\\n    if (argc == 2) {   // read eta value from commandline argument if present\\n        eta = strtof(argv[1], nullptr);\\n    }\\n\\n    test1(eta);\\n\\n    std::cout << \\\"Press ENTER to continue...\\\" << std::endl;\\n    std::cin.get();\\n\\n    test2(eta);\\n\\n    std::cout << \\\"Press ENTER to continue...\\\" << std::endl;\\n    std::cin.get();\\n\\n    test3(eta);\\n\\n    return 0;\\n}\\n\"",
    "a star search": "\"/**\\n * @brief\\n * [A* search algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)\\n * @details\\n * A* is an informed search algorithm, or a best-first search, meaning that it\\n * is formulated in terms of weighted graphs: starting from a specific starting\\n * node of a graph (initial state), it aims to find a path to the given goal\\n * node having the smallest cost (least distance travelled, shortest time,\\n * etc.). It evaluates by maintaining a tree of paths originating at the start\\n * node and extending those paths one edge at a time until it reaches the final\\n * state.\\n * The weighted edges (or cost) is evaluated on two factors, G score\\n * (cost required from starting node or initial state to current state) and H\\n * score (cost required from current state to final state). The F(state), then\\n * is evaluated as:\\n * F(state) = G(state) + H(state).\\n *\\n * To solve the given search with shortest cost or path possible  is to inspect\\n * values having minimum F(state).\\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\\n */\\n#include <algorithm>   /// for `std::reverse` function\\n#include <array>       /// for `std::array`, representing `EightPuzzle` board\\n#include <cassert>     /// for `assert`\\n#include <functional>  /// for `std::function` STL\\n#include <iostream>    /// for IO operations\\n#include <map>         /// for `std::map` STL\\n#include <memory>      /// for `std::shared_ptr`\\n#include <set>         /// for `std::set` STL\\n#include <vector>      /// for `std::vector` STL\\n/**\\n * @namespace machine_learning\\n * @brief Machine learning algorithms\\n */\\nnamespace machine_learning {\\n/**\\n * @namespace aystar_search\\n * @brief Functions for [A*\\n * Search](https://en.wikipedia.org/wiki/A*_search_algorithm) implementation.\\n */\\nnamespace aystar_search {\\n/**\\n * @class EightPuzzle\\n * @brief A class defining [EightPuzzle/15-Puzzle\\n * game](https://en.wikipedia.org/wiki/15_puzzle).\\n * @details\\n * A well known 3 x 3 puzzle of the form\\n * `\\n * 1   2   3\\n * 4   5   6\\n * 7   8   0\\n * `\\n * where `0` represents an empty space in the puzzle\\n * Given any random state, the goal is to achieve the above configuration\\n * (or any other configuration if possible)\\n * @tparam N size of the square Puzzle, default is set to 3 (since it is\\n * EightPuzzle)\\n */\\ntemplate <size_t N = 3>\\nclass EightPuzzle {\\n    std::array<std::array<uint32_t, N>, N>\\n        board;  /// N x N array to store the current state of the Puzzle.\\n\\n    std::vector<std::pair<int8_t, int8_t>> moves = {\\n        {0, 1},\\n        {1, 0},\\n        {0, -1},\\n        {-1,\\n         0}};  /// A helper array to evaluate the next state from current state;\\n    /**\\n     * @brief Finds an empty space in puzzle (in this case; a zero)\\n     * @returns a pair indicating integer distances from top and right\\n     * respectively, else returns -1, -1\\n     */\\n    std::pair<uint32_t, uint32_t> find_zero() {\\n        for (size_t i = 0; i < N; ++i) {\\n            for (size_t j = 0; j < N; ++j) {\\n                if (!board[i][j]) {\\n                    return {i, j};\\n                }\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n    /**\\n     * @brief check whether the index value is bounded within the puzzle area\\n     * @param value index for the current board\\n     * @returns `true` if index is within the board, else `false`\\n     */\\n    inline bool in_range(const uint32_t value) const { return value < N; }\\n\\n public:\\n    /**\\n     * @brief get the value from i units from right and j units from left side\\n     * of the board\\n     * @param i integer denoting ith row\\n     * @param j integer denoting column\\n     * @returns non-negative integer denoting the value at ith row and jth\\n     * column\\n     * @returns -1 if invalid i or j position\\n     */\\n    uint32_t get(size_t i, size_t j) const {\\n        if (in_range(i) && in_range(j)) {\\n            return board[i][j];\\n        }\\n        return -1;\\n    }\\n    /**\\n     * @brief Returns the current state of the board\\n     */\\n    std::array<std::array<uint32_t, N>, N> get_state() { return board; }\\n\\n    /**\\n     * @brief returns the size of the EightPuzzle (number of row / column)\\n     * @return N, the size of the puzzle.\\n     */\\n    inline size_t get_size() const { return N; }\\n    /**\\n     * @brief Default constructor for EightPuzzle\\n     */\\n    EightPuzzle() {\\n        for (size_t i = 0; i < N; ++i) {\\n            for (size_t j = 0; j < N; ++j) {\\n                board[i][j] = ((i * 3 + j + 1) % (N * N));\\n            }\\n        }\\n    }\\n    /**\\n     * @brief Parameterized Constructor for EightPuzzle\\n     * @param init a 2-dimensional array denoting a puzzle configuration\\n     */\\n    explicit EightPuzzle(const std::array<std::array<uint32_t, N>, N> &init)\\n        : board(init) {}\\n\\n    /**\\n     * @brief Copy constructor\\n     * @param A a reference of an EightPuzzle\\n     */\\n    EightPuzzle(const EightPuzzle<N> &A) : board(A.board) {}\\n\\n    /**\\n     * @brief Move constructor\\n     * @param A a reference of an EightPuzzle\\n     */\\n    EightPuzzle(const EightPuzzle<N> &&A) noexcept\\n        : board(std::move(A.board)) {}\\n    /**\\n     * @brief Destructor of EightPuzzle\\n     */\\n    ~EightPuzzle() = default;\\n\\n    /**\\n     * @brief Copy assignment operator\\n     * @param A a reference of an EightPuzzle\\n     */\\n    EightPuzzle &operator=(const EightPuzzle &A) {\\n        board = A.board;\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief Move assignment operator\\n     * @param A a reference of an EightPuzzle\\n     */\\n    EightPuzzle &operator=(EightPuzzle &&A) noexcept {\\n        board = std::move(A.board);\\n        return *this;\\n    }\\n\\n    /**\\n     * @brief Find all possible states after processing all possible\\n     * moves, given the current state of the puzzle\\n     * @returns list of vector containing all possible next moves\\n     * @note the implementation is compulsory to create A* search\\n     */\\n    std::vector<EightPuzzle<N>> generate_possible_moves() {\\n        auto zero_pos = find_zero();\\n        // vector which will contain all possible state from current state\\n        std::vector<EightPuzzle<N>> NewStates;\\n        for (auto &move : moves) {\\n            if (in_range(zero_pos.first + move.first) &&\\n                in_range(zero_pos.second + move.second)) {\\n                // swap with the possible moves\\n                std::array<std::array<uint32_t, N>, N> new_config = board;\\n                std::swap(new_config[zero_pos.first][zero_pos.second],\\n                          new_config[zero_pos.first + move.first]\\n                                    [zero_pos.second + move.second]);\\n                EightPuzzle<N> new_state(new_config);\\n                // Store new state and calculate heuristic value, and depth\\n                NewStates.emplace_back(new_state);\\n            }\\n        }\\n        return NewStates;\\n    }\\n    /**\\n     * @brief check whether two boards are equal\\n     * @returns `true` if check.state is equal to `this->state`, else\\n     * `false`\\n     */\\n    bool operator==(const EightPuzzle<N> &check) const {\\n        if (check.get_size() != N) {\\n            return false;\\n        }\\n        for (size_t i = 0; i < N; ++i) {\\n            for (size_t j = 0; j < N; ++j) {\\n                if (board[i][j] != check.board[i][j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    /**\\n     * @brief check whether one board is lexicographically smaller\\n     * @returns `true` if this->state is lexicographically smaller than\\n     * `check.state`, else `false`\\n     */\\n    bool operator<(const EightPuzzle<N> &check) const {\\n        for (size_t i = 0; i < N; ++i) {\\n            for (size_t j = 0; j < N; ++j) {\\n                if (board[i][j] != check.board[i][j]) {\\n                    return board[i][j] < check.board[i][j];\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    /**\\n     * @brief check whether one board is lexicographically smaller or equal\\n     * @returns `true` if this->state is lexicographically smaller than\\n     * `check.state` or same, else `false`\\n     */\\n    bool operator<=(const EightPuzzle<N> &check) const {\\n        for (size_t i = 0; i < N; ++i) {\\n            for (size_t j = 0; j < N; ++j) {\\n                if (board[i][j] != check.board[i][j]) {\\n                    return board[i][j] < check.board[i][j];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @brief friend operator to display EightPuzzle<>\\n     * @param op ostream object\\n     * @param SomeState a certain state.\\n     * @returns ostream operator op\\n     */\\n    friend std::ostream &operator<<(std::ostream &op,\\n                                    const EightPuzzle<N> &SomeState) {\\n        for (size_t i = 0; i < N; ++i) {\\n            for (size_t j = 0; j < N; ++j) {\\n                op << SomeState.board[i][j] << \\\" \\\";\\n            }\\n            op << \\\"\\\\n\\\";\\n        }\\n        return op;\\n    }\\n};\\n/**\\n * @class AyStarSearch\\n * @brief A class defining [A* search\\n * algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm). for some\\n * initial state and final state\\n * @details AyStarSearch class is defined as the informed search algorithm\\n * that is formulated in terms of weighted graphs: starting from a specific\\n * starting node of a graph (initial state), it aims to find a path to the given\\n * goal node having the smallest cost (least distance travelled, shortest time,\\n * etc.)\\n * The weighted edges (or cost) is evaluated on two factors, G score\\n * (cost required from starting node or initial state to current state) and H\\n * score (cost required from current state to final state). The `F(state)`, then\\n * is evaluated as:\\n * `F(state) = G(state) + H(state)`.\\n * The best search would be the final state having minimum `F(state)` value\\n * @tparam Puzzle denotes the puzzle or problem involving initial state and\\n * final state to be solved by A* search.\\n * @note 1. The algorithm is referred from pesudocode from\\n * [Wikipedia page](https://en.wikipedia.org/wiki/A*_search_algorithm)\\n * as is.\\n * 2. For `AyStarSearch` to work, the definitions for template Puzzle is\\n * compulsory.\\n * a. Comparison operator for template Puzzle (`<`, `==`, and `<=`)\\n * b. `generate_possible_moves()`\\n */\\ntemplate <typename Puzzle>\\nclass AyStarSearch {\\n    /**\\n     * @brief Struct that handles all the information related to the current\\n     * state.\\n     */\\n    typedef struct Info {\\n        std::shared_ptr<Puzzle> state;  /// Holds the current state.\\n        size_t heuristic_value = 0;     /// stores h score\\n        size_t depth = 0;               /// stores g score\\n\\n        /**\\n         * @brief Default constructor\\n         */\\n        Info() = default;\\n\\n        /**\\n         * @brief constructor having Puzzle as parameter\\n         * @param A a puzzle object\\n         */\\n        explicit Info(const Puzzle &A) : state(std::make_shared<Puzzle>(A)) {}\\n\\n        /**\\n         * @brief constructor having three parameters\\n         * @param A a puzzle object\\n         * @param h_value heuristic value of this puzzle object\\n         * @param depth the depth at which this node was found during traversal\\n         */\\n        Info(const Puzzle &A, size_t h_value, size_t d)\\n            : state(std::make_shared<Puzzle>(A)),\\n              heuristic_value(h_value),\\n              depth(d) {}\\n\\n        /**\\n         * @brief Copy constructor\\n         * @param A Info object reference\\n         */\\n        Info(const Info &A)\\n            : state(std::make_shared<Puzzle>(A.state)),\\n              heuristic_value(A.heuristic_value),\\n              depth(A.depth) {}\\n\\n        /**\\n         * @brief Move constructor\\n         * @param A Info object reference\\n         */\\n        Info(const Info &&A) noexcept\\n            : state(std::make_shared<Puzzle>(std::move(A.state))),\\n              heuristic_value(std::move(A.heuristic_value)),\\n              depth(std::move(A.depth)) {}\\n\\n        /**\\n         * @brief copy assignment operator\\n         * @param A Info object reference\\n         */\\n        Info &operator=(const Info &A) {\\n            state = A.state;\\n            heuristic_value = A.heuristic_value;\\n            depth = A.depth;\\n            return *this;\\n        }\\n\\n        /**\\n         * @brief move assignment operator\\n         * @param A Info object reference\\n         */\\n        Info &operator=(Info &&A) noexcept {\\n            state = std::move(A.state);\\n            heuristic_value = std::move(A.heuristic_value);\\n            depth = std::move(A.depth);\\n            return *this;\\n        }\\n        /**\\n         * @brief Destructor for Info\\n         */\\n        ~Info() = default;\\n    } Info;\\n\\n    std::shared_ptr<Info> Initial;  // Initial state of the AyStarSearch\\n    std::shared_ptr<Info> Final;    // Final state of the AyStarSearch\\n    /**\\n     * @brief Custom comparator for open_list\\n     */\\n    struct comparison_operator {\\n        bool operator()(const std::shared_ptr<Info> &a,\\n                        const std::shared_ptr<Info> &b) const {\\n            return *(a->state) < *(b->state);\\n        }\\n    };\\n\\n public:\\n    using MapOfPuzzleInfoWithPuzzleInfo =\\n        std::map<std::shared_ptr<Info>, std::shared_ptr<Info>,\\n                 comparison_operator>;\\n\\n    using MapOfPuzzleInfoWithInteger =\\n        std::map<std::shared_ptr<Info>, uint32_t, comparison_operator>;\\n\\n    using SetOfPuzzleInfo =\\n        std::set<std::shared_ptr<Info>, comparison_operator>;\\n    /**\\n     * @brief Parameterized constructor for AyStarSearch\\n     * @param initial denoting initial state of the puzzle\\n     * @param final denoting final state of the puzzle\\n     */\\n    AyStarSearch(const Puzzle &initial, const Puzzle &final) {\\n        Initial = std::make_shared<Info>(initial);\\n        Final = std::make_shared<Info>(final);\\n    }\\n    /**\\n     * @brief A helper solution: launches when a solution for AyStarSearch\\n     * is found\\n     * @param FinalState the pointer to the obtained final state\\n     * @param parent_of the list of all parents of nodes stored during A*\\n     * search\\n     * @returns the list of moves denoting moves from final state to initial\\n     * state (in reverse)\\n     */\\n    std::vector<Puzzle> Solution(\\n        std::shared_ptr<Info> FinalState,\\n        const MapOfPuzzleInfoWithPuzzleInfo &parent_of) {\\n        //  Useful for traversing from final state to current state.\\n        auto current_state = FinalState;\\n        /*\\n         * For storing the solution tree starting from initial state to\\n         * final state\\n         */\\n        std::vector<Puzzle> answer;\\n        while (current_state != nullptr) {\\n            answer.emplace_back(*current_state->state);\\n            current_state = parent_of.find(current_state)->second;\\n        }\\n        return answer;\\n    }\\n    /**\\n     * Main algorithm for finding `FinalState`, given the `InitialState`\\n     * @param dist the heuristic finction, defined by the user\\n     * @param permissible_depth the depth at which the A* search discards\\n     * searching for solution\\n     * @returns List of moves from Final state to initial state, if\\n     * evaluated, else returns an empty array\\n     */\\n    std::vector<Puzzle> a_star_search(\\n        const std::function<uint32_t(const Puzzle &, const Puzzle &)> &dist,\\n        const uint32_t permissible_depth = 30) {\\n        MapOfPuzzleInfoWithPuzzleInfo\\n            parent_of;                       /// Stores the parent of the states\\n        MapOfPuzzleInfoWithInteger g_score;  /// Stores the g_score\\n        SetOfPuzzleInfo open_list;           /// Stores the list to explore\\n        SetOfPuzzleInfo closed_list;  /// Stores the list that are explored\\n\\n        // Before starting the AyStartSearch, initialize the set and maps\\n        open_list.emplace(Initial);\\n        parent_of[Initial] = nullptr;\\n        g_score[Initial] = 0;\\n\\n        while (!open_list.empty()) {\\n            // Iterator for state having having lowest f_score.\\n            typename SetOfPuzzleInfo::iterator it_low_f_score;\\n            uint32_t min_f_score = 1e9;\\n            for (auto iter = open_list.begin(); iter != open_list.end();\\n                 ++iter) {\\n                // f score here is evaluated by g score (depth) and h score\\n                // (distance between current state and final state)\\n                uint32_t f_score = (*iter)->heuristic_value + (*iter)->depth;\\n                if (f_score < min_f_score) {\\n                    min_f_score = f_score;\\n                    it_low_f_score = iter;\\n                }\\n            }\\n\\n            // current_state, stores lowest f score so far for this state.\\n            std::shared_ptr<Info> current_state = *it_low_f_score;\\n\\n            // if this current state is equal to final, return\\n            if (*(current_state->state) == *(Final->state)) {\\n                return Solution(current_state, parent_of);\\n            }\\n            // else remove from open list as visited.\\n            open_list.erase(it_low_f_score);\\n            // if current_state has exceeded the allowed depth, skip\\n            // neighbor checking\\n            if (current_state->depth >= permissible_depth) {\\n                continue;\\n            }\\n            // Generate all possible moves (neighbors) given the current\\n            // state\\n            std::vector<Puzzle> total_possible_moves =\\n                current_state->state->generate_possible_moves();\\n\\n            for (Puzzle &neighbor : total_possible_moves) {\\n                // calculate score of neighbors with respect to\\n                // current_state\\n                std::shared_ptr<Info> Neighbor = std::make_shared<Info>(\\n                    neighbor, dist(neighbor, *(Final->state)),\\n                    current_state->depth + 1U);\\n                uint32_t temp_g_score = Neighbor->depth;\\n\\n                // Check whether this state is explored.\\n                // If this state is discovered at greater depth, then discard,\\n                // else remove from closed list and explore the node\\n                auto closed_list_iter = closed_list.find(Neighbor);\\n                if (closed_list_iter != closed_list.end()) {\\n                    // 1. If state in closed list has higher depth, then remove\\n                    // from list since we have found better option,\\n                    // 2. Else don't explore this state.\\n                    if (Neighbor->depth < (*closed_list_iter)->depth) {\\n                        closed_list.erase(closed_list_iter);\\n                    } else {\\n                        continue;\\n                    }\\n                }\\n                auto neighbor_g_score_iter = g_score.find(Neighbor);\\n                // if the neighbor is already created and has minimum\\n                // g_score, then update g_score and f_score else insert new\\n                if (neighbor_g_score_iter != g_score.end()) {\\n                    if (neighbor_g_score_iter->second > temp_g_score) {\\n                        neighbor_g_score_iter->second = temp_g_score;\\n                        parent_of[Neighbor] = current_state;\\n                    }\\n                } else {\\n                    g_score[Neighbor] = temp_g_score;\\n                    parent_of[Neighbor] = current_state;\\n                }\\n                // If this is a new state, insert into open_list\\n                // else update if the this state has better g score than\\n                // existing one.\\n                auto iter = open_list.find(Neighbor);\\n                if (iter == open_list.end()) {\\n                    open_list.emplace(Neighbor);\\n                } else if ((*iter)->depth > Neighbor->depth) {\\n                    (*iter)->depth = Neighbor->depth;\\n                }\\n            }\\n            closed_list.emplace(current_state);\\n        }\\n        // Cannot find the solution, return empty vector\\n        return std::vector<Puzzle>(0);\\n    }\\n};\\n}  // namespace aystar_search\\n}  // namespace machine_learning\\n\\n/**\\n * @brief Self test-implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // Renaming for simplicity\\n    using matrix3 = std::array<std::array<uint32_t, 3>, 3>;\\n    using row3 = std::array<uint32_t, 3>;\\n    using matrix4 = std::array<std::array<uint32_t, 4>, 4>;\\n    using row4 = std::array<uint32_t, 4>;\\n    // 1st test: A* search for simple EightPuzzle problem\\n    matrix3 puzzle;\\n    puzzle[0] = row3({0, 2, 3});\\n    puzzle[1] = row3({1, 5, 6});\\n    puzzle[2] = row3({4, 7, 8});\\n\\n    matrix3 ideal;\\n    ideal[0] = row3({1, 2, 3});\\n    ideal[1] = row3({4, 5, 6});\\n    ideal[2] = row3({7, 8, 0});\\n\\n    /*\\n     * Heuristic function: Manhattan distance\\n     */\\n    auto manhattan_distance =\\n        [](const machine_learning::aystar_search::EightPuzzle<> &first,\\n           const machine_learning::aystar_search::EightPuzzle<> &second) {\\n            uint32_t ret = 0;\\n            for (size_t i = 0; i < first.get_size(); ++i) {\\n                for (size_t j = 0; j < first.get_size(); ++j) {\\n                    uint32_t find = first.get(i, j);\\n                    size_t m = first.get_size(), n = first.get_size();\\n                    for (size_t k = 0; k < second.get_size(); ++k) {\\n                        for (size_t l = 0; l < second.get_size(); ++l) {\\n                            if (find == second.get(k, l)) {\\n                                std::tie(m, n) = std::make_pair(k, l);\\n                                break;\\n                            }\\n                        }\\n                        if (m != first.get_size()) {\\n                            break;\\n                        }\\n                    }\\n                    if (m != first.get_size()) {\\n                        ret += (std::max(m, i) - std::min(m, i)) +\\n                               (std::max(n, j) - std::min(n, j));\\n                    }\\n                }\\n            }\\n            return ret;\\n        };\\n\\n    machine_learning::aystar_search::EightPuzzle<> Puzzle(puzzle);\\n    machine_learning::aystar_search::EightPuzzle<> Ideal(ideal);\\n    machine_learning::aystar_search::AyStarSearch<\\n        machine_learning::aystar_search::EightPuzzle<3>>\\n        search(Puzzle, Ideal);  /// Search object\\n\\n    std::vector<matrix3> answer;  /// Array that validates the answer\\n\\n    answer.push_back(\\n        matrix3({row3({0, 2, 3}), row3({1, 5, 6}), row3({4, 7, 8})}));\\n    answer.push_back(\\n        matrix3({row3({1, 2, 3}), row3({0, 5, 6}), row3({4, 7, 8})}));\\n    answer.push_back(\\n        matrix3({row3({1, 2, 3}), row3({4, 5, 6}), row3({0, 7, 8})}));\\n    answer.push_back(\\n        matrix3({row3({1, 2, 3}), row3({4, 5, 6}), row3({7, 0, 8})}));\\n    answer.push_back(\\n        matrix3({row3({1, 2, 3}), row3({4, 5, 6}), row3({7, 8, 0})}));\\n\\n    auto Solution = search.a_star_search(manhattan_distance);\\n    std::cout << Solution.size() << std::endl;\\n\\n    assert(Solution.size() == answer.size());\\n\\n    uint32_t i = 0;\\n    for (auto it = Solution.rbegin(); it != Solution.rend(); ++it) {\\n        assert(it->get_state() == answer[i]);\\n        ++i;\\n    }\\n\\n    // 2nd test: A* search for complicated EightPuzzle problem\\n    // Initial state\\n    puzzle[0] = row3({5, 7, 3});\\n    puzzle[1] = row3({2, 0, 6});\\n    puzzle[2] = row3({1, 4, 8});\\n    // Final state\\n    ideal[0] = row3({1, 2, 3});\\n    ideal[1] = row3({4, 5, 6});\\n    ideal[2] = row3({7, 8, 0});\\n\\n    Puzzle = machine_learning::aystar_search::EightPuzzle<>(puzzle);\\n    Ideal = machine_learning::aystar_search::EightPuzzle<>(ideal);\\n\\n    // Initialize the search object\\n    search = machine_learning::aystar_search::AyStarSearch<\\n        machine_learning::aystar_search::EightPuzzle<3>>(Puzzle, Ideal);\\n\\n    Solution = search.a_star_search(manhattan_distance);\\n    std::cout << Solution.size() << std::endl;\\n    // Static assertion due to large solution\\n    assert(13 == Solution.size());\\n    // Check whether the final state is equal to expected one\\n    assert(Solution[0].get_state() == ideal);\\n    for (auto it = Solution.rbegin(); it != Solution.rend(); ++it) {\\n        std::cout << *it << std::endl;\\n    }\\n\\n    // 3rd test: A* search for 15-Puzzle\\n    // Initial State of the puzzle\\n    matrix4 puzzle2;\\n    puzzle2[0] = row4({10, 1, 6, 2});\\n    puzzle2[1] = row4({5, 8, 4, 3});\\n    puzzle2[2] = row4({13, 0, 7, 11});\\n    puzzle2[3] = row4({14, 9, 15, 12});\\n    // Final state of the puzzle\\n    matrix4 ideal2;\\n    ideal2[0] = row4({1, 2, 3, 4});\\n    ideal2[1] = row4({5, 6, 7, 8});\\n    ideal2[2] = row4({9, 10, 11, 12});\\n    ideal2[3] = row4({13, 14, 15, 0});\\n\\n    // Instantiate states for a*, initial state and final states\\n    machine_learning::aystar_search::EightPuzzle<4> Puzzle2(puzzle2),\\n        Ideal2(ideal2);\\n    // Initialize the search object\\n    machine_learning::aystar_search::AyStarSearch<\\n        machine_learning::aystar_search::EightPuzzle<4>>\\n        search2(Puzzle2, Ideal2);\\n    /**\\n     * Heuristic function: Manhattan distance\\n     */\\n    auto manhattan_distance2 =\\n        [](const machine_learning::aystar_search::EightPuzzle<4> &first,\\n           const machine_learning::aystar_search::EightPuzzle<4> &second) {\\n            uint32_t ret = 0;\\n            for (size_t i = 0; i < first.get_size(); ++i) {\\n                for (size_t j = 0; j < first.get_size(); ++j) {\\n                    uint32_t find = first.get(i, j);\\n                    size_t m = first.get_size(), n = first.get_size();\\n                    for (size_t k = 0; k < second.get_size(); ++k) {\\n                        for (size_t l = 0; l < second.get_size(); ++l) {\\n                            if (find == second.get(k, l)) {\\n                                std::tie(m, n) = std::make_pair(k, l);\\n                                break;\\n                            }\\n                        }\\n                        if (m != first.get_size()) {\\n                            break;\\n                        }\\n                    }\\n                    if (m != first.get_size()) {\\n                        ret += (std::max(m, i) - std::min(m, i)) +\\n                               (std::max(n, j) - std::min(n, j));\\n                    }\\n                }\\n            }\\n            return ret;\\n        };\\n\\n    auto sol2 = search2.a_star_search(manhattan_distance2);\\n    std::cout << sol2.size() << std::endl;\\n\\n    // Static assertion due to large solution\\n    assert(24 == sol2.size());\\n    // Check whether the final state is equal to expected one\\n    assert(sol2[0].get_state() == ideal2);\\n\\n    for (auto it = sol2.rbegin(); it != sol2.rend(); ++it) {\\n        std::cout << *it << std::endl;\\n    }\\n}\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "kohonen som topology": "\"/**\\n * \\\\addtogroup machine_learning Machine Learning Algorithms\\n * @{\\n * \\\\file\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n *\\n * \\\\brief [Kohonen self organizing\\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (topological map)\\n *\\n * \\\\details\\n * This example implements a powerful unsupervised learning algorithm called as\\n * a self organizing map. The algorithm creates a connected network of weights\\n * that closely follows the given data points. This thus creates a topological\\n * map of the given data i.e., it maintains the relationship between varipus\\n * data points in a much higher dimesional space by creating an equivalent in a\\n * 2-dimensional space.\\n * <img alt=\\\"Trained topological maps for the test cases in the program\\\"\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/2D_Kohonen_SOM.svg\\\"\\n * />\\n * \\\\note This C++ version of the program is considerable slower than its [C\\n * counterpart](https://github.com/kvedala/C/blob/master/machine_learning/kohonen_som_trace.c)\\n * \\\\note The compiled code is much slower when compiled with MS Visual C++ 2019\\n * than with GCC on windows\\n * \\\\see kohonen_som_trace.cpp\\n */\\n#define _USE_MATH_DEFINES  //< required for MS Visual C++\\n#include <algorithm>\\n#include <array>\\n#include <cerrno>\\n#include <cmath>\\n#include <cstdlib>\\n#include <cstring>\\n#include <ctime>\\n#include <fstream>\\n#include <iostream>\\n#include <valarray>\\n#include <vector>\\n#ifdef _OPENMP  // check if OpenMP based parallellization is available\\n#include <omp.h>\\n#endif\\n\\n/**\\n * Helper function to generate a random number in a given interval.\\n * \\\\n Steps:\\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\\n * 3. scale and offset the random number to given range of \\\\f$[a,b]\\\\f$\\n *\\n * \\\\param[in] a lower limit\\n * \\\\param[in] b upper limit\\n * \\\\returns random number in the range \\\\f$[a,b]\\\\f$\\n */\\ndouble _random(double a, double b) {\\n    return ((b - a) * (std::rand() % 100) / 100.f) + a;\\n}\\n\\n/**\\n * Save a given n-dimensional data martix to file.\\n *\\n * \\\\param[in] fname filename to save in (gets overwriten without confirmation)\\n * \\\\param[in] X matrix to save\\n * \\\\returns 0 if all ok\\n * \\\\returns -1 if file creation failed\\n */\\nint save_2d_data(const char *fname,\\n                 const std::vector<std::valarray<double>> &X) {\\n    size_t num_points = X.size();       // number of rows\\n    size_t num_features = X[0].size();  // number of columns\\n\\n    std::ofstream fp;\\n    fp.open(fname);\\n    if (!fp.is_open()) {\\n        // error with opening file to write\\n        std::cerr << \\\"Error opening file \\\" << fname << \\\": \\\"\\n                  << std::strerror(errno) << \\\"\\\\n\\\";\\n        return -1;\\n    }\\n\\n    // for each point in the array\\n    for (int i = 0; i < num_points; i++) {\\n        // for each feature in the array\\n        for (int j = 0; j < num_features; j++) {\\n            fp << X[i][j];               // print the feature value\\n            if (j < num_features - 1) {  // if not the last feature\\n                fp << \\\",\\\";               // suffix comma\\n            }\\n        }\\n        if (i < num_points - 1) {  // if not the last row\\n            fp << \\\"\\\\n\\\";            // start a new line\\n        }\\n    }\\n\\n    fp.close();\\n    return 0;\\n}\\n\\n/**\\n * Get minimum value and index of the value in a matrix\\n * \\\\param[in] X matrix to search\\n * \\\\param[in] N number of points in the vector\\n * \\\\param[out] val minimum value found\\n * \\\\param[out] idx_x x-index where minimum value was found\\n * \\\\param[out] idx_y y-index where minimum value was found\\n */\\nvoid get_min_2d(const std::vector<std::valarray<double>> &X, double *val,\\n                int *x_idx, int *y_idx) {\\n    val[0] = INFINITY;  // initial min value\\n    size_t N = X.size();\\n\\n    for (int i = 0; i < N; i++) {  // traverse each x-index\\n        auto result = std::min_element(std::begin(X[i]), std::end(X[i]));\\n        double d_min = *result;\\n        std::ptrdiff_t j = std::distance(std::begin(X[i]), result);\\n\\n        if (d_min < val[0]) {  // if a lower value is found\\n                               // save the value and its index\\n            x_idx[0] = i;\\n            y_idx[0] = j;\\n            val[0] = d_min;\\n        }\\n    }\\n}\\n\\n/** \\\\namespace machine_learning\\n * \\\\brief Machine learning algorithms\\n */\\nnamespace machine_learning {\\n/** Minimum average distance of image nodes */\\nconstexpr double MIN_DISTANCE = 1e-4;\\n\\n/**\\n * Create the distance matrix or\\n * [U-matrix](https://en.wikipedia.org/wiki/U-matrix) from the trained\\n * 3D weiths matrix and save to disk.\\n *\\n * \\\\param [in] fname filename to save in (gets overwriten without\\n * confirmation)\\n * \\\\param [in] W model matrix to save\\n * \\\\returns 0 if all ok\\n * \\\\returns -1 if file creation failed\\n */\\nint save_u_matrix(const char *fname,\\n                  const std::vector<std::vector<std::valarray<double>>> &W) {\\n    std::ofstream fp(fname);\\n    if (!fp) {  // error with fopen\\n        std::cerr << \\\"File error (\\\" << fname << \\\"): \\\" << std::strerror(errno)\\n                  << std::endl;\\n        return -1;\\n    }\\n\\n    // neighborhood range\\n    unsigned int R = 1;\\n\\n    for (int i = 0; i < W.size(); i++) {         // for each x\\n        for (int j = 0; j < W[0].size(); j++) {  // for each y\\n            double distance = 0.f;\\n\\n            int from_x = std::max<int>(0, i - R);\\n            int to_x = std::min<int>(W.size(), i + R + 1);\\n            int from_y = std::max<int>(0, j - R);\\n            int to_y = std::min<int>(W[0].size(), j + R + 1);\\n            int l = 0, m = 0;\\n#ifdef _OPENMP\\n#pragma omp parallel for reduction(+ : distance)\\n#endif\\n            for (l = from_x; l < to_x; l++) {      // scan neighborhoor in x\\n                for (m = from_y; m < to_y; m++) {  // scan neighborhood in y\\n                    auto d = W[i][j] - W[l][m];\\n                    double d2 = std::pow(d, 2).sum();\\n                    distance += std::sqrt(d2);\\n                    // distance += d2;\\n                }\\n            }\\n\\n            distance /= R * R;          // mean distance from neighbors\\n            fp << distance;             // print the mean separation\\n            if (j < W[0].size() - 1) {  // if not the last column\\n                fp << ',';              // suffix comma\\n            }\\n        }\\n        if (i < W.size() - 1) {  // if not the last row\\n            fp << '\\\\n';          // start a new line\\n        }\\n    }\\n\\n    fp.close();\\n    return 0;\\n}\\n\\n/**\\n * Update weights of the SOM using Kohonen algorithm\\n *\\n * \\\\param[in] X data point - N features\\n * \\\\param[in,out] W weights matrix - PxQxN\\n * \\\\param[in,out] D temporary vector to store distances PxQ\\n * \\\\param[in] alpha learning rate \\\\f$0<\\\\alpha\\\\le1\\\\f$\\n * \\\\param[in] R neighborhood range\\n * \\\\returns minimum distance of sample and trained weights\\n */\\ndouble update_weights(const std::valarray<double> &X,\\n                      std::vector<std::vector<std::valarray<double>>> *W,\\n                      std::vector<std::valarray<double>> *D, double alpha,\\n                      int R) {\\n    int x = 0, y = 0;\\n    int num_out_x = static_cast<int>(W->size());       // output nodes - in X\\n    int num_out_y = static_cast<int>(W[0][0].size());  // output nodes - in Y\\n    // int num_features = static_cast<int>(W[0][0][0].size());  //  features =\\n    // in Z\\n    double d_min = 0.f;\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    // step 1: for each output point\\n    for (x = 0; x < num_out_x; x++) {\\n        for (y = 0; y < num_out_y; y++) {\\n            (*D)[x][y] = 0.f;\\n            // compute Euclidian distance of each output\\n            // point from the current sample\\n            auto d = ((*W)[x][y] - X);\\n            (*D)[x][y] = (d * d).sum();\\n            (*D)[x][y] = std::sqrt((*D)[x][y]);\\n        }\\n    }\\n\\n    // step 2:  get closest node i.e., node with snallest Euclidian distance\\n    // to the current pattern\\n    int d_min_x = 0, d_min_y = 0;\\n    get_min_2d(*D, &d_min, &d_min_x, &d_min_y);\\n\\n    // step 3a: get the neighborhood range\\n    int from_x = std::max(0, d_min_x - R);\\n    int to_x = std::min(num_out_x, d_min_x + R + 1);\\n    int from_y = std::max(0, d_min_y - R);\\n    int to_y = std::min(num_out_y, d_min_y + R + 1);\\n\\n    // step 3b: update the weights of nodes in the\\n    // neighborhood\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (x = from_x; x < to_x; x++) {\\n        for (y = from_y; y < to_y; y++) {\\n            /* you can enable the following normalization if needed.\\n   personally, I found it detrimental to convergence */\\n            // const double s2pi = sqrt(2.f * M_PI);\\n            // double normalize = 1.f / (alpha * s2pi);\\n\\n            /* apply scaling inversely proportional to distance from the\\n               current node */\\n            double d2 =\\n                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);\\n            double scale_factor = std::exp(-d2 / (2.f * alpha * alpha));\\n\\n            (*W)[x][y] += (X - (*W)[x][y]) * alpha * scale_factor;\\n        }\\n    }\\n    return d_min;\\n}\\n\\n/**\\n * Apply incremental algorithm with updating neighborhood and learning\\n * rates on all samples in the given datset.\\n *\\n * \\\\param[in] X data set\\n * \\\\param[in,out] W weights matrix\\n * \\\\param[in] alpha_min terminal value of alpha\\n */\\nvoid kohonen_som(const std::vector<std::valarray<double>> &X,\\n                 std::vector<std::vector<std::valarray<double>>> *W,\\n                 double alpha_min) {\\n    size_t num_samples = X.size();  // number of rows\\n    // size_t num_features = X[0].size();  // number of columns\\n    size_t num_out = W->size();  // output matrix size\\n    size_t R = num_out >> 2, iter = 0;\\n    double alpha = 1.f;\\n\\n    std::vector<std::valarray<double>> D(num_out);\\n    for (int i = 0; i < num_out; i++) D[i] = std::valarray<double>(num_out);\\n\\n    double dmin = 1.f;        // average minimum distance of all samples\\n    double past_dmin = 1.f;   // average minimum distance of all samples\\n    double dmin_ratio = 1.f;  // change per step\\n\\n    // Loop alpha from 1 to slpha_min\\n    for (; alpha > 0 && dmin_ratio > 1e-5; alpha -= 1e-4, iter++) {\\n        // Loop for each sample pattern in the data set\\n        for (int sample = 0; sample < num_samples; sample++) {\\n            // update weights for the current input pattern sample\\n            dmin += update_weights(X[sample], W, &D, alpha, R);\\n        }\\n\\n        // every 100th iteration, reduce the neighborhood range\\n        if (iter % 300 == 0 && R > 1) {\\n            R--;\\n        }\\n\\n        dmin /= num_samples;\\n\\n        // termination condition variable -> % change in minimum distance\\n        dmin_ratio = (past_dmin - dmin) / past_dmin;\\n        if (dmin_ratio < 0) {\\n            dmin_ratio = 1.f;\\n        }\\n        past_dmin = dmin;\\n\\n        std::cout << \\\"iter: \\\" << iter << \\\"\\\\t alpha: \\\" << alpha << \\\"\\\\t R: \\\" << R\\n                  << \\\"\\\\t d_min: \\\" << dmin_ratio << \\\"\\\\r\\\";\\n    }\\n\\n    std::cout << \\\"\\\\n\\\";\\n}\\n\\n}  // namespace machine_learning\\n\\nusing machine_learning::kohonen_som;\\nusing machine_learning::save_u_matrix;\\n\\n/** @} */\\n\\n/** Creates a random set of points distributed in four clusters in\\n * 3D space with centroids at the points\\n * * \\\\f$(0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(0,5,-0.5, -0.5)\\\\f$\\n * * \\\\f$(-0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(-0,5,-0.5, -0.5)\\\\f$\\n *\\n * \\\\param[out] data matrix to store data in\\n */\\nvoid test_2d_classes(std::vector<std::valarray<double>> *data) {\\n    const int N = data->size();\\n    const double R = 0.3;  // radius of cluster\\n    int i = 0;\\n    const int num_classes = 4;\\n    std::array<std::array<double, 2>, num_classes> centres = {\\n        // centres of each class cluster\\n        std::array<double, 2>({.5, .5}),   // centre of class 1\\n        std::array<double, 2>({.5, -.5}),  // centre of class 2\\n        std::array<double, 2>({-.5, .5}),  // centre of class 3\\n        std::array<double, 2>({-.5, -.5})  // centre of class 4\\n    };\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++) {\\n        // select a random class for the point\\n        int cls = std::rand() % num_classes;\\n\\n        // create random coordinates (x,y,z) around the centre of the class\\n        data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);\\n        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);\\n\\n        /* The follosing can also be used\\n        for (int j = 0; j < 2; j++)\\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\\n        */\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed in four clusters in\\n * circumference of a circle and trains an SOM that finds that circular pattern.\\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\\n * files are created to validate the execution:\\n * * `test1.csv`: random test samples points with a circular pattern\\n * * `w11.csv`: initial random map\\n * * `w12.csv`: trained SOM map\\n */\\nvoid test1() {\\n    int j = 0, N = 300;\\n    int features = 2;\\n    int num_out = 30;\\n    std::vector<std::valarray<double>> X(N);\\n    std::vector<std::vector<std::valarray<double>>> W(num_out);\\n    for (int i = 0; i < std::max(num_out, N); i++) {\\n        // loop till max(N, num_out)\\n        if (i < N) {  // only add new arrays if i < N\\n            X[i] = std::valarray<double>(features);\\n        }\\n        if (i < num_out) {  // only add new arrays if i < num_out\\n            W[i] = std::vector<std::valarray<double>>(num_out);\\n            for (int k = 0; k < num_out; k++) {\\n                W[i][k] = std::valarray<double>(features);\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n                for (j = 0; j < features; j++) {\\n                    // preallocate with random initial weights\\n                    W[i][k][j] = _random(-10, 10);\\n                }\\n            }\\n        }\\n    }\\n\\n    test_2d_classes(&X);  // create test data around circumference of a circle\\n    save_2d_data(\\\"test1.csv\\\", X);  // save test data points\\n    save_u_matrix(\\\"w11.csv\\\", W);   // save initial random weights\\n    kohonen_som(X, &W, 1e-4);      // train the SOM\\n    save_u_matrix(\\\"w12.csv\\\", W);   // save the resultant weights\\n}\\n\\n/** Creates a random set of points distributed in four clusters in\\n * 3D space with centroids at the points\\n * * \\\\f$(0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(0,5,-0.5, -0.5)\\\\f$\\n * * \\\\f$(-0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(-0,5,-0.5, -0.5)\\\\f$\\n *\\n * \\\\param[out] data matrix to store data in\\n */\\nvoid test_3d_classes1(std::vector<std::valarray<double>> *data) {\\n    const size_t N = data->size();\\n    const double R = 0.3;  // radius of cluster\\n    int i = 0;\\n    const int num_classes = 4;\\n    const std::array<std::array<double, 3>, num_classes> centres = {\\n        // centres of each class cluster\\n        std::array<double, 3>({.5, .5, .5}),    // centre of class 1\\n        std::array<double, 3>({.5, -.5, -.5}),  // centre of class 2\\n        std::array<double, 3>({-.5, .5, .5}),   // centre of class 3\\n        std::array<double, 3>({-.5, -.5 - .5})  // centre of class 4\\n    };\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++) {\\n        // select a random class for the point\\n        int cls = std::rand() % num_classes;\\n\\n        // create random coordinates (x,y,z) around the centre of the class\\n        data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);\\n        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);\\n        data[0][i][2] = _random(centres[cls][2] - R, centres[cls][2] + R);\\n\\n        /* The follosing can also be used\\n        for (int j = 0; j < 3; j++)\\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\\n        */\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed in 4 clusters in\\n * 3D space and trains an SOM that finds the topological pattern. The following\\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\\n * to validate the execution:\\n * * `test2.csv`: random test samples points with a lamniscate pattern\\n * * `w21.csv`: initial random map\\n * * `w22.csv`: trained SOM map\\n */\\nvoid test2() {\\n    int j = 0, N = 300;\\n    int features = 3;\\n    int num_out = 30;\\n    std::vector<std::valarray<double>> X(N);\\n    std::vector<std::vector<std::valarray<double>>> W(num_out);\\n    for (int i = 0; i < std::max(num_out, N); i++) {\\n        // loop till max(N, num_out)\\n        if (i < N) {  // only add new arrays if i < N\\n            X[i] = std::valarray<double>(features);\\n        }\\n        if (i < num_out) {  // only add new arrays if i < num_out\\n            W[i] = std::vector<std::valarray<double>>(num_out);\\n            for (int k = 0; k < num_out; k++) {\\n                W[i][k] = std::valarray<double>(features);\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n                for (j = 0; j < features; j++) {\\n                    // preallocate with random initial weights\\n                    W[i][k][j] = _random(-10, 10);\\n                }\\n            }\\n        }\\n    }\\n\\n    test_3d_classes1(&X);  // create test data around circumference of a circle\\n    save_2d_data(\\\"test2.csv\\\", X);  // save test data points\\n    save_u_matrix(\\\"w21.csv\\\", W);   // save initial random weights\\n    kohonen_som(X, &W, 1e-4);      // train the SOM\\n    save_u_matrix(\\\"w22.csv\\\", W);   // save the resultant weights\\n}\\n\\n/** Creates a random set of points distributed in four clusters in\\n * 3D space with centroids at the points\\n * * \\\\f$(0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(0,5,-0.5, -0.5)\\\\f$\\n * * \\\\f$(-0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(-0,5,-0.5, -0.5)\\\\f$\\n *\\n * \\\\param[out] data matrix to store data in\\n */\\nvoid test_3d_classes2(std::vector<std::valarray<double>> *data) {\\n    const size_t N = data->size();\\n    const double R = 0.2;  // radius of cluster\\n    int i = 0;\\n    const int num_classes = 8;\\n    const std::array<std::array<double, 3>, num_classes> centres = {\\n        // centres of each class cluster\\n        std::array<double, 3>({.5, .5, .5}),    // centre of class 1\\n        std::array<double, 3>({.5, .5, -.5}),   // centre of class 2\\n        std::array<double, 3>({.5, -.5, .5}),   // centre of class 3\\n        std::array<double, 3>({.5, -.5, -.5}),  // centre of class 4\\n        std::array<double, 3>({-.5, .5, .5}),   // centre of class 5\\n        std::array<double, 3>({-.5, .5, -.5}),  // centre of class 6\\n        std::array<double, 3>({-.5, -.5, .5}),  // centre of class 7\\n        std::array<double, 3>({-.5, -.5, -.5})  // centre of class 8\\n    };\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++) {\\n        // select a random class for the point\\n        int cls = std::rand() % num_classes;\\n\\n        // create random coordinates (x,y,z) around the centre of the class\\n        data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);\\n        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);\\n        data[0][i][2] = _random(centres[cls][2] - R, centres[cls][2] + R);\\n\\n        /* The follosing can also be used\\n        for (int j = 0; j < 3; j++)\\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\\n        */\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed in eight clusters in\\n * 3D space and trains an SOM that finds the topological pattern. The following\\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\\n * to validate the execution:\\n * * `test3.csv`: random test samples points with a circular pattern\\n * * `w31.csv`: initial random map\\n * * `w32.csv`: trained SOM map\\n */\\nvoid test3() {\\n    int j = 0, N = 500;\\n    int features = 3;\\n    int num_out = 30;\\n    std::vector<std::valarray<double>> X(N);\\n    std::vector<std::vector<std::valarray<double>>> W(num_out);\\n    for (int i = 0; i < std::max(num_out, N); i++) {\\n        // loop till max(N, num_out)\\n        if (i < N) {  // only add new arrays if i < N\\n            X[i] = std::valarray<double>(features);\\n        }\\n        if (i < num_out) {  // only add new arrays if i < num_out\\n            W[i] = std::vector<std::valarray<double>>(num_out);\\n            for (int k = 0; k < num_out; k++) {\\n                W[i][k] = std::valarray<double>(features);\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n                for (j = 0; j < features; j++) {\\n                    // preallocate with random initial weights\\n                    W[i][k][j] = _random(-10, 10);\\n                }\\n            }\\n        }\\n    }\\n\\n    test_3d_classes2(&X);  // create test data around circumference of a circle\\n    save_2d_data(\\\"test3.csv\\\", X);  // save test data points\\n    save_u_matrix(\\\"w31.csv\\\", W);   // save initial random weights\\n    kohonen_som(X, &W, 1e-4);      // train the SOM\\n    save_u_matrix(\\\"w32.csv\\\", W);   // save the resultant weights\\n}\\n\\n/**\\n * Convert clock cycle difference to time in seconds\\n *\\n * \\\\param[in] start_t start clock\\n * \\\\param[in] end_t end clock\\n * \\\\returns time difference in seconds\\n */\\ndouble get_clock_diff(clock_t start_t, clock_t end_t) {\\n    return static_cast<double>(end_t - start_t) / CLOCKS_PER_SEC;\\n}\\n\\n/** Main function */\\nint main(int argc, char **argv) {\\n#ifdef _OPENMP\\n    std::cout << \\\"Using OpenMP based parallelization\\\\n\\\";\\n#else\\n    std::cout << \\\"NOT using OpenMP based parallelization\\\\n\\\";\\n#endif\\n\\n    std::srand(std::time(nullptr));\\n\\n    std::clock_t start_clk = std::clock();\\n    test1();\\n    auto end_clk = std::clock();\\n    std::cout << \\\"Test 1 completed in \\\" << get_clock_diff(start_clk, end_clk)\\n              << \\\" sec\\\\n\\\";\\n\\n    start_clk = std::clock();\\n    test2();\\n    end_clk = std::clock();\\n    std::cout << \\\"Test 2 completed in \\\" << get_clock_diff(start_clk, end_clk)\\n              << \\\" sec\\\\n\\\";\\n\\n    start_clk = std::clock();\\n    test3();\\n    end_clk = std::clock();\\n    std::cout << \\\"Test 3 completed in \\\" << get_clock_diff(start_clk, end_clk)\\n              << \\\" sec\\\\n\\\";\\n\\n    std::cout\\n        << \\\"(Note: Calculated times include: creating test sets, training \\\"\\n           \\\"model and writing files to disk.)\\\\n\\\\n\\\";\\n    return 0;\\n}\\n\"",
    "kohonen som trace": "\"/**\\n * \\\\addtogroup machine_learning Machine Learning Algorithms\\n * @{\\n * \\\\file\\n * \\\\brief [Kohonen self organizing\\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (data tracing)\\n *\\n * This example implements a powerful self organizing map algorithm.\\n * The algorithm creates a connected network of weights that closely\\n * follows the given data points. This this creates a chain of nodes that\\n * resembles the given input shape.\\n *\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n *\\n * \\\\note This C++ version of the program is considerable slower than its [C\\n * counterpart](https://github.com/kvedala/C/blob/master/machine_learning/kohonen_som_trace.c)\\n * \\\\note The compiled code is much slower when compiled with MS Visual C++ 2019\\n * than with GCC on windows\\n * \\\\see kohonen_som_topology.cpp\\n */\\n#define _USE_MATH_DEFINES  // required for MS Visual C++\\n#include <algorithm>\\n#include <array>\\n#include <cmath>\\n#include <cstdlib>\\n#include <ctime>\\n#include <fstream>\\n#include <iostream>\\n#include <valarray>\\n#include <vector>\\n#ifdef _OPENMP  // check if OpenMP based parallellization is available\\n#include <omp.h>\\n#endif\\n\\n/**\\n * Helper function to generate a random number in a given interval.\\n * \\\\n Steps:\\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\\n * 3. scale and offset the random number to given range of \\\\f$[a,b]\\\\f$\\n *\\n * \\\\param[in] a lower limit\\n * \\\\param[in] b upper limit\\n * \\\\returns random number in the range \\\\f$[a,b]\\\\f$\\n */\\ndouble _random(double a, double b) {\\n    return ((b - a) * (std::rand() % 100) / 100.f) + a;\\n}\\n\\n/**\\n * Save a given n-dimensional data martix to file.\\n *\\n * \\\\param[in] fname filename to save in (gets overwriten without confirmation)\\n * \\\\param[in] X matrix to save\\n * \\\\returns 0 if all ok\\n * \\\\returns -1 if file creation failed\\n */\\nint save_nd_data(const char *fname,\\n                 const std::vector<std::valarray<double>> &X) {\\n    size_t num_points = X.size();       // number of rows\\n    size_t num_features = X[0].size();  // number of columns\\n\\n    std::ofstream fp;\\n    fp.open(fname);\\n    if (!fp.is_open()) {\\n        // error with opening file to write\\n        std::cerr << \\\"Error opening file \\\" << fname << \\\"\\\\n\\\";\\n        return -1;\\n    }\\n\\n    // for each point in the array\\n    for (int i = 0; i < num_points; i++) {\\n        // for each feature in the array\\n        for (int j = 0; j < num_features; j++) {\\n            fp << X[i][j];               // print the feature value\\n            if (j < num_features - 1) {  // if not the last feature\\n                fp << \\\",\\\";               // suffix comma\\n            }\\n        }\\n        if (i < num_points - 1) {  // if not the last row\\n            fp << \\\"\\\\n\\\";            // start a new line\\n        }\\n    }\\n\\n    fp.close();\\n    return 0;\\n}\\n\\n/** \\\\namespace machine_learning\\n * \\\\brief Machine learning algorithms\\n */\\nnamespace machine_learning {\\n\\n/**\\n * Update weights of the SOM using Kohonen algorithm\\n *\\n * \\\\param[in] X data point\\n * \\\\param[in,out] W weights matrix\\n * \\\\param[in,out] D temporary vector to store distances\\n * \\\\param[in] alpha learning rate \\\\f$0<\\\\alpha\\\\le1\\\\f$\\n * \\\\param[in] R neighborhood range\\n */\\nvoid update_weights(const std::valarray<double> &x,\\n                    std::vector<std::valarray<double>> *W,\\n                    std::valarray<double> *D, double alpha, int R) {\\n    int j = 0, k = 0;\\n    int num_out = W->size();  // number of SOM output nodes\\n    // int num_features = x.size();  // number of data features\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    // step 1: for each output point\\n    for (j = 0; j < num_out; j++) {\\n        // compute Euclidian distance of each output\\n        // point from the current sample\\n        (*D)[j] = (((*W)[j] - x) * ((*W)[j] - x)).sum();\\n    }\\n\\n    // step 2:  get closest node i.e., node with snallest Euclidian distance to\\n    // the current pattern\\n    auto result = std::min_element(std::begin(*D), std::end(*D));\\n    // double d_min = *result;\\n    int d_min_idx = std::distance(std::begin(*D), result);\\n\\n    // step 3a: get the neighborhood range\\n    int from_node = std::max(0, d_min_idx - R);\\n    int to_node = std::min(num_out, d_min_idx + R + 1);\\n\\n    // step 3b: update the weights of nodes in the\\n    // neighborhood\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (j = from_node; j < to_node; j++) {\\n        // update weights of nodes in the neighborhood\\n        (*W)[j] += alpha * (x - (*W)[j]);\\n    }\\n}\\n\\n/**\\n * Apply incremental algorithm with updating neighborhood and learning rates\\n * on all samples in the given datset.\\n *\\n * \\\\param[in] X data set\\n * \\\\param[in,out] W weights matrix\\n * \\\\param[in] alpha_min terminal value of alpha\\n */\\nvoid kohonen_som_tracer(const std::vector<std::valarray<double>> &X,\\n                        std::vector<std::valarray<double>> *W,\\n                        double alpha_min) {\\n    int num_samples = X.size();  // number of rows\\n    // int num_features = X[0].size();  // number of columns\\n    int num_out = W->size();  // number of rows\\n    int R = num_out >> 2, iter = 0;\\n    double alpha = 1.f;\\n\\n    std::valarray<double> D(num_out);\\n\\n    // Loop alpha from 1 to slpha_min\\n    do {\\n        // Loop for each sample pattern in the data set\\n        for (int sample = 0; sample < num_samples; sample++) {\\n            // update weights for the current input pattern sample\\n            update_weights(X[sample], W, &D, alpha, R);\\n        }\\n\\n        // every 10th iteration, reduce the neighborhood range\\n        if (iter % 10 == 0 && R > 1) {\\n            R--;\\n        }\\n\\n        alpha -= 0.01;\\n        iter++;\\n    } while (alpha > alpha_min);\\n}\\n\\n}  // namespace machine_learning\\n\\n/** @} */\\n\\nusing machine_learning::kohonen_som_tracer;\\n\\n/** Creates a random set of points distributed *near* the circumference\\n * of a circle and trains an SOM that finds that circular pattern. The\\n * generating function is\\n * \\\\f{eqnarray*}{\\n * r &\\\\in& [1-\\\\delta r, 1+\\\\delta r)\\\\\\\\\\n * \\\\theta &\\\\in& [0, 2\\\\pi)\\\\\\\\\\n * x &=& r\\\\cos\\\\theta\\\\\\\\\\n * y &=& r\\\\sin\\\\theta\\n * \\\\f}\\n *\\n * \\\\param[out] data matrix to store data in\\n */\\nvoid test_circle(std::vector<std::valarray<double>> *data) {\\n    const int N = data->size();\\n    const double R = 0.75, dr = 0.3;\\n    double a_t = 0., b_t = 2.f * M_PI;  // theta random between 0 and 2*pi\\n    double a_r = R - dr, b_r = R + dr;  // radius random between R-dr and R+dr\\n    int i = 0;\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++) {\\n        double r = _random(a_r, b_r);      // random radius\\n        double theta = _random(a_t, b_t);  // random theta\\n        data[0][i][0] = r * cos(theta);    // convert from polar to cartesian\\n        data[0][i][1] = r * sin(theta);\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed *near* the\\n * circumference of a circle and trains an SOM that finds that circular pattern.\\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\\n * files are created to validate the execution:\\n * * `test1.csv`: random test samples points with a circular pattern\\n * * `w11.csv`: initial random map\\n * * `w12.csv`: trained SOM map\\n *\\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\\n * the following snippet\\n * ```gnuplot\\n * set datafile separator ','\\n * plot \\\"test1.csv\\\" title \\\"original\\\", \\\\\\n *      \\\"w11.csv\\\" title \\\"w1\\\", \\\\\\n *      \\\"w12.csv\\\" title \\\"w2\\\"\\n * ```\\n * ![Sample execution\\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test1.svg)\\n */\\nvoid test1() {\\n    int j = 0, N = 500;\\n    int features = 2;\\n    int num_out = 50;\\n    std::vector<std::valarray<double>> X(N);\\n    std::vector<std::valarray<double>> W(num_out);\\n    for (int i = 0; i < std::max(num_out, N); i++) {\\n        // loop till max(N, num_out)\\n        if (i < N) {  // only add new arrays if i < N\\n            X[i] = std::valarray<double>(features);\\n        }\\n        if (i < num_out) {  // only add new arrays if i < num_out\\n            W[i] = std::valarray<double>(features);\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n            for (j = 0; j < features; j++) {\\n                // preallocate with random initial weights\\n                W[i][j] = _random(-1, 1);\\n            }\\n        }\\n    }\\n\\n    test_circle(&X);  // create test data around circumference of a circle\\n    save_nd_data(\\\"test1.csv\\\", X);    // save test data points\\n    save_nd_data(\\\"w11.csv\\\", W);      // save initial random weights\\n    kohonen_som_tracer(X, &W, 0.1);  // train the SOM\\n    save_nd_data(\\\"w12.csv\\\", W);      // save the resultant weights\\n}\\n\\n/** Creates a random set of points distributed *near* the locus\\n * of the [Lamniscate of\\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono).\\n * \\\\f{eqnarray*}{\\n * \\\\delta r &=& 0.2\\\\\\\\\\n * \\\\delta x &\\\\in& [-\\\\delta r, \\\\delta r)\\\\\\\\\\n * \\\\delta y &\\\\in& [-\\\\delta r, \\\\delta r)\\\\\\\\\\n * \\\\theta &\\\\in& [0, \\\\pi)\\\\\\\\\\n * x &=& \\\\delta x + \\\\cos\\\\theta\\\\\\\\\\n * y &=& \\\\delta y + \\\\frac{\\\\sin(2\\\\theta)}{2}\\n * \\\\f}\\n * \\\\param[out] data matrix to store data in\\n */\\nvoid test_lamniscate(std::vector<std::valarray<double>> *data) {\\n    const int N = data->size();\\n    const double dr = 0.2;\\n    int i = 0;\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++) {\\n        double dx = _random(-dr, dr);     // random change in x\\n        double dy = _random(-dr, dr);     // random change in y\\n        double theta = _random(0, M_PI);  // random theta\\n        data[0][i][0] = dx + cos(theta);  // convert from polar to cartesian\\n        data[0][i][1] = dy + sin(2. * theta) / 2.f;\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed *near* the locus\\n * of the [Lamniscate of\\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono) and trains an SOM\\n * that finds that circular pattern. The following\\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\\n * to validate the execution:\\n * * `test2.csv`: random test samples points with a lamniscate pattern\\n * * `w21.csv`: initial random map\\n * * `w22.csv`: trained SOM map\\n *\\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\\n * the following snippet\\n * ```gnuplot\\n * set datafile separator ','\\n * plot \\\"test2.csv\\\" title \\\"original\\\", \\\\\\n *      \\\"w21.csv\\\" title \\\"w1\\\", \\\\\\n *      \\\"w22.csv\\\" title \\\"w2\\\"\\n * ```\\n * ![Sample execution\\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test2.svg)\\n */\\nvoid test2() {\\n    int j = 0, N = 500;\\n    int features = 2;\\n    int num_out = 20;\\n    std::vector<std::valarray<double>> X(N);\\n    std::vector<std::valarray<double>> W(num_out);\\n    for (int i = 0; i < std::max(num_out, N); i++) {\\n        // loop till max(N, num_out)\\n        if (i < N) {  // only add new arrays if i < N\\n            X[i] = std::valarray<double>(features);\\n        }\\n        if (i < num_out) {  // only add new arrays if i < num_out\\n            W[i] = std::valarray<double>(features);\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n            for (j = 0; j < features; j++) {\\n                // preallocate with random initial weights\\n                W[i][j] = _random(-1, 1);\\n            }\\n        }\\n    }\\n\\n    test_lamniscate(&X);              // create test data around the lamniscate\\n    save_nd_data(\\\"test2.csv\\\", X);     // save test data points\\n    save_nd_data(\\\"w21.csv\\\", W);       // save initial random weights\\n    kohonen_som_tracer(X, &W, 0.01);  // train the SOM\\n    save_nd_data(\\\"w22.csv\\\", W);       // save the resultant weights\\n}\\n\\n/** Creates a random set of points distributed in six clusters in\\n * 3D space with centroids at the points\\n * * \\\\f${0.5, 0.5, 0.5}\\\\f$\\n * * \\\\f${0.5, 0.5, -0.5}\\\\f$\\n * * \\\\f${0.5, -0.5, 0.5}\\\\f$\\n * * \\\\f${0.5, -0.5, -0.5}\\\\f$\\n * * \\\\f${-0.5, 0.5, 0.5}\\\\f$\\n * * \\\\f${-0.5, 0.5, -0.5}\\\\f$\\n * * \\\\f${-0.5, -0.5, 0.5}\\\\f$\\n * * \\\\f${-0.5, -0.5, -0.5}\\\\f$\\n *\\n * \\\\param[out] data matrix to store data in\\n */\\nvoid test_3d_classes(std::vector<std::valarray<double>> *data) {\\n    const int N = data->size();\\n    const double R = 0.1;  // radius of cluster\\n    int i = 0;\\n    const int num_classes = 8;\\n    const std::array<const std::array<double, 3>, num_classes> centres = {\\n        // centres of each class cluster\\n        std::array<double, 3>({.5, .5, .5}),    // centre of class 0\\n        std::array<double, 3>({.5, .5, -.5}),   // centre of class 1\\n        std::array<double, 3>({.5, -.5, .5}),   // centre of class 2\\n        std::array<double, 3>({.5, -.5, -.5}),  // centre of class 3\\n        std::array<double, 3>({-.5, .5, .5}),   // centre of class 4\\n        std::array<double, 3>({-.5, .5, -.5}),  // centre of class 5\\n        std::array<double, 3>({-.5, -.5, .5}),  // centre of class 6\\n        std::array<double, 3>({-.5, -.5, -.5})  // centre of class 7\\n    };\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++) {\\n        int cls =\\n            std::rand() % num_classes;  // select a random class for the point\\n\\n        // create random coordinates (x,y,z) around the centre of the class\\n        data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);\\n        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);\\n        data[0][i][2] = _random(centres[cls][2] - R, centres[cls][2] + R);\\n\\n        /* The follosing can also be used\\n        for (int j = 0; j < 3; j++)\\n            data[0][i][j] = _random(centres[cls][j] - R, centres[cls][j] + R);\\n        */\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed in six clusters in\\n * 3D space. The following\\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\\n * to validate the execution:\\n * * `test3.csv`: random test samples points with a circular pattern\\n * * `w31.csv`: initial random map\\n * * `w32.csv`: trained SOM map\\n *\\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\\n * the following snippet\\n * ```gnuplot\\n * set datafile separator ','\\n * plot \\\"test3.csv\\\" title \\\"original\\\", \\\\\\n *      \\\"w31.csv\\\" title \\\"w1\\\", \\\\\\n *      \\\"w32.csv\\\" title \\\"w2\\\"\\n * ```\\n * ![Sample execution\\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test3.svg)\\n */\\nvoid test3() {\\n    int j = 0, N = 200;\\n    int features = 3;\\n    int num_out = 20;\\n    std::vector<std::valarray<double>> X(N);\\n    std::vector<std::valarray<double>> W(num_out);\\n    for (int i = 0; i < std::max(num_out, N); i++) {\\n        // loop till max(N, num_out)\\n        if (i < N) {  // only add new arrays if i < N\\n            X[i] = std::valarray<double>(features);\\n        }\\n        if (i < num_out) {  // only add new arrays if i < num_out\\n            W[i] = std::valarray<double>(features);\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n            for (j = 0; j < features; j++) {\\n                // preallocate with random initial weights\\n                W[i][j] = _random(-1, 1);\\n            }\\n        }\\n    }\\n\\n    test_3d_classes(&X);              // create test data around the lamniscate\\n    save_nd_data(\\\"test3.csv\\\", X);     // save test data points\\n    save_nd_data(\\\"w31.csv\\\", W);       // save initial random weights\\n    kohonen_som_tracer(X, &W, 0.01);  // train the SOM\\n    save_nd_data(\\\"w32.csv\\\", W);       // save the resultant weights\\n}\\n\\n/**\\n * Convert clock cycle difference to time in seconds\\n *\\n * \\\\param[in] start_t start clock\\n * \\\\param[in] end_t end clock\\n * \\\\returns time difference in seconds\\n */\\ndouble get_clock_diff(clock_t start_t, clock_t end_t) {\\n    return static_cast<double>(end_t - start_t) / CLOCKS_PER_SEC;\\n}\\n\\n/** Main function */\\nint main(int argc, char **argv) {\\n#ifdef _OPENMP\\n    std::cout << \\\"Using OpenMP based parallelization\\\\n\\\";\\n#else\\n    std::cout << \\\"NOT using OpenMP based parallelization\\\\n\\\";\\n#endif\\n\\n    std::srand(std::time(nullptr));\\n\\n    std::clock_t start_clk = std::clock();\\n    test1();\\n    auto end_clk = std::clock();\\n    std::cout << \\\"Test 1 completed in \\\" << get_clock_diff(start_clk, end_clk)\\n              << \\\" sec\\\\n\\\";\\n\\n    start_clk = std::clock();\\n    test2();\\n    end_clk = std::clock();\\n    std::cout << \\\"Test 2 completed in \\\" << get_clock_diff(start_clk, end_clk)\\n              << \\\" sec\\\\n\\\";\\n\\n    start_clk = std::clock();\\n    test3();\\n    end_clk = std::clock();\\n    std::cout << \\\"Test 3 completed in \\\" << get_clock_diff(start_clk, end_clk)\\n              << \\\" sec\\\\n\\\";\\n\\n    std::cout\\n        << \\\"(Note: Calculated times include: creating test sets, training \\\"\\n           \\\"model and writing files to disk.)\\\\n\\\\n\\\";\\n    return 0;\\n}\\n\"",
    "neural network": "\"/**\\n * @file\\n * @author [Deep Raval](https://github.com/imdeep2905)\\n *\\n * @brief Implementation of [Multilayer Perceptron]\\n * (https://en.wikipedia.org/wiki/Multilayer_perceptron).\\n *\\n * @details\\n * A multilayer perceptron (MLP) is a class of feedforward artificial neural\\n * network (ANN). The term MLP is used ambiguously, sometimes loosely to any\\n * feedforward ANN, sometimes strictly to refer to networks composed of multiple\\n * layers of perceptrons (with threshold activation). Multilayer perceptrons are\\n * sometimes colloquially referred to as \\\"vanilla\\\" neural networks, especially\\n * when they have a single hidden layer.\\n *\\n * An MLP consists of at least three layers of nodes: an input layer, a hidden\\n * layer and an output layer. Except for the input nodes, each node is a neuron\\n * that uses a nonlinear activation function. MLP utilizes a supervised learning\\n * technique called backpropagation for training. Its multiple layers and\\n * non-linear activation distinguish MLP from a linear perceptron. It can\\n * distinguish data that is not linearly separable.\\n *\\n * See [Backpropagation](https://en.wikipedia.org/wiki/Backpropagation) for\\n * training algorithm.\\n *\\n * \\\\note This implementation uses mini-batch gradient descent as optimizer and\\n * MSE as loss function. Bias is also not included.\\n */\\n\\n#include <algorithm>\\n#include <cassert>\\n#include <chrono>\\n#include <cmath>\\n#include <fstream>\\n#include <iostream>\\n#include <sstream>\\n#include <string>\\n#include <valarray>\\n#include <vector>\\n\\n#include \\\"vector_ops.hpp\\\"  // Custom header file for vector operations\\n\\n/** \\\\namespace machine_learning\\n * \\\\brief Machine learning algorithms\\n */\\nnamespace machine_learning {\\n/** \\\\namespace neural_network\\n * \\\\brief Neural Network or Multilayer Perceptron\\n */\\nnamespace neural_network {\\n/** \\\\namespace activations\\n * \\\\brief Various activation functions used in Neural network\\n */\\nnamespace activations {\\n/**\\n * Sigmoid function\\n * @param X Value\\n * @return Returns sigmoid(x)\\n */\\ndouble sigmoid(const double &x) { return 1.0 / (1.0 + std::exp(-x)); }\\n\\n/**\\n * Derivative of sigmoid function\\n * @param X Value\\n * @return Returns derivative of sigmoid(x)\\n */\\ndouble dsigmoid(const double &x) { return x * (1 - x); }\\n\\n/**\\n * Relu function\\n * @param X Value\\n * @returns relu(x)\\n */\\ndouble relu(const double &x) { return std::max(0.0, x); }\\n\\n/**\\n * Derivative of relu function\\n * @param X Value\\n * @returns derivative of relu(x)\\n */\\ndouble drelu(const double &x) { return x >= 0.0 ? 1.0 : 0.0; }\\n\\n/**\\n * Tanh function\\n * @param X Value\\n * @return Returns tanh(x)\\n */\\ndouble tanh(const double &x) { return 2 / (1 + std::exp(-2 * x)) - 1; }\\n\\n/**\\n * Derivative of Sigmoid function\\n * @param X Value\\n * @return Returns derivative of tanh(x)\\n */\\ndouble dtanh(const double &x) { return 1 - x * x; }\\n}  // namespace activations\\n/** \\\\namespace util_functions\\n * \\\\brief Various utility functions used in Neural network\\n */\\nnamespace util_functions {\\n/**\\n * Square function\\n * @param X Value\\n * @return Returns x * x\\n */\\ndouble square(const double &x) { return x * x; }\\n/**\\n * Identity function\\n * @param X Value\\n * @return Returns x\\n */\\ndouble identity_function(const double &x) { return x; }\\n}  // namespace util_functions\\n/** \\\\namespace layers\\n * \\\\brief This namespace contains layers used\\n * in MLP.\\n */\\nnamespace layers {\\n/**\\n * neural_network::layers::DenseLayer class is used to store all necessary\\n * information about the layers (i.e. neurons, activation and kernel). This\\n * class is used by NeuralNetwork class to store layers.\\n *\\n */\\nclass DenseLayer {\\n public:\\n    // To store activation function and it's derivative\\n    double (*activation_function)(const double &);\\n    double (*dactivation_function)(const double &);\\n    int neurons;             // To store number of neurons (used in summary)\\n    std::string activation;  // To store activation name (used in summary)\\n    std::vector<std::valarray<double>> kernel;  // To store kernel (aka weights)\\n\\n    /**\\n     * Constructor for neural_network::layers::DenseLayer class\\n     * @param neurons number of neurons\\n     * @param activation activation function for layer\\n     * @param kernel_shape shape of kernel\\n     * @param random_kernel flag for whether to intialize kernel randomly\\n     */\\n    DenseLayer(const int &neurons, const std::string &activation,\\n               const std::pair<size_t, size_t> &kernel_shape,\\n               const bool &random_kernel) {\\n        // Choosing activation (and it's derivative)\\n        if (activation == \\\"sigmoid\\\") {\\n            activation_function = neural_network::activations::sigmoid;\\n            dactivation_function = neural_network::activations::sigmoid;\\n        } else if (activation == \\\"relu\\\") {\\n            activation_function = neural_network::activations::relu;\\n            dactivation_function = neural_network::activations::drelu;\\n        } else if (activation == \\\"tanh\\\") {\\n            activation_function = neural_network::activations::tanh;\\n            dactivation_function = neural_network::activations::dtanh;\\n        } else if (activation == \\\"none\\\") {\\n            // Set identity function in casse of none is supplied\\n            activation_function =\\n                neural_network::util_functions::identity_function;\\n            dactivation_function =\\n                neural_network::util_functions::identity_function;\\n        } else {\\n            // If supplied activation is invalid\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr << \\\"Invalid argument. Expected {none, sigmoid, relu, \\\"\\n                         \\\"tanh} got \\\";\\n            std::cerr << activation << std::endl;\\n            std::exit(EXIT_FAILURE);\\n        }\\n        this->activation = activation;  // Setting activation name\\n        this->neurons = neurons;        // Setting number of neurons\\n        // Initialize kernel according to flag\\n        if (random_kernel) {\\n            uniform_random_initialization(kernel, kernel_shape, -1.0, 1.0);\\n        } else {\\n            unit_matrix_initialization(kernel, kernel_shape);\\n        }\\n    }\\n    /**\\n     * Constructor for neural_network::layers::DenseLayer class\\n     * @param neurons number of neurons\\n     * @param activation activation function for layer\\n     * @param kernel values of kernel (useful in loading model)\\n     */\\n    DenseLayer(const int &neurons, const std::string &activation,\\n               const std::vector<std::valarray<double>> &kernel) {\\n        // Choosing activation (and it's derivative)\\n        if (activation == \\\"sigmoid\\\") {\\n            activation_function = neural_network::activations::sigmoid;\\n            dactivation_function = neural_network::activations::sigmoid;\\n        } else if (activation == \\\"relu\\\") {\\n            activation_function = neural_network::activations::relu;\\n            dactivation_function = neural_network::activations::drelu;\\n        } else if (activation == \\\"tanh\\\") {\\n            activation_function = neural_network::activations::tanh;\\n            dactivation_function = neural_network::activations::dtanh;\\n        } else if (activation == \\\"none\\\") {\\n            // Set identity function in casse of none is supplied\\n            activation_function =\\n                neural_network::util_functions::identity_function;\\n            dactivation_function =\\n                neural_network::util_functions::identity_function;\\n        } else {\\n            // If supplied activation is invalid\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr << \\\"Invalid argument. Expected {none, sigmoid, relu, \\\"\\n                         \\\"tanh} got \\\";\\n            std::cerr << activation << std::endl;\\n            std::exit(EXIT_FAILURE);\\n        }\\n        this->activation = activation;  // Setting activation name\\n        this->neurons = neurons;        // Setting number of neurons\\n        this->kernel = kernel;          // Setting supplied kernel values\\n    }\\n\\n    /**\\n     * Copy Constructor for class DenseLayer.\\n     *\\n     * @param model instance of class to be copied.\\n     */\\n    DenseLayer(const DenseLayer &layer) = default;\\n\\n    /**\\n     * Destructor for class DenseLayer.\\n     */\\n    ~DenseLayer() = default;\\n\\n    /**\\n     * Copy assignment operator for class DenseLayer\\n     */\\n    DenseLayer &operator=(const DenseLayer &layer) = default;\\n\\n    /**\\n     * Move constructor for class DenseLayer\\n     */\\n    DenseLayer(DenseLayer &&) = default;\\n\\n    /**\\n     * Move assignment operator for class DenseLayer\\n     */\\n    DenseLayer &operator=(DenseLayer &&) = default;\\n};\\n}  // namespace layers\\n/**\\n * NeuralNetwork class is implements MLP. This class is\\n * used by actual user to create and train networks.\\n *\\n */\\nclass NeuralNetwork {\\n private:\\n    std::vector<neural_network::layers::DenseLayer> layers;  // To store layers\\n    /**\\n     * Private Constructor for class NeuralNetwork. This constructor\\n     * is used internally to load model.\\n     * @param config vector containing pair (neurons, activation)\\n     * @param kernels vector containing all pretrained kernels\\n     */\\n    NeuralNetwork(\\n        const std::vector<std::pair<int, std::string>> &config,\\n        const std::vector<std::vector<std::valarray<double>>> &kernels) {\\n        // First layer should not have activation\\n        if (config.begin()->second != \\\"none\\\") {\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr\\n                << \\\"First layer can't have activation other than none got \\\"\\n                << config.begin()->second;\\n            std::cerr << std::endl;\\n            std::exit(EXIT_FAILURE);\\n        }\\n        // Network should have atleast two layers\\n        if (config.size() <= 1) {\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr << \\\"Invalid size of network, \\\";\\n            std::cerr << \\\"Atleast two layers are required\\\";\\n            std::exit(EXIT_FAILURE);\\n        }\\n        // Reconstructing all pretrained layers\\n        for (size_t i = 0; i < config.size(); i++) {\\n            layers.emplace_back(neural_network::layers::DenseLayer(\\n                config[i].first, config[i].second, kernels[i]));\\n        }\\n        std::cout << \\\"INFO: Network constructed successfully\\\" << std::endl;\\n    }\\n    /**\\n     * Private function to get detailed predictions (i.e.\\n     * activated neuron values). This function is used in\\n     * backpropagation, single predict and batch predict.\\n     * @param X input vector\\n     */\\n    std::vector<std::vector<std::valarray<double>>>\\n    __detailed_single_prediction(const std::vector<std::valarray<double>> &X) {\\n        std::vector<std::vector<std::valarray<double>>> details;\\n        std::vector<std::valarray<double>> current_pass = X;\\n        details.emplace_back(X);\\n        for (const auto &l : layers) {\\n            current_pass = multiply(current_pass, l.kernel);\\n            current_pass = apply_function(current_pass, l.activation_function);\\n            details.emplace_back(current_pass);\\n        }\\n        return details;\\n    }\\n\\n public:\\n    /**\\n     * Default Constructor for class NeuralNetwork. This constructor\\n     * is used to create empty variable of type NeuralNetwork class.\\n     */\\n    NeuralNetwork() = default;\\n\\n    /**\\n     * Constructor for class NeuralNetwork. This constructor\\n     * is used by user.\\n     * @param config vector containing pair (neurons, activation)\\n     */\\n    explicit NeuralNetwork(\\n        const std::vector<std::pair<int, std::string>> &config) {\\n        // First layer should not have activation\\n        if (config.begin()->second != \\\"none\\\") {\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr\\n                << \\\"First layer can't have activation other than none got \\\"\\n                << config.begin()->second;\\n            std::cerr << std::endl;\\n            std::exit(EXIT_FAILURE);\\n        }\\n        // Network should have atleast two layers\\n        if (config.size() <= 1) {\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr << \\\"Invalid size of network, \\\";\\n            std::cerr << \\\"Atleast two layers are required\\\";\\n            std::exit(EXIT_FAILURE);\\n        }\\n        // Separately creating first layer so it can have unit matrix\\n        // as kernel.\\n        layers.push_back(neural_network::layers::DenseLayer(\\n            config[0].first, config[0].second,\\n            {config[0].first, config[0].first}, false));\\n        // Creating remaining layers\\n        for (size_t i = 1; i < config.size(); i++) {\\n            layers.push_back(neural_network::layers::DenseLayer(\\n                config[i].first, config[i].second,\\n                {config[i - 1].first, config[i].first}, true));\\n        }\\n        std::cout << \\\"INFO: Network constructed successfully\\\" << std::endl;\\n    }\\n\\n    /**\\n     * Copy Constructor for class NeuralNetwork.\\n     *\\n     * @param model instance of class to be copied.\\n     */\\n    NeuralNetwork(const NeuralNetwork &model) = default;\\n\\n    /**\\n     * Destructor for class NeuralNetwork.\\n     */\\n    ~NeuralNetwork() = default;\\n\\n    /**\\n     * Copy assignment operator for class NeuralNetwork\\n     */\\n    NeuralNetwork &operator=(const NeuralNetwork &model) = default;\\n\\n    /**\\n     * Move constructor for class NeuralNetwork\\n     */\\n    NeuralNetwork(NeuralNetwork &&) = default;\\n\\n    /**\\n     * Move assignment operator for class NeuralNetwork\\n     */\\n    NeuralNetwork &operator=(NeuralNetwork &&) = default;\\n\\n    /**\\n     * Function to get X and Y from csv file (where X = data, Y = label)\\n     * @param file_name csv file name\\n     * @param last_label flag for whether label is in first or last column\\n     * @param normalize flag for whether to normalize data\\n     * @param slip_lines number of lines to skip\\n     * @return returns pair of X and Y\\n     */\\n    std::pair<std::vector<std::vector<std::valarray<double>>>,\\n              std::vector<std::vector<std::valarray<double>>>>\\n    get_XY_from_csv(const std::string &file_name, const bool &last_label,\\n                    const bool &normalize, const int &slip_lines = 1) {\\n        std::ifstream in_file;                          // Ifstream to read file\\n        in_file.open(file_name.c_str(), std::ios::in);  // Open file\\n        // If there is any problem in opening file\\n        if (!in_file.is_open()) {\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr << \\\"Unable to open file: \\\" << file_name << std::endl;\\n            std::exit(EXIT_FAILURE);\\n        }\\n        std::vector<std::vector<std::valarray<double>>> X,\\n            Y;             // To store X and Y\\n        std::string line;  // To store each line\\n        // Skip lines\\n        for (int i = 0; i < slip_lines; i++) {\\n            std::getline(in_file, line, '\\\\n');  // Ignore line\\n        }\\n        // While file has information\\n        while (!in_file.eof() && std::getline(in_file, line, '\\\\n')) {\\n            std::valarray<double> x_data,\\n                y_data;                  // To store single sample and label\\n            std::stringstream ss(line);  // Constructing stringstream from line\\n            std::string token;  // To store each token in line (seprated by ',')\\n            while (std::getline(ss, token, ',')) {  // For each token\\n                // Insert numerical value of token in x_data\\n                x_data = insert_element(x_data, std::stod(token));\\n            }\\n            // If label is in last column\\n            if (last_label) {\\n                y_data.resize(this->layers.back().neurons);\\n                // If task is classification\\n                if (y_data.size() > 1) {\\n                    y_data[x_data[x_data.size() - 1]] = 1;\\n                }\\n                // If task is regrssion (of single value)\\n                else {\\n                    y_data[0] = x_data[x_data.size() - 1];\\n                }\\n                x_data = pop_back(x_data);  // Remove label from x_data\\n            } else {\\n                y_data.resize(this->layers.back().neurons);\\n                // If task is classification\\n                if (y_data.size() > 1) {\\n                    y_data[x_data[x_data.size() - 1]] = 1;\\n                }\\n                // If task is regrssion (of single value)\\n                else {\\n                    y_data[0] = x_data[x_data.size() - 1];\\n                }\\n                x_data = pop_front(x_data);  // Remove label from x_data\\n            }\\n            // Push collected X_data and y_data in X and Y\\n            X.push_back({x_data});\\n            Y.push_back({y_data});\\n        }\\n        // Normalize training data if flag is set\\n        if (normalize) {\\n            // Scale data between 0 and 1 using min-max scaler\\n            X = minmax_scaler(X, 0.01, 1.0);\\n        }\\n        in_file.close();         // Closing file\\n        return make_pair(X, Y);  // Return pair of X and Y\\n    }\\n\\n    /**\\n     * Function to get prediction of model on single sample.\\n     * @param X array of feature vectors\\n     * @return returns predictions as vector\\n     */\\n    std::vector<std::valarray<double>> single_predict(\\n        const std::vector<std::valarray<double>> &X) {\\n        // Get activations of all layers\\n        auto activations = this->__detailed_single_prediction(X);\\n        // Return activations of last layer (actual predicted values)\\n        return activations.back();\\n    }\\n\\n    /**\\n     * Function to get prediction of model on batch\\n     * @param X array of feature vectors\\n     * @return returns predicted values as vector\\n     */\\n    std::vector<std::vector<std::valarray<double>>> batch_predict(\\n        const std::vector<std::vector<std::valarray<double>>> &X) {\\n        // Store predicted values\\n        std::vector<std::vector<std::valarray<double>>> predicted_batch(\\n            X.size());\\n        for (size_t i = 0; i < X.size(); i++) {  // For every sample\\n            // Push predicted values\\n            predicted_batch[i] = this->single_predict(X[i]);\\n        }\\n        return predicted_batch;  // Return predicted values\\n    }\\n\\n    /**\\n     * Function to fit model on supplied data\\n     * @param X array of feature vectors\\n     * @param Y array of target values\\n     * @param epochs number of epochs (default = 100)\\n     * @param learning_rate learning rate (default = 0.01)\\n     * @param batch_size batch size for gradient descent (default = 32)\\n     * @param shuffle flag for whether to shuffle data (default = true)\\n     */\\n    void fit(const std::vector<std::vector<std::valarray<double>>> &X_,\\n             const std::vector<std::vector<std::valarray<double>>> &Y_,\\n             const int &epochs = 100, const double &learning_rate = 0.01,\\n             const size_t &batch_size = 32, const bool &shuffle = true) {\\n        std::vector<std::vector<std::valarray<double>>> X = X_, Y = Y_;\\n        // Both label and input data should have same size\\n        if (X.size() != Y.size()) {\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr << \\\"X and Y in fit have different sizes\\\" << std::endl;\\n            std::exit(EXIT_FAILURE);\\n        }\\n        std::cout << \\\"INFO: Training Started\\\" << std::endl;\\n        for (int epoch = 1; epoch <= epochs; epoch++) {  // For every epoch\\n            // Shuffle X and Y if flag is set\\n            if (shuffle) {\\n                equal_shuffle(X, Y);\\n            }\\n            auto start =\\n                std::chrono::high_resolution_clock::now();  // Start clock\\n            double loss = 0,\\n                   acc = 0;  // Intialize performance metrics with zero\\n            // For each starting index of batch\\n            for (size_t batch_start = 0; batch_start < X.size();\\n                 batch_start += batch_size) {\\n                for (size_t i = batch_start;\\n                     i < std::min(X.size(), batch_start + batch_size); i++) {\\n                    std::vector<std::valarray<double>> grad, cur_error,\\n                        predicted;\\n                    auto activations = this->__detailed_single_prediction(X[i]);\\n                    // Gradients vector to store gradients for all layers\\n                    // They will be averaged and applied to kernel\\n                    std::vector<std::vector<std::valarray<double>>> gradients;\\n                    gradients.resize(this->layers.size());\\n                    // First intialize gradients to zero\\n                    for (size_t i = 0; i < gradients.size(); i++) {\\n                        zeroes_initialization(\\n                            gradients[i], get_shape(this->layers[i].kernel));\\n                    }\\n                    predicted = activations.back();  // Predicted vector\\n                    cur_error = predicted - Y[i];    // Absoulute error\\n                    // Calculating loss with MSE\\n                    loss += sum(apply_function(\\n                        cur_error, neural_network::util_functions::square));\\n                    // If prediction is correct\\n                    if (argmax(predicted) == argmax(Y[i])) {\\n                        acc += 1;\\n                    }\\n                    // For every layer (except first) starting from last one\\n                    for (size_t j = this->layers.size() - 1; j >= 1; j--) {\\n                        // Backpropogating errors\\n                        cur_error = hadamard_product(\\n                            cur_error,\\n                            apply_function(\\n                                activations[j + 1],\\n                                this->layers[j].dactivation_function));\\n                        // Calculating gradient for current layer\\n                        grad = multiply(transpose(activations[j]), cur_error);\\n                        // Change error according to current kernel values\\n                        cur_error = multiply(cur_error,\\n                                             transpose(this->layers[j].kernel));\\n                        // Adding gradient values to collection of gradients\\n                        gradients[j] = gradients[j] + grad / double(batch_size);\\n                    }\\n                    // Applying gradients\\n                    for (size_t j = this->layers.size() - 1; j >= 1; j--) {\\n                        // Updating kernel (aka weights)\\n                        this->layers[j].kernel = this->layers[j].kernel -\\n                                                 gradients[j] * learning_rate;\\n                    }\\n                }\\n            }\\n            auto stop =\\n                std::chrono::high_resolution_clock::now();  // Stoping the clock\\n            // Calculate time taken by epoch\\n            auto duration =\\n                std::chrono::duration_cast<std::chrono::microseconds>(stop -\\n                                                                      start);\\n            loss /= X.size();        // Averaging loss\\n            acc /= X.size();         // Averaging accuracy\\n            std::cout.precision(4);  // set output precision to 4\\n            // Printing training stats\\n            std::cout << \\\"Training: Epoch \\\" << epoch << '/' << epochs;\\n            std::cout << \\\", Loss: \\\" << loss;\\n            std::cout << \\\", Accuracy: \\\" << acc;\\n            std::cout << \\\", Taken time: \\\" << duration.count() / 1e6\\n                      << \\\" seconds\\\";\\n            std::cout << std::endl;\\n        }\\n        return;\\n    }\\n\\n    /**\\n     * Function to fit model on data stored in csv file\\n     * @param file_name csv file name\\n     * @param last_label flag for whether label is in first or last column\\n     * @param epochs number of epochs\\n     * @param learning_rate learning rate\\n     * @param normalize flag for whether to normalize data\\n     * @param slip_lines number of lines to skip\\n     * @param batch_size batch size for gradient descent (default = 32)\\n     * @param shuffle flag for whether to shuffle data (default = true)\\n     */\\n    void fit_from_csv(const std::string &file_name, const bool &last_label,\\n                      const int &epochs, const double &learning_rate,\\n                      const bool &normalize, const int &slip_lines = 1,\\n                      const size_t &batch_size = 32,\\n                      const bool &shuffle = true) {\\n        // Getting training data from csv file\\n        auto data =\\n            this->get_XY_from_csv(file_name, last_label, normalize, slip_lines);\\n        // Fit the model on training data\\n        this->fit(data.first, data.second, epochs, learning_rate, batch_size,\\n                  shuffle);\\n        return;\\n    }\\n\\n    /**\\n     * Function to evaluate model on supplied data\\n     * @param X array of feature vectors (input data)\\n     * @param Y array of target values (label)\\n     */\\n    void evaluate(const std::vector<std::vector<std::valarray<double>>> &X,\\n                  const std::vector<std::vector<std::valarray<double>>> &Y) {\\n        std::cout << \\\"INFO: Evaluation Started\\\" << std::endl;\\n        double acc = 0, loss = 0;  // intialize performance metrics with zero\\n        for (size_t i = 0; i < X.size(); i++) {  // For every sample in input\\n            // Get predictions\\n            std::vector<std::valarray<double>> pred =\\n                this->single_predict(X[i]);\\n            // If predicted class is correct\\n            if (argmax(pred) == argmax(Y[i])) {\\n                acc += 1;  // Increment accuracy\\n            }\\n            // Calculating loss - Mean Squared Error\\n            loss += sum(apply_function((Y[i] - pred),\\n                                       neural_network::util_functions::square) *\\n                        0.5);\\n        }\\n        acc /= X.size();   // Averaging accuracy\\n        loss /= X.size();  // Averaging loss\\n        // Prinitng performance of the model\\n        std::cout << \\\"Evaluation: Loss: \\\" << loss;\\n        std::cout << \\\", Accuracy: \\\" << acc << std::endl;\\n        return;\\n    }\\n\\n    /**\\n     * Function to evaluate model on data stored in csv file\\n     * @param file_name csv file name\\n     * @param last_label flag for whether label is in first or last column\\n     * @param normalize flag for whether to normalize data\\n     * @param slip_lines number of lines to skip\\n     */\\n    void evaluate_from_csv(const std::string &file_name, const bool &last_label,\\n                           const bool &normalize, const int &slip_lines = 1) {\\n        // Getting training data from csv file\\n        auto data =\\n            this->get_XY_from_csv(file_name, last_label, normalize, slip_lines);\\n        // Evaluating model\\n        this->evaluate(data.first, data.second);\\n        return;\\n    }\\n\\n    /**\\n     * Function to save current model.\\n     * @param file_name file name to save model (*.model)\\n     */\\n    void save_model(const std::string &_file_name) {\\n        std::string file_name = _file_name;\\n        // Adding \\\".model\\\" extension if it is not already there in name\\n        if (file_name.find(\\\".model\\\") == file_name.npos) {\\n            file_name += \\\".model\\\";\\n        }\\n        std::ofstream out_file;  // Ofstream to write in file\\n        // Open file in out|trunc mode\\n        out_file.open(file_name.c_str(),\\n                      std::ofstream::out | std::ofstream::trunc);\\n        // If there is any problem in opening file\\n        if (!out_file.is_open()) {\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr << \\\"Unable to open file: \\\" << file_name << std::endl;\\n            std::exit(EXIT_FAILURE);\\n        }\\n        /**\\n            Format in which model is saved:\\n\\n            total_layers\\n            neurons(1st neural_network::layers::DenseLayer) activation_name(1st\\n           neural_network::layers::DenseLayer) kernel_shape(1st\\n           neural_network::layers::DenseLayer) kernel_values\\n            .\\n            .\\n            .\\n            neurons(Nth neural_network::layers::DenseLayer) activation_name(Nth\\n           neural_network::layers::DenseLayer) kernel_shape(Nth\\n           neural_network::layers::DenseLayer) kernel_value\\n\\n            For Example, pretrained model with 3 layers:\\n            <pre>\\n            3\\n            4 none\\n            4 4\\n            1 0 0 0\\n            0 1 0 0\\n            0 0 1 0\\n            0 0 0 1\\n            6 relu\\n            4 6\\n            -1.88963 -3.61165 1.30757 -0.443906 -2.41039 -2.69653\\n            -0.684753 0.0891452 0.795294 -2.39619 2.73377 0.318202\\n            -2.91451 -4.43249 -0.804187 2.51995 -6.97524 -1.07049\\n            -0.571531 -1.81689 -1.24485 1.92264 -2.81322 1.01741\\n            3 sigmoid\\n            6 3\\n            0.390267 -0.391703 -0.0989607\\n            0.499234 -0.564539 -0.28097\\n            0.553386 -0.153974 -1.92493\\n            -2.01336 -0.0219682 1.44145\\n            1.72853 -0.465264 -0.705373\\n            -0.908409 -0.740547 0.376416\\n            </pre>\\n        */\\n        // Saving model in the same format\\n        out_file << layers.size();\\n        out_file << std::endl;\\n        for (const auto &layer : this->layers) {\\n            out_file << layer.neurons << ' ' << layer.activation << std::endl;\\n            const auto shape = get_shape(layer.kernel);\\n            out_file << shape.first << ' ' << shape.second << std::endl;\\n            for (const auto &row : layer.kernel) {\\n                for (const auto &val : row) {\\n                    out_file << val << ' ';\\n                }\\n                out_file << std::endl;\\n            }\\n        }\\n        std::cout << \\\"INFO: Model saved successfully with name : \\\";\\n        std::cout << file_name << std::endl;\\n        out_file.close();  // Closing file\\n        return;\\n    }\\n\\n    /**\\n     * Function to load earlier saved model.\\n     * @param file_name file from which model will be loaded (*.model)\\n     * @return instance of NeuralNetwork class with pretrained weights\\n     */\\n    NeuralNetwork load_model(const std::string &file_name) {\\n        std::ifstream in_file;            // Ifstream to read file\\n        in_file.open(file_name.c_str());  // Openinig file\\n        // If there is any problem in opening file\\n        if (!in_file.is_open()) {\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr << \\\"Unable to open file: \\\" << file_name << std::endl;\\n            std::exit(EXIT_FAILURE);\\n        }\\n        std::vector<std::pair<int, std::string>> config;  // To store config\\n        std::vector<std::vector<std::valarray<double>>>\\n            kernels;  // To store pretrained kernels\\n        // Loading model from saved file format\\n        size_t total_layers = 0;\\n        in_file >> total_layers;\\n        for (size_t i = 0; i < total_layers; i++) {\\n            int neurons = 0;\\n            std::string activation;\\n            size_t shape_a = 0, shape_b = 0;\\n            std::vector<std::valarray<double>> kernel;\\n            in_file >> neurons >> activation >> shape_a >> shape_b;\\n            for (size_t r = 0; r < shape_a; r++) {\\n                std::valarray<double> row(shape_b);\\n                for (size_t c = 0; c < shape_b; c++) {\\n                    in_file >> row[c];\\n                }\\n                kernel.push_back(row);\\n            }\\n            config.emplace_back(make_pair(neurons, activation));\\n            ;\\n            kernels.emplace_back(kernel);\\n        }\\n        std::cout << \\\"INFO: Model loaded successfully\\\" << std::endl;\\n        in_file.close();  // Closing file\\n        return NeuralNetwork(\\n            config, kernels);  // Return instance of NeuralNetwork class\\n    }\\n\\n    /**\\n     * Function to print summary of the network.\\n     */\\n    void summary() {\\n        // Printing Summary\\n        std::cout\\n            << \\\"===============================================================\\\"\\n            << std::endl;\\n        std::cout << \\\"\\\\t\\\\t+ MODEL SUMMARY +\\\\t\\\\t\\\\n\\\";\\n        std::cout\\n            << \\\"===============================================================\\\"\\n            << std::endl;\\n        for (size_t i = 1; i <= layers.size(); i++) {  // For every layer\\n            std::cout << i << \\\")\\\";\\n            std::cout << \\\" Neurons : \\\"\\n                      << layers[i - 1].neurons;  // number of neurons\\n            std::cout << \\\", Activation : \\\"\\n                      << layers[i - 1].activation;  // activation\\n            std::cout << \\\", kernel Shape : \\\"\\n                      << get_shape(layers[i - 1].kernel);  // kernel shape\\n            std::cout << std::endl;\\n        }\\n        std::cout\\n            << \\\"===============================================================\\\"\\n            << std::endl;\\n        return;\\n    }\\n};\\n}  // namespace neural_network\\n}  // namespace machine_learning\\n\\n/**\\n * Function to test neural network\\n * @returns none\\n */\\nstatic void test() {\\n    // Creating network with 3 layers for \\\"iris.csv\\\"\\n    machine_learning::neural_network::NeuralNetwork myNN =\\n        machine_learning::neural_network::NeuralNetwork({\\n            {4, \\\"none\\\"},  // First layer with 3 neurons and \\\"none\\\" as activation\\n            {6,\\n             \\\"relu\\\"},  // Second layer with 6 neurons and \\\"relu\\\" as activation\\n            {3, \\\"sigmoid\\\"}  // Third layer with 3 neurons and \\\"sigmoid\\\" as\\n                            // activation\\n        });\\n    // Printing summary of model\\n    myNN.summary();\\n    // Training Model\\n    myNN.fit_from_csv(\\\"iris.csv\\\", true, 100, 0.3, false, 2, 32, true);\\n    // Testing predictions of model\\n    assert(machine_learning::argmax(\\n               myNN.single_predict({{5, 3.4, 1.6, 0.4}})) == 0);\\n    assert(machine_learning::argmax(\\n               myNN.single_predict({{6.4, 2.9, 4.3, 1.3}})) == 1);\\n    assert(machine_learning::argmax(\\n               myNN.single_predict({{6.2, 3.4, 5.4, 2.3}})) == 2);\\n    return;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    // Testing\\n    test();\\n    return 0;\\n}\\n\"",
    "ordinary least squares regressor": "\"/**\\n * @file\\n * \\\\brief Linear regression example using [Ordinary least\\n * squares](https://en.wikipedia.org/wiki/Ordinary_least_squares)\\n *\\n * Program that gets the number of data samples and number of features per\\n * sample along with output per sample. It applies OLS regression to compute\\n * the regression output for additional test data samples.\\n *\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#include <cassert>\\n#include <cmath>    // for std::abs\\n#include <iomanip>  // for print formatting\\n#include <iostream>\\n#include <vector>\\n\\n/**\\n * operator to print a matrix\\n */\\ntemplate <typename T>\\nstd::ostream &operator<<(std::ostream &out,\\n                         std::vector<std::vector<T>> const &v) {\\n    const int width = 10;\\n    const char separator = ' ';\\n\\n    for (size_t row = 0; row < v.size(); row++) {\\n        for (size_t col = 0; col < v[row].size(); col++) {\\n            out << std::left << std::setw(width) << std::setfill(separator)\\n                << v[row][col];\\n        }\\n        out << std::endl;\\n    }\\n\\n    return out;\\n}\\n\\n/**\\n * operator to print a vector\\n */\\ntemplate <typename T>\\nstd::ostream &operator<<(std::ostream &out, std::vector<T> const &v) {\\n    const int width = 15;\\n    const char separator = ' ';\\n\\n    for (size_t row = 0; row < v.size(); row++) {\\n        out << std::left << std::setw(width) << std::setfill(separator)\\n            << v[row];\\n    }\\n\\n    return out;\\n}\\n\\n/**\\n * function to check if given matrix is a square matrix\\n * \\\\returns 1 if true, 0 if false\\n */\\ntemplate <typename T>\\ninline bool is_square(std::vector<std::vector<T>> const &A) {\\n    // Assuming A is square matrix\\n    size_t N = A.size();\\n    for (size_t i = 0; i < N; i++) {\\n        if (A[i].size() != N) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * Matrix multiplication such that if A is size (mxn) and\\n * B is of size (pxq) then the multiplication is defined\\n * only when n = p and the resultant matrix is of size (mxq)\\n *\\n * \\\\returns resultant matrix\\n **/\\ntemplate <typename T>\\nstd::vector<std::vector<T>> operator*(std::vector<std::vector<T>> const &A,\\n                                      std::vector<std::vector<T>> const &B) {\\n    // Number of rows in A\\n    size_t N_A = A.size();\\n    // Number of columns in B\\n    size_t N_B = B[0].size();\\n\\n    std::vector<std::vector<T>> result(N_A);\\n\\n    if (A[0].size() != B.size()) {\\n        std::cerr << \\\"Number of columns in A != Number of rows in B (\\\"\\n                  << A[0].size() << \\\", \\\" << B.size() << \\\")\\\" << std::endl;\\n        return result;\\n    }\\n\\n    for (size_t row = 0; row < N_A; row++) {\\n        std::vector<T> v(N_B);\\n        for (size_t col = 0; col < N_B; col++) {\\n            v[col] = static_cast<T>(0);\\n            for (size_t j = 0; j < B.size(); j++) {\\n                v[col] += A[row][j] * B[j][col];\\n            }\\n        }\\n        result[row] = v;\\n    }\\n\\n    return result;\\n}\\n\\n/**\\n * multiplication of a matrix with a column vector\\n * \\\\returns resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<T> operator*(std::vector<std::vector<T>> const &A,\\n                         std::vector<T> const &B) {\\n    // Number of rows in A\\n    size_t N_A = A.size();\\n\\n    std::vector<T> result(N_A);\\n\\n    if (A[0].size() != B.size()) {\\n        std::cerr << \\\"Number of columns in A != Number of rows in B (\\\"\\n                  << A[0].size() << \\\", \\\" << B.size() << \\\")\\\" << std::endl;\\n        return result;\\n    }\\n\\n    for (size_t row = 0; row < N_A; row++) {\\n        result[row] = static_cast<T>(0);\\n        for (size_t j = 0; j < B.size(); j++) result[row] += A[row][j] * B[j];\\n    }\\n\\n    return result;\\n}\\n\\n/**\\n * pre-multiplication of a vector by a scalar\\n * \\\\returns resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<float> operator*(float const scalar, std::vector<T> const &A) {\\n    // Number of rows in A\\n    size_t N_A = A.size();\\n\\n    std::vector<float> result(N_A);\\n\\n    for (size_t row = 0; row < N_A; row++) {\\n        result[row] += A[row] * static_cast<float>(scalar);\\n    }\\n\\n    return result;\\n}\\n\\n/**\\n * post-multiplication of a vector by a scalar\\n * \\\\returns resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<float> operator*(std::vector<T> const &A, float const scalar) {\\n    // Number of rows in A\\n    size_t N_A = A.size();\\n\\n    std::vector<float> result(N_A);\\n\\n    for (size_t row = 0; row < N_A; row++) {\\n        result[row] = A[row] * static_cast<float>(scalar);\\n    }\\n\\n    return result;\\n}\\n\\n/**\\n * division of a vector by a scalar\\n * \\\\returns resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<float> operator/(std::vector<T> const &A, float const scalar) {\\n    return (1.f / scalar) * A;\\n}\\n\\n/**\\n * subtraction of two vectors of identical lengths\\n * \\\\returns resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<T> operator-(std::vector<T> const &A, std::vector<T> const &B) {\\n    // Number of rows in A\\n    size_t N = A.size();\\n\\n    std::vector<T> result(N);\\n\\n    if (B.size() != N) {\\n        std::cerr << \\\"Vector dimensions shouldbe identical!\\\" << std::endl;\\n        return A;\\n    }\\n\\n    for (size_t row = 0; row < N; row++) result[row] = A[row] - B[row];\\n\\n    return result;\\n}\\n\\n/**\\n * addition of two vectors of identical lengths\\n * \\\\returns resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<T> operator+(std::vector<T> const &A, std::vector<T> const &B) {\\n    // Number of rows in A\\n    size_t N = A.size();\\n\\n    std::vector<T> result(N);\\n\\n    if (B.size() != N) {\\n        std::cerr << \\\"Vector dimensions shouldbe identical!\\\" << std::endl;\\n        return A;\\n    }\\n\\n    for (size_t row = 0; row < N; row++) result[row] = A[row] + B[row];\\n\\n    return result;\\n}\\n\\n/**\\n * Get matrix inverse using Row-trasnformations. Given matrix must\\n * be a square and non-singular.\\n * \\\\returns inverse matrix\\n **/\\ntemplate <typename T>\\nstd::vector<std::vector<float>> get_inverse(\\n    std::vector<std::vector<T>> const &A) {\\n    // Assuming A is square matrix\\n    size_t N = A.size();\\n\\n    std::vector<std::vector<float>> inverse(N);\\n    for (size_t row = 0; row < N; row++) {\\n        // preallocatae a resultant identity matrix\\n        inverse[row] = std::vector<float>(N);\\n        for (size_t col = 0; col < N; col++) {\\n            inverse[row][col] = (row == col) ? 1.f : 0.f;\\n        }\\n    }\\n\\n    if (!is_square(A)) {\\n        std::cerr << \\\"A must be a square matrix!\\\" << std::endl;\\n        return inverse;\\n    }\\n\\n    // preallocatae a temporary matrix identical to A\\n    std::vector<std::vector<float>> temp(N);\\n    for (size_t row = 0; row < N; row++) {\\n        std::vector<float> v(N);\\n        for (size_t col = 0; col < N; col++) {\\n            v[col] = static_cast<float>(A[row][col]);\\n        }\\n        temp[row] = v;\\n    }\\n\\n    // start transformations\\n    for (size_t row = 0; row < N; row++) {\\n        for (size_t row2 = row; row2 < N && temp[row][row] == 0; row2++) {\\n            // this to ensure diagonal elements are not 0\\n            temp[row] = temp[row] + temp[row2];\\n            inverse[row] = inverse[row] + inverse[row2];\\n        }\\n\\n        for (size_t col2 = row; col2 < N && temp[row][row] == 0; col2++) {\\n            // this to further ensure diagonal elements are not 0\\n            for (size_t row2 = 0; row2 < N; row2++) {\\n                temp[row2][row] = temp[row2][row] + temp[row2][col2];\\n                inverse[row2][row] = inverse[row2][row] + inverse[row2][col2];\\n            }\\n        }\\n\\n        if (temp[row][row] == 0) {\\n            // Probably a low-rank matrix and hence singular\\n            std::cerr << \\\"Low-rank matrix, no inverse!\\\" << std::endl;\\n            return inverse;\\n        }\\n\\n        // set diagonal to 1\\n        auto divisor = static_cast<float>(temp[row][row]);\\n        temp[row] = temp[row] / divisor;\\n        inverse[row] = inverse[row] / divisor;\\n        // Row transformations\\n        for (size_t row2 = 0; row2 < N; row2++) {\\n            if (row2 == row) {\\n                continue;\\n            }\\n            float factor = temp[row2][row];\\n            temp[row2] = temp[row2] - factor * temp[row];\\n            inverse[row2] = inverse[row2] - factor * inverse[row];\\n        }\\n    }\\n\\n    return inverse;\\n}\\n\\n/**\\n * matrix transpose\\n * \\\\returns resultant matrix\\n **/\\ntemplate <typename T>\\nstd::vector<std::vector<T>> get_transpose(\\n    std::vector<std::vector<T>> const &A) {\\n    std::vector<std::vector<T>> result(A[0].size());\\n\\n    for (size_t row = 0; row < A[0].size(); row++) {\\n        std::vector<T> v(A.size());\\n        for (size_t col = 0; col < A.size(); col++) v[col] = A[col][row];\\n\\n        result[row] = v;\\n    }\\n    return result;\\n}\\n\\n/**\\n * Perform Ordinary Least Squares curve fit. This operation is defined as\\n * \\\\f[\\\\beta = \\\\left(X^TXX^T\\\\right)Y\\\\f]\\n * \\\\param X feature matrix with rows representing sample vector of features\\n * \\\\param Y known regression value for each sample\\n * \\\\returns fitted regression model polynomial coefficients\\n */\\ntemplate <typename T>\\nstd::vector<float> fit_OLS_regressor(std::vector<std::vector<T>> const &X,\\n                                     std::vector<T> const &Y) {\\n    // NxF\\n    std::vector<std::vector<T>> X2 = X;\\n    for (size_t i = 0; i < X2.size(); i++) {\\n        // add Y-intercept -> Nx(F+1)\\n        X2[i].push_back(1);\\n    }\\n    // (F+1)xN\\n    std::vector<std::vector<T>> Xt = get_transpose(X2);\\n    // (F+1)x(F+1)\\n    std::vector<std::vector<T>> tmp = get_inverse(Xt * X2);\\n    // (F+1)xN\\n    std::vector<std::vector<float>> out = tmp * Xt;\\n    // cout << endl\\n    //      << \\\"Projection matrix: \\\" << X2 * out << endl;\\n\\n    // Fx1,1    -> (F+1)^th element is the independent constant\\n    return out * Y;\\n}\\n\\n/**\\n * Given data and OLS model coeffficients, predict\\n * regression estimates. This operation is defined as\\n * \\\\f[y_{\\\\text{row}=i} = \\\\sum_{j=\\\\text{columns}}\\\\beta_j\\\\cdot X_{i,j}\\\\f]\\n *\\n * \\\\param X feature matrix with rows representing sample vector of features\\n * \\\\param beta fitted regression model\\n * \\\\return vector with regression values for each sample\\n **/\\ntemplate <typename T>\\nstd::vector<float> predict_OLS_regressor(std::vector<std::vector<T>> const &X,\\n                                         std::vector<float> const &beta /**< */\\n) {\\n    std::vector<float> result(X.size());\\n\\n    for (size_t rows = 0; rows < X.size(); rows++) {\\n        // -> start with constant term\\n        result[rows] = beta[X[0].size()];\\n        for (size_t cols = 0; cols < X[0].size(); cols++) {\\n            result[rows] += beta[cols] * X[rows][cols];\\n        }\\n    }\\n    // Nx1\\n    return result;\\n}\\n\\n/** Self test checks */\\nvoid ols_test() {\\n    int F = 3, N = 5;\\n\\n    /* test function = x^2 -5 */\\n    std::cout << \\\"Test 1 (quadratic function)....\\\";\\n    // create training data set with features = x, x^2, x^3\\n    std::vector<std::vector<float>> data1(\\n        {{-5, 25, -125}, {-1, 1, -1}, {0, 0, 0}, {1, 1, 1}, {6, 36, 216}});\\n    // create corresponding outputs\\n    std::vector<float> Y1({20, -4, -5, -4, 31});\\n    // perform regression modelling\\n    std::vector<float> beta1 = fit_OLS_regressor(data1, Y1);\\n    // create test data set with same features = x, x^2, x^3\\n    std::vector<std::vector<float>> test_data1(\\n        {{-2, 4, -8}, {2, 4, 8}, {-10, 100, -1000}, {10, 100, 1000}});\\n    // expected regression outputs\\n    std::vector<float> expected1({-1, -1, 95, 95});\\n    // predicted regression outputs\\n    std::vector<float> out1 = predict_OLS_regressor(test_data1, beta1);\\n    // compare predicted results are within +-0.01 limit of expected\\n    for (size_t rows = 0; rows < out1.size(); rows++) {\\n        assert(std::abs(out1[rows] - expected1[rows]) < 0.01);\\n    }\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    /* test function = x^3 + x^2 - 100 */\\n    std::cout << \\\"Test 2 (cubic function)....\\\";\\n    // create training data set with features = x, x^2, x^3\\n    std::vector<std::vector<float>> data2(\\n        {{-5, 25, -125}, {-1, 1, -1}, {0, 0, 0}, {1, 1, 1}, {6, 36, 216}});\\n    // create corresponding outputs\\n    std::vector<float> Y2({-200, -100, -100, 98, 152});\\n    // perform regression modelling\\n    std::vector<float> beta2 = fit_OLS_regressor(data2, Y2);\\n    // create test data set with same features = x, x^2, x^3\\n    std::vector<std::vector<float>> test_data2(\\n        {{-2, 4, -8}, {2, 4, 8}, {-10, 100, -1000}, {10, 100, 1000}});\\n    // expected regression outputs\\n    std::vector<float> expected2({-104, -88, -1000, 1000});\\n    // predicted regression outputs\\n    std::vector<float> out2 = predict_OLS_regressor(test_data2, beta2);\\n    // compare predicted results are within +-0.01 limit of expected\\n    for (size_t rows = 0; rows < out2.size(); rows++) {\\n        assert(std::abs(out2[rows] - expected2[rows]) < 0.01);\\n    }\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << std::endl;  // ensure test results are displayed on screen\\n                             // (flush stdout)\\n}\\n\\n/**\\n * main function\\n */\\nint main() {\\n    ols_test();\\n\\n    size_t N = 0, F = 0;\\n\\n    std::cout << \\\"Enter number of features: \\\";\\n    // number of features = columns\\n    std::cin >> F;\\n    std::cout << \\\"Enter number of samples: \\\";\\n    // number of samples = rows\\n    std::cin >> N;\\n\\n    std::vector<std::vector<float>> data(N);\\n    std::vector<float> Y(N);\\n\\n    std::cout\\n        << \\\"Enter training data. Per sample, provide features and one output.\\\"\\n        << std::endl;\\n\\n    for (size_t rows = 0; rows < N; rows++) {\\n        std::vector<float> v(F);\\n        std::cout << \\\"Sample# \\\" << rows + 1 << \\\": \\\";\\n        for (size_t cols = 0; cols < F; cols++) {\\n            // get the F features\\n            std::cin >> v[cols];\\n        }\\n        data[rows] = v;\\n        // get the corresponding output\\n        std::cin >> Y[rows];\\n    }\\n\\n    std::vector<float> beta = fit_OLS_regressor(data, Y);\\n    std::cout << std::endl << std::endl << \\\"beta:\\\" << beta << std::endl;\\n\\n    size_t T = 0;\\n    std::cout << \\\"Enter number of test samples: \\\";\\n    // number of test sample inputs\\n    std::cin >> T;\\n    std::vector<std::vector<float>> data2(T);\\n    // vector<float> Y2(T);\\n\\n    for (size_t rows = 0; rows < T; rows++) {\\n        std::cout << \\\"Sample# \\\" << rows + 1 << \\\": \\\";\\n        std::vector<float> v(F);\\n        for (size_t cols = 0; cols < F; cols++) std::cin >> v[cols];\\n        data2[rows] = v;\\n    }\\n\\n    std::vector<float> out = predict_OLS_regressor(data2, beta);\\n    for (size_t rows = 0; rows < T; rows++) std::cout << out[rows] << std::endl;\\n\\n    return 0;\\n}\\n\"",
    "vector ops": "\"/**\\n * @file vector_ops.hpp\\n * @author [Deep Raval](https://github.com/imdeep2905)\\n *\\n * @brief Various functions for vectors associated with [NeuralNetwork (aka\\n * Multilayer Perceptron)]\\n * (https://en.wikipedia.org/wiki/Multilayer_perceptron).\\n *\\n */\\n#ifndef VECTOR_OPS_FOR_NN\\n#define VECTOR_OPS_FOR_NN\\n\\n#include <algorithm>\\n#include <chrono>\\n#include <iostream>\\n#include <random>\\n#include <valarray>\\n#include <vector>\\n\\n/**\\n * @namespace machine_learning\\n * @brief Machine Learning algorithms\\n */\\nnamespace machine_learning {\\n/**\\n * Overloaded operator \\\"<<\\\" to print 2D vector\\n * @tparam T typename of the vector\\n * @param out std::ostream to output\\n * @param A 2D vector to be printed\\n */\\ntemplate <typename T>\\nstd::ostream &operator<<(std::ostream &out,\\n                         std::vector<std::valarray<T>> const &A) {\\n    // Setting output precision to 4 in case of floating point numbers\\n    out.precision(4);\\n    for (const auto &a : A) {       // For each row in A\\n        for (const auto &x : a) {   // For each element in row\\n            std::cout << x << ' ';  // print element\\n        }\\n        std::cout << std::endl;\\n    }\\n    return out;\\n}\\n\\n/**\\n * Overloaded operator \\\"<<\\\" to print a pair\\n * @tparam T typename of the pair\\n * @param out std::ostream to output\\n * @param A Pair to be printed\\n */\\ntemplate <typename T>\\nstd::ostream &operator<<(std::ostream &out, const std::pair<T, T> &A) {\\n    // Setting output precision to 4 in case of floating point numbers\\n    out.precision(4);\\n    // printing pair in the form (p, q)\\n    std::cout << \\\"(\\\" << A.first << \\\", \\\" << A.second << \\\")\\\";\\n    return out;\\n}\\n\\n/**\\n * Overloaded operator \\\"<<\\\" to print a 1D vector\\n * @tparam T typename of the vector\\n * @param out std::ostream to output\\n * @param A 1D vector to be printed\\n */\\ntemplate <typename T>\\nstd::ostream &operator<<(std::ostream &out, const std::valarray<T> &A) {\\n    // Setting output precision to 4 in case of floating point numbers\\n    out.precision(4);\\n    for (const auto &a : A) {   // For every element in the vector.\\n        std::cout << a << ' ';  // Print element\\n    }\\n    std::cout << std::endl;\\n    return out;\\n}\\n\\n/**\\n * Function to insert element into 1D vector\\n * @tparam T typename of the 1D vector and the element\\n * @param A 1D vector in which element will to be inserted\\n * @param ele element to be inserted\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::valarray<T> insert_element(const std::valarray<T> &A, const T &ele) {\\n    std::valarray<T> B;      // New 1D vector to store resultant vector\\n    B.resize(A.size() + 1);  // Resizing it accordingly\\n    for (size_t i = 0; i < A.size(); i++) {  // For every element in A\\n        B[i] = A[i];                         // Copy element in B\\n    }\\n    B[B.size() - 1] = ele;  // Inserting new element in last position\\n    return B;               // Return resultant vector\\n}\\n\\n/**\\n * Function to remove first element from 1D vector\\n * @tparam T typename of the vector\\n * @param A 1D vector from which first element will be removed\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::valarray<T> pop_front(const std::valarray<T> &A) {\\n    std::valarray<T> B;      // New 1D vector to store resultant vector\\n    B.resize(A.size() - 1);  // Resizing it accordingly\\n    for (size_t i = 1; i < A.size();\\n         i++) {           // // For every (except first) element in A\\n        B[i - 1] = A[i];  // Copy element in B with left shifted position\\n    }\\n    return B;  // Return resultant vector\\n}\\n\\n/**\\n * Function to remove last element from 1D vector\\n * @tparam T typename of the vector\\n * @param A 1D vector from which last element will be removed\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::valarray<T> pop_back(const std::valarray<T> &A) {\\n    std::valarray<T> B;      // New 1D vector to store resultant vector\\n    B.resize(A.size() - 1);  // Resizing it accordingly\\n    for (size_t i = 0; i < A.size() - 1;\\n         i++) {       // For every (except last) element in A\\n        B[i] = A[i];  // Copy element in B\\n    }\\n    return B;  // Return resultant vector\\n}\\n\\n/**\\n * Function to equally shuffle two 3D vectors (used for shuffling training data)\\n * @tparam T typename of the vector\\n * @param A First 3D vector\\n * @param B Second 3D vector\\n */\\ntemplate <typename T>\\nvoid equal_shuffle(std::vector<std::vector<std::valarray<T>>> &A,\\n                   std::vector<std::vector<std::valarray<T>>> &B) {\\n    // If two vectors have different sizes\\n    if (A.size() != B.size()) {\\n        std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n        std::cerr\\n            << \\\"Can not equally shuffle two vectors with different sizes: \\\";\\n        std::cerr << A.size() << \\\" and \\\" << B.size() << std::endl;\\n        std::exit(EXIT_FAILURE);\\n    }\\n    for (size_t i = 0; i < A.size(); i++) {  // For every element in A and B\\n        // Genrating random index < size of A and B\\n        std::srand(std::chrono::system_clock::now().time_since_epoch().count());\\n        size_t random_index = std::rand() % A.size();\\n        // Swap elements in both A and B with same random index\\n        std::swap(A[i], A[random_index]);\\n        std::swap(B[i], B[random_index]);\\n    }\\n    return;\\n}\\n\\n/**\\n * Function to initialize given 2D vector using uniform random initialization\\n * @tparam T typename of the vector\\n * @param A 2D vector to be initialized\\n * @param shape required shape\\n * @param low lower limit on value\\n * @param high upper limit on value\\n */\\ntemplate <typename T>\\nvoid uniform_random_initialization(std::vector<std::valarray<T>> &A,\\n                                   const std::pair<size_t, size_t> &shape,\\n                                   const T &low, const T &high) {\\n    A.clear();  // Making A empty\\n    // Uniform distribution in range [low, high]\\n    std::default_random_engine generator(\\n        std::chrono::system_clock::now().time_since_epoch().count());\\n    std::uniform_real_distribution<T> distribution(low, high);\\n    for (size_t i = 0; i < shape.first; i++) {  // For every row\\n        std::valarray<T>\\n            row;  // Making empty row which will be inserted in vector\\n        row.resize(shape.second);\\n        for (auto &r : row) {             // For every element in row\\n            r = distribution(generator);  // copy random number\\n        }\\n        A.push_back(row);  // Insert new row in vector\\n    }\\n    return;\\n}\\n\\n/**\\n * Function to Intialize 2D vector as unit matrix\\n * @tparam T typename of the vector\\n * @param A 2D vector to be initialized\\n * @param shape required shape\\n */\\ntemplate <typename T>\\nvoid unit_matrix_initialization(std::vector<std::valarray<T>> &A,\\n                                const std::pair<size_t, size_t> &shape) {\\n    A.clear();  // Making A empty\\n    for (size_t i = 0; i < shape.first; i++) {\\n        std::valarray<T>\\n            row;  // Making empty row which will be inserted in vector\\n        row.resize(shape.second);\\n        row[i] = T(1);     // Insert 1 at ith position\\n        A.push_back(row);  // Insert new row in vector\\n    }\\n    return;\\n}\\n\\n/**\\n * Function to Intialize 2D vector as zeroes\\n * @tparam T typename of the vector\\n * @param A 2D vector to be initialized\\n * @param shape required shape\\n */\\ntemplate <typename T>\\nvoid zeroes_initialization(std::vector<std::valarray<T>> &A,\\n                           const std::pair<size_t, size_t> &shape) {\\n    A.clear();  // Making A empty\\n    for (size_t i = 0; i < shape.first; i++) {\\n        std::valarray<T>\\n            row;  // Making empty row which will be inserted in vector\\n        row.resize(shape.second);  // By default all elements are zero\\n        A.push_back(row);          // Insert new row in vector\\n    }\\n    return;\\n}\\n\\n/**\\n * Function to get sum of all elements in 2D vector\\n * @tparam T typename of the vector\\n * @param A 2D vector for which sum is required\\n * @return returns sum of all elements of 2D vector\\n */\\ntemplate <typename T>\\nT sum(const std::vector<std::valarray<T>> &A) {\\n    T cur_sum = 0;             // Initially sum is zero\\n    for (const auto &a : A) {  // For every row in A\\n        cur_sum += a.sum();    // Add sum of that row to current sum\\n    }\\n    return cur_sum;  // Return sum\\n}\\n\\n/**\\n * Function to get shape of given 2D vector\\n * @tparam T typename of the vector\\n * @param A 2D vector for which shape is required\\n * @return shape as pair\\n */\\ntemplate <typename T>\\nstd::pair<size_t, size_t> get_shape(const std::vector<std::valarray<T>> &A) {\\n    const size_t sub_size = (*A.begin()).size();\\n    for (const auto &a : A) {\\n        // If supplied vector don't have same shape in all rows\\n        if (a.size() != sub_size) {\\n            std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n            std::cerr << \\\"Supplied vector is not 2D Matrix\\\" << std::endl;\\n            std::exit(EXIT_FAILURE);\\n        }\\n    }\\n    return std::make_pair(A.size(), sub_size);  // Return shape as pair\\n}\\n\\n/**\\n * Function to scale given 3D vector using min-max scaler\\n * @tparam T typename of the vector\\n * @param A 3D vector which will be scaled\\n * @param low new minimum value\\n * @param high new maximum value\\n * @return new scaled 3D vector\\n */\\ntemplate <typename T>\\nstd::vector<std::vector<std::valarray<T>>> minmax_scaler(\\n    const std::vector<std::vector<std::valarray<T>>> &A, const T &low,\\n    const T &high) {\\n    std::vector<std::vector<std::valarray<T>>> B =\\n        A;                               // Copying into new vector B\\n    const auto shape = get_shape(B[0]);  // Storing shape of B's every element\\n    // As this function is used for scaling training data vector should be of\\n    // shape (1, X)\\n    if (shape.first != 1) {\\n        std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n        std::cerr\\n            << \\\"Supplied vector is not supported for minmax scaling, shape: \\\";\\n        std::cerr << shape << std::endl;\\n        std::exit(EXIT_FAILURE);\\n    }\\n    for (size_t i = 0; i < shape.second; i++) {\\n        T min = B[0][0][i], max = B[0][0][i];\\n        for (size_t j = 0; j < B.size(); j++) {\\n            // Updating minimum and maximum values\\n            min = std::min(min, B[j][0][i]);\\n            max = std::max(max, B[j][0][i]);\\n        }\\n        for (size_t j = 0; j < B.size(); j++) {\\n            // Applying min-max scaler formula\\n            B[j][0][i] =\\n                ((B[j][0][i] - min) / (max - min)) * (high - low) + low;\\n        }\\n    }\\n    return B;  // Return new resultant 3D vector\\n}\\n\\n/**\\n * Function to get index of maximum element in 2D vector\\n * @tparam T typename of the vector\\n * @param A 2D vector for which maximum index is required\\n * @return index of maximum element\\n */\\ntemplate <typename T>\\nsize_t argmax(const std::vector<std::valarray<T>> &A) {\\n    const auto shape = get_shape(A);\\n    // As this function is used on predicted (or target) vector, shape should be\\n    // (1, X)\\n    if (shape.first != 1) {\\n        std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n        std::cerr << \\\"Supplied vector is ineligible for argmax\\\" << std::endl;\\n        std::exit(EXIT_FAILURE);\\n    }\\n    // Return distance of max element from first element (i.e. index)\\n    return std::distance(std::begin(A[0]),\\n                         std::max_element(std::begin(A[0]), std::end(A[0])));\\n}\\n\\n/**\\n * Function which applys supplied function to every element of 2D vector\\n * @tparam T typename of the vector\\n * @param A 2D vector on which function will be applied\\n * @param func Function to be applied\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<std::valarray<T>> apply_function(\\n    const std::vector<std::valarray<T>> &A, T (*func)(const T &)) {\\n    std::vector<std::valarray<double>> B =\\n        A;                  // New vector to store resultant vector\\n    for (auto &b : B) {     // For every row in vector\\n        b = b.apply(func);  // Apply function to that row\\n    }\\n    return B;  // Return new resultant 2D vector\\n}\\n\\n/**\\n * Overloaded operator \\\"*\\\" to multiply given 2D vector with scaler\\n * @tparam T typename of both vector and the scaler\\n * @param A 2D vector to which scaler will be multiplied\\n * @param val Scaler value which will be multiplied\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<std::valarray<T>> operator*(const std::vector<std::valarray<T>> &A,\\n                                        const T &val) {\\n    std::vector<std::valarray<double>> B =\\n        A;               // New vector to store resultant vector\\n    for (auto &b : B) {  // For every row in vector\\n        b = b * val;     // Multiply row with scaler\\n    }\\n    return B;  // Return new resultant 2D vector\\n}\\n\\n/**\\n * Overloaded operator \\\"/\\\" to divide given 2D vector with scaler\\n * @tparam T typename of the vector and the scaler\\n * @param A 2D vector to which scaler will be divided\\n * @param val Scaler value which will be divided\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<std::valarray<T>> operator/(const std::vector<std::valarray<T>> &A,\\n                                        const T &val) {\\n    std::vector<std::valarray<double>> B =\\n        A;               // New vector to store resultant vector\\n    for (auto &b : B) {  // For every row in vector\\n        b = b / val;     // Divide row with scaler\\n    }\\n    return B;  // Return new resultant 2D vector\\n}\\n\\n/**\\n * Function to get transpose of 2D vector\\n * @tparam T typename of the vector\\n * @param A 2D vector which will be transposed\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<std::valarray<T>> transpose(\\n    const std::vector<std::valarray<T>> &A) {\\n    const auto shape = get_shape(A);  // Current shape of vector\\n    std::vector<std::valarray<T>> B;  // New vector to store result\\n    // Storing transpose values of A in B\\n    for (size_t j = 0; j < shape.second; j++) {\\n        std::valarray<T> row;\\n        row.resize(shape.first);\\n        for (size_t i = 0; i < shape.first; i++) {\\n            row[i] = A[i][j];\\n        }\\n        B.push_back(row);\\n    }\\n    return B;  // Return new resultant 2D vector\\n}\\n\\n/**\\n * Overloaded operator \\\"+\\\" to add two 2D vectors\\n * @tparam T typename of the vector\\n * @param A First 2D vector\\n * @param B Second 2D vector\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<std::valarray<T>> operator+(\\n    const std::vector<std::valarray<T>> &A,\\n    const std::vector<std::valarray<T>> &B) {\\n    const auto shape_a = get_shape(A);\\n    const auto shape_b = get_shape(B);\\n    // If vectors don't have equal shape\\n    if (shape_a.first != shape_b.first || shape_a.second != shape_b.second) {\\n        std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n        std::cerr << \\\"Supplied vectors have different shapes \\\";\\n        std::cerr << shape_a << \\\" and \\\" << shape_b << std::endl;\\n        std::exit(EXIT_FAILURE);\\n    }\\n    std::vector<std::valarray<T>> C;\\n    for (size_t i = 0; i < A.size(); i++) {  // For every row\\n        C.push_back(A[i] + B[i]);            // Elementwise addition\\n    }\\n    return C;  // Return new resultant 2D vector\\n}\\n\\n/**\\n * Overloaded operator \\\"-\\\" to add subtract 2D vectors\\n * @tparam T typename of the vector\\n * @param A First 2D vector\\n * @param B Second 2D vector\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<std::valarray<T>> operator-(\\n    const std::vector<std::valarray<T>> &A,\\n    const std::vector<std::valarray<T>> &B) {\\n    const auto shape_a = get_shape(A);\\n    const auto shape_b = get_shape(B);\\n    // If vectors don't have equal shape\\n    if (shape_a.first != shape_b.first || shape_a.second != shape_b.second) {\\n        std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n        std::cerr << \\\"Supplied vectors have different shapes \\\";\\n        std::cerr << shape_a << \\\" and \\\" << shape_b << std::endl;\\n        std::exit(EXIT_FAILURE);\\n    }\\n    std::vector<std::valarray<T>> C;         // Vector to store result\\n    for (size_t i = 0; i < A.size(); i++) {  // For every row\\n        C.push_back(A[i] - B[i]);            // Elementwise substraction\\n    }\\n    return C;  // Return new resultant 2D vector\\n}\\n\\n/**\\n * Function to multiply two 2D vectors\\n * @tparam T typename of the vector\\n * @param A First 2D vector\\n * @param B Second 2D vector\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<std::valarray<T>> multiply(const std::vector<std::valarray<T>> &A,\\n                                       const std::vector<std::valarray<T>> &B) {\\n    const auto shape_a = get_shape(A);\\n    const auto shape_b = get_shape(B);\\n    // If vectors are not eligible for multiplication\\n    if (shape_a.second != shape_b.first) {\\n        std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n        std::cerr << \\\"Vectors are not eligible for multiplication \\\";\\n        std::cerr << shape_a << \\\" and \\\" << shape_b << std::endl;\\n        std::exit(EXIT_FAILURE);\\n    }\\n    std::vector<std::valarray<T>> C;  // Vector to store result\\n    // Normal matrix multiplication\\n    for (size_t i = 0; i < shape_a.first; i++) {\\n        std::valarray<T> row;\\n        row.resize(shape_b.second);\\n        for (size_t j = 0; j < shape_b.second; j++) {\\n            for (size_t k = 0; k < shape_a.second; k++) {\\n                row[j] += A[i][k] * B[k][j];\\n            }\\n        }\\n        C.push_back(row);\\n    }\\n    return C;  // Return new resultant 2D vector\\n}\\n\\n/**\\n * Function to get hadamard product of two 2D vectors\\n * @tparam T typename of the vector\\n * @param A First 2D vector\\n * @param B Second 2D vector\\n * @return new resultant vector\\n */\\ntemplate <typename T>\\nstd::vector<std::valarray<T>> hadamard_product(\\n    const std::vector<std::valarray<T>> &A,\\n    const std::vector<std::valarray<T>> &B) {\\n    const auto shape_a = get_shape(A);\\n    const auto shape_b = get_shape(B);\\n    // If vectors are not eligible for hadamard product\\n    if (shape_a.first != shape_b.first || shape_a.second != shape_b.second) {\\n        std::cerr << \\\"ERROR (\\\" << __func__ << \\\") : \\\";\\n        std::cerr << \\\"Vectors have different shapes \\\";\\n        std::cerr << shape_a << \\\" and \\\" << shape_b << std::endl;\\n        std::exit(EXIT_FAILURE);\\n    }\\n    std::vector<std::valarray<T>> C;  // Vector to store result\\n    for (size_t i = 0; i < A.size(); i++) {\\n        C.push_back(A[i] * B[i]);  // Elementwise multiplication\\n    }\\n    return C;  // Return new resultant 2D vector\\n}\\n}  // namespace machine_learning\\n\\n#endif\\n\"",
    "area": "\"/**\\n * @file\\n * @brief Implementations for the [area](https://en.wikipedia.org/wiki/Area) of\\n * various shapes\\n * @details The area of a shape is the amount of 2D space it takes up.\\n * All shapes have a formula to get the area of any given shape.\\n * These implementations support multiple return types.\\n *\\n * @author [Focusucof](https://github.com/Focusucof)\\n */\\n#define _USE_MATH_DEFINES\\n#include <cassert>  /// for assert\\n#include <cmath>    /// for M_PI definition and pow()\\n#include <cmath>\\n#include <cstdint>   /// for uint16_t datatype\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @brief area of a [square](https://en.wikipedia.org/wiki/Square) (l * l)\\n * @param length is the length of the square\\n * @returns area of square\\n */\\ntemplate <typename T>\\nT square_area(T length) {\\n    return length * length;\\n}\\n\\n/**\\n * @brief area of a [rectangle](https://en.wikipedia.org/wiki/Rectangle) (l * w)\\n * @param length is the length of the rectangle\\n * @param width is the width of the rectangle\\n * @returns area of the rectangle\\n */\\ntemplate <typename T>\\nT rect_area(T length, T width) {\\n    return length * width;\\n}\\n\\n/**\\n * @brief area of a [triangle](https://en.wikipedia.org/wiki/Triangle) (b * h /\\n * 2)\\n * @param base is the length of the bottom side of the triangle\\n * @param height is the length of the tallest point in the triangle\\n * @returns area of the triangle\\n */\\ntemplate <typename T>\\nT triangle_area(T base, T height) {\\n    return base * height / 2;\\n}\\n\\n/**\\n * @brief area of a [circle](https://en.wikipedia.org/wiki/Area_of_a_circle) (pi\\n * * r^2)\\n * @param radius is the radius of the circle\\n * @returns area of the circle\\n */\\ntemplate <typename T>\\nT circle_area(T radius) {\\n    return M_PI * pow(radius, 2);\\n}\\n\\n/**\\n * @brief area of a [parallelogram](https://en.wikipedia.org/wiki/Parallelogram)\\n * (b * h)\\n * @param base is the length of the bottom side of the parallelogram\\n * @param height is the length of the tallest point in the parallelogram\\n * @returns area of the parallelogram\\n */\\ntemplate <typename T>\\nT parallelogram_area(T base, T height) {\\n    return base * height;\\n}\\n\\n/**\\n * @brief surface area of a [cube](https://en.wikipedia.org/wiki/Cube) ( 6 * (l\\n * * l))\\n * @param length is the length of the cube\\n * @returns surface area of the cube\\n */\\ntemplate <typename T>\\nT cube_surface_area(T length) {\\n    return 6 * length * length;\\n}\\n\\n/**\\n * @brief surface area of a [sphere](https://en.wikipedia.org/wiki/Sphere) ( 4 *\\n * pi * r^2)\\n * @param radius is the radius of the sphere\\n * @returns surface area of the sphere\\n */\\ntemplate <typename T>\\nT sphere_surface_area(T radius) {\\n    return 4 * M_PI * pow(radius, 2);\\n}\\n\\n/**\\n * @brief surface area of a [cylinder](https://en.wikipedia.org/wiki/Cylinder)\\n * (2 * pi * r * h + 2 * pi * r^2)\\n * @param radius is the radius of the cylinder\\n * @param height is the height of the cylinder\\n * @returns surface area of the cylinder\\n */\\ntemplate <typename T>\\nT cylinder_surface_area(T radius, T height) {\\n    return 2 * M_PI * radius * height + 2 * M_PI * pow(radius, 2);\\n}\\n}  // namespace math\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // I/O variables for testing\\n    uint16_t int_length = 0;    // 16 bit integer length input\\n    uint16_t int_width = 0;     // 16 bit integer width input\\n    uint16_t int_base = 0;      // 16 bit integer base input\\n    uint16_t int_height = 0;    // 16 bit integer height input\\n    uint16_t int_expected = 0;  // 16 bit integer expected output\\n    uint16_t int_area = 0;      // 16 bit integer output\\n\\n    float float_length = NAN;    // float length input\\n    float float_expected = NAN;  // float expected output\\n    float float_area = NAN;      // float output\\n\\n    double double_length = NAN;    // double length input\\n    double double_width = NAN;     // double width input\\n    double double_radius = NAN;    // double radius input\\n    double double_height = NAN;    // double height input\\n    double double_expected = NAN;  // double expected output\\n    double double_area = NAN;      // double output\\n\\n    // 1st test\\n    int_length = 5;\\n    int_expected = 25;\\n    int_area = math::square_area(int_length);\\n\\n    std::cout << \\\"AREA OF A SQUARE (int)\\\" << std::endl;\\n    std::cout << \\\"Input Length: \\\" << int_length << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << int_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << int_area << std::endl;\\n    assert(int_area == int_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 2nd test\\n    float_length = 2.5;\\n    float_expected = 6.25;\\n    float_area = math::square_area(float_length);\\n\\n    std::cout << \\\"AREA OF A SQUARE (float)\\\" << std::endl;\\n    std::cout << \\\"Input Length: \\\" << float_length << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << float_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << float_area << std::endl;\\n    assert(float_area == float_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 3rd test\\n    int_length = 4;\\n    int_width = 7;\\n    int_expected = 28;\\n    int_area = math::rect_area(int_length, int_width);\\n\\n    std::cout << \\\"AREA OF A RECTANGLE (int)\\\" << std::endl;\\n    std::cout << \\\"Input Length: \\\" << int_length << std::endl;\\n    std::cout << \\\"Input Width: \\\" << int_width << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << int_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << int_area << std::endl;\\n    assert(int_area == int_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 4th test\\n    double_length = 2.5;\\n    double_width = 5.7;\\n    double_expected = 14.25;\\n    double_area = math::rect_area(double_length, double_width);\\n\\n    std::cout << \\\"AREA OF A RECTANGLE (double)\\\" << std::endl;\\n    std::cout << \\\"Input Length: \\\" << double_length << std::endl;\\n    std::cout << \\\"Input Width: \\\" << double_width << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << double_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << double_area << std::endl;\\n    assert(double_area == double_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 5th test\\n    int_base = 10;\\n    int_height = 3;\\n    int_expected = 15;\\n    int_area = math::triangle_area(int_base, int_height);\\n\\n    std::cout << \\\"AREA OF A TRIANGLE\\\" << std::endl;\\n    std::cout << \\\"Input Base: \\\" << int_base << std::endl;\\n    std::cout << \\\"Input Height: \\\" << int_height << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << int_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << int_area << std::endl;\\n    assert(int_area == int_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 6th test\\n    double_radius = 6;\\n    double_expected =\\n        113.09733552923255;  // rounded down because the double datatype\\n                             // truncates after 14 decimal places\\n    double_area = math::circle_area(double_radius);\\n\\n    std::cout << \\\"AREA OF A CIRCLE\\\" << std::endl;\\n    std::cout << \\\"Input Radius: \\\" << double_radius << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << double_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << double_area << std::endl;\\n    assert(double_area == double_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 7th test\\n    int_base = 6;\\n    int_height = 7;\\n    int_expected = 42;\\n    int_area = math::parallelogram_area(int_base, int_height);\\n\\n    std::cout << \\\"AREA OF A PARALLELOGRAM\\\" << std::endl;\\n    std::cout << \\\"Input Base: \\\" << int_base << std::endl;\\n    std::cout << \\\"Input Height: \\\" << int_height << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << int_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << int_area << std::endl;\\n    assert(int_area == int_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 8th test\\n    double_length = 5.5;\\n    double_expected = 181.5;\\n    double_area = math::cube_surface_area(double_length);\\n\\n    std::cout << \\\"SURFACE AREA OF A CUBE\\\" << std::endl;\\n    std::cout << \\\"Input Length: \\\" << double_length << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << double_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << double_area << std::endl;\\n    assert(double_area == double_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 9th test\\n    double_radius = 10.0;\\n    double_expected = 1256.6370614359172;  // rounded down because the whole\\n                                           // value gets truncated\\n    double_area = math::sphere_surface_area(double_radius);\\n\\n    std::cout << \\\"SURFACE AREA OF A SPHERE\\\" << std::endl;\\n    std::cout << \\\"Input Radius: \\\" << double_radius << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << double_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << double_area << std::endl;\\n    assert(double_area == double_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 10th test\\n    double_radius = 4.0;\\n    double_height = 7.0;\\n    double_expected = 276.46015351590177;\\n    double_area = math::cylinder_surface_area(double_radius, double_height);\\n\\n    std::cout << \\\"SURFACE AREA OF A CYLINDER\\\" << std::endl;\\n    std::cout << \\\"Input Radius: \\\" << double_radius << std::endl;\\n    std::cout << \\\"Input Height: \\\" << double_height << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << double_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << double_area << std::endl;\\n    assert(double_area == double_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "binary exponent": "\"/**\\n * @file\\n * @brief C++ Program to find Binary Exponent Iteratively and Recursively.\\n *\\n * Calculate \\\\f$a^b\\\\f$ in \\\\f$O(\\\\log(b))\\\\f$ by converting \\\\f$b\\\\f$ to a\\n * binary number. Binary exponentiation is also known as exponentiation by\\n * squaring.\\n * @note This is a far better approach compared to naive method which\\n * provide \\\\f$O(b)\\\\f$ operations.\\n *\\n * Example:\\n * </br>10 in base 2 is 1010.\\n * \\\\f{eqnarray*}{\\n * 2^{10_d} &=& 2^{1010_b} = 2^8 * 2^2\\\\\\\\\\n * 2^1 &=& 2\\\\\\\\\\n * 2^2 &=& (2^1)^2 = 2^2 = 4\\\\\\\\\\n * 2^4 &=& (2^2)^2 = 4^2 = 16\\\\\\\\\\n * 2^8 &=& (2^4)^2 = 16^2 = 256\\\\\\\\\\n * \\\\f}\\n * Hence to calculate 2^10 we only need to multiply \\\\f$2^8\\\\f$ and \\\\f$2^2\\\\f$\\n * skipping \\\\f$2^1\\\\f$ and \\\\f$2^4\\\\f$.\\n */\\n\\n#include <iostream>\\n\\n/// Recursive function to calculate exponent in \\\\f$O(\\\\log(n))\\\\f$ using binary\\n/// exponent.\\nint binExpo(int a, int b) {\\n    if (b == 0) {\\n        return 1;\\n    }\\n    int res = binExpo(a, b / 2);\\n    if (b % 2) {\\n        return res * res * a;\\n    } else {\\n        return res * res;\\n    }\\n}\\n\\n/// Iterative function to calculate exponent in \\\\f$O(\\\\log(n))\\\\f$ using binary\\n/// exponent.\\nint binExpo_alt(int a, int b) {\\n    int res = 1;\\n    while (b > 0) {\\n        if (b % 2) {\\n            res = res * a;\\n        }\\n        a = a * a;\\n        b /= 2;\\n    }\\n    return res;\\n}\\n\\n/// Main function\\nint main() {\\n    int a, b;\\n    /// Give two numbers a, b\\n    std::cin >> a >> b;\\n    if (a == 0 && b == 0) {\\n        std::cout << \\\"Math error\\\" << std::endl;\\n    } else if (b < 0) {\\n        std::cout << \\\"Exponent must be positive !!\\\" << std::endl;\\n    } else {\\n        int resRecurse = binExpo(a, b);\\n        /// int resIterate = binExpo_alt(a, b);\\n\\n        /// Result of a^b (where '^' denotes exponentiation)\\n        std::cout << resRecurse << std::endl;\\n        /// std::cout << resIterate << std::endl;\\n    }\\n}\\n\"",
    "binomial calculate": "\"/**\\n * @file\\n * @brief Program to calculate [Binomial\\n * coefficients](https://en.wikipedia.org/wiki/Binomial_coefficient)\\n *\\n * @author [astronmax](https://github.com/astronmax)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <cstdint>   /// for int32_t type\\n#include <cstdlib>   /// for atoi\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @namespace binomial\\n * @brief Functions for [Binomial\\n * coefficients](https://en.wikipedia.org/wiki/Binomial_coefficient)\\n * implementation\\n */\\nnamespace binomial {\\n/**\\n * @brief Function to calculate binomial coefficients\\n * @param n first value\\n * @param k second value\\n * @return binomial coefficient for n and k\\n */\\nsize_t calculate(int32_t n, int32_t k) {\\n    // basic cases\\n    if (k > (n / 2))\\n        k = n - k;\\n    if (k == 1)\\n        return n;\\n    if (k == 0)\\n        return 1;\\n\\n    size_t result = 1;\\n    for (int32_t i = 1; i <= k; ++i) {\\n        result *= n - k + i;\\n        result /= i;\\n    }\\n\\n    return result;\\n}\\n}  // namespace binomial\\n}  // namespace math\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void tests() {\\n    // tests for calculate function\\n    assert(math::binomial::calculate(1, 1) == 1);\\n    assert(math::binomial::calculate(57, 57) == 1);\\n    assert(math::binomial::calculate(6, 3) == 20);\\n    assert(math::binomial::calculate(10, 5) == 252);\\n    assert(math::binomial::calculate(20, 10) == 184756);\\n    assert(math::binomial::calculate(30, 15) == 155117520);\\n    assert(math::binomial::calculate(40, 20) == 137846528820);\\n    assert(math::binomial::calculate(50, 25) == 126410606437752);\\n    assert(math::binomial::calculate(60, 30) == 118264581564861424);\\n    assert(math::binomial::calculate(62, 31) == 465428353255261088);\\n\\n    std::cout << \\\"[+] Binomial coefficients calculate test completed\\\"\\n              << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count\\n * @param argv commandline array of arguments\\n * @returns 0 on exit\\n */\\nint main(int argc, const char* argv[]) {\\n    tests();  // run self-test implementations\\n\\n    if (argc < 3) {\\n        std::cout << \\\"Usage ./binomial_calculate {n} {k}\\\" << std::endl;\\n        return 0;\\n    }\\n\\n    int32_t n = atoi(argv[1]);\\n    int32_t k = atoi(argv[2]);\\n\\n    std::cout << math::binomial::calculate(n, k) << std::endl;\\n    return 0;\\n}\\n\"",
    "check amicable pair": "\"/**\\n *\\n * @file\\n * \\\\brief A C++ Program to check whether a pair of number is [amicable\\n * pair](https://en.wikipedia.org/wiki/Amicable_numbers) or not.\\n *\\n * \\\\details\\n * Amicable Pair are two positive integers such that sum of the proper divisor\\n * of each number is equal to the other number.\\n * @author iamnambiar\\n */\\n#include <cassert>\\n#include <iostream>\\n\\n/**\\n * Function to calculate the sum of all the proper divisor\\n * of an integer.\\n * @param num First number.\\n * @return Sum of the proper divisor of the number.\\n */\\nint sum_of_divisor(int num) {\\n    // Variable to store the sum of all proper divisors.\\n    int sum = 0;\\n    // Below loop condition helps to reduce Time complexity by a factor of\\n    // square root of the number.\\n    for (int div = 2; div * div <= num; ++div) {\\n        // Check 'div' is divisor of 'num'.\\n        if (num % div == 0) {\\n            // If both divisor are same, add once to 'sum'\\n            if (div == (num / div)) {\\n                sum += div;\\n            } else {\\n                // If both divisor are not the same, add both to 'sum'.\\n                sum += (div + (num / div));\\n            }\\n        }\\n    }\\n    return sum + 1;\\n}\\n\\n/**\\n * Function to check whether the pair is amicable or not.\\n * @param x First number.\\n * @param y Second number.\\n * @return `true` if the pair is amicable\\n * @return `false` if the pair is not amicable\\n */\\nbool are_amicable(int x, int y) {\\n    return (sum_of_divisor(x) == y) && (sum_of_divisor(y) == x);\\n}\\n\\n/**\\n * Function for testing the is_amicable() with\\n * all the test cases.\\n */\\nvoid test() {\\n    // are_amicable(220, 284) returns true.\\n    assert(are_amicable(220, 284) == true);\\n    // are_amicable(6232, 6368) returns true.\\n    assert(are_amicable(6368, 6232) == true);\\n    // are_amicable(458, 232) returns false.\\n    assert(are_amicable(458, 232) == false);\\n}\\n\\n/**\\n * Main Function\\n */\\nint main() {\\n    test();\\n    std::cout << \\\"Assertion Success.\\\" << std::endl;\\n    return 0;\\n}\\n\"",
    "check factorial": "\"/**\\n * @file\\n * @brief A simple program to check if the given number is a factorial of some\\n * number or not.\\n * @author [Divyajyoti Ukirde](https://github.com/divyajyotiuk)\\n */\\n#include <cassert>\\n#include <iostream>\\n\\n/**\\n * Function to check if the given number is factorial of some number or not.\\n * @param n number to be checked.\\n * @return if number is a factorial, returns true, else false.\\n */\\n\\nbool is_factorial(uint64_t n) {\\n    if (n <= 0) {\\n        return false;\\n    }\\n    for (uint32_t i = 1;; i++) {\\n        if (n % i != 0) {\\n            break;\\n        }\\n        n = n / i;\\n    }\\n    if (n == 1) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\n/** Test function\\n * @returns void\\n */\\nvoid tests() {\\n    std::cout << \\\"Test 1:\\\\t n=50\\\\n\\\";\\n    assert(is_factorial(50) == false);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Test 2:\\\\t n=720\\\\n\\\";\\n    assert(is_factorial(720) == true);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Test 3:\\\\t n=0\\\\n\\\";\\n    assert(is_factorial(0) == false);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Test 4:\\\\t n=479001600\\\\n\\\";\\n    assert(is_factorial(479001600) == true);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Test 5:\\\\t n=-24\\\\n\\\";\\n    assert(is_factorial(-24) == false);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/** Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    tests();\\n    return 0;\\n}\\n\"",
    "check prime": "\"/**\\n * Copyright 2020 @author omkarlanghe\\n *\\n * @file\\n * A simple program to check if the given number if prime or not.\\n *\\n * @brief\\n * Reduced all possibilities of a number which cannot be prime.\\n * Eg: No even number, except 2 can be a prime number, hence we will increment\\n * our loop with i+6 jumping and check for i or i+2 to be a factor of the\\n * number; if it's a factor then we will return false otherwise true after the\\n * loop terminates at the terminating condition which is (i*i<=num)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * Function to check if the given number is prime or not.\\n * @param num number to be checked.\\n * @return if number is prime, it returns @ true, else it returns @ false.\\n */\\ntemplate <typename T>\\nbool is_prime(T num) {\\n    bool result = true;\\n    if (num <= 1) {\\n        return false;\\n    } else if (num == 2 || num == 3) {\\n        return true;\\n    } else if ((num % 2) == 0 || num % 3 == 0) {\\n        return false;\\n    } else {\\n        for (T i = 5; (i * i) <= (num); i = (i + 6)) {\\n            if ((num % i) == 0 || (num % (i + 2) == 0)) {\\n                result = false;\\n                break;\\n            }\\n        }\\n    }\\n    return (result);\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    // perform self-test\\n    assert(is_prime(50) == false);\\n    assert(is_prime(115249) == true);\\n\\n    int num = 0;\\n    std::cout << \\\"Enter the number to check if it is prime or not\\\" << std::endl;\\n    std::cin >> num;\\n    bool result = is_prime(num);\\n    if (result) {\\n        std::cout << num << \\\" is a prime number\\\" << std::endl;\\n    } else {\\n        std::cout << num << \\\" is not a prime number\\\" << std::endl;\\n    }\\n\\n    return 0;\\n}\\n\"",
    "complex numbers": "\"/**\\n * @author tjgurwara99\\n * @file\\n *\\n * \\\\brief An implementation of Complex Number as Objects\\n * \\\\details A basic implementation of Complex Number field as a class with\\n * operators overloaded to accommodate (mathematical) field operations.\\n */\\n\\n#include <cassert>\\n#include <cmath>\\n#include <complex>\\n#include <ctime>\\n#include <iostream>\\n#include <stdexcept>\\n\\n/**\\n * \\\\brief Class Complex to represent complex numbers as a field.\\n */\\nclass Complex {\\n    // The real value of the complex number\\n    double re;\\n    // The imaginary value of the complex number\\n    double im;\\n\\n public:\\n    /**\\n     * \\\\brief Complex Constructor which initialises our complex number.\\n     * \\\\details\\n     * Complex Constructor which initialises the complex number which takes\\n     * three arguments.\\n     * @param x If the third parameter is 'true' then this x is the absolute\\n     * value of the complex number, if the third parameter is 'false' then this\\n     * x is the real value of the complex number (optional).\\n     * @param y If the third parameter is 'true' then this y is the argument of\\n     * the complex number, if the third parameter is 'false' then this y is the\\n     * imaginary value of the complex number (optional).\\n     * @param is_polar 'false' by default. If we want to initialise our complex\\n     * number using polar form then set this to true, otherwise set it to false\\n     * to use initialiser which initialises real and imaginary values using the\\n     * first two parameters (optional).\\n     */\\n    explicit Complex(double x = 0.f, double y = 0.f, bool is_polar = false) {\\n        if (!is_polar) {\\n            re = x;\\n            im = y;\\n            return;\\n        }\\n\\n        re = x * std::cos(y);\\n        im = x * std::sin(y);\\n    }\\n\\n    /**\\n     * \\\\brief Copy Constructor\\n     * @param other The other number to equate our number to.\\n     */\\n    Complex(const Complex &other) : re(other.real()), im(other.imag()) {}\\n\\n    /**\\n     * \\\\brief Member function to get real value of our complex number.\\n     * Member function (getter) to access the class' re value.\\n     */\\n    double real() const { return this->re; }\\n\\n    /**\\n     * \\\\brief Member function to get imaginary value of our complex number.\\n     * Member function (getter) to access the class' im value.\\n     */\\n    double imag() const { return this->im; }\\n\\n    /**\\n     * \\\\brief Member function to give the modulus of our complex number.\\n     * Member function to which gives the absolute value (modulus) of our\\n     * complex number\\n     * @return \\\\f$ \\\\sqrt{z \\\\bar{z}} \\\\f$ where \\\\f$ z \\\\f$ is our complex\\n     * number.\\n     */\\n    double abs() const {\\n        return std::sqrt(this->re * this->re + this->im * this->im);\\n    }\\n\\n    /**\\n     * \\\\brief Member function to give the argument of our complex number.\\n     * @return Argument of our Complex number in radians.\\n     */\\n    double arg() const { return std::atan2(this->im, this->re); }\\n\\n    /**\\n     * \\\\brief Operator overload of '+' on Complex class.\\n     * Operator overload to be able to add two complex numbers.\\n     * @param other The other number that is added to the current number.\\n     * @return result current number plus other number\\n     */\\n    Complex operator+(const Complex &other) {\\n        Complex result(this->re + other.re, this->im + other.im);\\n        return result;\\n    }\\n\\n    /**\\n     * \\\\brief Operator overload of '-' on Complex class.\\n     * Operator overload to be able to subtract two complex numbers.\\n     * @param other The other number being subtracted from the current number.\\n     * @return result current number subtract other number\\n     */\\n    Complex operator-(const Complex &other) {\\n        Complex result(this->re - other.re, this->im - other.im);\\n        return result;\\n    }\\n\\n    /**\\n     * \\\\brief Operator overload of '*' on Complex class.\\n     * Operator overload to be able to multiple two complex numbers.\\n     * @param other The other number to multiply the current number to.\\n     * @return result current number times other number.\\n     */\\n    Complex operator*(const Complex &other) {\\n        Complex result(this->re * other.re - this->im * other.im,\\n                       this->re * other.im + this->im * other.re);\\n        return result;\\n    }\\n\\n    /**\\n     * \\\\brief Operator overload of '~' on Complex class.\\n     * Operator overload of the BITWISE NOT which gives us the conjugate of our\\n     * complex number. NOTE: This is overloading the BITWISE operator but its\\n     * not a BITWISE operation in this definition.\\n     * @return result The conjugate of our complex number.\\n     */\\n    Complex operator~() const {\\n        Complex result(this->re, -(this->im));\\n        return result;\\n    }\\n\\n    /**\\n     * \\\\brief Operator overload of '/' on Complex class.\\n     * Operator overload to be able to divide two complex numbers. This function\\n     * would throw an exception if the other number is zero.\\n     * @param other The other number we divide our number by.\\n     * @return result Current number divided by other number.\\n     */\\n    Complex operator/(const Complex &other) {\\n        Complex result = *this * ~other;\\n        double denominator =\\n            other.real() * other.real() + other.imag() * other.imag();\\n        if (denominator != 0) {\\n            result = Complex(result.real() / denominator,\\n                             result.imag() / denominator);\\n            return result;\\n        } else {\\n            throw std::invalid_argument(\\\"Undefined Value\\\");\\n        }\\n    }\\n\\n    /**\\n     * \\\\brief Operator overload of '=' on Complex class.\\n     * Operator overload to be able to copy RHS instance of Complex to LHS\\n     * instance of Complex\\n     */\\n    const Complex &operator=(const Complex &other) {\\n        this->re = other.real();\\n        this->im = other.imag();\\n        return *this;\\n    }\\n};\\n\\n/**\\n * \\\\brief Operator overload of '==' on Complex class.\\n * Logical Equal overload for our Complex class.\\n * @param a Left hand side of our expression\\n * @param b Right hand side of our expression\\n * @return 'True' If real and imaginary parts of a and b are same\\n * @return 'False' Otherwise.\\n */\\nbool operator==(const Complex &a, const Complex &b) {\\n    return a.real() == b.real() && a.imag() == b.imag();\\n}\\n\\n/**\\n * \\\\brief Operator overload of '<<' of ostream for Complex class.\\n * Overloaded insersion operator to accommodate the printing of our complex\\n * number in their standard form.\\n * @param os The console stream\\n * @param num The complex number.\\n */\\nstd::ostream &operator<<(std::ostream &os, const Complex &num) {\\n    os << \\\"(\\\" << num.real();\\n    if (num.imag() < 0) {\\n        os << \\\" - \\\" << -num.imag();\\n    } else {\\n        os << \\\" + \\\" << num.imag();\\n    }\\n    os << \\\"i)\\\";\\n    return os;\\n}\\n\\n/**\\n * \\\\brief Function to get random numbers to generate our complex numbers for\\n * test\\n */\\ndouble get_rand() { return (std::rand() % 100 - 50) / 100.f; }\\n\\n/**\\n * Tests Function\\n */\\nvoid tests() {\\n    std::srand(std::time(nullptr));\\n    double x1 = get_rand(), y1 = get_rand(), x2 = get_rand(), y2 = get_rand();\\n    Complex num1(x1, y1), num2(x2, y2);\\n    std::complex<double> cnum1(x1, y1), cnum2(x2, y2);\\n    Complex result;\\n    std::complex<double> expected;\\n    // Test for addition\\n    result = num1 + num2;\\n    expected = cnum1 + cnum2;\\n    assert(((void)\\\"1 + 1i + 1 + 1i is equal to 2 + 2i but the addition doesn't \\\"\\n                  \\\"add up \\\\n\\\",\\n            (result.real() == expected.real() &&\\n             result.imag() == expected.imag())));\\n    std::cout << \\\"First test passes.\\\" << std::endl;\\n    // Test for subtraction\\n    result = num1 - num2;\\n    expected = cnum1 - cnum2;\\n    assert(((void)\\\"1 + 1i - 1 - 1i is equal to 0 but the program says \\\"\\n                  \\\"otherwise. \\\\n\\\",\\n            (result.real() == expected.real() &&\\n             result.imag() == expected.imag())));\\n    std::cout << \\\"Second test passes.\\\" << std::endl;\\n    // Test for multiplication\\n    result = num1 * num2;\\n    expected = cnum1 * cnum2;\\n    assert(((void)\\\"(1 + 1i) * (1 + 1i) is equal to 2i but the program says \\\"\\n                  \\\"otherwise. \\\\n\\\",\\n            (result.real() == expected.real() &&\\n             result.imag() == expected.imag())));\\n    std::cout << \\\"Third test passes.\\\" << std::endl;\\n    // Test for division\\n    result = num1 / num2;\\n    expected = cnum1 / cnum2;\\n    assert(((void)\\\"(1 + 1i) / (1 + 1i) is equal to 1 but the program says \\\"\\n                  \\\"otherwise.\\\\n\\\",\\n            (result.real() == expected.real() &&\\n             result.imag() == expected.imag())));\\n    std::cout << \\\"Fourth test passes.\\\" << std::endl;\\n    // Test for conjugates\\n    result = ~num1;\\n    expected = std::conj(cnum1);\\n    assert(((void)\\\"(1 + 1i) has a conjugate which is equal to (1 - 1i) but the \\\"\\n                  \\\"program says otherwise.\\\\n\\\",\\n            (result.real() == expected.real() &&\\n             result.imag() == expected.imag())));\\n    std::cout << \\\"Fifth test passes.\\\\n\\\";\\n    // Test for Argument of our complex number\\n    assert(((void)\\\"(1 + 1i) has argument PI / 4 but the program differs from \\\"\\n                  \\\"the std::complex result.\\\\n\\\",\\n            (num1.arg() == std::arg(cnum1))));\\n    std::cout << \\\"Sixth test passes.\\\\n\\\";\\n    // Test for absolute value of our complex number\\n    assert(((void)\\\"(1 + 1i) has absolute value sqrt(2) but the program differs \\\"\\n                  \\\"from the std::complex result. \\\\n\\\",\\n            (num1.abs() == std::abs(cnum1))));\\n    std::cout << \\\"Seventh test passes.\\\\n\\\";\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    tests();\\n    return 0;\\n}\\n\"",
    "double factorial": "\"/**\\n * @file\\n * @brief Compute [double\\n * factorial](https://en.wikipedia.org/wiki/Double_factorial): \\\\f$n!!\\\\f$\\n *\\n * Double factorial of a non-negative integer `n`, is defined as the product of\\n * all the integers from 1 to n that have the same parity (odd or even) as n.\\n * <br/>It is also called as semifactorial of a number and is denoted by\\n * \\\\f$n!!\\\\f$\\n */\\n\\n#include <cassert>\\n#include <iostream>\\n\\n/** Compute double factorial using iterative method\\n */\\nuint64_t double_factorial_iterative(uint64_t n) {\\n    uint64_t res = 1;\\n    for (uint64_t i = n;; i -= 2) {\\n        if (i == 0 || i == 1)\\n            return res;\\n        res *= i;\\n    }\\n    return res;\\n}\\n\\n/** Compute double factorial using resursive method.\\n * <br/>Recursion can be costly for large numbers.\\n */\\nuint64_t double_factorial_recursive(uint64_t n) {\\n    if (n <= 1)\\n        return 1;\\n    return n * double_factorial_recursive(n - 2);\\n}\\n\\n/** Wrapper to run tests using both recursive and iterative implementations.\\n * The checks are only valid in debug builds due to the use of `assert()`\\n * statements.\\n * \\\\param [in] n number to check double factorial for\\n * \\\\param [in] expected expected result\\n */\\nvoid test(uint64_t n, uint64_t expected) {\\n    assert(double_factorial_iterative(n) == expected);\\n    assert(double_factorial_recursive(n) == expected);\\n}\\n\\n/**\\n * Test implementations\\n */\\nvoid tests() {\\n    std::cout << \\\"Test 1:\\\\t n=5\\\\t...\\\";\\n    test(5, 15);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Test 2:\\\\t n=15\\\\t...\\\";\\n    test(15, 2027025);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Test 3:\\\\t n=0\\\\t...\\\";\\n    test(0, 1);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    tests();\\n    return 0;\\n}\\n\"",
    "eulers totient function": "\"/**\\n * @file\\n * @brief C++ Program to find\\n * [Euler's Totient](https://en.wikipedia.org/wiki/Euler%27s_totient_function)\\n * function\\n *\\n * Euler Totient Function is also known as phi function.\\n * \\\\f[\\\\phi(n) =\\n * \\\\phi\\\\left({p_1}^{a_1}\\\\right)\\\\cdot\\\\phi\\\\left({p_2}^{a_2}\\\\right)\\\\ldots\\\\f] where\\n * \\\\f$p_1\\\\f$, \\\\f$p_2\\\\f$, \\\\f$\\\\ldots\\\\f$ are prime factors of n.\\n * <br/>3 Euler's properties:\\n * 1. \\\\f$\\\\phi(n) = n-1\\\\f$\\n * 2. \\\\f$\\\\phi(n^k) = n^k - n^{k-1}\\\\f$\\n * 3. \\\\f$\\\\phi(a,b) = \\\\phi(a)\\\\cdot\\\\phi(b)\\\\f$ where a and b are relative primes.\\n *\\n * Applying this 3 properties on the first equation.\\n * \\\\f[\\\\phi(n) =\\n * n\\\\cdot\\\\left(1-\\\\frac{1}{p_1}\\\\right)\\\\cdot\\\\left(1-\\\\frac{1}{p_2}\\\\right)\\\\cdots\\\\f]\\n * where \\\\f$p_1\\\\f$,\\\\f$p_2\\\\f$... are prime factors.\\n * Hence Implementation in \\\\f$O\\\\left(\\\\sqrt{n}\\\\right)\\\\f$.\\n * <br/>Some known values are:\\n * * \\\\f$\\\\phi(100) = 40\\\\f$\\n * * \\\\f$\\\\phi(1) = 1\\\\f$\\n * * \\\\f$\\\\phi(17501) = 15120\\\\f$\\n * * \\\\f$\\\\phi(1420) = 560\\\\f$\\n */\\n#include <cstdlib>\\n#include <iostream>\\n\\n/** Function to caculate Euler's totient phi\\n */\\nuint64_t phiFunction(uint64_t n) {\\n    uint64_t result = n;\\n    for (uint64_t i = 2; i * i <= n; i++) {\\n        if (n % i == 0) {\\n            while (n % i == 0) {\\n                n /= i;\\n            }\\n            result -= result / i;\\n        }\\n    }\\n    if (n > 1)\\n        result -= result / n;\\n    return result;\\n}\\n\\n/// Main function\\nint main(int argc, char *argv[]) {\\n    uint64_t n;\\n    if (argc < 2) {\\n        std::cout << \\\"Enter the number: \\\";\\n    } else {\\n        n = strtoull(argv[1], nullptr, 10);\\n    }\\n    std::cin >> n;\\n    std::cout << phiFunction(n);\\n    return 0;\\n}\\n\"",
    "extended euclid algorithm": "\"/**\\n * @file\\n * @brief GCD using [extended Euclid's algorithm]\\n * (https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)\\n *\\n * Finding coefficients of a and b ie x and y in  Bézout's identity\\n * \\\\f[\\\\text{gcd}(a, b) = a \\\\times x + b \\\\times y \\\\f]\\n * This is also used in finding Modular\\n * multiplicative inverse of a number. (A * B)%M == 1 Here B is the MMI of A for\\n * given M, so extendedEuclid (A, M) gives B.\\n */\\n#include <algorithm>  // for swap function\\n#include <iostream>\\n\\n/**\\n * function to update the coefficients per iteration\\n * \\\\f[r_0,\\\\,r = r,\\\\, r_0 - \\\\text{quotient}\\\\times r\\\\f]\\n *\\n * @param[in,out] r signed or unsigned\\n * @param[in,out] r0 signed or unsigned\\n * @param[in] quotient  unsigned\\n */\\ntemplate <typename T, typename T2>\\ninline void update_step(T *r, T *r0, const T2 quotient) {\\n    T temp = *r;\\n    *r = *r0 - (quotient * temp);\\n    *r0 = temp;\\n}\\n\\n/**\\n * Implementation using iterative algorithm from\\n * [Wikipedia](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode)\\n *\\n * @param[in] A unsigned\\n * @param[in] B unsigned\\n * @param[out] GCD unsigned\\n * @param[out] x signed\\n * @param[out] y signed\\n */\\ntemplate <typename T1, typename T2>\\nvoid extendedEuclid_1(T1 A, T1 B, T1 *GCD, T2 *x, T2 *y) {\\n    if (B > A)\\n        std::swap(A, B);  // Ensure that A >= B\\n\\n    T2 s = 0, s0 = 1;\\n    T2 t = 1, t0 = 0;\\n    T1 r = B, r0 = A;\\n\\n    while (r != 0) {\\n        T1 quotient = r0 / r;\\n        update_step(&r, &r0, quotient);\\n        update_step(&s, &s0, quotient);\\n        update_step(&t, &t0, quotient);\\n    }\\n    *GCD = r0;\\n    *x = s0;\\n    *y = t0;\\n}\\n\\n/**\\n * Implementation using recursive algorithm\\n *\\n * @param[in] A unsigned\\n * @param[in] B unsigned\\n * @param[out] GCD unsigned\\n * @param[in,out] x signed\\n * @param[in,out] y signed\\n */\\ntemplate <typename T, typename T2>\\nvoid extendedEuclid(T A, T B, T *GCD, T2 *x, T2 *y) {\\n    if (B > A)\\n        std::swap(A, B);  // Ensure that A >= B\\n\\n    if (B == 0) {\\n        *GCD = A;\\n        *x = 1;\\n        *y = 0;\\n    } else {\\n        extendedEuclid(B, A % B, GCD, x, y);\\n        T2 temp = *x;\\n        *x = *y;\\n        *y = temp - (A / B) * (*y);\\n    }\\n}\\n\\n/// Main function\\nint main() {\\n    uint32_t a, b, gcd;\\n    int32_t x, y;\\n    std::cin >> a >> b;\\n    extendedEuclid(a, b, &gcd, &x, &y);\\n    std::cout << gcd << \\\" \\\" << x << \\\" \\\" << y << std::endl;\\n    extendedEuclid_1(a, b, &gcd, &x, &y);\\n    std::cout << gcd << \\\" \\\" << x << \\\" \\\" << y << std::endl;\\n    return 0;\\n}\\n\"",
    "factorial": "\"/**\\n * @file\\n * @brief C++ program to find factorial of given number\\n */\\n#include <iostream>\\n\\n/** function to find factorial of given number */\\nunsigned int factorial(unsigned int n) {\\n    if (n == 0)\\n        return 1;\\n    return n * factorial(n - 1);\\n}\\n\\n/** Main function */\\nint main() {\\n    int num = 5;\\n    std::cout << \\\"Factorial of \\\" << num << \\\" is \\\" << factorial(num)\\n              << std::endl;\\n    return 0;\\n}\\n\"",
    "fast power": "\"/**\\n * @file\\n * @brief Faster computation for \\\\f$a^b\\\\f$\\n *\\n * Program that computes \\\\f$a^b\\\\f$ in \\\\f$O(logN)\\\\f$ time.\\n * It is based on formula that:\\n * 1. if \\\\f$b\\\\f$ is even:\\n *  \\\\f$a^b = a^\\\\frac{b}{2} \\\\cdot a^\\\\frac{b}{2} = {a^\\\\frac{b}{2}}^2\\\\f$\\n * 2. if \\\\f$b\\\\f$ is odd: \\\\f$a^b = a^\\\\frac{b-1}{2}\\n *  \\\\cdot a^\\\\frac{b-1}{2} \\\\cdot a = {a^\\\\frac{b-1}{2}}^2 \\\\cdot a\\\\f$\\n *\\n * We can compute \\\\f$a^b\\\\f$ recursively using above algorithm.\\n */\\n\\n#include <cassert>\\n#include <cmath>\\n#include <cstdint>\\n#include <cstdlib>\\n#include <ctime>\\n#include <iostream>\\n\\n/**\\n * algorithm implementation for \\\\f$a^b\\\\f$\\n */\\ntemplate <typename T>\\ndouble fast_power_recursive(T a, T b) {\\n    // negative power. a^b = 1 / (a^-b)\\n    if (b < 0)\\n        return 1.0 / fast_power_recursive(a, -b);\\n\\n    if (b == 0)\\n        return 1;\\n    T bottom = fast_power_recursive(a, b >> 1);\\n    // Since it is integer division b/2 = (b-1)/2 where b is odd.\\n    // Therefore, case2 is easily solved by integer division.\\n\\n    double result;\\n    if ((b & 1) == 0)  // case1\\n        result = bottom * bottom;\\n    else  // case2\\n        result = bottom * bottom * a;\\n    return result;\\n}\\n\\n/**\\n    Same algorithm with little different formula.\\n    It still calculates in \\\\f$O(\\\\log N)\\\\f$\\n*/\\ntemplate <typename T>\\ndouble fast_power_linear(T a, T b) {\\n    // negative power. a^b = 1 / (a^-b)\\n    if (b < 0)\\n        return 1.0 / fast_power_linear(a, -b);\\n\\n    double result = 1;\\n    while (b) {\\n        if (b & 1)\\n            result = result * a;\\n        a = a * a;\\n        b = b >> 1;\\n    }\\n    return result;\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    std::srand(std::time(nullptr));\\n    std::ios_base::sync_with_stdio(false);\\n\\n    std::cout << \\\"Testing...\\\" << std::endl;\\n    for (int i = 0; i < 20; i++) {\\n        int a = std::rand() % 20 - 10;\\n        int b = std::rand() % 20 - 10;\\n        std::cout << std::endl << \\\"Calculating \\\" << a << \\\"^\\\" << b << std::endl;\\n        assert(fast_power_recursive(a, b) == std::pow(a, b));\\n        assert(fast_power_linear(a, b) == std::pow(a, b));\\n\\n        std::cout << \\\"------ \\\" << a << \\\"^\\\" << b << \\\" = \\\"\\n                  << fast_power_recursive(a, b) << std::endl;\\n    }\\n\\n    int64_t a, b;\\n    std::cin >> a >> b;\\n\\n    std::cout << a << \\\"^\\\" << b << \\\" = \\\" << fast_power_recursive(a, b)\\n              << std::endl;\\n\\n    std::cout << a << \\\"^\\\" << b << \\\" = \\\" << fast_power_linear(a, b) << std::endl;\\n\\n    return 0;\\n}\\n\"",
    "fibonacci": "\"/**\\n * @file\\n * @brief Generate fibonacci sequence\\n *\\n * Calculate the the value on Fibonacci's sequence given an\\n * integer as input.\\n * \\\\f[\\\\text{fib}(n) = \\\\text{fib}(n-1) + \\\\text{fib}(n-2)\\\\f]\\n *\\n * @see fibonacci_large.cpp, fibonacci_fast.cpp, string_fibonacci.cpp\\n */\\n#include <cassert>\\n#include <iostream>\\n\\n/**\\n * Recursively compute sequences\\n * @param n input\\n * @returns n-th element of the Fbinacci's sequence\\n */\\nuint64_t fibonacci(uint64_t n) {\\n    /* If the input is 0 or 1 just return the same\\n       This will set the first 2 values of the sequence */\\n    if (n <= 1) {\\n        return n;\\n    }\\n\\n    /* Add the last 2 values of the sequence to get next */\\n    return fibonacci(n - 1) + fibonacci(n - 2);\\n}\\n\\n/**\\n * Function for testing the fibonacci() function with a few\\n * test cases and assert statement.\\n * @returns `void`\\n*/\\nstatic void test() {\\n    uint64_t test_case_1 = fibonacci(0);\\n    assert(test_case_1 == 0);\\n    std::cout << \\\"Passed Test 1!\\\" << std::endl;\\n\\n    uint64_t test_case_2 = fibonacci(1);\\n    assert(test_case_2 == 1);\\n    std::cout << \\\"Passed Test 2!\\\" << std::endl;\\n\\n    uint64_t test_case_3 = fibonacci(2);\\n    assert(test_case_3 == 1);\\n    std::cout << \\\"Passed Test 3!\\\" << std::endl;\\n\\n    uint64_t test_case_4 = fibonacci(3);\\n    assert(test_case_4 == 2);\\n    std::cout << \\\"Passed Test 4!\\\" << std::endl;\\n\\n    uint64_t test_case_5 = fibonacci(4);\\n    assert(test_case_5 == 3);\\n    std::cout << \\\"Passed Test 5!\\\" << std::endl;\\n\\n    uint64_t test_case_6 = fibonacci(15);\\n    assert(test_case_6 == 610);\\n    std::cout << \\\"Passed Test 6!\\\" << std::endl << std::endl;\\n}\\n\\n/// Main function\\nint main() {\\n    test();\\n    int n = 0;\\n    std::cin >> n;\\n    assert(n >= 0);\\n    std::cout << \\\"F(\\\" << n << \\\")= \\\" << fibonacci(n) << std::endl;\\n}\\n\"",
    "fibonacci fast": "\"/**\\n * @file\\n * @brief Faster computation of Fibonacci series\\n *\\n * An efficient way to calculate nth fibonacci number faster and simpler than\\n * \\\\f$O(n\\\\log n)\\\\f$ method of matrix exponentiation This works by using both\\n * recursion and dynamic programming. as 93rd fibonacci exceeds 19 digits, which\\n * cannot be stored in a single long long variable, we can only use it till 92nd\\n * fibonacci we can use it for 10000th fibonacci etc, if we implement\\n * bigintegers. This algorithm works with the fact that nth fibonacci can easily\\n * found if we have already found n/2th or (n+1)/2th fibonacci It is a property\\n * of fibonacci similar to matrix exponentiation.\\n *\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n * @see fibonacci_large.cpp, fibonacci.cpp, string_fibonacci.cpp\\n */\\n\\n#include <cinttypes>\\n#include <cstdio>\\n#include <iostream>\\n\\n/**\\n * maximum number that can be computed - The result after 93 cannot be stored\\n * in a `uint64_t` data type.\\n */\\n\\n#define MAX 93\\n\\n/** Algorithm */\\nuint64_t fib(uint64_t n) {\\n    static uint64_t f1 = 1,\\n                    f2 = 1;  // using static keyword will retain the values of\\n                             // f1 and f2 for the next function call.\\n\\n    if (n <= 2)\\n        return f2;\\n    if (n >= 93) {\\n        std::cerr\\n            << \\\"Cannot compute for n>93 due to limit of 64-bit integers\\\\n\\\";\\n        return 0;\\n    }\\n\\n    uint64_t temp = f2;  // we do not need temp to be static\\n    f2 += f1;\\n    f1 = temp;\\n\\n    return f2;\\n}\\n\\n/** Main function */\\nint main() {\\n    // Main Function\\n    for (uint64_t i = 1; i < 93; i++) {\\n        std::cout << i << \\\" th fibonacci number is \\\" << fib(i) << std::endl;\\n    }\\n    return 0;\\n}\\n\"",
    "fibonacci large": "\"/**\\n * @file\\n * @brief Computes N^th Fibonacci number given as\\n * input argument. Uses custom build arbitrary integers library\\n * to perform additions and other operations.\\n *\\n * Took 0.608246 seconds to compute 50,000^th Fibonacci\\n * number that contains 10450 digits!\\n *\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n * @see fibonacci.cpp, fibonacci_fast.cpp, string_fibonacci.cpp\\n */\\n\\n#include <cinttypes>\\n#include <ctime>\\n#include <iostream>\\n\\n#include \\\"./large_number.h\\\"\\n\\n/** Compute fibonacci numbers using the relation\\n * \\\\f[f(n)=f(n-1)+f(n-2)\\\\f]\\n * and returns the result as a large_number type.\\n */\\nlarge_number fib(uint64_t n) {\\n    large_number f0(1);\\n    large_number f1(1);\\n\\n    do {\\n        large_number f2 = f1;\\n        f1 += f0;\\n        f0 = f2;\\n        n--;\\n    } while (n > 2);  // since we start from 2\\n\\n    return f1;\\n}\\n\\nint main(int argc, char *argv[]) {\\n    uint64_t N;\\n    if (argc == 2) {\\n        N = strtoull(argv[1], NULL, 10);\\n    } else {\\n        std::cout << \\\"Enter N: \\\";\\n        std::cin >> N;\\n    }\\n\\n    clock_t start_time = std::clock();\\n    large_number result = fib(N);\\n    clock_t end_time = std::clock();\\n    double time_taken = static_cast<double>(end_time - start_time) /\\n                        static_cast<double>(CLOCKS_PER_SEC);\\n\\n    std::cout << std::endl\\n              << N << \\\"^th Fibonacci number: \\\" << result << std::endl\\n              << \\\"Number of digits: \\\" << result.num_digits() << std::endl\\n              << \\\"Time taken: \\\" << std::scientific << time_taken << \\\" s\\\"\\n              << std::endl;\\n\\n    N = 5000;\\n    if (fib(N) ==\\n        large_number(\\n            \\\"387896845438832563370191630832590531208212771464624510616059721489\\\"\\n            \\\"555013904403709701082291646221066947929345285888297381348310200895\\\"\\n            \\\"498294036143015691147893836421656394410691021450563413370655865623\\\"\\n            \\\"825465670071252592990385493381392883637834751890876297071203333705\\\"\\n            \\\"292310769300851809384980180384781399674888176555465378829164426891\\\"\\n            \\\"298038461377896902150229308247566634622492307188332480328037503913\\\"\\n            \\\"035290330450584270114763524227021093463769910400671417488329842289\\\"\\n            \\\"149127310405432875329804427367682297724498774987455569190770388063\\\"\\n            \\\"704683279481135897373999311010621930814901857081539785437919530561\\\"\\n            \\\"751076105307568878376603366735544525884488624161921055345749367589\\\"\\n            \\\"784902798823435102359984466393485325641195222185956306047536464547\\\"\\n            \\\"076033090242080638258492915645287629157575914234380914230291749108\\\"\\n            \\\"898415520985443248659407979357131684169286803954530954538869811466\\\"\\n            \\\"508206686289742063932343848846524098874239587380197699382031717420\\\"\\n            \\\"893226546887936400263079778005875912967138963421425257911687275560\\\"\\n            \\\"0360311370547754724604639987588046985178408674382863125\\\"))\\n        std::cout << \\\"Test for \\\" << N << \\\"^th Fibonacci number passed!\\\"\\n                  << std::endl;\\n    else\\n        std::cerr << \\\"Test for \\\" << N << \\\"^th Fibonacci number failed!\\\"\\n                  << std::endl;\\n\\n    return 0;\\n}\\n\"",
    "fibonacci matrix exponentiation": "\"/**\\n * @file \\n * @brief This program computes the N^th Fibonacci number in modulo mod\\n * input argument .\\n *\\n * Takes O(logn) time to compute nth Fibonacci number\\n * \\n *\\n * \\\\author [villayatali123](https://github.com/villayatali123)\\n * \\\\author [unknown author]()\\n * @see fibonacci.cpp, fibonacci_fast.cpp, string_fibonacci.cpp, fibonacci_large.cpp\\n */\\n\\n#include<iostream>\\n#include<vector>\\n#include <cassert>\\n\\n/**\\n * This function finds nth fibonacci number in a given modulus\\n * @param n nth fibonacci number\\n * @param mod  modulo number \\n */\\nuint64_t fibo(uint64_t n , uint64_t mod )\\n{\\n\\tstd::vector<uint64_t> result(2,0);\\n\\tstd::vector<std::vector<uint64_t>> transition(2,std::vector<uint64_t>(2,0));\\n\\tstd::vector<std::vector<uint64_t>> Identity(2,std::vector<uint64_t>(2,0));\\n\\tn--;\\n\\tresult[0]=1, result[1]=1;\\n\\tIdentity[0][0]=1; Identity[0][1]=0;\\n\\tIdentity[1][0]=0; Identity[1][1]=1;\\n\\t \\n\\ttransition[0][0]=0;\\n\\ttransition[1][0]=transition[1][1]=transition[0][1]=1;\\n\\t\\n\\twhile(n)\\n\\t{\\n\\t\\tif(n%2)\\n\\t\\t{\\n\\t\\t\\tstd::vector<std::vector<uint64_t>> res(2, std::vector<uint64_t>(2,0));\\n\\t                for(int i=0;i<2;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<2;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int k=0;k<2;k++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tres[i][j]=(res[i][j]%mod+((Identity[i][k]%mod*transition[k][j]%mod))%mod)%mod;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t       \\tfor(int i=0;i<2;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<2;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tIdentity[i][j]=res[i][j];\\n\\t\\t\\t\\t}\\n\\t    \\t\\t}\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tstd::vector<std::vector<uint64_t>> res1(2, std::vector<uint64_t>(2,0));\\n\\t\\t\\tfor(int i=0;i<2;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<2;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int k=0;k<2;k++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tres1[i][j]=(res1[i][j]%mod+((transition[i][k]%mod*transition[k][j]%mod))%mod)%mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<2;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<2;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttransition[i][j]=res1[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tn=n/2;\\n\\t\\t\\t}\\n\\t}\\n\\treturn ((result[0]%mod*Identity[0][0]%mod)%mod+(result[1]%mod*Identity[1][0]%mod)%mod)%mod;\\n}\\n\\n/**\\n * Function to test above algorithm\\n */\\nvoid test()\\n{\\n    assert(fibo(6, 1000000007 ) == 8);\\n    std::cout << \\\"test case:1 passed\\\\n\\\";\\n    assert(fibo(5, 1000000007  ) == 5);\\n    std::cout << \\\"test case:2 passed\\\\n\\\";\\n    assert(fibo(10 , 1000000007) == 55);\\n    std::cout << \\\"test case:3 passed\\\\n\\\";\\n    assert(fibo(500 , 100) == 25);\\n    std::cout << \\\"test case:3 passed\\\\n\\\";\\n    assert(fibo(500 , 10000) == 4125);\\n    std::cout << \\\"test case:3 passed\\\\n\\\";\\n    std::cout << \\\"--All tests passed--\\\\n\\\";\\n}\\n\\n/**\\n * Main function\\n */\\nint main()\\n{\\n\\ttest();\\n\\tuint64_t mod=1000000007;\\n\\tstd::cout<<\\\"Enter the value of N: \\\";\\n\\tuint64_t n=0; std::cin>>n; \\n\\tstd::cout<<n<<\\\"th Fibonacci number in modulo \\\" << mod << \\\": \\\"<< fibo( n , mod) << std::endl;\\n}\\n\"",
    "fibonacci sum": "\"/**\\n * @file\\n * @brief An algorithm to calculate the sum of [Fibonacci\\n * Sequence](https://en.wikipedia.org/wiki/Fibonacci_number): \\\\f$\\\\mathrm{F}(n) +\\n * \\\\mathrm{F}(n+1) + .. + \\\\mathrm{F}(m)\\\\f$\\n * @details An algorithm to calculate the sum of Fibonacci Sequence:\\n * \\\\f$\\\\mathrm{F}(n) + \\\\mathrm{F}(n+1) + .. + \\\\mathrm{F}(m)\\\\f$ where\\n * \\\\f$\\\\mathrm{F}(i)\\\\f$ denotes the i-th Fibonacci Number . Note that F(0) = 0\\n * and F(1) = 1. The value of the sum is calculated using matrix exponentiation.\\n * Reference source:\\n * https://stackoverflow.com/questions/4357223/finding-the-sum-of-fibonacci-numbers\\n * @author [Sarthak Sahu](https://github.com/SarthakSahu1009)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for std::cin and std::cout\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @namespace fibonacci_sum\\n * @brief Functions for the sum of the Fibonacci Sequence: \\\\f$\\\\mathrm{F}(n) +\\n * \\\\mathrm{F}(n+1) + .. + \\\\mathrm{F}(m)\\\\f$\\n */\\nnamespace fibonacci_sum {\\nusing matrix = std::vector<std::vector<uint64_t> >;\\n\\n/**\\n * Function to multiply two matrices\\n * @param T matrix 1\\n * @param A martix 2\\n * @returns resultant matrix\\n */\\nmath::fibonacci_sum::matrix multiply(const math::fibonacci_sum::matrix &T,\\n                                     const math::fibonacci_sum::matrix &A) {\\n    math::fibonacci_sum::matrix result(2, std::vector<uint64_t>(2, 0));\\n\\n    // multiplying matrices\\n    result[0][0] = T[0][0] * A[0][0] + T[0][1] * A[1][0];\\n    result[0][1] = T[0][0] * A[0][1] + T[0][1] * A[1][1];\\n    result[1][0] = T[1][0] * A[0][0] + T[1][1] * A[1][0];\\n    result[1][1] = T[1][0] * A[0][1] + T[1][1] * A[1][1];\\n\\n    return result;\\n}\\n\\n/**\\n * Function to compute A^n where A is a matrix.\\n * @param T matrix\\n * @param ex power\\n * @returns resultant matrix\\n */\\nmath::fibonacci_sum::matrix power(math::fibonacci_sum::matrix T, uint64_t ex) {\\n    math::fibonacci_sum::matrix A{{1, 1}, {1, 0}};\\n    if (ex == 0 || ex == 1) {\\n        return T;\\n    }\\n\\n    T = power(T, ex / 2);\\n    T = multiply(T, T);\\n    if (ex & 1) {\\n        T = multiply(T, A);\\n    }\\n    return T;\\n}\\n\\n/**\\n * Function to compute sum of fibonacci sequence from 0 to n.\\n * @param n number\\n * @returns uint64_t ans, the sum of sequence\\n */\\nuint64_t result(uint64_t n) {\\n    math::fibonacci_sum::matrix T{{1, 1}, {1, 0}};\\n    T = power(T, n);\\n    uint64_t ans = T[0][1];\\n    ans = (ans - 1);\\n    return ans;\\n}\\n\\n/**\\n * Function to compute sum of fibonacci sequence from n to m.\\n * @param n start of sequence\\n * @param m end of sequence\\n * @returns uint64_t the sum of sequence\\n */\\nuint64_t fiboSum(uint64_t n, uint64_t m) {\\n    return (result(m + 2) - result(n + 1));\\n}\\n}  // namespace fibonacci_sum\\n}  // namespace math\\n\\n/**\\n * Function for testing fiboSum function.\\n * test cases and assert statement.\\n * @returns `void`\\n */\\nstatic void test() {\\n    uint64_t n = 0, m = 3;\\n    uint64_t test_1 = math::fibonacci_sum::fiboSum(n, m);\\n    assert(test_1 == 4);\\n    std::cout << \\\"Passed Test 1!\\\" << std::endl;\\n\\n    n = 3;\\n    m = 5;\\n    uint64_t test_2 = math::fibonacci_sum::fiboSum(n, m);\\n    assert(test_2 == 10);\\n    std::cout << \\\"Passed Test 2!\\\" << std::endl;\\n\\n    n = 5;\\n    m = 7;\\n    uint64_t test_3 = math::fibonacci_sum::fiboSum(n, m);\\n    assert(test_3 == 26);\\n    std::cout << \\\"Passed Test 3!\\\" << std::endl;\\n\\n    n = 7;\\n    m = 10;\\n    uint64_t test_4 = math::fibonacci_sum::fiboSum(n, m);\\n    assert(test_4 == 123);\\n    std::cout << \\\"Passed Test 4!\\\" << std::endl;\\n\\n    n = 9;\\n    m = 12;\\n    uint64_t test_5 = math::fibonacci_sum::fiboSum(n, m);\\n    assert(test_5 == 322);\\n    std::cout << \\\"Passed Test 5!\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // execute the tests\\n    return 0;\\n}\\n\"",
    "finding number of digits in a number": "\"/**\\n * @author [aminos 🇮🇳](https://github.com/amino19)\\n * @file\\n *\\n * @brief [Program to count digits\\n * in an\\n * integer](https://www.geeksforgeeks.org/program-count-digits-integer-3-different-methods)\\n * @details It is a very basic math of finding number of digits in a given\\n * number i.e, we can use it by inputting values whether it can be a\\n * positive/negative value, let's say: an integer. There is also a second\\n * method: by using \\\"K = floor(log10(N) + 1)\\\", but it's only applicable for\\n * numbers (not integers).\\n * For more details, refer to the\\n * [Algorithms-Explanation](https://github.com/TheAlgorithms/Algorithms-Explanation/blob/master/en/Basic%20Math/Finding\\n * the number of digits in a number.md) repository.\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * @brief The main function that checks\\n * the number of digits in a number.\\n * @param n the number to check its digits\\n * @returns the digits count\\n */\\nuint64_t finding_number_of_digits_in_a_number(uint64_t n) {\\n    uint64_t count = 0;  ///< the variable used for the digits count\\n\\n    // iterate until `n` becomes 0\\n    // remove last digit from `n` in each iteration\\n    // increase `count` by 1 in each iteration\\n    while (n != 0) {\\n        // we can also use `n = n / 10`\\n        n /= 10;\\n        // each time the loop is running, `count` will be incremented by 1.\\n        ++count;\\n    }\\n\\n    return count;\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    assert(finding_number_of_digits_in_a_number(5492) == 4);\\n    assert(finding_number_of_digits_in_a_number(-0) == 0);\\n    assert(finding_number_of_digits_in_a_number(10000) == 5);\\n    assert(finding_number_of_digits_in_a_number(9) == 1);\\n    assert(finding_number_of_digits_in_a_number(100000) == 6);\\n    assert(finding_number_of_digits_in_a_number(13) == 2);\\n    assert(finding_number_of_digits_in_a_number(564) == 3);\\n\\n    std::cout << \\\"All tests have successfully passed!\\\\n\\\";\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "gcd iterative euclidean": "\"/**\\n * @file\\n * @brief Compute the greatest common denominator of two integers using\\n * *iterative form* of\\n * [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)\\n *\\n * @see gcd_recursive_euclidean.cpp, gcd_of_n_numbers.cpp\\n */\\n#include <iostream>\\n#include <stdexcept>\\n\\n/**\\n * algorithm\\n */\\nint gcd(int num1, int num2) {\\n    if (num1 <= 0 | num2 <= 0) {\\n        throw std::domain_error(\\\"Euclidean algorithm domain is for ints > 0\\\");\\n    }\\n\\n    if (num1 == num2) {\\n        return num1;\\n    }\\n\\n    int base_num = 0;\\n    int previous_remainder = 1;\\n\\n    if (num1 > num2) {\\n        base_num = num1;\\n        previous_remainder = num2;\\n    } else {\\n        base_num = num2;\\n        previous_remainder = num1;\\n    }\\n\\n    while ((base_num % previous_remainder) != 0) {\\n        int old_base = base_num;\\n        base_num = previous_remainder;\\n        previous_remainder = old_base % previous_remainder;\\n    }\\n\\n    return previous_remainder;\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    std::cout << \\\"gcd of 120,7 is \\\" << (gcd(120, 7)) << std::endl;\\n    try {\\n        std::cout << \\\"gcd of -120,10 is \\\" << gcd(-120, 10) << std::endl;\\n    } catch (const std::domain_error &e) {\\n        std::cout << \\\"Error handling was successful\\\" << std::endl;\\n    }\\n    std::cout << \\\"gcd of 312,221 is \\\" << (gcd(312, 221)) << std::endl;\\n    std::cout << \\\"gcd of 289,204 is \\\" << (gcd(289, 204)) << std::endl;\\n\\n    return 0;\\n}\\n\"",
    "gcd of n numbers": "\"/**\\n * @file\\n * @brief This program aims at calculating the GCD of n numbers by division\\n * method\\n *\\n * @see gcd_iterative_euclidean.cpp, gcd_recursive_euclidean.cpp\\n */\\n#include <iostream>\\n\\n/** Compute GCD using division algorithm\\n *\\n * @param[in] a array of integers to compute GCD for\\n * @param[in] n number of integers in array `a`\\n */\\nint gcd(int *a, int n) {\\n    int j = 1;  // to access all elements of the array starting from 1\\n    int gcd = a[0];\\n    while (j < n) {\\n        if (a[j] % gcd == 0)  // value of gcd is as needed so far\\n            j++;              // so we check for next element\\n        else\\n            gcd = a[j] % gcd;  // calculating GCD by division method\\n    }\\n    return gcd;\\n}\\n\\n/** Main function */\\nint main() {\\n    int n;\\n    std::cout << \\\"Enter value of n:\\\" << std::endl;\\n    std::cin >> n;\\n    int *a = new int[n];\\n    int i;\\n    std::cout << \\\"Enter the n numbers:\\\" << std::endl;\\n    for (i = 0; i < n; i++) std::cin >> a[i];\\n\\n    std::cout << \\\"GCD of entered n numbers:\\\" << gcd(a, n) << std::endl;\\n\\n    delete[] a;\\n    return 0;\\n}\\n\"",
    "gcd recursive euclidean": "\"/**\\n * @file\\n * @brief Compute the greatest common denominator of two integers using\\n * *recursive form* of\\n * [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)\\n *\\n * @see gcd_iterative_euclidean.cpp, gcd_of_n_numbers.cpp\\n */\\n#include <iostream>\\n\\n/**\\n * algorithm\\n */\\nint gcd(int num1, int num2) {\\n    if (num1 <= 0 | num2 <= 0) {\\n        throw std::domain_error(\\\"Euclidean algorithm domain is for ints > 0\\\");\\n    }\\n\\n    if (num1 == num2) {\\n        return num1;\\n    }\\n\\n    // Everything divides 0\\n    if (num1 == 0)\\n        return num2;\\n    if (num2 == 0)\\n        return num1;\\n\\n    // base case\\n    if (num1 == num2)\\n        return num1;\\n\\n    // a is greater\\n    if (num1 > num2)\\n        return gcd(num1 - num2, num2);\\n    return gcd(num1, num2 - num1);\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    std::cout << \\\"gcd of 120,7 is \\\" << (gcd(120, 7)) << std::endl;\\n    try {\\n        std::cout << \\\"gcd of -120,10 is \\\" << gcd(-120, 10) << std::endl;\\n    } catch (const std::domain_error &e) {\\n        std::cout << \\\"Error handling was successful\\\" << std::endl;\\n    }\\n    std::cout << \\\"gcd of 312,221 is \\\" << (gcd(312, 221)) << std::endl;\\n    std::cout << \\\"gcd of 289,204 is \\\" << (gcd(289, 204)) << std::endl;\\n    return 0;\\n}\\n\"",
    "integral approximation": "\"/**\\r\\n * @file\\r\\n * @brief Compute integral approximation of the function using [Riemann sum](https://en.wikipedia.org/wiki/Riemann_sum)\\r\\n * @details In mathematics, a Riemann sum is a certain kind of approximation of an integral by a finite sum. It is named after nineteenth-century German mathematician Bernhard Riemann.\\r\\n * One very common application is approximating the area of functions or lines on a graph and the length of curves and other approximations.\\r\\n * The sum is calculated by partitioning the region into shapes (rectangles, trapezoids, parabolas, or cubics) that form a region similar to the region being measured, then calculating the area for each of these shapes, and finally adding all of these small areas together.\\r\\n * This approach can be used to find a numerical approximation for a definite integral even if the fundamental theorem of calculus does not make it easy to find a closed-form solution.\\r\\n * Because the region filled by the small shapes is usually not the same shape as the region being measured, the Riemann sum will differ from the area being measured.\\r\\n * This error can be reduced by dividing up the region more finely, using smaller and smaller shapes. As the shapes get smaller and smaller, the sum approaches the Riemann integral.\\r\\n * \\\\author [Benjamin Walton](https://github.com/bwalton24)\\r\\n * \\\\author [Shiqi Sheng](https://github.com/shiqisheng00)\\r\\n */\\r\\n#include <cassert>        /// for assert\\r\\n#include <cmath>         /// for mathematical functions\\r\\n#include <functional>   /// for passing in functions\\r\\n#include <iostream>    /// for IO operations\\r\\n\\r\\n/**\\r\\n * @namespace math\\r\\n * @brief Mathematical functions\\r\\n */\\r\\nnamespace math {\\r\\n/**\\r\\n * @brief Computes integral approximation\\r\\n * @param lb lower bound\\r\\n * @param ub upper bound\\r\\n * @param func function passed in\\r\\n * @param delta\\r\\n * @returns integral approximation of function from [lb, ub]\\r\\n */\\r\\ndouble integral_approx(double lb, double ub,\\r\\n                       const std::function<double(double)>& func,\\r\\n                       double delta = .0001) {\\r\\n    double result = 0;\\r\\n    uint64_t numDeltas = static_cast<uint64_t>((ub - lb) / delta);\\r\\n    for (int i = 0; i < numDeltas; i++) {\\r\\n        double begin = lb + i * delta;\\r\\n        double end = lb + (i + 1) * delta;\\r\\n        result += delta * (func(begin) + func(end)) / 2;\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Wrapper to evaluate if the approximated\\r\\n * value is within `.XX%` threshold of the exact value.\\r\\n * @param approx aprroximate value\\r\\n * @param exact expected value\\r\\n * @param threshold values from [0, 1)\\r\\n */\\r\\nvoid test_eval(double approx, double expected, double threshold) {\\r\\n    assert(approx >= expected * (1 - threshold));\\r\\n    assert(approx <= expected * (1 + threshold));\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Self-test implementations to\\r\\n * test the `integral_approx` function.\\r\\n *\\r\\n * @returns `void`\\r\\n */\\r\\n}  // namespace math\\r\\n\\r\\nstatic void test() {\\r\\n    double test_1 = math::integral_approx(\\r\\n        3.24, 7.56, [](const double x) { return log(x) + exp(x) + x; });\\r\\n    std::cout << \\\"Test Case 1\\\" << std::endl;\\r\\n    std::cout << \\\"function: log(x) + e^x + x\\\" << std::endl;\\r\\n    std::cout << \\\"range: [3.24, 7.56]\\\" << std::endl;\\r\\n    std::cout << \\\"value: \\\" << test_1 << std::endl;\\r\\n    math::test_eval(test_1, 1924.80384023549, .001);\\r\\n    std::cout << \\\"Test 1 Passed!\\\" << std::endl;\\r\\n    std::cout << \\\"=====================\\\" << std::endl;\\r\\n\\r\\n    double test_2 = math::integral_approx(0.023, 3.69, [](const double x) {\\r\\n        return x * x + cos(x) + exp(x) + log(x) * log(x);\\r\\n    });\\r\\n    std::cout << \\\"Test Case 2\\\" << std::endl;\\r\\n    std::cout << \\\"function: x^2 + cos(x) + e^x + log^2(x)\\\" << std::endl;\\r\\n    std::cout << \\\"range: [.023, 3.69]\\\" << std::endl;\\r\\n    std::cout << \\\"value: \\\" << test_2 << std::endl;\\r\\n    math::test_eval(test_2, 58.71291345202729, .001);\\r\\n    std::cout << \\\"Test 2 Passed!\\\" << std::endl;\\r\\n    std::cout << \\\"=====================\\\" << std::endl;\\r\\n\\r\\n    double test_3 = math::integral_approx(\\r\\n        10.78, 24.899, [](const double x) { return x * x * x - x * x + 378; });\\r\\n    std::cout << \\\"Test Case 3\\\" << std::endl;\\r\\n    std::cout << \\\"function: x^3 - x^2 + 378\\\" << std::endl;\\r\\n    std::cout << \\\"range: [10.78, 24.899]\\\" << std::endl;\\r\\n    std::cout << \\\"value: \\\" << test_3 << std::endl;\\r\\n    math::test_eval(test_3, 93320.65915078377, .001);\\r\\n    std::cout << \\\"Test 3 Passed!\\\" << std::endl;\\r\\n    std::cout << \\\"=====================\\\" << std::endl;\\r\\n\\r\\n    double test_4 = math::integral_approx(\\r\\n        .101, .505,\\r\\n        [](const double x) { return cos(x) * tan(x) * x * x + exp(x); },\\r\\n        .00001);\\r\\n    std::cout << \\\"Test Case 4\\\" << std::endl;\\r\\n    std::cout << \\\"function: cos(x)*tan(x)*x^2 + e^x\\\" << std::endl;\\r\\n    std::cout << \\\"range: [.101, .505]\\\" << std::endl;\\r\\n    std::cout << \\\"value: \\\" << test_4 << std::endl;\\r\\n    math::test_eval(test_4, 0.566485986311631, .001);\\r\\n    std::cout << \\\"Test 4 Passed!\\\" << std::endl;\\r\\n    std::cout << \\\"=====================\\\" << std::endl;\\r\\n\\r\\n    double test_5 = math::integral_approx(\\r\\n        -1, 1, [](const double x) { return exp(-1 / (x * x)); });\\r\\n    std::cout << \\\"Test Case 5\\\" << std::endl;\\r\\n    std::cout << \\\"function: e^(-1/x^2)\\\" << std::endl;\\r\\n    std::cout << \\\"range: [-1, 1]\\\" << std::endl;\\r\\n    std::cout << \\\"value: \\\" << test_5 << std::endl;\\r\\n    math::test_eval(test_5, 0.1781477117815607, .001);\\r\\n    std::cout << \\\"Test 5 Passed!\\\" << std::endl;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @returns 0 on exit\\r\\n */\\r\\nint main() {\\r\\n    test();  // run self-test implementations\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "integral approximation2": "\"/**\\n * @file\\n * @brief [Monte Carlo\\n * Integration](https://en.wikipedia.org/wiki/Monte_Carlo_integration)\\n *\\n * @details\\n * In mathematics, Monte Carlo integration is a technique for numerical\\n * integration using random numbers. It is a particular Monte Carlo method that\\n * numerically computes a definite integral. While other algorithms usually\\n * evaluate the integrand at a regular grid, Monte Carlo randomly chooses points\\n * at which the integrand is evaluated. This method is particularly useful for\\n * higher-dimensional integrals.\\n *\\n * This implementation supports arbitrary pdfs.\\n * These pdfs are sampled using the [Metropolis-Hastings\\n * algorithm](https://en.wikipedia.org/wiki/Metropolis–Hastings_algorithm). This\\n * can be swapped out by every other sampling techniques for example the inverse\\n * method. Metropolis-Hastings was chosen because it is the most general and can\\n * also be extended for a higher dimensional sampling space.\\n *\\n * @author [Domenic Zingsheim](https://github.com/DerAndereDomenic)\\n */\\n\\n#define _USE_MATH_DEFINES  /// for M_PI on windows\\n#include <cmath>           /// for math functions\\n#include <cstdint>         /// for fixed size data types\\n#include <ctime>           /// for time to initialize rng\\n#include <functional>      /// for function pointers\\n#include <iostream>        /// for std::cout\\n#include <random>          /// for random number generation\\n#include <vector>          /// for std::vector\\n\\n/**\\n * @namespace math\\n * @brief Math algorithms\\n */\\nnamespace math {\\n/**\\n * @namespace monte_carlo\\n * @brief Functions for the [Monte Carlo\\n * Integration](https://en.wikipedia.org/wiki/Monte_Carlo_integration)\\n * implementation\\n */\\nnamespace monte_carlo {\\n\\nusing Function = std::function<double(\\n    double&)>;  /// short-hand for std::functions used in this implementation\\n\\n/**\\n * @brief Generate samples according to some pdf\\n * @details This function uses Metropolis-Hastings to generate random numbers.\\n * It generates a sequence of random numbers by using a markov chain. Therefore,\\n * we need to define a start_point and the number of samples we want to\\n * generate. Because the first samples generated by the markov chain may not be\\n * distributed according to the given pdf, one can specify how many samples\\n * should be discarded before storing samples.\\n * @param start_point The starting point of the markov chain\\n * @param pdf The pdf to sample\\n * @param num_samples The number of samples to generate\\n * @param discard How many samples should be discarded at the start\\n * @returns A vector of size num_samples with samples distributed according to\\n * the pdf\\n */\\nstd::vector<double> generate_samples(const double& start_point,\\n                                     const Function& pdf,\\n                                     const uint32_t& num_samples,\\n                                     const uint32_t& discard = 100000) {\\n    std::vector<double> samples;\\n    samples.reserve(num_samples);\\n\\n    double x_t = start_point;\\n\\n    std::default_random_engine generator;\\n    std::uniform_real_distribution<double> uniform(0.0, 1.0);\\n    std::normal_distribution<double> normal(0.0, 1.0);\\n    generator.seed(time(nullptr));\\n\\n    for (uint32_t t = 0; t < num_samples + discard; ++t) {\\n        // Generate a new proposal according to some mutation strategy.\\n        // This is arbitrary and can be swapped.\\n        double x_dash = normal(generator) + x_t;\\n        double acceptance_probability = std::min(pdf(x_dash) / pdf(x_t), 1.0);\\n        double u = uniform(generator);\\n\\n        // Accept \\\"new state\\\" according to the acceptance_probability\\n        if (u <= acceptance_probability) {\\n            x_t = x_dash;\\n        }\\n\\n        if (t >= discard) {\\n            samples.push_back(x_t);\\n        }\\n    }\\n\\n    return samples;\\n}\\n\\n/**\\n * @brief Compute an approximation of an integral using Monte Carlo integration\\n * @details The integration domain [a,b] is given by the pdf.\\n * The pdf has to fulfill the following conditions:\\n * 1) for all x \\\\in [a,b] : p(x) > 0\\n * 2) for all x \\\\not\\\\in [a,b] : p(x) = 0\\n * 3) \\\\int_a^b p(x) dx = 1\\n * @param start_point The start point of the Markov Chain (see generate_samples)\\n * @param function The function to integrate\\n * @param pdf The pdf to sample\\n * @param num_samples The number of samples used to approximate the integral\\n * @returns The approximation of the integral according to 1/N \\\\sum_{i}^N f(x_i)\\n * / p(x_i)\\n */\\ndouble integral_monte_carlo(const double& start_point, const Function& function,\\n                            const Function& pdf,\\n                            const uint32_t& num_samples = 1000000) {\\n    double integral = 0.0;\\n    std::vector<double> samples =\\n        generate_samples(start_point, pdf, num_samples);\\n\\n    for (double sample : samples) {\\n        integral += function(sample) / pdf(sample);\\n    }\\n\\n    return integral / static_cast<double>(samples.size());\\n}\\n\\n}  // namespace monte_carlo\\n}  // namespace math\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    std::cout << \\\"Disclaimer: Because this is a randomized algorithm,\\\"\\n              << std::endl;\\n    std::cout\\n        << \\\"it may happen that singular samples deviate from the true result.\\\"\\n        << std::endl\\n        << std::endl;\\n    ;\\n\\n    math::monte_carlo::Function f;\\n    math::monte_carlo::Function pdf;\\n    double integral = 0;\\n    double lower_bound = 0, upper_bound = 0;\\n\\n    /* \\\\int_{-2}^{2} -x^2 + 4 dx */\\n    f = [&](double& x) { return -x * x + 4.0; };\\n\\n    lower_bound = -2.0;\\n    upper_bound = 2.0;\\n    pdf = [&](double& x) {\\n        if (x >= lower_bound && x <= -1.0) {\\n            return 0.1;\\n        }\\n        if (x <= upper_bound && x >= 1.0) {\\n            return 0.1;\\n        }\\n        if (x > -1.0 && x < 1.0) {\\n            return 0.4;\\n        }\\n        return 0.0;\\n    };\\n\\n    integral = math::monte_carlo::integral_monte_carlo(\\n        (upper_bound - lower_bound) / 2.0, f, pdf);\\n\\n    std::cout << \\\"This number should be close to 10.666666: \\\" << integral\\n              << std::endl;\\n\\n    /* \\\\int_{0}^{1} e^x dx */\\n    f = [&](double& x) { return std::exp(x); };\\n\\n    lower_bound = 0.0;\\n    upper_bound = 1.0;\\n    pdf = [&](double& x) {\\n        if (x >= lower_bound && x <= 0.2) {\\n            return 0.1;\\n        }\\n        if (x > 0.2 && x <= 0.4) {\\n            return 0.4;\\n        }\\n        if (x > 0.4 && x < upper_bound) {\\n            return 1.5;\\n        }\\n        return 0.0;\\n    };\\n\\n    integral = math::monte_carlo::integral_monte_carlo(\\n        (upper_bound - lower_bound) / 2.0, f, pdf);\\n\\n    std::cout << \\\"This number should be close to 1.7182818: \\\" << integral\\n              << std::endl;\\n\\n    /* \\\\int_{-\\\\infty}^{\\\\infty} sinc(x) dx, sinc(x) = sin(pi * x) / (pi * x)\\n       This is a difficult integral because of its infinite domain.\\n       Therefore, it may deviate largely from the expected result.\\n    */\\n    f = [&](double& x) { return std::sin(M_PI * x) / (M_PI * x); };\\n\\n    pdf = [&](double& x) {\\n        return 1.0 / std::sqrt(2.0 * M_PI) * std::exp(-x * x / 2.0);\\n    };\\n\\n    integral = math::monte_carlo::integral_monte_carlo(0.0, f, pdf, 10000000);\\n\\n    std::cout << \\\"This number should be close to 1.0: \\\" << integral\\n              << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "inv sqrt": "\"/**\\n * @file\\n * @brief Implementation of [the inverse square root\\n * Root](https://medium.com/hard-mode/the-legendary-fast-inverse-square-root-e51fee3b49d9).\\n * @details\\n * Two implementation to calculate inverse inverse root,\\n * from Quake III Arena (C++ version) and with a standard library (`cmath`).\\n * This algorithm is used to calculate shadows in Quake III Arena.\\n */\\n\\n#include <cassert>   /// for assert\\n#include <cmath>     /// for `std::sqrt`\\n#include <iostream>  /// for IO operations\\n#include <limits>    /// for numeric_limits\\n\\n/**\\n * @brief This is the function that calculates the fast inverse square root.\\n * The following code is the fast inverse square root implementation from\\n * Quake III Arena (Adapted for C++). More information can be found at\\n * [Wikipedia](https://en.wikipedia.org/wiki/Fast_inverse_square_root)\\n * @tparam T floating type\\n * @tparam iterations inverse square root, the greater the number of\\n * iterations, the more exact the result will be (1 or 2).\\n * @param x value to calculate\\n * @return the inverse square root\\n */\\ntemplate <typename T = double, char iterations = 2>\\ninline T Fast_InvSqrt(T x) {\\n    using Tint = typename std::conditional<sizeof(T) == 8, std::int64_t,\\n                                           std::int32_t>::type;\\n    T y = x;\\n    T x2 = y * 0.5;\\n\\n    Tint i =\\n        *reinterpret_cast<Tint *>(&y);  // Store floating-point bits in integer\\n\\n    i = (sizeof(T) == 8 ? 0x5fe6eb50c7b537a9 : 0x5f3759df) -\\n        (i >> 1);  // Initial guess for Newton's method\\n\\n    y = *reinterpret_cast<T *>(&i);  // Convert new bits into float\\n\\n    y = y * (1.5 - (x2 * y * y));  // 1st iteration Newton's method\\n    if (iterations == 2) {\\n        y = y * (1.5 - (x2 * y * y));  // 2nd iteration, the more exact result\\n    }\\n    return y;\\n}\\n\\n/**\\n * @brief This is the function that calculates the fast inverse square root.\\n * The following code is the fast inverse square root with standard lib (cmath)\\n * More information can be found at\\n * [LinkedIn](https://www.linkedin.com/pulse/fast-inverse-square-root-still-armin-kassemi-langroodi)\\n * @tparam T floating type\\n * @param number value to calculate\\n * @return the inverse square root\\n */\\ntemplate <typename T = double>\\nT Standard_InvSqrt(T number) {\\n    T squareRoot = sqrt(number);\\n    return 1.0f / squareRoot;\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    const float epsilon = 1e-3f;\\n\\n    /* Tests with multiple values */\\n    assert(std::fabs(Standard_InvSqrt<float>(100.0f) - 0.0998449f) < epsilon);\\n    assert(std::fabs(Standard_InvSqrt<double>(36.0f) - 0.166667f) < epsilon);\\n    assert(std::fabs(Standard_InvSqrt(12.0f) - 0.288423f) < epsilon);\\n    assert(std::fabs(Standard_InvSqrt<double>(5.0f) - 0.447141f) < epsilon);\\n\\n    assert(std::fabs(Fast_InvSqrt<float, 1>(100.0f) - 0.0998449f) < epsilon);\\n    assert(std::fabs(Fast_InvSqrt<double, 1>(36.0f) - 0.166667f) < epsilon);\\n    assert(std::fabs(Fast_InvSqrt(12.0f) - 0.288423) < epsilon);\\n    assert(std::fabs(Fast_InvSqrt<double>(5.0f) - 0.447141) < epsilon);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    std::cout << \\\"The Fast inverse square root of 36 is: \\\"\\n              << Fast_InvSqrt<float, 1>(36.0f) << std::endl;\\n    std::cout << \\\"The Fast inverse square root of 36 is: \\\"\\n              << Fast_InvSqrt<double, 2>(36.0f) << \\\" (2 iterations)\\\"\\n              << std::endl;\\n    std::cout << \\\"The Fast inverse square root of 100 is: \\\"\\n              << Fast_InvSqrt(100.0f)\\n              << \\\" (With default template type and iterations: double, 2)\\\"\\n              << std::endl;\\n    std::cout << \\\"The Standard inverse square root of 36 is: \\\"\\n              << Standard_InvSqrt<float>(36.0f) << std::endl;\\n    std::cout << \\\"The Standard inverse square root of 100 is: \\\"\\n              << Standard_InvSqrt(100.0f)\\n              << \\\" (With default template type: double)\\\" << std::endl;\\n}\\n\"",
    "largest power": "\"/**\\n * @file\\n * @brief Algorithm to find largest x such that p^x divides n! (factorial) using Legendre's Formula.\\n * @details Given an integer n and a prime number p, the task is to find the largest x such that \\n * p^x (p raised to power x) divides n! (factorial). This will be done using Legendre's formula:\\n * x = [n/(p^1)] + [n/(p^2)] + [n/(p^3)] + \\\\ldots + 1\\n * @see more on https://math.stackexchange.com/questions/141196/highest-power-of-a-prime-p-dividing-n\\n * @author [uday6670](https://github.com/uday6670)\\n */\\n\\n#include <iostream> /// for std::cin and std::cout\\n#include <cassert>  /// for assert\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n\\n\\t/** \\n\\t * @brief Function to calculate largest power\\n\\t * @param n number\\n         * @param p prime number\\n\\t * @returns largest power\\n\\t */ \\n    uint64_t largestPower(uint32_t n, const uint16_t& p)  \\n    {  \\n        // Initialize result  \\n        int x = 0;  \\n  \\n        // Calculate result \\n        while (n)  \\n        {  \\n            n /= p;  \\n            x += n;  \\n        }  \\n        return x;  \\n    }\\n\\n}  // namespace math\\n\\n/**\\n * @brief Function for testing largestPower function.\\n * test cases and assert statement.\\n * @returns `void`\\n*/\\nstatic void test()\\n{\\n\\tuint8_t test_case_1 = math::largestPower(5,2);\\n\\tassert(test_case_1==3);\\n\\tstd::cout<<\\\"Test 1 Passed!\\\"<<std::endl;\\n\\t\\n\\tuint16_t test_case_2 = math::largestPower(10,3);\\n\\tassert(test_case_2==4);\\n\\tstd::cout<<\\\"Test 2 Passed!\\\"<<std::endl;\\n\\t\\n\\tuint32_t test_case_3 = math::largestPower(25,5);\\n\\tassert(test_case_3==6);\\n\\tstd::cout<<\\\"Test 3 Passed!\\\"<<std::endl;\\n\\t\\n\\tuint32_t test_case_4 = math::largestPower(27,2);\\n\\tassert(test_case_4==23);\\n\\tstd::cout<<\\\"Test 4 Passed!\\\"<<std::endl;\\n\\t\\n\\tuint16_t test_case_5 = math::largestPower(7,3);\\n\\tassert(test_case_5==2);\\n\\tstd::cout<<\\\"Test 5 Passed!\\\"<<std::endl;\\n} \\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() \\n{ \\n    test(); // execute the tests\\n    return 0;\\n} \\n\"",
    "large factorial": "\"/**\\n * @file\\n * @brief Compute factorial of any arbitratily large number/\\n *\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n * @see factorial.cpp\\n */\\n#include <cstring>\\n#include <ctime>\\n#include <iostream>\\n\\n#include \\\"./large_number.h\\\"\\n\\n/** Test implementation for 10! Result must be 3628800.\\n * @returns True if test pass else False\\n */\\nbool test1() {\\n    std::cout << \\\"---- Check 1\\\\t\\\";\\n    unsigned int i, number = 10;\\n    large_number result;\\n    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */\\n        result *= i;\\n\\n    const char *known_reslt = \\\"3628800\\\";\\n\\n    /* check 1 */\\n    if (strlen(known_reslt) != result.num_digits()) {\\n        std::cerr << \\\"Result lengths dont match! \\\" << strlen(known_reslt)\\n                  << \\\" != \\\" << result.num_digits() << std::endl;\\n        return false;\\n    }\\n\\n    const size_t N = result.num_digits();\\n    for (i = 0; i < N; i++) {\\n        if (known_reslt[i] != result.digit_char(i)) {\\n            std::cerr << i << \\\"^th digit mismatch! \\\" << known_reslt[i]\\n                      << \\\" != \\\" << result.digit_char(i) << std::endl;\\n            return false;\\n        }\\n    }\\n\\n    std::cout << \\\"Passed!\\\" << std::endl;\\n    return true;\\n}\\n\\n/** Test implementation for 100! The result is the 156 digit number:\\n * ```\\n * 9332621544394415268169923885626670049071596826438162146859296389521759\\n * 9993229915608941463976156518286253697920827223758251185210916864000000\\n * 000000000000000000\\n * ```\\n * @returns True if test pass else False\\n */\\nbool test2() {\\n    std::cout << \\\"---- Check 2\\\\t\\\";\\n    unsigned int i, number = 100;\\n    large_number result;\\n    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */\\n        result *= i;\\n\\n    const char *known_reslt =\\n        \\\"9332621544394415268169923885626670049071596826438162146859296389521759\\\"\\n        \\\"9993229915608941463976156518286253697920827223758251185210916864000000\\\"\\n        \\\"000000000000000000\\\";\\n\\n    /* check 1 */\\n    if (strlen(known_reslt) != result.num_digits()) {\\n        std::cerr << \\\"Result lengths dont match! \\\" << strlen(known_reslt)\\n                  << \\\" != \\\" << result.num_digits() << std::endl;\\n        return false;\\n    }\\n\\n    const size_t N = result.num_digits();\\n    for (i = 0; i < N; i++) {\\n        if (known_reslt[i] != result.digit_char(i)) {\\n            std::cerr << i << \\\"^th digit mismatch! \\\" << known_reslt[i]\\n                      << \\\" != \\\" << result.digit_char(i) << std::endl;\\n            return false;\\n        }\\n    }\\n\\n    std::cout << \\\"Passed!\\\" << std::endl;\\n    return true;\\n}\\n\\n/**\\n * Main program\\n **/\\nint main(int argc, char *argv[]) {\\n    int number, i;\\n\\n    if (argc == 2) {\\n        number = atoi(argv[1]);\\n    } else {\\n        std::cout << \\\"Enter the value of n(n starts from 0 ): \\\";\\n        std::cin >> number;\\n    }\\n\\n    large_number result;\\n\\n    std::clock_t start_time = std::clock();\\n    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */\\n        result *= i;\\n    std::clock_t end_time = std::clock();\\n    double time_taken =\\n        static_cast<double>(end_time - start_time) / CLOCKS_PER_SEC;\\n\\n    std::cout << number << \\\"! = \\\" << result << std::endl\\n              << \\\"Number of digits: \\\" << result.num_digits() << std::endl\\n              << \\\"Time taken: \\\" << std::scientific << time_taken << \\\" s\\\"\\n              << std::endl;\\n\\n    test1();\\n    test2();\\n    result.test();\\n\\n    return 0;\\n}\\n\"",
    "large number": "\"/**\\n * @file\\n * @brief Library to perform arithmatic operations on arbitrarily large\\n * numbers.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n\\n#ifndef MATH_LARGE_NUMBER_H_\\n#define MATH_LARGE_NUMBER_H_\\n#include <algorithm>\\n#include <cassert>\\n#include <cinttypes>\\n#include <cstring>\\n#include <iostream>\\n#include <type_traits>\\n#include <vector>\\n\\n/**\\n * Store large unsigned numbers as a C++ vector\\n * The class provides convenience functions to add a\\n * digit to the number, perform multiplication of\\n * large number with long unsigned integers.\\n **/\\nclass large_number {\\n public:\\n    /**< initializer with value = 1 */\\n    large_number() { _digits.push_back(1); }\\n\\n    // /**< initializer from an integer */\\n    // explicit large_number(uint64_t n) {\\n    //     uint64_t carry = n;\\n    //     do {\\n    //         add_digit(carry % 10);\\n    //         carry /= 10;\\n    //     } while (carry != 0);\\n    // }\\n\\n    /**< initializer from an integer */\\n    explicit large_number(int n) {\\n        int carry = n;\\n        do {\\n            add_digit(carry % 10);\\n            carry /= 10;\\n        } while (carry != 0);\\n    }\\n\\n    /**< initializer from another large_number */\\n    large_number(const large_number &a) : _digits(a._digits) {}\\n\\n    /**< initializer from a vector */\\n    explicit large_number(std::vector<unsigned char> &vec) : _digits(vec) {}\\n\\n    /**< initializer from a string */\\n    explicit large_number(char const *number_str) {\\n        for (size_t i = strlen(number_str); i > 0; i--) {\\n            char a = number_str[i - 1] - '0';\\n            if (a >= 0 && a <= 9)\\n                _digits.push_back(a);\\n        }\\n    }\\n\\n    /**\\n     * Function to check implementation\\n     **/\\n    static bool test() {\\n        std::cout << \\\"------ Checking `large_number` class implementations\\\\t\\\"\\n                  << std::endl;\\n        large_number a(40);\\n        // 1. test multiplication\\n        a *= 10;\\n        if (a != large_number(400)) {\\n            std::cerr << \\\"\\\\tFailed 1/6 (\\\" << a << \\\"!=400)\\\" << std::endl;\\n            return false;\\n        }\\n        std::cout << \\\"\\\\tPassed 1/6...\\\";\\n        // 2. test compound addition with integer\\n        a += 120;\\n        if (a != large_number(520)) {\\n            std::cerr << \\\"\\\\tFailed 2/6 (\\\" << a << \\\"!=520)\\\" << std::endl;\\n            return false;\\n        }\\n        std::cout << \\\"\\\\tPassed 2/6...\\\";\\n        // 3. test compound multiplication again\\n        a *= 10;\\n        if (a != large_number(5200)) {\\n            std::cerr << \\\"\\\\tFailed 3/6 (\\\" << a << \\\"!=5200)\\\" << std::endl;\\n            return false;\\n        }\\n        std::cout << \\\"\\\\tPassed 3/6...\\\";\\n        // 4. test increment (prefix)\\n        ++a;\\n        if (a != large_number(5201)) {\\n            std::cerr << \\\"\\\\tFailed 4/6 (\\\" << a << \\\"!=5201)\\\" << std::endl;\\n            return false;\\n        }\\n        std::cout << \\\"\\\\tPassed 4/6...\\\";\\n        // 5. test increment (postfix)\\n        a++;\\n        if (a != large_number(5202)) {\\n            std::cerr << \\\"\\\\tFailed 5/6 (\\\" << a << \\\"!=5202)\\\" << std::endl;\\n            return false;\\n        }\\n        std::cout << \\\"\\\\tPassed 5/6...\\\";\\n        // 6. test addition with another large number\\n        a = a + large_number(\\\"7000000000000000000000000000000\\\");\\n        if (a != large_number(\\\"7000000000000000000000000005202\\\")) {\\n            std::cerr << \\\"\\\\tFailed 6/6 (\\\" << a\\n                      << \\\"!=7000000000000000000000000005202)\\\" << std::endl;\\n            return false;\\n        }\\n        std::cout << \\\"\\\\tPassed 6/6...\\\" << std::endl;\\n        return true;\\n    }\\n\\n    /**\\n     * add a digit at MSB to the large number\\n     **/\\n    void add_digit(unsigned int value) {\\n        if (value > 9) {\\n            std::cerr << \\\"digit > 9!!\\\\n\\\";\\n            exit(EXIT_FAILURE);\\n        }\\n\\n        _digits.push_back(value);\\n    }\\n\\n    /**\\n     * Get number of digits in the number\\n     **/\\n    size_t num_digits() const { return _digits.size(); }\\n\\n    /**\\n     * operator over load to access the\\n     * i^th digit conveniently and also\\n     * assign value to it\\n     **/\\n    inline unsigned char &operator[](size_t n) { return this->_digits[n]; }\\n\\n    inline const unsigned char &operator[](size_t n) const {\\n        return this->_digits[n];\\n    }\\n\\n    /**\\n     * operator overload to compare two numbers\\n     **/\\n    friend std::ostream &operator<<(std::ostream &out, const large_number &a) {\\n        for (size_t i = a.num_digits(); i > 0; i--)\\n            out << static_cast<int>(a[i - 1]);\\n        return out;\\n    }\\n\\n    /**\\n     * operator overload to compare two numbers\\n     **/\\n    friend bool operator==(large_number const &a, large_number const &b) {\\n        size_t N = a.num_digits();\\n        if (N != b.num_digits())\\n            return false;\\n        for (size_t i = 0; i < N; i++)\\n            if (a[i] != b[i])\\n                return false;\\n        return true;\\n    }\\n\\n    /**\\n     * operator overload to compare two numbers\\n     **/\\n    friend bool operator!=(large_number const &a, large_number const &b) {\\n        return !(a == b);\\n    }\\n\\n    /**\\n     * operator overload to increment (prefix)\\n     **/\\n    large_number &operator++() {\\n        (*this) += 1;\\n        return *this;\\n    }\\n\\n    /**\\n     * operator overload to increment (postfix)\\n     **/\\n    large_number &operator++(int) {\\n        static large_number tmp(_digits);\\n        ++(*this);\\n        return tmp;\\n    }\\n\\n    /**\\n     * operator overload to add\\n     **/\\n    large_number &operator+=(large_number n) {\\n        // if adding with another large_number\\n        large_number *b = reinterpret_cast<large_number *>(&n);\\n        const size_t max_L = std::max(this->num_digits(), b->num_digits());\\n        unsigned int carry = 0;\\n        size_t i;\\n        for (i = 0; i < max_L || carry != 0; i++) {\\n            if (i < b->num_digits())\\n                carry += (*b)[i];\\n            if (i < this->num_digits())\\n                carry += (*this)[i];\\n            if (i < this->num_digits())\\n                (*this)[i] = carry % 10;\\n            else\\n                this->add_digit(carry % 10);\\n            carry /= 10;\\n        }\\n        return *this;\\n    }\\n\\n    large_number &operator+=(int n) { return (*this) += large_number(n); }\\n    // large_number &operator+=(uint64_t n) { return (*this) += large_number(n);\\n    // }\\n\\n    /**\\n     * operator overload to perform addition\\n     **/\\n    template <class T>\\n    friend large_number &operator+(const large_number &a, const T &b) {\\n        static large_number c = a;\\n        c += b;\\n        return c;\\n    }\\n\\n    /**\\n     * assignment operator\\n     **/\\n    large_number &operator=(const large_number &b) {\\n        this->_digits = b._digits;\\n        return *this;\\n    }\\n\\n    /**\\n     * operator overload to increment\\n     **/\\n    template <class T>\\n    large_number &operator*=(const T n) {\\n        static_assert(std::is_integral<T>::value,\\n                      \\\"Must be integer addition unsigned integer types.\\\");\\n        this->multiply(n);\\n        return *this;\\n    }\\n\\n    /**\\n     * returns i^th digit as an ASCII character\\n     **/\\n    char digit_char(size_t i) const {\\n        return _digits[num_digits() - i - 1] + '0';\\n    }\\n\\n private:\\n    /**\\n     * multiply large number with another integer and\\n     * store the result in the same large number\\n     **/\\n    template <class T>\\n    void multiply(const T n) {\\n        static_assert(std::is_integral<T>::value,\\n                      \\\"Can only have integer types.\\\");\\n        // assert(!(std::is_signed<T>::value)); //, \\\"Implemented only for\\n        // unsigned integer types.\\\");\\n\\n        size_t i;\\n        uint64_t carry = 0, temp;\\n        for (i = 0; i < this->num_digits(); i++) {\\n            temp = static_cast<uint64_t>((*this)[i]) * n;\\n            temp += carry;\\n            if (temp < 10) {\\n                carry = 0;\\n            } else {\\n                carry = temp / 10;\\n                temp = temp % 10;\\n            }\\n            (*this)[i] = temp;\\n        }\\n\\n        while (carry != 0) {\\n            this->add_digit(carry % 10);\\n            carry /= 10;\\n        }\\n    }\\n\\n    std::vector<unsigned char>\\n        _digits; /**< where individual digits are stored */\\n};\\n\\n#endif  // MATH_LARGE_NUMBER_H_\\n\"",
    "lcm sum": "\"/**\\n * @file\\n * @brief An algorithm to calculate the sum of LCM: \\\\f$\\\\mathrm{LCM}(1,n) +\\n * \\\\mathrm{LCM}(2,n) + \\\\ldots + \\\\mathrm{LCM}(n,n)\\\\f$\\n * @details An algorithm to calculate the sum of LCM: \\\\f$\\\\mathrm{LCM}(1,n) +\\n * \\\\mathrm{LCM}(2,n) + \\\\ldots + \\\\mathrm{LCM}(n,n)\\\\f$ where\\n * \\\\f$\\\\mathrm{LCM}(i,n)\\\\f$ denotes the Least Common Multiple of the integers i\\n * and n. For n greater than or equal to 1. The value of the sum is calculated\\n * by formula: \\\\f[ \\\\sum\\\\mathrm{LCM}(i, n) = \\\\frac{1}{2} \\\\left[\\\\left(\\\\sum (d *\\n * \\\\mathrm{ETF}(d)) + 1\\\\right) * n\\\\right] \\\\f] where \\\\mathrm{ETF}(i) represents\\n * Euler totient function of i.\\n * @author [Chesta Mittal](https://github.com/chestamittal)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for std::cin and std::cout\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * Function to compute sum of euler totients in sumOfEulerTotient vector\\n * @param num input number\\n * @returns int Sum of LCMs, i.e. ∑LCM(i, num) from i = 1 to num\\n */\\nuint64_t lcmSum(const uint16_t& num) {\\n    uint64_t i = 0, j = 0;\\n    std::vector<uint64_t> eulerTotient(num + 1);\\n    std::vector<uint64_t> sumOfEulerTotient(num + 1);\\n\\n    // storing initial values in eulerTotient vector\\n    for (i = 1; i <= num; i++) {\\n        eulerTotient[i] = i;\\n    }\\n\\n    // applying totient sieve\\n    for (i = 2; i <= num; i++) {\\n        if (eulerTotient[i] == i) {\\n            for (j = i; j <= num; j += i) {\\n                eulerTotient[j] = eulerTotient[j] / i;\\n                eulerTotient[j] = eulerTotient[j] * (i - 1);\\n            }\\n        }\\n    }\\n\\n    // computing sum of euler totients\\n    for (i = 1; i <= num; i++) {\\n        for (j = i; j <= num; j += i) {\\n            sumOfEulerTotient[j] += eulerTotient[i] * i;\\n        }\\n    }\\n\\n    return ((sumOfEulerTotient[num] + 1) * num) / 2;\\n}\\n}  // namespace math\\n\\n/**\\n * Function for testing lcmSum function.\\n * test cases and assert statement.\\n * @returns `void`\\n */\\nstatic void test() {\\n    uint64_t n = 2;\\n    uint64_t test_1 = math::lcmSum(n);\\n    assert(test_1 == 4);\\n    std::cout << \\\"Passed Test 1!\\\" << std::endl;\\n\\n    n = 5;\\n    uint64_t test_2 = math::lcmSum(n);\\n    assert(test_2 == 55);\\n    std::cout << \\\"Passed Test 2!\\\" << std::endl;\\n\\n    n = 10;\\n    uint64_t test_3 = math::lcmSum(n);\\n    assert(test_3 == 320);\\n    std::cout << \\\"Passed Test 3!\\\" << std::endl;\\n\\n    n = 11;\\n    uint64_t test_4 = math::lcmSum(n);\\n    assert(test_4 == 616);\\n    std::cout << \\\"Passed Test 4!\\\" << std::endl;\\n\\n    n = 15;\\n    uint64_t test_5 = math::lcmSum(n);\\n    assert(test_5 == 1110);\\n    std::cout << \\\"Passed Test 5!\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // execute the tests\\n    return 0;\\n}\\n\"",
    "least common multiple": "\"/**\\n * Copyright 2020 @author tjgurwara99\\n * @file\\n *\\n * A basic implementation of LCM function\\n */\\n\\n#include <cassert>\\n#include <iostream>\\n\\n/**\\n * Function for finding greatest common divisor of two numbers.\\n * @params two integers x and y whose gcd we want to find.\\n * @return greatest common divisor of x and y.\\n */\\nunsigned int gcd(unsigned int x, unsigned int y) {\\n    if (x == 0) {\\n        return y;\\n    }\\n    if (y == 0) {\\n        return x;\\n    }\\n    if (x == y) {\\n        return x;\\n    }\\n    if (x > y) {\\n        // The following is valid because we have checked whether y == 0\\n\\n        unsigned int temp = x / y;\\n        return gcd(y, x - temp * y);\\n    }\\n    // Again the following is valid because we have checked whether x == 0\\n\\n    unsigned int temp = y / x;\\n    return gcd(x, y - temp * x);\\n}\\n\\n/**\\n * Function for finding the least common multiple of two numbers.\\n * @params integer x and y whose lcm we want to find.\\n * @return lcm of x and y using the relation x * y = gcd(x, y) * lcm(x, y)\\n */\\nunsigned int lcm(unsigned int x, unsigned int y) {\\n  return x / gcd(x, y) * y;\\n}\\n\\n/**\\n * Function for testing the lcm() functions with some assert statements.\\n */\\nvoid tests() {\\n    // First test on lcm(5,10) == 10\\n    assert(((void)\\\"LCM of 5 and 10 is 10 but lcm function gives a different \\\"\\n                  \\\"result.\\\\n\\\",\\n            lcm(5, 10) == 10));\\n    std::cout << \\\"First assertion passes: LCM of 5 and 10 is \\\" << lcm(5, 10)\\n              << std::endl;\\n\\n    // Second test on lcm(2,3) == 6 as 2 and 3 are coprime (prime in fact)\\n    assert(((void)\\\"LCM of 2 and 3 is 6 but lcm function gives a different \\\"\\n                  \\\"result.\\\\n\\\",\\n            lcm(2, 3) == 6));\\n    std::cout << \\\"Second assertion passes: LCM of 2 and 3 is \\\" << lcm(2, 3)\\n              << std::endl;\\n\\n    // Testing an integer overflow.\\n    // The algorithm should work as long as the result fits into integer.\\n    assert(((void)\\\"LCM of 987654321 and 987654321 is 987654321 but lcm function\\\"\\n                  \\\" gives a different result.\\\\n\\\",\\n            lcm(987654321, 987654321) == 987654321));\\n    std::cout << \\\"Third assertion passes: LCM of 987654321 and 987654321 is \\\"\\n              << lcm(987654321, 987654321)\\n              << std::endl;\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    tests();\\n    return 0;\\n}\\n\"",
    "linear recurrence matrix": "\"/**\\n * @brief Evaluate recurrence relation using [matrix\\n * exponentiation](https://www.hackerearth.com/practice/notes/matrix-exponentiation-1/).\\n * @details\\n * Given a recurrence relation; evaluate the value of nth term.\\n * For e.g., For fibonacci series, recurrence series is `f(n) = f(n-1) + f(n-2)`\\n * where `f(0) = 0` and `f(1) = 1`.\\n * Note that the method used only demonstrates\\n * recurrence relation with one variable (n), unlike `nCr` problem, since it has\\n * two (n, r)\\n *\\n * ### Algorithm\\n * This problem can be solved using matrix exponentiation method.\\n * @see here for simple [number exponentiation\\n * algorithm](https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_exponentiation.cpp)\\n * or [explaination\\n * here](https://en.wikipedia.org/wiki/Exponentiation_by_squaring).\\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\\n */\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector STL\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @namespace linear_recurrence_matrix\\n * @brief Functions for [Linear Recurrence\\n * Matrix](https://www.hackerearth.com/practice/notes/matrix-exponentiation-1/)\\n * implementation.\\n */\\nnamespace linear_recurrence_matrix {\\n/**\\n * @brief Implementation of matrix multiplication\\n * @details Multiplies matrix A and B, given total columns in A are equal to\\n * total given rows in column B\\n * @tparam T template type for integer as well as floating values, default is\\n * long long int\\n * @param _mat_a first matrix of size n * m\\n * @param _mat_b second matrix of size m * k\\n * @returns `_mat_c` resultant matrix of size n * k\\n * Complexity: `O(n*m*k)`\\n * @note The complexity in this case will be O(n^3) due to the nature of the\\n * problem. We'll be multiplying the matrix with itself most of the time.\\n */\\ntemplate <typename T = int64_t>\\nstd::vector<std::vector<T>> matrix_multiplication(\\n    const std::vector<std::vector<T>>& _mat_a,\\n    const std::vector<std::vector<T>>& _mat_b, const int64_t mod = 1000000007) {\\n    // assert that columns in `_mat_a` and rows in `_mat_b` are equal\\n    assert(_mat_a[0].size() == _mat_b.size());\\n    std::vector<std::vector<T>> _mat_c(_mat_a.size(),\\n                                       std::vector<T>(_mat_b[0].size(), 0));\\n    /**\\n     * Actual matrix multiplication.\\n     */\\n    for (uint32_t i = 0; i < _mat_a.size(); ++i) {\\n        for (uint32_t j = 0; j < _mat_b[0].size(); ++j) {\\n            for (uint32_t k = 0; k < _mat_b.size(); ++k) {\\n                _mat_c[i][j] =\\n                    (_mat_c[i][j] % mod +\\n                     (_mat_a[i][k] % mod * _mat_b[k][j] % mod) % mod) %\\n                    mod;\\n            }\\n        }\\n    }\\n    return _mat_c;\\n}\\n/**\\n * @brief Returns whether matrix `mat` is a [zero\\n * matrix.](https://en.wikipedia.org/wiki/Zero_matrix)\\n * @tparam T template type for integer as well as floating values, default is\\n * long long int\\n * @param _mat A matrix\\n * @returns true if it is a zero matrix else false\\n */\\ntemplate <typename T = int64_t>\\nbool is_zero_matrix(const std::vector<std::vector<T>>& _mat) {\\n    for (uint32_t i = 0; i < _mat.size(); ++i) {\\n        for (uint32_t j = 0; j < _mat[i].size(); ++j) {\\n            if (_mat[i][j] != 0) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * @brief Implementation of Matrix exponentiation\\n * @details returns the matrix exponentiation `(B^n)` in `k^3 * O(log2(power))`\\n * time, where `k` is the size of matrix (k by k).\\n * @tparam T template type for integer as well as floating values, default is\\n * long long int\\n * @param _mat matrix for exponentiation\\n * @param power the exponent value\\n * @returns the matrix _mat to the power `power (_mat^power)`\\n */\\ntemplate <typename T = int64_t>\\nstd::vector<std::vector<T>> matrix_exponentiation(\\n    std::vector<std::vector<T>> _mat, uint64_t power,\\n    const int64_t mod = 1000000007) {\\n    /**\\n     * Initializing answer as identity matrix. For simple binary\\n     * exponentiation reference, [see\\n     * here](https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_exponentiation.cpp)\\n     */\\n    if (is_zero_matrix(_mat)) {\\n        return _mat;\\n    }\\n\\n    std::vector<std::vector<T>> _mat_answer(_mat.size(),\\n                                            std::vector<T>(_mat.size(), 0));\\n\\n    for (uint32_t i = 0; i < _mat.size(); ++i) {\\n        _mat_answer[i][i] = 1;\\n    }\\n    // exponentiation algorithm here.\\n    while (power > 0) {\\n        if (power & 1) {\\n            _mat_answer = matrix_multiplication(_mat_answer, _mat, mod);\\n        }\\n        power >>= 1;\\n        _mat = matrix_multiplication(_mat, _mat, mod);\\n    }\\n\\n    return _mat_answer;\\n}\\n\\n/**\\n * @brief Implementation of nth recurrence series.\\n * @details Returns the nth term in the recurrence series.\\n * Note that the function assumes definition of base cases from `n = 0`\\n * (e.g., for fibonacci, `f(0)` has a defined value `0`)\\n * @tparam T template type for integer as well as floating values, default is\\n * long long int\\n * @param _mat [square matrix](https://en.m.wikipedia.org/wiki/Square_matrix)\\n * that evaluates the nth term using exponentiation\\n * @param _base_cases 2D array of dimension `1*n` containing values which are\\n * defined for some n (e.g., for fibonacci, `f(0)` and `f(1)` are defined, and\\n * `f(n)` where `n > 1` is evaluated on previous two values)\\n * @param nth_term the nth term of recurrence relation\\n * @param constant_or_sum_included whether the recurrence relation has a\\n * constant value or is evaluating sum of first n terms of the recurrence.\\n * @returns the nth term of the recurrence relation in `O(k^3. log(n))`, where k\\n * is number of rows and columns in `_mat` and `n` is the value of `nth_term`\\n * If constant_or_sum_included is true, returns the sum of first n terms in\\n * recurrence series\\n */\\ntemplate <typename T = int64_t>\\nT get_nth_term_of_recurrence_series(\\n    const std::vector<std::vector<T>>& _mat,\\n    const std::vector<std::vector<T>>& _base_cases, uint64_t nth_term,\\n    bool constant_or_sum_included = false) {\\n    assert(_mat.size() == _base_cases.back().size());\\n\\n    /**\\n     * If nth term is a base case, then return base case directly.\\n     */\\n\\n    if (nth_term < _base_cases.back().size() - constant_or_sum_included) {\\n        return _base_cases.back()[nth_term - constant_or_sum_included];\\n    } else {\\n        /**\\n         * Else evaluate the expression, so multiplying _mat to itself (n -\\n         * base_cases.length + 1 + constant_or_sum_included) times.\\n         */\\n        std::vector<std::vector<T>> _res_matrix =\\n            matrix_exponentiation(_mat, nth_term - _base_cases.back().size() +\\n                                            1 + constant_or_sum_included);\\n\\n        /**\\n         * After matrix exponentiation, multiply with the base case to evaluate\\n         * the answer. The answer is always at the end of the array.\\n         */\\n        std::vector<std::vector<T>> _res =\\n            matrix_multiplication(_base_cases, _res_matrix);\\n\\n        return _res.back().back();\\n    }\\n}\\n}  // namespace linear_recurrence_matrix\\n}  // namespace math\\n\\n/**\\n * @brief Self test-implementations\\n * @returns void\\n */\\nstatic void test() {\\n    /*\\n     * Example 1: [Fibonacci\\n     * series](https://en.wikipedia.org/wiki/Fibonacci_number);\\n     *\\n     * [fn-2    fn-1]  [0      1]  ==   [fn-1   (fn-2 + fn-1)] => [fn-1   fn]\\n     *                 [1      1]\\n     *\\n     * Let A = [fn-2   fn-1], and B = [0   1]\\n     *                                [1   1],\\n     *\\n     * Since, A.B....(n-1 times) = [fn-1   fn]\\n     * we can multiply B with itself n-1 times to obtain the required value\\n     */\\n    std::vector<std::vector<int64_t>> fibonacci_matrix = {{0, 1}, {1, 1}},\\n                                      fib_base_case = {{0, 1}};\\n\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               fibonacci_matrix, fib_base_case, 11) == 89LL);\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               fibonacci_matrix, fib_base_case, 39) == 63245986LL);\\n    /*\\n     * Example 2: [Tribonacci series](https://oeis.org/A000073)\\n     *                    [0   0   1]\\n     * [fn-3  fn-2  fn-1] [1   0   1]  =  [(fn-2)  (fn-1)  (fn-3 + fn-2 + fn-1)]\\n     *                    [0   1   1]\\n     *                                 => [fn-2     fn-1    fn]\\n     *\\n     *                                       [0   0   1]\\n     * Let A = [fn-3   fn-2   fn-1], and B = [1   0   1]\\n     *                                       [0   1   1]\\n     *\\n     * Since, A.B....(n-2 times) = [fn-2  fn-1   fn]\\n     * we will have multiply B with itself n-2 times to obtain the required\\n     * value ()\\n     */\\n\\n    std::vector<std::vector<int64_t>> tribonacci = {{0, 0, 1},\\n                                                    {1, 0, 1},\\n                                                    {0, 1, 1}},\\n                                      trib_base_case = {\\n                                          {0, 0, 1}};  // f0 = 0, f1 = 0, f2 = 1\\n\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               tribonacci, trib_base_case, 11) == 149LL);\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               tribonacci, trib_base_case, 36) == 615693474LL);\\n\\n    /*\\n     * Example 3: [Pell numbers](https://oeis.org/A000129)\\n     * `f(n)  = 2* f(n-1) + f(n-2); f(0) = f(1) = 2`\\n     *\\n     * [fn-2  fn-1] [0   1]  =  [(fn-1)  fn-2 + 2*fn-1)]\\n     *              [1   2]\\n     *                       => [fn-1     fn]\\n     *\\n     * Let A = [fn-2  fn-1], and B = [0   1]\\n     *                               [1   2]\\n     */\\n\\n    std::vector<std::vector<int64_t>> pell_recurrence = {{0, 1}, {1, 2}},\\n                                      pell_base_case = {\\n                                          {2, 2}};  // `f0 = 2, f1 = 2`\\n\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               pell_recurrence, pell_base_case, 15) == 551614LL);\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               pell_recurrence, pell_base_case, 23) == 636562078LL);\\n\\n    /*\\n     * Example 4: Custom recurrence relation:\\n     * Now the recurrence is of the form `a*f(n-1) + b*(fn-2) + ... + c`\\n     * where `c` is the constant\\n     * `f(n)  = 2* f(n-1) + f(n-2) + 7; f(0) = f(1) = 2, c = 7`\\n     *\\n     *                   [1   0   1]\\n     * [7,  fn-2,  fn-1] [0   0   1]\\n     *                   [0   1   2]\\n     * =  [7,  (fn-1),  fn-2 + 2*fn-1) + 7]\\n     *\\n     * => [7,    fn-1,     fn]\\n     * :: Series will be 2, 2, 13, 35, 90, 222, 541, 1311, 3170, 7658, 18493,\\n     * 44651, 107802, 260262, 628333, 1516935, 362210, 8841362, 21344941,\\n     * 51531251\\n     *\\n     * Let A = [7,  fn-2,  fn-1], and B = [1   0   1]\\n     *                                    [0   0   1]\\n     *                                    [0   1   2]\\n     */\\n\\n    std::vector<std::vector<int64_t>>\\n        custom_recurrence = {{1, 0, 1}, {0, 0, 1}, {0, 1, 2}},\\n        custom_base_case = {{7, 2, 2}};  // `c = 7, f0 = 2, f1 = 2`\\n\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               custom_recurrence, custom_base_case, 10, 1) == 18493LL);\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               custom_recurrence, custom_base_case, 19, 1) == 51531251LL);\\n\\n    /*\\n     * Example 5: Sum fibonacci sequence\\n     * The following matrix evaluates the sum of first n fibonacci terms in\\n     * O(27. log2(n)) time.\\n     * `f(n) = f(n-1) + f(n-2); f(0) = 0, f(1) = 1`\\n     *\\n     *                           [1   0   0]\\n     * [s(f, n-1),  fn-2,  fn-1] [1   0   1]\\n     *                           [1   1   1]\\n     *   => [(s(f, n-1)+f(n-2)+f(n-1)), (fn-1),  f(n-2)+f(n-1)]\\n     *\\n     *   => [s(f, n-1)+f(n),    fn-1,     fn]\\n     *\\n     *   => [s(f, n),    fn-1,     fn]\\n     *\\n     * Sum of first 20 fibonacci series:\\n     * 0, 1, 2, 4, 7, 12, 20, 33, 54, 88, 143, 232, 376, 609, 986, 1596, 2583,\\n     * 4180, 6764\\n     *          f0  f1  s(f,1)\\n     * Let A = [0    1    1], and B = [0   1   1]\\n     *                                [1   1   1]\\n     *                                [0   0   1]\\n     */\\n\\n    std::vector<std::vector<int64_t>> sum_fibo_recurrence = {{0, 1, 1},\\n                                                             {1, 1, 1},\\n                                                             {0, 0, 1}},\\n                                      sum_fibo_base_case = {\\n                                          {0, 1, 1}};  // `f0 = 0, f1 = 1`\\n\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               sum_fibo_recurrence, sum_fibo_base_case, 13, 1) == 609LL);\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               sum_fibo_recurrence, sum_fibo_base_case, 16, 1) == 2583LL);\\n    /*\\n     * Example 6: [Tribonacci sum series](https://oeis.org/A000073)\\n     *                               [0   0   1   1]\\n     * [fn-3  fn-2  fn-1  s(f, n-1)] [1   0   1   1]\\n     *                               [0   1   1   1]\\n     *                               [0   0   0   1]\\n     *\\n     * = [fn-2, fn-1, fn-3 + fn-2 + fn-1, (fn-3 + fn-2 + fn-1 + s(f, n-1))]\\n     *\\n     * => [fn-2, fn-1, fn,  fn + s(f, n-1)]\\n     *\\n     * => [fn-2, fn-1, fn, s(f, n)]\\n     *\\n     * Sum of the series is: 0, 0, 1, 2, 4, 8, 15, 28, 52, 96, 177, 326, 600,\\n     * 1104, 2031, 3736, 6872, 12640, 23249, 42762\\n     *\\n     * Let A = [fn-3   fn-2   fn-1   s(f, n-1)], and\\n     *     [0   0   1   1]\\n     * B = [1   0   1   1]\\n     *     [0   1   1   1]\\n     *     [0   0   0   1]\\n     *\\n     * Since, A.B....(n-2 times) = [fn-2  fn-1   fn]\\n     * we will have multiply B with itself n-2 times to obtain the required\\n     * value\\n     */\\n\\n    std::vector<std::vector<int64_t>> tribonacci_sum = {{0, 0, 1, 1},\\n                                                        {1, 0, 1, 1},\\n                                                        {0, 1, 1, 1},\\n                                                        {0, 0, 0, 1}},\\n                                      trib_sum_base_case = {{0, 0, 1, 1}};\\n    // `f0 = 0, f1 = 0, f2 = 1, s = 1`\\n\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               tribonacci_sum, trib_sum_base_case, 18, 1) == 23249LL);\\n    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(\\n               tribonacci_sum, trib_sum_base_case, 19, 1) == 42762LL);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "magic number": "\"/**\\n * @file\\n * @brief A simple program to check if the given number is a magic number or\\n * not. A number is said to be a magic number, if the sum of its digits are\\n * calculated till a single digit recursively by adding the sum of the digits\\n * after every addition. If the single digit comes out to be 1,then the number\\n * is a magic number.\\n *\\n * This is a shortcut method to verify Magic Number.\\n * On dividing the input by 9, if the remainder is 1 then the number is a magic\\n * number else not. The divisibility rule of 9 says that a number is divisible\\n * by 9 if the sum of its digits are also divisible by 9. Therefore, if a number\\n * is divisible by 9, then, recursively, all the digit sums are also divisible\\n * by 9. The final digit sum is always 9. An increase of 1 in the original\\n * number will increase the ultimate value by 1, making it 10 and the ultimate\\n * sum will be 1, thus verifying that it is a magic number.\\n * @author [Neha Hasija](https://github.com/neha-hasija17)\\n */\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for io operations\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * Function to check if the given number is magic number or not.\\n * @param n number to be checked.\\n * @return if number is a magic number, returns true, else false.\\n */\\nbool magic_number(const uint64_t &n) {\\n    if (n <= 0) {\\n        return false;\\n    }\\n    // result stores the modulus of @param n with 9\\n    uint64_t result = n % 9;\\n    // if result is 1 then the number is a magic number else not\\n    if (result == 1) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n}  // namespace math\\n\\n/**\\n * @brief Test function\\n * @returns void\\n */\\nstatic void tests() {\\n    std::cout << \\\"Test 1:\\\\t n=60\\\\n\\\";\\n    assert(math::magic_number(60) == false);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Test 2:\\\\t n=730\\\\n\\\";\\n    assert(math::magic_number(730) == true);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Test 3:\\\\t n=0\\\\n\\\";\\n    assert(math::magic_number(0) == false);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Test 4:\\\\t n=479001600\\\\n\\\";\\n    assert(math::magic_number(479001600) == false);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Test 5:\\\\t n=-35\\\\n\\\";\\n    assert(math::magic_number(-35) == false);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    tests();  // execute the tests\\n    return 0;\\n}\\n\"",
    "miller rabin": "\"/**\\n * Copyright 2020 @author tjgurwara99\\n * @file\\n *\\n * A basic implementation of Miller-Rabin primality test.\\n */\\n\\n#include <cassert>\\n#include <iostream>\\n#include <random>\\n#include <vector>\\n\\n/**\\n * Function to give a binary representation of a number in reverse order\\n * @param num integer number that we want to convert\\n * @return result vector of the number input in reverse binary\\n */\\ntemplate <typename T>\\nstd::vector<T> reverse_binary(T num) {\\n    std::vector<T> result;\\n    T temp = num;\\n    while (temp > 0) {\\n        result.push_back(temp % 2);\\n        temp = temp / 2;\\n    }\\n    return result;\\n}\\n\\n/**\\n * Function for modular exponentiation.\\n * This function is an efficient modular exponentiation function.\\n * It can be used with any big integer library such as Boost multiprecision\\n * to give result any modular exponentiation problem relatively quickly.\\n * @param base number being raised to a power as integer\\n * @param rev_binary_exponent reverse binary of the power the base is being\\n * raised to\\n * @param mod modulo\\n * @return r the modular exponentiation of \\\\f$a^{n} \\\\equiv r \\\\mod{m}\\\\f$ where\\n * \\\\f$n\\\\f$ is the base 10 representation of rev_binary_exponent and \\\\f$m = mod\\n * \\\\f$ parameter.\\n */\\ntemplate <typename T>\\nT modular_exponentiation(T base, const std::vector<T> &rev_binary_exponent,\\n                         T mod) {\\n    if (mod == 1)\\n        return 0;\\n    T b = 1;\\n    if (rev_binary_exponent.size() == 0)\\n        return b;\\n    T A = base;\\n    if (rev_binary_exponent[0] == 1)\\n        b = base;\\n\\n    for (typename std::vector<T>::const_iterator it =\\n             rev_binary_exponent.cbegin() + 1;\\n         it != rev_binary_exponent.cend(); ++it) {\\n        A = A * A % mod;\\n        if (*it == 1)\\n            b = A * b % mod;\\n    }\\n    return b;\\n}\\n\\n/** Function for testing the conditions that are satisfied when a number is\\n * prime.\\n * \\t@param d number such that \\\\f$d \\\\cdot 2^r = n - 1\\\\f$ where \\\\f$n = num\\\\f$\\n * parameter and \\\\f$r \\\\geq 1\\\\f$\\n * \\t@param num number being tested for primality.\\n * \\t@return 'false' if n is composite\\n * \\t@return 'true' if n is (probably) prime.\\n */\\ntemplate <typename T>\\nbool miller_test(T d, T num) {\\n    // random number seed\\n    std::random_device rd_seed;\\n    // random number generator\\n    std::mt19937 gen(rd_seed());\\n    // Uniformly distributed range [2, num - 2] for random numbers\\n    std::uniform_int_distribution<> distribution(2, num - 2);\\n    // Random number generated in the range [2, num -2].\\n    T random = distribution(gen);\\n    // vector for reverse binary of the power\\n    std::vector<T> power = reverse_binary(d);\\n    // x = random ^ d % num\\n    T x = modular_exponentiation(random, power, num);\\n    // miller conditions\\n    if (x == 1 || x == num - 1) {\\n        return true;\\n    }\\n\\n    while (d != num - 1) {\\n        x = (x * x) % num;\\n        d *= 2;\\n        if (x == 1) {\\n            return false;\\n        }\\n        if (x == num - 1) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n/**\\n * Function that test (probabilistically) whether a given number is a prime\\n * based on the Miller-Rabin Primality Test.\\n * @param num number to be tested for primality.\\n * @param repeats number of repetitions for the test to increase probability of\\n * correct result.\\n * @return 'false' if num is composite\\n * @return 'true' if num is (probably) prime\\n *\\n * \\\\detail\\n * First we check whether the num input is less than 4, if so we can determine\\n * whether this is a prime or composite by checking for 2 and 3.\\n * Next we check whether this num is odd (as all primes greater than 2 are odd).\\n * Next we write our num in the following format \\\\f$num = 2^r \\\\cdot d + 1\\\\f$.\\n * After finding r and d for our input num, we use for loop repeat number of\\n * times inside which we check the miller conditions using the function\\n * miller_test. If miller_test returns false then the number is composite After\\n * the loop finishes completely without issuing a false return call, we can\\n * conclude that this number is probably prime.\\n */\\ntemplate <typename T>\\nbool miller_rabin_primality_test(T num, T repeats) {\\n    if (num <= 4) {\\n        // If num == 2 or num == 3 then prime\\n        if (num == 2 || num == 3) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    // If num is even then not prime\\n    if (num % 2 == 0) {\\n        return false;\\n    }\\n    // Finding d and r in num = 2^r * d + 1\\n    T d = num - 1, r = 0;\\n    while (d % 2 == 0) {\\n        d = d / 2;\\n        r++;\\n    }\\n\\n    for (T i = 0; i < repeats; ++i) {\\n        if (!miller_test(d, num)) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * Functions for testing the miller_rabin_primality_test() function with some\\n * assert statements.\\n */\\nvoid tests() {\\n    // First test on 2\\n    assert(((void)\\\"2 is prime but function says otherwise.\\\\n\\\",\\n            miller_rabin_primality_test(2, 1) == true));\\n    std::cout << \\\"First test passes.\\\" << std::endl;\\n    // Second test on 5\\n    assert(((void)\\\"5 should be prime but the function says otherwise.\\\\n\\\",\\n            miller_rabin_primality_test(5, 3) == true));\\n    std::cout << \\\"Second test passes.\\\" << std::endl;\\n    // Third test on 23\\n    assert(((void)\\\"23 should be prime but the function says otherwise.\\\\n\\\",\\n            miller_rabin_primality_test(23, 3) == true));\\n    std::cout << \\\"Third test passes.\\\" << std::endl;\\n    // Fourth test on 16\\n    assert(((void)\\\"16 is not a prime but the function says otherwise.\\\\n\\\",\\n            miller_rabin_primality_test(16, 3) == false));\\n    std::cout << \\\"Fourth test passes.\\\" << std::endl;\\n    // Fifth test on 27\\n    assert(((void)\\\"27 is not a prime but the function says otherwise.\\\\n\\\",\\n            miller_rabin_primality_test(27, 3) == false));\\n    std::cout << \\\"Fifth test passes.\\\" << std::endl;\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    tests();\\n    return 0;\\n}\\n\"",
    "modular division": "\"/**\\n * @file\\n * @brief An algorithm to divide two numbers under modulo p [Modular\\n * Division](https://www.geeksforgeeks.org/modular-division)\\n * @details To calculate division of two numbers under modulo p\\n * Modulo operator is not distributive under division, therefore\\n * we first have to calculate the inverse of divisor using\\n * [Fermat's little\\n theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)\\n * Now, we can multiply the dividend with the inverse of divisor\\n * and modulo is distributive over multiplication operation.\\n * Let,\\n * We have 3 numbers a, b, p\\n * To compute (a/b)%p\\n * (a/b)%p ≡ (a*(inverse(b)))%p ≡ ((a%p)*inverse(b)%p)%p\\n * NOTE: For the existence of inverse of 'b', 'b' and 'p' must be coprime\\n * For simplicity we take p as prime\\n * Time Complexity: O(log(b))\\n * Example: ( 24 / 3 ) % 5 => 8 % 5 = 3 --- (i)\\n            Now the inverse of 3 is 2\\n            (24 * 2) % 5 = (24 % 5) * (2 % 5) = (4 * 2) % 5 = 3 --- (ii)\\n            (i) and (ii) are equal hence the answer is correct.\\n * @see modular_inverse_fermat_little_theorem.cpp, modular_exponentiation.cpp\\n * @author [Shubham Yadav](https://github.com/shubhamamsa)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @namespace modular_division\\n * @brief Functions for [Modular\\n * Division](https://www.geeksforgeeks.org/modular-division) implementation\\n */\\nnamespace modular_division {\\n/**\\n * @brief This function calculates a raised to exponent b under modulo c using\\n * modular exponentiation.\\n * @param a integer base\\n * @param b unsigned integer exponent\\n * @param c integer modulo\\n * @return a raised to power b modulo c\\n */\\nuint64_t power(uint64_t a, uint64_t b, uint64_t c) {\\n    uint64_t ans = 1;  /// Initialize the answer to be returned\\n    a = a % c;         /// Update a if it is more than or equal to c\\n    if (a == 0) {\\n        return 0;  /// In case a is divisible by c;\\n    }\\n    while (b > 0) {\\n        /// If b is odd, multiply a with answer\\n        if (b & 1) {\\n            ans = ((ans % c) * (a % c)) % c;\\n        }\\n        /// b must be even now\\n        b = b >> 1;  /// b = b/2\\n        a = ((a % c) * (a % c)) % c;\\n    }\\n    return ans;\\n}\\n\\n/**\\n * @brief This function calculates modular division\\n * @param a integer dividend\\n * @param b integer divisor\\n * @param p integer modulo\\n * @return a/b modulo c\\n */\\nuint64_t mod_division(uint64_t a, uint64_t b, uint64_t p) {\\n    uint64_t inverse = power(b, p - 2, p) % p;  /// Calculate the inverse of b\\n    uint64_t result =\\n        ((a % p) * (inverse % p)) % p;  /// Calculate the final result\\n    return result;\\n}\\n}  // namespace modular_division\\n}  // namespace math\\n\\n/**\\n * Function for testing power function.\\n * test cases and assert statement.\\n * @returns `void`\\n */\\nstatic void test() {\\n    uint64_t test_case_1 = math::modular_division::mod_division(8, 2, 2);\\n    assert(test_case_1 == 0);\\n    std::cout << \\\"Test 1 Passed!\\\" << std::endl;\\n    uint64_t test_case_2 = math::modular_division::mod_division(15, 3, 7);\\n    assert(test_case_2 == 5);\\n    std::cout << \\\"Test 2 Passed!\\\" << std::endl;\\n    uint64_t test_case_3 = math::modular_division::mod_division(10, 5, 2);\\n    assert(test_case_3 == 0);\\n    std::cout << \\\"Test 3 Passed!\\\" << std::endl;\\n    uint64_t test_case_4 = math::modular_division::mod_division(81, 3, 5);\\n    assert(test_case_4 == 2);\\n    std::cout << \\\"Test 4 Passed!\\\" << std::endl;\\n    uint64_t test_case_5 = math::modular_division::mod_division(12848, 73, 29);\\n    assert(test_case_5 == 2);\\n    std::cout << \\\"Test 5 Passed!\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, char *argv[]) {\\n    test();  // execute the tests\\n    return 0;\\n}\\n\"",
    "modular exponentiation": "\"/**\\n * @file\\n * @brief C++ Program for Modular Exponentiation Iteratively.\\n * @details The task is to calculate the value of an integer a raised to an\\n * integer exponent b under modulo c.\\n * @note The time complexity of this approach is O(log b).\\n *\\n * Example:\\n * (4^3) % 5 (where ^ stands for exponentiation and % for modulo)\\n * (4*4*4) % 5\\n * (4 % 5) * ( (4*4) % 5 )\\n * 4 * (16 % 5)\\n * 4 * 1\\n * 4\\n * We can also verify the result as 4^3 is 64 and 64 modulo 5 is 4\\n *\\n * @author [Shri2206](https://github.com/Shri2206)\\n */\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for io operations\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @brief This function calculates a raised to exponent b under modulo c using\\n * modular exponentiation.\\n * @param a integer base\\n * @param b unsigned integer exponent\\n * @param c integer modulo\\n * @return a raised to power b modulo c\\n */\\nuint64_t power(uint64_t a, uint64_t b, uint64_t c) {\\n    uint64_t ans = 1;  /// Initialize the answer to be returned\\n    a = a % c;         /// Update a if it is more than or equal to c\\n    if (a == 0) {\\n        return 0;  /// In case a is divisible by c;\\n    }\\n    while (b > 0) {\\n        /// If b is odd, multiply a with answer\\n        if (b & 1) {\\n            ans = ((ans % c) * (a % c)) % c;\\n        }\\n        /// b must be even now\\n        b = b >> 1;  /// b = b/2\\n        a = ((a % c) * (a % c)) % c;\\n    }\\n    return ans;\\n}\\n\\n}  // namespace math\\n\\n/**\\n * Function for testing power function.\\n * test cases and assert statement.\\n * @returns `void`\\n */\\nstatic void test() {\\n    uint32_t test_case_1 = math::power(2, 5, 13);\\n    assert(test_case_1 == 6);\\n    std::cout << \\\"Test 1 Passed!\\\" << std::endl;\\n\\n    uint32_t test_case_2 = math::power(14, 7, 15);\\n    assert(test_case_2 == 14);\\n    std::cout << \\\"Test 2 Passed!\\\" << std::endl;\\n\\n    uint64_t test_case_3 = math::power(8, 15, 41);\\n    assert(test_case_3 == 32);\\n    std::cout << \\\"Test 3 Passed!\\\" << std::endl;\\n\\n    uint64_t test_case_4 = math::power(27, 2, 5);\\n    assert(test_case_4 == 4);\\n    std::cout << \\\"Test 4 Passed!\\\" << std::endl;\\n\\n    uint16_t test_case_5 = math::power(7, 3, 6);\\n    assert(test_case_5 == 1);\\n    std::cout << \\\"Test 5 Passed!\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // execute the tests\\n    return 0;\\n}\\n\"",
    "modular inverse fermat little theorem": "\"/**\\n * @file\\n * @brief C++ Program to find the modular inverse using [Fermat's Little\\n * Theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)\\n *\\n * Fermat's Little Theorem state that \\\\f[ϕ(m) = m-1\\\\f]\\n * where \\\\f$m\\\\f$ is a prime number.\\n * \\\\f{eqnarray*}{\\n *  a \\\\cdot x &≡& 1 \\\\;\\\\text{mod}\\\\; m\\\\\\\\\\n *  x &≡& a^{-1} \\\\;\\\\text{mod}\\\\; m\\n * \\\\f}\\n * Using Euler's theorem we can modify the equation.\\n *\\\\f[\\n * a^{ϕ(m)} ≡ 1 \\\\;\\\\text{mod}\\\\; m\\n * \\\\f]\\n * (Where '^' denotes the exponent operator)\\n *\\n * Here 'ϕ' is Euler's Totient Function. For modular inverse existence 'a' and\\n * 'm' must be relatively primes numbers. To apply Fermat's Little Theorem is\\n * necessary that 'm' must be a prime number. Generally in many competitive\\n * programming competitions 'm' is either 1000000007 (1e9+7) or 998244353.\\n *\\n * We considered m as large prime (1e9+7).\\n * \\\\f$a^{ϕ(m)} ≡ 1 \\\\;\\\\text{mod}\\\\; m\\\\f$ (Using Euler's Theorem)\\n * \\\\f$ϕ(m) = m-1\\\\f$ using Fermat's Little Theorem.\\n * \\\\f$a^{m-1} ≡ 1 \\\\;\\\\text{mod}\\\\; m\\\\f$\\n * Now multiplying both side by \\\\f$a^{-1}\\\\f$.\\n * \\\\f{eqnarray*}{\\n * a^{m-1} \\\\cdot a^{-1} &≡& a^{-1} \\\\;\\\\text{mod}\\\\; m\\\\\\\\\\n * a^{m-2} &≡&  a^{-1} \\\\;\\\\text{mod}\\\\; m\\n * \\\\f}\\n *\\n * We will find the exponent using binary exponentiation. Such that the\\n * algorithm works in \\\\f$O(\\\\log m)\\\\f$ time.\\n *\\n * Examples: -\\n * * a = 3 and m = 7\\n * * \\\\f$a^{-1} \\\\;\\\\text{mod}\\\\; m\\\\f$ is equivalent to\\n * \\\\f$a^{m-2} \\\\;\\\\text{mod}\\\\; m\\\\f$\\n * * \\\\f$3^5 \\\\;\\\\text{mod}\\\\; 7 = 243 \\\\;\\\\text{mod}\\\\; 7 = 5\\\\f$\\n * <br/>Hence, \\\\f$3^{-1} \\\\;\\\\text{mod}\\\\; 7 = 5\\\\f$\\n * or \\\\f$3 \\\\times 5  \\\\;\\\\text{mod}\\\\; 7 = 1 \\\\;\\\\text{mod}\\\\; 7\\\\f$\\n * (as \\\\f$a\\\\times a^{-1} = 1\\\\f$)\\n */\\n\\n#include <iostream>\\n#include <vector>\\n\\n/** Recursive function to calculate exponent in \\\\f$O(\\\\log n)\\\\f$ using binary\\n * exponent.\\n */\\nint64_t binExpo(int64_t a, int64_t b, int64_t m) {\\n    a %= m;\\n    int64_t res = 1;\\n    while (b > 0) {\\n        if (b % 2) {\\n            res = res * a % m;\\n        }\\n        a = a * a % m;\\n        // Dividing b by 2 is similar to right shift.\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n\\n/** Prime check in \\\\f$O(\\\\sqrt{m})\\\\f$ time.\\n */\\nbool isPrime(int64_t m) {\\n    if (m <= 1) {\\n        return false;\\n    } else {\\n        for (int64_t i = 2; i * i <= m; i++) {\\n            if (m % i == 0) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    int64_t a, m;\\n    // Take input of  a and m.\\n    std::cout << \\\"Computing ((a^(-1))%(m)) using Fermat's Little Theorem\\\";\\n    std::cout << std::endl << std::endl;\\n    std::cout << \\\"Give input 'a' and 'm' space separated : \\\";\\n    std::cin >> a >> m;\\n    if (isPrime(m)) {\\n        std::cout << \\\"The modular inverse of a with mod m is (a^(m-2)) : \\\";\\n        std::cout << binExpo(a, m - 2, m) << std::endl;\\n    } else {\\n        std::cout << \\\"m must be a prime number.\\\";\\n        std::cout << std::endl;\\n    }\\n}\\n\"",
    "ncr modulo p": "\"/**\\n * @file\\n * @brief This program aims at calculating [nCr modulo\\n * p](https://cp-algorithms.com/combinatorics/binomial-coefficients.html).\\n * @details nCr is defined as n! / (r! * (n-r)!) where n! represents factorial\\n * of n. In many cases, the value of nCr is too large to fit in a 64 bit\\n * integer. Hence, in competitive programming, there are many problems or\\n * subproblems to compute nCr modulo p where p is a given number.\\n * @author [Kaustubh Damania](https://github.com/KaustubhDamania)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for io operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @namespace ncr_modulo_p\\n * @brief Functions for [nCr modulo\\n * p](https://cp-algorithms.com/combinatorics/binomial-coefficients.html)\\n * implementation.\\n */\\nnamespace ncr_modulo_p {\\n/**\\n * @brief Class which contains all methods required for calculating nCr mod p\\n */\\nclass NCRModuloP {\\n private:\\n    std::vector<uint64_t> fac{};  /// stores precomputed factorial(i) % p value\\n    uint64_t p = 0;               /// the p from (nCr % p)\\n\\n public:\\n    /** Constructor which precomputes the values of n! % mod from n=0 to size\\n     *  and stores them in vector 'fac'\\n     *  @params[in] the numbers 'size', 'mod'\\n     */\\n    NCRModuloP(const uint64_t& size, const uint64_t& mod) {\\n        p = mod;\\n        fac = std::vector<uint64_t>(size);\\n        fac[0] = 1;\\n        for (int i = 1; i <= size; i++) {\\n            fac[i] = (fac[i - 1] * i) % p;\\n        }\\n    }\\n\\n    /** Finds the value of x, y such that a*x + b*y = gcd(a,b)\\n     *\\n     * @params[in] the numbers 'a', 'b' and address of 'x' and 'y' from above\\n     * equation\\n     * @returns the gcd of a and b\\n     */\\n    uint64_t gcdExtended(const uint64_t& a, const uint64_t& b, int64_t* x,\\n                         int64_t* y) {\\n        if (a == 0) {\\n            *x = 0, *y = 1;\\n            return b;\\n        }\\n\\n        int64_t x1 = 0, y1 = 0;\\n        uint64_t gcd = gcdExtended(b % a, a, &x1, &y1);\\n\\n        *x = y1 - (b / a) * x1;\\n        *y = x1;\\n        return gcd;\\n    }\\n\\n    /** Find modular inverse of a with m i.e. a number x such that (a*x)%m = 1\\n     *\\n     * @params[in] the numbers 'a' and 'm' from above equation\\n     * @returns the modular inverse of a\\n     */\\n    int64_t modInverse(const uint64_t& a, const uint64_t& m) {\\n        int64_t x = 0, y = 0;\\n        uint64_t g = gcdExtended(a, m, &x, &y);\\n        if (g != 1) {  // modular inverse doesn't exist\\n            return -1;\\n        } else {\\n            int64_t res = ((x + m) % m);\\n            return res;\\n        }\\n    }\\n\\n    /** Find nCr % p\\n     *\\n     * @params[in] the numbers 'n', 'r' and 'p'\\n     * @returns the value nCr % p\\n     */\\n    int64_t ncr(const uint64_t& n, const uint64_t& r, const uint64_t& p) {\\n        // Base cases\\n        if (r > n) {\\n            return 0;\\n        }\\n        if (r == 1) {\\n            return n % p;\\n        }\\n        if (r == 0 || r == n) {\\n            return 1;\\n        }\\n        // fac is a global array with fac[r] = (r! % p)\\n        int64_t denominator = modInverse(fac[r], p);\\n        if (denominator < 0) {  // modular inverse doesn't exist\\n            return -1;\\n        }\\n        denominator = (denominator * modInverse(fac[n - r], p)) % p;\\n        if (denominator < 0) {  // modular inverse doesn't exist\\n            return -1;\\n        }\\n        return (fac[n] * denominator) % p;\\n    }\\n};\\n}  // namespace ncr_modulo_p\\n}  // namespace math\\n\\n/**\\n * @brief Test implementations\\n * @param ncrObj object which contains the precomputed factorial values and\\n * ncr function\\n * @returns void\\n */\\nstatic void tests(math::ncr_modulo_p::NCRModuloP ncrObj) {\\n    // (52323 C 26161) % (1e9 + 7) = 224944353\\n    assert(ncrObj.ncr(52323, 26161, 1000000007) == 224944353);\\n    // 6 C 2 = 30, 30%5 = 0\\n    assert(ncrObj.ncr(6, 2, 5) == 0);\\n    // 7C3 = 35, 35 % 29 = 8\\n    assert(ncrObj.ncr(7, 3, 29) == 6);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    // populate the fac array\\n    const uint64_t size = 1e6 + 1;\\n    const uint64_t p = 1e9 + 7;\\n    math::ncr_modulo_p::NCRModuloP ncrObj =\\n        math::ncr_modulo_p::NCRModuloP(size, p);\\n    // test 6Ci for i=0 to 7\\n    for (int i = 0; i <= 7; i++) {\\n        std::cout << 6 << \\\"C\\\" << i << \\\" = \\\" << ncrObj.ncr(6, i, p) << \\\"\\\\n\\\";\\n    }\\n    tests(ncrObj);  // execute the tests\\n    std::cout << \\\"Assertions passed\\\\n\\\";\\n    return 0;\\n}\\n\"",
    "number of positive divisors": "\"/**\\n * @file\\n * @brief C++ Program to calculate the number of positive divisors\\n *\\n * This algorithm uses the prime factorization approach.\\n * Any positive integer can be written as a product of its prime factors.\\n * <br/>Let \\\\f$N = p_1^{e_1} \\\\times p_2^{e_2} \\\\times\\\\cdots\\\\times p_k^{e_k}\\\\f$\\n * where \\\\f$p_1,\\\\, p_2,\\\\, \\\\dots,\\\\, p_k\\\\f$ are distinct prime factors of \\\\f$N\\\\f$ and\\n * \\\\f$e_1,\\\\, e_2,\\\\, \\\\dots,\\\\, e_k\\\\f$ are respective positive integer exponents.\\n * <br/>Each positive divisor of \\\\f$N\\\\f$ is in the form\\n * \\\\f$p_1^{g_1}\\\\times p_2^{g_2}\\\\times\\\\cdots\\\\times p_k^{g_k}\\\\f$\\n * where \\\\f$0\\\\le g_i\\\\le e_i\\\\f$ are integers for all \\\\f$1\\\\le i\\\\le k\\\\f$.\\n * <br/>Finally, there are \\\\f$(e_1+1) \\\\times (e_2+1)\\\\times\\\\cdots\\\\times (e_k+1)\\\\f$\\n * positive divisors of \\\\f$N\\\\f$ since we can choose every \\\\f$g_i\\\\f$\\n * independently.\\n *\\n * Example:\\n * <br/>\\\\f$N = 36 = (3^2 \\\\cdot 2^2)\\\\f$\\n * <br/>\\\\f$\\\\mbox{number_of_positive_divisors}(36) = (2+1) \\\\cdot (2+1) = 9\\\\f$.\\n * <br/>list of positive divisors of 36 = 1, 2, 3, 4, 6, 9, 12, 18, 36.\\n *\\n * Similarly, for N = -36 the number of positive divisors remain same.\\n**/\\n\\n#include <cassert>\\n#include <iostream>\\n\\n/**\\n * Function to compute the number of positive divisors.\\n * @param n number to compute divisors for\\n * @returns number of positive divisors of n (or 1 if n = 0)\\n */\\nint number_of_positive_divisors(int n) {\\n    if (n < 0) {\\n        n = -n; // take the absolute value of n\\n    }\\n\\n    int number_of_divisors = 1;\\n\\n    for (int i = 2; i * i <= n; i++) {\\n        // This part is doing the prime factorization.\\n        // Note that we cannot find a composite divisor of n unless we would\\n        // already previously find the corresponding prime divisor and dvided\\n        // n by that prime. Therefore, all the divisors found here will\\n        // actually be primes.\\n        // The loop terminates early when it is left with a number n which\\n        // does not have a divisor smaller or equal to sqrt(n) - that means\\n        // the remaining number is a prime itself.\\n        int prime_exponent = 0;\\n        while (n % i == 0) {\\n            // Repeatedly divide n by the prime divisor n to compute\\n            // the exponent (e_i in the algorithm description).\\n            prime_exponent++;\\n            n /= i;\\n        }\\n        number_of_divisors *= prime_exponent + 1;\\n    }\\n    if (n > 1) {\\n        // In case the remaining number n is a prime number itself\\n        // (essentially p_k^1) the final answer is also multiplied by (e_k+1).\\n        number_of_divisors *= 2;\\n    }\\n\\n    return number_of_divisors;\\n}\\n\\n/**\\n * Test implementations\\n */\\nvoid tests() {\\n    assert(number_of_positive_divisors(36) == 9);\\n    assert(number_of_positive_divisors(-36) == 9);\\n    assert(number_of_positive_divisors(1) == 1);\\n    assert(number_of_positive_divisors(2011) == 2); // 2011 is a prime\\n    assert(number_of_positive_divisors(756) == 24); // 756 = 2^2 * 3^3 * 7\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    tests();\\n    int n;\\n    std::cin >> n;\\n    if (n == 0) {\\n        std::cout << \\\"All non-zero numbers are divisors of 0 !\\\" << std::endl;\\n    } else {\\n        std::cout << \\\"Number of positive divisors is : \\\";\\n        std::cout << number_of_positive_divisors(n) << std::endl;\\n    }\\n    return 0;\\n}\\n\"",
    "n bonacci": "\"/**\\n * @file\\n * @brief Implementation of the\\n * [N-bonacci](http://oeis.org/wiki/N-bonacci_numbers) series\\n *\\n * @details\\n * In general, in N-bonacci sequence,\\n * we generate sum of preceding N numbers from the next term.\\n *\\n * For example, a 3-bonacci sequence is the following:\\n * 0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81\\n * In this code we take N and M as input where M is the number of terms\\n * to be printed of the N-bonacci series\\n *\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n */\\n\\n#include <algorithm>  /// for std::is_equal, std::swap\\n#include <cassert>    /// for assert\\n#include <iostream>   /// for IO operations\\n#include <vector>     /// for std::vector\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @namespace n_bonacci\\n * @brief Functions for the [N-bonacci](http://oeis.org/wiki/N-bonacci_numbers)\\n * implementation\\n */\\nnamespace n_bonacci {\\n/**\\n * @brief Finds the N-Bonacci series for the `n` parameter value and `m`\\n * parameter terms\\n * @param n is in the N-Bonacci series\\n * @param m is the number of terms in the N-Bonacci sequence\\n * @returns the n-bonacci sequence as vector array\\n */\\nstd::vector<uint64_t> N_bonacci(const uint64_t &n, const uint64_t &m) {\\n    std::vector<uint64_t> a(m, 0);  // we create an empty array of size m\\n\\n    a[n - 1] = 1;  /// we initialise the (n-1)th term as 1 which is the sum of\\n                   /// preceding N zeros\\n    a[n] = 1;  /// similarily the sum of preceding N zeros and the (N+1)th 1 is\\n               /// also 1\\n    for (uint64_t i = n + 1; i < m; i++) {\\n        // this is an optimized solution that works in O(M) time and takes O(M)\\n        // extra space here we use the concept of the sliding window the current\\n        // term can be computed using the given formula\\n        a[i] = 2 * a[i - 1] - a[i - 1 - n];\\n    }\\n    return a;\\n}\\n}  // namespace n_bonacci\\n}  // namespace math\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // n = 1 m = 1 return [1, 1]\\n    std::cout << \\\"1st test\\\";\\n    std::vector<uint64_t> arr1 = math::n_bonacci::N_bonacci(\\n        1, 1);  // first input is the param n and second one is the param m for\\n                // N-bonacci func\\n    std::vector<uint64_t> output_array1 = {\\n        1, 1};  // It is the expected output series of length m\\n    assert(std::equal(std::begin(arr1), std::end(arr1),\\n                      std::begin(output_array1)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // n = 5 m = 15 return [0, 0, 0, 0, 1, 1, 2, 4, 8, 16, 31, 61, 120, 236,\\n    // 464]\\n    std::cout << \\\"2nd test\\\";\\n    std::vector<uint64_t> arr2 = math::n_bonacci::N_bonacci(\\n        5, 15);  // first input is the param n and second one is the param m for\\n                 // N-bonacci func\\n    std::vector<uint64_t> output_array2 = {\\n        0, 0,  0,  0,  1,   1,   2,  4,\\n        8, 16, 31, 61, 120, 236, 464};  // It is the expected output series of\\n                                        // length m\\n    assert(std::equal(std::begin(arr2), std::end(arr2),\\n                      std::begin(output_array2)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // n = 6 m = 17 return [0, 0, 0, 0, 0, 1, 1, 2, 4, 8, 16, 32, 63, 125, 248,\\n    // 492, 976]\\n    std::cout << \\\"3rd test\\\";\\n    std::vector<uint64_t> arr3 = math::n_bonacci::N_bonacci(\\n        6, 17);  // first input is the param n and second one is the param m for\\n                 // N-bonacci func\\n    std::vector<uint64_t> output_array3 = {\\n        0, 0,  0,  0,  0,   1,   1,   2,  4,\\n        8, 16, 32, 63, 125, 248, 492, 976};  // It is the expected output series\\n                                             // of length m\\n    assert(std::equal(std::begin(arr3), std::end(arr3),\\n                      std::begin(output_array3)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // n = 56 m = 15 return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n    std::cout << \\\"4th test\\\";\\n    std::vector<uint64_t> arr4 = math::n_bonacci::N_bonacci(\\n        56, 15);  // first input is the param n and second one is the param m\\n                  // for N-bonacci func\\n    std::vector<uint64_t> output_array4 = {\\n        0, 0, 0, 0, 0, 0, 0, 0,\\n        0, 0, 0, 0, 0, 0, 0};  // It is the expected output series of length m\\n    assert(std::equal(std::begin(arr4), std::end(arr4),\\n                      std::begin(output_array4)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "n choose r": "\"/**\\n * @file\\n * @brief [Combinations](https://en.wikipedia.org/wiki/Combination) n choose r\\n * function implementation\\n * @details\\n * A very basic and efficient method of calculating\\n * choosing r from n different choices.\\n * \\\\f$ \\\\binom{n}{r} = \\\\frac{n!}{r! (n-r)!} \\\\f$\\n *\\n * @author [Tajmeet Singh](https://github.com/tjgurwara99)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for io operations\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @brief This is the function implementation of \\\\f$ \\\\binom{n}{r} \\\\f$\\n * @details\\n * We are calculating the ans with iterations\\n * instead of calculating three different factorials.\\n * Also, we are using the fact that\\n * \\\\f$ \\\\frac{n!}{r! (n-r)!} = \\\\frac{(n - r + 1) \\\\times \\\\cdots \\\\times n}{1 \\\\times\\n * \\\\cdots \\\\times r} \\\\f$\\n * @tparam T Only for integer types such as long, int_64 etc\\n * @param n \\\\f$ n \\\\f$ in \\\\f$ \\\\binom{n}{r} \\\\f$\\n * @param r \\\\f$ r \\\\f$ in \\\\f$ \\\\binom{n}{r} \\\\f$\\n * @returns ans \\\\f$ \\\\binom{n}{r} \\\\f$\\n */\\ntemplate <class T>\\nT n_choose_r(T n, T r) {\\n    if (r > n / 2) {\\n        r = n - r;  // Because of the fact that  nCr(n, r) == nCr(n, n - r)\\n    }\\n    T ans = 1;\\n    for (int i = 1; i <= r; i++) {\\n        ans *= n - r + i;\\n        ans /= i;\\n    }\\n    return ans;\\n}\\n}  // namespace math\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // First test on 5 choose 2\\n    uint8_t t = math::n_choose_r(5, 2);\\n    assert(((void)\\\"10 is the answer but function says otherwise.\\\\n\\\", t == 10));\\n    std::cout << \\\"First test passes.\\\" << std::endl;\\n    // Second test on 5 choose 3\\n    t = math::n_choose_r(5, 3);\\n    assert(\\n        ((void)\\\"10 is the answer but the function says otherwise.\\\\n\\\", t == 10));\\n    std::cout << \\\"Second test passes.\\\" << std::endl;\\n    // Third test on 3 choose 2\\n    t = math::n_choose_r(3, 2);\\n    assert(\\n        ((void)\\\"3 is the answer but the function says otherwise.\\\\n\\\", t == 3));\\n    std::cout << \\\"Third test passes.\\\" << std::endl;\\n    // Fourth test on 10 choose 4\\n    t = math::n_choose_r(10, 4);\\n    assert(((void)\\\"210 is the answer but the function says otherwise.\\\\n\\\",\\n            t == 210));\\n    std::cout << \\\"Fourth test passes.\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, char *argv[]) {\\n    test();  // executing tests\\n    return 0;\\n}\\n\"",
    "power for huge numbers": "\"/**\\n * @file\\n * @brief Compute powers of large numbers\\n */\\n#include <iostream>\\n\\n/** Maximum number of digits in output\\n *  \\\\f$x^n\\\\f$ where \\\\f$1 <= x,\\\\; n <= 10000\\\\f$ and overflow may happen\\n */\\n#define MAX 100000\\n\\n/** This function multiplies x\\n * with the number represented by res[].\\n * res_size is size of res[] or\\n * number of digits in the number\\n * represented by res[]. This function\\n * uses simple school mathematics\\n * for multiplication.\\n * This function may value of res_size\\n * and returns the new value of res_size\\n * @param x multiplicand\\n * @param res large number representation using array\\n * @param res_size number of digits in `res`\\n */\\nint multiply(int x, int res[], int res_size) {\\n    // Initialize carry\\n    int carry = 0;\\n\\n    // One by one multiply n with\\n    // individual digits of res[]\\n    for (int i = 0; i < res_size; i++) {\\n        int prod = res[i] * x + carry;\\n\\n        // Store last digit of\\n        // 'prod' in res[]\\n        res[i] = prod % 10;\\n\\n        // Put rest in carry\\n        carry = prod / 10;\\n    }\\n\\n    // Put carry in res and\\n    // increase result size\\n    while (carry) {\\n        res[res_size] = carry % 10;\\n        carry = carry / 10;\\n        res_size++;\\n    }\\n    return res_size;\\n}\\n\\n/** This function finds power of a number x and print \\\\f$x^n\\\\f$\\n * @param x base\\n * @param n exponent\\n */\\nvoid power(int x, int n) {\\n    // printing value \\\"1\\\" for power = 0\\n    if (n == 0) {\\n        std::cout << \\\"1\\\";\\n        return;\\n    }\\n\\n    int res[MAX];\\n    int res_size = 0;\\n    int temp = x;\\n\\n    // Initialize result\\n    while (temp != 0) {\\n        res[res_size++] = temp % 10;\\n        temp = temp / 10;\\n    }\\n\\n    // Multiply x n times\\n    // (x^n = x*x*x....n times)\\n    for (int i = 2; i <= n; i++) res_size = multiply(x, res, res_size);\\n\\n    std::cout << x << \\\"^\\\" << n << \\\" = \\\";\\n    for (int i = res_size - 1; i >= 0; i--) std::cout << res[i];\\n}\\n\\n/** Main function */\\nint main() {\\n    int exponent, base;\\n    std::cout << \\\"Enter base \\\";\\n    std::cin >> base;\\n    std::cout << \\\"Enter exponent \\\";\\n    std::cin >> exponent;\\n    power(base, exponent);\\n    return 0;\\n}\\n\"",
    "power of two": "\"/**\\n * @file\\n * @brief Implementation to check whether a number is a power of 2 or not.\\n *\\n * @details\\n * This algorithm uses bit manipulation to check if a number is a power of 2 or\\n * not.\\n *\\n * ### Algorithm\\n * Let the input number be n, then the bitwise and between n and n-1 will let us\\n * know whether the number is power of 2 or not\\n *\\n * For Example,\\n * If N= 32 then N-1 is 31, if we perform bitwise and of these two numbers then\\n * the result will be zero, which indicates that it is the power of 2\\n * If N=23 then N-1 is 22, if we perform bitwise and of these two numbers then\\n * the result will not be zero , which indicates that it is not the power of 2\\n * \\\\note This implementation is better than naive recursive or iterative\\n * approach.\\n *\\n * @author [Neha Hasija](https://github.com/neha-hasija17)\\n */\\n\\n#include <iostream>  /// for std::cout\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @brief Function to test above algorithm\\n * @param n description\\n * @returns void\\n */\\nvoid power_of_two(int n) {\\n    /**\\n     * This function finds whether a number is power of 2 or not\\n     * @param n value for which we want to check\\n     * prints the result, as \\\"Yes, the number n is a power of 2\\\" or\\n     * \\\"No, the number is not a power of 2\\\" without quotes\\n     */\\n    /// result stores the\\n    /// bitwise and of n and n-1\\n    int result = n & (n - 1);\\n    if (result == 0) {\\n        std::cout << \\\"Yes, the number \\\" << n << \\\" is a power of 2\\\";\\n    } else {\\n        std::cout << \\\"No, the number \\\" << n << \\\" is not a power of 2\\\";\\n    }\\n}\\n}  // namespace math\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    int n = 0;\\n    /// n stores the input from the user\\n    std::cout << \\\"enter a number \\\" << std::endl;\\n    std::cin >> n;\\n    /// function call with @param n\\n    math::power_of_two(n);\\n    return 0;\\n}\\n\"",
    "primes up to billion": "\"/**\\n * @file\\n * @brief Compute prime numbers upto 1 billion\\n * @see prime_numbers.cpp sieve_of_eratosthenes.cpp\\n */\\n#include <cstring>\\n#include <iostream>\\n\\n/** array to store the primes */\\nchar prime[100000000];\\n\\n/** Perform Sieve algorithm */\\nvoid Sieve(int64_t n) {\\n    memset(prime, '1', sizeof(prime));  // intitize '1' to every index\\n    prime[0] = '0';                     // 0 is not prime\\n    prime[1] = '0';                     // 1 is not prime\\n    for (int64_t p = 2; p * p <= n; p++) {\\n        if (prime[p] == '1') {\\n            for (int64_t i = p * p; i <= n; i += p)\\n                prime[i] = '0';  // set all multiples of p to false\\n        }\\n    }\\n}\\n\\n/** Main function */\\nint main() {\\n    Sieve(100000000);\\n    int64_t n;\\n    std::cin >> n;  // 10006187\\n    if (prime[n] == '1')\\n        std::cout << \\\"YES\\\\n\\\";\\n    else\\n        std::cout << \\\"NO\\\\n\\\";\\n\\n    return 0;\\n}\\n\"",
    "prime factorization": "\"/**\\n * @file\\n * @brief Prime factorization of positive integers\\n */\\n#include <algorithm>\\n#include <cstring>\\n#include <iostream>\\n#include <vector>\\n\\n/** Declaring variables for maintaing prime numbers and to check whether a\\n * number is prime or not\\n */\\nbool isprime[1000006];\\n\\n/** list of prime numbers */\\nstd::vector<int> prime_numbers;\\n\\n/** list of prime factor-pairs */\\nstd::vector<std::pair<int, int>> factors;\\n\\n/** Calculating prime number upto a given range\\n */\\nvoid SieveOfEratosthenes(int N) {\\n    // initializes the array isprime\\n    memset(isprime, true, sizeof isprime);\\n\\n    for (int i = 2; i <= N; i++) {\\n        if (isprime[i]) {\\n            for (int j = 2 * i; j <= N; j += i) isprime[j] = false;\\n        }\\n    }\\n\\n    for (int i = 2; i <= N; i++) {\\n        if (isprime[i])\\n            prime_numbers.push_back(i);\\n    }\\n}\\n\\n/** Prime factorization of a number */\\nvoid prime_factorization(int num) {\\n    int number = num;\\n\\n    for (int i = 0; prime_numbers[i] <= num; i++) {\\n        int count = 0;\\n\\n        // termination condition\\n        if (number == 1) {\\n            break;\\n        }\\n\\n        while (number % prime_numbers[i] == 0) {\\n            count++;\\n            number = number / prime_numbers[i];\\n        }\\n\\n        if (count)\\n            factors.push_back(std::make_pair(prime_numbers[i], count));\\n    }\\n}\\n\\n/** Main program */\\nint main() {\\n    int num;\\n    std::cout << \\\"\\\\t\\\\tComputes the prime factorization\\\\n\\\\n\\\";\\n    std::cout << \\\"Type in a number: \\\";\\n    std::cin >> num;\\n\\n    SieveOfEratosthenes(num);\\n\\n    prime_factorization(num);\\n\\n    // Prime factors with their powers in the given number in new line\\n    for (auto it : factors) {\\n        std::cout << it.first << \\\" \\\" << it.second << std::endl;\\n    }\\n\\n    return 0;\\n}\\n\"",
    "prime numbers": "\"/**\\n * @file\\n * @brief Get list of prime numbers\\n * @see primes_up_to_billion.cpp sieve_of_eratosthenes.cpp\\n */\\n#include <iostream>\\n#include <vector>\\n\\n/** Generate an increasingly large number of primes\\n * and store in a list\\n */\\nstd::vector<int> primes(size_t max) {\\n    std::vector<int> res;\\n    std::vector<bool> is_not_prime(max + 1, false);\\n    for (size_t i = 2; i <= max; i++) {\\n        if (!is_not_prime[i]) {\\n            res.emplace_back(i);\\n        }\\n        for (int p : res) {\\n            size_t k = i * p;\\n            if (k > max) {\\n                break;\\n            }\\n            is_not_prime[k] = true;\\n            if (i % p == 0) {\\n                break;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n\\n/** main function */\\nint main() {\\n    std::cout << \\\"Calculate primes up to:\\\\n>> \\\";\\n    int n = 0;\\n    std::cin >> n;\\n    std::vector<int> ans = primes(n);\\n    for (int p : ans) std::cout << p << ' ';\\n    std::cout << std::endl;\\n}\\n\"",
    "realtime stats": "\"/**\\n * \\\\file\\n * \\\\brief Compute statistics for data entered in rreal-time\\n *\\n * This algorithm is really beneficial to compute statistics on data read in\\n * realtime. For example, devices reading biometrics data. The algorithm is\\n * simple enough to be easily implemented in an embedded system.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#include <cassert>\\n#include <cmath>\\n#include <iostream>\\n\\n/**\\n * \\\\namespace statistics\\n * \\\\brief Statistical algorithms\\n */\\nnamespace statistics {\\n\\n/**\\n * continuous mean and variance computance using\\n * first value as an approximation for the mean.\\n * If the first number is much far form the mean, the algorithm becomes very\\n * inaccurate to compute variance and standard deviation.\\n */\\ntemplate <typename T>\\nclass stats_computer1 {\\n public:\\n    /** Constructor\\n     * \\\\param[in] x new data sample\\n     */\\n    void new_val(T x) {\\n        if (n == 0)\\n            K = x;\\n        n++;\\n        T tmp = x - K;\\n        Ex += tmp;\\n        Ex2 += static_cast<double>(tmp) * tmp;\\n    }\\n\\n    /** return sample mean computed till last sample */\\n    double mean() const { return K + Ex / n; }\\n\\n    /** return data variance computed till last sample */\\n    double variance() const { return (Ex2 - (Ex * Ex) / n) / (n - 1); }\\n\\n    /** return sample standard deviation computed till last sample */\\n    double std() const { return std::sqrt(this->variance()); }\\n\\n    /** short-hand operator to read new sample from input stream\\n     * \\\\n e.g.: `std::cin >> stats1;`\\n     */\\n    friend std::istream &operator>>(std::istream &input,\\n                                    stats_computer1 &stat) {\\n        T val;\\n        input >> val;\\n        stat.new_val(val);\\n        return input;\\n    }\\n\\n private:\\n    unsigned int n = 0;\\n    double Ex, Ex2;\\n    T K;\\n};\\n\\n/**\\n * continuous mean and variance computance using\\n * Welford's algorithm  (very accurate)\\n */\\ntemplate <typename T>\\nclass stats_computer2 {\\n public:\\n    /** Constructor\\n     * \\\\param[in] x new data sample\\n     */\\n    void new_val(T x) {\\n        n++;\\n        double delta = x - mu;\\n        mu += delta / n;\\n        double delta2 = x - mu;\\n        M += delta * delta2;\\n    }\\n\\n    /** return sample mean computed till last sample */\\n    double mean() const { return mu; }\\n\\n    /** return data variance computed till last sample */\\n    double variance() const { return M / n; }\\n\\n    /** return sample standard deviation computed till last sample */\\n    double std() const { return std::sqrt(this->variance()); }\\n\\n    /** short-hand operator to read new sample from input stream\\n     * \\\\n e.g.: `std::cin >> stats1;`\\n     */\\n    friend std::istream &operator>>(std::istream &input,\\n                                    stats_computer2 &stat) {\\n        T val;\\n        input >> val;\\n        stat.new_val(val);\\n        return input;\\n    }\\n\\n private:\\n    unsigned int n = 0;\\n    double mu = 0, var = 0, M = 0;\\n};\\n\\n}  // namespace statistics\\n\\nusing statistics::stats_computer1;\\nusing statistics::stats_computer2;\\n\\n/** Test the algorithm implementation\\n * \\\\param[in] test_data array of data to test the algorithms\\n */\\nvoid test_function(const float *test_data, const int number_of_samples) {\\n    float mean = 0.f, variance = 0.f;\\n\\n    stats_computer1<float> stats01;\\n    stats_computer2<float> stats02;\\n\\n    for (int i = 0; i < number_of_samples; i++) {\\n        stats01.new_val(test_data[i]);\\n        stats02.new_val(test_data[i]);\\n        mean += test_data[i];\\n    }\\n\\n    mean /= number_of_samples;\\n\\n    for (int i = 0; i < number_of_samples; i++) {\\n        float temp = test_data[i] - mean;\\n        variance += temp * temp;\\n    }\\n    variance /= number_of_samples;\\n\\n    std::cout << \\\"<<<<<<<< Test Function >>>>>>>>\\\" << std::endl\\n              << \\\"Expected: Mean: \\\" << mean << \\\"\\\\t Variance: \\\" << variance\\n              << std::endl;\\n    std::cout << \\\"\\\\tMethod 1:\\\"\\n              << \\\"\\\\tMean: \\\" << stats01.mean()\\n              << \\\"\\\\t Variance: \\\" << stats01.variance()\\n              << \\\"\\\\t Std: \\\" << stats01.std() << std::endl;\\n    std::cout << \\\"\\\\tMethod 2:\\\"\\n              << \\\"\\\\tMean: \\\" << stats02.mean()\\n              << \\\"\\\\t Variance: \\\" << stats02.variance()\\n              << \\\"\\\\t Std: \\\" << stats02.std() << std::endl;\\n\\n    assert(std::abs(stats01.mean() - mean) < 0.01);\\n    assert(std::abs(stats02.mean() - mean) < 0.01);\\n    assert(std::abs(stats02.variance() - variance) < 0.01);\\n\\n    std::cout << \\\"(Tests passed)\\\" << std::endl;\\n}\\n\\n/** Main function */\\nint main(int argc, char **argv) {\\n    const float test_data1[] = {3, 4, 5, -1.4, -3.6, 1.9, 1.};\\n    test_function(test_data1, sizeof(test_data1) / sizeof(test_data1[0]));\\n\\n    std::cout\\n        << \\\"Enter data. Any non-numeric data will terminate the data input.\\\"\\n        << std::endl;\\n\\n    stats_computer1<float> stats1;\\n    stats_computer2<float> stats2;\\n\\n    while (1) {\\n        double val;\\n        std::cout << \\\"Enter number: \\\";\\n        std::cin >> val;\\n\\n        // check for failure to read input. Happens for\\n        // non-numeric data\\n        if (std::cin.fail())\\n            break;\\n\\n        stats1.new_val(val);\\n        stats2.new_val(val);\\n\\n        std::cout << \\\"\\\\tMethod 1:\\\"\\n                  << \\\"\\\\tMean: \\\" << stats1.mean()\\n                  << \\\"\\\\t Variance: \\\" << stats1.variance()\\n                  << \\\"\\\\t Std: \\\" << stats1.std() << std::endl;\\n        std::cout << \\\"\\\\tMethod 2:\\\"\\n                  << \\\"\\\\tMean: \\\" << stats2.mean()\\n                  << \\\"\\\\t Variance: \\\" << stats2.variance()\\n                  << \\\"\\\\t Std: \\\" << stats2.std() << std::endl;\\n    }\\n\\n    return 0;\\n}\\n\"",
    "sieve of eratosthenes": "\"/**\\n * @file\\n * @brief Get list of prime numbers using Sieve of Eratosthenes\\n * @details\\n * Sieve of Eratosthenes is an algorithm that finds all the primes\\n * between 2 and N.\\n *\\n * Time Complexity  : \\\\f$O(N \\\\cdot\\\\log \\\\log N)\\\\f$\\n * <br/>Space Complexity : \\\\f$O(N)\\\\f$\\n *\\n * @see primes_up_to_billion.cpp prime_numbers.cpp\\n */\\n\\n#include <cassert>\\n#include <iostream>\\n#include <vector>\\n\\n/**\\n * This is the function that finds the primes and eliminates the multiples.\\n * Contains a common optimization to start eliminating multiples of\\n * a prime p starting from p * p since all of the lower multiples\\n * have been already eliminated.\\n * @param N number of primes to check\\n * @return is_prime a vector of `N + 1` booleans identifying if `i`^th number is a prime or not\\n */\\nstd::vector<bool> sieve(uint32_t N) {\\n    std::vector<bool> is_prime(N + 1, true);\\n    is_prime[0] = is_prime[1] = false;\\n    for (uint32_t i = 2; i * i <= N; i++) {\\n        if (is_prime[i]) {\\n            for (uint32_t j = i * i; j <= N; j += i) {\\n                is_prime[j] = false;\\n            }\\n        }\\n    }\\n    return is_prime;\\n}\\n\\n/**\\n * This function prints out the primes to STDOUT\\n * @param N number of primes to check\\n * @param is_prime a vector of `N + 1` booleans identifying if `i`^th number is a prime or not\\n */\\nvoid print(uint32_t N, const std::vector<bool> &is_prime) {\\n    for (uint32_t i = 2; i <= N; i++) {\\n        if (is_prime[i]) {\\n            std::cout << i << ' ';\\n        }\\n    }\\n    std::cout << std::endl;\\n}\\n\\n/**\\n * Test implementations\\n */\\nvoid tests() {\\n  //                    0      1      2     3     4      5     6      7     8      9      10\\n  std::vector<bool> ans{false, false, true, true, false, true, false, true, false, false, false};\\n  assert(sieve(10) == ans);\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    tests();\\n\\n    uint32_t N = 100;\\n    std::vector<bool> is_prime = sieve(N);\\n    print(N, is_prime);\\n    return 0;\\n}\\n\"",
    "sqrt double": "\"/**\\n * @file\\n * @brief Calculate the square root of any positive real number in \\\\f$O(\\\\log\\n * N)\\\\f$ time, with precision fixed using [bisection\\n * method](https://en.wikipedia.org/wiki/Bisection_method) of root-finding.\\n *\\n * @see Can be implemented using faster and better algorithms like\\n * newton_raphson_method.cpp and false_position.cpp\\n */\\n#include <cassert>\\n#include <iostream>\\n\\n/** Bisection method implemented for the function \\\\f$x^2-a=0\\\\f$\\n * whose roots are \\\\f$\\\\pm\\\\sqrt{a}\\\\f$ and only the positive root is returned.\\n */\\ndouble Sqrt(double a) {\\n    if (a > 0 && a < 1) {\\n        return 1 / Sqrt(1 / a);\\n    }\\n    double l = 0, r = a;\\n    /* Epsilon is the precision.\\n    A great precision is\\n    between 1e-7 and 1e-12.\\n    double epsilon = 1e-12;\\n    */\\n    double epsilon = 1e-12;\\n    while (l <= r) {\\n        double mid = (l + r) / 2;\\n        if (mid * mid > a) {\\n            r = mid;\\n        } else {\\n            if (a - mid * mid < epsilon) {\\n                return mid;\\n            }\\n            l = mid;\\n        }\\n    }\\n    return -1;\\n}\\n\\n/** main function */\\nint main() {\\n    double n{};\\n    std::cin >> n;\\n    assert(n >= 0);\\n    // Change this line for a better precision\\n    std::cout.precision(12);\\n    std::cout << std::fixed << Sqrt(n);\\n}\\n\"",
    "string fibonacci": "\"/**\\n * @file\\n * @brief This Programme returns the Nth fibonacci as a string.\\n *\\n * The method used is manual addition with carry and placing it in a string\\n * which is called string addition This makes it have no bounds or limits\\n *\\n * @see fibonacci_large.cpp, fibonacci_fast.cpp, fibonacci.cpp\\n */\\n\\n#include <iostream>\\n#ifdef _MSC_VER\\n#include <string>  // use this for MS Visual C\\n#else\\n#include <cstring>  // otherwise\\n#endif\\n\\n/**\\n * function to add two string numbers\\n * \\\\param [in] a first number in string to add\\n * \\\\param [in] b second number in string to add\\n * \\\\returns sum as a std::string\\n */\\nstd::string add(std::string a, std::string b) {\\n    std::string temp = \\\"\\\";\\n\\n    // carry flag\\n    int carry = 0;\\n\\n    // fills up with zeros\\n    while (a.length() < b.length()) {\\n        a = \\\"0\\\" + a;\\n    }\\n\\n    // fills up with zeros\\n    while (b.length() < a.length()) {\\n        b = \\\"0\\\" + b;\\n    }\\n\\n    // adds the numbers a and b\\n    for (int i = a.length() - 1; i >= 0; i--) {\\n        char val = static_cast<char>(((a[i] - 48) + (b[i] - 48)) + 48 + carry);\\n        if (val > 57) {\\n            carry = 1;\\n            val -= 10;\\n        } else {\\n            carry = 0;\\n        }\\n        temp = val + temp;\\n    }\\n\\n    // processes the carry flag\\n    if (carry == 1) {\\n        temp = \\\"1\\\" + temp;\\n    }\\n\\n    // removes leading zeros.\\n    while (temp[0] == '0' && temp.length() > 1) {\\n        temp = temp.substr(1);\\n    }\\n\\n    return temp;\\n}\\n\\n/** Fibonacci iterator\\n * \\\\param [in] n n^th Fibonacci number\\n */\\nvoid fib_Accurate(uint64_t n) {\\n    std::string tmp = \\\"\\\";\\n    std::string fibMinus1 = \\\"1\\\";\\n    std::string fibMinus2 = \\\"0\\\";\\n    for (uint64_t i = 0; i < n; i++) {\\n        tmp = add(fibMinus1, fibMinus2);\\n        fibMinus2 = fibMinus1;\\n        fibMinus1 = tmp;\\n    }\\n    std::cout << fibMinus2;\\n}\\n\\n/** main function */\\nint main() {\\n    int n;\\n    std::cout << \\\"Enter whatever number N you want to find the fibonacci of\\\\n\\\";\\n    std::cin >> n;\\n    std::cout << n << \\\" th Fibonacci is \\\\n\\\";\\n    fib_Accurate(n);\\n\\n    return 0;\\n}\\n\"",
    "sum of binomial coefficient": "\"/**\\r\\n * @file\\r\\n * @brief Algorithm to find sum of binomial coefficients of a given positive\\r\\n * integer.\\r\\n * @details Given a positive integer n, the task is to find the sum of binomial\\r\\n * coefficient i.e nC0 + nC1 + nC2 + ... + nCn-1 + nCn By induction, we can\\r\\n * prove that the sum is equal to 2^n\\r\\n * @see more on\\r\\n * https://en.wikipedia.org/wiki/Binomial_coefficient#Sums_of_the_binomial_coefficients\\r\\n * @author [muskan0719](https://github.com/muskan0719)\\r\\n */\\r\\n#include <cassert>   /// for assert\\r\\n#include <iostream>  /// for std::cin and std::cout\\r\\n\\r\\n/**\\r\\n * @namespace math\\r\\n * @brief Mathematical algorithms\\r\\n */\\r\\nnamespace math {\\r\\n\\r\\n/**\\r\\n * Function to calculate sum of binomial coefficients\\r\\n * @param n number\\r\\n * @return Sum of binomial coefficients of number\\r\\n */\\r\\nuint64_t binomialCoeffSum(uint64_t n) {\\r\\n    // Calculating 2^n\\r\\n    return (1 << n);\\r\\n}\\r\\n}  // namespace math\\r\\n\\r\\n/**\\r\\n * Function for testing binomialCoeffSum function.\\r\\n * test cases and assert statement.\\r\\n * @returns `void`\\r\\n */\\r\\nstatic void test() {\\r\\n    int test_case_1 = math::binomialCoeffSum(2);\\r\\n    assert(test_case_1 == 4);\\r\\n    std::cout << \\\"Test_case_1 Passed!\\\" << std::endl;\\r\\n\\r\\n    int test_case_2 = math::binomialCoeffSum(3);\\r\\n    assert(test_case_2 == 8);\\r\\n    std::cout << \\\"Test_case_2 Passed!\\\" << std::endl;\\r\\n\\r\\n    int test_case_3 = math::binomialCoeffSum(4);\\r\\n    assert(test_case_3 == 16);\\r\\n    std::cout << \\\"Test_case_3 Passed!\\\" << std::endl;\\r\\n\\r\\n    int test_case_4 = math::binomialCoeffSum(5);\\r\\n    assert(test_case_4 == 32);\\r\\n    std::cout << \\\"Test_case_4 Passed!\\\" << std::endl;\\r\\n\\r\\n    int test_case_5 = math::binomialCoeffSum(7);\\r\\n    assert(test_case_5 == 128);\\r\\n    std::cout << \\\"Test_case_5 Passed!\\\" << std::endl;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @returns 0 on exit\\r\\n */\\r\\nint main() {\\r\\n    test();  // execute the tests\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "sum of digits": "\"/**\\n * Copyright 2020 @author iamnambiar\\n *\\n * @file\\n * \\\\brief A C++ Program to find the Sum of Digits of input integer.\\n */\\n#include <cassert>\\n#include <iostream>\\n\\n/**\\n * Function to find the sum of the digits of an integer.\\n * @param num The integer.\\n * @return Sum of the digits of the integer.\\n *\\n * \\\\detail\\n * First the algorithm check whether the num is negative or positive,\\n * if it is negative, then we neglect the negative sign.\\n * Next, the algorithm extract the last digit of num by dividing by 10\\n * and extracting the remainder and this is added to the sum.\\n * The number is then divided by 10 to remove the last digit.\\n * This loop continues until num becomes 0.\\n */\\nint sum_of_digits(int num) {\\n    // If num is negative then negative sign is neglected.\\n    if (num < 0) {\\n        num = -1 * num;\\n    }\\n    int sum = 0;\\n    while (num > 0) {\\n        sum = sum + (num % 10);\\n        num = num / 10;\\n    }\\n    return sum;\\n}\\n\\n/**\\n * Function for testing the sum_of_digits() function with a\\n * first test case of 119765 and assert statement.\\n */\\nvoid test1() {\\n    int test_case_1 = sum_of_digits(119765);\\n    assert(test_case_1 == 29);\\n}\\n\\n/**\\n * Function for testing the sum_of_digits() function with a\\n * second test case of -12256 and assert statement.\\n */\\nvoid test2() {\\n    int test_case_2 = sum_of_digits(-12256);\\n    assert(test_case_2 == 16);\\n}\\n\\n/**\\n * Function for testing the sum_of_digits() with\\n * all the test cases.\\n */\\nvoid test() {\\n    // First test.\\n    test1();\\n    // Second test.\\n    test2();\\n}\\n\\n/**\\n * Main Function\\n */\\nint main() {\\n    test();\\n    std::cout << \\\"Success.\\\" << std::endl;\\n    return 0;\\n}\\n\"",
    "vector cross product": "\"/**\\n * @file\\n *\\n * @brief Calculates the [Cross Product](https://en.wikipedia.org/wiki/Cross_product) and the magnitude of two mathematical 3D vectors.\\n *\\n *\\n * @details Cross Product of two vectors gives a vector.\\n * Direction Ratios of a vector are the numeric parts of the given vector. They are the tree parts of the\\n * vector which determine the magnitude (value) of the vector.\\n * The method of finding a cross product is the same as finding the determinant of an order 3 matrix consisting\\n * of the first row with unit vectors of magnitude 1, the second row with the direction ratios of the\\n * first vector and the third row with the direction ratios of the second vector.\\n * The magnitude of a vector is it's value expressed as a number.\\n * Let the direction ratios of the first vector, P be: a, b, c\\n * Let the direction ratios of the second vector, Q be: x, y, z\\n * Therefore the calculation for the cross product can be arranged as:\\n *\\n * ```\\n * P x Q:\\n *  \\t1\\t1\\t1\\n *  \\ta\\tb\\tc\\n *  \\tx\\ty\\tz\\n * ```\\n *\\n * The direction ratios (DR) are calculated as follows:\\n *  \\t1st DR, J:  (b * z) - (c * y)\\n *  \\t2nd DR, A: -((a * z) - (c * x))\\n *  \\t3rd DR, N:  (a * y) - (b * x)\\n *\\n * Therefore, the direction ratios of the cross product are: J, A, N\\n * The following C++ Program calculates the direction ratios of the cross products of two vector.\\n * The program uses a function, cross() for doing so.\\n * The direction ratios for the first and the second vector has to be passed one by one seperated by a space character.\\n *\\n * Magnitude of a vector is the square root of the sum of the squares of the direction ratios.\\n *\\n * ### Example:\\n * An example of a running instance of the executable program:\\n *\\n * \\tPass the first Vector: 1 2 3\\n *\\tPass the second Vector: 4 5 6\\n *\\tThe cross product is: -3 6 -3\\n *\\tMagnitude: 7.34847\\n *\\n * @author [Shreyas Sable](https://github.com/Shreyas-OwO)\\n */\\n\\n#include <iostream>\\n#include <array>\\n#include <cmath>\\n#include <cassert>\\n\\n/**\\n * @namespace math\\n * @brief Math algorithms\\n */\\nnamespace math {\\n\\t/**\\n\\t * @namespace vector_cross\\n\\t * @brief Functions for Vector Cross Product algorithms\\n\\t */\\n\\tnamespace vector_cross {\\n\\t\\t/**\\n\\t\\t * @brief Function to calculate the cross product of the passed arrays containing the direction ratios of the two mathematical vectors.\\n\\t\\t * @param A contains the direction ratios of the first mathematical vector.\\n\\t\\t * @param B contains the direction ration of the second mathematical vector.\\n\\t\\t * @returns the direction ratios of the cross product.\\n\\t\\t */\\n\\t\\tstd::array<double, 3> cross(const std::array<double, 3> &A, const std::array<double, 3> &B) {\\n\\t\\t\\tstd::array<double, 3> product;\\n\\t\\t\\t/// Performs the cross product as shown in @algorithm.\\n\\t\\t\\tproduct[0] = (A[1] * B[2]) - (A[2] * B[1]);\\n\\t\\t\\tproduct[1] = -((A[0] * B[2]) - (A[2] * B[0]));\\n\\t\\t\\tproduct[2] = (A[0] * B[1]) - (A[1] * B[0]);\\n\\t\\t\\treturn product;\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * @brief Calculates the magnitude of the mathematical vector from it's direction ratios.\\n\\t\\t * @param vec an array containing the direction ratios of a mathematical vector.\\n\\t\\t * @returns type: double description: the magnitude of the mathematical vector from the given direction ratios.\\n\\t\\t */\\n\\t\\tdouble mag(const std::array<double, 3> &vec) {\\n\\t\\t\\tdouble magnitude = sqrt((vec[0] * vec[0]) + (vec[1] * vec[1]) + (vec[2] * vec[2]));\\n\\t\\t\\treturn magnitude;\\n\\t\\t}\\n\\t} /// namespace vector_cross\\n} /// namespace math\\n\\n/**\\n * @brief test function.\\n * @details test the cross() and the mag() functions.\\n */\\nstatic void test() {\\n\\t/// Tests the cross() function.\\n\\tstd::array<double, 3> t_vec = math::vector_cross::cross({1, 2, 3}, {4, 5, 6});\\n\\tassert(t_vec[0] == -3 && t_vec[1] == 6 && t_vec[2] == -3);\\n\\n\\t/// Tests the mag() function.\\n\\tdouble t_mag = math::vector_cross::mag({6, 8, 0});\\n\\tassert(t_mag == 10);\\n}\\n\\n/**\\n * @brief Main Function\\n * @details Asks the user to enter the direction ratios for each of the two mathematical vectors using std::cin\\n * @returns 0 on exit\\n */\\nint main() {\\n\\n\\t/// Tests the functions with sample input before asking for user input.\\n\\ttest();\\n\\n\\tstd::array<double, 3> vec1;\\n\\tstd::array<double, 3> vec2;\\n\\n\\t/// Gets the values for the first vector.\\n\\tstd::cout << \\\"\\\\nPass the first Vector: \\\";\\n\\tstd::cin >> vec1[0] >> vec1[1] >> vec1[2];\\n\\n\\t/// Gets the values for the second vector.\\n\\tstd::cout << \\\"\\\\nPass the second Vector: \\\";\\n\\tstd::cin >> vec2[0] >> vec2[1] >> vec2[2];\\n\\n\\t/// Displays the output out.\\n\\tstd::array<double, 3> product = math::vector_cross::cross(vec1, vec2);\\n\\tstd::cout << \\\"\\\\nThe cross product is: \\\" << product[0] << \\\" \\\" << product[1] << \\\" \\\" << product[2] << std::endl;\\n\\n\\t/// Displays the magnitude of the cross product.\\n\\tstd::cout << \\\"Magnitude: \\\" << math::vector_cross::mag(product) << \\\"\\\\n\\\" << std::endl;\\n\\n\\treturn 0;\\n}\\n\"",
    "volume": "\"/**\\n * @file\\n * @brief Implmentations for the [volume](https://en.wikipedia.org/wiki/Volume)\\n * of various 3D shapes.\\n * @details The volume of a 3D shape is the amount of 3D space that the shape\\n * takes up. All shapes have a formula to get the volume of any given shape.\\n * These implementations support multiple return types.\\n *\\n * @author [Focusucof](https://github.com/Focusucof)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <cmath>     /// for std::pow\\n#include <cstdint>   /// for std::uint32_t\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * @namespace math\\n * @brief Mathematical algorithms\\n */\\nnamespace math {\\n/**\\n * @brief The volume of a [cube](https://en.wikipedia.org/wiki/Cube)\\n * @param length The length of the cube\\n * @returns The volume of the cube\\n */\\ntemplate <typename T>\\nT cube_volume(T length) {\\n    return std::pow(length, 3);\\n}\\n\\n/**\\n * @brief The volume of a\\n * [rectangular](https://en.wikipedia.org/wiki/Cuboid) prism\\n * @param length The length of the base rectangle\\n * @param width The width of the base rectangle\\n * @param height The height of the rectangular prism\\n * @returns The volume of the rectangular prism\\n */\\ntemplate <typename T>\\nT rect_prism_volume(T length, T width, T height) {\\n    return length * width * height;\\n}\\n\\n/**\\n * @brief The volume of a [cone](https://en.wikipedia.org/wiki/Cone)\\n * @param radius The radius of the base circle\\n * @param height The height of the cone\\n * @param PI The definition of the constant PI\\n * @returns The volume of the cone\\n */\\ntemplate <typename T>\\nT cone_volume(T radius, T height, double PI = 3.14) {\\n    return std::pow(radius, 2) * PI * height / 3;\\n}\\n\\n/**\\n * @brief The volume of a\\n * [triangular](https://en.wikipedia.org/wiki/Triangular_prism) prism\\n * @param base The length of the base triangle\\n * @param height The height of the base triangles\\n * @param depth The depth of the triangular prism (the height of the whole\\n * prism)\\n * @returns The volume of the triangular prism\\n */\\ntemplate <typename T>\\nT triangle_prism_volume(T base, T height, T depth) {\\n    return base * height * depth / 2;\\n}\\n\\n/**\\n * @brief The volume of a\\n * [pyramid](https://en.wikipedia.org/wiki/Pyramid_(geometry))\\n * @param length The length of the base shape (or base for triangles)\\n * @param width The width of the base shape (or height for triangles)\\n * @param height The height of the pyramid\\n * @returns The volume of the pyramid\\n */\\ntemplate <typename T>\\nT pyramid_volume(T length, T width, T height) {\\n    return length * width * height / 3;\\n}\\n\\n/**\\n * @brief The volume of a [sphere](https://en.wikipedia.org/wiki/Sphere)\\n * @param radius The radius of the sphere\\n * @param PI The definition of the constant PI\\n * @returns The volume of the sphere\\n */\\ntemplate <typename T>\\nT sphere_volume(T radius, double PI = 3.14) {\\n    return PI * std::pow(radius, 3) * 4 / 3;\\n}\\n\\n/**\\n * @brief The volume of a [cylinder](https://en.wikipedia.org/wiki/Cylinder)\\n * @param radius The radius of the base circle\\n * @param height The height of the cylinder\\n * @param PI The definition of the constant PI\\n * @returns The volume of the cylinder\\n */\\ntemplate <typename T>\\nT cylinder_volume(T radius, T height, double PI = 3.14) {\\n    return PI * std::pow(radius, 2) * height;\\n}\\n}  // namespace math\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // Input variables\\n    uint32_t int_length = 0; // 32 bit integer length input\\n    uint32_t int_width = 0;  // 32 bit integer width input\\n    uint32_t int_base = 0;   // 32 bit integer base input\\n    uint32_t int_height = 0; // 32 bit integer height input\\n    uint32_t int_depth = 0;  // 32 bit integer depth input\\n\\n    double double_radius = NAN; // double radius input\\n    double double_height = NAN; // double height input\\n\\n    // Output variables\\n    uint32_t int_expected = 0; // 32 bit integer expected output\\n    uint32_t int_volume = 0;   // 32 bit integer output\\n\\n    double double_expected = NAN; // double expected output\\n    double double_volume = NAN;   // double output\\n\\n    // 1st test\\n    int_length = 5;\\n    int_expected = 125;\\n    int_volume = math::cube_volume(int_length);\\n\\n    std::cout << \\\"VOLUME OF A CUBE\\\" << std::endl;\\n    std::cout << \\\"Input Length: \\\" << int_length << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << int_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << int_volume << std::endl;\\n    assert(int_volume == int_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 2nd test\\n    int_length = 4;\\n    int_width = 3;\\n    int_height = 5;\\n    int_expected = 60;\\n    int_volume = math::rect_prism_volume(int_length, int_width, int_height);\\n\\n    std::cout << \\\"VOLUME OF A RECTANGULAR PRISM\\\" << std::endl;\\n    std::cout << \\\"Input Length: \\\" << int_length << std::endl;\\n    std::cout << \\\"Input Width: \\\" << int_width << std::endl;\\n    std::cout << \\\"Input Height: \\\" << int_height << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << int_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << int_volume << std::endl;\\n    assert(int_volume == int_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 3rd test\\n    double_radius = 5;\\n    double_height = 7;\\n    double_expected = 183.16666666666666;  // truncated to 14 decimal places\\n    double_volume = math::cone_volume(double_radius, double_height);\\n\\n    std::cout << \\\"VOLUME OF A CONE\\\" << std::endl;\\n    std::cout << \\\"Input Radius: \\\" << double_radius << std::endl;\\n    std::cout << \\\"Input Height: \\\" << double_height << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << double_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << double_volume << std::endl;\\n    assert(double_volume == double_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 4th test\\n    int_base = 3;\\n    int_height = 4;\\n    int_depth = 5;\\n    int_expected = 30;\\n    int_volume = math::triangle_prism_volume(int_base, int_height, int_depth);\\n\\n    std::cout << \\\"VOLUME OF A TRIANGULAR PRISM\\\" << std::endl;\\n    std::cout << \\\"Input Base: \\\" << int_base << std::endl;\\n    std::cout << \\\"Input Height: \\\" << int_height << std::endl;\\n    std::cout << \\\"Input Depth: \\\" << int_depth << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << int_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << int_volume << std::endl;\\n    assert(int_volume == int_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 5th test\\n    int_length = 10;\\n    int_width = 3;\\n    int_height = 5;\\n    int_expected = 50;\\n    int_volume = math::pyramid_volume(int_length, int_width, int_height);\\n\\n    std::cout << \\\"VOLUME OF A PYRAMID\\\" << std::endl;\\n    std::cout << \\\"Input Length: \\\" << int_length << std::endl;\\n    std::cout << \\\"Input Width: \\\" << int_width << std::endl;\\n    std::cout << \\\"Input Height: \\\" << int_height << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << int_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << int_volume << std::endl;\\n    assert(int_volume == int_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 6th test\\n    double_radius = 3;\\n    double_expected = 113.04;\\n    double_volume = math::sphere_volume(double_radius);\\n\\n    std::cout << \\\"VOLUME OF A SPHERE\\\" << std::endl;\\n    std::cout << \\\"Input Radius: \\\" << double_radius << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << double_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << double_volume << std::endl;\\n    assert(double_volume == double_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n\\n    // 7th test\\n    double_radius = 5;\\n    double_height = 2;\\n    double_expected = 157;\\n    double_volume = math::cylinder_volume(double_radius, double_height);\\n\\n    std::cout << \\\"VOLUME OF A CYLINDER\\\" << std::endl;\\n    std::cout << \\\"Input Radius: \\\" << double_radius << std::endl;\\n    std::cout << \\\"Input Height: \\\" << double_height << std::endl;\\n    std::cout << \\\"Expected Output: \\\" << double_expected << std::endl;\\n    std::cout << \\\"Output: \\\" << double_volume << std::endl;\\n    assert(double_volume == double_expected);\\n    std::cout << \\\"TEST PASSED\\\" << std::endl << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "babylonian method": "\"/**\\r\\n * @file\\r\\n * @brief [A babylonian method\\r\\n * (BM)](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n * is an algorithm that computes the square root.\\r\\n * @details\\r\\n * This algorithm has an application in use case scenario where a user wants\\r\\n * find accurate square roots of large numbers\\r\\n * @author [Ameya Chawla](https://github.com/ameyachawlaggsipu)\\r\\n */\\r\\n\\r\\n#include <cassert>  /// for assert\\r\\n#include <cmath>\\r\\n#include <iostream>  /// for IO operations\\r\\n\\r\\n/**\\r\\n * @namespace numerical_methods\\r\\n * @brief Numerical algorithms/methods\\r\\n */\\r\\n\\r\\nnamespace numerical_methods {\\r\\n\\r\\n/**\\r\\n * @brief Babylonian methods is an iterative function which returns\\r\\n * square root of radicand\\r\\n * @param radicand is the radicand\\r\\n * @returns x1 the square root of radicand\\r\\n */\\r\\n\\r\\ndouble babylonian_method(double radicand) {\\r\\n    int i = 1;  /// To find initial root or rough approximation\\r\\n\\r\\n    while (i * i <= radicand) {\\r\\n        i++;\\r\\n    }\\r\\n\\r\\n    i--;  /// Real Initial value will be i-1 as loop stops on +1 value\\r\\n\\r\\n    double x0 = i;  /// Storing previous value for comparison\\r\\n    double x1 =\\r\\n        (radicand / x0 + x0) / 2;  /// Storing calculated value for comparison\\r\\n    double temp = NAN;             /// Temp variable to x0 and x1\\r\\n\\r\\n    while (std::max(x0, x1) - std::min(x0, x1) < 0.0001) {\\r\\n        temp = (radicand / x1 + x1) / 2;  /// Newly calculated root\\r\\n        x0 = x1;\\r\\n        x1 = temp;\\r\\n    }\\r\\n\\r\\n    return x1;  /// Returning final root\\r\\n}\\r\\n\\r\\n}  // namespace numerical_methods\\r\\n\\r\\n/**\\r\\n * @brief Self-test implementations\\r\\n * @details\\r\\n * Declaring two test cases and checking for the error\\r\\n * in predicted and true value is less than 0.0001.\\r\\n * @returns void\\r\\n */\\r\\nstatic void test() {\\r\\n    /* descriptions of the following test */\\r\\n\\r\\n    auto testcase1 = 125348;  /// Testcase 1\\r\\n    auto testcase2 = 752080;  /// Testcase 2\\r\\n\\r\\n    auto real_output1 = 354.045194855;  /// Real Output 1\\r\\n    auto real_output2 = 867.225460881;  /// Real Output 2\\r\\n\\r\\n    auto test_result1 = numerical_methods::babylonian_method(testcase1);\\r\\n    /// Test result for testcase 1\\r\\n    auto test_result2 = numerical_methods::babylonian_method(testcase2);\\r\\n    /// Test result for testcase 2\\r\\n\\r\\n    assert(std::max(test_result1, real_output1) -\\r\\n               std::min(test_result1, real_output1) <\\r\\n           0.0001);\\r\\n    /// Testing for test Case 1\\r\\n    assert(std::max(test_result2, real_output2) -\\r\\n               std::min(test_result2, real_output2) <\\r\\n           0.0001);\\r\\n    /// Testing for test Case 2\\r\\n\\r\\n    std::cout << \\\"All tests have successfully passed!\\\\n\\\";\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @param argc commandline argument count (ignored)\\r\\n * @param argv commandline array of arguments (ignored)\\r\\n * calls automated test function to test the working of fast fourier transform.\\r\\n * @returns 0 on exit\\r\\n */\\r\\n\\r\\nint main(int argc, char const *argv[]) {\\r\\n    test();  //  run self-test implementations\\r\\n             //  with 2 defined test cases\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "bisection method": "\"/**\\n * \\\\file\\n * \\\\brief Solve the equation \\\\f$f(x)=0\\\\f$ using [bisection\\n * method](https://en.wikipedia.org/wiki/Bisection_method)\\n *\\n * Given two points \\\\f$a\\\\f$ and \\\\f$b\\\\f$ such that \\\\f$f(a)<0\\\\f$ and\\n * \\\\f$f(b)>0\\\\f$, then the \\\\f$(i+1)^\\\\text{th}\\\\f$ approximation is given by: \\\\f[\\n * x_{i+1} = \\\\frac{a_i+b_i}{2}\\n * \\\\f]\\n * For the next iteration, the interval is selected\\n * as: \\\\f$[a,x]\\\\f$ if \\\\f$x>0\\\\f$ or \\\\f$[x,b]\\\\f$ if \\\\f$x<0\\\\f$. The Process is\\n * continued till a close enough approximation is achieved.\\n *\\n * \\\\see newton_raphson_method.cpp, false_position.cpp, secant_method.cpp\\n */\\n#include <cmath>\\n#include <iostream>\\n#include <limits>\\n\\n#define EPSILON \\\\\\n    1e-6  // std::numeric_limits<double>::epsilon()  ///< system accuracy limit\\n#define MAX_ITERATIONS 50000  ///< Maximum number of iterations to check\\n\\n/** define \\\\f$f(x)\\\\f$ to find root for\\n */\\nstatic double eq(double i) {\\n    return (std::pow(i, 3) - (4 * i) - 9);  // original equation\\n}\\n\\n/** get the sign of any given number */\\ntemplate <typename T>\\nint sgn(T val) {\\n    return (T(0) < val) - (val < T(0));\\n}\\n\\n/** main function */\\nint main() {\\n    double a = -1, b = 1, x, z;\\n    int i;\\n\\n    // loop to find initial intervals a, b\\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\\n        z = eq(a);\\n        x = eq(b);\\n        if (sgn(z) == sgn(x)) {  // same signs, increase interval\\n            b++;\\n            a--;\\n        } else {  // if opposite signs, we got our interval\\n            break;\\n        }\\n    }\\n\\n    std::cout << \\\"\\\\nFirst initial: \\\" << a;\\n    std::cout << \\\"\\\\nSecond initial: \\\" << b;\\n\\n    // start iterations\\n    for (i = 0; i < MAX_ITERATIONS; i++) {\\n        x = (a + b) / 2;\\n        z = eq(x);\\n        std::cout << \\\"\\\\n\\\\nz: \\\" << z << \\\"\\\\t[\\\" << a << \\\" , \\\" << b\\n                  << \\\" | Bisect: \\\" << x << \\\"]\\\";\\n\\n        if (z < 0) {\\n            a = x;\\n        } else {\\n            b = x;\\n        }\\n\\n        if (std::abs(z) < EPSILON)  // stoping criteria\\n            break;\\n    }\\n\\n    std::cout << \\\"\\\\n\\\\nRoot: \\\" << x << \\\"\\\\t\\\\tSteps: \\\" << i << std::endl;\\n    return 0;\\n}\\n\"",
    "brent method extrema": "\"/**\\n * \\\\file\\n * \\\\brief Find real extrema of a univariate real function in a given interval\\n * using [Brent's method](https://en.wikipedia.org/wiki/Brent%27s_method).\\n *\\n * Refer the algorithm discoverer's publication\\n * [online](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf) and also\\n * associated book:\\n * > R. P. Brent, Algorithms for Minimization without\\n * > Derivatives, Prentice-Hall, Englewood Cliffs, New Jersey, 1973\\n *\\n * \\\\see golden_search_extrema.cpp\\n *\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#define _USE_MATH_DEFINES  ///< required for MS Visual C++\\n#include <cassert>\\n#include <cmath>\\n#include <functional>\\n#include <iostream>\\n#include <limits>\\n\\n#define EPSILON \\\\\\n    std::sqrt(  \\\\\\n        std::numeric_limits<double>::epsilon())  ///< system accuracy limit\\n\\n/**\\n * @brief Get the real root of a function in the given interval.\\n *\\n * @param f function to get root for\\n * @param lim_a lower limit of search window\\n * @param lim_b upper limit of search window\\n * @return root found in the interval\\n */\\ndouble get_minima(const std::function<double(double)> &f, double lim_a,\\n                  double lim_b) {\\n    uint32_t iters = 0;\\n\\n    if (lim_a > lim_b) {\\n        std::swap(lim_a, lim_b);\\n    } else if (std::abs(lim_a - lim_b) <= EPSILON) {\\n        std::cerr << \\\"Search range must be greater than \\\" << EPSILON << \\\"\\\\n\\\";\\n        return lim_a;\\n    }\\n\\n    // golden ratio value\\n    const double M_GOLDEN_RATIO = (3.f - std::sqrt(5.f)) / 2.f;\\n\\n    double v = lim_a + M_GOLDEN_RATIO * (lim_b - lim_a);\\n    double u, w = v, x = v;\\n    double fu, fv = f(v);\\n    double fw = fv, fx = fv;\\n\\n    double mid_point = (lim_a + lim_b) / 2.f;\\n    double p = 0, q = 0, r = 0;\\n\\n    double d, e = 0;\\n    double tolerance, tolerance2;\\n\\n    do {\\n        mid_point = (lim_a + lim_b) / 2.f;\\n        tolerance = EPSILON * std::abs(x);\\n        tolerance2 = 2 * tolerance;\\n\\n        if (std::abs(e) > tolerance2) {\\n            // fit parabola\\n            r = (x - w) * (fx - fv);\\n            q = (x - v) * (fx - fw);\\n            p = (x - v) * q - (x - w) * r;\\n            q = 2.f * (q - r);\\n            if (q > 0)\\n                p = -p;\\n            else\\n                q = -q;\\n            r = e;\\n            e = d;\\n        }\\n\\n        if (std::abs(p) < std::abs(0.5 * q * r) && p < q * (lim_b - x)) {\\n            // parabolic interpolation step\\n            d = p / q;\\n            u = x + d;\\n            if (u - lim_a < tolerance2 || lim_b - u < tolerance2)\\n                d = x < mid_point ? tolerance : -tolerance;\\n        } else {\\n            // golden section interpolation step\\n            e = (x < mid_point ? lim_b : lim_a) - x;\\n            d = M_GOLDEN_RATIO * e;\\n        }\\n\\n        // evaluate not too close to x\\n        if (std::abs(d) >= tolerance)\\n            u = d;\\n        else if (d > 0)\\n            u = tolerance;\\n        else\\n            u = -tolerance;\\n        u += x;\\n        fu = f(u);\\n\\n        // update variables\\n        if (fu <= fx) {\\n            if (u < x)\\n                lim_b = x;\\n            else\\n                lim_a = x;\\n            v = w;\\n            fv = fw;\\n            w = x;\\n            fw = fx;\\n            x = u;\\n            fx = fu;\\n        } else {\\n            if (u < x)\\n                lim_a = u;\\n            else\\n                lim_b = u;\\n            if (fu <= fw || x == w) {\\n                v = w;\\n                fv = fw;\\n                w = u;\\n                fw = fu;\\n            } else if (fu <= fv || v == x || v == w) {\\n                v = u;\\n                fv = fu;\\n            }\\n        }\\n\\n        iters++;\\n    } while (std::abs(x - mid_point) > (tolerance - (lim_b - lim_a) / 2.f));\\n\\n    std::cout << \\\" (iters: \\\" << iters << \\\") \\\";\\n\\n    return x;\\n}\\n\\n/**\\n * @brief Test function to find root for the function\\n * \\\\f$f(x)= (x-2)^2\\\\f$\\n * in the interval \\\\f$[1,5]\\\\f$\\n * \\\\n Expected result = 2\\n */\\nvoid test1() {\\n    // define the function to minimize as a lambda function\\n    std::function<double(double)> f1 = [](double x) {\\n        return (x - 2) * (x - 2);\\n    };\\n\\n    std::cout << \\\"Test 1.... \\\";\\n\\n    double minima = get_minima(f1, -1, 5);\\n\\n    std::cout << minima << \\\"...\\\";\\n\\n    assert(std::abs(minima - 2) < EPSILON);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/**\\n * @brief Test function to find root for the function\\n * \\\\f$f(x)= x^{\\\\frac{1}{x}}\\\\f$\\n * in the interval \\\\f$[-2,10]\\\\f$\\n * \\\\n Expected result: \\\\f$e\\\\approx 2.71828182845904509\\\\f$\\n */\\nvoid test2() {\\n    // define the function to maximize as a lambda function\\n    // since we are maximixing, we negated the function return value\\n    std::function<double(double)> func = [](double x) {\\n        return -std::pow(x, 1.f / x);\\n    };\\n\\n    std::cout << \\\"Test 2.... \\\";\\n\\n    double minima = get_minima(func, -2, 5);\\n\\n    std::cout << minima << \\\" (\\\" << M_E << \\\")...\\\";\\n\\n    assert(std::abs(minima - M_E) < EPSILON);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/**\\n * @brief Test function to find *maxima* for the function\\n * \\\\f$f(x)= \\\\cos x\\\\f$\\n * in the interval \\\\f$[0,12]\\\\f$\\n * \\\\n Expected result: \\\\f$\\\\pi\\\\approx 3.14159265358979312\\\\f$\\n */\\nvoid test3() {\\n    // define the function to maximize as a lambda function\\n    // since we are maximixing, we negated the function return value\\n    std::function<double(double)> func = [](double x) { return std::cos(x); };\\n\\n    std::cout << \\\"Test 3.... \\\";\\n\\n    double minima = get_minima(func, -4, 12);\\n\\n    std::cout << minima << \\\" (\\\" << M_PI << \\\")...\\\";\\n\\n    assert(std::abs(minima - M_PI) < EPSILON);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/** Main function */\\nint main() {\\n    std::cout.precision(18);\\n\\n    std::cout << \\\"Computations performed with machine epsilon: \\\" << EPSILON\\n              << \\\"\\\\n\\\";\\n\\n    test1();\\n    test2();\\n    test3();\\n\\n    return 0;\\n}\\n\"",
    "composite simpson rule": "\"/**\\n * @file\\n * @brief Implementation of the Composite Simpson Rule for the approximation\\n *\\n * @details The following is an implementation of the Composite Simpson Rule for\\n * the approximation of definite integrals. More info -> wiki:\\n * https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule\\n *\\n * The idea is to split the interval in an EVEN number N of intervals and use as\\n * interpolation points the xi for which it applies that xi = x0 + i*h, where h\\n * is a step defined as h = (b-a)/N where a and b are the first and last points\\n * of the interval of the integration [a, b].\\n *\\n * We create a table of the xi and their corresponding f(xi) values and we\\n * evaluate the integral by the formula: I = h/3 * {f(x0) + 4*f(x1) + 2*f(x2) +\\n * ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}\\n *\\n * That means that the first and last indexed i f(xi) are multiplied by 1,\\n * the odd indexed f(xi) by 4 and the even by 2.\\n *\\n * In this program there are 4 sample test functions f, g, k, l that are\\n * evaluated in the same interval.\\n *\\n * Arguments can be passed as parameters from the command line argv[1] = N,\\n * argv[2] = a, argv[3] = b\\n *\\n * N must be even number and a<b.\\n *\\n * In the end of the main() i compare the program's result with the one from\\n * mathematical software with 2 decimal points margin.\\n *\\n * Add sample function by replacing one of the f, g, k, l and the assert\\n *\\n * @author [ggkogkou](https://github.com/ggkogkou)\\n *\\n */\\n\\n#include <cassert>  /// for assert\\n#include <cmath>    /// for math functions\\n#include <cmath>\\n#include <cstdint>     /// for integer allocation\\n#include <cstdlib>     /// for std::atof\\n#include <functional>  /// for std::function\\n#include <iostream>    /// for IO operations\\n#include <map>         /// for std::map container\\n\\n/**\\n * @namespace numerical_methods\\n * @brief Numerical algorithms/methods\\n */\\nnamespace numerical_methods {\\n/**\\n * @namespace simpson_method\\n * @brief Contains the Simpson's method implementation\\n */\\nnamespace simpson_method {\\n/**\\n * @fn double evaluate_by_simpson(int N, double h, double a,\\n * std::function<double (double)> func)\\n * @brief Calculate integral or assert if integral is not a number (Nan)\\n * @param N number of intervals\\n * @param h step\\n * @param a x0\\n * @param func: choose the function that will be evaluated\\n * @returns the result of the integration\\n */\\ndouble evaluate_by_simpson(std::int32_t N, double h, double a,\\n                           const std::function<double(double)>& func) {\\n    std::map<std::int32_t, double>\\n        data_table;  // Contains the data points. key: i, value: f(xi)\\n    double xi = a;   // Initialize xi to the starting point x0 = a\\n\\n    // Create the data table\\n    double temp = NAN;\\n    for (std::int32_t i = 0; i <= N; i++) {\\n        temp = func(xi);\\n        data_table.insert(\\n            std::pair<std::int32_t, double>(i, temp));  // add i and f(xi)\\n        xi += h;  // Get the next point xi for the next iteration\\n    }\\n\\n    // Evaluate the integral.\\n    // Remember: f(x0) + 4*f(x1) + 2*f(x2) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)\\n    double evaluate_integral = 0;\\n    for (std::int32_t i = 0; i <= N; i++) {\\n        if (i == 0 || i == N) {\\n            evaluate_integral += data_table.at(i);\\n        } else if (i % 2 == 1) {\\n            evaluate_integral += 4 * data_table.at(i);\\n        } else {\\n            evaluate_integral += 2 * data_table.at(i);\\n        }\\n    }\\n\\n    // Multiply by the coefficient h/3\\n    evaluate_integral *= h / 3;\\n\\n    // If the result calculated is nan, then the user has given wrong input\\n    // interval.\\n    assert(!std::isnan(evaluate_integral) &&\\n           \\\"The definite integral can't be evaluated. Check the validity of \\\"\\n           \\\"your input.\\\\n\\\");\\n    // Else return\\n    return evaluate_integral;\\n}\\n\\n/**\\n * @fn double f(double x)\\n * @brief A function f(x) that will be used to test the method\\n * @param x The independent variable xi\\n * @returns the value of the dependent variable yi = f(xi)\\n */\\ndouble f(double x) { return std::sqrt(x) + std::log(x); }\\n/** @brief Another test function */\\ndouble g(double x) { return std::exp(-x) * (4 - std::pow(x, 2)); }\\n/** @brief Another test function */\\ndouble k(double x) { return std::sqrt(2 * std::pow(x, 3) + 3); }\\n/** @brief Another test function*/\\ndouble l(double x) { return x + std::log(2 * x + 1); }\\n}  // namespace simpson_method\\n}  // namespace numerical_methods\\n\\n/**\\n * \\\\brief Self-test implementations\\n * @param N is the number of intervals\\n * @param h is the step\\n * @param a is x0\\n * @param b is the end of the interval\\n * @param used_argv_parameters is 'true' if argv parameters are given and\\n * 'false' if not\\n */\\nstatic void test(std::int32_t N, double h, double a, double b,\\n                 bool used_argv_parameters) {\\n    // Call the functions and find the integral of each function\\n    double result_f = numerical_methods::simpson_method::evaluate_by_simpson(\\n        N, h, a, numerical_methods::simpson_method::f);\\n    assert((used_argv_parameters || (result_f >= 4.09 && result_f <= 4.10)) &&\\n           \\\"The result of f(x) is wrong\\\");\\n    std::cout << \\\"The result of integral f(x) on interval [\\\" << a << \\\", \\\" << b\\n              << \\\"] is equal to: \\\" << result_f << std::endl;\\n\\n    double result_g = numerical_methods::simpson_method::evaluate_by_simpson(\\n        N, h, a, numerical_methods::simpson_method::g);\\n    assert((used_argv_parameters || (result_g >= 0.27 && result_g <= 0.28)) &&\\n           \\\"The result of g(x) is wrong\\\");\\n    std::cout << \\\"The result of integral g(x) on interval [\\\" << a << \\\", \\\" << b\\n              << \\\"] is equal to: \\\" << result_g << std::endl;\\n\\n    double result_k = numerical_methods::simpson_method::evaluate_by_simpson(\\n        N, h, a, numerical_methods::simpson_method::k);\\n    assert((used_argv_parameters || (result_k >= 9.06 && result_k <= 9.07)) &&\\n           \\\"The result of k(x) is wrong\\\");\\n    std::cout << \\\"The result of integral k(x) on interval [\\\" << a << \\\", \\\" << b\\n              << \\\"] is equal to: \\\" << result_k << std::endl;\\n\\n    double result_l = numerical_methods::simpson_method::evaluate_by_simpson(\\n        N, h, a, numerical_methods::simpson_method::l);\\n    assert((used_argv_parameters || (result_l >= 7.16 && result_l <= 7.17)) &&\\n           \\\"The result of l(x) is wrong\\\");\\n    std::cout << \\\"The result of integral l(x) on interval [\\\" << a << \\\", \\\" << b\\n              << \\\"] is equal to: \\\" << result_l << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, char** argv) {\\n    std::int32_t N = 16;  /// Number of intervals to divide the integration\\n                          /// interval. MUST BE EVEN\\n    double a = 1, b = 3;  /// Starting and ending point of the integration in\\n                          /// the real axis\\n    double h = NAN;       /// Step, calculated by a, b and N\\n\\n    bool used_argv_parameters =\\n        false;  // If argv parameters are used then the assert must be omitted\\n                // for the tst cases\\n\\n    // Get user input (by the command line parameters or the console after\\n    // displaying messages)\\n    if (argc == 4) {\\n        N = std::atoi(argv[1]);\\n        a = std::atof(argv[2]);\\n        b = std::atof(argv[3]);\\n        // Check if a<b else abort\\n        assert(a < b && \\\"a has to be less than b\\\");\\n        assert(N > 0 && \\\"N has to be > 0\\\");\\n        if (N < 16 || a != 1 || b != 3) {\\n            used_argv_parameters = true;\\n        }\\n        std::cout << \\\"You selected N=\\\" << N << \\\", a=\\\" << a << \\\", b=\\\" << b\\n                  << std::endl;\\n    } else {\\n        std::cout << \\\"Default N=\\\" << N << \\\", a=\\\" << a << \\\", b=\\\" << b\\n                  << std::endl;\\n    }\\n\\n    // Find the step\\n    h = (b - a) / N;\\n\\n    test(N, h, a, b, used_argv_parameters);  // run self-test implementations\\n\\n    return 0;\\n}\\n\"",
    "durand kerner roots": "\"/**\\n * @file\\n * \\\\brief Compute all possible approximate roots of any given polynomial using\\n * [Durand Kerner\\n * algorithm](https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method)\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n *\\n * Test the algorithm online:\\n * https://gist.github.com/kvedala/27f1b0b6502af935f6917673ec43bcd7\\n *\\n * Try the highly unstable Wilkinson's polynomial:\\n * ```\\n * ./numerical_methods/durand_kerner_roots 1 -210 20615 -1256850 53327946\\n * -1672280820 40171771630 -756111184500 11310276995381 -135585182899530\\n * 1307535010540395 -10142299865511450 63030812099294896 -311333643161390640\\n * 1206647803780373360 -3599979517947607200 8037811822645051776\\n * -12870931245150988800 13803759753640704000 -8752948036761600000\\n * 2432902008176640000\\n * ```\\n * Sample implementation results to compute approximate roots of the equation\\n * \\\\f$x^4-1=0\\\\f$:\\\\n\\n * <img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/durand_kerner_error.svg\\\"\\n * width=\\\"400\\\" alt=\\\"Error evolution during root approximations computed every\\n * iteration.\\\"/> <img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/durand_kerner_roots.svg\\\"\\n * width=\\\"400\\\" alt=\\\"Roots evolution - shows the initial approximation of the\\n * roots and their convergence to a final approximation along with the iterative\\n * approximations\\\" />\\n */\\n\\n#include <algorithm>\\n#include <cassert>\\n#include <cmath>\\n#include <complex>\\n#include <cstdlib>\\n#include <ctime>\\n#include <fstream>\\n#include <iostream>\\n#include <valarray>\\n#ifdef _OPENMP\\n#include <omp.h>\\n#endif\\n\\n#define ACCURACY 1e-10 /**< maximum accuracy limit */\\n\\n/**\\n * Evaluate the value of a polynomial with given coefficients\\n * \\\\param[in] coeffs coefficients of the polynomial\\n * \\\\param[in] x point at which to evaluate the polynomial\\n * \\\\returns \\\\f$f(x)\\\\f$\\n **/\\nstd::complex<double> poly_function(const std::valarray<double> &coeffs,\\n                                   std::complex<double> x) {\\n    double real = 0.f, imag = 0.f;\\n    int n;\\n\\n    // #ifdef _OPENMP\\n    // #pragma omp target teams distribute reduction(+ : real, imag)\\n    // #endif\\n    for (n = 0; n < coeffs.size(); n++) {\\n        std::complex<double> tmp =\\n            coeffs[n] * std::pow(x, coeffs.size() - n - 1);\\n        real += tmp.real();\\n        imag += tmp.imag();\\n    }\\n\\n    return std::complex<double>(real, imag);\\n}\\n\\n/**\\n * create a textual form of complex number\\n * \\\\param[in] x point at which to evaluate the polynomial\\n * \\\\returns pointer to converted string\\n */\\nconst char *complex_str(const std::complex<double> &x) {\\n#define MAX_BUFF_SIZE 50\\n    static char msg[MAX_BUFF_SIZE];\\n\\n    std::snprintf(msg, MAX_BUFF_SIZE, \\\"% 7.04g%+7.04gj\\\", x.real(), x.imag());\\n\\n    return msg;\\n}\\n\\n/**\\n * check for termination condition\\n * \\\\param[in] delta point at which to evaluate the polynomial\\n * \\\\returns `false` if termination not reached\\n * \\\\returns `true` if termination reached\\n */\\nbool check_termination(long double delta) {\\n    static long double past_delta = INFINITY;\\n    if (std::abs(past_delta - delta) <= ACCURACY || delta < ACCURACY)\\n        return true;\\n    past_delta = delta;\\n    return false;\\n}\\n\\n/**\\n * Implements Durand Kerner iterative algorithm to compute all roots of a\\n * polynomial.\\n *\\n * \\\\param[in] coeffs coefficients of the polynomial\\n * \\\\param[out] roots the computed roots of the polynomial\\n * \\\\param[in] write_log flag whether to save the log file (default = `false`)\\n * \\\\returns pair of values - number of iterations taken and final accuracy\\n * achieved\\n */\\nstd::pair<uint32_t, double> durand_kerner_algo(\\n    const std::valarray<double> &coeffs,\\n    std::valarray<std::complex<double>> *roots, bool write_log = false) {\\n    long double tol_condition = 1;\\n    uint32_t iter = 0;\\n    int n;\\n    std::ofstream log_file;\\n\\n    if (write_log) {\\n        /*\\n         * store intermediate values to a CSV file\\n         */\\n        log_file.open(\\\"durand_kerner.log.csv\\\");\\n        if (!log_file.is_open()) {\\n            perror(\\\"Unable to create a storage log file!\\\");\\n            std::exit(EXIT_FAILURE);\\n        }\\n        log_file << \\\"iter#,\\\";\\n\\n        for (n = 0; n < roots->size(); n++) log_file << \\\"root_\\\" << n << \\\",\\\";\\n\\n        log_file << \\\"avg. correction\\\";\\n        log_file << \\\"\\\\n0,\\\";\\n        for (n = 0; n < roots->size(); n++)\\n            log_file << complex_str((*roots)[n]) << \\\",\\\";\\n    }\\n\\n    bool break_loop = false;\\n    while (!check_termination(tol_condition) && iter < INT16_MAX &&\\n           !break_loop) {\\n        tol_condition = 0;\\n        iter++;\\n        break_loop = false;\\n\\n        if (log_file.is_open())\\n            log_file << \\\"\\\\n\\\" << iter << \\\",\\\";\\n\\n#ifdef _OPENMP\\n#pragma omp parallel for shared(break_loop, tol_condition)\\n#endif\\n        for (n = 0; n < roots->size(); n++) {\\n            if (break_loop)\\n                continue;\\n\\n            std::complex<double> numerator, denominator;\\n            numerator = poly_function(coeffs, (*roots)[n]);\\n            denominator = 1.0;\\n            for (int i = 0; i < roots->size(); i++)\\n                if (i != n)\\n                    denominator *= (*roots)[n] - (*roots)[i];\\n\\n            std::complex<long double> delta = numerator / denominator;\\n\\n            if (std::isnan(std::abs(delta)) || std::isinf(std::abs(delta))) {\\n                std::cerr << \\\"\\\\n\\\\nOverflow/underrun error - got value = \\\"\\n                          << std::abs(delta) << \\\"\\\\n\\\";\\n                // return std::pair<uint32_t, double>(iter, tol_condition);\\n                break_loop = true;\\n            }\\n\\n            (*roots)[n] -= delta;\\n\\n#ifdef _OPENMP\\n#pragma omp critical\\n#endif\\n            tol_condition = std::max(tol_condition, std::abs(std::abs(delta)));\\n        }\\n        // tol_condition /= (degree - 1);\\n\\n        if (break_loop)\\n            break;\\n\\n        if (log_file.is_open()) {\\n            for (n = 0; n < roots->size(); n++)\\n                log_file << complex_str((*roots)[n]) << \\\",\\\";\\n        }\\n\\n#if defined(DEBUG) || !defined(NDEBUG)\\n        if (iter % 500 == 0) {\\n            std::cout << \\\"Iter: \\\" << iter << \\\"\\\\t\\\";\\n            for (n = 0; n < roots->size(); n++)\\n                std::cout << \\\"\\\\t\\\" << complex_str((*roots)[n]);\\n            std::cout << \\\"\\\\t\\\\tabsolute average change: \\\" << tol_condition\\n                      << \\\"\\\\n\\\";\\n        }\\n#endif\\n\\n        if (log_file.is_open())\\n            log_file << tol_condition;\\n    }\\n\\n    return std::pair<uint32_t, long double>(iter, tol_condition);\\n}\\n\\n/**\\n * Self test the algorithm by checking the roots for \\\\f$x^2+4=0\\\\f$ to which the\\n * roots are \\\\f$0 \\\\pm 2i\\\\f$\\n */\\nvoid test1() {\\n    const std::valarray<double> coeffs = {1, 0, 4};  // x^2 - 2 = 0\\n    std::valarray<std::complex<double>> roots(2);\\n    std::valarray<std::complex<double>> expected = {\\n        std::complex<double>(0., 2.),\\n        std::complex<double>(0., -2.)  // known expected roots\\n    };\\n\\n    /* initialize root approximations with random values */\\n    for (int n = 0; n < roots.size(); n++) {\\n        roots[n] = std::complex<double>(std::rand() % 100, std::rand() % 100);\\n        roots[n] -= 50.f;\\n        roots[n] /= 25.f;\\n    }\\n\\n    auto result = durand_kerner_algo(coeffs, &roots, false);\\n\\n    for (int i = 0; i < roots.size(); i++) {\\n        // check if approximations are have < 0.1% error with one of the\\n        // expected roots\\n        bool err1 = false;\\n        for (int j = 0; j < roots.size(); j++)\\n            err1 |= std::abs(std::abs(roots[i] - expected[j])) < 1e-3;\\n        assert(err1);\\n    }\\n\\n    std::cout << \\\"Test 1 passed! - \\\" << result.first << \\\" iterations, \\\"\\n              << result.second << \\\" accuracy\\\"\\n              << \\\"\\\\n\\\";\\n}\\n\\n/**\\n * Self test the algorithm by checking the roots for \\\\f$0.015625x^3-1=0\\\\f$ to\\n * which the roots are \\\\f$(4+0i),\\\\,(-2\\\\pm3.464i)\\\\f$\\n */\\nvoid test2() {\\n    const std::valarray<double> coeffs = {// 0.015625 x^3 - 1 = 0\\n                                          1. / 64., 0., 0., -1.};\\n    std::valarray<std::complex<double>> roots(3);\\n    const std::valarray<std::complex<double>> expected = {\\n        std::complex<double>(4., 0.), std::complex<double>(-2., 3.46410162),\\n        std::complex<double>(-2., -3.46410162)  // known expected roots\\n    };\\n\\n    /* initialize root approximations with random values */\\n    for (int n = 0; n < roots.size(); n++) {\\n        roots[n] = std::complex<double>(std::rand() % 100, std::rand() % 100);\\n        roots[n] -= 50.f;\\n        roots[n] /= 25.f;\\n    }\\n\\n    auto result = durand_kerner_algo(coeffs, &roots, false);\\n\\n    for (int i = 0; i < roots.size(); i++) {\\n        // check if approximations are have < 0.1% error with one of the\\n        // expected roots\\n        bool err1 = false;\\n        for (int j = 0; j < roots.size(); j++)\\n            err1 |= std::abs(std::abs(roots[i] - expected[j])) < 1e-3;\\n        assert(err1);\\n    }\\n\\n    std::cout << \\\"Test 2 passed! - \\\" << result.first << \\\" iterations, \\\"\\n              << result.second << \\\" accuracy\\\"\\n              << \\\"\\\\n\\\";\\n}\\n\\n/***\\n * Main function.\\n * The comandline input arguments are taken as coeffiecients of a\\n *polynomial. For example, this command\\n * ```sh\\n * ./durand_kerner_roots 1 0 -4\\n * ```\\n * will find roots of the polynomial \\\\f$1\\\\cdot x^2 + 0\\\\cdot x^1 + (-4)=0\\\\f$\\n **/\\nint main(int argc, char **argv) {\\n    /* initialize random seed: */\\n    std::srand(std::time(nullptr));\\n\\n    if (argc < 2) {\\n        test1();  // run tests when no input is provided\\n        test2();  // and skip tests when input polynomial is provided\\n        std::cout << \\\"Please pass the coefficients of the polynomial as \\\"\\n                     \\\"commandline \\\"\\n                     \\\"arguments.\\\\n\\\";\\n        return 0;\\n    }\\n\\n    int n, degree = argc - 1;              // detected polynomial degree\\n    std::valarray<double> coeffs(degree);  // create coefficiencts array\\n\\n    // number of roots = degree - 1\\n    std::valarray<std::complex<double>> s0(degree - 1);\\n\\n    std::cout << \\\"Computing the roots for:\\\\n\\\\t\\\";\\n    for (n = 0; n < degree; n++) {\\n        coeffs[n] = strtod(argv[n + 1], nullptr);\\n        if (n < degree - 1 && coeffs[n] != 0)\\n            std::cout << \\\"(\\\" << coeffs[n] << \\\") x^\\\" << degree - n - 1 << \\\" + \\\";\\n        else if (coeffs[n] != 0)\\n            std::cout << \\\"(\\\" << coeffs[n] << \\\") x^\\\" << degree - n - 1\\n                      << \\\" = 0\\\\n\\\";\\n\\n        /* initialize root approximations with random values */\\n        if (n < degree - 1) {\\n            s0[n] = std::complex<double>(std::rand() % 100, std::rand() % 100);\\n            s0[n] -= 50.f;\\n            s0[n] /= 50.f;\\n        }\\n    }\\n\\n    // numerical errors less when the first coefficient is \\\"1\\\"\\n    // hence, we normalize the first coefficient\\n    {\\n        double tmp = coeffs[0];\\n        coeffs /= tmp;\\n    }\\n\\n    clock_t end_time, start_time = clock();\\n    auto result = durand_kerner_algo(coeffs, &s0, true);\\n    end_time = clock();\\n\\n    std::cout << \\\"\\\\nIterations: \\\" << result.first << \\\"\\\\n\\\";\\n    for (n = 0; n < degree - 1; n++)\\n        std::cout << \\\"\\\\t\\\" << complex_str(s0[n]) << \\\"\\\\n\\\";\\n    std::cout << \\\"absolute average change: \\\" << result.second << \\\"\\\\n\\\";\\n    std::cout << \\\"Time taken: \\\"\\n              << static_cast<double>(end_time - start_time) / CLOCKS_PER_SEC\\n              << \\\" sec\\\\n\\\";\\n\\n    return 0;\\n}\\n\"",
    "false position": "\"/**\\n * \\\\file\\n * \\\\brief Solve the equation \\\\f$f(x)=0\\\\f$ using [false position\\n * method](https://en.wikipedia.org/wiki/Regula_falsi), also known as the Secant\\n * method\\n *\\n * \\\\details\\n * First, multiple intervals are selected with the interval gap provided.\\n * Separate recursive function called for every root.\\n * Roots are printed Separatelt.\\n *\\n * For an interval [a,b] \\\\f$a\\\\f$ and \\\\f$b\\\\f$ such that \\\\f$f(a)<0\\\\f$ and\\n * \\\\f$f(b)>0\\\\f$, then the \\\\f$(i+1)^\\\\text{th}\\\\f$ approximation is given by: \\\\f[\\n * x_{i+1} = \\\\frac{a_i\\\\cdot f(b_i) - b_i\\\\cdot f(a_i)}{f(b_i) - f(a_i)}\\n * \\\\f]\\n * For the next iteration, the interval is selected\\n * as: \\\\f$[a,x]\\\\f$ if \\\\f$x>0\\\\f$ or \\\\f$[x,b]\\\\f$ if \\\\f$x<0\\\\f$. The Process is\\n * continued till a close enough approximation is achieved.\\n *\\n * \\\\see newton_raphson_method.cpp, bisection_method.cpp\\n *\\n * \\\\author Unknown author\\n * \\\\author [Samruddha Patil](https://github.com/sampatil578)\\n */\\n#include <cmath>     /// for math operations\\n#include <iostream>  /// for io operations\\n\\n/**\\n * @namespace numerical_methods\\n * @brief Numerical methods\\n */\\nnamespace numerical_methods {\\n/**\\n * @namespace false_position\\n * @brief Functions for [False Position]\\n * (https://en.wikipedia.org/wiki/Regula_falsi) method.\\n */\\nnamespace false_position {\\n/**\\n * @brief This function gives the value of f(x) for given x.\\n * @param x value for which we have to find value of f(x).\\n * @return value of f(x) for given x.\\n */\\nstatic float eq(float x) {\\n    return (x * x - x);  // original equation\\n}\\n\\n/**\\n* @brief This function finds root of the equation in given interval i.e.\\n(x1,x2).\\n* @param x1,x2 values for an interval in which root is present.\\n  @param y1,y2 values of function at x1, x2 espectively.\\n* @return root of the equation in the given interval.\\n*/\\nstatic float regula_falsi(float x1, float x2, float y1, float y2) {\\n    float diff = x1 - x2;\\n    if (diff < 0) {\\n        diff = (-1) * diff;\\n    }\\n    if (diff < 0.00001) {\\n        if (y1 < 0) {\\n            y1 = -y1;\\n        }\\n        if (y2 < 0) {\\n            y2 = -y2;\\n        }\\n        if (y1 < y2) {\\n            return x1;\\n        } else {\\n            return x2;\\n        }\\n    }\\n    float x3 = 0, y3 = 0;\\n    x3 = x1 - (x1 - x2) * (y1) / (y1 - y2);\\n    y3 = eq(x3);\\n    return regula_falsi(x2, x3, y2, y3);\\n}\\n\\n/**\\n * @brief This function prints roots of the equation.\\n * @param root which we have to print.\\n * @param count which is count of the root in an interval [-range,range].\\n */\\nvoid printRoot(float root, const int16_t &count) {\\n    if (count == 1) {\\n        std::cout << \\\"Your 1st root is : \\\" << root << std::endl;\\n    } else if (count == 2) {\\n        std::cout << \\\"Your 2nd root is : \\\" << root << std::endl;\\n    } else if (count == 3) {\\n        std::cout << \\\"Your 3rd root is : \\\" << root << std::endl;\\n    } else {\\n        std::cout << \\\"Your \\\" << count << \\\"th root is : \\\" << root << std::endl;\\n    }\\n}\\n}  // namespace false_position\\n}  // namespace numerical_methods\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    float a = 0, b = 0, i = 0, root = 0;\\n    int16_t count = 0;\\n    float range =\\n        100000;       // Range in which we have to find the root. (-range,range)\\n    float gap = 0.5;  // interval gap. lesser the gap more the accuracy\\n    a = numerical_methods::false_position::eq((-1) * range);\\n    i = ((-1) * range + gap);\\n    // while loop for selecting proper interval in provided range and with\\n    // provided interval gap.\\n    while (i <= range) {\\n        b = numerical_methods::false_position::eq(i);\\n        if (b == 0) {\\n            count++;\\n            numerical_methods::false_position::printRoot(i, count);\\n        }\\n        if (a * b < 0) {\\n            root = numerical_methods::false_position::regula_falsi(i - gap, i,\\n                                                                   a, b);\\n            count++;\\n            numerical_methods::false_position::printRoot(root, count);\\n        }\\n        a = b;\\n        i += gap;\\n    }\\n    return 0;\\n}\\n\"",
    "fast fourier transform": "\"/**\\r\\n * @file\\r\\n * @brief [A fast Fourier transform\\r\\n * (FFT)](https://medium.com/@aiswaryamathur/understanding-fast-fouriertransform-from-scratch-to-solve-polynomial-multiplication-8018d511162f)\\r\\n * is an algorithm that computes the\\r\\n * discrete Fourier transform (DFT) of a sequence, or its inverse (IDFT).\\r\\n * @details\\r\\n * This\\r\\n * algorithm has application in use case scenario where a user wants to find\\r\\n points of a\\r\\n * function\\r\\n * in a short time by just using the coefficients of the polynomial\\r\\n * function.\\r\\n * It can be also used to find inverse fourier transform by just switching the\\r\\n value of omega.\\r\\n * Time complexity\\r\\n * this algorithm computes the DFT in O(nlogn) time in comparison to traditional\\r\\n O(n^2).\\r\\n * @author [Ameya Chawla](https://github.com/ameyachawlaggsipu)\\r\\n */\\r\\n\\r\\n#include <cassert>   /// for assert\\r\\n#include <cmath>     /// for mathematical-related functions\\r\\n#include <complex>   /// for storing points and coefficents\\r\\n#include <iostream>  /// for IO operations\\r\\n#include <vector>    /// for std::vector\\r\\n\\r\\n/**\\r\\n * @namespace numerical_methods\\r\\n * @brief Numerical algorithms/methods\\r\\n */\\r\\nnamespace numerical_methods {\\r\\n/**\\r\\n * @brief FastFourierTransform is a recursive function which returns list of\\r\\n * complex numbers\\r\\n * @param p List of Coefficents in form of complex numbers\\r\\n * @param n Count of elements in list p\\r\\n * @returns p if n==1\\r\\n * @returns y if n!=1\\r\\n */\\r\\nstd::complex<double> *FastFourierTransform(std::complex<double> *p, uint8_t n) {\\r\\n    if (n == 1) {\\r\\n        return p;  /// Base Case To return\\r\\n    }\\r\\n\\r\\n    double pi = 2 * asin(1.0);  /// Declaring value of pi\\r\\n\\r\\n    std::complex<double> om = std::complex<double>(\\r\\n        cos(2 * pi / n), sin(2 * pi / n));  /// Calculating value of omega\\r\\n\\r\\n    auto *pe = new std::complex<double>[n / 2];  /// Coefficients of even power\\r\\n\\r\\n    auto *po = new std::complex<double>[n / 2];  /// Coefficients of odd power\\r\\n\\r\\n    int k1 = 0, k2 = 0;\\r\\n    for (int j = 0; j < n; j++) {\\r\\n        if (j % 2 == 0) {\\r\\n            pe[k1++] = p[j];  /// Assigning values of even Coefficients\\r\\n\\r\\n        } else {\\r\\n            po[k2++] = p[j];  /// Assigning value of odd Coefficients\\r\\n        }\\r\\n    }\\r\\n\\r\\n    std::complex<double> *ye =\\r\\n        FastFourierTransform(pe, n / 2);  /// Recursive Call\\r\\n\\r\\n    std::complex<double> *yo =\\r\\n        FastFourierTransform(po, n / 2);  /// Recursive Call\\r\\n\\r\\n    auto *y = new std::complex<double>[n];  /// Final value representation list\\r\\n\\r\\n    k1 = 0, k2 = 0;\\r\\n\\r\\n    for (int i = 0; i < n / 2; i++) {\\r\\n        y[i] =\\r\\n            ye[k1] + pow(om, i) * yo[k2];  /// Updating the first n/2 elements\\r\\n        y[i + n / 2] =\\r\\n            ye[k1] - pow(om, i) * yo[k2];  /// Updating the last n/2 elements\\r\\n\\r\\n        k1++;\\r\\n        k2++;\\r\\n    }\\r\\n\\r\\n    if (n != 2) {\\r\\n        delete[] pe;\\r\\n        delete[] po;\\r\\n    }\\r\\n\\r\\n    delete[] ye;  /// Deleting dynamic array ye\\r\\n    delete[] yo;  /// Deleting dynamic array yo\\r\\n    return y;\\r\\n}\\r\\n\\r\\n}  // namespace numerical_methods\\r\\n\\r\\n/**\\r\\n * @brief Self-test implementations\\r\\n * @details\\r\\n * Declaring two test cases and checking for the error\\r\\n * in predicted and true value is less than 0.000000000001.\\r\\n * @returns void\\r\\n */\\r\\nstatic void test() {\\r\\n    /* descriptions of the following test */\\r\\n\\r\\n    auto *t1 = new std::complex<double>[2];  /// Test case 1\\r\\n    auto *t2 = new std::complex<double>[4];  /// Test case 2\\r\\n\\r\\n    t1[0] = {1, 0};\\r\\n    t1[1] = {2, 0};\\r\\n    t2[0] = {1, 0};\\r\\n    t2[1] = {2, 0};\\r\\n    t2[2] = {3, 0};\\r\\n    t2[3] = {4, 0};\\r\\n\\r\\n    uint8_t n1 = 2;\\r\\n    uint8_t n2 = 4;\\r\\n    std::vector<std::complex<double>> r1 = {\\r\\n        {3, 0}, {-1, 0}};  /// True Answer for test case 1\\r\\n\\r\\n    std::vector<std::complex<double>> r2 = {\\r\\n        {10, 0}, {-2, -2}, {-2, 0}, {-2, 2}};  /// True Answer for test case 2\\r\\n\\r\\n    std::complex<double> *o1 = numerical_methods::FastFourierTransform(t1, n1);\\r\\n    std::complex<double> *t3 =\\r\\n        o1;  /// Temporary variable used to delete memory location of o1\\r\\n    std::complex<double> *o2 = numerical_methods::FastFourierTransform(t2, n2);\\r\\n    std::complex<double> *t4 =\\r\\n        o2;  /// Temporary variable used to delete memory location of o2\\r\\n    for (uint8_t i = 0; i < n1; i++) {\\r\\n        assert((r1[i].real() - o1->real() < 0.000000000001) &&\\r\\n               (r1[i].imag() - o1->imag() <\\r\\n                0.000000000001));  /// Comparing for both real and imaginary\\r\\n                                   /// values for test case 1\\r\\n        o1++;\\r\\n    }\\r\\n\\r\\n    for (uint8_t i = 0; i < n2; i++) {\\r\\n        assert((r2[i].real() - o2->real() < 0.000000000001) &&\\r\\n               (r2[i].imag() - o2->imag() <\\r\\n                0.000000000001));  /// Comparing for both real and imaginary\\r\\n                                   /// values for test case 2\\r\\n        o2++;\\r\\n    }\\r\\n\\r\\n    delete[] t1;\\r\\n    delete[] t2;\\r\\n    delete[] t3;\\r\\n    delete[] t4;\\r\\n    std::cout << \\\"All tests have successfully passed!\\\\n\\\";\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @param argc commandline argument count (ignored)\\r\\n * @param argv commandline array of arguments (ignored)\\r\\n * calls automated test function to test the working of fast fourier transform.\\r\\n * @returns 0 on exit\\r\\n */\\r\\n\\r\\nint main(int argc, char const *argv[]) {\\r\\n    test();  //  run self-test implementations\\r\\n             //  with 2 defined test cases\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "gaussian elimination": "\"/**\\n * \\\\file\\n * \\\\brief [Gaussian elimination\\n * method](https://en.wikipedia.org/wiki/Gaussian_elimination)\\n */\\n#include <iostream>\\n\\n/** Main function */\\nint main() {\\n    int mat_size, i, j, step;\\n\\n    std::cout << \\\"Matrix size: \\\";\\n    std::cin >> mat_size;\\n\\n    // create a 2D matrix by dynamic memory allocation\\n    double **mat = new double *[mat_size + 1], **x = new double *[mat_size];\\n    for (i = 0; i <= mat_size; i++) {\\n        mat[i] = new double[mat_size + 1];\\n        if (i < mat_size)\\n            x[i] = new double[mat_size + 1];\\n    }\\n\\n    // get the matrix elements from user\\n    std::cout << std::endl << \\\"Enter value of the matrix: \\\" << std::endl;\\n    for (i = 0; i < mat_size; i++) {\\n        for (j = 0; j <= mat_size; j++) {\\n            std::cin >>\\n                mat[i][j];  // Enter (mat_size*mat_size) value of the matrix.\\n        }\\n    }\\n\\n    // perform Gaussian elimination\\n    for (step = 0; step < mat_size - 1; step++) {\\n        for (i = step; i < mat_size - 1; i++) {\\n            double a = (mat[i + 1][step] / mat[step][step]);\\n\\n            for (j = step; j <= mat_size; j++)\\n                mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]);\\n        }\\n    }\\n\\n    std::cout << std::endl\\n              << \\\"Matrix using Gaussian Elimination method: \\\" << std::endl;\\n    for (i = 0; i < mat_size; i++) {\\n        for (j = 0; j <= mat_size; j++) {\\n            x[i][j] = mat[i][j];\\n            std::cout << mat[i][j] << \\\" \\\";\\n        }\\n        std::cout << std::endl;\\n    }\\n    std::cout << std::endl\\n              << \\\"Value of the Gaussian Elimination method: \\\" << std::endl;\\n    for (i = mat_size - 1; i >= 0; i--) {\\n        double sum = 0;\\n        for (j = mat_size - 1; j > i; j--) {\\n            x[i][j] = x[j][j] * x[i][j];\\n            sum = x[i][j] + sum;\\n        }\\n        if (x[i][i] == 0)\\n            x[i][i] = 0;\\n        else\\n            x[i][i] = (x[i][mat_size] - sum) / (x[i][i]);\\n\\n        std::cout << \\\"x\\\" << i << \\\"= \\\" << x[i][i] << std::endl;\\n    }\\n\\n    for (i = 0; i <= mat_size; i++) {\\n        delete[] mat[i];\\n        if (i < mat_size)\\n            delete[] x[i];\\n    }\\n    delete[] mat;\\n    delete[] x;\\n\\n    return 0;\\n}\\n\"",
    "golden search extrema": "\"/**\\n * \\\\file\\n * \\\\brief Find extrema of a univariate real function in a given interval using\\n * [golden section search\\n * algorithm](https://en.wikipedia.org/wiki/Golden-section_search).\\n *\\n * \\\\see brent_method_extrema.cpp\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#define _USE_MATH_DEFINES  //< required for MS Visual C++\\n#include <cassert>\\n#include <cmath>\\n#include <functional>\\n#include <iostream>\\n#include <limits>\\n\\n#define EPSILON 1e-7  ///< solution accuracy limit\\n\\n/**\\n * @brief Get the minima of a function in the given interval. To get the maxima,\\n * simply negate the function. The golden ratio used here is:\\\\f[\\n * k=\\\\frac{3-\\\\sqrt{5}}{2} \\\\approx 0.381966\\\\ldots\\\\f]\\n *\\n * @param f function to get minima for\\n * @param lim_a lower limit of search window\\n * @param lim_b upper limit of search window\\n * @return local minima found in the interval\\n */\\ndouble get_minima(const std::function<double(double)> &f, double lim_a,\\n                  double lim_b) {\\n    uint32_t iters = 0;\\n    double c, d;\\n    double prev_mean, mean = std::numeric_limits<double>::infinity();\\n\\n    // golden ratio value\\n    const double M_GOLDEN_RATIO = (1.f + std::sqrt(5.f)) / 2.f;\\n\\n    // ensure that lim_a < lim_b\\n    if (lim_a > lim_b) {\\n        std::swap(lim_a, lim_b);\\n    } else if (std::abs(lim_a - lim_b) <= EPSILON) {\\n        std::cerr << \\\"Search range must be greater than \\\" << EPSILON << \\\"\\\\n\\\";\\n        return lim_a;\\n    }\\n\\n    do {\\n        prev_mean = mean;\\n\\n        // compute the section ratio width\\n        double ratio = (lim_b - lim_a) / M_GOLDEN_RATIO;\\n        c = lim_b - ratio;  // right-side section start\\n        d = lim_a + ratio;  // left-side section end\\n\\n        if (f(c) < f(d)) {\\n            // select left section\\n            lim_b = d;\\n        } else {\\n            // selct right section\\n            lim_a = c;\\n        }\\n\\n        mean = (lim_a + lim_b) / 2.f;\\n        iters++;\\n\\n        // continue till the interval width is greater than sqrt(system epsilon)\\n    } while (std::abs(lim_a - lim_b) > EPSILON);\\n\\n    std::cout << \\\" (iters: \\\" << iters << \\\") \\\";\\n    return prev_mean;\\n}\\n\\n/**\\n * @brief Test function to find minima for the function\\n * \\\\f$f(x)= (x-2)^2\\\\f$\\n * in the interval \\\\f$[1,5]\\\\f$\\n * \\\\n Expected result = 2\\n */\\nvoid test1() {\\n    // define the function to minimize as a lambda function\\n    std::function<double(double)> f1 = [](double x) {\\n        return (x - 2) * (x - 2);\\n    };\\n\\n    std::cout << \\\"Test 1.... \\\";\\n\\n    double minima = get_minima(f1, 1, 5);\\n\\n    std::cout << minima << \\\"...\\\";\\n\\n    assert(std::abs(minima - 2) < EPSILON);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/**\\n * @brief Test function to find *maxima* for the function\\n * \\\\f$f(x)= x^{\\\\frac{1}{x}}\\\\f$\\n * in the interval \\\\f$[-2,10]\\\\f$\\n * \\\\n Expected result: \\\\f$e\\\\approx 2.71828182845904509\\\\f$\\n */\\nvoid test2() {\\n    // define the function to maximize as a lambda function\\n    // since we are maximixing, we negated the function return value\\n    std::function<double(double)> func = [](double x) {\\n        return -std::pow(x, 1.f / x);\\n    };\\n\\n    std::cout << \\\"Test 2.... \\\";\\n\\n    double minima = get_minima(func, -2, 10);\\n\\n    std::cout << minima << \\\" (\\\" << M_E << \\\")...\\\";\\n\\n    assert(std::abs(minima - M_E) < EPSILON);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/**\\n * @brief Test function to find *maxima* for the function\\n * \\\\f$f(x)= \\\\cos x\\\\f$\\n * in the interval \\\\f$[0,12]\\\\f$\\n * \\\\n Expected result: \\\\f$\\\\pi\\\\approx 3.14159265358979312\\\\f$\\n */\\nvoid test3() {\\n    // define the function to maximize as a lambda function\\n    // since we are maximixing, we negated the function return value\\n    std::function<double(double)> func = [](double x) { return std::cos(x); };\\n\\n    std::cout << \\\"Test 3.... \\\";\\n\\n    double minima = get_minima(func, -4, 12);\\n\\n    std::cout << minima << \\\" (\\\" << M_PI << \\\")...\\\";\\n\\n    assert(std::abs(minima - M_PI) < EPSILON);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/** Main function */\\nint main() {\\n    std::cout.precision(9);\\n\\n    std::cout << \\\"Computations performed with machine epsilon: \\\" << EPSILON\\n              << \\\"\\\\n\\\";\\n\\n    test1();\\n    test2();\\n    test3();\\n\\n    return 0;\\n}\\n\"",
    "inverse fast fourier transform": "\"/**\\n * @file\\n * @brief [An inverse fast Fourier transform\\n * (IFFT)](https://www.geeksforgeeks.org/python-inverse-fast-fourier-transformation/)\\n * is an algorithm that computes the inverse fourier transform.\\n * @details\\n * This algorithm has an application in use case scenario where a user wants\\n * find coefficients of a function in a short time by just using points\\n * generated by DFT. Time complexity this algorithm computes the IDFT in\\n * O(nlogn) time in comparison to traditional O(n^2).\\n * @author [Ameya Chawla](https://github.com/ameyachawlaggsipu)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <cmath>     /// for mathematical-related functions\\n#include <complex>   /// for storing points and coefficents\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace numerical_methods\\n * @brief Numerical algorithms/methods\\n */\\nnamespace numerical_methods {\\n/**\\n * @brief InverseFastFourierTransform is a recursive function which returns list\\n * of complex numbers\\n * @param p List of Coefficents in form of complex numbers\\n * @param n Count of elements in list p\\n * @returns p if n==1\\n * @returns y if n!=1\\n */\\nstd::complex<double> *InverseFastFourierTransform(std::complex<double> *p,\\n                                                  uint8_t n) {\\n    if (n == 1) {\\n        return p;  /// Base Case To return\\n    }\\n\\n    double pi = 2 * asin(1.0);  /// Declaring value of pi\\n\\n    std::complex<double> om = std::complex<double>(\\n        cos(2 * pi / n), sin(2 * pi / n));  /// Calculating value of omega\\n\\n    om.real(om.real() / n);  /// One change in comparison with DFT\\n    om.imag(om.imag() / n);  /// One change in comparison with DFT\\n\\n    auto *pe = new std::complex<double>[n / 2];  /// Coefficients of even power\\n\\n    auto *po = new std::complex<double>[n / 2];  /// Coefficients of odd power\\n\\n    int k1 = 0, k2 = 0;\\n    for (int j = 0; j < n; j++) {\\n        if (j % 2 == 0) {\\n            pe[k1++] = p[j];  /// Assigning values of even Coefficients\\n\\n        } else {\\n            po[k2++] = p[j];  /// Assigning value of odd Coefficients\\n        }\\n    }\\n\\n    std::complex<double> *ye =\\n        InverseFastFourierTransform(pe, n / 2);  /// Recursive Call\\n\\n    std::complex<double> *yo =\\n        InverseFastFourierTransform(po, n / 2);  /// Recursive Call\\n\\n    auto *y = new std::complex<double>[n];  /// Final value representation list\\n\\n    k1 = 0, k2 = 0;\\n\\n    for (int i = 0; i < n / 2; i++) {\\n        y[i] =\\n            ye[k1] + pow(om, i) * yo[k2];  /// Updating the first n/2 elements\\n        y[i + n / 2] =\\n            ye[k1] - pow(om, i) * yo[k2];  /// Updating the last n/2 elements\\n\\n        k1++;\\n        k2++;\\n    }\\n\\n    if (n != 2) {\\n        delete[] pe;\\n        delete[] po;\\n    }\\n\\n    delete[] ye;  /// Deleting dynamic array ye\\n    delete[] yo;  /// Deleting dynamic array yo\\n    return y;\\n}\\n\\n}  // namespace numerical_methods\\n\\n/**\\n * @brief Self-test implementations\\n * @details\\n * Declaring two test cases and checking for the error\\n * in predicted and true value is less than 0.000000000001.\\n * @returns void\\n */\\nstatic void test() {\\n    /* descriptions of the following test */\\n\\n    auto *t1 = new std::complex<double>[2];  /// Test case 1\\n    auto *t2 = new std::complex<double>[4];  /// Test case 2\\n\\n    t1[0] = {3, 0};\\n    t1[1] = {-1, 0};\\n    t2[0] = {10, 0};\\n    t2[1] = {-2, -2};\\n    t2[2] = {-2, 0};\\n    t2[3] = {-2, 2};\\n\\n    uint8_t n1 = 2;\\n    uint8_t n2 = 4;\\n    std::vector<std::complex<double>> r1 = {\\n        {1, 0}, {2, 0}};  /// True Answer for test case 1\\n\\n    std::vector<std::complex<double>> r2 = {\\n        {1, 0}, {2, 0}, {3, 0}, {4, 0}};  /// True Answer for test case 2\\n\\n    std::complex<double> *o1 =\\n        numerical_methods::InverseFastFourierTransform(t1, n1);\\n\\n    std::complex<double> *o2 =\\n        numerical_methods::InverseFastFourierTransform(t2, n2);\\n\\n    for (uint8_t i = 0; i < n1; i++) {\\n        assert((r1[i].real() - o1[i].real() < 0.000000000001) &&\\n               (r1[i].imag() - o1[i].imag() <\\n                0.000000000001));  /// Comparing for both real and imaginary\\n                                   /// values for test case 1\\n    }\\n\\n    for (uint8_t i = 0; i < n2; i++) {\\n        assert((r2[i].real() - o2[i].real() < 0.000000000001) &&\\n               (r2[i].imag() - o2[i].imag() <\\n                0.000000000001));  /// Comparing for both real and imaginary\\n                                   /// values for test case 2\\n    }\\n\\n    delete[] t1;\\n    delete[] t2;\\n    delete[] o1;\\n    delete[] o2;\\n    std::cout << \\\"All tests have successfully passed!\\\\n\\\";\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * calls automated test function to test the working of fast fourier transform.\\n * @returns 0 on exit\\n */\\n\\nint main(int argc, char const *argv[]) {\\n    test();  //  run self-test implementations\\n             //  with 2 defined test cases\\n    return 0;\\n}\\n\"",
    "lu decompose": "\"/**\\n * \\\\file\\n * \\\\brief [LU decomposition](https://en.wikipedia.org/wiki/LU_decompositon) of a\\n * square matrix\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#include <cassert>\\n#include <ctime>\\n#include <iomanip>\\n#include <iostream>\\n\\n#include \\\"./lu_decomposition.h\\\"\\n\\n/**\\n * operator to print a matrix\\n */\\ntemplate <typename T>\\nstd::ostream &operator<<(std::ostream &out, matrix<T> const &v) {\\n    const int width = 10;\\n    const char separator = ' ';\\n\\n    for (size_t row = 0; row < v.size(); row++) {\\n        for (size_t col = 0; col < v[row].size(); col++)\\n            out << std::left << std::setw(width) << std::setfill(separator)\\n                << v[row][col];\\n        out << std::endl;\\n    }\\n\\n    return out;\\n}\\n\\n/**\\n * Test LU decomposition\\n * \\\\todo better ways to self-check a matrix output?\\n */\\nvoid test1() {\\n    int mat_size = 3;  // default matrix size\\n    const int range = 50;\\n    const int range2 = range >> 1;\\n\\n    /* Create a square matrix with random values */\\n    matrix<double> A(mat_size, std::valarray<double>(mat_size));\\n    matrix<double> L(mat_size, std::valarray<double>(mat_size));  // output\\n    matrix<double> U(mat_size, std::valarray<double>(mat_size));  // output\\n    for (int i = 0; i < mat_size; i++) {\\n        // calloc so that all valeus are '0' by default\\n        for (int j = 0; j < mat_size; j++)\\n            /* create random values in the limits [-range2, range-1] */\\n            A[i][j] = static_cast<double>(std::rand() % range - range2);\\n    }\\n\\n    std::clock_t start_t = std::clock();\\n    lu_decomposition(A, &L, &U);\\n    std::clock_t end_t = std::clock();\\n    std::cout << \\\"Time taken: \\\"\\n              << static_cast<double>(end_t - start_t) / CLOCKS_PER_SEC << \\\"\\\\n\\\";\\n\\n    std::cout << \\\"A = \\\\n\\\" << A << \\\"\\\\n\\\";\\n    std::cout << \\\"L = \\\\n\\\" << L << \\\"\\\\n\\\";\\n    std::cout << \\\"U = \\\\n\\\" << U << \\\"\\\\n\\\";\\n}\\n\\n/**\\n * Test determinant computation using LU decomposition\\n */\\nvoid test2() {\\n    std::cout << \\\"Determinant test 1...\\\";\\n    matrix<int> A1({{1, 2, 3}, {4, 9, 6}, {7, 8, 9}});\\n    assert(determinant_lu(A1) == -48);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Determinant test 2...\\\";\\n    matrix<int> A2({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});\\n    assert(determinant_lu(A2) == 0);\\n    std::cout << \\\"passed\\\\n\\\";\\n\\n    std::cout << \\\"Determinant test 3...\\\";\\n    matrix<float> A3({{1.2, 2.3, 3.4}, {4.5, 5.6, 6.7}, {7.8, 8.9, 9.0}});\\n    assert(determinant_lu(A3) == 3.63);\\n    std::cout << \\\"passed\\\\n\\\";\\n}\\n\\n/** Main function */\\nint main(int argc, char **argv) {\\n    std::srand(std::time(NULL));  // random number initializer\\n\\n    test1();\\n    test2();\\n    return 0;\\n}\\n\"",
    "lu decomposition": "\"/**\\n * @file lu_decomposition.h\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Functions associated with [LU\\n * Decomposition](https://en.wikipedia.org/wiki/LU_decomposition)\\n * of a square matrix.\\n */\\n#pragma once\\n\\n#include <iostream>\\n#include <valarray>\\n#include <vector>\\n#ifdef _OPENMP\\n#include <omp.h>\\n#endif\\n\\n/** Define matrix type as a `std::vector` of `std::valarray` */\\ntemplate <typename T>\\nusing matrix = std::vector<std::valarray<T>>;\\n\\n/** Perform LU decomposition on matrix\\n * \\\\param[in] A matrix to decompose\\n * \\\\param[out] L output L matrix\\n * \\\\param[out] U output U matrix\\n * \\\\returns 0 if no errors\\n * \\\\returns negative if error occurred\\n */\\ntemplate <typename T>\\nint lu_decomposition(const matrix<T> &A, matrix<double> *L, matrix<double> *U) {\\n    int row, col, j;\\n    int mat_size = A.size();\\n\\n    if (mat_size != A[0].size()) {\\n        // check matrix is a square matrix\\n        std::cerr << \\\"Not a square matrix!\\\\n\\\";\\n        return -1;\\n    }\\n\\n    // regularize each row\\n    for (row = 0; row < mat_size; row++) {\\n        // Upper triangular matrix\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n        for (col = row; col < mat_size; col++) {\\n            // Summation of L[i,j] * U[j,k]\\n            double lu_sum = 0.;\\n            for (j = 0; j < row; j++) {\\n                lu_sum += L[0][row][j] * U[0][j][col];\\n            }\\n\\n            // Evaluate U[i,k]\\n            U[0][row][col] = A[row][col] - lu_sum;\\n        }\\n\\n        // Lower triangular matrix\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n        for (col = row; col < mat_size; col++) {\\n            if (row == col) {\\n                L[0][row][col] = 1.;\\n                continue;\\n            }\\n\\n            // Summation of L[i,j] * U[j,k]\\n            double lu_sum = 0.;\\n            for (j = 0; j < row; j++) {\\n                lu_sum += L[0][col][j] * U[0][j][row];\\n            }\\n\\n            // Evaluate U[i,k]\\n            L[0][col][row] = (A[col][row] - lu_sum) / U[0][row][row];\\n        }\\n    }\\n\\n    return 0;\\n}\\n\\n/**\\n * Compute determinant of an NxN square matrix using LU decomposition.\\n * Using LU decomposition, the determinant is given by the product of diagonal\\n * elements of matrices L and U.\\n *\\n * @tparam T datatype of input matrix - int, unsigned int, double, etc\\n * @param A input square matrix\\n * @return determinant of matrix A\\n */\\ntemplate <typename T>\\ndouble determinant_lu(const matrix<T> &A) {\\n    matrix<double> L(A.size(), std::valarray<double>(A.size()));\\n    matrix<double> U(A.size(), std::valarray<double>(A.size()));\\n\\n    if (lu_decomposition(A, &L, &U) < 0)\\n        return 0;\\n\\n    double result = 1.f;\\n    for (size_t i = 0; i < A.size(); i++) {\\n        result *= L[i][i] * U[i][i];\\n    }\\n    return result;\\n}\\n\"",
    "midpoint integral method": "\"/**\\n * @file\\n * @brief A numerical method for easy [approximation of\\n * integrals](https://en.wikipedia.org/wiki/Midpoint_method)\\n * @details The idea is to split the interval into N of intervals and use as\\n * interpolation points the xi for which it applies that xi = x0 + i*h, where h\\n * is a step defined as h = (b-a)/N where a and b are the first and last points\\n * of the interval of the integration [a, b].\\n *\\n * We create a table of the xi and their corresponding f(xi) values and we\\n * evaluate the integral by the formula: I = h * {f(x0+h/2) + f(x1+h/2) + ... +\\n * f(xN-1+h/2)}\\n *\\n * Arguments can be passed as parameters from the command line argv[1] = N,\\n * argv[2] = a, argv[3] = b. In this case if the default values N=16, a=1, b=3\\n * are changed then the tests/assert are disabled.\\n *\\n *\\n * @author [ggkogkou](https://github.com/ggkogkou)\\n */\\n#include <cassert>     /// for assert\\n#include <cmath>       /// for math functions\\n#include <cstdint>     /// for integer allocation\\n#include <cstdlib>     /// for std::atof\\n#include <functional>  /// for std::function\\n#include <iostream>    /// for IO operations\\n#include <map>         /// for std::map container\\n\\n/**\\n * @namespace numerical_methods\\n * @brief Numerical algorithms/methods\\n */\\nnamespace numerical_methods {\\n/**\\n * @namespace midpoint_rule\\n * @brief Functions for the [Midpoint\\n * Integral](https://en.wikipedia.org/wiki/Midpoint_method) method\\n * implementation\\n */\\nnamespace midpoint_rule {\\n/**\\n * @fn double midpoint(const std::int32_t N, const double h, const double a,\\n * const std::function<double (double)>& func)\\n * @brief Main function for implementing the Midpoint Integral Method\\n * implementation\\n * @param N is the number of intervals\\n * @param h is the step\\n * @param a is x0\\n * @param func is the function that will be integrated\\n * @returns the result of the integration\\n */\\ndouble midpoint(const std::int32_t N, const double h, const double a,\\n                const std::function<double(double)>& func) {\\n    std::map<int, double>\\n        data_table;  // Contains the data points, key: i, value: f(xi)\\n    double xi = a;   // Initialize xi to the starting point x0 = a\\n\\n    // Create the data table\\n    // Loop from x0 to xN-1\\n    double temp = NAN;\\n    for (std::int32_t i = 0; i < N; i++) {\\n        temp = func(xi + h / 2);  // find f(xi+h/2)\\n        data_table.insert(\\n            std::pair<std::int32_t, double>(i, temp));  // add i and f(xi)\\n        xi += h;  // Get the next point xi for the next iteration\\n    }\\n\\n    // Evaluate the integral.\\n    // Remember: {f(x0+h/2) + f(x1+h/2) + ... + f(xN-1+h/2)}\\n    double evaluate_integral = 0;\\n    for (std::int32_t i = 0; i < N; i++) evaluate_integral += data_table.at(i);\\n\\n    // Multiply by the coefficient h\\n    evaluate_integral *= h;\\n\\n    // If the result calculated is nan, then the user has given wrong input\\n    // interval.\\n    assert(!std::isnan(evaluate_integral) &&\\n           \\\"The definite integral can't be evaluated. Check the validity of \\\"\\n           \\\"your input.\\\\n\\\");\\n    // Else return\\n    return evaluate_integral;\\n}\\n\\n/**\\n * @brief A function f(x) that will be used to test the method\\n * @param x The independent variable xi\\n * @returns the value of the dependent variable yi = f(xi) = sqrt(xi) + ln(xi)\\n */\\ndouble f(double x) { return std::sqrt(x) + std::log(x); }\\n/**\\n * @brief A function g(x) that will be used to test the method\\n * @param x The independent variable xi\\n * @returns the value of the dependent variable yi = g(xi) = e^(-xi) * (4 -\\n * xi^2)\\n */\\ndouble g(double x) { return std::exp(-x) * (4 - std::pow(x, 2)); }\\n/**\\n * @brief A function k(x) that will be used to test the method\\n * @param x The independent variable xi\\n * @returns the value of the dependent variable yi = k(xi) = sqrt(2*xi^3 + 3)\\n */\\ndouble k(double x) { return std::sqrt(2 * std::pow(x, 3) + 3); }\\n/**\\n * @brief A function l(x) that will be used to test the method\\n * @param x The independent variable xi\\n * @returns the value of the dependent variable yi = l(xi) = xi + ln(2*xi + 1)\\n */\\ndouble l(double x) { return x + std::log(2 * x + 1); }\\n\\n}  // namespace midpoint_rule\\n}  // namespace numerical_methods\\n\\n/**\\n * @brief Self-test implementations\\n * @param N is the number of intervals\\n * @param h is the step\\n * @param a is x0\\n * @param b is the end of the interval\\n * @param used_argv_parameters is 'true' if argv parameters are given and\\n * 'false' if not\\n */\\nstatic void test(std::int32_t N, double h, double a, double b,\\n                 bool used_argv_parameters) {\\n    // Call midpoint() for each of the test functions f, g, k, l\\n    // Assert with two decimal point precision\\n    double result_f = numerical_methods::midpoint_rule::midpoint(\\n        N, h, a, numerical_methods::midpoint_rule::f);\\n    assert((used_argv_parameters || (result_f >= 4.09 && result_f <= 4.10)) &&\\n           \\\"The result of f(x) is wrong\\\");\\n    std::cout << \\\"The result of integral f(x) on interval [\\\" << a << \\\", \\\" << b\\n              << \\\"] is equal to: \\\" << result_f << std::endl;\\n\\n    double result_g = numerical_methods::midpoint_rule::midpoint(\\n        N, h, a, numerical_methods::midpoint_rule::g);\\n    assert((used_argv_parameters || (result_g >= 0.27 && result_g <= 0.28)) &&\\n           \\\"The result of g(x) is wrong\\\");\\n    std::cout << \\\"The result of integral g(x) on interval [\\\" << a << \\\", \\\" << b\\n              << \\\"] is equal to: \\\" << result_g << std::endl;\\n\\n    double result_k = numerical_methods::midpoint_rule::midpoint(\\n        N, h, a, numerical_methods::midpoint_rule::k);\\n    assert((used_argv_parameters || (result_k >= 9.06 && result_k <= 9.07)) &&\\n           \\\"The result of k(x) is wrong\\\");\\n    std::cout << \\\"The result of integral k(x) on interval [\\\" << a << \\\", \\\" << b\\n              << \\\"] is equal to: \\\" << result_k << std::endl;\\n\\n    double result_l = numerical_methods::midpoint_rule::midpoint(\\n        N, h, a, numerical_methods::midpoint_rule::l);\\n    assert((used_argv_parameters || (result_l >= 7.16 && result_l <= 7.17)) &&\\n           \\\"The result of l(x) is wrong\\\");\\n    std::cout << \\\"The result of integral l(x) on interval [\\\" << a << \\\", \\\" << b\\n              << \\\"] is equal to: \\\" << result_l << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, char** argv) {\\n    std::int32_t N =\\n        16;  /// Number of intervals to divide the integration interval.\\n    /// MUST BE EVEN\\n    double a = 1, b = 3;  /// Starting and ending point of the integration in\\n    /// the real axis\\n    double h = NAN;  /// Step, calculated by a, b and N\\n\\n    bool used_argv_parameters =\\n        false;  // If argv parameters are used then the assert must be omitted\\n    // for the test cases\\n\\n    // Get user input (by the command line parameters or the console after\\n    // displaying messages)\\n    if (argc == 4) {\\n        N = std::atoi(argv[1]);\\n        a = std::atof(argv[2]);\\n        b = std::atof(argv[3]);\\n        // Check if a<b else abort\\n        assert(a < b && \\\"a has to be less than b\\\");\\n        assert(N > 0 && \\\"N has to be > 0\\\");\\n        if (N < 4 || a != 1 || b != 3) {\\n            used_argv_parameters = true;\\n        }\\n        std::cout << \\\"You selected N=\\\" << N << \\\", a=\\\" << a << \\\", b=\\\" << b\\n                  << std::endl;\\n    } else {\\n        std::cout << \\\"Default N=\\\" << N << \\\", a=\\\" << a << \\\", b=\\\" << b\\n                  << std::endl;\\n    }\\n\\n    // Find the step\\n    h = (b - a) / N;\\n\\n    test(N, h, a, b, used_argv_parameters);  // run self-test implementations\\n\\n    return 0;\\n}\\n\"",
    "newton raphson method": "\"/**\\n * \\\\file\\n * \\\\brief Solve the equation \\\\f$f(x)=0\\\\f$ using [Newton-Raphson\\n * method](https://en.wikipedia.org/wiki/Newton%27s_method) for both real and\\n * complex solutions\\n *\\n * The \\\\f$(i+1)^\\\\text{th}\\\\f$ approximation is given by:\\n * \\\\f[\\n * x_{i+1} = x_i - \\\\frac{f(x_i)}{f'(x_i)}\\n * \\\\f]\\n *\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n * \\\\see bisection_method.cpp, false_position.cpp\\n */\\n#include <cmath>\\n#include <ctime>\\n#include <iostream>\\n#include <limits>\\n\\nconstexpr double EPSILON = 1e-10;              ///< system accuracy limit\\nconstexpr int16_t MAX_ITERATIONS = INT16_MAX;  ///< Maximum number of iterations\\n\\n/** define \\\\f$f(x)\\\\f$ to find root for.\\n * Currently defined as:\\n * \\\\f[\\n * f(x) = x^3 - 4x - 9\\n * \\\\f]\\n */\\nstatic double eq(double i) {\\n    return (std::pow(i, 3) - (4 * i) - 9);  // original equation\\n}\\n\\n/** define the derivative function \\\\f$f'(x)\\\\f$\\n * For the current problem, it is:\\n * \\\\f[\\n * f'(x) = 3x^2 - 4\\n * \\\\f]\\n */\\nstatic double eq_der(double i) {\\n    return ((3 * std::pow(i, 2)) - 4);  // derivative of equation\\n}\\n\\n/** Main function */\\nint main() {\\n    std::srand(std::time(nullptr));  // initialize randomizer\\n\\n    double z = NAN, c = std::rand() % 100, m = NAN, n = NAN;\\n    int i = 0;\\n\\n    std::cout << \\\"\\\\nInitial approximation: \\\" << c;\\n\\n    // start iterations\\n    for (i = 0; i < MAX_ITERATIONS; i++) {\\n        m = eq(c);\\n        n = eq_der(c);\\n\\n        z = c - (m / n);\\n        c = z;\\n\\n        if (std::abs(m) < EPSILON) {  // stoping criteria\\n            break;\\n        }\\n    }\\n\\n    std::cout << \\\"\\\\n\\\\nRoot: \\\" << z << \\\"\\\\t\\\\tSteps: \\\" << i << std::endl;\\n    return 0;\\n}\\n\"",
    "ode forward euler": "\"/**\\n * \\\\file\\n * \\\\authors [Krishna Vedala](https://github.com/kvedala)\\n * \\\\brief Solve a multivariable first order [ordinary differential equation\\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\\n * [forward Euler\\n * method](https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations#Euler_method)\\n *\\n * \\\\details\\n * The ODE being solved is:\\n * \\\\f{eqnarray*}{\\n * \\\\dot{u} &=& v\\\\\\\\\\n * \\\\dot{v} &=& -\\\\omega^2 u\\\\\\\\\\n * \\\\omega &=& 1\\\\\\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\\\qquad\\\\ldots\\\\text{(initial values)}\\n * \\\\f}\\n * The exact solution for the above problem is:\\n * \\\\f{eqnarray*}{\\n * u(x) &=& \\\\cos(x)\\\\\\\\\\n * v(x) &=& -\\\\sin(x)\\\\\\\\\\n * \\\\f}\\n * The computation results are stored to a text file `forward_euler.csv` and the\\n * exact soltuion results in `exact.csv` for comparison.\\n * <img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/ode_forward_euler.svg\\\"\\n * alt=\\\"Implementation solution\\\"/>\\n *\\n * To implement [Van der Pol\\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\\n * ::problem function to:\\n * ```cpp\\n * const double mu = 2.0;\\n * dy[0] = y[1];\\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\\n * ```\\n * \\\\see ode_midpoint_euler.cpp, ode_semi_implicit_euler.cpp\\n */\\n\\n#include <cmath>\\n#include <ctime>\\n#include <fstream>\\n#include <iostream>\\n#include <valarray>\\n\\n/**\\n * @brief Problem statement for a system with first-order differential\\n * equations. Updates the system differential variables.\\n * \\\\note This function can be updated to and ode of any order.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable(s)\\n * @param[in,out]\\ty\\t\\tdependent variable(s)\\n * @param[in,out]\\tdy\\t    first-derivative of dependent variable(s)\\n */\\nvoid problem(const double &x, std::valarray<double> *y,\\n             std::valarray<double> *dy) {\\n    const double omega = 1.F;             // some const for the problem\\n    (*dy)[0] = (*y)[1];                   // x dot // NOLINT\\n    (*dy)[1] = -omega * omega * (*y)[0];  // y dot // NOLINT\\n}\\n\\n/**\\n * @brief Exact solution of the problem. Used for solution comparison.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable\\n * @param[in,out]\\ty\\t\\tdependent variable\\n */\\nvoid exact_solution(const double &x, std::valarray<double> *y) {\\n    y[0][0] = std::cos(x);\\n    y[0][1] = -std::sin(x);\\n}\\n\\n/** \\\\addtogroup ode Ordinary Differential Equations\\n * Integration functions for implementations with solving [ordinary differential\\n * equations](https://en.wikipedia.org/wiki/Ordinary_differential_equation)\\n * (ODEs) of any order and and any number of independent variables.\\n * @{\\n */\\n/**\\n * @brief Compute next step approximation using the forward-Euler\\n * method. @f[y_{n+1}=y_n + dx\\\\cdot f\\\\left(x_n,y_n\\\\right)@f]\\n * @param[in] \\t\\tdx\\tstep size\\n * @param[in] \\t    x\\ttake \\\\f$x_n\\\\f$ and compute \\\\f$x_{n+1}\\\\f$\\n * @param[in,out] \\ty\\ttake \\\\f$y_n\\\\f$ and compute \\\\f$y_{n+1}\\\\f$\\n * @param[in,out]\\tdy\\tcompute \\\\f$f\\\\left(x_n,y_n\\\\right)\\\\f$\\n */\\nvoid forward_euler_step(const double dx, const double x,\\n                        std::valarray<double> *y, std::valarray<double> *dy) {\\n    problem(x, y, dy);\\n    *y += *dy * dx;\\n}\\n\\n/**\\n * @brief Compute approximation using the forward-Euler\\n * method in the given limits.\\n * @param[in] \\t\\tdx  \\tstep size\\n * @param[in]   \\tx0  \\tinitial value of independent variable\\n * @param[in] \\t    x_max\\tfinal value of independent variable\\n * @param[in,out] \\ty\\t    take \\\\f$y_n\\\\f$ and compute \\\\f$y_{n+1}\\\\f$\\n * @param[in] save_to_file\\tflag to save results to a CSV file (1) or not (0)\\n * @returns time taken for computation in seconds\\n */\\ndouble forward_euler(double dx, double x0, double x_max,\\n                     std::valarray<double> *y, bool save_to_file = false) {\\n    std::valarray<double> dy = *y;\\n\\n    std::ofstream fp;\\n    if (save_to_file) {\\n        fp.open(\\\"forward_euler.csv\\\", std::ofstream::out);\\n        if (!fp.is_open()) {\\n            std::perror(\\\"Error! \\\");\\n        }\\n    }\\n\\n    std::size_t L = y->size();\\n\\n    /* start integration */\\n    std::clock_t t1 = std::clock();\\n    double x = x0;\\n\\n    do {  // iterate for each step of independent variable\\n        if (save_to_file && fp.is_open()) {\\n            // write to file\\n            fp << x << \\\",\\\";\\n            for (int i = 0; i < L - 1; i++) {\\n                fp << y[0][i] << \\\",\\\";  // NOLINT\\n            }\\n            fp << y[0][L - 1] << \\\"\\\\n\\\";  // NOLINT\\n        }\\n\\n        forward_euler_step(dx, x, y, &dy);  // perform integration\\n        x += dx;                            // update step\\n    } while (x <= x_max);  // till upper limit of independent variable\\n    /* end of integration */\\n    std::clock_t t2 = std::clock();\\n\\n    if (fp.is_open()) {\\n        fp.close();\\n    }\\n\\n    return static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\\n}\\n\\n/** @} */\\n\\n/**\\n * Function to compute and save exact solution for comparison\\n *\\n * \\\\param [in]    X0  \\t    initial value of independent variable\\n * \\\\param [in] \\t  X_MAX\\t    final value of independent variable\\n * \\\\param [in] \\t  step_size\\tindependent variable step size\\n * \\\\param [in]    Y0\\t    initial values of dependent variables\\n */\\nvoid save_exact_solution(const double &X0, const double &X_MAX,\\n                         const double &step_size,\\n                         const std::valarray<double> &Y0) {\\n    double x = X0;\\n    std::valarray<double> y(Y0);\\n\\n    std::ofstream fp(\\\"exact.csv\\\", std::ostream::out);\\n    if (!fp.is_open()) {\\n        std::perror(\\\"Error! \\\");\\n        return;\\n    }\\n    std::cout << \\\"Finding exact solution\\\\n\\\";\\n\\n    std::clock_t t1 = std::clock();\\n    do {\\n        fp << x << \\\",\\\";\\n        for (int i = 0; i < y.size() - 1; i++) {\\n            fp << y[i] << \\\",\\\";  // NOLINT\\n        }\\n        fp << y[y.size() - 1] << \\\"\\\\n\\\";  // NOLINT\\n\\n        exact_solution(x, &y);\\n\\n        x += step_size;\\n    } while (x <= X_MAX);\\n\\n    std::clock_t t2 = std::clock();\\n    double total_time = static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\\n    std::cout << \\\"\\\\tTime = \\\" << total_time << \\\" ms\\\\n\\\";\\n\\n    fp.close();\\n}\\n\\n/**\\n * Main Function\\n */\\nint main(int argc, char *argv[]) {\\n    double X0 = 0.f;                    /* initial value of x0 */\\n    double X_MAX = 10.F;                /* upper limit of integration */\\n    std::valarray<double> Y0{1.f, 0.f}; /* initial value Y = y(x = x_0) */\\n    double step_size = NAN;\\n\\n    if (argc == 1) {\\n        std::cout << \\\"\\\\nEnter the step size: \\\";\\n        std::cin >> step_size;\\n    } else {\\n        // use commandline argument as independent variable step size\\n        step_size = std::atof(argv[1]);\\n    }\\n\\n    // get approximate solution\\n    double total_time = forward_euler(step_size, X0, X_MAX, &Y0, true);\\n    std::cout << \\\"\\\\tTime = \\\" << total_time << \\\" ms\\\\n\\\";\\n\\n    /* compute exact solution for comparion */\\n    save_exact_solution(X0, X_MAX, step_size, Y0);\\n\\n    return 0;\\n}\\n\"",
    "ode midpoint euler": "\"/**\\n * \\\\file\\n * \\\\authors [Krishna Vedala](https://github.com/kvedala)\\n * \\\\brief Solve a multivariable first order [ordinary differential equation\\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\\n * [midpoint Euler\\n * method](https://en.wikipedia.org/wiki/Midpoint_method)\\n *\\n * \\\\details\\n * The ODE being solved is:\\n * \\\\f{eqnarray*}{\\n * \\\\dot{u} &=& v\\\\\\\\\\n * \\\\dot{v} &=& -\\\\omega^2 u\\\\\\\\\\n * \\\\omega &=& 1\\\\\\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\\\qquad\\\\ldots\\\\text{(initial values)}\\n * \\\\f}\\n * The exact solution for the above problem is:\\n * \\\\f{eqnarray*}{\\n * u(x) &=& \\\\cos(x)\\\\\\\\\\n * v(x) &=& -\\\\sin(x)\\\\\\\\\\n * \\\\f}\\n * The computation results are stored to a text file `midpoint_euler.csv` and\\n * the exact soltuion results in `exact.csv` for comparison. <img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/ode_midpoint_euler.svg\\\"\\n * alt=\\\"Implementation solution\\\"/>\\n *\\n * To implement [Van der Pol\\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\\n * ::problem function to:\\n * ```cpp\\n * const double mu = 2.0;\\n * dy[0] = y[1];\\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\\n * ```\\n * \\\\see ode_forward_euler.cpp, ode_semi_implicit_euler.cpp\\n */\\n\\n#include <cmath>\\n#include <ctime>\\n#include <fstream>\\n#include <iostream>\\n#include <valarray>\\n\\n/**\\n * @brief Problem statement for a system with first-order differential\\n * equations. Updates the system differential variables.\\n * \\\\note This function can be updated to and ode of any order.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable(s)\\n * @param[in,out]\\ty\\t\\tdependent variable(s)\\n * @param[in,out]\\tdy\\t    first-derivative of dependent variable(s)\\n */\\nvoid problem(const double &x, std::valarray<double> *y,\\n             std::valarray<double> *dy) {\\n    const double omega = 1.F;             // some const for the problem\\n    dy[0][0] = y[0][1];                   // x dot\\n    dy[0][1] = -omega * omega * y[0][0];  // y dot\\n}\\n\\n/**\\n * @brief Exact solution of the problem. Used for solution comparison.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable\\n * @param[in,out]\\ty\\t\\tdependent variable\\n */\\nvoid exact_solution(const double &x, std::valarray<double> *y) {\\n    y[0][0] = std::cos(x);\\n    y[0][1] = -std::sin(x);\\n}\\n\\n/** \\\\addtogroup ode Ordinary Differential Equations\\n * @{\\n */\\n/**\\n * @brief Compute next step approximation using the midpoint-Euler\\n * method.\\n * @f[y_{n+1} = y_n + dx\\\\, f\\\\left(x_n+\\\\frac{1}{2}dx,\\n * y_n + \\\\frac{1}{2}dx\\\\,f\\\\left(x_n,y_n\\\\right)\\\\right)@f]\\n *\\n * @param[in] \\t\\tdx\\tstep size\\n * @param[in] \\t    x\\ttake \\\\f$x_n\\\\f$ and compute \\\\f$x_{n+1}\\\\f$\\n * @param[in,out] \\ty\\ttake \\\\f$y_n\\\\f$ and compute \\\\f$y_{n+1}\\\\f$\\n * @param[in,out]\\tdy\\tcompute \\\\f$f\\\\left(x_n,y_n\\\\right)\\\\f$\\n */\\nvoid midpoint_euler_step(const double dx, const double &x,\\n                         std::valarray<double> *y, std::valarray<double> *dy) {\\n    problem(x, y, dy);\\n    double tmp_x = x + 0.5 * dx;\\n\\n    std::valarray<double> tmp_y = y[0] + dy[0] * (0.5 * dx);\\n\\n    problem(tmp_x, &tmp_y, dy);\\n\\n    y[0] += dy[0] * dx;\\n}\\n\\n/**\\n * @brief Compute approximation using the midpoint-Euler\\n * method in the given limits.\\n * @param[in] \\t\\tdx  \\tstep size\\n * @param[in]   \\tx0  \\tinitial value of independent variable\\n * @param[in] \\t    x_max\\tfinal value of independent variable\\n * @param[in,out] \\ty\\t    take \\\\f$y_n\\\\f$ and compute \\\\f$y_{n+1}\\\\f$\\n * @param[in] save_to_file\\tflag to save results to a CSV file (1) or not (0)\\n * @returns time taken for computation in seconds\\n */\\ndouble midpoint_euler(double dx, double x0, double x_max,\\n                      std::valarray<double> *y, bool save_to_file = false) {\\n    std::valarray<double> dy = y[0];\\n\\n    std::ofstream fp;\\n    if (save_to_file) {\\n        fp.open(\\\"midpoint_euler.csv\\\", std::ofstream::out);\\n        if (!fp.is_open()) {\\n            std::perror(\\\"Error! \\\");\\n        }\\n    }\\n\\n    std::size_t L = y->size();\\n\\n    /* start integration */\\n    std::clock_t t1 = std::clock();\\n    double x = x0;\\n    do {  // iterate for each step of independent variable\\n        if (save_to_file && fp.is_open()) {\\n            // write to file\\n            fp << x << \\\",\\\";\\n            for (int i = 0; i < L - 1; i++) {\\n                fp << y[0][i] << \\\",\\\";\\n            }\\n            fp << y[0][L - 1] << \\\"\\\\n\\\";\\n        }\\n\\n        midpoint_euler_step(dx, x, y, &dy);  // perform integration\\n        x += dx;                             // update step\\n    } while (x <= x_max);  // till upper limit of independent variable\\n    /* end of integration */\\n    std::clock_t t2 = std::clock();\\n\\n    if (fp.is_open())\\n        fp.close();\\n\\n    return static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\\n}\\n\\n/** @} */\\n\\n/**\\n * Function to compute and save exact solution for comparison\\n *\\n * \\\\param [in]    X0  \\t    initial value of independent variable\\n * \\\\param [in] \\t  X_MAX\\t    final value of independent variable\\n * \\\\param [in] \\t  step_size\\tindependent variable step size\\n * \\\\param [in]    Y0\\t    initial values of dependent variables\\n */\\nvoid save_exact_solution(const double &X0, const double &X_MAX,\\n                         const double &step_size,\\n                         const std::valarray<double> &Y0) {\\n    double x = X0;\\n    std::valarray<double> y = Y0;\\n\\n    std::ofstream fp(\\\"exact.csv\\\", std::ostream::out);\\n    if (!fp.is_open()) {\\n        std::perror(\\\"Error! \\\");\\n        return;\\n    }\\n    std::cout << \\\"Finding exact solution\\\\n\\\";\\n\\n    std::clock_t t1 = std::clock();\\n    do {\\n        fp << x << \\\",\\\";\\n        for (int i = 0; i < y.size() - 1; i++) {\\n            fp << y[i] << \\\",\\\";\\n        }\\n        fp << y[y.size() - 1] << \\\"\\\\n\\\";\\n\\n        exact_solution(x, &y);\\n\\n        x += step_size;\\n    } while (x <= X_MAX);\\n\\n    std::clock_t t2 = std::clock();\\n    double total_time = static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\\n    std::cout << \\\"\\\\tTime = \\\" << total_time << \\\" ms\\\\n\\\";\\n\\n    fp.close();\\n}\\n\\n/**\\n * Main Function\\n */\\nint main(int argc, char *argv[]) {\\n    double X0 = 0.f;                       /* initial value of x0 */\\n    double X_MAX = 10.F;                   /* upper limit of integration */\\n    std::valarray<double> Y0 = {1.f, 0.f}; /* initial value Y = y(x = x_0) */\\n    double step_size;\\n\\n    if (argc == 1) {\\n        std::cout << \\\"\\\\nEnter the step size: \\\";\\n        std::cin >> step_size;\\n    } else {\\n        // use commandline argument as independent variable step size\\n        step_size = std::atof(argv[1]);\\n    }\\n\\n    // get approximate solution\\n    double total_time = midpoint_euler(step_size, X0, X_MAX, &Y0, true);\\n    std::cout << \\\"\\\\tTime = \\\" << total_time << \\\" ms\\\\n\\\";\\n\\n    /* compute exact solution for comparion */\\n    save_exact_solution(X0, X_MAX, step_size, Y0);\\n\\n    return 0;\\n}\\n\"",
    "ode semi implicit euler": "\"/**\\n * \\\\file\\n * \\\\authors [Krishna Vedala](https://github.com/kvedala)\\n * \\\\brief Solve a multivariable first order [ordinary differential equation\\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\\n * [semi implicit Euler\\n * method](https://en.wikipedia.org/wiki/Semi-implicit_Euler_method)\\n *\\n * \\\\details\\n * The ODE being solved is:\\n * \\\\f{eqnarray*}{\\n * \\\\dot{u} &=& v\\\\\\\\\\n * \\\\dot{v} &=& -\\\\omega^2 u\\\\\\\\\\n * \\\\omega &=& 1\\\\\\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\\\qquad\\\\ldots\\\\text{(initial values)}\\n * \\\\f}\\n * The exact solution for the above problem is:\\n * \\\\f{eqnarray*}{\\n * u(x) &=& \\\\cos(x)\\\\\\\\\\n * v(x) &=& -\\\\sin(x)\\\\\\\\\\n * \\\\f}\\n * The computation results are stored to a text file `semi_implicit_euler.csv`\\n * and the exact soltuion results in `exact.csv` for comparison. <img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/ode_semi_implicit_euler.svg\\\"\\n * alt=\\\"Implementation solution\\\"/>\\n *\\n * To implement [Van der Pol\\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\\n * ::problem function to:\\n * ```cpp\\n * const double mu = 2.0;\\n * dy[0] = y[1];\\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\\n * ```\\n * \\\\see ode_midpoint_euler.cpp, ode_forward_euler.cpp\\n */\\n\\n#include <cmath>\\n#include <ctime>\\n#include <fstream>\\n#include <iostream>\\n#include <valarray>\\n\\n/**\\n * @brief Problem statement for a system with first-order differential\\n * equations. Updates the system differential variables.\\n * \\\\note This function can be updated to and ode of any order.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable(s)\\n * @param[in,out]\\ty\\t\\tdependent variable(s)\\n * @param[in,out]\\tdy\\t    first-derivative of dependent variable(s)\\n */\\nvoid problem(const double &x, std::valarray<double> *y,\\n             std::valarray<double> *dy) {\\n    const double omega = 1.F;             // some const for the problem\\n    dy[0][0] = y[0][1];                   // x dot\\n    dy[0][1] = -omega * omega * y[0][0];  // y dot\\n}\\n\\n/**\\n * @brief Exact solution of the problem. Used for solution comparison.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable\\n * @param[in,out]\\ty\\t\\tdependent variable\\n */\\nvoid exact_solution(const double &x, std::valarray<double> *y) {\\n    y[0][0] = std::cos(x);\\n    y[0][1] = -std::sin(x);\\n}\\n\\n/** \\\\addtogroup ode Ordinary Differential Equations\\n * @{\\n */\\n/**\\n * @brief Compute next step approximation using the semi-implicit-Euler\\n * method. @f[y_{n+1}=y_n + dx\\\\cdot f\\\\left(x_n,y_n\\\\right)@f]\\n * @param[in] \\t\\tdx\\tstep size\\n * @param[in] \\t    x\\ttake \\\\f$x_n\\\\f$ and compute \\\\f$x_{n+1}\\\\f$\\n * @param[in,out] \\ty\\ttake \\\\f$y_n\\\\f$ and compute \\\\f$y_{n+1}\\\\f$\\n * @param[in,out]\\tdy\\tcompute \\\\f$f\\\\left(x_n,y_n\\\\right)\\\\f$\\n */\\nvoid semi_implicit_euler_step(const double dx, const double &x,\\n                              std::valarray<double> *y,\\n                              std::valarray<double> *dy) {\\n    problem(x, y, dy);         // update dy once\\n    y[0][0] += dx * dy[0][0];  // update y0\\n    problem(x, y, dy);         // update dy once more\\n\\n    dy[0][0] = 0.f;      // ignore y0\\n    y[0] += dy[0] * dx;  // update remaining using new dy\\n}\\n\\n/**\\n * @brief Compute approximation using the semi-implicit-Euler\\n * method in the given limits.\\n * @param[in] \\t\\tdx  \\tstep size\\n * @param[in]   \\tx0  \\tinitial value of independent variable\\n * @param[in] \\t    x_max\\tfinal value of independent variable\\n * @param[in,out] \\ty\\t    take \\\\f$y_n\\\\f$ and compute \\\\f$y_{n+1}\\\\f$\\n * @param[in] save_to_file\\tflag to save results to a CSV file (1) or not (0)\\n * @returns time taken for computation in seconds\\n */\\ndouble semi_implicit_euler(double dx, double x0, double x_max,\\n                           std::valarray<double> *y,\\n                           bool save_to_file = false) {\\n    std::valarray<double> dy = y[0];\\n\\n    std::ofstream fp;\\n    if (save_to_file) {\\n        fp.open(\\\"semi_implicit_euler.csv\\\", std::ofstream::out);\\n        if (!fp.is_open()) {\\n            std::perror(\\\"Error! \\\");\\n        }\\n    }\\n\\n    std::size_t L = y->size();\\n\\n    /* start integration */\\n    std::clock_t t1 = std::clock();\\n    double x = x0;\\n    do {  // iterate for each step of independent variable\\n        if (save_to_file && fp.is_open()) {\\n            // write to file\\n            fp << x << \\\",\\\";\\n            for (int i = 0; i < L - 1; i++) {\\n                fp << y[0][i] << \\\",\\\";\\n            }\\n            fp << y[0][L - 1] << \\\"\\\\n\\\";\\n        }\\n\\n        semi_implicit_euler_step(dx, x, y, &dy);  // perform integration\\n        x += dx;                                  // update step\\n    } while (x <= x_max);  // till upper limit of independent variable\\n    /* end of integration */\\n    std::clock_t t2 = std::clock();\\n\\n    if (fp.is_open())\\n        fp.close();\\n\\n    return static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\\n}\\n\\n/** @} */\\n\\n/**\\n * Function to compute and save exact solution for comparison\\n *\\n * \\\\param [in]    X0  \\t    initial value of independent variable\\n * \\\\param [in] \\t  X_MAX\\t    final value of independent variable\\n * \\\\param [in] \\t  step_size\\tindependent variable step size\\n * \\\\param [in]    Y0\\t    initial values of dependent variables\\n */\\nvoid save_exact_solution(const double &X0, const double &X_MAX,\\n                         const double &step_size,\\n                         const std::valarray<double> &Y0) {\\n    double x = X0;\\n    std::valarray<double> y = Y0;\\n\\n    std::ofstream fp(\\\"exact.csv\\\", std::ostream::out);\\n    if (!fp.is_open()) {\\n        std::perror(\\\"Error! \\\");\\n        return;\\n    }\\n    std::cout << \\\"Finding exact solution\\\\n\\\";\\n\\n    std::clock_t t1 = std::clock();\\n    do {\\n        fp << x << \\\",\\\";\\n        for (int i = 0; i < y.size() - 1; i++) {\\n            fp << y[i] << \\\",\\\";\\n        }\\n        fp << y[y.size() - 1] << \\\"\\\\n\\\";\\n\\n        exact_solution(x, &y);\\n\\n        x += step_size;\\n    } while (x <= X_MAX);\\n\\n    std::clock_t t2 = std::clock();\\n    double total_time = static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\\n    std::cout << \\\"\\\\tTime = \\\" << total_time << \\\" ms\\\\n\\\";\\n\\n    fp.close();\\n}\\n\\n/**\\n * Main Function\\n */\\nint main(int argc, char *argv[]) {\\n    double X0 = 0.f;                       /* initial value of x0 */\\n    double X_MAX = 10.F;                   /* upper limit of integration */\\n    std::valarray<double> Y0 = {1.f, 0.f}; /* initial value Y = y(x = x_0) */\\n    double step_size;\\n\\n    if (argc == 1) {\\n        std::cout << \\\"\\\\nEnter the step size: \\\";\\n        std::cin >> step_size;\\n    } else {\\n        // use commandline argument as independent variable step size\\n        step_size = std::atof(argv[1]);\\n    }\\n\\n    // get approximate solution\\n    double total_time = semi_implicit_euler(step_size, X0, X_MAX, &Y0, true);\\n    std::cout << \\\"\\\\tTime = \\\" << total_time << \\\" ms\\\\n\\\";\\n\\n    /* compute exact solution for comparion */\\n    save_exact_solution(X0, X_MAX, step_size, Y0);\\n\\n    return 0;\\n}\\n\"",
    "qr decompose": "\"/**\\n * @file\\n * \\\\brief Library functions to compute [QR\\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given\\n * matrix.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n\\n#ifndef NUMERICAL_METHODS_QR_DECOMPOSE_H_\\n#define NUMERICAL_METHODS_QR_DECOMPOSE_H_\\n\\n#include <cmath>\\n#include <cstdlib>\\n#include <iomanip>\\n#include <iostream>\\n#include <limits>\\n#include <numeric>\\n#include <valarray>\\n#ifdef _OPENMP\\n#include <omp.h>\\n#endif\\n\\n/** \\\\namespace qr_algorithm\\n * \\\\brief Functions to compute [QR\\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of any\\n * rectangular matrix\\n */\\nnamespace qr_algorithm {\\n/**\\n * operator to print a matrix\\n */\\ntemplate <typename T>\\nstd::ostream &operator<<(std::ostream &out,\\n                         std::valarray<std::valarray<T>> const &v) {\\n    const int width = 12;\\n    const char separator = ' ';\\n\\n    out.precision(4);\\n    for (size_t row = 0; row < v.size(); row++) {\\n        for (size_t col = 0; col < v[row].size(); col++)\\n            out << std::right << std::setw(width) << std::setfill(separator)\\n                << v[row][col];\\n        out << std::endl;\\n    }\\n\\n    return out;\\n}\\n\\n/**\\n * operator to print a vector\\n */\\ntemplate <typename T>\\nstd::ostream &operator<<(std::ostream &out, std::valarray<T> const &v) {\\n    const int width = 10;\\n    const char separator = ' ';\\n\\n    out.precision(4);\\n    for (size_t row = 0; row < v.size(); row++) {\\n        out << std::right << std::setw(width) << std::setfill(separator)\\n            << v[row];\\n    }\\n\\n    return out;\\n}\\n\\n/**\\n * Compute dot product of two vectors of equal lengths\\n *\\n * If \\\\f$\\\\vec{a}=\\\\left[a_0,a_1,a_2,...,a_L\\\\right]\\\\f$ and\\n * \\\\f$\\\\vec{b}=\\\\left[b_0,b_1,b_1,...,b_L\\\\right]\\\\f$ then\\n * \\\\f$\\\\vec{a}\\\\cdot\\\\vec{b}=\\\\displaystyle\\\\sum_{i=0}^L a_i\\\\times b_i\\\\f$\\n *\\n * \\\\returns \\\\f$\\\\vec{a}\\\\cdot\\\\vec{b}\\\\f$\\n */\\ntemplate <typename T>\\ninline double vector_dot(const std::valarray<T> &a, const std::valarray<T> &b) {\\n    return (a * b).sum();\\n    // could also use following\\n    // return std::inner_product(std::begin(a), std::end(a), std::begin(b),\\n    // 0.f);\\n}\\n\\n/**\\n * Compute magnitude of vector.\\n *\\n * If \\\\f$\\\\vec{a}=\\\\left[a_0,a_1,a_2,...,a_L\\\\right]\\\\f$ then\\n * \\\\f$\\\\left|\\\\vec{a}\\\\right|=\\\\sqrt{\\\\displaystyle\\\\sum_{i=0}^L a_i^2}\\\\f$\\n *\\n * \\\\returns \\\\f$\\\\left|\\\\vec{a}\\\\right|\\\\f$\\n */\\ntemplate <typename T>\\ninline double vector_mag(const std::valarray<T> &a) {\\n    double dot = vector_dot(a, a);\\n    return std::sqrt(dot);\\n}\\n\\n/**\\n * Compute projection of vector \\\\f$\\\\vec{a}\\\\f$ on \\\\f$\\\\vec{b}\\\\f$ defined as\\n * \\\\f[\\\\text{proj}_\\\\vec{b}\\\\vec{a}=\\\\frac{\\\\vec{a}\\\\cdot\\\\vec{b}}{\\\\left|\\\\vec{b}\\\\right|^2}\\\\vec{b}\\\\f]\\n *\\n * \\\\returns NULL if error, otherwise pointer to output\\n */\\ntemplate <typename T>\\nstd::valarray<T> vector_proj(const std::valarray<T> &a,\\n                             const std::valarray<T> &b) {\\n    double num = vector_dot(a, b);\\n    double deno = vector_dot(b, b);\\n\\n    /*! check for division by zero using machine epsilon */\\n    if (deno <= std::numeric_limits<double>::epsilon()) {\\n        std::cerr << \\\"[\\\" << __func__ << \\\"] Possible division by zero\\\\n\\\";\\n        return a;  // return vector a back\\n    }\\n\\n    double scalar = num / deno;\\n\\n    return b * scalar;\\n}\\n\\n/**\\n * Decompose matrix \\\\f$A\\\\f$ using [Gram-Schmidt\\n *process](https://en.wikipedia.org/wiki/QR_decomposition).\\n *\\n * \\\\f{eqnarray*}{\\n * \\\\text{given that}\\\\quad A &=&\\n *\\\\left[\\\\mathbf{a}_1,\\\\mathbf{a}_2,\\\\ldots,\\\\mathbf{a}_{N-1},\\\\right]\\\\\\\\\\n * \\\\text{where}\\\\quad\\\\mathbf{a}_i &=&\\n * \\\\left[a_{0i},a_{1i},a_{2i},\\\\ldots,a_{(M-1)i}\\\\right]^T\\\\quad\\\\ldots\\\\mbox{(column\\n * vectors)}\\\\\\\\\\n * \\\\text{then}\\\\quad\\\\mathbf{u}_i &=& \\\\mathbf{a}_i\\n *-\\\\sum_{j=0}^{i-1}\\\\text{proj}_{\\\\mathbf{u}_j}\\\\mathbf{a}_i\\\\\\\\\\n * \\\\mathbf{e}_i &=&\\\\frac{\\\\mathbf{u}_i}{\\\\left|\\\\mathbf{u}_i\\\\right|}\\\\\\\\\\n * Q &=& \\\\begin{bmatrix}\\\\mathbf{e}_0 & \\\\mathbf{e}_1 & \\\\mathbf{e}_2 & \\\\dots &\\n * \\\\mathbf{e}_{N-1}\\\\end{bmatrix}\\\\\\\\\\n * R &=& \\\\begin{bmatrix}\\\\langle\\\\mathbf{e}_0\\\\,,\\\\mathbf{a}_0\\\\rangle &\\n * \\\\langle\\\\mathbf{e}_1\\\\,,\\\\mathbf{a}_1\\\\rangle &\\n * \\\\langle\\\\mathbf{e}_2\\\\,,\\\\mathbf{a}_2\\\\rangle & \\\\dots \\\\\\\\\\n *                  0 & \\\\langle\\\\mathbf{e}_1\\\\,,\\\\mathbf{a}_1\\\\rangle &\\n * \\\\langle\\\\mathbf{e}_2\\\\,,\\\\mathbf{a}_2\\\\rangle & \\\\dots\\\\\\\\\\n *                  0 & 0 & \\\\langle\\\\mathbf{e}_2\\\\,,\\\\mathbf{a}_2\\\\rangle &\\n * \\\\dots\\\\\\\\ \\\\vdots & \\\\vdots & \\\\vdots & \\\\ddots\\n *      \\\\end{bmatrix}\\\\\\\\\\n * \\\\f}\\n */\\ntemplate <typename T>\\nvoid qr_decompose(\\n    const std::valarray<std::valarray<T>> &A, /**< input matrix to decompose */\\n    std::valarray<std::valarray<T>> *Q,       /**< output decomposed matrix */\\n    std::valarray<std::valarray<T>> *R        /**< output decomposed matrix */\\n) {\\n    std::size_t ROWS = A.size();        // number of rows of A\\n    std::size_t COLUMNS = A[0].size();  // number of columns of A\\n    std::valarray<T> col_vector(ROWS);\\n    std::valarray<T> col_vector2(ROWS);\\n    std::valarray<T> tmp_vector(ROWS);\\n\\n    for (int i = 0; i < COLUMNS; i++) {\\n        /* for each column => R is a square matrix of NxN */\\n        int j;\\n        R[0][i] = 0.; /* make R upper triangular */\\n\\n        /* get corresponding Q vector */\\n#ifdef _OPENMP\\n// parallelize on threads\\n#pragma omp for\\n#endif\\n        for (j = 0; j < ROWS; j++) {\\n            tmp_vector[j] = A[j][i]; /* accumulator for uk */\\n            col_vector[j] = A[j][i];\\n        }\\n        for (j = 0; j < i; j++) {\\n            for (int k = 0; k < ROWS; k++) {\\n                col_vector2[k] = Q[0][k][j];\\n            }\\n            col_vector2 = vector_proj(col_vector, col_vector2);\\n            tmp_vector -= col_vector2;\\n        }\\n\\n        double mag = vector_mag(tmp_vector);\\n\\n#ifdef _OPENMP\\n// parallelize on threads\\n#pragma omp for\\n#endif\\n        for (j = 0; j < ROWS; j++) Q[0][j][i] = tmp_vector[j] / mag;\\n\\n            /* compute upper triangular values of R */\\n#ifdef _OPENMP\\n// parallelize on threads\\n#pragma omp for\\n#endif\\n        for (int kk = 0; kk < ROWS; kk++) {\\n            col_vector[kk] = Q[0][kk][i];\\n        }\\n\\n#ifdef _OPENMP\\n// parallelize on threads\\n#pragma omp for\\n#endif\\n        for (int k = i; k < COLUMNS; k++) {\\n            for (int kk = 0; kk < ROWS; kk++) {\\n                col_vector2[kk] = A[kk][k];\\n            }\\n            R[0][i][k] = (col_vector * col_vector2).sum();\\n        }\\n    }\\n}\\n}  // namespace qr_algorithm\\n\\n#endif  // NUMERICAL_METHODS_QR_DECOMPOSE_H_\\n\"",
    "qr decomposition": "\"/**\\n * @file\\n * \\\\brief Program to compute the [QR\\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given\\n * matrix.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n\\n#include <array>\\n#include <cmath>\\n#include <cstdlib>\\n#include <ctime>\\n#include <iostream>\\n\\n#include \\\"./qr_decompose.h\\\"\\n\\nusing qr_algorithm::qr_decompose;\\nusing qr_algorithm::operator<<;\\n\\n/**\\n * main function\\n */\\nint main(void) {\\n    unsigned int ROWS, COLUMNS;\\n\\n    std::cout << \\\"Enter the number of rows and columns: \\\";\\n    std::cin >> ROWS >> COLUMNS;\\n\\n    std::cout << \\\"Enter matrix elements row-wise:\\\\n\\\";\\n\\n    std::valarray<std::valarray<double>> A(ROWS);\\n    std::valarray<std::valarray<double>> Q(ROWS);\\n    std::valarray<std::valarray<double>> R(COLUMNS);\\n    for (int i = 0; i < std::max(ROWS, COLUMNS); i++) {\\n        if (i < ROWS) {\\n            A[i] = std::valarray<double>(COLUMNS);\\n            Q[i] = std::valarray<double>(COLUMNS);\\n        }\\n        if (i < COLUMNS) {\\n            R[i] = std::valarray<double>(COLUMNS);\\n        }\\n    }\\n\\n    for (int i = 0; i < ROWS; i++)\\n        for (int j = 0; j < COLUMNS; j++) std::cin >> A[i][j];\\n\\n    std::cout << A << \\\"\\\\n\\\";\\n\\n    clock_t t1 = clock();\\n    qr_decompose(A, &Q, &R);\\n    double dtime = static_cast<double>(clock() - t1) / CLOCKS_PER_SEC;\\n\\n    std::cout << Q << \\\"\\\\n\\\";\\n    std::cout << R << \\\"\\\\n\\\";\\n    std::cout << \\\"Time taken to compute: \\\" << dtime << \\\" sec\\\\n \\\";\\n\\n    return 0;\\n}\\n\"",
    "qr eigen values": "\"/**\\n * @file\\n * \\\\brief Compute real eigen values and eigen vectors of a symmetric matrix\\n * using [QR decomposition](https://en.wikipedia.org/wiki/QR_decomposition)\\n * method.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#include <cassert>\\n#include <cmath>\\n#include <cstdlib>\\n#include <ctime>\\n#include <iostream>\\n#ifdef _OPENMP\\n#include <omp.h>\\n#endif\\n\\n#include \\\"./qr_decompose.h\\\"\\nusing qr_algorithm::operator<<;\\n\\n#define LIMS 9 /**< limit of range of matrix values */\\n\\n/**\\n * create a symmetric square matrix of given size with random elements. A\\n * symmetric square matrix will *always* have real eigen values.\\n *\\n * \\\\param[out] A matrix to create (must be pre-allocated in memory)\\n */\\nvoid create_matrix(std::valarray<std::valarray<double>> *A) {\\n    int i, j, tmp, lim2 = LIMS >> 1;\\n    int N = A->size();\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++) {\\n        A[0][i][i] = (std::rand() % LIMS) - lim2;\\n        for (j = i + 1; j < N; j++) {\\n            tmp = (std::rand() % LIMS) - lim2;\\n            A[0][i][j] = tmp;  // summetrically distribute random values\\n            A[0][j][i] = tmp;\\n        }\\n    }\\n}\\n\\n/**\\n * Perform multiplication of two matrices.\\n * * R2 must be equal to C1\\n * * Resultant matrix size should be R1xC2\\n * \\\\param[in] A first matrix to multiply\\n * \\\\param[in] B second matrix to multiply\\n * \\\\param[out] OUT output matrix (must be pre-allocated)\\n * \\\\returns pointer to resultant matrix\\n */\\nvoid mat_mul(const std::valarray<std::valarray<double>> &A,\\n             const std::valarray<std::valarray<double>> &B,\\n             std::valarray<std::valarray<double>> *OUT) {\\n    int R1 = A.size();\\n    int C1 = A[0].size();\\n    int R2 = B.size();\\n    int C2 = B[0].size();\\n    if (C1 != R2) {\\n        perror(\\\"Matrix dimensions mismatch!\\\");\\n        return;\\n    }\\n\\n    for (int i = 0; i < R1; i++) {\\n        for (int j = 0; j < C2; j++) {\\n            OUT[0][i][j] = 0.f;\\n            for (int k = 0; k < C1; k++) {\\n                OUT[0][i][j] += A[i][k] * B[k][j];\\n            }\\n        }\\n    }\\n}\\n\\nnamespace qr_algorithm {\\n/** Compute eigen values using iterative shifted QR decomposition algorithm as\\n * follows:\\n * 1. Use last diagonal element of A as eigen value approximation \\\\f$c\\\\f$\\n * 2. Shift diagonals of matrix \\\\f$A' = A - cI\\\\f$\\n * 3. Decompose matrix \\\\f$A'=QR\\\\f$\\n * 4. Compute next approximation \\\\f$A'_1 = RQ \\\\f$\\n * 5. Shift diagonals back \\\\f$A_1 = A'_1 + cI\\\\f$\\n * 6. Termination condition check: last element below diagonal is almost 0\\n *   1. If not 0, go back to step 1 with the new approximation \\\\f$A_1\\\\f$\\n *   2. If 0, continue to step 7\\n * 7. Save last known \\\\f$c\\\\f$ as the eigen value.\\n * 8. Are all eigen values found?\\n *   1. If not, remove last row and column of \\\\f$A_1\\\\f$ and go back to step 1.\\n *   2. If yes, stop.\\n *\\n * \\\\note The matrix \\\\f$A\\\\f$ gets modified\\n *\\n * \\\\param[in,out] A matrix to compute eigen values for\\n * \\\\param[in] print_intermediates (optional) whether to print intermediate A, Q\\n * and R matrices (default = `false`)\\n */\\nstd::valarray<double> eigen_values(std::valarray<std::valarray<double>> *A,\\n                                   bool print_intermediates = false) {\\n    int rows = A->size();\\n    int columns = rows;\\n    int counter = 0, num_eigs = rows - 1;\\n    double last_eig = 0;\\n\\n    std::valarray<std::valarray<double>> Q(rows);\\n    std::valarray<std::valarray<double>> R(columns);\\n\\n    /* number of eigen values = matrix size */\\n    std::valarray<double> eigen_vals(rows);\\n    for (int i = 0; i < rows; i++) {\\n        Q[i] = std::valarray<double>(columns);\\n        R[i] = std::valarray<double>(columns);\\n    }\\n\\n    /* continue till all eigen values are found */\\n    while (num_eigs > 0) {\\n        /* iterate with QR decomposition */\\n        while (std::abs(A[0][num_eigs][num_eigs - 1]) >\\n               std::numeric_limits<double>::epsilon()) {\\n            // initial approximation = last diagonal element\\n            last_eig = A[0][num_eigs][num_eigs];\\n            for (int i = 0; i < rows; i++) {\\n                A[0][i][i] -= last_eig; /* A - cI */\\n            }\\n\\n            qr_decompose(*A, &Q, &R);\\n\\n            if (print_intermediates) {\\n                std::cout << *A << \\\"\\\\n\\\";\\n                std::cout << Q << \\\"\\\\n\\\";\\n                std::cout << R << \\\"\\\\n\\\";\\n                printf(\\\"-------------------- %d ---------------------\\\\n\\\",\\n                       ++counter);\\n            }\\n\\n            // new approximation A' = R * Q\\n            mat_mul(R, Q, A);\\n\\n            for (int i = 0; i < rows; i++) {\\n                A[0][i][i] += last_eig; /* A + cI */\\n            }\\n        }\\n\\n        /* store the converged eigen value */\\n        eigen_vals[num_eigs] = last_eig;\\n        // A[0][num_eigs][num_eigs];\\n        if (print_intermediates) {\\n            std::cout << \\\"========================\\\\n\\\";\\n            std::cout << \\\"Eigen value: \\\" << last_eig << \\\",\\\\n\\\";\\n            std::cout << \\\"========================\\\\n\\\";\\n        }\\n\\n        num_eigs--;\\n        rows--;\\n        columns--;\\n    }\\n    eigen_vals[0] = A[0][0][0];\\n\\n    if (print_intermediates) {\\n        std::cout << Q << \\\"\\\\n\\\";\\n        std::cout << R << \\\"\\\\n\\\";\\n    }\\n\\n    return eigen_vals;\\n}\\n\\n}  // namespace qr_algorithm\\n\\n/**\\n * test function to compute eigen values of a 2x2 matrix\\n * \\\\f[\\\\begin{bmatrix}\\n * 5 & 7\\\\\\\\\\n * 7 & 11\\n * \\\\end{bmatrix}\\\\f]\\n * which are approximately, {15.56158, 0.384227}\\n */\\nvoid test1() {\\n    std::valarray<std::valarray<double>> X = {{5, 7}, {7, 11}};\\n    double y[] = {15.56158, 0.384227};  // corresponding y-values\\n\\n    std::cout << \\\"------- Test 1 -------\\\" << std::endl;\\n    std::valarray<double> eig_vals = qr_algorithm::eigen_values(&X);\\n\\n    for (int i = 0; i < 2; i++) {\\n        std::cout << i + 1 << \\\"/2 Checking for \\\" << y[i] << \\\" --> \\\";\\n        bool result = false;\\n        for (int j = 0; j < 2 && !result; j++) {\\n            if (std::abs(y[i] - eig_vals[j]) < 0.1) {\\n                result = true;\\n                std::cout << \\\"(\\\" << eig_vals[j] << \\\") \\\";\\n            }\\n        }\\n        assert(result);  // ensure that i^th expected eigen value was computed\\n        std::cout << \\\"found\\\\n\\\";\\n    }\\n    std::cout << \\\"Test 1 Passed\\\\n\\\\n\\\";\\n}\\n\\n/**\\n * test function to compute eigen values of a 2x2 matrix\\n * \\\\f[\\\\begin{bmatrix}\\n * -4& 4& 2& 0& -3\\\\\\\\\\n * 4& -4& 4& -3& -1\\\\\\\\\\n * 2& 4& 4& 3& -3\\\\\\\\\\n * 0& -3& 3& -1&-1\\\\\\\\\\n * -3& -1& -3& -3& 0\\n * \\\\end{bmatrix}\\\\f]\\n * which are approximately, {9.27648, -9.26948, 2.0181, -1.03516, -5.98994}\\n */\\nvoid test2() {\\n    std::valarray<std::valarray<double>> X = {{-4, 4, 2, 0, -3},\\n                                              {4, -4, 4, -3, -1},\\n                                              {2, 4, 4, 3, -3},\\n                                              {0, -3, 3, -1, -3},\\n                                              {-3, -1, -3, -3, 0}};\\n    double y[] = {9.27648, -9.26948, 2.0181, -1.03516,\\n                  -5.98994};  // corresponding y-values\\n\\n    std::cout << \\\"------- Test 2 -------\\\" << std::endl;\\n    std::valarray<double> eig_vals = qr_algorithm::eigen_values(&X);\\n\\n    std::cout << X << \\\"\\\\n\\\"\\n              << \\\"Eigen values: \\\" << eig_vals << \\\"\\\\n\\\";\\n\\n    for (int i = 0; i < 5; i++) {\\n        std::cout << i + 1 << \\\"/5 Checking for \\\" << y[i] << \\\" --> \\\";\\n        bool result = false;\\n        for (int j = 0; j < 5 && !result; j++) {\\n            if (std::abs(y[i] - eig_vals[j]) < 0.1) {\\n                result = true;\\n                std::cout << \\\"(\\\" << eig_vals[j] << \\\") \\\";\\n            }\\n        }\\n        assert(result);  // ensure that i^th expected eigen value was computed\\n        std::cout << \\\"found\\\\n\\\";\\n    }\\n    std::cout << \\\"Test 2 Passed\\\\n\\\\n\\\";\\n}\\n\\n/**\\n * main function\\n */\\nint main(int argc, char **argv) {\\n    int mat_size = 5;\\n    if (argc == 2) {\\n        mat_size = atoi(argv[1]);\\n    } else {  // if invalid input argument is given run tests\\n        test1();\\n        test2();\\n        std::cout << \\\"Usage: ./qr_eigen_values [mat_size]\\\\n\\\";\\n        return 0;\\n    }\\n\\n    if (mat_size < 2) {\\n        fprintf(stderr, \\\"Matrix size should be > 2\\\\n\\\");\\n        return -1;\\n    }\\n\\n    // initialize random number generator\\n    std::srand(std::time(nullptr));\\n\\n    int i, rows = mat_size, columns = mat_size;\\n\\n    std::valarray<std::valarray<double>> A(rows);\\n\\n    for (int i = 0; i < rows; i++) {\\n        A[i] = std::valarray<double>(columns);\\n    }\\n\\n    /* create a random matrix */\\n    create_matrix(&A);\\n\\n    std::cout << A << \\\"\\\\n\\\";\\n\\n    clock_t t1 = clock();\\n    std::valarray<double> eigen_vals = qr_algorithm::eigen_values(&A);\\n    double dtime = static_cast<double>(clock() - t1) / CLOCKS_PER_SEC;\\n\\n    std::cout << \\\"Eigen vals: \\\";\\n    for (i = 0; i < mat_size; i++) std::cout << eigen_vals[i] << \\\"\\\\t\\\";\\n    std::cout << \\\"\\\\nTime taken to compute: \\\" << dtime << \\\" sec\\\\n\\\";\\n\\n    return 0;\\n}\\n\"",
    "rungekutta": "\"/**\\n * @{\\n * \\\\file\\n * \\\\brief [Runge Kutta fourth\\n * order](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods) method\\n * implementation\\n *\\n * \\\\author [Rudra Prasad Das](http://github.com/rudra697)\\n *\\n * \\\\details\\n * It solves the unknown value of y\\n * for a given value of x\\n * only first order differential equations\\n * can be solved\\n * \\\\example\\n * it solves \\\\frac{\\\\mathrm{d} y}{\\\\mathrm{d} x}= \\\\frac{\\\\left ( x-y \\\\right )}{2}\\n * given x for given initial\\n * conditions\\n * There can be many such equations\\n */\\n#include <cassert>   /// asserting the test functions\\n#include <iostream>  /// for io operations\\n#include <vector>    /// for using the vector container\\n\\n/**\\n * @brief The change() function is used\\n * to return the updated iterative value corresponding\\n * to the given function\\n * @param x is the value corresponding to the x coordinate\\n * @param y is the value corresponding to the y coordinate\\n * @returns the computed function value at that call\\n */\\nstatic double change(double x, double y) { return ((x - y) / 2.0); }\\n\\n/**\\n * @namespace numerical_methods\\n * @brief Numerical Methods\\n */\\nnamespace numerical_methods {\\n/**\\n * @namespace runge_kutta\\n * @brief Functions for [Runge Kutta fourth\\n * order](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods) method\\n */\\nnamespace runge_kutta {\\n/**\\n * @brief the Runge Kutta method finds the value of integration of a function in\\n * the given limits. the lower limit of integration as the initial value and the\\n * upper limit is the given x\\n * @param init_x is the value of initial x and is updated after each call\\n * @param init_y is the value of initial x and is updated after each call\\n * @param x is current iteration at which the function needs to be evaluated\\n * @param h is the step value\\n * @returns the value of y at thr required value of x from the initial\\n * conditions\\n */\\ndouble rungeKutta(double init_x, const double &init_y, const double &x,\\n                  const double &h) {\\n    // Count number of iterations\\n    // using step size or\\n    // step height h\\n\\n    // n calucates the number of iterations\\n    // k1, k2, k3, k4 are the Runge Kutta variables\\n    // used for calculation of y at each iteration\\n\\n    auto n = static_cast<uint64_t>((x - init_x) / h);\\n    // used a vector container for the variables\\n    std::vector<double> k(4, 0.0);\\n\\n    // Iterate for number of iterations\\n\\n    double y = init_y;\\n    for (int i = 1; i <= n; ++i) {\\n        // Apply Runge Kutta Formulas\\n        // to find next value of y\\n        k[0] = h * change(init_x, y);\\n        k[1] = h * change(init_x + 0.5 * h, y + 0.5 * k[0]);\\n        k[2] = h * change(init_x + 0.5 * h, y + 0.5 * k[1]);\\n        k[3] = h * change(init_x + h, y + k[2]);\\n\\n        // Update next value of y\\n\\n        y += (1.0 / 6.0) * (k[0] + 2 * k[1] + 2 * k[2] + k[3]);\\n\\n        // Update next value of x\\n\\n        init_x += h;\\n    }\\n\\n    return y;\\n}\\n}  // namespace runge_kutta\\n}  // namespace numerical_methods\\n\\n/**\\n * @brief Tests to check algorithm implementation.\\n * @returns void\\n */\\nstatic void test() {\\n    std::cout << \\\"The Runge Kutta function will be tested on the basis of \\\"\\n                 \\\"precomputed values\\\\n\\\";\\n\\n    std::cout << \\\"Test 1....\\\"\\n              << \\\"\\\\n\\\";\\n    double valfirst = numerical_methods::runge_kutta::rungeKutta(\\n        2, 3, 4, 0.2);  // Tests the function with pre calculated values\\n    assert(valfirst == 3.10363932323749570);\\n    std::cout << \\\"Passed Test 1\\\\n\\\";\\n\\n    std::cout << \\\"Test 2....\\\"\\n              << \\\"\\\\n\\\";\\n    double valsec = numerical_methods::runge_kutta::rungeKutta(\\n        1, 2, 5, 0.1);  // The value of step changed\\n    assert(valsec == 3.40600589380261409);\\n    std::cout << \\\"Passed Test 2\\\\n\\\";\\n\\n    std::cout << \\\"Test 3....\\\"\\n              << \\\"\\\\n\\\";\\n    double valthird = numerical_methods::runge_kutta::rungeKutta(\\n        -1, 3, 4, 0.1);  // Tested with negative value\\n    assert(valthird == 2.49251005860244268);\\n    std::cout << \\\"Passed Test 3\\\\n\\\";\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // Execute the tests\\n    return 0;\\n}\\n\"",
    "successive approximation": "\"/**\\n * \\\\file\\n * \\\\brief Method of successive approximations using [fixed-point\\n * iteration](https://en.wikipedia.org/wiki/Fixed-point_iteration) method\\n */\\n#include <cmath>\\n#include <iostream>\\n\\n/** equation 1\\n * \\\\f[f(y) = 3y - \\\\cos y -2\\\\f]\\n */\\nstatic float eq(float y) { return (3 * y) - cos(y) - 2; }\\n\\n/** equation 2\\n * \\\\f[f(y) = \\\\frac{\\\\cos y+2}{2}\\\\f]\\n */\\nstatic float eqd(float y) { return 0.5 * (cos(y) + 2); }\\n\\n/** Main function */\\nint main() {\\n    float y, x1, x2, x3, sum, s, a, f1, f2, gd;\\n    int i, n;\\n\\n    for (i = 0; i < 10; i++) {\\n        sum = eq(y);\\n        std::cout << \\\"value of equation at \\\" << i << \\\" \\\" << sum << \\\"\\\\n\\\";\\n        y++;\\n    }\\n    std::cout << \\\"enter the x1->\\\";\\n    std::cin >> x1;\\n    std::cout << \\\"enter the no iteration to perform->\\\\n\\\";\\n    std::cin >> n;\\n\\n    for (i = 0; i <= n; i++) {\\n        x2 = eqd(x1);\\n        std::cout << \\\"\\\\nenter the x2->\\\" << x2;\\n        x1 = x2;\\n    }\\n    return 0;\\n}\\n\"",
    "array left rotation": "\"/**\\n * @file\\n * @brief Implementation for the [Array Left\\n * Rotation](https://www.javatpoint.com/program-to-left-rotate-the-elements-of-an-array)\\n * algorithm.\\n * @details Shifting an array to the left involves moving each element of the\\n * array so that it occupies a position of a certain shift value before its\\n * current one. This implementation uses a result vector and does not mutate the\\n * input.\\n * @author [Alvin](https://github.com/polarvoid)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace operations_on_datastructures\\n * @brief Operations on Data Structures\\n */\\nnamespace operations_on_datastructures {\\n\\n/**\\n * @brief Prints the values of a vector sequentially, ending with a newline\\n * character.\\n * @param array Reference to the array to be printed\\n * @returns void\\n */\\nvoid print(const std::vector<int32_t> &array) {\\n    for (int32_t i : array) {\\n        std::cout << i << \\\" \\\";  /// Print each value in the array\\n    }\\n    std::cout << \\\"\\\\n\\\";  /// Print newline\\n}\\n\\n/**\\n * @brief Shifts the given vector to the left by the shift amount and returns a\\n * new vector with the result. The original vector is not mutated.\\n * @details Shifts the values of the vector, by creating a new vector and adding\\n * values from the shift index to the end, then appending the rest of the\\n * elements from the start of the vector.\\n * @param array A reference to the input std::vector\\n * @param shift The amount to be shifted to the left\\n * @returns A std::vector with the shifted values\\n */\\nstd::vector<int32_t> shift_left(const std::vector<int32_t> &array,\\n                                size_t shift) {\\n    if (array.size() <= shift) {\\n        return {};  ///< We got an invalid shift, return empty array\\n    }\\n    std::vector<int32_t> res(array.size());  ///< Result array\\n    for (size_t i = shift; i < array.size(); i++) {\\n        res[i - shift] = array[i];  ///< Add values after the shift index\\n    }\\n    for (size_t i = 0; i < shift; i++) {\\n        res[array.size() - shift + i] =\\n            array[i];  ///< Add the values from the start\\n    }\\n    return res;\\n}\\n\\n}  // namespace operations_on_datastructures\\n\\n/**\\n * @namespace tests\\n * @brief Testcases to check Union of Two Arrays.\\n */\\nnamespace tests {\\nusing operations_on_datastructures::print;\\nusing operations_on_datastructures::shift_left;\\n/**\\n * @brief A Test to check an simple case\\n * @returns void\\n */\\nvoid test1() {\\n    std::cout << \\\"TEST CASE 1\\\\n\\\";\\n    std::cout << \\\"Initialized arr = {1, 2, 3, 4, 5}\\\\n\\\";\\n    std::cout << \\\"Expected result: {3, 4, 5, 1, 2}\\\\n\\\";\\n    std::vector<int32_t> arr = {1, 2, 3, 4, 5};\\n    std::vector<int32_t> res = shift_left(arr, 2);\\n    std::vector<int32_t> expected = {3, 4, 5, 1, 2};\\n    assert(res == expected);\\n    print(res);  ///< Should print 3 4 5 1 2\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check an empty vector\\n * @returns void\\n */\\nvoid test2() {\\n    std::cout << \\\"TEST CASE 2\\\\n\\\";\\n    std::cout << \\\"Initialized arr = {}\\\\n\\\";\\n    std::cout << \\\"Expected result: {}\\\\n\\\";\\n    std::vector<int32_t> arr = {};\\n    std::vector<int32_t> res = shift_left(arr, 2);\\n    std::vector<int32_t> expected = {};\\n    assert(res == expected);\\n    print(res);  ///< Should print empty newline\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check an invalid shift value\\n * @returns void\\n */\\nvoid test3() {\\n    std::cout << \\\"TEST CASE 3\\\\n\\\";\\n    std::cout << \\\"Initialized arr = {1, 2, 3, 4, 5}\\\\n\\\";\\n    std::cout << \\\"Expected result: {}\\\\n\\\";\\n    std::vector<int32_t> arr = {1, 2, 3, 4, 5};\\n    std::vector<int32_t> res = shift_left(arr, 7);  ///< 7 > 5\\n    std::vector<int32_t> expected = {};\\n    assert(res == expected);\\n    print(res);  ///< Should print empty newline\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check a very large input\\n * @returns void\\n */\\nvoid test4() {\\n    std::cout << \\\"TEST CASE 4\\\\n\\\";\\n    std::cout << \\\"Initialized arr = {2, 4, ..., 420}\\\\n\\\";\\n    std::cout << \\\"Expected result: {4, 6, ..., 420, 2}\\\\n\\\";\\n    std::vector<int32_t> arr;\\n    for (int i = 1; i <= 210; i++) {\\n        arr.push_back(i * 2);\\n    }\\n    print(arr);\\n    std::vector<int32_t> res = shift_left(arr, 1);\\n    std::vector<int32_t> expected;\\n    for (int i = 1; i < 210; i++) {\\n        expected.push_back(arr[i]);\\n    }\\n    expected.push_back(2);\\n    assert(res == expected);\\n    print(res);  ///< Should print {4, 6, ..., 420, 2}\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check a shift of zero\\n * @returns void\\n */\\nvoid test5() {\\n    std::cout << \\\"TEST CASE 5\\\\n\\\";\\n    std::cout << \\\"Initialized arr = {1, 2, 3, 4, 5}\\\\n\\\";\\n    std::cout << \\\"Expected result: {1, 2, 3, 4, 5}\\\\n\\\";\\n    std::vector<int32_t> arr = {1, 2, 3, 4, 5};\\n    std::vector<int32_t> res = shift_left(arr, 0);\\n    assert(res == arr);\\n    print(res);  ///< Should print 1 2 3 4 5\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n}  // namespace tests\\n\\n/**\\n * @brief Function to test the correctness of shift_left() function\\n * @returns void\\n */\\nstatic void test() {\\n    tests::test1();\\n    tests::test2();\\n    tests::test3();\\n    tests::test4();\\n    tests::test5();\\n}\\n\\n/**\\n * @brief main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "array right rotation": "\"/**\\n * @file\\n * @brief Implementation for the [Array right\\n * Rotation](https://www.javatpoint.com/program-to-right-rotate-the-elements-of-an-array)\\n * algorithm.\\n * @details Shifting an array to the right involves moving each element of the\\n * array so that it occupies a position of a certain shift value after its\\n * current one. This implementation uses a result vector and does not mutate the\\n * input.\\n * @see array_left_rotation.cpp\\n * @author [Alvin](https://github.com/polarvoid)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace operations_on_datastructures\\n * @brief Operations on Data Structures\\n */\\nnamespace operations_on_datastructures {\\n\\n/**\\n * @brief Prints the values of a vector sequentially, ending with a newline\\n * character.\\n * @param array Reference to the array to be printed\\n * @returns void\\n */\\nvoid print(const std::vector<int32_t> &array) {\\n    for (int32_t i : array) {\\n        std::cout << i << \\\" \\\";  /// Print each value in the array\\n    }\\n    std::cout << \\\"\\\\n\\\";  /// Print newline\\n}\\n\\n/**\\n * @brief Shifts the given vector to the right by the shift amount and returns a\\n * new vector with the result. The original vector is not mutated.\\n * @details Shifts the values of the vector, by creating a new vector and adding\\n * values from the shift index to the end, then appending the rest of the\\n * elements to the start of the vector.\\n * @param array A reference to the input std::vector\\n * @param shift The amount to be shifted to the right\\n * @returns A std::vector with the shifted values\\n */\\nstd::vector<int32_t> shift_right(const std::vector<int32_t> &array,\\n                                 size_t shift) {\\n    if (array.size() <= shift) {\\n        return {};  ///< We got an invalid shift, return empty array\\n    }\\n    std::vector<int32_t> res(array.size());  ///< Result array\\n    for (size_t i = shift; i < array.size(); i++) {\\n        res[i] = array[i - shift];  ///< Add values after the shift index\\n    }\\n    for (size_t i = 0; i < shift; i++) {\\n        res[i] =\\n            array[array.size() - shift + i];  ///< Add the values from the start\\n    }\\n    return res;\\n}\\n\\n}  // namespace operations_on_datastructures\\n\\n/**\\n * @namespace tests\\n * @brief Testcases to check Union of Two Arrays.\\n */\\nnamespace tests {\\nusing operations_on_datastructures::print;\\nusing operations_on_datastructures::shift_right;\\n/**\\n * @brief A Test to check an simple case\\n * @returns void\\n */\\nvoid test1() {\\n    std::cout << \\\"TEST CASE 1\\\\n\\\";\\n    std::cout << \\\"Initialized arr = {1, 2, 3, 4, 5}\\\\n\\\";\\n    std::cout << \\\"Expected result: {4, 5, 1, 2, 3}\\\\n\\\";\\n    std::vector<int32_t> arr = {1, 2, 3, 4, 5};\\n    std::vector<int32_t> res = shift_right(arr, 2);\\n    std::vector<int32_t> expected = {4, 5, 1, 2, 3};\\n    assert(res == expected);\\n    print(res);  ///< Should print 4 5 1 2 3\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check an empty vector\\n * @returns void\\n */\\nvoid test2() {\\n    std::cout << \\\"TEST CASE 2\\\\n\\\";\\n    std::cout << \\\"Initialized arr = {}\\\\n\\\";\\n    std::cout << \\\"Expected result: {}\\\\n\\\";\\n    std::vector<int32_t> arr = {};\\n    std::vector<int32_t> res = shift_right(arr, 2);\\n    std::vector<int32_t> expected = {};\\n    assert(res == expected);\\n    print(res);  ///< Should print empty newline\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check an invalid shift value\\n * @returns void\\n */\\nvoid test3() {\\n    std::cout << \\\"TEST CASE 3\\\\n\\\";\\n    std::cout << \\\"Initialized arr = {1, 2, 3, 4, 5}\\\\n\\\";\\n    std::cout << \\\"Expected result: {}\\\\n\\\";\\n    std::vector<int32_t> arr = {1, 2, 3, 4, 5};\\n    std::vector<int32_t> res = shift_right(arr, 7);  ///< 7 > 5\\n    std::vector<int32_t> expected = {};\\n    assert(res == expected);\\n    print(res);  ///< Should print empty newline\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check a very large input\\n * @returns void\\n */\\nvoid test4() {\\n    std::cout << \\\"TEST CASE 4\\\\n\\\";\\n    std::cout << \\\"Initialized arr = {2, 4, ..., 420}\\\\n\\\";\\n    std::cout << \\\"Expected result: {420, 2, 4, ..., 418}\\\\n\\\";\\n    std::vector<int32_t> arr;\\n    for (int i = 1; i <= 210; i++) {\\n        arr.push_back(i * 2);\\n    }\\n    print(arr);\\n    std::vector<int32_t> res = shift_right(arr, 1);\\n    std::vector<int32_t> expected;\\n    expected.push_back(420);\\n    for (int i = 0; i < 209; i++) {\\n        expected.push_back(arr[i]);\\n    }\\n    assert(res == expected);\\n    print(res);  ///< Should print {420, 2, 4, ..., 418}\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check a shift of zero\\n * @returns void\\n */\\nvoid test5() {\\n    std::cout << \\\"TEST CASE 5\\\\n\\\";\\n    std::cout << \\\"Initialized arr = {1, 2, 3, 4, 5}\\\\n\\\";\\n    std::cout << \\\"Expected result: {1, 2, 3, 4, 5}\\\\n\\\";\\n    std::vector<int32_t> arr = {1, 2, 3, 4, 5};\\n    std::vector<int32_t> res = shift_right(arr, 0);\\n    assert(res == arr);\\n    print(res);  ///< Should print 1 2 3 4 5\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n}  // namespace tests\\n\\n/**\\n * @brief Function to test the correctness of shift_right() function\\n * @returns void\\n */\\nstatic void test() {\\n    tests::test1();\\n    tests::test2();\\n    tests::test3();\\n    tests::test4();\\n    tests::test5();\\n}\\n\\n/**\\n * @brief main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "circular linked list": "\"/**\\n * @file\\n * @brief Implementation for a [Circular Linked\\n * List](https://www.geeksforgeeks.org/circular-linked-list/).\\n * @details A Circular Linked List is a variation on the regular linked list, in\\n * which the last node has a pointer to the first node, which creates a full\\n * circle. Consequently, this allows any node to be used as the starting point\\n * for the list.\\n * @author [Alvin](https://github.com/polarvoid)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace operations_on_datastructures\\n * @brief Operations on Data Structures\\n */\\nnamespace operations_on_datastructures {\\n\\n/**\\n * @namespace circular_linked_list\\n * @brief Functions for the [Circular Linked\\n * List](https://www.geeksforgeeks.org/circular-linked-list/) implementation\\n */\\nnamespace circular_linked_list {\\n\\n/**\\n * @brief A Node struct that represents a single Node in a Binary Tree\\n */\\nstruct Node {\\n    int64_t data;  ///< The value of the Node\\n    Node* next;    ///< The Node's successor\\n    /**\\n     * @brief Creates a new Node with some initial data\\n     * @param _data Value of Node\\n     */\\n    explicit Node(int64_t _data) {\\n        data = _data;    ///< Set value of Node data\\n        next = nullptr;  ///< Initialize successor\\n    }\\n    /**\\n     * @brief Creates a new Node with initial data and a successor\\n     * @param _data Value of Node\\n     * @param _next Pointer to the next Node\\n     */\\n    explicit Node(int64_t _data, Node* _next) {\\n        data = _data;  ///< Set value of Node data\\n        next = _next;  ///< Initialize successor\\n    }\\n};\\n\\n/**\\n * @brief A class that implements a Circular Linked List.\\n */\\nclass CircularLinkedList {\\n private:\\n    Node* root;   ///< Pointer to the root Node\\n    Node* end{};  ///< Pointer to the last Node\\n\\n public:\\n    /**\\n     * @brief Creates an empty CircularLinkedList.\\n     */\\n    CircularLinkedList() {\\n        root = nullptr;\\n        end = nullptr;\\n    }\\n    /**\\n     * @brief Copy constructor for CircularLinkedList.\\n     */\\n    CircularLinkedList(const CircularLinkedList& copy) {\\n        erase();\\n        root = nullptr;\\n        Node* node = copy.root;\\n        while (node != nullptr) {\\n            insert(node->data);\\n            node = node->next;\\n        }\\n    }\\n    /**\\n     * @brief Move constructor for CircularLinkedList\\n     * @param source rvalue reference to a Circular Linked List\\n     */\\n    CircularLinkedList(CircularLinkedList&& source) noexcept {\\n        root = source.root;\\n        end = source.end;\\n        source.root = nullptr;\\n        source.end = nullptr;\\n    }\\n    /**\\n     * @brief Copy assignment operator\\n     * @param other Reference to a Circular Linked List\\n     * @returns Reference to CircularLinkedList\\n     */\\n    CircularLinkedList& operator=(const CircularLinkedList& other) {\\n        erase();\\n        root = nullptr;\\n        Node* node = other.root;\\n        while (node != nullptr) {\\n            insert(node->data);\\n            node = node->next;\\n        }\\n        return *this;\\n    }\\n    /**\\n     * @brief Move assignment operator\\n     * @param other rvalue reference to a Circular Linked List\\n     * @returns Reference to CircularLinkedList\\n     */\\n    CircularLinkedList& operator=(CircularLinkedList&& other) noexcept {\\n        root = other.root;\\n        end = other.end;\\n        other.root = nullptr;\\n        other.end = nullptr;\\n        return *this;\\n    }\\n    /**\\n     * @brief Cleans up memory when destroyed\\n     */\\n    ~CircularLinkedList() { erase(); }\\n    /**\\n     * Iteratively frees each node in the Circular Linked List from the heap\\n     */\\n    void erase() {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        Node* node = root;\\n        do {\\n            Node* temp = node;\\n            node = node->next;\\n            delete (temp);\\n        } while (node != root);\\n        root = nullptr;\\n        end = nullptr;\\n    }\\n    /**\\n     * @brief Inserts all the values from a vector into the Circular Linked List\\n     * @details Goes through each element in the vector sequentially, inserting\\n     * it into the list\\n     * @param values The vector of integer values that is to be inserted\\n     * @returns void\\n     */\\n    void insert(const std::vector<int64_t>& values) {\\n        for (int64_t value : values) {\\n            insert(value);\\n        }\\n    }\\n    /**\\n     * @brief Inserts a single value into the Circular Linked List\\n     * @details Creates a Node with the given value, pointing to the root Node\\n     * and inserts it into the list\\n     * @param data The integer valus to be inserted\\n     * @returns void\\n     */\\n    void insert(int64_t data) {\\n        Node* node = new Node(data, root);\\n        insert(node);\\n    }\\n    /**\\n     * @brief Inserts a given Node into the Circular Linked List\\n     * @details Checks wheter the list is empty, and inserts the Node, modifying\\n     * the end pointer\\n     * @param node The Node that is to be inserted\\n     * @returns void\\n     */\\n    void insert(Node* node) {\\n        if (root == nullptr) {\\n            root = node;        ///< Set node as the root\\n            node->next = root;  ///< Point node to itself\\n            end = root;         ///< Set the end to the root\\n        } else {\\n            end->next = node;   ///< Append node to the end\\n            node->next = root;  ///< Set the next value to the root\\n            end = node;         ///< Make end point to node\\n        }\\n    }\\n    /**\\n     * @brief Prints the values of the Circular Linked List, beginning from the\\n     * root Node\\n     * @details Goes through each Node from the root and prints them out in\\n     * order\\n     * @returns void\\n     */\\n    void print() { print(root); }\\n    /**\\n     * @brief Prints the values of the Circular Linked List, beginning from a\\n     * given Node to be used as the root\\n     * @details Goes through each Node from the given Node and prints them out\\n     * in order. If the list is empty, it prints the message 'Empty List!'\\n     * @param root The Node to start at\\n     * @returns void\\n     */\\n    void print(Node* root) {\\n        Node* temp = root;\\n        if (root == nullptr) {\\n            std::cout << \\\"Empty List!\\\\n\\\";\\n            return;\\n        }\\n        do {\\n            std::cout << temp->data << \\\" \\\";\\n            temp = temp->next;\\n        } while (temp != root);\\n        std::cout << \\\"\\\\n\\\";\\n    }\\n    /**\\n     * @brief Returns a std::vector of the values of the Circular Linked List\\n     * @details Starting from the root Node, appends each value of the list to a\\n     * std::vector and returns it\\n     * @returns A std::vector of the list's values\\n     */\\n    std::vector<int64_t> values() { return values(root); }\\n    /**\\n     * @brief Returns a std::vector of the values of the Circular Linked List,\\n     * beginning from a given Node\\n     * @details Starting from a given Node, appends each value of the list to a\\n     * std::vector and returns it\\n     * @param root The Node to start at\\n     * @returns A std::vector of the list's values\\n     */\\n    std::vector<int64_t> values(Node* root) {\\n        std::vector<int64_t> res;\\n        if (root == nullptr) {\\n            return res;  ///< Return empty vector\\n        }\\n        Node* temp = root;\\n        do {\\n            res.push_back(temp->data);\\n            temp = temp->next;\\n        } while (temp != root);\\n        return res;\\n    }\\n};\\n\\n}  // namespace circular_linked_list\\n\\n}  // namespace operations_on_datastructures\\n\\n/**\\n * @namespace tests\\n * @brief Testcases to check Circular Linked List.\\n */\\nnamespace tests {\\nusing operations_on_datastructures::circular_linked_list::CircularLinkedList;\\nusing operations_on_datastructures::circular_linked_list::Node;\\n/**\\n * @brief A Test to check a single value\\n * @returns void\\n */\\nvoid test1() {\\n    std::cout << \\\"TEST CASE 1\\\\n\\\";\\n    std::cout << \\\"Intialized a = {2}\\\\n\\\";\\n    std::cout << \\\"Expected result: {2}\\\\n\\\";\\n    CircularLinkedList a;\\n    std::vector<int64_t> res = {2};\\n    a.insert(2);\\n    assert(a.values() == res);\\n    a.print();\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check a few values\\n * @returns void\\n */\\nvoid test2() {\\n    std::cout << \\\"TEST CASE 2\\\\n\\\";\\n    std::cout << \\\"Intialized a = {2, 5, 6}\\\\n\\\";\\n    std::cout << \\\"Expected result: {2, 5, 6}\\\\n\\\";\\n    CircularLinkedList a;\\n    std::vector<int64_t> res = {2, 5, 6};\\n    a.insert(2);\\n    a.insert(5);\\n    a.insert(6);\\n    assert(a.values() == res);\\n    a.print();\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check an input array\\n * @returns void\\n */\\nvoid test3() {\\n    std::cout << \\\"TEST CASE 3\\\\n\\\";\\n    std::cout << \\\"Intialized a = {2, 7, 8, 3, 2, 6}\\\\n\\\";\\n    std::cout << \\\"Expected result: {2, 7, 8, 3, 2, 6}\\\\n\\\";\\n    CircularLinkedList a;\\n    std::vector<int64_t> res = {2, 7, 8, 3, 2, 6};\\n    a.insert({2, 7, 8, 3, 2, 6});\\n    a.print();\\n    assert(a.values() == res);\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check using a specific Node as the starting point\\n * @returns void\\n */\\nvoid test4() {\\n    std::cout << \\\"TEST CASE 4\\\\n\\\";\\n    std::cout << \\\"Intialized a = {2, 5}\\\\n\\\";\\n    std::cout << \\\"Expected result: {5, 2}\\\\n\\\";\\n    CircularLinkedList a;\\n    std::vector<int64_t> res = {5, 2};\\n    a.insert(2);\\n    Node* start = new Node(5);  ///< Node we will start printing from\\n    a.insert(start);\\n    assert(a.values(start) == res);\\n    a.print(start);\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n\\n/**\\n * @brief A Test to check an empty list\\n * @returns void\\n */\\nvoid test5() {\\n    std::cout << \\\"TEST CASE 5\\\\n\\\";\\n    std::cout << \\\"Intialized a = {}\\\\n\\\";\\n    std::cout << \\\"Expected result: Empty List!\\\\n\\\";\\n    CircularLinkedList a;\\n    std::vector<int64_t> res = {};\\n    assert(a.values() == res);\\n    a.print();\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n}  // namespace tests\\n\\n/**\\n * @brief Function to test the correctness of the Circular Linked List\\n * @returns void\\n */\\nstatic void test() {\\n    tests::test1();\\n    tests::test2();\\n    tests::test3();\\n    tests::test4();\\n    tests::test5();\\n}\\n\\n/**\\n * @brief main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "circular queue using array": "\"#include <iostream>\\nusing namespace std;\\n\\nint queue[10];\\nint front = 0;\\nint rear = 0;\\nint count = 0;\\n\\nvoid Enque(int x) {\\n    if (count == 10) {\\n        cout << \\\"\\\\nOverflow\\\";\\n    } else {\\n        queue[rear] = x;\\n        rear = (rear + 1) % 10;\\n        count++;\\n    }\\n}\\n\\nvoid Deque() {\\n    if (front == rear) {\\n        cout << \\\"\\\\nUnderflow\\\";\\n    }\\n\\n    else {\\n        cout << \\\"\\\\n\\\" << queue[front] << \\\" deleted\\\";\\n        front = (front + 1) % 10;\\n        count--;\\n    }\\n}\\n\\nvoid show() {\\n    for (int i = 0; i < count; i++) {\\n        cout << queue[(i + front) % 10] << \\\"\\\\t\\\";\\n    }\\n}\\n\\nint main() {\\n    int ch, x;\\n    do {\\n        cout << \\\"\\\\n1. Enque\\\";\\n        cout << \\\"\\\\n2. Deque\\\";\\n        cout << \\\"\\\\n3. Print\\\";\\n        cout << \\\"\\\\nEnter Your Choice : \\\";\\n        cin >> ch;\\n        if (ch == 1) {\\n            cout << \\\"\\\\nInsert : \\\";\\n            cin >> x;\\n            Enque(x);\\n        } else if (ch == 2) {\\n            Deque();\\n        } else if (ch == 3) {\\n            show();\\n        }\\n    } while (ch != 0);\\n\\n    return 0;\\n}\\n\"",
    "get size of linked list": "\"#include <iostream>\\n\\nclass Node {\\n public:\\n    int val;\\n    Node *next;\\n\\n    Node(int v, Node *n) : val(v), next(n) {}  // Default constructor for Node\\n};\\n\\nint getSize(Node *root) {\\n    if (root == NULL) {\\n        return 0;\\n    }\\n    // Each node will return 1 so the total adds up to be the size\\n    return 1 + getSize(root->next);\\n}\\n\\nint main() {\\n    Node *myList = new Node(0, NULL);  // Initializes the LinkedList\\n    Node *temp = myList;\\n    // Creates a linked lists of total size 10, numbered 1 - 10\\n    for (int i = 1; i < 10; i++) {\\n        temp->next = new Node(i, NULL);\\n        temp = temp->next;\\n    }\\n    // Creating other lists for checking purposes\\n    Node *secondList = new Node(0, NULL);  // List of size 1\\n    Node *thirdList = NULL;                // List of size 0\\n\\n    std::cout << getSize(myList) << std::endl\\n              << getSize(secondList) << std::endl\\n              << getSize(thirdList) << std::endl;\\n\\n    return 0;\\n}\\n\"",
    "inorder successor of bst": "\"/**\\n * @file\\n * @brief An implementation for finding the [Inorder successor of a binary\\n * search tree](https://www.youtube.com/watch?v=5cPbNCrdotA) Inorder\\n * successor of a node is the next node in Inorder traversal of the Binary Tree.\\n * Inorder Successor is NULL for the last node in Inorder traversal.\\n * @details\\n * ### Case 1: The given node has the right node/subtree\\n *\\n *      * In this case, the left-most deepest node in the right subtree will\\n * come just after the given node as we go to left deep in inorder.\\n *      - Go deep to left most node in right subtree.\\n *        OR, we can also say in case if BST, find the minimum of the subtree\\n * for a given node.\\n *\\n * ### Case 2: The given node does not have a right node/subtree\\n *\\n * #### Method 1: Use parent pointer (store the address of parent nodes)\\n *      * If a node does not have the right subtree, and we already visited the\\n * node itself, then the next node will be its parent node according to inorder\\n * traversal, and if we are going to parent from left, then the parent would be\\n * unvisited.\\n *      * In other words, go to the nearest ancestor for which given node would\\n * be in left subtree.\\n *\\n * #### Method 2: Search from the root node\\n *      * In case if there is no link from a child node to the parent node, we\\n * need to walk down the tree starting from the root node to the given node, by\\n * doing so, we are visiting every ancestor of the given node.\\n *      * In order successor would be the deepest node in this path for which\\n * given node is in left subtree.\\n *\\n * @author [Nitin Sharma](https://github.com/foo290)\\n * */\\n\\n#include <cassert>   ///  for assert\\n#include <iostream>  ///  for IO Operations\\n#include <vector>    ///  for std::vector\\n\\n/**\\n * @namespace operations_on_datastructures\\n * @brief Operations on data structures\\n */\\nnamespace operations_on_datastructures {\\n\\n/**\\n * @namespace inorder_successor_of_bst\\n * @brief Functions for the [Inorder successor of a binary search\\n * tree](https://www.youtube.com/watch?v=5cPbNCrdotA) implementation\\n */\\nnamespace inorder_traversal_of_bst {\\n\\n/**\\n * @brief A Node structure representing a single node in BST\\n */\\nclass Node {\\n public:\\n    int64_t data;  ///< The key/value of the node\\n    Node *left;    ///< Pointer to Left child\\n    Node *right;   ///< Pointer to right child\\n};\\n\\n/**\\n * @brief Allocates a new node in heap for given data and returns it's pointer.\\n * @param data Data for the node.\\n * @returns A pointer to the newly allocated Node.\\n * */\\nNode *makeNode(int64_t data) {\\n    Node *node = new Node();\\n    node->data = data;      ///< setting data for node\\n    node->left = nullptr;   ///< setting left child as null\\n    node->right = nullptr;  ///< setting right child as null\\n    return node;\\n}\\n\\n/**\\n * @brief Inserts the given data in BST while maintaining the properties of BST.\\n * @param root Pointer to the root node of the BST\\n * @param data Data to be inserted.\\n * @returns Node* Pointer to the root node.\\n * */\\nNode *Insert(Node *root, int64_t data) {\\n    if (root == nullptr) {\\n        root = makeNode(data);\\n    } else if (data <= root->data) {\\n        root->left = Insert(root->left, data);\\n    } else {\\n        root->right = Insert(root->right, data);\\n    }\\n    return root;\\n}\\n\\n/**\\n * @brief Searches the given data in BST and returns the pointer to the node\\n * containing that data.\\n * @param root Pointer to the root node of the BST\\n * @param data Data to be Searched.\\n * @returns Node* pointer to the found node\\n * */\\nNode *getNode(Node *root, int64_t data) {\\n    if (root == nullptr) {\\n        return nullptr;\\n    } else if (root->data == data) {\\n        return root;  /// Node found!\\n    } else if (data > root->data) {\\n        /// Traverse right subtree recursively as the given data is greater than\\n        /// the data in root node, data must be present in right subtree.\\n        return getNode(root->right, data);\\n    } else {\\n        /// Traverse left subtree recursively as the given data is less than the\\n        /// data in root node, data must be present in left subtree.\\n        return getNode(root->left, data);\\n    }\\n}\\n\\n/**\\n * @brief Finds and return the minimum node in BST.\\n * @param root A pointer to root node.\\n * @returns Node* Pointer to the found node\\n * */\\nNode *findMinNode(Node *root) {\\n    if (root == nullptr) {\\n        return root;\\n    }\\n    while (root->left != nullptr) {\\n        root = root->left;\\n    }\\n    return root;\\n}\\n\\n/**\\n * @brief Prints the BST in inorder traversal using recursion.\\n * @param root A pointer to the root node of the BST.\\n * @returns void\\n * */\\nvoid printInorder(Node *root) {\\n    if (root == nullptr) {\\n        return;\\n    }\\n\\n    printInorder(root->left);  /// recursive call to left subtree\\n    std::cout << root->data << \\\" \\\";\\n    printInorder(root->right);  /// recursive call to right subtree\\n}\\n\\n/**\\n * @brief This function is used in test cases to quickly create BST containing\\n * large data instead of hard coding it in code. For a given root, this will add\\n * all the nodes containing data passes in data vector.\\n * @param root Pointer to the root node.\\n * @param data A vector containing integer values which are suppose to be\\n * inserted as nodes in BST.\\n * @returns Node pointer to the root node.\\n * */\\nNode *makeBST(Node *root, const std::vector<int64_t> &data) {\\n    for (int64_t values : data) {\\n        root = Insert(root, values);\\n    }\\n    return root;\\n}\\n\\n/**\\n * @brief Inorder successor of a node is the next node in inorder traversal of\\n * the Binary Tree. This function takes the root node and the data of the node\\n * for which we have to find the inorder successor, and returns the inorder\\n * successor node.\\n * @details Search from the root node as we need to walk the tree starting from\\n * the root node to the given node, by doing so, we are visiting every ancestor\\n * of the given node. In order successor would be the deepest node in this path\\n * for which given node is in left subtree. Time complexity O(h)\\n * @param root A pointer to the root node of the BST\\n * @param data The data (or the data of node) for which we have to find inorder\\n * successor.\\n * @returns Node pointer to the inorder successor node.\\n * */\\nNode *getInorderSuccessor(Node *root, int64_t data) {\\n    Node *current = getNode(root, data);\\n    if (current == nullptr) {\\n        return nullptr;\\n    }\\n\\n    // Case - 1\\n    if (current->right != nullptr) {\\n        return findMinNode(current->right);\\n    }\\n    // case - 2\\n    else {\\n        Node *successor = nullptr;\\n        Node *ancestor = root;\\n\\n        while (ancestor != current && ancestor != nullptr) {\\n            // This means my current node is in left of the root node\\n            if (current->data < ancestor->data) {\\n                successor = ancestor;\\n                ancestor = ancestor->left;  // keep going left\\n            } else {\\n                ancestor = ancestor->right;\\n            }\\n        }\\n        return successor;  // Nodes with maximum vales will not have a successor\\n    }\\n}\\n\\n/**\\n * @brief This function clears the memory allocated to entire tree recursively.\\n * Its just for clean up the memory and not relevant to the actual topic.\\n * @param root Root node of the tree.\\n * @returns void\\n * */\\nvoid deallocate(Node *rootNode) {\\n    if (rootNode == nullptr) {\\n        return;\\n    }\\n    deallocate(rootNode->left);\\n    deallocate(rootNode->right);\\n    delete (rootNode);\\n}\\n\\n}  // namespace inorder_traversal_of_bst\\n}  // namespace operations_on_datastructures\\n\\n/**\\n * @brief class encapsulating the necessary test cases\\n */\\nclass TestCases {\\n private:\\n    /**\\n     * @brief A function to print given message on console.\\n     * @tparam T Type of the given message.\\n     * @returns void\\n     * */\\n    template <typename T>\\n    void log(T msg) {\\n        // It's just to avoid writing cout and endl\\n        std::cout << \\\"[TESTS] : ---> \\\" << msg << std::endl;\\n    }\\n\\n public:\\n    /**\\n     * @brief Executes test cases\\n     * @returns void\\n     * */\\n    void runTests() {\\n        log(\\\"Running Tests...\\\");\\n\\n        testCase_1();\\n        testCase_2();\\n        testCase_3();\\n\\n        log(\\\"Test Cases over!\\\");\\n        std::cout << std::endl;\\n    }\\n\\n    /**\\n     * @brief A test case contains edge case, printing inorder successor of last\\n     * node.\\n     * @returns void\\n     * */\\n    void testCase_1() {\\n        const operations_on_datastructures::inorder_traversal_of_bst::Node\\n            *expectedOutput = nullptr;  ///< Expected output of this test\\n\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\");\\n        log(\\\"This is test case 1 : \\\");\\n        log(\\\"Description:\\\");\\n        log(\\\"   EDGE CASE : Printing inorder successor for last node in the \\\"\\n            \\\"BST, Output will be nullptr.\\\");\\n\\n        operations_on_datastructures::inorder_traversal_of_bst::Node *root =\\n            nullptr;\\n        std::vector<int64_t> node_data{\\n            20, 3, 5, 6, 2, 23, 45, 78, 21};  ///< Data to make nodes in BST\\n\\n        root = operations_on_datastructures::inorder_traversal_of_bst::makeBST(\\n            root,\\n            node_data);  ///< Adding nodes to BST\\n\\n        std::cout << \\\"Inorder sequence is : \\\";\\n        operations_on_datastructures::inorder_traversal_of_bst::printInorder(\\n            root);  ///< Printing inorder to cross-verify.\\n        std::cout << std::endl;\\n\\n        operations_on_datastructures::inorder_traversal_of_bst::Node\\n            *inorderSuccessor = operations_on_datastructures::\\n                inorder_traversal_of_bst::getInorderSuccessor(\\n                    root, 78);  ///< The inorder successor node for given data\\n\\n        log(\\\"Checking assert expression...\\\");\\n        assert(inorderSuccessor == expectedOutput);\\n        log(\\\"Assertion check passed!\\\");\\n\\n        operations_on_datastructures::inorder_traversal_of_bst::deallocate(\\n            root);  /// memory cleanup!\\n\\n        log(\\\"[PASS] : TEST CASE 1 PASS!\\\");\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\");\\n    }\\n\\n    /**\\n     * @brief A test case which contains main list of 100 elements and sublist\\n     * of 20.\\n     * @returns void\\n     * */\\n    void testCase_2() {\\n        const int expectedOutput = 21;  ///< Expected output of this test\\n\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\");\\n        log(\\\"This is test case 2 : \\\");\\n\\n        operations_on_datastructures::inorder_traversal_of_bst::Node *root =\\n            nullptr;\\n        std::vector<int64_t> node_data{\\n            20, 3, 5, 6, 2, 23, 45, 78, 21};  ///< Data to make nodes in BST\\n\\n        root = operations_on_datastructures::inorder_traversal_of_bst::makeBST(\\n            root,\\n            node_data);  ///< Adding nodes to BST\\n\\n        std::cout << \\\"Inorder sequence is : \\\";\\n        operations_on_datastructures::inorder_traversal_of_bst::printInorder(\\n            root);  ///< Printing inorder to cross-verify.\\n        std::cout << std::endl;\\n\\n        operations_on_datastructures::inorder_traversal_of_bst::Node\\n            *inorderSuccessor = operations_on_datastructures::\\n                inorder_traversal_of_bst::getInorderSuccessor(\\n                    root, 20);  ///< The inorder successor node for given data\\n\\n        log(\\\"Checking assert expression...\\\");\\n        assert(inorderSuccessor->data == expectedOutput);\\n        log(\\\"Assertion check passed!\\\");\\n\\n        operations_on_datastructures::inorder_traversal_of_bst::deallocate(\\n            root);  /// memory cleanup!\\n\\n        log(\\\"[PASS] : TEST CASE 2 PASS!\\\");\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\");\\n    }\\n\\n    /**\\n     * @brief A test case which contains main list of 50 elements and sublist\\n     * of 20.\\n     * @returns void\\n     * */\\n    void testCase_3() {\\n        const int expectedOutput = 110;  ///< Expected output of this test\\n\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\");\\n        log(\\\"This is test case 3 : \\\");\\n\\n        operations_on_datastructures::inorder_traversal_of_bst::Node *root =\\n            nullptr;\\n        std::vector<int64_t> node_data{\\n            89,  67,  32, 56, 90, 123, 120,\\n            110, 115, 6,  78, 7,  10};  ///< Data to make nodes in BST\\n\\n        root = operations_on_datastructures::inorder_traversal_of_bst::makeBST(\\n            root,\\n            node_data);  ///< Adding nodes to BST\\n\\n        std::cout << \\\"Inorder sequence is : \\\";\\n        operations_on_datastructures::inorder_traversal_of_bst::printInorder(\\n            root);  ///< Printing inorder to cross-verify.\\n        std::cout << std::endl;\\n\\n        operations_on_datastructures::inorder_traversal_of_bst::Node\\n            *inorderSuccessor = operations_on_datastructures::\\n                inorder_traversal_of_bst::getInorderSuccessor(\\n                    root, 90);  ///< The inorder successor node for given data\\n\\n        log(\\\"Checking assert expression...\\\");\\n        assert(inorderSuccessor->data == expectedOutput);\\n        log(\\\"Assertion check passed!\\\");\\n\\n        operations_on_datastructures::inorder_traversal_of_bst::deallocate(\\n            root);  /// memory cleanup!\\n\\n        log(\\\"[PASS] : TEST CASE 3 PASS!\\\");\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\");\\n    }\\n};\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    TestCases tc;\\n    tc.runTests();\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, char *argv[]) {\\n    test();  // run self-test implementations\\n\\n    operations_on_datastructures::inorder_traversal_of_bst::Node *root =\\n        nullptr;  ///< root node of the bst\\n    std::vector<int64_t> node_data{3,  4, 5,\\n                                   89, 1, 2};  ///< Data to add nodes in BST\\n\\n    int64_t targetElement = 4;  ///< An element to find inorder successor for.\\n    root = operations_on_datastructures::inorder_traversal_of_bst::makeBST(\\n        root, node_data);  ///< Making BST\\n\\n    operations_on_datastructures::inorder_traversal_of_bst::Node\\n        *inorderSuccessor = operations_on_datastructures::\\n            inorder_traversal_of_bst::getInorderSuccessor(root, targetElement);\\n\\n    std::cout << \\\"In-order sequence is : \\\";\\n    operations_on_datastructures::inorder_traversal_of_bst::printInorder(root);\\n    std::cout << std::endl;\\n\\n    if (inorderSuccessor == nullptr) {\\n        std::cout << \\\"Inorder successor for last node is NULL\\\" << std::endl;\\n    } else {\\n        std::cout << \\\"Target element is : \\\" << targetElement << std::endl;\\n        std::cout << \\\"Inorder successor for target element is : \\\"\\n                  << inorderSuccessor->data << std::endl;\\n    }\\n\\n    deallocate(root);  /// memory cleanup!\\n\\n    return 0;\\n}\\n\"",
    "intersection of two arrays": "\"/**\\n * @file\\n * @brief Implementation for the [Intersection of two sorted\\n * Arrays](https://en.wikipedia.org/wiki/Intersection_(set_theory))\\n * algorithm.\\n * @details The intersection of two arrays is the collection of all the elements\\n * that are common in both the first and second arrays. This implementation uses\\n * ordered arrays, and an algorithm to correctly order them and return the\\n * result as a new array (vector).\\n * @see union_of_two_arrays.cpp\\n * @author [Alvin](https://github.com/polarvoid)\\n */\\n\\n#include <algorithm>  /// for std::sort\\n#include <cassert>    /// for assert\\n#include <iostream>   /// for IO operations\\n#include <vector>     /// for std::vector\\n\\n/**\\n * @namespace operations_on_datastructures\\n * @brief Operations on Data Structures\\n */\\nnamespace operations_on_datastructures {\\n\\n/**\\n * @brief Prints the values of a vector sequentially, ending with a newline\\n * character.\\n * @param array Reference to the array to be printed\\n * @returns void\\n */\\nvoid print(const std::vector<int32_t> &array) {\\n    for (int32_t i : array) {\\n        std::cout << i << \\\" \\\";  /// Print each value in the array\\n    }\\n    std::cout << \\\"\\\\n\\\";  /// Print newline\\n}\\n\\n/**\\n * @brief Gets the intersection of two sorted arrays, and returns them in a\\n * vector.\\n * @details An algorithm is used that compares the elements of the two vectors,\\n * incrementing the index of the smaller of the two. If the elements are the\\n * same, the element is appended to the result array to be returned.\\n * @param first A std::vector of sorted integer values\\n * @param second A std::vector of sorted integer values\\n * @returns A std::vector of the intersection of the two arrays, in ascending\\n * order\\n */\\nstd::vector<int32_t> get_intersection(const std::vector<int32_t> &first,\\n                                      const std::vector<int32_t> &second) {\\n    std::vector<int32_t> res;         ///< Vector to hold the intersection\\n    size_t f_index = 0;               ///< Index for the first array\\n    size_t s_index = 0;               ///< Index for the second array\\n    size_t f_length = first.size();   ///< Length of first array\\n    size_t s_length = second.size();  ///< Length of second array\\n\\n    while (f_index < f_length && s_index < s_length) {\\n        if (first[f_index] < second[s_index]) {\\n            f_index++;  ///< Increment index of second array\\n        } else if (first[f_index] > second[s_index]) {\\n            s_index++;  ///< Increment index of second array\\n        } else {\\n            if ((res.size() == 0) || (first[f_index] != res.back())) {\\n                res.push_back(\\n                    first[f_index]);  ///< Add the element if it is unique\\n            }\\n            f_index++;  ///< Increment index of first array\\n            s_index++;  ///< Increment index of second array too\\n        }\\n    }\\n    return res;\\n}\\n\\n}  // namespace operations_on_datastructures\\n\\n/**\\n * @namespace tests\\n * @brief Testcases to check intersection of Two Arrays.\\n */\\nnamespace tests {\\nusing operations_on_datastructures::get_intersection;\\nusing operations_on_datastructures::print;\\n/**\\n * @brief A Test to check an edge case (two empty arrays)\\n * @returns void\\n */\\nvoid test1() {\\n    std::cout << \\\"TEST CASE 1\\\\n\\\";\\n    std::cout << \\\"Intialized a = {} b = {}\\\\n\\\";\\n    std::cout << \\\"Expected result: {}\\\\n\\\";\\n    std::vector<int32_t> a = {};\\n    std::vector<int32_t> b = {};\\n    std::vector<int32_t> result = get_intersection(a, b);\\n    assert(result == a);  ///< Check if result is empty\\n    print(result);        ///< Should only print newline\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check an edge case (one empty array)\\n * @returns void\\n */\\nvoid test2() {\\n    std::cout << \\\"TEST CASE 2\\\\n\\\";\\n    std::cout << \\\"Intialized a = {} b = {2, 3}\\\\n\\\";\\n    std::cout << \\\"Expected result: {}\\\\n\\\";\\n    std::vector<int32_t> a = {};\\n    std::vector<int32_t> b = {2, 3};\\n    std::vector<int32_t> result = get_intersection(a, b);\\n    assert(result == a);  ///< Check if result is equal to a\\n    print(result);        ///< Should only print newline\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check correct functionality with a simple test case\\n * @returns void\\n */\\nvoid test3() {\\n    std::cout << \\\"TEST CASE 3\\\\n\\\";\\n    std::cout << \\\"Intialized a = {4, 6} b = {3, 6}\\\\n\\\";\\n    std::cout << \\\"Expected result: {6}\\\\n\\\";\\n    std::vector<int32_t> a = {4, 6};\\n    std::vector<int32_t> b = {3, 6};\\n    std::vector<int32_t> result = get_intersection(a, b);\\n    std::vector<int32_t> expected = {6};\\n    assert(result == expected);  ///< Check if result is correct\\n    print(result);               ///< Should print 6\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check correct functionality with duplicate values\\n * @returns void\\n */\\nvoid test4() {\\n    std::cout << \\\"TEST CASE 4\\\\n\\\";\\n    std::cout << \\\"Intialized a = {4, 6, 6, 6} b = {2, 4, 4, 6}\\\\n\\\";\\n    std::cout << \\\"Expected result: {4, 6}\\\\n\\\";\\n    std::vector<int32_t> a = {4, 6, 6, 6};\\n    std::vector<int32_t> b = {2, 4, 4, 6};\\n    std::vector<int32_t> result = get_intersection(a, b);\\n    std::vector<int32_t> expected = {4, 6};\\n    assert(result == expected);  ///< Check if result is correct\\n    print(result);               ///< Should print 4 6\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check correct functionality with a harder test case\\n * @returns void\\n */\\nvoid test5() {\\n    std::cout << \\\"TEST CASE 5\\\\n\\\";\\n    std::cout << \\\"Intialized a = {1, 2, 3, 4, 6, 7, 9} b = {2, 3, 4, 5}\\\\n\\\";\\n    std::cout << \\\"Expected result: {2, 3, 4}\\\\n\\\";\\n    std::vector<int32_t> a = {1, 2, 3, 4, 6, 7, 9};\\n    std::vector<int32_t> b = {2, 3, 4, 5};\\n    std::vector<int32_t> result = get_intersection(a, b);\\n    std::vector<int32_t> expected = {2, 3, 4};\\n    assert(result == expected);  ///< Check if result is correct\\n    print(result);               ///< Should print 2 3 4\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check correct functionality with an array sorted using\\n * std::sort\\n * @returns void\\n */\\nvoid test6() {\\n    std::cout << \\\"TEST CASE 6\\\\n\\\";\\n    std::cout << \\\"Intialized a = {1, 3, 3, 2, 5, 9, 4, 7, 3, 2} \\\";\\n    std::cout << \\\"b = {11, 3, 7, 8, 6}\\\\n\\\";\\n    std::cout << \\\"Expected result: {3, 7}\\\\n\\\";\\n    std::vector<int32_t> a = {1, 3, 3, 2, 5, 9, 4, 7, 3, 2};\\n    std::vector<int32_t> b = {11, 3, 7, 8, 6};\\n    std::sort(a.begin(), a.end());  ///< Sort vector a\\n    std::sort(b.begin(), b.end());  ///< Sort vector b\\n    std::vector<int32_t> result = get_intersection(a, b);\\n    std::vector<int32_t> expected = {3, 7};\\n    assert(result == expected);  ///< Check if result is correct\\n    print(result);               ///< Should print 3 7\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n}  // namespace tests\\n\\n/**\\n * @brief Function to test the correctness of get_intersection() function\\n * @returns void\\n */\\nstatic void test() {\\n    tests::test1();\\n    tests::test2();\\n    tests::test3();\\n    tests::test4();\\n    tests::test5();\\n    tests::test6();\\n}\\n\\n/**\\n * @brief main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "reverse a linked list using recusion": "\"#include <iostream>\\nusing namespace std;\\n\\nstruct node {\\n    int val;\\n    node *next;\\n};\\n\\nnode *start;\\n\\nvoid insert(int x) {\\n    node *t = start;\\n    if (start != NULL) {\\n        while (t->next != NULL) {\\n            t = t->next;\\n        }\\n        node *n = new node;\\n        t->next = n;\\n        n->val = x;\\n        n->next = NULL;\\n    } else {\\n        node *n = new node;\\n        n->val = x;\\n        n->next = NULL;\\n        start = n;\\n    }\\n}\\n\\nvoid reverse(node *p, node *q) {\\n    if (q->next == NULL) {\\n        q->next = p;\\n        p->next = NULL;\\n        start = q;\\n        return;\\n    } else {\\n        reverse(q, q->next);\\n        q->next = p;\\n        p->next = NULL;\\n    }\\n}\\n\\nvoid show() {\\n    node *t = start;\\n    while (t != NULL) {\\n        cout << t->val << \\\"\\\\t\\\";\\n        t = t->next;\\n    }\\n}\\n\\nint main() {\\n    insert(1);\\n    insert(2);\\n    insert(3);\\n    insert(4);\\n    insert(5);\\n    insert(6);\\n\\n    reverse(start, start->next);\\n\\n    show();\\n\\n    return 0;\\n}\\n\"",
    "reverse binary tree": "\"/**\\n * @file\\n * @brief Implementation for the [Reversing a Binary\\n * Tree](https://www.geeksforgeeks.org/reverse-tree-path/) recursively\\n * algorithm.\\n * @details A binary tree can be reversed by swapping the left and\\n * right child of a node at each node, starting from the root, and\\n * cascading below. This solution aims to provide an implementation of\\n * a recursive reversal of a binary tree.\\n * @author [Alvin](https://github.com/polarvoid)\\n */\\n\\n#include <cassert>   /// For assert\\n#include <iostream>  /// For IO operations\\n#include <queue>     /// For std::queue\\n#include <vector>    /// For std::vector\\n\\n/**\\n * @namespace operations_on_datastructures\\n * @brief Operations on Data Structures\\n */\\nnamespace operations_on_datastructures {\\n\\n/**\\n * @namespace reverse_binary_tree\\n * @brief Functions for the [Reverse a Binary\\n * Tree](https://www.geeksforgeeks.org/reverse-tree-path/) implementation\\n */\\nnamespace reverse_binary_tree {\\n\\n/**\\n * @brief A Node struct that represents a single node in a Binary Tree\\n */\\nstruct Node {\\n    int64_t data;  ///< The value of the Node\\n    Node* left;    ///< The Node's left child\\n    Node* right;   ///< The Node's right child\\n    /**\\n     * @brief Creates a new Node with some initial data\\n     */\\n    explicit Node(int64_t _data) {\\n        data = _data;     ///< Set value of Node data\\n        left = nullptr;   ///< Initialize left child to NULL\\n        right = nullptr;  ///< Initialize right child to NULL\\n    }\\n};\\n\\n/**\\n * @brief A Binary Tree class that implements a Binary Search Tree\\n *(BST) by default.\\n */\\nclass BinaryTree {\\n private:\\n    Node* root;  ///< Pointer to root node of Binary Tree\\n    /**\\n     * @brief inserts a node in the Binary Tree, with the behaviouur of\\n     * a Binary Search Tree.\\n     * @details Nodes with smaller values are inserted in the left\\n     * subtree, and Nodes with larger values are inserted into the\\n     * right subtree recursively. Time Complexity: O(log(n))\\n     * @param data The data/value of the Node to be inserted\\n     * @param pivot A pointer to the root node of the (sub)tree\\n     * @returns Node pointer to the root\\n     */\\n    Node* insert(int64_t data, Node* pivot) {\\n        if (pivot == nullptr) {\\n            return new Node(data);  ///< Create new node\\n        }\\n        if (data <= pivot->data) {\\n            pivot->left =\\n                insert(data, pivot->left);  ///< Insert Node to the left\\n        } else {\\n            pivot->right =\\n                insert(data, pivot->right);  ///< Insert node to the right\\n        }\\n        return pivot;\\n    }\\n    /**\\n     * @brief Reverses a Binary Tree recursively by swapping the left and\\n     * right subtrees and their children.\\n     * @param pivot A reference to the root of the (sub)tree\\n     * @returns Node pointer to root node\\n     */\\n    Node* reverseBinaryTree(Node* pivot) {\\n        if (pivot == nullptr) {\\n            return pivot;  ///< Base case\\n        }\\n        Node* temp = pivot->left;  ///< pointer to the left subtree\\n        pivot->left = reverseBinaryTree(pivot->right);  ///< Swap\\n        pivot->right = reverseBinaryTree(temp);         ///< Swap\\n        return pivot;\\n    }\\n\\n public:\\n    /**\\n     * @brief Creates a BinaryTree with a root pointing to NULL.\\n     */\\n    BinaryTree() { root = nullptr; }\\n    /**\\n     * @brief Creates a BinaryTree with a root with an initial value.\\n     */\\n    explicit BinaryTree(int64_t data) { root = new Node(data); }\\n    /**\\n     * @brief Adds a new Node to the Binary Tree\\n     */\\n    void add(int64_t data) { root = insert(data, root); }\\n    /**\\n     * Reverses the Binary Tree\\n     */\\n    void reverse() { root = reverseBinaryTree(root); }\\n    /**\\n     * @brief Level order traversal of a tree consists of visiting its\\n     * elements, top to bottom, left to right. This function performs\\n     * level order traversal and returns the node datas as a vector.\\n     * @details The function uses a queue to append and remove elements\\n     * as they are visited, and then adds their children, if any. This\\n     * ensures that the elements are visited layer-by-layer, starting\\n     * from the root of the Tree.\\n     * @returns vector<int64_t> of nodes of the tree.\\n     */\\n    std::vector<int64_t> get_level_order() {\\n        std::vector<int64_t> data;  ///< Result vector of int\\n        if (root == nullptr) {\\n            return data;  ///< Return empty vector if root is Invalid\\n        }\\n        std::queue<Node*> nodes;  ///< Queue of the nodes in the tree\\n        nodes.push(root);         ///< Insert root into the queue\\n        while (!nodes.empty()) {\\n            Node* temp = nodes.front();  ///< Copy the first element\\n            data.push_back(temp->data);  ///< Add the element to the data\\n            nodes.pop();                 ///< Remove element\\n            if (temp->left != nullptr) {\\n                nodes.push(temp->left);  ///< Insert left node\\n            }\\n            if (temp->right != nullptr) {\\n                nodes.push(temp->right);  ///< Insert right node\\n            }\\n        }  /// Add nodes while Tree is not empty\\n        return data;\\n    }\\n    /**\\n     * @brief Prints all of the elements in the tree to stdout\\n     * level-by-level, using the get_level_order() function.\\n     * @returns void\\n     */\\n    void print() {\\n        for (int i : get_level_order()) {\\n            std::cout << i << \\\" \\\";  /// Print each element in the tree\\n        }\\n        std::cout << \\\"\\\\n\\\";  /// Print newline\\n    }\\n};\\n\\n}  // namespace reverse_binary_tree\\n}  // namespace operations_on_datastructures\\n\\n/**\\n * @namespace tests\\n * @brief Testcases to check Reversal of Binary Tree.\\n */\\nnamespace tests {\\nusing operations_on_datastructures::reverse_binary_tree::\\n    BinaryTree;  ///< Use the BinaryTree\\n/**\\n * @brief A Test to check an edge case (single element reversal)\\n */\\nvoid test1() {\\n    BinaryTree bst;\\n    std::vector<int64_t> pre_reversal, post_reversal;\\n    std::cout << \\\"TEST CASE 1\\\\n\\\";\\n    std::cout << \\\"Initializing tree with a single element (5)\\\\n\\\";\\n    bst.add(5);\\n    pre_reversal = bst.get_level_order();\\n    std::cout << \\\"Before reversal: \\\";\\n    bst.print();\\n    std::cout << \\\"After reversal: \\\";\\n    bst.reverse();\\n    post_reversal = bst.get_level_order();\\n    assert(pre_reversal.size() ==\\n           post_reversal.size());  ///< Check for equal sizes\\n    assert(pre_reversal.size() ==\\n           1);  ///< Ensure that there is only one element\\n    assert(pre_reversal[0] ==\\n           post_reversal[0]);  ///< Check if both elements are same\\n    bst.print();\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check an edge case (NULL root element)\\n */\\nvoid test2() {\\n    BinaryTree bst;\\n    std::vector<int64_t> pre_reversal, post_reversal;\\n    std::cout << \\\"TEST CASE 2\\\\n\\\";\\n    std::cout << \\\"Creating empty tree (root points to NULL)\\\\n\\\";\\n    pre_reversal = bst.get_level_order();\\n    std::cout << \\\"Before reversal: \\\";\\n    bst.print();\\n    std::cout << \\\"After reversal: \\\";\\n    bst.reverse();\\n    post_reversal = bst.get_level_order();\\n    assert(pre_reversal.size() ==\\n           post_reversal.size());  ///< Check for equal sizes\\n    assert(pre_reversal.size() ==\\n           0);  ///< Ensure that there is only one element\\n    bst.print();\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check correct reversal of a Binary Tree\\n */\\nvoid test3() {\\n    BinaryTree bst;\\n    std::vector<int64_t> pre_reversal, post_reversal;\\n    std::vector<int64_t> pre_res = {4, 3, 6, 2, 5, 7, 1};\\n    std::vector<int64_t> post_res = {4, 6, 3, 7, 5, 2, 1};\\n    std::cout << \\\"TEST CASE 3\\\\n\\\";\\n    std::cout << \\\"Creating tree with elements (4, 6, 3, 2, 5, 7, 1)\\\\n\\\";\\n    bst.add(4);\\n    bst.add(6);\\n    bst.add(3);\\n    bst.add(2);\\n    bst.add(5);\\n    bst.add(7);\\n    bst.add(1);\\n    pre_reversal = bst.get_level_order();\\n    assert(pre_reversal == pre_res);  ///< Check for equality\\n    std::cout << \\\"Before reversal: \\\";\\n    bst.print();\\n    std::cout << \\\"After reversal: \\\";\\n    bst.reverse();\\n    post_reversal = bst.get_level_order();\\n    assert(post_reversal == post_res);  ///< Check for equality\\n    bst.print();\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n}  // namespace tests\\n\\n/**\\n * @brief Function to test the correctness of the Tree Reversal\\n */\\nstatic void test() {\\n    tests::test1();  ///< Single element test\\n    tests::test2();  ///< No element test\\n    tests::test3();  ///< Correct reversal test\\n}\\n\\n/**\\n * @brief main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "selectionsortlinkedlist": "\"#include <iostream>\\nusing namespace std;\\n\\n// node defined\\nclass node {\\n public:\\n    int data;\\n    node *link;\\n    node(int d) {\\n        data = d;\\n        link = NULL;\\n    }\\n};\\n\\n// printing the linked list\\nvoid print(node *head) {\\n    node *current = head;\\n    while (current != NULL) {\\n        cout << current->data << \\\" \\\";\\n        current = current->link;\\n    }\\n    cout << endl;\\n}\\n\\n// creating the linked list with 'n' nodes\\nnode *createlist(int n) {\\n    node *head = NULL;\\n    node *t = NULL;\\n    for (int i = 0; i < n; i++) {\\n        node *temp = NULL;\\n        int num;\\n        cin >> num;\\n        temp = new node(num);\\n        if (head == NULL) {\\n            head = temp;\\n            t = temp;\\n            continue;\\n        }\\n        if (t->link == NULL)\\n            t->link = temp;\\n        t = temp;\\n    }\\n    return head;\\n}\\n\\n// performing selection sort on the linked list in an iterative manner\\nvoid my_selection_sort_linked_list(node *&head) {\\n    node *min = head;  // throughout the algorithm 'min' is used to denote the\\n                       // node with min value out of all the nodes left for\\n                       // scanning while scanning if we find a node 'X' with\\n                       // value lesser than min, then we update the pointers in\\n                       // such a way that 'X' becomes the predecessor of 'min'\\n    node *current =\\n        min->link;  // 'current' refers to the current node we are scanning\\n    node *previous = min;  //'previous' refers to the node that is previous to\\n                           // the current node\\n    node *temp =\\n        NULL;  // 'temp' in this algo is used to point to the last node of the\\n               // sorted part of the linked list.\\n               // eg. If at any time instance the state of the linked list is\\n               // suppose 1->2->5->3->8->NULL then, we see that \\\"1->2\\\" is the\\n               // sorted part of the LL, and therefore temp will be pointing to\\n               // the last node of the sorted part,i.e,'2' We keep on arranging\\n               // the Linked list in such a way that after each iteration the\\n               // node with 'min' value is placed at its correct position. Eg.\\n               // Let suppose initially we have 5->4->1->3->2->NULL After 1st\\n               // iteration : 1->4->5->3->2->NULL and so on\\n\\n    while (\\n        min->link !=\\n        NULL)  // so that all the nodes are scanned or until there exists a node\\n    {\\n        // pick the first node from the unsorted part and assume that it is the\\n        // minimum and then start scanning from the next node\\n\\n        while (current != NULL)  // suppose you choose the min node to be X,\\n                                 // then scan starts from the (X+1)th node until\\n                                 // its NULL. current = (X+1)th node and min = X\\n        {\\n            if (current->data < min->data)  // if the current node is smaller\\n                                            // than the presumed node 'min'\\n            {\\n                if (temp == NULL)  // temp stays null for the first iteration,\\n                                   // therefore it symbolizes that we are\\n                                   // scanning for the first time\\n                {\\n                    if (previous ==\\n                        min)  // if the 'previous' is pointing to the 'min' node\\n                    {\\n                        // Update the pointers\\n                        head = current;  // update the head pointer with the\\n                                         // current node\\n                        min->link = current->link;\\n                        current->link = previous;\\n                        min = current;\\n                        current = previous->link;\\n                    } else  // if the 'previous' is not pointing to the 'min'\\n                            // node\\n                    {\\n                        // Update the pointers\\n                        head = current;  // update the head pointer with the\\n                                         // current node\\n                        previous->link = current->link;\\n                        current->link = min;\\n                        min = current;\\n                        current = previous->link;\\n                    }\\n                } else  // if 'temp' is not NULL, i.e., its not the 1st\\n                        // iteration\\n                {\\n                    temp->link = current;\\n                    previous->link = current->link;\\n                    current->link = min;\\n                    min = current;\\n                    current = previous->link;\\n                }\\n            } else  // if the current node is greater than min, just move the\\n                    // previous and the current pointer a step further\\n            {\\n                previous = previous->link;\\n                current = current->link;\\n            }\\n        }\\n\\n        // update the pointers. Set 'temp' to the last node in the sorted part.\\n        // Make 'min' move a step further so that 'min' points to the 1st node\\n        // of the unsorted part start the iteration again\\n        temp = min;\\n        min = min->link;\\n        previous = min;\\n        current = min->link;\\n    }\\n}\\n\\n// Test cases:\\n\\n// enter the no. of nodes : 5\\n// 8 9 3 1 4\\n// original list is : 8 9 3 1 4\\n// sorted list is : 1 3 4 8 9\\n\\n// enter the no. of nodes : 3\\n// -1 -2 -3\\n// original list is : -1 -2 -3\\n// sorted list is : -3 -2 -1\\n\\n// enter the no. of nodes : 8\\n// 8 7 6 5 4 3 2 1\\n// original list is : 8 7 6 5 4 3 2 1\\n// sorted list is : 1 2 3 4 5 6 7 8\\n\\n// enter the no. of nodes : 6\\n// 5 3 4 1 -2 -4\\n// original list is : 5 3 4 1 -2 -4\\n// sorted list is : -4 -2 1 3 4 5\\n\\nint main() {\\n    node *head = NULL;\\n    int n;\\n    cout << \\\"enter the no. of nodes : \\\";  // taking input from user about the\\n                                          // number of nodes in linked list\\n    cin >> n;\\n    if (n == 0)\\n        return 0;\\n    head = createlist(n);  // creating the list\\n    cout << \\\"original list is : \\\";\\n    print(head);                          // printing the original linked list\\n    my_selection_sort_linked_list(head);  // applying selection sort\\n    cout << \\\"sorted list is : \\\";\\n    print(head);  // printing the sorted linked list\\n    return 0;\\n}\"",
    "trie multiple search": "\"/**\\r\\n * @file\\r\\n * @brief [Trie datastructure](https://iq.opengenus.org/autocomplete-using-trie-data-structure/)\\r\\n * with search variants\\r\\n * @details\\r\\n * This provides multiple variants of search functions\\r\\n * on a trie structure utilizing STL. The trie is valid\\r\\n * for only English alphabets.\\r\\n * @author [Ghanashyam](https://github.com/g-s-k-zoro)\\r\\n */\\r\\n\\r\\n#include <algorithm>  /// for std::count\\r\\n#include <cassert>    /// for assert\\r\\n#include <cctype>     /// for tolower\\r\\n#include <cstring>    /// for string operations\\r\\n#include <iostream>   /// for IO Operations\\r\\n#include <queue>      /// for std::priority_queue\\r\\n\\r\\n/**\\r\\n * @namespace operations_on_datastructures\\r\\n * @brief Operations on data structures\\r\\n */\\r\\nnamespace operations_on_datastructures {\\r\\n/**\\r\\n * @namespace trie_operations\\r\\n * @brief Functions for [Trie datastructure](https://iq.opengenus.org/autocomplete-using-trie-data-structure/)\\r\\n * implementation\\r\\n */\\r\\nnamespace trie_operations {\\r\\n/**\\r\\n * @brief Class defining the structure of trie node and containing the methods\\r\\n * to perform operations on them.\\r\\n */\\r\\nclass Tnode {\\r\\n private:\\r\\n    static constexpr uint8_t ENGLISH_ALPHABET_SIZE = 26;\\r\\n    // pointers to alphabets\\r\\n    std::vector<Tnode *> english;\\r\\n\\r\\n    // To mark the end of word\\r\\n    bool endOfWord;\\r\\n\\r\\n    // To store the frequency of searches for the word\\r\\n    uint32_t frequency;\\r\\n\\r\\n public:\\r\\n    Tnode() {\\r\\n        english.resize(ENGLISH_ALPHABET_SIZE, nullptr);\\r\\n        endOfWord = false;\\r\\n        frequency = 0;\\r\\n    }\\r\\n    // Copy Constructor\\r\\n    Tnode(const Tnode &node) {\\r\\n        english = node.english;\\r\\n        endOfWord = node.endOfWord;\\r\\n        frequency = node.frequency;\\r\\n    }\\r\\n\\r\\n    Tnode &operator=(const Tnode &node) = default;\\r\\n\\r\\n    Tnode(Tnode &&) = default;\\r\\n\\r\\n    Tnode &operator=(Tnode &&) = default;\\r\\n    /**\\r\\n     * @brief Function to count the number of children a node in the trie has\\r\\n     * @param node a trie node whose children need to be counted\\r\\n     * @return count of the number of children of the given node (max 26)\\r\\n     */\\r\\n    inline uint8_t numberOfChildren(Tnode *node) {\\r\\n        return ENGLISH_ALPHABET_SIZE -\\r\\n               std::count(node->english.begin(), node->english.end(), nullptr);\\r\\n    }\\r\\n\\r\\n    // Functions to perform operations on trie\\r\\n    void Insert(const std::string &entry);\\r\\n    void Delete(std::string entry);\\r\\n    void DeleteFrom(Tnode *delete_from, std::string delete_string,\\r\\n                    int remove_index);\\r\\n    bool SearchPresence(const std::string &key);\\r\\n    void SuggestAutocomplete(Tnode *new_root, const std::string &prefix);\\r\\n    void SearchSuggestions(const std::string &key);\\r\\n    void SuggestFreqAutocomplete(\\r\\n        Tnode *new_root, const std::string &prefix,\\r\\n        std::priority_queue<std::pair<int, std::string> > *suggestions);\\r\\n    void SearchFreqSuggestions(const std::string &key);\\r\\n    void SelectionTop_3(\\r\\n        std::priority_queue<std::pair<int, std::string> > *suggestions);\\r\\n\\r\\n    // To free up the dynamically allocated objects\\r\\n    ~Tnode() {\\r\\n        int i = 0;\\r\\n        for (i = 0; i < ENGLISH_ALPHABET_SIZE; i++) {\\r\\n            if (english[i]) {\\r\\n                delete english[i];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\n/**\\r\\n * @brief Function to insert a word in the trie\\r\\n * @param entry string entry to be inserted in the trie\\r\\n */\\r\\nvoid Tnode::Insert(const std::string &entry) {\\r\\n    Tnode *cur_pos = this;\\r\\n    int letter_index = 0;\\r\\n\\r\\n    for (auto &i : entry) {\\r\\n        // To ignore case\\r\\n        letter_index = tolower(i) - 97;\\r\\n\\r\\n        // Allocate a node for each character of entry if not present in the\\r\\n        // trie\\r\\n        if (cur_pos->english[letter_index] == nullptr) {\\r\\n            cur_pos->english[letter_index] = new Tnode();\\r\\n        }\\r\\n\\r\\n        cur_pos = cur_pos->english[letter_index];\\r\\n    }\\r\\n    // cur_pos points to the last char, mark it as end of word\\r\\n    cur_pos->endOfWord = true;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Function recursively deletes the substring character by\\r\\n * character iterating through the string to be deleted. It traverses till the\\r\\n * end of word in a recursive fashion, from there it deletes characters one by\\r\\n * one till it reaches back to the initial call.\\r\\n * @param delete_from the acting root to the required suffix to be deleted\\r\\n * @param delete_string the string to be deleted from the trie\\r\\n * @param remove_index index denoting the beginning of the substring to be\\r\\n * deleted\\r\\n */\\r\\nvoid Tnode::DeleteFrom(Tnode *delete_from, std::string delete_string,\\r\\n                       int remove_index) {\\r\\n    if (delete_string.size() == remove_index) {\\r\\n        int letter_index = tolower(delete_string[remove_index]) - 97;\\r\\n\\r\\n        DeleteFrom(delete_from->english[letter_index], delete_string,\\r\\n                   remove_index + 1);\\r\\n\\r\\n        delete delete_from;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Function to verify presence and hence delete an entry from the trie\\r\\n * @param entry string entry to be deleted from the trie\\r\\n */\\r\\nvoid Tnode::Delete(std::string entry) {\\r\\n    Tnode *cur_pos = this,\\r\\n          *delete_from = this;  // Current pointer pointing to root\\r\\n    int letter_index = 0, delete_from_index = 0, i = 0, n = entry.size();\\r\\n\\r\\n    for (i = 0; i < n; i++) {\\r\\n        // To ignore case\\r\\n        letter_index = tolower(entry[i]) - 97;\\r\\n\\r\\n        // Display error message when given entry is not present in the tree\\r\\n        if (cur_pos->english[letter_index] == nullptr) {\\r\\n            std::cout << \\\"Entry not Found\\\" << std::endl;\\r\\n            return;\\r\\n        }\\r\\n        // If the current node is end of word for the current prefix or if it\\r\\n        // has 2 or more branches It cannot be deleted while deleting the\\r\\n        // required entry.\\r\\n        if (numberOfChildren(cur_pos) > 1 || cur_pos->endOfWord) {\\r\\n            delete_from = cur_pos;      // denotes the beginning of the shortest\\r\\n                                        // suffix that is allowed to be deleted\\r\\n            delete_from_index = i - 1;  // Beginning index of the suffix\\r\\n                                        // corresponding to the 'entry'\\r\\n        }\\r\\n\\r\\n        // Traversing through the entry\\r\\n        cur_pos = cur_pos->english[letter_index];\\r\\n    }\\r\\n\\r\\n    // cur_pos now points to the last char of entry. Display message if that\\r\\n    // entry does not exist\\r\\n    if (!cur_pos->endOfWord) {\\r\\n        std::cout << \\\"Entry not Found\\\" << std::endl;\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // If cur_pos is not a leaf node, unmark end of word and assign 0 to it's\\r\\n    // frequency for deletion\\r\\n    if (numberOfChildren(cur_pos)) {\\r\\n        cur_pos->endOfWord = false;\\r\\n        cur_pos->frequency = 0;\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // The first character of the suffix to be deleted\\r\\n    letter_index = tolower(entry[delete_from_index + 1]) - 97;\\r\\n    // Point cur_pos to the next node\\r\\n    cur_pos = delete_from->english[letter_index];\\r\\n    // Sever the connection from the main trie\\r\\n    delete_from->english[letter_index] = nullptr;\\r\\n\\r\\n    // If number of characters in the suffix are more than 1, recursively delete\\r\\n    // each character starting from cur_pos using the helper function\\r\\n    if (n > delete_from_index + 2) {\\r\\n        DeleteFrom(cur_pos, entry, delete_from_index + 2);\\r\\n    }\\r\\n    // If the suffix is only 1 char in length\\r\\n    else {\\r\\n        delete cur_pos;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Function to check a word's presence in the trie (Basic)\\r\\n * @param key the string key to be searched in the trie\\r\\n * @return true if the key is found\\r\\n * @return false if the key is not found\\r\\n */\\r\\nbool Tnode::SearchPresence(const std::string &key) {\\r\\n    Tnode *cur_pos = this;\\r\\n    int letter_index = 0;\\r\\n\\r\\n    for (auto &i : key) {\\r\\n        letter_index = tolower(i) - 97;\\r\\n        // If any character in the order of the key is absent, word not found!\\r\\n        if (cur_pos->english[letter_index] == nullptr) {\\r\\n            return false;\\r\\n        }\\r\\n        cur_pos = cur_pos->english[letter_index];\\r\\n    }\\r\\n    // Word is only present in the trie if the key is a valid complete entry and\\r\\n    // not just a prefix.\\r\\n    if (cur_pos->endOfWord) {\\r\\n        (cur_pos->frequency)++;\\r\\n        return true;\\r\\n    } else {\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Recursive function to suggest all the entries of trie\\r\\n * which have a given common prefix\\r\\n * @param new_root pointer pointing to the node corresponding to the last char\\r\\n * of prefix\\r\\n * @param prefix the common prefix that all the suggestions must have\\r\\n */\\r\\nvoid Tnode::SuggestAutocomplete(Tnode *new_root, const std::string &prefix) {\\r\\n    // Iterate through all 26 nodes as we have to print all strings with the\\r\\n    // given prefix\\r\\n    int i = 0;\\r\\n    for (i = 0; i < ENGLISH_ALPHABET_SIZE; i++) {\\r\\n        if (new_root->english[i] != nullptr) {\\r\\n            // Print the sugestion only if it's a valid complete entry and not\\r\\n            // just a prefix\\r\\n            if (new_root->english[i]->endOfWord) {\\r\\n                std::cout << prefix + char(i + 97) << std::endl;\\r\\n            }\\r\\n\\r\\n            SuggestAutocomplete(new_root->english[i], prefix + char(i + 97));\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Lists out all the words in trie with the longest prefix\\r\\n * of the search key that is present in the trie. For example - if trie contains\\r\\n * \\\"abc\\\", \\\"abcde\\\", \\\"abcdefg\\\", \\\"abcddef\\\" and if the search key is \\\"abcdezz\\\", then\\r\\n * the longest common prefix is \\\"abcde\\\" and hence search results will be\\r\\n * \\\"abcde\\\", \\\"abcdefg\\\".\\r\\n * @param key the string key to be searched for suggestions\\r\\n */\\r\\nvoid Tnode::SearchSuggestions(const std::string &key) {\\r\\n    Tnode *cur_pos = nullptr, *prev_pos = nullptr;\\r\\n    cur_pos = prev_pos = this;  // maintaining 2 pointers, initialized to root\\r\\n    int letter_index = 0;\\r\\n    std::string prefix =\\r\\n        \\\"\\\";  // variable storing the updated value of longest common prefix\\r\\n\\r\\n    for (auto &i : key) {\\r\\n        letter_index = tolower(i) - 97;\\r\\n        prev_pos = cur_pos;  // Previous pointer updated to point to the last\\r\\n                             // char of the longest common prefix\\r\\n\\r\\n        // When the node for the character does not exist, longest prefix has\\r\\n        // been determined and SuggestAutocomplete is called\\r\\n        if (cur_pos->english[letter_index] == nullptr) {\\r\\n            SuggestAutocomplete(prev_pos, prefix);\\r\\n            std::cout << \\\"- - - - - - - - - - - - - - - - - - - - - - - - - - \\\"\\r\\n                      << std::endl;\\r\\n            return;\\r\\n        }\\r\\n        // Updating the longest common prefix\\r\\n        prefix += char(tolower(i));\\r\\n        cur_pos = cur_pos->english[letter_index];\\r\\n    }\\r\\n    // If the key is a valid entry of trie, display it @ top of the suggestions\\r\\n    if (cur_pos->endOfWord) {\\r\\n        std::cout << key << std::endl;\\r\\n        (cur_pos->frequency)++;\\r\\n    }\\r\\n\\r\\n    (void)prev_pos;  // Idiom to ignore previous pointer\\r\\n\\r\\n    // Call for suggestions when the search key is present as an entry/a prefix\\r\\n    // in the trie\\r\\n    SuggestAutocomplete(cur_pos, prefix);\\r\\n    std::cout << \\\"- - - - - - - - - - - - - - - - - - - - - - - - - - \\\"\\r\\n              << std::endl;\\r\\n    return;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Function to display the 3 suggestions with highest frequency\\r\\n * of search hits\\r\\n * @param suggestions a max heap that contains pairs of (frequency, word)\\r\\n * heapified based on frequency\\r\\n */\\r\\nvoid Tnode::SelectionTop_3(\\r\\n    std::priority_queue<std::pair<int, std::string> > *suggestions) {\\r\\n    // Display Either top 3 or total number of suggestions, whichever is smaller\\r\\n    int n = suggestions->size(), Top = 0;\\r\\n    Top = n < 3 ? n : 3;\\r\\n    while (Top--) {\\r\\n        std::cout << suggestions->top().second << std::endl;\\r\\n        suggestions->pop();\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Recursive function to suggest most frequently\\r\\n * searched entries of trie which have a given common prefix\\r\\n * @param new_root pointer pointing to the node corresponding to the last char\\r\\n * of prefix\\r\\n * @param prefix the common prefix that all the suggestions must have\\r\\n * @param suggestions a max heap that contains pairs of (frequency, word)\\r\\n * heapified based on frequency\\r\\n */\\r\\nvoid Tnode::SuggestFreqAutocomplete(\\r\\n    Tnode *new_root, const std::string &prefix,\\r\\n    std::priority_queue<std::pair<int, std::string> > *suggestions) {\\r\\n    int i = 0;\\r\\n    for (i = 0; i < ENGLISH_ALPHABET_SIZE; i++) {\\r\\n        if (new_root->english[i] != nullptr) {\\r\\n            // Add to sugestions only if it's a valid complete entry and not\\r\\n            // just a prefix\\r\\n            if (new_root->english[i]->endOfWord) {\\r\\n                suggestions->push(std::make_pair(\\r\\n                    new_root->english[i]->frequency, prefix + char(i + 97)));\\r\\n            }\\r\\n\\r\\n            SuggestFreqAutocomplete(new_root->english[i], prefix + char(i + 97),\\r\\n                                    suggestions);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Lists out the most frequent words in trie with the\\r\\n * longest prefix of the search key that is present in the trie. For example -\\r\\n * if trie contains \\\"abc\\\", \\\"abcde\\\", \\\"abcdefg\\\", \\\"abcddef\\\" and they have been\\r\\n * previously searched for 3, 1, 2, 4 times respectively, if the search key is\\r\\n * \\\"ab\\\", then the longest common prefix is \\\"ab\\\" and only the top 3 frequencies\\r\\n * among the matches would be displayed viz. \\\"abcddef\\\", \\\"abc\\\", \\\"abcdefg\\\".\\r\\n * @param key the string key to be searched for suggestions\\r\\n */\\r\\nvoid Tnode::SearchFreqSuggestions(const std::string &key) {\\r\\n    Tnode *cur_pos = nullptr, *prev_pos = nullptr;\\r\\n    cur_pos = prev_pos = this;  // maintaining 2 pointers, initialized to root\\r\\n    int letter_index = 0;\\r\\n    std::string prefix =\\r\\n        \\\"\\\";  // variable storing the updated value of longest common prefix\\r\\n    std::priority_queue<std::pair<int, std::string> >\\r\\n        suggestions;  // max heap to store (frequency, word) in descending order\\r\\n                      // of freq\\r\\n\\r\\n    std::priority_queue<std::pair<int, std::string> > *Suggestions =\\r\\n        &suggestions;\\r\\n\\r\\n    for (auto &i : key) {\\r\\n        letter_index = tolower(i) - 97;\\r\\n        prev_pos = cur_pos;  // Previous pointer updated to point to the last\\r\\n                             // char of the longest common prefix\\r\\n\\r\\n        // When the node for the character does not exist, longest prefix has\\r\\n        // been determined and SuggestFreqAutocomplete is called\\r\\n        if (cur_pos->english[letter_index] == nullptr) {\\r\\n            SuggestFreqAutocomplete(prev_pos, prefix, Suggestions);\\r\\n            // To display the top 3 results\\r\\n            SelectionTop_3(Suggestions);\\r\\n            std::cout << \\\"- - - - - - - - - - - - - - - - - - - - - - - - - - \\\"\\r\\n                      << std::endl;\\r\\n            return;\\r\\n        }\\r\\n        // Updating the longest common prefix\\r\\n        prefix += char(tolower(i));\\r\\n        cur_pos = cur_pos->english[letter_index];\\r\\n    }\\r\\n    // If the key is a valid entry of trie, display it @ top of the suggestions\\r\\n    if (cur_pos->endOfWord) {\\r\\n        (cur_pos->frequency)++;\\r\\n        std::cout << key << std::endl;\\r\\n    }\\r\\n\\r\\n    (void)prev_pos;  // Idiom to ignore previous pointer\\r\\n\\r\\n    // Call for Suggestions when the search key is present as an entry/a prefix\\r\\n    // in the trie\\r\\n    SuggestFreqAutocomplete(cur_pos, prefix, Suggestions);\\r\\n    // Display the top 3 results\\r\\n    SelectionTop_3(Suggestions);\\r\\n\\r\\n    std::cout << \\\"- - - - - - - - - - - - - - - - - - - - - - - - - - \\\"\\r\\n              << std::endl;\\r\\n    return;\\r\\n}\\r\\n}  // namespace trie_operations\\r\\n}  // namespace operations_on_datastructures\\r\\n\\r\\n/**\\r\\n * @brief Function to test a simple search before and after deleting\\r\\n * an entry. And to test out the multiple variants of search.\\r\\n */\\r\\nstatic void test() {\\r\\n    auto root = new operations_on_datastructures::trie_operations::Tnode();\\r\\n    std::vector<std::string> inputs = {\\r\\n        \\\"abcde\\\", \\\"sss\\\",    \\\"ssss\\\",  \\\"ssst\\\", \\\"sssu\\\", \\\"sssv\\\",\\r\\n        \\\"sst\\\",   \\\"ssts\\\",   \\\"sstt\\\",  \\\"sstu\\\", \\\"tutu\\\", \\\"tutuv\\\",\\r\\n        \\\"tutuu\\\", \\\"tutuvs\\\", \\\"tutus\\\", \\\"tvst\\\", \\\"tvsu\\\", \\\"vvvv\\\"};\\r\\n\\r\\n    for (auto &i : inputs) {\\r\\n        root->Insert(i);\\r\\n    }\\r\\n    // Search an existing entry\\r\\n    assert(root->SearchPresence(\\\"vvvv\\\"));\\r\\n    std::cout << root->SearchPresence(\\\"vvvv\\\") << std::endl;\\r\\n    // Delete it\\r\\n    root->Delete(\\\"vvvv\\\");\\r\\n    // Search for the entry again\\r\\n    assert(!root->SearchPresence(\\\"vvvv\\\"));\\r\\n    std::cout << root->SearchPresence(\\\"vvvv\\\") << std::endl;\\r\\n\\r\\n    std::cout << root->SearchPresence(\\\"tutu\\\") << std::endl;\\r\\n    root->SearchSuggestions(\\\"tutu\\\");\\r\\n    std::cout << root->SearchPresence(\\\"tutu\\\") << std::endl;\\r\\n\\r\\n    root->SearchSuggestions(\\\"tutuv\\\");\\r\\n    std::cout << root->SearchPresence(\\\"tutuv\\\") << std::endl;\\r\\n\\r\\n    root->SearchSuggestions(\\\"tutuvs\\\");\\r\\n\\r\\n    root->SearchFreqSuggestions(\\r\\n        \\\"tu\\\");  // The top 3 frequent entries with prefix tu are tutu, tutuv &\\r\\n                // tutuvs respectively\\r\\n    root->SearchSuggestions(\\r\\n        \\\"\\\");  // Empty search to list all the entries in the trie\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @param argc commandline argument count (ignored)\\r\\n * @param argv commandline array of arguments (ignored)\\r\\n * @returns 0 on exit\\r\\n */\\r\\nint main(int argc, char const *argv[]) {\\r\\n    test();  // run self-test implementations\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "union of two arrays": "\"/**\\n * @file\\n * @brief Implementation for the [Union of two sorted\\n * Arrays](https://en.wikipedia.org/wiki/Union_(set_theory))\\n * algorithm.\\n * @details The Union of two arrays is the collection of all the unique elements\\n * in the first array, combined with all of the unique elements of a second\\n * array. This implementation uses ordered arrays, and an algorithm to correctly\\n * order them and return the result as a new array (vector).\\n * @see intersection_of_two_arrays.cpp\\n * @author [Alvin](https://github.com/polarvoid)\\n */\\n\\n#include <algorithm>  /// for std::sort\\n#include <cassert>    /// for assert\\n#include <iostream>   /// for IO operations\\n#include <vector>     /// for std::vector\\n\\n/**\\n * @namespace operations_on_datastructures\\n * @brief Operations on Data Structures\\n */\\nnamespace operations_on_datastructures {\\n\\n/**\\n * @brief Prints the values of a vector sequentially, ending with a newline\\n * character.\\n * @param array Reference to the array to be printed\\n * @returns void\\n */\\nvoid print(const std::vector<int32_t> &array) {\\n    for (int32_t i : array) {\\n        std::cout << i << \\\" \\\";  /// Print each value in the array\\n    }\\n    std::cout << \\\"\\\\n\\\";  /// Print newline\\n}\\n\\n/**\\n * @brief Gets the union of two sorted arrays, and returns them in a\\n * vector.\\n * @details An algorithm is used that compares the elements of the two vectors,\\n * appending the one that has a lower value, and incrementing the index for that\\n * array. If one of the arrays reaches its end, all the elements of the other\\n * are appended to the resultant vector.\\n * @param first A std::vector of sorted integer values\\n * @param second A std::vector of sorted integer values\\n * @returns A std::vector of the union of the two arrays, in ascending order\\n */\\nstd::vector<int32_t> get_union(const std::vector<int32_t> &first,\\n                               const std::vector<int32_t> &second) {\\n    std::vector<int32_t> res;         ///< Vector to hold the union\\n    size_t f_index = 0;               ///< Index for the first array\\n    size_t s_index = 0;               ///< Index for the second array\\n    size_t f_length = first.size();   ///< Length of first array\\n    size_t s_length = second.size();  ///< Length of second array\\n    int32_t next = 0;  ///< Integer to store value of the next element\\n\\n    while (f_index < f_length && s_index < s_length) {\\n        if (first[f_index] < second[s_index]) {\\n            next = first[f_index];  ///< Append from first array\\n            f_index++;              ///< Increment index of second array\\n        } else if (first[f_index] > second[s_index]) {\\n            next = second[s_index];  ///< Append from second array\\n            s_index++;               ///< Increment index of second array\\n        } else {\\n            next = first[f_index];  ///< Element is the same in both\\n            f_index++;              ///< Increment index of first array\\n            s_index++;              ///< Increment index of second array too\\n        }\\n        if ((res.size() == 0) || (next != res.back())) {\\n            res.push_back(next);  ///< Add the element if it is unique\\n        }\\n    }\\n    while (f_index < f_length) {\\n        next = first[f_index];  ///< Add remaining elements\\n        if ((res.size() == 0) || (next != res.back())) {\\n            res.push_back(next);  ///< Add the element if it is unique\\n        }\\n        f_index++;\\n    }\\n    while (s_index < s_length) {\\n        next = second[s_index];  ///< Add remaining elements\\n        if ((res.size() == 0) || (next != res.back())) {\\n            res.push_back(next);  ///< Add the element if it is unique\\n        }\\n        s_index++;\\n    }\\n    return res;\\n}\\n\\n}  // namespace operations_on_datastructures\\n\\n/**\\n * @namespace tests\\n * @brief Testcases to check Union of Two Arrays.\\n */\\nnamespace tests {\\nusing operations_on_datastructures::get_union;\\nusing operations_on_datastructures::print;\\n/**\\n * @brief A Test to check an edge case (two empty arrays)\\n * @returns void\\n */\\nvoid test1() {\\n    std::cout << \\\"TEST CASE 1\\\\n\\\";\\n    std::cout << \\\"Intialized a = {} b = {}\\\\n\\\";\\n    std::cout << \\\"Expected result: {}\\\\n\\\";\\n    std::vector<int32_t> a = {};\\n    std::vector<int32_t> b = {};\\n    std::vector<int32_t> result = get_union(a, b);\\n    assert(result == a);  ///< Check if result is empty\\n    print(result);        ///< Should only print newline\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check an edge case (one empty array)\\n * @returns void\\n */\\nvoid test2() {\\n    std::cout << \\\"TEST CASE 2\\\\n\\\";\\n    std::cout << \\\"Intialized a = {} b = {2, 3}\\\\n\\\";\\n    std::cout << \\\"Expected result: {2, 3}\\\\n\\\";\\n    std::vector<int32_t> a = {};\\n    std::vector<int32_t> b = {2, 3};\\n    std::vector<int32_t> result = get_union(a, b);\\n    assert(result == b);  ///< Check if result is equal to b\\n    print(result);        ///< Should print 2 3\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check correct functionality with a simple test case\\n * @returns void\\n */\\nvoid test3() {\\n    std::cout << \\\"TEST CASE 3\\\\n\\\";\\n    std::cout << \\\"Intialized a = {4, 6} b = {2, 3}\\\\n\\\";\\n    std::cout << \\\"Expected result: {2, 3, 4, 6}\\\\n\\\";\\n    std::vector<int32_t> a = {4, 6};\\n    std::vector<int32_t> b = {2, 3};\\n    std::vector<int32_t> result = get_union(a, b);\\n    std::vector<int32_t> expected = {2, 3, 4, 6};\\n    assert(result == expected);  ///< Check if result is correct\\n    print(result);               ///< Should print 2 3 4 6\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check correct functionality with duplicate values\\n * @returns void\\n */\\nvoid test4() {\\n    std::cout << \\\"TEST CASE 4\\\\n\\\";\\n    std::cout << \\\"Intialized a = {4, 6, 6, 7} b = {2, 3, 4}\\\\n\\\";\\n    std::cout << \\\"Expected result: {2, 3, 4, 6, 7}\\\\n\\\";\\n    std::vector<int32_t> a = {4, 6, 6, 7};\\n    std::vector<int32_t> b = {2, 3, 4};\\n    std::vector<int32_t> result = get_union(a, b);\\n    std::vector<int32_t> expected = {2, 3, 4, 6, 7};\\n    assert(result == expected);  ///< Check if result is correct\\n    print(result);               ///< Should print 2 3 4 6 7\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check correct functionality with a harder test case\\n * @returns void\\n */\\nvoid test5() {\\n    std::cout << \\\"TEST CASE 5\\\\n\\\";\\n    std::cout << \\\"Intialized a = {1, 4, 6, 7, 9} b = {2, 3, 5}\\\\n\\\";\\n    std::cout << \\\"Expected result: {1, 2, 3, 4, 5, 6, 7, 9}\\\\n\\\";\\n    std::vector<int32_t> a = {1, 4, 6, 7, 9};\\n    std::vector<int32_t> b = {2, 3, 5};\\n    std::vector<int32_t> result = get_union(a, b);\\n    std::vector<int32_t> expected = {1, 2, 3, 4, 5, 6, 7, 9};\\n    assert(result == expected);  ///< Check if result is correct\\n    print(result);               ///< Should print 1 2 3 4 5 6 7 9\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n/**\\n * @brief A Test to check correct functionality with an array sorted using\\n * std::sort\\n * @returns void\\n */\\nvoid test6() {\\n    std::cout << \\\"TEST CASE 6\\\\n\\\";\\n    std::cout << \\\"Intialized a = {1, 3, 3, 2, 5, 9, 4, 3, 2} \\\";\\n    std::cout << \\\"b = {11, 3, 7, 8, 6}\\\\n\\\";\\n    std::cout << \\\"Expected result: {1, 2, 3, 4, 5, 6, 7, 8, 9, 11}\\\\n\\\";\\n    std::vector<int32_t> a = {1, 3, 3, 2, 5, 9, 4, 3, 2};\\n    std::vector<int32_t> b = {11, 3, 7, 8, 6};\\n    std::sort(a.begin(), a.end());  ///< Sort vector a\\n    std::sort(b.begin(), b.end());  ///< Sort vector b\\n    std::vector<int32_t> result = get_union(a, b);\\n    std::vector<int32_t> expected = {1, 2, 3, 4, 5, 6, 7, 8, 9, 11};\\n    assert(result == expected);  ///< Check if result is correct\\n    print(result);               ///< Should print 1 2 3 4 5 6 7 8 9 11\\n    std::cout << \\\"TEST PASSED!\\\\n\\\\n\\\";\\n}\\n}  // namespace tests\\n\\n/**\\n * @brief Function to test the correctness of get_union() function\\n * @returns void\\n */\\nstatic void test() {\\n    tests::test1();\\n    tests::test2();\\n    tests::test3();\\n    tests::test4();\\n    tests::test5();\\n    tests::test6();\\n}\\n\\n/**\\n * @brief main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "buzz number": "\"/**\\n * @file\\n * @brief A buzz number is a number that is either divisible by 7 or has last\\n * digit as 7.\\n */\\n#include <iostream>\\n\\n/** main function */\\nint main() {\\n    int n, t;\\n    std::cin >> t;\\n    while (t--) {\\n        std::cin >> n;\\n        if ((n % 7 == 0) || (n % 10 == 7))\\n            std::cout << n << \\\" is a buzz number\\\" << std::endl;\\n        else\\n            std::cout << n << \\\" is not a buzz number\\\" << std::endl;\\n    }\\n    return 0;\\n}\\n\"",
    "decimal to binary": "\"/**\\n * @file\\n * @brief Function to convert decimal number to binary representation\\n */\\n#include <iostream>\\n\\n/**\\n * This method converts the bit representation and stores it as a decimal\\n * number.\\n */\\nvoid method1(int number) {\\n    int remainder, binary = 0, var = 1;\\n\\n    do {\\n        remainder = number % 2;\\n        number = number / 2;\\n        binary = binary + (remainder * var);\\n        var = var * 10;\\n    } while (number > 0);\\n    std::cout << \\\"Method 1 : \\\" << binary << std::endl;\\n}\\n\\n/**\\n * This method stores each bit value from LSB to MSB and then prints them back\\n * from MSB to LSB\\n */\\nvoid method2(int number) {\\n    int num_bits = 0;\\n    char bit_string[50];\\n\\n    do {\\n        bool bit = number & 0x01;  // get last bit\\n        if (bit)\\n            bit_string[num_bits++] = '1';\\n        else\\n            bit_string[num_bits++] = '0';\\n        number >>= 1;  // right shift bit 1 bit\\n    } while (number > 0);\\n\\n    std::cout << \\\"Method 2 : \\\";\\n    while (num_bits >= 0)\\n        std::cout << bit_string[num_bits--];  // print from MSB to LSB\\n    std::cout << std::endl;\\n}\\n\\nint main() {\\n    int number;\\n    std::cout << \\\"Enter a number:\\\";\\n    std::cin >> number;\\n\\n    method1(number);\\n    method2(number);\\n\\n    return 0;\\n}\\n\"",
    "decimal to hexadecimal": "\"/**\\n * @file\\n * @brief Convert decimal number to hexadecimal representation\\n */\\n\\n#include <iostream>\\n\\n/**\\n * Main program\\n */\\nint main(void) {\\n    int valueToConvert = 0;  // Holds user input\\n    int hexArray[8];         // Contains hex values backwards\\n    int i = 0;               // counter\\n    char HexValues[] = \\\"0123456789ABCDEF\\\";\\n\\n    std::cout << \\\"Enter a Decimal Value\\\"\\n              << std::endl;  // Displays request to stdout\\n    std::cin >>\\n        valueToConvert;  // Stores value into valueToConvert via user input\\n\\n    while (valueToConvert > 15) {             // Dec to Hex Algorithm\\n        hexArray[i++] = valueToConvert % 16;  // Gets remainder\\n        valueToConvert /= 16;\\n        // valueToConvert >>= 4;  // This will divide by 2^4=16 and is faster\\n    }\\n    hexArray[i] = valueToConvert;  // Gets last value\\n\\n    std::cout << \\\"Hex Value: \\\";\\n    while (i >= 0) std::cout << HexValues[hexArray[i--]];\\n\\n    std::cout << std::endl;\\n    return 0;\\n}\\n\"",
    "decimal to roman numeral": "\"/**\\n * @file\\n * @brief This Programme Converts a given decimal number in the range [0,4000)\\n * to both Lower case and Upper case Roman Numeral\\n */\\n\\n#include <cmath>\\n#include <cstdio>\\n#include <cstring>\\n#include <iostream>\\n\\n/** This functions fills a string with character c, n times and returns it\\n * @note This can probably be replace by `memcpy` function.\\n */\\nstd::string fill(char c, int n) {\\n    std::string s = \\\"\\\";\\n    while (n--) s += c;\\n    return s;\\n}\\n\\n/** to convert to lowercase Roman Numeral\\n * the function works recursively\\n */\\nstd::string tolowerRoman(int n) {\\n    if (n < 4)\\n        return fill('i', n);\\n    if (n < 6)\\n        return fill('i', 5 - n) + \\\"v\\\";\\n    if (n < 9)\\n        return std::string(\\\"v\\\") + fill('i', n - 5);\\n    if (n < 11)\\n        return fill('i', 10 - n) + \\\"x\\\";\\n    if (n < 40)\\n        return fill('x', n / 10) + tolowerRoman(n % 10);\\n    if (n < 60)\\n        return fill('x', 5 - n / 10) + 'l' + tolowerRoman(n % 10);\\n    if (n < 90)\\n        return std::string(\\\"l\\\") + fill('x', n / 10 - 5) + tolowerRoman(n % 10);\\n    if (n < 110)\\n        return fill('x', 10 - n / 10) + \\\"c\\\" + tolowerRoman(n % 10);\\n    if (n < 400)\\n        return fill('c', n / 100) + tolowerRoman(n % 100);\\n    if (n < 600)\\n        return fill('c', 5 - n / 100) + 'd' + tolowerRoman(n % 100);\\n    if (n < 900)\\n        return std::string(\\\"d\\\") + fill('c', n / 100 - 5) +\\n               tolowerRoman(n % 100);\\n    if (n < 1100)\\n        return fill('c', 10 - n / 100) + \\\"m\\\" + tolowerRoman(n % 100);\\n    if (n < 4000)\\n        return fill('m', n / 1000) + tolowerRoman(n % 1000);\\n    return \\\"?\\\";\\n}\\n\\n/** to convert to uppercase Roman Numeral\\n * the function works recursively\\n */\\nstd::string toupperRoman(int n) {\\n    if (n < 4)\\n        return fill('I', n);\\n    if (n < 6)\\n        return fill('I', 5 - n) + \\\"V\\\";\\n    if (n < 9)\\n        return std::string(\\\"V\\\") + fill('I', n - 5);\\n    if (n < 11)\\n        return fill('I', 10 - n) + \\\"X\\\";\\n    if (n < 40)\\n        return fill('X', n / 10) + toupperRoman(n % 10);\\n    if (n < 60)\\n        return fill('X', 5 - n / 10) + 'L' + toupperRoman(n % 10);\\n    if (n < 90)\\n        return std::string(\\\"L\\\") + fill('X', n / 10 - 5) + toupperRoman(n % 10);\\n    if (n < 110)\\n        return fill('X', 10 - n / 10) + \\\"C\\\" + toupperRoman(n % 10);\\n    if (n < 400)\\n        return fill('C', n / 100) + toupperRoman(n % 100);\\n    if (n < 600)\\n        return fill('C', 5 - n / 100) + 'D' + toupperRoman(n % 100);\\n    if (n < 900)\\n        return std::string(\\\"D\\\") + fill('C', n / 100 - 5) +\\n               toupperRoman(n % 100);\\n    if (n < 1100)\\n        return fill('C', 10 - n / 100) + \\\"M\\\" + toupperRoman(n % 100);\\n    if (n < 4000)\\n        return fill('M', n / 1000) + toupperRoman(n % 1000);\\n    return \\\"?\\\";\\n}\\n\\n/** main function */\\nint main() {\\n    int n;\\n    std::cout << \\\"\\\\t\\\\tRoman numbers converter\\\\n\\\\n\\\";\\n    std::cout << \\\"Type in decimal number between 0 up to 4000 (exclusive): \\\";\\n    std::cin >> n;\\n    std::cout << n << \\\" in Upper Roman Numerals is \\\" << toupperRoman(n) << \\\"\\\\n\\\";\\n    std::cout << n << \\\" in Lower Roman Numerals is \\\" << tolowerRoman(n) << \\\"\\\\n\\\";\\n    return 0;\\n}\\n\"",
    "easter": "\"/*\\n * @file\\n * @brief Determines the [Date of\\n * Easter](https://en.wikipedia.org/wiki/Date_of_Easter) after 1582\\n *\\n * @details\\n * The date of Easter is determined in each year through a calculation known as\\n * \\\"computus.\\\" Easter is celebrated on the first Sunday after the Paschal full\\n * moon, which is the first full moon on or after 21 March. Determining this\\n * date in advance requires a correlation between the lunar months and the solar\\n * year, while also accounting for the month, date, and weekday of the Julian or\\n * Gregorian calendar. The complexity of the algorithm arises because of the\\n * desire to associate the date of Easter with the date of the Jewish feast of\\n * Passover which, Christians believe, is when Jesus was crucified.\\n *\\n *\\n * @author [AlternateWalls](https://github.com/AlternateWalls)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n\\n/*\\n * @brief Contains information for Easter date\\n */\\nclass EasterYearMonthDay {\\n public:\\n    uint64_t year;   ///< year Easter is on\\n    uint64_t month;  ///< month Easter is on\\n    uint64_t day;    ///< day Easter is on\\n\\n    EasterYearMonthDay(uint64_t newYear, uint64_t newMonth, uint64_t newDay) {\\n        year = newYear;  // Assigns year to class\\n        month = newMonth;\\n        day = newDay;\\n    }\\n};\\n\\n/*\\n * @brief Function that finds the month and day of Easter\\n * @params param1 An int \\\"y\\\" of the year you want to find Easter on after\\n * 1582\\n * @returns An instance of the easterYearMonthDay calss that contains the\\n * information (Ex. 420 - 4/20 or April 20th)\\n */\\nEasterYearMonthDay findEaster(uint64_t y) {\\n    if (y > 1582) {\\n        uint64_t a = y % 19;   // Year's location on Metonic Calendar\\n        uint64_t b = y / 100;  // Century index\\n        uint64_t c = y % 100;\\n        uint64_t d = b / 4;\\n        uint64_t e = b % 4;  // Takes into account leap years\\n        uint64_t f = (b + 8) / 25;\\n        uint64_t g = (b - f + 1) / 3;\\n        uint64_t h = (19 * a + b - d - g + 15) %\\n                     30;  // Days from Mar. 21st until the full moon\\n        uint64_t i = c / 4;\\n        uint64_t k = c % 4;\\n        uint64_t r =\\n            (32 + 2 * e + 2 * i - h - k) %\\n            7;  // The number of days from Paschal full moon to next Sunday\\n        uint64_t m = (a + 11 * h + 22 * r) / 451;\\n        uint64_t n = (h + r - 7 * m + 114) / 31;  // Month of Easter\\n        uint64_t p = (h + r - 7 * m + 114) % 31;  // p + 1 is the day of Easter\\n\\n        // Assign values\\n        EasterYearMonthDay date(\\n            y, n, p + 1);  // Assign values to new instance of class\\n\\n        // Return date\\n        return date;\\n    } else {\\n        EasterYearMonthDay date(0, 0, 0);\\n\\n        // Return date\\n        return date;\\n    }\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 2003 | April 20th\\n    assert(findEaster(2003).month == 4);  // Should return true\\n    assert(findEaster(2003).day == 20);   // Should return true\\n\\n    // 1910 | March 27th\\n    assert(findEaster(1910).month == 3);  // Should return true\\n    assert(findEaster(1910).day == 27);   // Should return true\\n\\n    // 1877 | April 1st\\n    assert(findEaster(1877).month != 3);  // Should return true\\n    assert(findEaster(1877).day != 22);   // Should return true\\n\\n    // 1400 | Invalid date\\n    assert(findEaster(1400).month == 0);  // Should return true\\n    assert(findEaster(1400).day == 0);    // Should return true\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "fast integer input": "\"/**\\n * @file\\n * @brief Read integers from stdin continuously as they are entered without\\n * waiting for the `\\\\n` character\\n */\\n#include <iostream>\\n\\n/** Function to read the number from stdin. The function reads input until a non\\n * numeric character is entered.\\n */\\nvoid fastinput(int *number) {\\n    // variable to indicate sign of input integer\\n    bool negative = false;\\n    register int c;\\n    *number = 0;\\n\\n    // extract current character from buffer\\n    c = std::getchar();\\n    if (c == '-') {\\n        // number is negative\\n        negative = true;\\n\\n        // extract the next character from the buffer\\n        c = std::getchar();\\n    }\\n\\n    // Keep on extracting characters if they are integers\\n    // i.e ASCII Value lies from '0'(48) to '9' (57)\\n    for (; (c > 47 && c < 58); c = std::getchar())\\n        *number = *number * 10 + c - 48;\\n\\n    // if scanned input has a negative sign, negate the\\n    // value of the input number\\n    if (negative)\\n        *(number) *= -1;\\n}\\n\\n/** Main function */\\nint main() {\\n    int number;\\n    fastinput(&number);\\n    std::cout << number << std::endl;\\n    return 0;\\n}\\n\"",
    "happy number": "\"/**\\n * @file\\n * @brief A happy number is a number whose sum of digits is calculated until the\\n * sum is a single digit, and this sum turns out to be 1\\n */\\n\\n#include <iostream>\\n\\n/**\\n * Checks if a decimal number is a happy number\\n * \\\\returns true if happy else false\\n */\\ntemplate <typename T>\\nbool is_happy(T n) {\\n    T s = 0;              // stores sum of digits\\n    while (n > 9) {       // while number is > 9, there are more than 1 digit\\n        while (n != 0) {  // get digit\\n            T d = n % 10;\\n            s += d;\\n            n /= 10;\\n        }\\n        n = s;\\n        s = 0;\\n    }\\n    return (n == 1) ? true : false;  // true if k == 1\\n}\\n\\n/** Main function */\\nint main() {\\n    int n;\\n    std::cout << \\\"Enter a number:\\\";\\n    std::cin >> n;\\n\\n    if (is_happy(n))\\n        std::cout << n << \\\" is a happy number\\\" << std::endl;\\n    else\\n        std::cout << n << \\\" is not a happy number\\\" << std::endl;\\n    return 0;\\n}\\n\"",
    "iterative tree traversals": "\"/**\\r\\n * @file\\r\\n * @brief Iterative version of Preorder, Postorder, and preorder [Traversal of\\r\\n * the Tree] (https://en.wikipedia.org/wiki/Tree_traversal)\\r\\n * @author [Motasim](https://github.com/motasimmakki)\\r\\n * @details\\r\\n *\\r\\n * ### Iterative Preorder Traversal of a tree\\r\\n * Create a Stack that will store the Node of Tree.\\r\\n * Push the root node into the stack.\\r\\n * Save the root into the variabe named as current, and pop and elemnt from the\\r\\n * stack. Store the data of current into the result array, and start traversing\\r\\n * from it. Push both the child node of the current node into the stack, first\\r\\n * right child then left child. Repeat the same set of steps untill the Stack\\r\\n * becomes empty. And return the result array as the preorder traversal of a\\r\\n * tree.\\r\\n *\\r\\n * ### Iterative Postorder Traversal of a tree\\r\\n * Create a Stack that will store the Node of Tree.\\r\\n * Push the root node into the stack.\\r\\n * Save the root into the variabe named as current, and pop and elemnt from the\\r\\n * stack. Store the data of current into the result array, and start traversing\\r\\n * from it. Push both the child node of the current node into the stack, first\\r\\n * left child then right child. Repeat the same set of steps untill the Stack\\r\\n * becomes empty. Now reverse the result array and then return it to the calling\\r\\n * function as a postorder traversal of a tree.\\r\\n *\\r\\n * ### Iterative Inorder Traversal of a tree\\r\\n * Create a Stack that will store the Node of Tree.\\r\\n * Push the root node into the stack.\\r\\n * Save the root into the variabe named as current.\\r\\n * Now iterate and take the current to the extreme left of the tree by\\r\\n * traversing only to its left. Pop the elemnt from the stack and assign it to\\r\\n * the current. Store the data of current into the result array. Repeat the same\\r\\n * set of steps until the Stack becomes empty or the current becomes NULL. And\\r\\n * return the result array as the inorder traversal of a tree.\\r\\n */\\r\\n#include <algorithm>  /// for `reverse`\\r\\n#include <cassert>    /// for `assert`\\r\\n#include <iostream>   /// for I/O operations\\r\\n#include <stack>      /// for `stack`\\r\\n#include <vector>     /// for `vector`\\r\\n\\r\\n/**\\r\\n * @namespace others\\r\\n * @brief Other algorithms\\r\\n */\\r\\nnamespace others {\\r\\n/**\\r\\n * @namespace iterative_tree_traversals\\r\\n * @brief Functions for the [Traversal of the\\r\\n * Tree](https://en.wikipedia.org/wiki/Tree_traversal) algorithm\\r\\n */\\r\\nnamespace iterative_tree_traversals {\\r\\n/**\\r\\n * @brief defines the structure of a node of the tree\\r\\n */\\r\\nstruct Node {\\r\\n    int64_t data = 0;      ///< The value/key of the node.\\r\\n    struct Node *left{};   ///< struct pointer to left subtree.\\r\\n    struct Node *right{};  ///< struct pointer to right subtree.\\r\\n};\\r\\n\\r\\n/**\\r\\n * @brief defines the functions associated with the binary tree\\r\\n */\\r\\nclass BinaryTree {\\r\\n public:\\r\\n    Node *createNewNode(\\r\\n        int64_t);  ///< function that will create new node for insertion.\\r\\n    std::vector<int64_t> preOrderIterative(\\r\\n        Node *);  ///< function that takes root of the tree as an argument, and\\r\\n                  ///< returns its preorder traversal.\\r\\n    std::vector<int64_t> postOrderIterative(\\r\\n        Node *);  ///< function that takes root of the tree as an argument, and\\r\\n                  ///< returns its postorder traversal.\\r\\n    std::vector<int64_t> inOrderIterative(\\r\\n        Node *);  ///< function that takes root of the tree as an argument, and\\r\\n                  ///< returns its inorder traversal.\\r\\n};\\r\\n\\r\\n/**\\r\\n * @brief will allocate the memory for a node and, along the data and return the\\r\\n * node.\\r\\n * @param data value that a particular node will contain.\\r\\n * @return pointer to the newly created node with assigned data.\\r\\n */\\r\\nNode *BinaryTree::createNewNode(int64_t data) {\\r\\n    Node *node = new Node();\\r\\n    node->data = data;\\r\\n    node->left = node->right = nullptr;\\r\\n    return node;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief preOrderIterative() function that will perform the preorder traversal\\r\\n * iteratively, and return the result array that contain the preorder traversal\\r\\n * of a tree.\\r\\n * @param root head/root node of a tree\\r\\n * @return result that is containing the preorder traversal of a tree\\r\\n */\\r\\nstd::vector<int64_t> BinaryTree::preOrderIterative(Node *root) {\\r\\n    std::stack<Node *>\\r\\n        stack;  ///< is used to find and traverse the child nodes.\\r\\n    std::vector<int64_t> result;  ///< list of values, sorted in pre-order.\\r\\n\\r\\n    stack.push(root);\\r\\n\\r\\n    while (!stack.empty()) {\\r\\n        result.push_back(stack.top()->data);\\r\\n        Node *current = stack.top();\\r\\n        stack.pop();\\r\\n\\r\\n        if (current->right) {\\r\\n            stack.push(current->right);\\r\\n        }\\r\\n        if (current->left) {\\r\\n            stack.push(current->left);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return result;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief postOrderIterative() function that will perform the postorder\\r\\n * traversal iteratively, and return the result array that contain the postorder\\r\\n * traversal of a tree.\\r\\n * @param root head/root node of a tree\\r\\n * @return result that is containing the postorder traversal of a tree\\r\\n */\\r\\nstd::vector<int64_t> BinaryTree::postOrderIterative(Node *root) {\\r\\n    std::stack<Node *>\\r\\n        stack;  ///< is used to find and traverse the child nodes.\\r\\n    std::vector<int64_t> result;  ///< List of values, sorted in post-order.\\r\\n\\r\\n    stack.push(root);\\r\\n\\r\\n    while (!stack.empty()) {\\r\\n        result.push_back(stack.top()->data);\\r\\n        Node *current = stack.top();\\r\\n        stack.pop();\\r\\n\\r\\n        if (current->left) {\\r\\n            stack.push(current->left);\\r\\n        }\\r\\n        if (current->right) {\\r\\n            stack.push(current->right);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    reverse(result.begin(), result.end());\\r\\n\\r\\n    return result;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief inOrderIterative() function that will perform the inorder traversal\\r\\n * iteratively, and return the result array that contain the inorder traversal\\r\\n * of a tree.\\r\\n * @param root head/root node of a tree\\r\\n * @return result that is containing the inorder traversal of a tree\\r\\n */\\r\\nstd::vector<int64_t> BinaryTree::inOrderIterative(Node *root) {\\r\\n    std::stack<Node *>\\r\\n        stack;  ///< is used to find and traverse the child nodes.\\r\\n    std::vector<int64_t> result;  ///< List of values, sorted in in-order.\\r\\n\\r\\n    Node *current = root;\\r\\n\\r\\n    while (!stack.empty() || current) {\\r\\n        while (current) {\\r\\n            stack.push(current);\\r\\n            current = current->left;\\r\\n        }\\r\\n        current = stack.top();\\r\\n        stack.pop();\\r\\n        result.push_back(current->data);\\r\\n        current = current->right;\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n}  // namespace iterative_tree_traversals\\r\\n}  // namespace others\\r\\n\\r\\n/**\\r\\n * @brief Test the computed preorder with the actual preorder.\\r\\n * @param binaryTree instance of the BinaryTree class\\r\\n * @param root head/root node of a tree\\r\\n */\\r\\nstatic void test1(others::iterative_tree_traversals::BinaryTree binaryTree,\\r\\n                  others::iterative_tree_traversals::Node *root) {\\r\\n    std::vector<int64_t> actual_result{1, 2, 4, 5, 3};\\r\\n    std::vector<int64_t>\\r\\n        result;  ///< result stores the preorder traversal of the binary tree\\r\\n\\r\\n    // Calling preOrderIterative() function by passing a root node,\\r\\n    // and storing the preorder traversal in result.\\r\\n    result = binaryTree.preOrderIterative(root);\\r\\n\\r\\n    // Self-testing the result using `assert`\\r\\n    for (int i = 0; i < result.size(); i++) {\\r\\n        assert(actual_result[i] == result[i]);\\r\\n    }\\r\\n\\r\\n    // Printing the result storing preorder.\\r\\n    std::cout << \\\"\\\\nPreOrder Traversal Is : \\\" << std::endl;\\r\\n    for (auto i : result) {\\r\\n        std::cout << i << \\\"  \\\";\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Test the computed postorder with the actual postorder.\\r\\n * @param binaryTree instance of BinaryTree class\\r\\n * @param root head/root node of a tree\\r\\n */\\r\\nstatic void test2(others::iterative_tree_traversals::BinaryTree binaryTree,\\r\\n                  others::iterative_tree_traversals::Node *root) {\\r\\n    std::vector<int64_t> actual_result{4, 5, 2, 3, 1};\\r\\n    std::vector<int64_t>\\r\\n        result;  ///< result stores the postorder traversal of the binary tree.\\r\\n\\r\\n    // Calling postOrderIterative() function by passing a root node,\\r\\n    // and storing the postorder traversal in result.\\r\\n    result = binaryTree.postOrderIterative(root);\\r\\n\\r\\n    // Self-testing the result using `assert`\\r\\n    for (int i = 0; i < result.size(); i++) {\\r\\n        assert(actual_result[i] == result[i]);\\r\\n    }\\r\\n\\r\\n    // Printing the result storing postorder.\\r\\n    std::cout << \\\"\\\\nPostOrder Traversal Is : \\\" << std::endl;\\r\\n    for (auto i : result) {\\r\\n        std::cout << i << \\\"  \\\";\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Test the computed inorder with the actual inorder.\\r\\n * @param binaryTree instance of BinaryTree class\\r\\n * @param root head/root node of a tree\\r\\n */\\r\\nstatic void test3(others::iterative_tree_traversals::BinaryTree binaryTree,\\r\\n                  others::iterative_tree_traversals::Node *root) {\\r\\n    std::vector<int64_t> actual_result{4, 2, 5, 1, 3};\\r\\n    std::vector<int64_t>\\r\\n        result;  ///< result stores the inorder traversal of the binary tree.\\r\\n\\r\\n    // Calling inOrderIterative() function by passing a root node,\\r\\n    // and storing the inorder traversal in result.\\r\\n    result = binaryTree.inOrderIterative(root);\\r\\n\\r\\n    // Self-testing the result using `assert`\\r\\n    for (int i = 0; i < result.size(); i++) {\\r\\n        assert(actual_result[i] == result[i]);\\r\\n    }\\r\\n\\r\\n    // Printing the result storing inorder.\\r\\n    std::cout << \\\"\\\\nInOrder Traversal Is : \\\" << std::endl;\\r\\n    for (auto i : result) {\\r\\n        std::cout << i << \\\"  \\\";\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Test the computed preorder with the actual preorder on negative value.\\r\\n * @param binaryTree instance of BinaryTree class\\r\\n * @param root head/root node of a tree\\r\\n */\\r\\nstatic void test4(others::iterative_tree_traversals::BinaryTree binaryTree,\\r\\n                  others::iterative_tree_traversals::Node *root) {\\r\\n    std::vector<int64_t> actual_result{-1, -2, -4, -5, -3};\\r\\n    std::vector<int64_t>\\r\\n        result;  ///< result stores the preorder traversal of the binary tree\\r\\n\\r\\n    // Calling preOrderIterative() function by passing a root node,\\r\\n    // and storing the preorder traversal in result.\\r\\n    result = binaryTree.preOrderIterative(root);\\r\\n\\r\\n    // Self-testing the result using `assert`\\r\\n    for (int i = 0; i < result.size(); i++) {\\r\\n        assert(actual_result[i] == result[i]);\\r\\n    }\\r\\n\\r\\n    // Printing the result storing preorder.\\r\\n    std::cout << \\\"\\\\nPreOrder Traversal Is : \\\" << std::endl;\\r\\n    for (auto i : result) {\\r\\n        std::cout << i << \\\"  \\\";\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Test the computed postorder with the actual postorder on negative\\r\\n * value.\\r\\n * @param binaryTree instance of BinaryTree class\\r\\n * @param root head/root node of a tree\\r\\n */\\r\\nstatic void test5(others::iterative_tree_traversals::BinaryTree binaryTree,\\r\\n                  others::iterative_tree_traversals::Node *root) {\\r\\n    std::vector<int64_t> actual_result{-4, -5, -2, -3, -1};\\r\\n    std::vector<int64_t>\\r\\n        result;  ///< result stores the postorder traversal of the binary tree.\\r\\n\\r\\n    // Calling postOrderIterative() function by passing a root node,\\r\\n    // and storing the postorder traversal in result.\\r\\n    result = binaryTree.postOrderIterative(root);\\r\\n\\r\\n    // Self-testing the result using `assert`\\r\\n    for (int i = 0; i < result.size(); i++) {\\r\\n        assert(actual_result[i] == result[i]);\\r\\n    }\\r\\n\\r\\n    // Printing the result storing postorder.\\r\\n    std::cout << \\\"\\\\nPostOrder Traversal Is : \\\" << std::endl;\\r\\n    for (auto i : result) {\\r\\n        std::cout << i << \\\"  \\\";\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Test the computed inorder with the actual inorder on negative value.\\r\\n * @param binaryTree instance of BinaryTree class\\r\\n * @param root head/root node of a tree\\r\\n */\\r\\nstatic void test6(others::iterative_tree_traversals::BinaryTree binaryTree,\\r\\n                  others::iterative_tree_traversals::Node *root) {\\r\\n    std::vector<int64_t> actual_result{-4, -2, -5, -1, -3};\\r\\n    std::vector<int64_t>\\r\\n        result;  ///< result stores the inorder traversal of the binary tree.\\r\\n\\r\\n    // Calling inOrderIterative() function by passing a root node,\\r\\n    // and storing the inorder traversal in result.\\r\\n    result = binaryTree.inOrderIterative(root);\\r\\n\\r\\n    // Self-testing the result using `assert`\\r\\n    for (int i = 0; i < result.size(); i++) {\\r\\n        assert(actual_result[i] == result[i]);\\r\\n    }\\r\\n\\r\\n    // Printing the result storing inorder.\\r\\n    std::cout << \\\"\\\\nInOrder Traversal Is : \\\" << std::endl;\\r\\n    for (auto i : result) {\\r\\n        std::cout << i << \\\"  \\\";\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @returns 0 on exit\\r\\n */\\r\\nint main() {\\r\\n    // Creating a tree with the following structure,\\r\\n    /*\\r\\n              1\\r\\n            /   \\\\\\r\\n           2     3\\r\\n         /   \\\\\\r\\n        4     5\\r\\n    */\\r\\n\\r\\n    others::iterative_tree_traversals::BinaryTree\\r\\n        binaryTree;  ///< instace of BinaryTree, used to access its members\\r\\n                     ///< functions.\\r\\n    others::iterative_tree_traversals::Node *root = binaryTree.createNewNode(1);\\r\\n    root->left = binaryTree.createNewNode(2);\\r\\n    root->right = binaryTree.createNewNode(3);\\r\\n    root->left->left = binaryTree.createNewNode(4);\\r\\n    root->left->right = binaryTree.createNewNode(5);\\r\\n\\r\\n    std::cout << \\\"\\\\n| Tests for positive data value |\\\" << std::endl;\\r\\n    test1(binaryTree, root);  // run preorder-iterative test\\r\\n    std::cout << \\\"\\\\nPre-order test Passed!\\\" << std::endl;\\r\\n\\r\\n    test2(binaryTree, root);  // run postorder-iterative test\\r\\n    std::cout << \\\"\\\\nPost-order test Passed!\\\" << std::endl;\\r\\n\\r\\n    test3(binaryTree, root);  // run inorder-iterative test\\r\\n    std::cout << \\\"\\\\nIn-order test Passed!\\\" << std::endl;\\r\\n\\r\\n    // Modifying tree for negative values.\\r\\n    root->data = -1;\\r\\n    root->left->data = -2;\\r\\n    root->right->data = -3;\\r\\n    root->left->left->data = -4;\\r\\n    root->left->right->data = -5;\\r\\n\\r\\n    std::cout << \\\"\\\\n| Tests for negative data values |\\\" << std::endl;\\r\\n    test4(binaryTree, root);  // run preorder-iterative test on negative values\\r\\n    std::cout << \\\"\\\\nPre-order test on-negative value Passed!\\\" << std::endl;\\r\\n\\r\\n    test5(binaryTree, root);  // run postorder-iterative test on negative values\\r\\n    std::cout << \\\"\\\\nPost-order test on-negative value Passed!\\\" << std::endl;\\r\\n\\r\\n    test6(binaryTree, root);  // run inorder-iterative test on negative values\\r\\n    std::cout << \\\"\\\\nIn-order test on-negative value Passed!\\\" << std::endl;\\r\\n\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "kadanes3": "\"/**\\n * @file\\n * @brief Efficient implementation for maximum contiguous subarray sum by\\n * [Kadane's\\n * algorithm](https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/).\\n * @details\\n * Our task is to take length of array and then the whole array as input from\\n * the user and then calculate the maximum contiguos subarray sum for the\\n * input array, using the kadane's algorithm.\\n *\\n * There can be a case that all the elements in the input array are negative.\\n * In that case, the least value among all elements is the maximum sum with\\n * subarray length = 1.\\n * @author [Abhijeet Tiwari](https://github.com/thisabhijeet)\\n */\\n\\n#include <array>     /// for std::array\\n#include <cassert>   /// for assert\\n#include <climits>   /// for INT_MIN value\\n#include <iostream>  /// for IO operations\\n\\n/**\\n * @brief Utility function to check the current maximum number\\n * \\\\param arr input array\\n * \\\\param length length of the input array\\n * \\\\returns maximum contiguous subarray sum\\n */\\ntemplate <std::size_t SIZE>\\nint max_subarray_sum(std::array<int64_t, SIZE> arr, uint64_t length) {\\n    int64_t current_max = INT_MIN, current_sum = 0;\\n    for (int i = 0; i < length; i++) {\\n        current_sum = current_sum + arr[i];\\n        if (current_max < current_sum) {\\n            current_max = current_sum;\\n        }\\n\\n        if (current_sum < 0) {\\n            current_sum = 0;\\n        }\\n    }\\n    return current_max;\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    std::array<int64_t, 4> arr = {1, 2, 3, 4};\\n    std::array<int64_t, 5> arr1 = {-1, -2, -4, -6, 7};\\n    assert(max_subarray_sum(arr, 4) == 10);\\n    assert(max_subarray_sum(arr1, 5) == 7);\\n    std::cout << \\\"All test cases have passed!\\\\n\\\";\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    // Below is the code for accepting array from the user and then\\n    // calling the function for the required output.\\n    // It has been commented for now so that the test() function can run\\n    // and the test cases can be verified.\\n    // code for accepting array from user starts\\n\\n    // std::size_t n;  // variable for length of input array\\n    // std::cout << \\\"Enter length of the array: \\\";\\n    // std::cin >> n;\\n    // std::array<int64_t, 100> arr = {0};\\n    // // we need to give a constant in size. Hence we have allocated 100\\n    // for now.\\n    // for (int i = 0; i < n; i++)\\n    // taking input of each element of the array\\n    // {\\n    //     std::cin >> arr[i];\\n    // }\\n    // code for accepting array from user ends\\n\\n    // int max_sum = max_subarray_sum(arr, n);\\n    // std::cout << \\\"Maximum contiguous sum for this array is : \\\" << max_sum\\n    //           << std::endl;\\n\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "lru cache": "\"/**\\n * @file\\n * @brief An implementation of\\n * [LRU\\n * Cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)).\\n * Lru is a part of cache algorithms (also frequently called cache replacement\\n * algorithms or cache replacement policies).\\n *\\n * ### Logic\\n *      * Discards the least recently used items first.\\n *      * This algorithm requires keeping track of what was used when, which is\\n * expensive if one wants to make sure the algorithm always discards the least\\n * recently used item.\\n *      * General implementations of this technique require keeping \\\"age bits\\\"\\n * for cache-lines and track the \\\"Least Recently Used\\\" cache-line based on\\n * age-bits.\\n *      * In such an implementation, every time a cache-line is used, the age of\\n * all other cache-lines changes\\n *\\n * ### Algorithm explanation\\n *      For a cache of page frame x:\\n *          * Check if the page is present in cache.\\n *          * If not present, then check is the cache is full or not:\\n *          * If the cache is full, REMOVE the last element from the cache.\\n *          * If the element is present in cache, then shift that element to\\n * first position in cache from its original position.\\n *              * This way you can keep the least recently used elements in the\\n * last and most recently used in front of the cache.\\n *\\n *  Every time a requested page is  not found in cache, that is a miss or page\\n * fault, and if the page is present in cache, then its a hit.\\n *\\n * ## Data Structure used\\n *  * In the algorithm below we used two different data structure, one is linked\\n * list and other one is a hash map\\n *  * The linked list is used to contain the pages and the hash map contains the\\n * pages and their address.\\n *  * Every time a new page is requested, we first check in the hash map if the\\n * page is present or not.\\n *  * If not present, and the cache is full, we simply delete the last entry in\\n * the cache.\\n *  * If present, we shift that page from its current location to beginning of\\n * the cache and update the address in hash map for that page.\\n *\\n * @author [Nitin Sharma](https://github.com/foo290)\\n * */\\n\\n#include <cassert>        /// for assert\\n#include <iostream>       /// for IO Operations\\n#include <list>           /// for std::list\\n#include <unordered_map>  /// for std::unordered_map\\n\\n/**\\n * @namespace others\\n * @brief Other algorithms\\n */\\nnamespace others {\\n/**\\n * @namespace lru_cache\\n * @brief Implementation of the [LRU caching\\n * algorithm](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU))\\n */\\nnamespace lru_cache {\\n/**\\n * @brief LRU cache class\\n */\\nclass LRUCache {\\n    uint64_t pageFrame;         ///< Page frame, or total size of the cache.\\n    std::list<uint64_t> cache;  ///< Cache linked list (using the STL)\\n    std::unordered_map<uint64_t, std::list<uint64_t>::iterator>\\n        pageMap;  ///< Hash map containing pages and their addresses\\n\\n    uint64_t hits =\\n        0;  ///< Total number of hits, or total number of times a page\\n    ///< was found in cache.\\n    uint64_t pageFault = 0;  ///< Total number of miss/page fault, or total\\n                             ///< number of times a page was not found in cache\\n\\n public:\\n    /**\\n     * @brief Constructor, Initialize thee LRU class with page frame.\\n     * @param pf Page frame or total size of cache.\\n     * */\\n    explicit LRUCache(uint64_t pf) { pageFrame = pf; }\\n\\n    /**\\n     * @brief Refer to a page, or request a page from memory.\\n     * @param page The page that you are referring to.\\n     * @returns void\\n     * */\\n    void refer(uint64_t page) {\\n        // If the page requested not in cache.\\n        if (pageMap.find(page) == pageMap.end()) {\\n            pageFault++;  ///< Increase the page fault by one.\\n\\n            // Check if the cache is full\\n            if (cache.size() == pageFrame) {\\n                // delete the last page from cache\\n                uint64_t lastPage = cache.back();\\n                cache.pop_back();\\n                pageMap.erase(lastPage);\\n            }\\n        }\\n        // The requested page is in the cache\\n        else {\\n            hits++;\\n            // present in cache, erase from current position to bring in front\\n            cache.erase(pageMap[page]);\\n        }\\n        // Push it in the front of the cache and update the page reference in\\n        // page map.\\n        cache.push_front(page);\\n        pageMap[page] = cache.begin();\\n    }\\n\\n    /**\\n     * @brief A function to display the current cache\\n     * @returns Void\\n     * */\\n    void display() {\\n        for (uint64_t &it : cache) {\\n            std::cout << it << \\\" \\\";\\n        }\\n        std::cout << std::endl;\\n    }\\n    /**\\n     * @brief A function to get page hits\\n     * @returns int\\n     * */\\n    uint64_t getHits() const { return hits; }\\n    /**\\n     * @brief A function to get page fault\\n     * @returns int\\n     * */\\n    uint64_t getPageFault() const { return pageFault; }\\n};\\n\\n}  // namespace lru_cache\\n}  // namespace others\\n\\nnamespace lru_tests {\\n/**\\n * @brief A function to print given message on console.\\n * @tparam T Type of the given message.\\n * @returns void\\n * */\\ntemplate <typename T>\\nvoid log(T msg) {\\n    // It's just to avoid writing cout and endl\\n    std::cout << \\\"[TESTS] : ---> \\\" << msg << std::endl;\\n}\\n\\n/**\\n * @brief A simple test case\\n * The assert statement will check expected hist and miss to resultant hits and\\n * miss\\n * @returns void\\n * */\\nstatic void test_1() {\\n    uint64_t expected_hits = 2;\\n    uint64_t expected_pageFault = 4;\\n\\n    log(\\\"Running Test-1...\\\");\\n\\n    others::lru_cache::LRUCache cache(4);\\n    cache.refer(1);\\n    cache.refer(2);\\n    cache.refer(5);\\n    cache.refer(1);\\n    cache.refer(4);\\n    cache.refer(5);\\n\\n    log(\\\"Checking assert statement...\\\");\\n    assert(cache.getHits() == expected_hits &&\\n           cache.getPageFault() == expected_pageFault);\\n    log(\\\"Assert successful!\\\");\\n    log(\\\"Test-1 complete!\\\");\\n}\\n\\n/**\\n * @brief A test case contains hits more than cache size\\n * The assert statement will check expected hist and miss to resultant hits and\\n * miss\\n * @returns void\\n * */\\nstatic void test_2() {\\n    uint64_t expected_hits = 4;\\n    uint64_t expected_pageFault = 2;\\n\\n    log(\\\"Running Test-2...\\\");\\n\\n    others::lru_cache::LRUCache cache(4);\\n    cache.refer(1);\\n    cache.refer(1);\\n    cache.refer(1);\\n    cache.refer(1);\\n    cache.refer(1);\\n    cache.refer(5);\\n\\n    log(\\\"Checking assert statement...\\\");\\n    assert(cache.getHits() == expected_hits &&\\n           cache.getPageFault() == expected_pageFault);\\n    log(\\\"Assert successful!\\\");\\n    log(\\\"Test-2 complete!\\\");\\n}\\n\\n/**\\n * @brief A simple test case\\n * The assert statement will check expected hist and miss to resultant hits and\\n * miss\\n * @returns void\\n * */\\nstatic void test_3() {\\n    uint64_t expected_hits = 1;\\n    uint64_t expected_pageFault = 5;\\n\\n    log(\\\"Running Test-3...\\\");\\n\\n    others::lru_cache::LRUCache cache(4);\\n    cache.refer(1);\\n    cache.refer(2);\\n    cache.refer(3);\\n    cache.refer(4);\\n    cache.refer(5);\\n    cache.refer(5);\\n\\n    log(\\\"Checking assert statement...\\\");\\n    assert(cache.getHits() == expected_hits &&\\n           cache.getPageFault() == expected_pageFault);\\n    log(\\\"Assert successful!\\\");\\n    log(\\\"Test-3 complete!\\\");\\n}\\n\\n/**\\n * @brief A function to invoke all test cases\\n * @returns void\\n * */\\nstatic void run_tests() {\\n    test_1();\\n    test_2();\\n    test_3();\\n    log(\\\"\\\");\\n    log(\\\"TESTS COMPLETED!\\\");\\n}\\n}  // namespace lru_tests\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    lru_tests::run_tests();\\n\\n    // Usage\\n    others::lru_cache::LRUCache cache(4);\\n    cache.refer(1);\\n    cache.refer(2);\\n    cache.refer(3);\\n    cache.refer(4);\\n    cache.refer(5);\\n    cache.refer(5);\\n\\n    cache.display();\\n\\n    std::cout << \\\"Hits: \\\" << cache.getHits()\\n              << \\\" Miss: \\\" << cache.getPageFault() << std::endl;\\n    return 0;\\n}\\n\"",
    "matrix exponentiation": "\"/**\\n@file\\n@brief Matrix Exponentiation.\\n\\nThe problem can be solved with DP but constraints are high.\\n<br/>\\\\f$a_i = b_i\\\\f$ (for \\\\f$i <= k\\\\f$)\\n<br/>\\\\f$a_i = c_1 a_{i-1} + c_2 a_{i-2} + ... + c_k a_{i-k}\\\\f$ (for \\\\f$i > k\\\\f$)\\n<br/>Taking the example of Fibonacci series, \\\\f$k=2\\\\f$\\n<br/>\\\\f$b_1 = 1,\\\\; b_2=1\\\\f$\\n<br/>\\\\f$c_1 = 1,\\\\; c_2=1\\\\f$\\n<br/>\\\\f$a = \\\\begin{bmatrix}0& 1& 1& 2& \\\\ldots\\\\end{bmatrix}\\\\f$\\n<br/>This way you can find the \\\\f$10^{18}\\\\f$ fibonacci number%MOD.\\nI have given a general way to use it. The program takes the input of B and C\\nmatrix.\\n\\nSteps for Matrix Expo\\n1. Create vector F1 : which is the copy of B.\\n2. Create transpose matrix (Learn more about it on the internet)\\n3. Perform \\\\f$T^{n-1}\\\\f$ [transpose matrix to the power n-1]\\n4. Multiply with F to get the last matrix of size (1\\\\f$\\\\times\\\\f$k).\\n\\nThe first element of this matrix is the required result.\\n*/\\n\\n#include <iostream>\\n#include <vector>\\n\\nusing std::cin;\\nusing std::cout;\\nusing std::vector;\\n\\n/*! shorthand definition for `int64_t` */\\n#define ll int64_t\\n\\n/*! shorthand definition for `std::endl` */\\n#define endl std::endl\\n\\n/*! shorthand definition for `int64_t` */\\n#define pb push_back\\n#define MOD 1000000007\\n\\n/** global variable mat_size\\n * @todo @stepfencurryxiao add documetnation\\n */\\nll mat_size;\\n\\n/** global vector variables used in the ::ans function.\\n * @todo @stepfencurryxiao add documetnation\\n */\\nvector<ll> fib_b, fib_c;\\n\\n/** To multiply 2 matrices\\n * \\\\param [in] A matrix 1 of size (m\\\\f$\\\\times\\\\f$n)\\n * \\\\param [in] B \\\\p matrix 2 of size (p\\\\f$\\\\times\\\\f$q)\\\\n\\\\note \\\\f$p=n\\\\f$\\n * \\\\result matrix of dimension (m\\\\f$\\\\times\\\\f$q)\\n */\\nvector<vector<ll>> multiply(const vector<vector<ll>> &A,\\n                            const vector<vector<ll>> &B) {\\n    vector<vector<ll>> C(mat_size + 1, vector<ll>(mat_size + 1));\\n    for (ll i = 1; i <= mat_size; i++) {\\n        for (ll j = 1; j <= mat_size; j++) {\\n            for (ll z = 1; z <= mat_size; z++) {\\n                C[i][j] = (C[i][j] + (A[i][z] * B[z][j]) % MOD) % MOD;\\n            }\\n        }\\n    }\\n    return C;\\n}\\n\\n/** computing integer power of a matrix using recursive multiplication.\\n * @note A must be a square matrix for this algorithm.\\n * \\\\param [in] A base matrix\\n * \\\\param [in] p exponent\\n * \\\\return matrix of same dimension as A\\n */\\nvector<vector<ll>> power(const vector<vector<ll>> &A, ll p) {\\n    if (p == 1)\\n        return A;\\n    if (p % 2 == 1) {\\n        return multiply(A, power(A, p - 1));\\n    } else {\\n        vector<vector<ll>> X = power(A, p / 2);\\n        return multiply(X, X);\\n    }\\n}\\n\\n/*! Wrapper for Fibonacci\\n * \\\\param[in] n \\\\f$n^\\\\text{th}\\\\f$ Fibonacci number\\n * \\\\return \\\\f$n^\\\\text{th}\\\\f$ Fibonacci number\\n */\\nll ans(ll n) {\\n    if (n == 0)\\n        return 0;\\n    if (n <= mat_size)\\n        return fib_b[n - 1];\\n    // F1\\n    vector<ll> F1(mat_size + 1);\\n    for (ll i = 1; i <= mat_size; i++) F1[i] = fib_b[i - 1];\\n\\n    // Transpose matrix\\n    vector<vector<ll>> T(mat_size + 1, vector<ll>(mat_size + 1));\\n    for (ll i = 1; i <= mat_size; i++) {\\n        for (ll j = 1; j <= mat_size; j++) {\\n            if (i < mat_size) {\\n                if (j == i + 1)\\n                    T[i][j] = 1;\\n                else\\n                    T[i][j] = 0;\\n                continue;\\n            }\\n            T[i][j] = fib_c[mat_size - j];\\n        }\\n    }\\n    // T^n-1\\n    T = power(T, n - 1);\\n\\n    // T*F1\\n    ll res = 0;\\n    for (ll i = 1; i <= mat_size; i++) {\\n        res = (res + (T[1][i] * F1[i]) % MOD) % MOD;\\n    }\\n    return res;\\n}\\n\\n/** Main function */\\nint main() {\\n    cin.tie(0);\\n    cout.tie(0);\\n    ll t;\\n    cin >> t;\\n    ll i, j, x;\\n    while (t--) {\\n        cin >> mat_size;\\n        for (i = 0; i < mat_size; i++) {\\n            cin >> x;\\n            fib_b.pb(x);\\n        }\\n        for (i = 0; i < mat_size; i++) {\\n            cin >> x;\\n            fib_c.pb(x);\\n        }\\n        cin >> x;\\n        cout << ans(x) << endl;\\n        fib_b.clear();\\n        fib_c.clear();\\n    }\\n    return 0;\\n}\\n\"",
    "palindrome of number": "\"/**\\n * @file\\n * @brief Check if a number is\\n * [palindrome](https://en.wikipedia.org/wiki/Palindrome) or not.\\n *\\n * This program cheats by using the STL library's std::reverse function.\\n */\\n#include <algorithm>\\n#include <iostream>\\n\\n#ifdef _MSC_VER\\n// Required to compile std::toString function using MSVC\\n#include <string>\\n#else\\n#include <cstring>\\n#endif\\n\\n/** Main function */\\nint main() {\\n    int num;\\n    std::cout << \\\"Enter number = \\\";\\n    std::cin >> num;\\n\\n    std::string s1 = std::to_string(num);  // convert number to string\\n    std::string s2 = s1;\\n\\n    std::reverse(s1.begin(), s1.end());  // reverse the string\\n\\n    if (s1 == s2)  // check if reverse and original string are identical\\n        std::cout << \\\"true\\\";\\n    else\\n        std::cout << \\\"false\\\";\\n\\n    return 0;\\n}\\n\"",
    "paranthesis matching": "\"/**\\n * @file\\n * @brief Perform paranthesis matching. \\\\note Do not know the application of\\n * this, however.\\n * @note Implementation is C-type and does not utilize the C++ constructs\\n * @todo implement as a C++ class\\n */\\n#include <iostream>\\n#ifdef _MSC_VER\\n#include <string>  // Visual Studio C requires this include\\n#else\\n#include <cstring>\\n#endif\\n\\n/** check number */\\n#define MAX 100\\n\\n//! @{-------------- stack --------------\\n//! global stack\\nchar stack[MAX];\\n\\n//! pointer to track stack index\\nint stack_idx = -1;\\n\\n//! push byte to stack variable\\nvoid push(char ch) { stack[++stack_idx] = ch; }\\n\\n//! pop a byte out of stack variable\\nchar pop() { return stack[stack_idx--]; }\\n\\n//! @}-------------- end stack -----------\\n\\n/** return opening paranthesis corresponding to the close paranthesis\\n * @param[in] ch closed paranthesis character\\n */\\nchar opening(char ch) {\\n    switch (ch) {\\n    case '}':\\n        return '{';\\n    case ']':\\n        return '[';\\n    case ')':\\n        return '(';\\n    case '>':\\n        return '<';\\n    }\\n    return '\\\\0';\\n}\\n\\nint main() {\\n    std::string exp;\\n    int valid = 1, i = 0;\\n    std::cout << \\\"Enter The Expression : \\\";\\n    std::cin >> exp;\\n\\n    while (valid == 1 && i < exp.length()) {\\n        if (exp[i] == '(' || exp[i] == '{' || exp[i] == '[' || exp[i] == '<') {\\n            push(exp[i]);\\n        } else if (stack_idx >= 0 && stack[stack_idx] == opening(exp[i])) {\\n            pop();\\n        } else {\\n            valid = 0;\\n        }\\n        i++;\\n    }\\n\\n    // makes sure the stack is empty after processsing (above)\\n    if (valid == 1 && stack_idx == -1) {\\n        std::cout << \\\"\\\\nCorrect Expression\\\";\\n    } else {\\n        std::cout << \\\"\\\\nWrong Expression\\\";\\n    }\\n\\n    return 0;\\n}\\n\"",
    "pascal triangle": "\"/**\\n * @file\\n * @brief Pascal's triangle implementation\\n */\\n#ifdef _MSC_VER\\n#include <string>  // required for Visual C\\n#else\\n#include <cstring>\\n#endif\\n#include <iomanip>\\n#include <iostream>\\n\\n/**\\n * Print the triangle\\n * \\\\param [in] arr  2D-array containing Pascal numbers\\n * \\\\param [in] n    depth of Pascal triangle to print\\n */\\nvoid show_pascal(int **arr, int n) {\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j < n + i; ++j) {\\n            if (arr[i][j] == 0)\\n                std::cout << std::setw(4) << \\\" \\\";\\n            else\\n                std::cout << std::setw(4) << arr[i][j];\\n        }\\n        std::cout << std::endl;\\n    }\\n}\\n\\n/**\\n * Print the triangle\\n * \\\\param [in,out] arr  array containing Pascal numbers\\n * \\\\param [in] n    depth of Pascal triangle to print\\n * \\\\result arr pointer returned\\n */\\nint **pascal_triangle(int **arr, int n) {\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = n - i - 1; j < n + i; ++j) {\\n            if (j == n - i - 1 || j == n + i - 1)\\n                arr[i][j] = 1;  // The edge of the Pascal triangle goes in 1\\n            else\\n                arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j + 1];\\n        }\\n    }\\n\\n    return arr;\\n}\\n\\n/**\\n * main function\\n */\\nint main() {\\n    int n = 0;\\n\\n    std::cout << \\\"Set Pascal's Triangle Height\\\" << std::endl;\\n    std::cin >> n;\\n\\n    // memory allocation (Assign two-dimensional array to store Pascal triangle)\\n    int **arr = new int *[n];\\n    for (int i = 0; i < n; ++i) {\\n        arr[i] = new int[2 * n - 1];\\n        memset(arr[i], 0, sizeof(int) * (2 * n - 1));\\n    }\\n\\n    pascal_triangle(arr, n);\\n    show_pascal(arr, n);\\n\\n    // deallocation\\n    for (int i = 0; i < n; ++i) {\\n        delete[] arr[i];\\n    }\\n    delete[] arr;\\n\\n    return 0;\\n}\\n\"",
    "postfix evaluation": "\"/**\\n * @file\\n * @brief Evaluation of [Postfix Expression](https://en.wikipedia.org/wiki/Reverse_Polish_notation)\\n * @author [Darshana Sarma](https://github.com/Darshana-Sarma)\\n * @details\\n * Create a stack to store operands (or values).\\n * Scan the given expression and do following for every scanned element.\\n * If the element is a number, push it into the stack\\n * If the element is a operator, pop operands for the operator from stack.\\n * Evaluate the operator and push the result back to the stack\\n * When the expression is ended, the number in the stack is the final answer\\n */\\n#include <algorithm>  // for all_of\\n#include <array>      // for std::array\\n#include <cassert>    // for assert\\n#include <iostream>   // for io operations\\n#include <string>     // for stof\\n\\n/**\\n * @namespace others\\n * @brief Other algorithms\\n */\\nnamespace others {\\n/**\\n * @namespace postfix_expression\\n * @brief Functions for Postfix Expression algorithm\\n */\\nnamespace postfix_expression {\\n /**\\n * @brief Creates an array to be used as stack for storing values\\n */\\nclass Stack {\\n public:\\n    std::array<float, 20> stack{}; ///< Array which will be used to store numbers in the input\\n    int stackTop = -1;            ///< Represents the index of the last value added to array. -1 means array is empty\\n};\\n\\n/**\\n * @brief Pushing operand, also called the number in the array to the stack\\n * @param operand float value from the input array or evaluation\\n * @param stack stack containing numbers\\n * @returns none\\n */\\nvoid push(float operand, Stack *stack) {\\n    stack->stackTop++;\\n    stack->stack[stack->stackTop] = operand;\\n}\\n\\n/**\\n * @brief Popping operand, also called the number from the stack\\n * @param stack stack containing numbers\\n * @returns operand float on top of stack\\n */\\nfloat pop(Stack *stack) {\\n    float operand = stack->stack[stack->stackTop];\\n    stack->stackTop--;\\n    return operand;\\n}\\n\\n/**\\n * @brief Checks if scanned string is a number\\n * @param s scanned string\\n * @returns bool boolean value if string is number\\n */\\nbool is_number(const std::string &s) {\\n    return !s.empty() && std::all_of(s.begin(), s.end(), ::isdigit);\\n}\\n\\n/**\\n * @brief Evaluate answer using given last two operands from and operation\\n * @param a second last added operand which will be used for evaluation\\n * @param b last added operand which will be used for evaluation\\n * @param operation to be performed with respective floats\\n * @param stack containing numbers\\n * @returns none\\n */\\nvoid evaluate(float a, float b, const std::string &operation, Stack *stack) {\\n    float c = 0;\\n    const char *op = operation.c_str();\\n    switch (*op) {\\n        case '+':\\n            c = a + b; // Addition of numbers\\n            others::postfix_expression::push(c, stack);\\n            break;\\n\\n        case '-':\\n            c = a - b; // Subtraction of numbers\\n            others::postfix_expression::push(c, stack);\\n            break;\\n\\n        case '*':\\n            c = a * b; // Multiplication of numbers\\n            others::postfix_expression::push(c, stack);\\n            break;\\n\\n        case '/':\\n            c = a / b; // Division of numbers\\n            others::postfix_expression::push(c, stack);\\n            break;\\n\\n        default:\\n            std::cout << \\\"Operator not defined\\\\n\\\";\\n            break;\\n    }\\n}\\n\\n/**\\n * @brief Postfix Evaluation algorithm to compute the value from given input\\n * array\\n * @tparam N number of array size\\n * @param input Array of characters consisting of numbers and operations\\n * @returns stack[stackTop] returns the top value from the stack\\n */\\ntemplate <std::size_t N>\\nfloat postfix_evaluation(std::array<std::string, N> input) {\\n    Stack stack;\\n    int j = 0;\\n\\n    while (j < N) {\\n        std::string scan = input[j];\\n        if (is_number(scan)) {\\n            push(std::stof(scan), &stack);\\n\\n        } else {\\n            float op2 = pop(&stack);\\n            float op1 = pop(&stack);\\n\\n            evaluate(op1, op2, scan, &stack);\\n        }\\n        j++;\\n    }\\n\\n    std::cout << stack.stack[stack.stackTop] << \\\"\\\\n\\\";\\n\\n    return stack.stack[stack.stackTop];\\n}\\n}  // namespace postfix_expression\\n}  // namespace others\\n\\n\\n/**\\n * @brief Test function 1 with input array\\n * {'2', '3', '1', '*', '+', '9', '-'}\\n * @returns none\\n */\\nstatic void test_function_1() {\\n    std::array<std::string, 7> input = {\\\"2\\\", \\\"3\\\", \\\"1\\\", \\\"*\\\", \\\"+\\\", \\\"9\\\", \\\"-\\\"};\\n\\n    float answer = others::postfix_expression::postfix_evaluation(input);\\n\\n    assert(answer == -4);\\n}\\n\\n/**\\n * @brief Test function 2 with input array\\n * {'1', '2', '+', '2', '/', '5', '*', '7', '+'}\\n * @returns none\\n */\\nstatic void test_function_2() {\\n    std::array<std::string, 9> input = {\\\"100\\\", \\\"200\\\", \\\"+\\\", \\\"2\\\", \\\"/\\\",\\n                                        \\\"5\\\",   \\\"*\\\",   \\\"7\\\", \\\"+\\\"};\\n    float answer = others::postfix_expression::postfix_evaluation(input);\\n\\n    assert(answer == 757);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test_function_1();\\n    test_function_2();\\n\\n    std::cout << \\\"\\\\nTest implementations passed!\\\\n\\\";\\n\\n    return 0;\\n}\\n\"",
    "primality test": "\"/**\\n * @file\\n * @brief [Primality test](https://en.wikipedia.org/wiki/Primality_test)\\n * implementation.\\n *\\n * A simple and efficient implementation of a function to test if a number is\\n * prime, based on the fact that\\n * > Every Prime number, except 2 and 3, are of the form \\\\f$6k\\\\pm1\\\\f$ for\\n * > integer values of k.\\n * This gives a 3x speed improvement.\\n */\\n#include <iostream>\\n\\n/** Check if a number is prime\\n * \\\\param[in] number number to check\\n * \\\\returns true if prime else false\\n */\\nbool IsPrime(int number) {\\n    if (((!(number & 1)) && number != 2) || (number < 2) ||\\n        (number % 3 == 0 && number != 3))\\n        return false;\\n\\n    for (int k = 1; 36 * k * k - 12 * k < number; ++k) {\\n        if ((number % (6 * k + 1) == 0) || (number % (6 * k - 1) == 0))\\n            return false;\\n    }\\n    return true;\\n}\\n\\n/** main function */\\nint main() {\\n    // Main Function\\n    std::cout << \\\"Enter the value of n to check if Prime\\\\n\\\";\\n    int n;\\n    std::cin >> n;\\n    if (IsPrime(n))\\n        std::cout << n << \\\" is Prime\\\" << std::endl;\\n    else\\n        std::cout << n << \\\" is not Prime\\\" << std::endl;\\n\\n    return 0;\\n}\\n\"",
    "smallest circle": "\"/**\\n * @file\\n * @brief Get centre and radius of the\\n * [smallest circle](https://en.wikipedia.org/wiki/Smallest-circle_problem)\\n * that circumscribes given set of points.\\n *\\n * @see [other\\n * implementation](https://www.nayuki.io/page/smallest-enclosing-circle)\\n */\\n#include <cmath>\\n#include <iostream>\\n#include <vector>\\n\\n/** Define a point */\\nstruct Point {\\n    double x, /**< abscissa */\\n        y;    /**< ordinate */\\n\\n    /** construct a point\\n     * \\\\param [in] a absicca (default = 0.0)\\n     * \\\\param [in] b ordinate (default = 0.0)\\n     */\\n    explicit Point(double a = 0.f, double b = 0.f) {\\n        x = a;\\n        y = b;\\n    }\\n};\\n\\n/** Compute the Euclidian distance between two points \\\\f$A\\\\equiv(x_1,y_1)\\\\f$ and\\n * \\\\f$B\\\\equiv(x_2,y_2)\\\\f$ using the formula:\\n * \\\\f[d=\\\\sqrt{\\\\left(x_1-x_2\\\\right)^2+\\\\left(y_1-y_2\\\\right)^2}\\\\f]\\n *\\n * \\\\param [in] A point A\\n * \\\\param [in] B point B\\n * \\\\return ditance\\n */\\ndouble LenghtLine(const Point &A, const Point &B) {\\n    double dx = B.x - A.x;\\n    double dy = B.y - A.y;\\n    return std::sqrt((dx * dx) + (dy * dy));\\n}\\n\\n/**\\n * Compute the area of triangle formed by three points using [Heron's\\n * formula](https://en.wikipedia.org/wiki/Heron%27s_formula).\\n * If the lengths of the sides of the triangle are \\\\f$a,\\\\,b,\\\\,c\\\\f$ and\\n * \\\\f$s=\\\\displaystyle\\\\frac{a+b+c}{2}\\\\f$ is the semi-perimeter then the area is\\n * given by \\\\f[A=\\\\sqrt{s(s-a)(s-b)(s-c)}\\\\f]\\n * \\\\param [in] A vertex A\\n * \\\\param [in] B vertex B\\n * \\\\param [in] C vertex C\\n * \\\\returns area of triangle\\n */\\ndouble TriangleArea(const Point &A, const Point &B, const Point &C) {\\n    double a = LenghtLine(A, B);\\n    double b = LenghtLine(B, C);\\n    double c = LenghtLine(C, A);\\n    double p = (a + b + c) / 2;\\n    return std::sqrt(p * (p - a) * (p - b) * (p - c));\\n}\\n\\n/**\\n * Check if a set of points lie within given circle. This is true if the\\n * distance of all the points from the centre of the circle is less than the\\n * radius of the circle\\n * \\\\param [in] P set of points to check\\n * \\\\param [in] Center coordinates to centre of the circle\\n * \\\\param [in] R radius of the circle\\n * \\\\returns True if P lies on or within the circle\\n * \\\\returns False if P lies outside the circle\\n */\\nbool PointInCircle(const std::vector<Point> &P, const Point &Center, double R) {\\n    for (size_t i = 0; i < P.size(); i++) {\\n        if (LenghtLine(P[i], Center) > R)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n/**\\n * Find the centre and radius of a circle enclosing a set of points.\\\\n\\n * The function returns the radius of the circle and prints the coordinated of\\n * the centre of the circle.\\n * \\\\param [in] P vector of points\\n * \\\\returns radius of the circle\\n */\\ndouble circle(const std::vector<Point> &P) {\\n    double minR = INFINITY;\\n    double R;\\n    Point C;\\n    Point minC;\\n\\n    /* This code is invalid and does not give correct result for TEST 3 */\\n    // for each point in the list\\n    for (size_t i = 0; i < P.size() - 2; i++)\\n        // for every subsequent point in the list\\n        for (size_t j = i + 1; j < P.size(); j++)\\n            // for every subsequent point in the list\\n            for (size_t k = j + 1; k < P.size(); k++) {\\n                // here, we now have picked three points from the given set of\\n                // points that we can use\\n                // viz., P[i], P[j] and P[k]\\n                C.x = -0.5 * ((P[i].y * (P[j].x * P[j].x + P[j].y * P[j].y -\\n                                         P[k].x * P[k].x - P[k].y * P[k].y) +\\n                               P[j].y * (P[k].x * P[k].x + P[k].y * P[k].y -\\n                                         P[i].x * P[i].x - P[i].y * P[i].y) +\\n                               P[k].y * (P[i].x * P[i].x + P[i].y * P[i].y -\\n                                         P[j].x * P[j].x - P[j].y * P[j].y)) /\\n                              (P[i].x * (P[j].y - P[k].y) +\\n                               P[j].x * (P[k].y - P[i].y) +\\n                               P[k].x * (P[i].y - P[j].y)));\\n                C.y = 0.5 * ((P[i].x * (P[j].x * P[j].x + P[j].y * P[j].y -\\n                                        P[k].x * P[k].x - P[k].y * P[k].y) +\\n                              P[j].x * (P[k].x * P[k].x + P[k].y * P[k].y -\\n                                        P[i].x * P[i].x - P[i].y * P[i].y) +\\n                              P[k].x * (P[i].x * P[i].x + P[i].y * P[i].y -\\n                                        P[j].x * P[j].x - P[j].y * P[j].y)) /\\n                             (P[i].x * (P[j].y - P[k].y) +\\n                              P[j].x * (P[k].y - P[i].y) +\\n                              P[k].x * (P[i].y - P[j].y)));\\n                R = (LenghtLine(P[i], P[j]) * LenghtLine(P[j], P[k]) *\\n                     LenghtLine(P[k], P[i])) /\\n                    (4 * TriangleArea(P[i], P[j], P[k]));\\n                if (!PointInCircle(P, C, R)) {\\n                    continue;\\n                }\\n                if (R <= minR) {\\n                    minR = R;\\n                    minC = C;\\n                }\\n            }\\n\\n    // for each point in the list\\n    for (size_t i = 0; i < P.size() - 1; i++)\\n        // for every subsequent point in the list\\n        for (size_t j = i + 1; j < P.size(); j++) {\\n            // check for diameterically opposite points\\n            C.x = (P[i].x + P[j].x) / 2;\\n            C.y = (P[i].y + P[j].y) / 2;\\n            R = LenghtLine(C, P[i]);\\n            if (!PointInCircle(P, C, R)) {\\n                continue;\\n            }\\n            if (R <= minR) {\\n                minR = R;\\n                minC = C;\\n            }\\n        }\\n    std::cout << minC.x << \\\" \\\" << minC.y << std::endl;\\n    return minR;\\n}\\n\\n/** Test case: result should be:\\n * \\\\n Circle with\\n * \\\\n radius 3.318493136080724\\n * \\\\n centre at (3.0454545454545454, 1.3181818181818181)\\n */\\nvoid test() {\\n    std::vector<Point> Pv;\\n    Pv.push_back(Point(0, 0));\\n    Pv.push_back(Point(5, 4));\\n    Pv.push_back(Point(1, 3));\\n    Pv.push_back(Point(4, 1));\\n    Pv.push_back(Point(3, -2));\\n    std::cout << circle(Pv) << std::endl;\\n}\\n\\n/** Test case: result should be:\\n * \\\\n Circle with\\n * \\\\n radius 1.4142135623730951\\n * \\\\n centre at (1.0, 1.0)\\n */\\nvoid test2() {\\n    std::vector<Point> Pv;\\n    Pv.push_back(Point(0, 0));\\n    Pv.push_back(Point(0, 2));\\n    Pv.push_back(Point(2, 2));\\n    Pv.push_back(Point(2, 0));\\n    std::cout << circle(Pv) << std::endl;\\n}\\n\\n/** Test case: result should be:\\n * \\\\n Circle with\\n * \\\\n radius 1.821078397711709\\n * \\\\n centre at (2.142857142857143, 1.7857142857142856)\\n * @todo This test fails\\n */\\nvoid test3() {\\n    std::vector<Point> Pv;\\n    Pv.push_back(Point(0.5, 1));\\n    Pv.push_back(Point(3.5, 3));\\n    Pv.push_back(Point(2.5, 0));\\n    Pv.push_back(Point(2, 1.5));\\n    std::cout << circle(Pv) << std::endl;\\n}\\n\\n/** Main program */\\nint main() {\\n    test();\\n    std::cout << std::endl;\\n    test2();\\n    std::cout << std::endl;\\n    test3();\\n    return 0;\\n}\\n\"",
    "sparse matrix": "\"/** @file\\n * A sparse matrix is a matrix which has number of zeroes greater than\\n * \\\\f$\\\\frac{m\\\\times n}{2}\\\\f$, where m and n are the dimensions of the matrix.\\n */\\n\\n#include <iostream>\\n\\n/** main function */\\nint main() {\\n    int m, n;\\n    int counterZeros = 0;\\n\\n    std::cout << \\\"Enter dimensions of matrix (seperated with space): \\\";\\n    std::cin >> m;\\n    std::cin >> n;\\n\\n    int **a = new int *[m];\\n    for (int i = 0; i < m; i++) a[i] = new int[n];\\n\\n    std::cout << \\\"Enter matrix elements:\\\";\\n    std::cout << \\\"\\\\n\\\";\\n\\n    // reads the matrix from stdin\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            std::cout << \\\"element? \\\";\\n            std::cin >> a[i][j];\\n        }\\n    }\\n\\n    // counts the zero's\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (a[i][j] == 0)\\n                counterZeros++;  // Counting number of zeroes\\n        }\\n    }\\n\\n    // makes sure the matrix is a sparse matrix\\n    if (counterZeros > ((m * n) / 2))  // Checking for sparse matrix\\n        std::cout << \\\"Sparse matrix\\\";\\n    else\\n        std::cout << \\\"Not a sparse matrix\\\";\\n\\n    for (int i = 0; i < m; i++) delete[] a[i];\\n    delete[] a;\\n    return 0;\\n}\\n\"",
    "spiral print": "\"/**\\n * @file\\n * @brief Print the elements of a matrix traversing it spirally\\n */\\n#include <iostream>\\n\\n/** Arrange sequence of numbers from '1' in a matrix form\\n * \\\\param [out] a matrix to fill\\n * \\\\param [in] r number of rows\\n * \\\\param [in] c number of columns\\n */\\nvoid genArray(int **a, int r, int c) {\\n    int value = 1;\\n    for (int i = 0; i < r; i++) {\\n        for (int j = 0; j < c; j++) {\\n            a[i][j] = value;\\n            std::cout << a[i][j] << \\\" \\\";\\n            value++;\\n        }\\n        std::cout << std::endl;\\n    }\\n}\\n\\n/** Traverse the matrix spirally and print the sequence of elements\\n * \\\\param [in] a matrix to read from\\n * \\\\param [in] r number of rows\\n * \\\\param [in] c number of columns\\n */\\nvoid spiralPrint(int **a, int r, int c) {\\n    int startRow = 0, endRow = r - 1;\\n    int startCol = 0, endCol = c - 1;\\n    int cnt = 0;\\n\\n    while (startRow <= endRow && startCol <= endCol) {\\n        /// Print start row\\n        for (int i = startCol; i <= endCol; i++, cnt++) {\\n            std::cout << a[startRow][i] << \\\" \\\";\\n        }\\n        startRow++;\\n\\n        /// Print the end col\\n        for (int i = startRow; i <= endRow; i++, cnt++) {\\n            std::cout << a[i][endCol] << \\\" \\\";\\n        }\\n        endCol--;\\n\\n        /// Print the end row\\n        if (cnt == r * c) {\\n            break;\\n        }\\n\\n        for (int i = endCol; i >= startCol; i--, cnt++) {\\n            std::cout << a[endRow][i] << \\\" \\\";\\n        }\\n        endRow--;\\n\\n        /// Print the start Col\\n        if (cnt == r * c) {\\n            break;\\n        }\\n        for (int i = endRow; i >= startRow; i--, cnt++) {\\n            std::cout << a[i][startCol] << \\\" \\\";\\n        }\\n        startCol++;\\n    }\\n}\\n\\n/** main function */\\nint main() {\\n    int r, c;\\n    std::cin >> r >> c;\\n    int **a = new int *[r];\\n    for (int i = 0; i < r; i++) a[i] = new int[c];\\n\\n    genArray(a, r, c);\\n    spiralPrint(a, r, c);\\n\\n    for (int i = 0; i < r; i++) delete[] a[i];\\n    delete[] a;\\n    return 0;\\n}\\n\"",
    "stairs pattern": "\"/**\\n * @file\\n@brief This program is use to print the following pattern<pre>\\n   \\\\*\\\\*\\n   \\\\*\\\\*\\n  \\\\*\\\\*\\\\*\\\\*\\n  \\\\*\\\\*\\\\*\\\\*\\n \\\\*\\\\*\\\\*\\\\*\\\\*\\\\*\\n \\\\*\\\\*\\\\*\\\\*\\\\*\\\\*\\n\\\\*\\\\*\\\\*\\\\*\\\\*\\\\*\\\\*\\\\*\\n********</pre>\\nwhere number of pairs line is given by user\\n*/\\n#include <iostream>\\n\\n/** main function */\\nint main() {\\n    int l, st = 2, x, r, z, n, sp;\\n    std::cout << \\\"enter Index \\\";\\n    std::cin >> x;\\n    z = x;\\n    for (r = 1; r <= x; r++) {\\n        z = z - 1;\\n        for (n = 1; n <= 2; n++) {\\n            for (sp = 1; sp <= z; sp++) {\\n                std::cout << \\\" \\\";\\n            }\\n            for (l = 1; l <= st; l++) {\\n                std::cout << \\\"*\\\";\\n            }\\n            std::cout << std::endl;\\n        }\\n        st = st + 2;\\n    }\\n}\\n\"",
    "tower of hanoi": "\"/**\\n * @file\\n * @brief Solve the [Tower of\\n * Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi) problem.\\n */\\n#include <iostream>\\n\\n/**\\n * Define the state of tower\\n */\\nstruct tower {\\n    //! Values in the tower\\n    int values[10];\\n    //! top tower ID\\n    int top;\\n};\\n\\n/** Display the towers */\\nvoid show(const struct tower *const F, const struct tower *const T,\\n          const struct tower *const U) {\\n    std::cout << \\\"\\\\n\\\\n\\\\tF : \\\";\\n    for (int i = 0; i < F->top; i++) {\\n        std::cout << F->values[i] << \\\"\\\\t\\\";\\n    }\\n    std::cout << \\\"\\\\n\\\\tU : \\\";\\n    for (int i = 0; i < U->top; i++) {\\n        std::cout << U->values[i] << \\\"\\\\t\\\";\\n    }\\n    std::cout << \\\"\\\\n\\\\tT : \\\";\\n    for (int i = 0; i < T->top; i++) {\\n        std::cout << T->values[i] << \\\"\\\\t\\\";\\n    }\\n}\\n\\n/** Move one disc from one tower to another\\n * \\\\param [in,out] From tower to move disk *from*\\n * \\\\param [in,out] To  tower to move disk *to*\\n */\\nvoid mov(tower *From, tower *To) {\\n    --From->top;\\n    To->values[To->top] = From->values[From->top];\\n    ++To->top;\\n}\\n\\n/**\\n * Recursive algorithm to solve the puzzle\\n * \\\\param [in] n starting number of disks\\n * \\\\param [in,out] From  tower to move disks from\\n * \\\\param [in,out] Using temporary tower for the puzzle\\n * \\\\param [in,out] To  tower to move disk to\\n */\\nvoid TH(int n, tower *From, tower *Using, tower *To) {\\n    if (n == 1) {\\n        mov(From, To);\\n        show(From, To, Using);\\n    } else {\\n        TH(n - 1, From, To, Using);\\n        mov(From, To);\\n        show(From, To, Using);\\n        TH(n - 1, Using, From, To);\\n    }\\n}\\n\\n/** Main function */\\nint main() {\\n    struct tower F, U, T;\\n\\n    F.top = 0;\\n    U.top = 0;\\n    T.top = 0;\\n\\n    int no;\\n\\n    std::cout << \\\"\\\\nEnter number of discs : \\\";\\n    std::cin >> no;\\n\\n    for (int i = no; i > 0; i--) {\\n        F.values[F.top++] = i;\\n    }\\n\\n    show(&F, &T, &U);\\n    TH(no, &F, &U, &T);\\n\\n    return 0;\\n}\\n\"",
    "vector important functions": "\"/**\\n * @file\\n * @brief A C++ program to demonstrate working of std::sort(), std::reverse()\\n */\\n#include <algorithm>\\n#include <iostream>\\n#include <numeric>  // For accumulate operation\\n#include <vector>\\n\\n/** Main function */\\nint main() {\\n    // Initializing vector with array values\\n    int arr[] = {10, 20, 5, 23, 42, 15};\\n    int n = sizeof(arr) / sizeof(arr[0]);\\n    std::vector<int> vect(arr, arr + n);\\n\\n    std::cout << \\\"Vector is: \\\";\\n    for (int i = 0; i < n; i++) std::cout << vect[i] << \\\" \\\";\\n\\n    // Sorting the Vector in Ascending order\\n    std::sort(vect.begin(), vect.end());\\n\\n    std::cout << \\\"\\\\nVector after sorting is: \\\";\\n    for (int i = 0; i < n; i++) std::cout << vect[i] << \\\" \\\";\\n\\n    // Reversing the Vector\\n    std::reverse(vect.begin(), vect.end());\\n\\n    std::cout << \\\"\\\\nVector after reversing is: \\\";\\n    for (int i = 0; i < 6; i++) std::cout << vect[i] << \\\" \\\";\\n\\n    std::cout << \\\"\\\\nMaximum element of vector is: \\\";\\n    std::cout << *max_element(vect.begin(), vect.end());\\n\\n    std::cout << \\\"\\\\nMinimum element of vector is: \\\";\\n    std::cout << *min_element(vect.begin(), vect.end());\\n\\n    // Starting the summation from 0\\n    std::cout << \\\"\\\\nThe summation of vector elements is: \\\";\\n    std::cout << accumulate(vect.begin(), vect.end(), 0);\\n\\n    return 0;\\n}\\n\"",
    "addition rule": "\"/**\\n * @file\\n * @brief Addition rule of probabilities\\n */\\n#include <iostream>\\n\\n/**\\n * calculates the probability of the independent events A or B for independent\\n * events\\n * \\\\parama [in] A probability of event A\\n * \\\\parama [in] B probability of event B\\n * \\\\returns probability of A and B\\n */\\ndouble addition_rule_independent(double A, double B) {\\n    return (A + B) - (A * B);\\n}\\n\\n/** Calculates the probability of the events A or B for dependent events\\n * note that if value of B_given_A is unknown, use chainrule to find it\\n * \\\\parama [in] A probability of event A\\n * \\\\parama [in] B probability of event B\\n * \\\\parama [in] B_given_A probability of event B condition A\\n * \\\\returns probability of A and B\\n */\\ndouble addition_rule_dependent(double A, double B, double B_given_A) {\\n    return (A + B) - (A * B_given_A);\\n}\\n\\n/** Main function */\\nint main() {\\n    double A = 0.5;\\n    double B = 0.25;\\n    double B_given_A = 0.05;\\n\\n    std::cout << \\\"independent P(A or B) = \\\" << addition_rule_independent(A, B)\\n              << std::endl;\\n\\n    std::cout << \\\"dependent P(A or B) = \\\"\\n              << addition_rule_dependent(A, B, B_given_A) << std::endl;\\n\\n    return 0;\\n}\\n\"",
    "bayes theorem": "\"/**\\n * @file\\n * @brief [Bayes' theorem](https://en.wikipedia.org/wiki/Bayes%27_theorem)\\n *\\n * Bayes' theorem allows one to find \\\\f$P(A|B)\\\\f$ given \\\\f$P(B|A)\\\\f$ or\\n * \\\\f$P(B|A)\\\\f$ given \\\\f$P(A|B)\\\\f$ and \\\\f$P(A)\\\\f$ and \\\\f$P(B)\\\\f$.\\\\n\\n * Note that \\\\f$P(A|B)\\\\f$ is read 'The probability of A given that the event B\\n * has occured'.\\n */\\n#include <iostream>\\n\\n/** returns P(A|B)\\n */\\ndouble bayes_AgivenB(double BgivenA, double A, double B) {\\n    return (BgivenA * A) / B;\\n}\\n\\n/** returns P(B|A)\\n */\\ndouble bayes_BgivenA(double AgivenB, double A, double B) {\\n    return (AgivenB * B) / A;\\n}\\n\\n/** Main function\\n */\\nint main() {\\n    double A = 0.01;\\n    double B = 0.1;\\n    double BgivenA = 0.9;\\n    double AgivenB = bayes_AgivenB(BgivenA, A, B);\\n    std::cout << \\\"A given B = \\\" << AgivenB << std::endl;\\n    std::cout << \\\"B given A = \\\" << bayes_BgivenA(AgivenB, A, B) << std::endl;\\n    return 0;\\n}\\n\"",
    "binomial dist": "\"/**\\n * @file\\n * @brief [Binomial\\n * distribution](https://en.wikipedia.org/wiki/Binomial_distribution) example\\n *\\n * The binomial distribution models the number of\\n * successes in a sequence of n independent events\\n *\\n * Summary of variables used:\\n * * n : number of trials\\n * * p : probability of success\\n * * x : desired successes\\n */\\n#include <cmath>\\n#include <iostream>\\n\\n/** finds the expected value of a binomial distribution\\n * \\\\param [in] n\\n * \\\\param [in] p\\n * \\\\returns \\\\f$\\\\mu=np\\\\f$\\n */\\ndouble binomial_expected(double n, double p) { return n * p; }\\n\\n/** finds the variance of the binomial distribution\\n * \\\\param [in] n\\n * \\\\param [in] p\\n * \\\\returns \\\\f$\\\\sigma^2 = n\\\\cdot p\\\\cdot (1-p)\\\\f$\\n */\\ndouble binomial_variance(double n, double p) { return n * p * (1 - p); }\\n\\n/** finds the standard deviation of the binomial distribution\\n * \\\\param [in] n\\n * \\\\param [in] p\\n * \\\\returns \\\\f$\\\\sigma = \\\\sqrt{\\\\sigma^2} = \\\\sqrt{n\\\\cdot p\\\\cdot (1-p)}\\\\f$\\n */\\ndouble binomial_standard_deviation(double n, double p) {\\n    return std::sqrt(binomial_variance(n, p));\\n}\\n\\n/** Computes n choose r\\n * \\\\param [in] n\\n * \\\\param [in] r\\n * \\\\returns \\\\f$\\\\displaystyle {n\\\\choose r} =\\n * \\\\frac{n!}{r!(n-r)!} = \\\\frac{n\\\\times(n-1)\\\\times(n-2)\\\\times\\\\cdots(n-r)}{r!}\\n * \\\\f$\\n */\\ndouble nCr(double n, double r) {\\n    double numerator = n;\\n    double denominator = r;\\n\\n    for (int i = n - 1; i >= ((n - r) + 1); i--) {\\n        numerator *= i;\\n    }\\n\\n    for (int i = 1; i < r; i++) {\\n        denominator *= i;\\n    }\\n\\n    return numerator / denominator;\\n}\\n\\n/** calculates the probability of exactly x successes\\n * \\\\returns \\\\f$\\\\displaystyle P(n,p,x) = {n\\\\choose x} p^x (1-p)^{n-x}\\\\f$\\n */\\ndouble binomial_x_successes(double n, double p, double x) {\\n    return nCr(n, x) * std::pow(p, x) * std::pow(1 - p, n - x);\\n}\\n\\n/** calculates the probability of a result within a range (inclusive, inclusive)\\n * \\\\returns \\\\f$\\\\displaystyle \\\\left.P(n,p)\\\\right|_{x_0}^{x_1} =\\n * \\\\sum_{i=x_0}^{x_1} P(i)\\n * =\\\\sum_{i=x_0}^{x_1} {n\\\\choose i} p^i (1-p)^{n-i}\\\\f$\\n */\\ndouble binomial_range_successes(double n, double p, double lower_bound,\\n                                double upper_bound) {\\n    double probability = 0;\\n    for (int i = lower_bound; i <= upper_bound; i++) {\\n        probability += nCr(n, i) * std::pow(p, i) * std::pow(1 - p, n - i);\\n    }\\n    return probability;\\n}\\n\\n/** main function */\\nint main() {\\n    std::cout << \\\"expected value : \\\" << binomial_expected(100, 0.5)\\n              << std::endl;\\n\\n    std::cout << \\\"variance : \\\" << binomial_variance(100, 0.5) << std::endl;\\n\\n    std::cout << \\\"standard deviation : \\\"\\n              << binomial_standard_deviation(100, 0.5) << std::endl;\\n\\n    std::cout << \\\"exactly 30 successes : \\\" << binomial_x_successes(100, 0.5, 30)\\n              << std::endl;\\n\\n    std::cout << \\\"45 or more successes : \\\"\\n              << binomial_range_successes(100, 0.5, 45, 100) << std::endl;\\n\\n    return 0;\\n}\\n\"",
    "geometric dist": "\"/**\\n * @file\\n * @brief [Geometric\\n * Distribution](https://en.wikipedia.org/wiki/Geometric_distribution)\\n *\\n * @details\\n * The geometric distribution models the experiment of doing Bernoulli trials\\n * until a sucess was observed. There are two formulations of the geometric\\n * distribution: 1) The probability distribution of the number X of Bernoulli\\n * trials needed to get one success, supported on the set { 1, 2, 3, ... } 2)\\n * The probability distribution of the number Y = X − 1 of failures before the\\n * first success, supported on the set { 0, 1, 2, 3, ... } Here, the first one\\n * is implemented.\\n *\\n * Common variables used:\\n * p - The success probability\\n * k - The number of tries\\n *\\n * @author [Domenic Zingsheim](https://github.com/DerAndereDomenic)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <cmath>     /// for math functions\\n#include <cstdint>   /// for fixed size data types\\n#include <ctime>     /// for time to initialize rng\\n#include <iostream>  /// for std::cout\\n#include <limits>    /// for std::numeric_limits\\n#include <random>    /// for random numbers\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace probability\\n * @brief Probability algorithms\\n */\\nnamespace probability {\\n/**\\n * @namespace geometric_dist\\n * @brief Functions for the [Geometric\\n * Distribution](https://en.wikipedia.org/wiki/Geometric_distribution) algorithm\\n * implementation\\n */\\nnamespace geometric_dist {\\n/**\\n * @brief Returns a random number between [0,1]\\n * @returns A uniformly distributed random number between 0 (included) and 1\\n * (included)\\n */\\nfloat generate_uniform() {\\n    return static_cast<float>(rand()) / static_cast<float>(RAND_MAX);\\n}\\n\\n/**\\n * @brief A class to model the geometric distribution\\n */\\nclass geometric_distribution {\\n private:\\n    float p;  ///< The succes probability p\\n\\n public:\\n    /**\\n     * @brief Constructor for the geometric distribution\\n     * @param p The success probability\\n     */\\n    explicit geometric_distribution(const float& p) : p(p) {}\\n\\n    /**\\n     * @brief The expected value of a geometrically distributed random variable\\n     * X\\n     * @returns E[X] = 1/p\\n     */\\n    float expected_value() const { return 1.0f / p; }\\n\\n    /**\\n     * @brief The variance of a geometrically distributed random variable X\\n     * @returns V[X] = (1 - p) / p^2\\n     */\\n    float variance() const { return (1.0f - p) / (p * p); }\\n\\n    /**\\n     * @brief The standard deviation of a geometrically distributed random\\n     * variable X\\n     * @returns \\\\sigma = \\\\sqrt{V[X]}\\n     */\\n    float standard_deviation() const { return std::sqrt(variance()); }\\n\\n    /**\\n     * @brief The probability density function\\n     * @details As we use the first definition of the geometric series (1),\\n     * we are doing k - 1 failed trials and the k-th trial is a success.\\n     * @param k The number of trials to observe the first success in [1,\\\\infty)\\n     * @returns A number between [0,1] according to p * (1-p)^{k-1}\\n     */\\n    float probability_density(const uint32_t& k) const {\\n        return std::pow((1.0f - p), static_cast<float>(k - 1)) * p;\\n    }\\n\\n    /**\\n     * @brief The cumulative distribution function\\n     * @details The sum of all probabilities up to (and including) k trials.\\n     * Basically CDF(k) = P(x <= k)\\n     * @param k The number of trials in [1,\\\\infty)\\n     * @returns The probability to have success within k trials\\n     */\\n    float cumulative_distribution(const uint32_t& k) const {\\n        return 1.0f - std::pow((1.0f - p), static_cast<float>(k));\\n    }\\n\\n    /**\\n     * @brief The inverse cumulative distribution function\\n     * @details This functions answers the question: Up to how many trials are\\n     * needed to have success with a probability of cdf? The exact floating\\n     * point value is reported.\\n     * @param cdf The probability in [0,1]\\n     * @returns The number of (exact) trials.\\n     */\\n    float inverse_cumulative_distribution(const float& cdf) const {\\n        return std::log(1.0f - cdf) / std::log(1.0f - p);\\n    }\\n\\n    /**\\n     * @brief Generates a (discrete) sample according to the geometrical\\n     * distribution\\n     * @returns A geometrically distributed number in [1,\\\\infty)\\n     */\\n    uint32_t draw_sample() const {\\n        float uniform_sample = generate_uniform();\\n        return static_cast<uint32_t>(\\n                   inverse_cumulative_distribution(uniform_sample)) +\\n               1;\\n    }\\n\\n    /**\\n     * @brief This function computes the probability to have success in a given\\n     * range of tries\\n     * @details Computes P(min_tries <= x <= max_tries).\\n     * Can be used to calculate P(x >= min_tries) by not passing a second\\n     * argument. Can be used to calculate P(x <= max_tries) by passing 1 as the\\n     * first argument\\n     * @param min_tries The minimum number of tries in [1,\\\\infty) (inclusive)\\n     * @param max_tries The maximum number of tries in [min_tries, \\\\infty)\\n     * (inclusive)\\n     * @returns The probability of having success within a range of tries\\n     * [min_tries, max_tries]\\n     */\\n    float range_tries(const uint32_t& min_tries = 1,\\n                      const uint32_t& max_tries =\\n                          std::numeric_limits<uint32_t>::max()) const {\\n        float cdf_lower = cumulative_distribution(min_tries - 1);\\n        float cdf_upper = max_tries == std::numeric_limits<uint32_t>::max()\\n                              ? 1.0f\\n                              : cumulative_distribution(max_tries);\\n        return cdf_upper - cdf_lower;\\n    }\\n};\\n}  // namespace geometric_dist\\n}  // namespace probability\\n\\n/**\\n * @brief Tests the sampling method of the geometric distribution\\n * @details Draws 1000000 random samples and estimates mean and variance\\n * These should be close to the expected value and variance of the given\\n * distribution to pass.\\n * @param dist The distribution to test\\n */\\nvoid sample_test(\\n    const probability::geometric_dist::geometric_distribution& dist) {\\n    uint32_t n_tries = 1000000;\\n    std::vector<float> tries;\\n    tries.resize(n_tries);\\n\\n    float mean = 0.0f;\\n    for (uint32_t i = 0; i < n_tries; ++i) {\\n        tries[i] = static_cast<float>(dist.draw_sample());\\n        mean += tries[i];\\n    }\\n\\n    mean /= static_cast<float>(n_tries);\\n\\n    float var = 0.0f;\\n    for (uint32_t i = 0; i < n_tries; ++i) {\\n        var += (tries[i] - mean) * (tries[i] - mean);\\n    }\\n\\n    // Unbiased estimate of variance\\n    var /= static_cast<float>(n_tries - 1);\\n\\n    std::cout << \\\"This value should be near \\\" << dist.expected_value() << \\\": \\\"\\n              << mean << std::endl;\\n    std::cout << \\\"This value should be near \\\" << dist.variance() << \\\": \\\" << var\\n              << std::endl;\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    probability::geometric_dist::geometric_distribution dist(0.3);\\n\\n    const float threshold = 1e-3f;\\n\\n    std::cout << \\\"Starting tests for p = 0.3...\\\" << std::endl;\\n    assert(std::abs(dist.expected_value() - 3.33333333f) < threshold);\\n    assert(std::abs(dist.variance() - 7.77777777f) < threshold);\\n    assert(std::abs(dist.standard_deviation() - 2.788866755) < threshold);\\n    assert(std::abs(dist.probability_density(5) - 0.07203) < threshold);\\n    assert(std::abs(dist.cumulative_distribution(6) - 0.882351) < threshold);\\n    assert(std::abs(dist.inverse_cumulative_distribution(\\n                        dist.cumulative_distribution(8)) -\\n                    8) < threshold);\\n    assert(std::abs(dist.range_tries() - 1.0f) < threshold);\\n    assert(std::abs(dist.range_tries(3) - 0.49f) < threshold);\\n    assert(std::abs(dist.range_tries(5, 11) - 0.2203267f) < threshold);\\n    std::cout << \\\"All tests passed\\\" << std::endl;\\n    sample_test(dist);\\n\\n    dist = probability::geometric_dist::geometric_distribution(0.5f);\\n\\n    std::cout << \\\"Starting tests for p = 0.5...\\\" << std::endl;\\n    assert(std::abs(dist.expected_value() - 2.0f) < threshold);\\n    assert(std::abs(dist.variance() - 2.0f) < threshold);\\n    assert(std::abs(dist.standard_deviation() - 1.4142135f) < threshold);\\n    assert(std::abs(dist.probability_density(5) - 0.03125) < threshold);\\n    assert(std::abs(dist.cumulative_distribution(6) - 0.984375) < threshold);\\n    assert(std::abs(dist.inverse_cumulative_distribution(\\n                        dist.cumulative_distribution(8)) -\\n                    8) < threshold);\\n    assert(std::abs(dist.range_tries() - 1.0f) < threshold);\\n    assert(std::abs(dist.range_tries(3) - 0.25f) < threshold);\\n    assert(std::abs(dist.range_tries(5, 11) - 0.062011f) < threshold);\\n    std::cout << \\\"All tests passed\\\" << std::endl;\\n    sample_test(dist);\\n\\n    dist = probability::geometric_dist::geometric_distribution(0.8f);\\n\\n    std::cout << \\\"Starting tests for p = 0.8...\\\" << std::endl;\\n    assert(std::abs(dist.expected_value() - 1.25f) < threshold);\\n    assert(std::abs(dist.variance() - 0.3125f) < threshold);\\n    assert(std::abs(dist.standard_deviation() - 0.559016f) < threshold);\\n    assert(std::abs(dist.probability_density(5) - 0.00128) < threshold);\\n    assert(std::abs(dist.cumulative_distribution(6) - 0.999936) < threshold);\\n    assert(std::abs(dist.inverse_cumulative_distribution(\\n                        dist.cumulative_distribution(8)) -\\n                    8) < threshold);\\n    assert(std::abs(dist.range_tries() - 1.0f) < threshold);\\n    assert(std::abs(dist.range_tries(3) - 0.04f) < threshold);\\n    assert(std::abs(dist.range_tries(5, 11) - 0.00159997f) < threshold);\\n    std::cout << \\\"All tests have successfully passed!\\\" << std::endl;\\n    sample_test(dist);\\n}\\n\\n/**\\n * @brief Main function\\n * @return 0 on exit\\n */\\nint main() {\\n    srand(time(nullptr));\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "poisson dist": "\"/**\\n * @file\\n * @brief [Poisson\\n * statistics](https://en.wikipedia.org/wiki/Poisson_distribution)\\n *\\n * The Poisson distribution counts how many\\n * events occur over a set time interval.\\n */\\n#include <cmath>\\n#include <iostream>\\n\\n/**\\n * poisson rate:\\\\n\\n * calculate the events per unit time\\\\n\\n * e.g 5 dollars every 2 mins = 5 / 2 = 2.5\\n */\\ndouble poisson_rate(double events, double timeframe) {\\n    return events / timeframe;\\n}\\n\\n/**\\n *  calculate the expected value over a time\\n * e.g rate of 2.5 over 10 mins = 2.5 x 10 = 25\\n */\\ndouble poisson_expected(double rate, double time) { return rate * time; }\\n\\n/**\\n * Compute factorial of a given number\\n */\\ndouble fact(double x) {\\n    double x_fact = x;\\n    for (int i = x - 1; i > 0; i--) {\\n        x_fact *= i;\\n    }\\n\\n    if (x_fact <= 0) {\\n        x_fact = 1;\\n    }\\n    return x_fact;\\n}\\n\\n/**\\n * Find the probability of x successes in a Poisson dist.\\n * \\\\f[p(\\\\mu,x) = \\\\frac{\\\\mu^x e^{-\\\\mu}}{x!}\\\\f]\\n */\\ndouble poisson_x_successes(double expected, double x) {\\n    return (std::pow(expected, x) * std::exp(-expected)) / fact(x);\\n}\\n\\n/**\\n * probability of a success in range for Poisson dist (inclusive, inclusive)\\n * \\\\f[P = \\\\sum_i p(\\\\mu,i)\\\\f]\\n */\\ndouble poisson_range_successes(double expected, double lower, double upper) {\\n    double probability = 0;\\n    for (int i = lower; i <= upper; i++) {\\n        probability += poisson_x_successes(expected, i);\\n    }\\n    return probability;\\n}\\n\\n/**\\n * main function\\n */\\nint main() {\\n    double rate, expected;\\n    rate = poisson_rate(3, 1);\\n    std::cout << \\\"Poisson rate : \\\" << rate << std::endl;\\n\\n    expected = poisson_expected(rate, 2);\\n    std::cout << \\\"Poisson expected : \\\" << expected << std::endl;\\n\\n    std::cout << \\\"Poisson 0 successes : \\\" << poisson_x_successes(expected, 0)\\n              << std::endl;\\n    std::cout << \\\"Poisson 0-8 successes : \\\"\\n              << poisson_range_successes(expected, 0, 8) << std::endl;\\n\\n    return 0;\\n}\\n\"",
    "windowed median": "\"/**\\n * @file\\n * @brief An implementation of a median calculation of a sliding window along a\\n * data stream\\n *\\n * @details\\n * Given a stream of integers, the algorithm calculates the median of a fixed\\n * size window at the back of the stream. The leading time complexity of this\\n * algorithm is O(log(N), and it is inspired by the known algorithm to [find\\n * median from (infinite) data\\n * stream](https://www.tutorialcup.com/interview/algorithm/find-median-from-data-stream.htm),\\n * with the proper modifications to account for the finite window size for which\\n * the median is requested\\n *\\n * ### Algorithm\\n * The sliding window is managed by a list, which guarantees O(1) for both\\n * pushing and popping. Each new value is pushed to the window back, while a\\n * value from the front of the window is popped. In addition, the algorithm\\n * manages a multi-value binary search tree (BST), implemented by std::multiset.\\n * For each new value that is inserted into the window, it is also inserted to\\n * the BST. When a value is popped from the window, it is also erased from the\\n * BST. Both insertion and erasion to/from the BST are O(logN) in time, with N\\n * the size of the window. Finally, the algorithm keeps a pointer to the root of\\n * the BST, and updates its position whenever values are inserted or erased\\n * to/from BST. The root of the tree is the median! Hence, median retrieval is\\n * always O(1)\\n *\\n * Time complexity: O(logN). Space complexity: O(N). N - size of window\\n * @author [Yaniv Hollander](https://github.com/YanivHollander)\\n */\\n#include <cassert>  /// for assert\\n#include <cstdlib>  /// for std::rand - needed in testing\\n#include <ctime>    /// for std::time - needed in testing\\n#include <list>     /// for std::list - used to manage sliding window\\n#include <set>  /// for std::multiset - used to manage multi-value sorted sliding window values\\n#include <vector>  /// for std::vector - needed in testing\\n\\n/**\\n * @namespace probability\\n * @brief Probability algorithms\\n */\\nnamespace probability {\\n/**\\n * @namespace windowed_median\\n * @brief Functions for the Windowed Median algorithm implementation\\n */\\nnamespace windowed_median {\\nusing Window = std::list<int>;\\nusing size_type = Window::size_type;\\n\\n/**\\n * @class WindowedMedian\\n * @brief A class to calculate the median of a leading sliding window at the\\n * back of a stream of integer values.\\n */\\nclass WindowedMedian {\\n    const size_type _windowSize;  ///< sliding window size\\n    Window _window;  ///< a sliding window of values along the stream\\n    std::multiset<int> _sortedValues;  ///< a DS to represent a balanced\\n                                       /// multi-value binary search tree (BST)\\n    std::multiset<int>::const_iterator\\n        _itMedian;  ///< an iterator that points to the root of the multi-value\\n                    /// BST\\n\\n    /**\\n     * @brief Inserts a value to a sorted multi-value BST\\n     * @param value Value to insert\\n     */\\n    void insertToSorted(int value) {\\n        _sortedValues.insert(value);  /// Insert value to BST - O(logN)\\n        const auto sz = _sortedValues.size();\\n        if (sz == 1) {  /// For the first value, set median iterator to BST root\\n            _itMedian = _sortedValues.begin();\\n            return;\\n        }\\n\\n        /// If new value goes to left tree branch, and number of elements is\\n        /// even, the new median in the balanced tree is the left child of the\\n        /// median before the insertion\\n        if (value < *_itMedian && sz % 2 == 0) {\\n            --_itMedian;  // O(1) - traversing one step to the left child\\n        }\\n\\n        /// However, if the new value goes to the right branch, the previous\\n        /// median's right child is the new median in the balanced tree\\n        else if (value >= *_itMedian && sz % 2 != 0) {\\n            ++_itMedian;  /// O(1) - traversing one step to the right child\\n        }\\n    }\\n\\n    /**\\n     * @brief Erases a value from a sorted multi-value BST\\n     * @param value Value to insert\\n     */\\n    void eraseFromSorted(int value) {\\n        const auto sz = _sortedValues.size();\\n\\n        /// If the erased value is on the left branch or the median itself and\\n        /// the number of elements is even, the new median will be the right\\n        /// child of the current one\\n        if (value <= *_itMedian && sz % 2 == 0) {\\n            ++_itMedian;  /// O(1) - traversing one step to the right child\\n        }\\n\\n        /// However, if the erased value is on the right branch or the median\\n        /// itself, and the number of elements is odd, the new median will be\\n        /// the left child of the current one\\n        else if (value >= *_itMedian && sz % 2 != 0) {\\n            --_itMedian;  // O(1) - traversing one step to the left child\\n        }\\n\\n        /// Find the (first) position of the value we want to erase, and erase\\n        /// it\\n        const auto it = _sortedValues.find(value);  // O(logN)\\n        _sortedValues.erase(it);                    // O(logN)\\n    }\\n\\n public:\\n    /**\\n     * @brief Constructs a WindowedMedian object\\n     * @param windowSize Sliding window size\\n     */\\n    explicit WindowedMedian(size_type windowSize) : _windowSize(windowSize){};\\n\\n    /**\\n     * @brief Insert a new value to the stream\\n     * @param value New value to insert\\n     */\\n    void insert(int value) {\\n        /// Push new value to the back of the sliding window - O(1)\\n        _window.push_back(value);\\n        insertToSorted(value);  // Insert value to the multi-value BST - O(logN)\\n        if (_window.size() > _windowSize) {  /// If exceeding size of window,\\n                                             /// pop from its left side\\n            eraseFromSorted(\\n                _window.front());  /// Erase from the multi-value BST\\n                                   /// the window left side value\\n            _window.pop_front();   /// Pop the left side value from the window -\\n                                   /// O(1)\\n        }\\n    }\\n\\n    /**\\n     * @brief Gets the median of the values in the sliding window\\n     * @return Median of sliding window. For even window size return the average\\n     * between the two values in the middle\\n     */\\n    float getMedian() const {\\n        if (_sortedValues.size() % 2 != 0) {\\n            return *_itMedian;  // O(1)\\n        }\\n        return 0.5f * *_itMedian + 0.5f * *next(_itMedian);  /// O(1)\\n    }\\n\\n    /**\\n     * @brief A naive and inefficient method to obtain the median of the sliding\\n     * window. Used for testing!\\n     * @return Median of sliding window. For even window size return the average\\n     * between the two values in the middle\\n     */\\n    float getMedianNaive() const {\\n        auto window = _window;\\n        window.sort();  /// Sort window - O(NlogN)\\n        auto median =\\n            *next(window.begin(),\\n                  window.size() / 2);  /// Find value in the middle - O(N)\\n        if (window.size() % 2 != 0) {\\n            return median;\\n        }\\n        return 0.5f * median +\\n               0.5f * *next(window.begin(), window.size() / 2 - 1);  /// O(N)\\n    }\\n};\\n}  // namespace windowed_median\\n}  // namespace probability\\n\\n/**\\n * @brief Self-test implementations\\n * @param vals Stream of values\\n * @param windowSize Size of sliding window\\n */\\nstatic void test(const std::vector<int> &vals, int windowSize) {\\n    probability::windowed_median::WindowedMedian windowedMedian(windowSize);\\n    for (const auto val : vals) {\\n        windowedMedian.insert(val);\\n\\n        /// Comparing medians: efficient function vs. Naive one\\n        assert(windowedMedian.getMedian() == windowedMedian.getMedianNaive());\\n    }\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc command line argument count (ignored)\\n * @param argv command line array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, const char *argv[]) {\\n    /// A few fixed test cases\\n    test({1, 2, 3, 4, 5, 6, 7, 8, 9},\\n         3);  /// Array of sorted values; odd window size\\n    test({9, 8, 7, 6, 5, 4, 3, 2, 1},\\n         3);  /// Array of sorted values - decreasing; odd window size\\n    test({9, 8, 7, 6, 5, 4, 5, 6}, 4);     /// Even window size\\n    test({3, 3, 3, 3, 3, 3, 3, 3, 3}, 3);  /// Array with repeating values\\n    test({3, 3, 3, 3, 7, 3, 3, 3, 3}, 3);  /// Array with same values except one\\n    test({4, 3, 3, -5, -5, 1, 3, 4, 5},\\n         5);  /// Array that includes repeating values including negatives\\n\\n    /// Array with large values - sum of few pairs exceeds MAX_INT. Window size\\n    /// is even - testing calculation of average median between two middle\\n    /// values\\n    test({470211272, 101027544, 1457850878, 1458777923, 2007237709, 823564440,\\n          1115438165, 1784484492, 74243042, 114807987},\\n         6);\\n\\n    /// Random test cases\\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\\n    std::vector<int> vals;\\n    for (int i = 8; i < 100; i++) {\\n        const auto n =\\n            1 + std::rand() /\\n                    ((RAND_MAX + 5u) / 20);  /// Array size in the range [5, 20]\\n        auto windowSize =\\n            1 + std::rand() / ((RAND_MAX + 3u) /\\n                               10);  /// Window size in the range [3, 10]\\n        vals.clear();\\n        vals.reserve(n);\\n        for (int i = 0; i < n; i++) {\\n            vals.push_back(\\n                rand() - RAND_MAX);  /// Random array values (positive/negative)\\n        }\\n        test(vals, windowSize);  /// Testing randomized test\\n    }\\n    return 0;\\n}\\n\"",
    "fenwick tree": "\"/**\\n * @file\\n * @brief Fenwick tree\\n *\\n * A Fenwick tree or binary indexed tree is a data structure\\n * that can efficiently update elements and calculate\\n * prefix sums in a table of numbers.\\n */\\n#include <cassert>\\n#include <iostream>\\n#include <vector>\\n\\n/**\\n * n --> No. of elements present in input array.\\n * bit[0..n] --> Array that represents Binary Indexed Tree.\\n */\\nclass FenwickTree {\\n    int n;\\n    std::vector<int> bit;\\n\\n    /** Returns the highest power of two which is not more than x */\\n    inline int offset(int x) { return (x & (-x)); }\\n\\n public:\\n    /** Constructor\\n     * \\\\param[in] arr --> Input array for which prefix sum is evaluated.\\n     */\\n    explicit FenwickTree(const std::vector<int>& arr) {\\n        n = arr.size();\\n        bit.assign(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            update(i, arr[i]);\\n        }\\n    }\\n\\n    /** Constructor\\n     * \\\\param[in] x --> Size of array that represents Binary Indexed Tree.\\n     */\\n    explicit FenwickTree(int x) {\\n        n = x;\\n        bit.assign(n + 1, 0);\\n    }\\n\\n    /** Add val at id */\\n    void update(int id, int val) {\\n        id++;\\n        while (id <= n) {\\n            bit[id] += val;\\n            id += offset(id);\\n        }\\n    }\\n\\n    /** Get prefix sum upto id */\\n    int sum(int id) {\\n        id++;\\n        int res = 0;\\n        while (id > 0) {\\n            res += bit[id];\\n            id -= offset(id);\\n        }\\n        return res;\\n    }\\n\\n    /** Returns the prefix sum in range from l to r */\\n    int sum_range(int l, int r) { return sum(r) - sum(l - 1); }\\n};\\n\\n/** Main function */\\nint main() {\\n    int n = 5;\\n    std::vector<int> arr = {1, 2, 3, 4, 5};\\n    FenwickTree fenwick_tree(arr);\\n\\n    assert(fenwick_tree.sum_range(0, 0) == 1);\\n    assert(fenwick_tree.sum_range(0, 1) == 3);\\n    assert(fenwick_tree.sum_range(0, 2) == 6);\\n    fenwick_tree.update(0, 6);\\n    assert(fenwick_tree.sum_range(0, 0) == 6);\\n    assert(fenwick_tree.sum_range(0, 1) == 8);\\n    assert(fenwick_tree.sum_range(0, 2) == 11);\\n    return 0;\\n}\\n\"",
    "heavy light decomposition": "\"/**\\n * @file\\n * @brief [Heavy Light\\n * Decomposition](https://en.wikipedia.org/wiki/Heavy_path_decomposition)\\n * implementation\\n * @author [Aniruthan R](https://github.com/aneee004)\\n *\\n * @details\\n * Heavy-Light Decomposition is a technique on trees, that supports the\\n * following:\\n * 1. Update node s, with a value v\\n * 2. Return the (sum) of all node values on the simple path from a to b\\n * (sum) can also be replced with XOR, OR, AND, min, or max\\n *\\n * The update is done in O(log n) time, and\\n * the query is done in O(log^2 n) time with HLD\\n * where, n is the number of nodes\\n *\\n * The template type is the data type of the value stored in the nodes.\\n * If a non-primitive data-type is used as a template,\\n * the coressponding operators must be overloaded.\\n *\\n * An HLD object can only be created with a constant number of nodes, and\\n * it cannot be changed later. Creaty an empty instance is not supported.\\n *\\n * To start answering updates and queries,\\n * 1. Create an instance of HLD<X> object (obj), with the required data type.\\n * 2. Read in the edge/parent information and update it with obj.add_edge().\\n * Note: The edges addes must be 0 indexed.\\n * 3. Create a vector with initial node values, and call set_node_val() with it.\\n * 4. Call obj.init() to populate the required information for supporting\\n * operations.\\n * 5. Call obj.update(node, new_val), to update the value at index 'node' to the\\n * new value. Note: node must be 0 indexed\\n * 6. Call obj.query(a, b) to get the (sum) of node values in the simple path\\n * from a to b. Note: a and b, must be 0 indexed.\\n *\\n * Sample I/O at the bottom.\\n * @todo Support edge weight queries, by storing the edge weight value in it's\\n * child algorithm verified by testing in CSES path queries:\\n * https://cses.fi/problemset/task/1138\\n */\\n\\n#include <algorithm>\\n#include <cassert>\\n#include <cmath>\\n#include <cstring>\\n#include <iostream>\\n#include <list>\\n#include <numeric>\\n#include <string>\\n#include <vector>\\n\\n/**\\n * @namespace range_queries\\n * @brief Algorithms and Data Structures that support range queries and updates.\\n */\\nnamespace range_queries {\\n/**\\n * @namespace heavy_light_decomposition\\n * @brief Heavy light decomposition algorithm\\n */\\nnamespace heavy_light_decomposition {\\n/**\\n * @brief A Basic Tree, which supports binary lifting\\n * @tparam the data type of the values stored in the tree nodes\\n * @details Deleting the default constructor\\n * An instance can only be created with the number of nodes\\n * Defaults:\\n * t_node indexing are zero based\\n * t_root is 0\\n * depth of root_node is 0\\n * Supports:\\n * lift :- lift a node k units up the tree\\n * kth_ancestor :- returns the kth ancestor\\n * lca :- returns the least common ancestor\\n */\\ntemplate <typename X> class Tree {\\n  //\\n\\nprivate:\\n  std::vector<std::list<int>>\\n      t_adj;         ///< an adjacency list to stores the tree edges\\n  const int t_nodes, ///< number of nodes\\n      t_maxlift;     ///< maximum possible height of the tree\\n  std::vector<std::vector<int>>\\n      t_par;                ///< a matrix to store every node's 2^kth parent\\n  std::vector<int> t_depth, ///< a vector to store the depth of a node,\\n      t_size; ///< a vector to store the subtree size rooted at node\\n\\n  int t_root;           ///< the root of the tree\\n  std::vector<X> t_val; ///< values of nodes\\n  template <typename T> friend class HLD;\\n\\n  /**\\n   * @brief Utility function to compute sub-tree sizes\\n   * @param u current dfs node\\n   * @param p the parent of node @param u\\n   * @returns void\\n   */\\n  void dfs_size(int u, int p = -1) {\\n    for (const int &v : t_adj[u]) {\\n      if (v ^ p) {\\n        dfs_size(v, u);\\n        t_size[u] += t_size[v];\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @brief Utility function to populate the t_par vector\\n   * @param u current dfs node\\n   * @param p the parent of node u\\n   * @returns void\\n   */\\n  void dfs_lca(int u, int p = -1) {\\n    t_par[u][0] = p;\\n    if (p != -1) {\\n      t_depth[u] = 1 + t_depth[p];\\n    }\\n    for (int k = 1; k < t_maxlift; k++) {\\n      if (t_par[u][k - 1] != -1) {\\n        t_par[u][k] = t_par[t_par[u][k - 1]][k - 1];\\n      }\\n    }\\n\\n    for (const int &v : t_adj[u]) {\\n      if (v ^ p) {\\n        dfs_lca(v, u);\\n      }\\n    }\\n  }\\n\\npublic:\\n  /**\\n   * @brief Class parameterized constructor, resizes the and initializes the\\n   * data members\\n   * @param nodes the total number of nodes in the tree\\n   */\\n  explicit Tree(int nodes)\\n      : t_nodes(nodes), t_maxlift(static_cast<int>(floor(log2(nodes))) + 1) {\\n    /* Initialize and resize all the vectors */\\n    t_root = 0; /* Default */\\n    t_adj.resize(t_nodes);\\n    t_par.assign(t_nodes, std::vector<int>(t_maxlift, -1));\\n    t_depth.assign(t_nodes, 0);\\n    t_size.assign(t_nodes, 1);\\n    t_val.resize(t_nodes);\\n  }\\n\\n  /**\\n   * @brief Adds an undirected edge from node u to node v in the tree\\n   * @param u the node where the edge is from\\n   * @param v the node where the edge is to\\n   * @returns void\\n   */\\n  void add_edge(const int u, const int v) {\\n    t_adj[u].push_back(v);\\n    t_adj[v].push_back(u);\\n  }\\n\\n  /**\\n   * @brief Set the root for the tree\\n   * @param new_root the new root\\n   * @returns void\\n   */\\n  void change_root(int new_root) { t_root = new_root; }\\n\\n  /**\\n   * @brief Set the values for all the nodes\\n   * @param node_val a vector of size n, with all the node values where, n is\\n   * the number of nodes\\n   * @returns void\\n   */\\n  void set_node_val(const std::vector<X> &node_val) {\\n    assert(static_cast<int>(node_val.size()) == t_nodes);\\n    t_val = node_val;\\n  }\\n\\n  /**\\n   * @brief This function must be called after the tree adjacency list and node\\n   * values are populated The function initializes the required parameters, and\\n   * populates the segment tree\\n   * @returns void\\n   */\\n  void init() {\\n    assert(t_nodes > 0);\\n    dfs_size(t_root);\\n    dfs_lca(t_root);\\n  }\\n\\n  /**\\n   * @brief The function lifts a node, k units up the tree.\\n   * The lifting is done in place, and the result is stored in the address\\n   * pointed by p.\\n   * @param p a pointer to the variable that stores the node id\\n   * @param dist the distance to move up the tree\\n   * @returns void\\n   */\\n  void lift(int *const p, int dist) {\\n    for (int k = 0; k < t_maxlift; k++) {\\n      if (*p == -1) {\\n        return;\\n      }\\n      if (dist & 1) {\\n        *p = t_par[*p][k];\\n      }\\n      dist >>= 1;\\n    }\\n  }\\n\\n  /**\\n   * @brief The function returns the kth ancestor of a node\\n   * @param p the node id whose kth ancestor is to be found\\n   * @param dist the distance to move up the tree\\n   * @returns the kth ancestor of node\\n   */\\n  int kth_ancestor(int p, const int &dist) {\\n    lift(&p, dist);\\n    return p;\\n  }\\n\\n  /**\\n   * @brief The function returns the least common ancestor of two nodes\\n   * @param a node id_1\\n   * @param b node id_2\\n   * @returns the least common ancestor of node a, and node b\\n   */\\n  int lca(int a, int b) {\\n    assert(a >= 0 and b >= 0 and a < t_nodes and b < t_nodes);\\n    if (t_depth[a] > t_depth[b]) {\\n      lift(&a, t_depth[a] - t_depth[b]);\\n    }\\n    if (t_depth[b] > t_depth[a]) {\\n      lift(&b, t_depth[b] - t_depth[a]);\\n    }\\n    if (a == b) {\\n      return a;\\n    }\\n    for (int k = t_maxlift - 1; k >= 0; k--) {\\n      if (t_par[a][k] != t_par[b][k]) {\\n        a = t_par[a][k];\\n        b = t_par[b][k];\\n      }\\n    }\\n    return t_par[a][0];\\n  }\\n};\\n\\n/**\\n * @brief Segment Tree, to store heavy chains\\n * @tparam the data type of the values stored in the tree nodes\\n */\\ntemplate <typename X> class SG {\\nprivate:\\n  /**\\n   * @brief Everything here is private,\\n   * and can only be accessed through the methods,\\n   * in the derived class (HLD)\\n   */\\n\\n  std::vector<X> s_tree; ///< the segment tree, stored as a vector\\n  int s_size;            ///< number of leaves in the segment tree\\n  X sret_init = 0;       ///< inital query return value\\n  template <typename T> friend class HLD;\\n\\n  /**\\n   * @brief Function that specifies the type of operation involved when segments\\n   * are combined\\n   * @param lhs the left segment\\n   * @param rhs the right segment\\n   * @returns the combined result\\n   */\\n  X combine(X lhs, X rhs) { return lhs + rhs; }\\n\\n  /**\\n   * @brief Class parameterized constructor. Resizes the and initilizes the data\\n   * members.\\n   * @param nodes the total number of nodes in the tree\\n   * @returns void\\n   */\\n  explicit SG(int size) {\\n    s_size = size;\\n    s_tree.assign(2 * s_size, 0ll);\\n  }\\n\\n  /**\\n   * @brief Update the value at a node\\n   * @param p the node to be udpated\\n   * @param v the update value\\n   * @returns void\\n   */\\n  void update(int p, X v) {\\n    for (p += s_size; p > 0; p >>= 1) {\\n      s_tree[p] += v;\\n    }\\n  }\\n\\n  /**\\n   * @brief Make a range query from node label l to node label r\\n   * @param l node label where the path starts\\n   * @param r node label where the path ends\\n   * @returns void\\n   */\\n  X query(int l, int r) {\\n    X lhs = sret_init, rhs = sret_init;\\n    for (l += s_size, r += s_size + 1; l < r; l >>= 1, r >>= 1) {\\n      if (l & 1) {\\n        lhs = combine(lhs, s_tree[l++]);\\n      }\\n      if (r & 1) {\\n        rhs = combine(s_tree[--r], rhs);\\n      }\\n    }\\n    return combine(lhs, rhs);\\n  }\\n\\n  /**\\n   * @brief Set the initialization for the query data type, based on requirement\\n   *\\n   * @details\\n   * Change the sret_init, based on requirement:\\n   * * Sum Query: 0 (Default)\\n   * * XOR Query: 0 (Default)\\n   * * Min Query: Infinity\\n   * * Max Query: -Infinity\\n   * @param new_sret_init the new init\\n   */\\n  void set_sret_init(X new_sret_init) { sret_init = new_sret_init; }\\n};\\n\\n/**\\n * @brief The Heavy-Light Decomposition class\\n * @tparam the data type of the values stored in the tree nodes\\n */\\ntemplate <typename X> class HLD : public Tree<X>, public SG<X> {\\nprivate:\\n  int label;                ///< utility member to assign labels in dfs_labels()\\n  std::vector<int> h_label, ///< stores the label of a node\\n      h_heavychlid,         ///< stores the heavy child of a node\\n      h_parent;             ///< stores the top of the heavy chain from a node\\n\\n  /**\\n   * @brief Utility function to assign heavy child to each node (-1 for a leaf\\n   * node)\\n   * @param u current dfs node\\n   * @param p the parent of node u\\n   * @returns void\\n   */\\n  void dfs_hc(int u, int p = -1) {\\n    int hc_size = -1, hc_id = -1;\\n    for (const int &v : Tree<X>::t_adj[u]) {\\n      if (v ^ p) {\\n        dfs_hc(v, u);\\n        if (Tree<X>::t_size[v] > hc_size) {\\n          hc_size = Tree<X>::t_size[v];\\n          hc_id = v;\\n        }\\n      }\\n    }\\n    h_heavychlid[u] = hc_id;\\n  }\\n\\n  /**\\n   * @brief Utility function to assign highest parent that can be reached though\\n   * heavy chains\\n   * @param u current dfs node\\n   * @param p the parent of node u\\n   * @returns void\\n   */\\n  void dfs_par(int u, int p = -1) {\\n    if (h_heavychlid[u] != -1) {\\n      h_parent[h_heavychlid[u]] = h_parent[u];\\n      dfs_par(h_heavychlid[u], u);\\n    }\\n    for (const int &v : Tree<X>::t_adj[u]) {\\n      if (v ^ p and v ^ h_heavychlid[u]) {\\n        dfs_par(v, u);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @brief Utility function to lable the nodes so that heavy chains have a\\n   * contigous lable\\n   * @param u current dfs node\\n   * @param p the parent of node u\\n   * @returns void\\n   */\\n  void dfs_labels(int u, int p = -1) {\\n    h_label[u] = label++;\\n    if (h_heavychlid[u] != -1) {\\n      dfs_labels(h_heavychlid[u], u);\\n    }\\n    for (const int &v : Tree<X>::t_adj[u]) {\\n      if (v ^ p and v ^ h_heavychlid[u]) {\\n        dfs_labels(v, u);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @brief Utility function to break down a path query into two chain queries\\n   * @param a node where the path starts\\n   * @param b node where the path ends\\n   * a and b must belong to a single root to leaf chain\\n   * @returns the sum of ndoe values in the simple path from a to b\\n   */\\n  X chain_query(int a, int b) {\\n    X ret = SG<X>::sret_init;\\n    if (Tree<X>::t_depth[a] < Tree<X>::t_depth[b]) {\\n      std::swap(a, b);\\n    }\\n    while (Tree<X>::t_depth[a] >= Tree<X>::t_depth[b]) {\\n      int l = h_label[h_parent[a]];\\n      int r = h_label[a];\\n      if (Tree<X>::t_depth[h_parent[a]] < Tree<X>::t_depth[b]) {\\n        l += Tree<X>::t_depth[b] - Tree<X>::t_depth[h_parent[a]];\\n      }\\n      ret = SG<X>::combine(ret, SG<X>::query(l, r));\\n      a = Tree<X>::t_par[h_parent[a]][0];\\n      if (a == -1) {\\n        break;\\n      }\\n    }\\n    return ret;\\n  }\\n\\npublic:\\n  /**\\n   * @brief Class parameterized constructor. Resizes the and initilizes the data\\n   * members.\\n   * @param nodes the total number of nodes in the tree\\n   */\\n  explicit HLD<X>(int nodes) : Tree<X>(nodes), SG<X>(nodes) {\\n    /* Initialization and resize vectors */\\n    label = 0;\\n    h_label.assign(Tree<X>::t_nodes, -1);\\n    h_heavychlid.assign(Tree<X>::t_nodes, -1);\\n    h_parent.resize(Tree<X>::t_nodes);\\n    iota(h_parent.begin(), h_parent.end(), 0);\\n  }\\n\\n  /**\\n   * @brief This function must be called after the tree adjacency list and node\\n   * values are populated The function initializes the required parametes, and\\n   * populates the segment tree\\n   * @returns void\\n   */\\n  void init() {\\n    Tree<X>::init();\\n\\n    // Fill the heavy child, greatest parent, and labels\\n    label = 0;\\n    dfs_hc(Tree<X>::t_root);\\n    dfs_par(Tree<X>::t_root);\\n    dfs_labels(Tree<X>::t_root);\\n\\n    // Segment Tree Initialization\\n    for (int i = 0; i < Tree<X>::t_nodes; i++) {\\n      SG<X>::s_tree[h_label[i] + Tree<X>::t_nodes] = Tree<X>::t_val[i];\\n    }\\n    for (int i = Tree<X>::t_nodes - 1; i > 0; i--) {\\n      SG<X>::s_tree[i] =\\n          SG<X>::combine(SG<X>::s_tree[i << 1], SG<X>::s_tree[i << 1 | 1]);\\n    }\\n  }\\n\\n  /**\\n   * @brief This function updates the value at node with val\\n   * @param node the node where the update is done\\n   * @param val the value that is being updated\\n   * @returns void\\n   */\\n  void update(int node, X val) {\\n    X diff = val - Tree<X>::t_val[node];\\n    SG<X>::update(h_label[node], diff);\\n    Tree<X>::t_val[node] = val;\\n  }\\n\\n  /**\\n   * @brief This function returns the sum of node values in the simple path from\\n   * from node_1 to node_2\\n   * @param a the node where the simple path starts\\n   * @param b the node where the simple path ends\\n   * (parameters are interchangeable, i.e., the function is commutative)\\n   * @returns the sum of node values in the simple path from a to b\\n   */\\n  X query(int a, int b) {\\n    int lc = Tree<X>::lca(a, b);\\n    X ret = SG<X>::sret_init;\\n    assert(lc != -1);\\n    ret += chain_query(a, lc);\\n    ret += chain_query(b, lc);\\n    return ret - Tree<X>::t_val[lc];\\n  }\\n};\\n} // namespace heavy_light_decomposition\\n} // namespace range_queries\\n\\n/**\\n * Test implementations\\n * @returns none\\n */\\nstatic void test_1() {\\n  std::cout << \\\"Test 1:\\\\n\\\";\\n\\n  // Test details\\n  int n = 5;\\n  std::vector<int64_t> node_values = {4, 2, 5, 2, 1};\\n  std::vector<std::vector<int>> edges = {{1, 2}, {1, 3}, {3, 4}, {3, 5}};\\n  std::vector<std::vector<int>> queries = {\\n      {2, 1, 4},\\n      {1, 3, 2},\\n      {2, 1, 4},\\n  };\\n  std::vector<int> expected_result = {11, 8};\\n  std::vector<int> code_result;\\n\\n  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);\\n  hld.set_node_val(node_values);\\n  for (int i = 0; i < n - 1; i++) {\\n    int u = edges[i][0], v = edges[i][1];\\n    hld.add_edge(u - 1, v - 1);\\n  }\\n  hld.init();\\n  for (const auto &q : queries) {\\n    int type = q[0];\\n    if (type == 1) {\\n      int p = q[1], x = q[2];\\n      hld.update(p - 1, x);\\n    } else if (type == 2) {\\n      int a = q[1], b = q[2];\\n      code_result.push_back(hld.query(a - 1, b - 1));\\n    } else {\\n      continue;\\n    }\\n  }\\n  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {\\n    assert(expected_result[i] == code_result[i]);\\n  }\\n  std::cout << \\\"\\\\nTest 1 passed!\\\\n\\\";\\n}\\n\\n/**\\n * Second test implementations\\n * @returns void\\n */\\nstatic void test_2() {\\n  std::cout << \\\"Test 2:\\\\n\\\";\\n\\n  // Test details (Bamboo)\\n  int n = 10;\\n  std::vector<int64_t> node_values = {1, 8, 6, 8, 6, 2, 9, 2, 3, 2};\\n  std::vector<std::vector<int>> edges = {\\n      {10, 5}, {6, 2}, {10, 7}, {5, 2}, {3, 9}, {8, 3}, {1, 4}, {6, 4}, {8, 7}};\\n  std::vector<std::vector<int>> queries = {\\n      {2, 1, 10}, {2, 1, 6}, {1, 3, 4}, {2, 1, 9}, {1, 5, 3},\\n      {1, 7, 8},  {2, 1, 4}, {2, 1, 8}, {1, 1, 4}, {1, 2, 7}};\\n  std::vector<int> expected_result = {27, 11, 45, 9, 34};\\n  std::vector<int> code_result;\\n\\n  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);\\n  hld.set_node_val(node_values);\\n  for (int i = 0; i < n - 1; i++) {\\n    int u = edges[i][0], v = edges[i][1];\\n    hld.add_edge(u - 1, v - 1);\\n  }\\n  hld.init();\\n  for (const auto &q : queries) {\\n    int type = q[0];\\n    if (type == 1) {\\n      int p = q[1], x = q[2];\\n      hld.update(p - 1, x);\\n    } else if (type == 2) {\\n      int a = q[1], b = q[2];\\n      code_result.push_back(hld.query(a - 1, b - 1));\\n    } else {\\n      continue;\\n    }\\n  }\\n  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {\\n    assert(expected_result[i] == code_result[i]);\\n  }\\n  std::cout << \\\"\\\\nTest2 passed!\\\\n\\\";\\n}\\n\\n/**\\n * Third test implementations\\n * @returns void\\n */\\nstatic void test_3() {\\n  std::cout << \\\"Test 3:\\\\n\\\";\\n\\n  // Test details\\n  int n = 8;\\n  std::vector<int64_t> node_values = {1, 8, 6, 8, 6, 2, 9, 2};\\n  std::vector<std::vector<int>> edges = {{1, 2}, {2, 3}, {3, 4}, {1, 5},\\n                                         {6, 3}, {7, 5}, {8, 7}};\\n  std::vector<std::vector<int>> queries = {\\n      {2, 6, 8}, {2, 3, 6}, {1, 3, 4}, {2, 7, 1}, {1, 5, 3},\\n      {1, 7, 8}, {2, 6, 4}, {2, 7, 8}, {1, 1, 4}, {1, 2, 7}};\\n  std::vector<int> expected_result = {34, 8, 16, 14, 10};\\n  std::vector<int> code_result;\\n\\n  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);\\n  hld.set_node_val(node_values);\\n  for (int i = 0; i < n - 1; i++) {\\n    int u = edges[i][0], v = edges[i][1];\\n    hld.add_edge(u - 1, v - 1);\\n  }\\n  hld.init();\\n  for (const auto &q : queries) {\\n    int type = q[0];\\n    if (type == 1) {\\n      int p = q[1], x = q[2];\\n      hld.update(p - 1, x);\\n    } else if (type == 2) {\\n      int a = q[1], b = q[2];\\n      code_result.push_back(hld.query(a - 1, b - 1));\\n    } else {\\n      continue;\\n    }\\n  }\\n  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {\\n    assert(expected_result[i] == code_result[i]);\\n  }\\n  std::cout << \\\"\\\\nTest3 passed!\\\\n\\\";\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n  test_1();\\n  test_2();\\n  test_3();\\n  return 0;\\n}\\n\"",
    "mo": "\"#include <iostream>\\nusing namespace std;\\nconst int N = 1e6 + 5;\\nint a[N], bucket[N], cnt[N];\\nint bucket_size;\\nstruct query {\\n    int l, r, i;\\n} q[N];\\nint ans = 0;\\n\\nvoid add(int index) {\\n    cnt[a[index]]++;\\n    if (cnt[a[index]] == 1)\\n        ans++;\\n}\\nvoid remove(int index) {\\n    cnt[a[index]]--;\\n    if (cnt[a[index]] == 0)\\n        ans--;\\n}\\n\\nbool mycmp(query x, query y) {\\n    if (x.l / bucket_size != y.l / bucket_size)\\n        return x.l / bucket_size < y.l / bucket_size;\\n    return x.r < y.r;\\n}\\n\\nint main() {\\n    int n, t, i, j, k = 0;\\n    scanf(\\\"%d\\\", &n);\\n    for (i = 0; i < n; i++) scanf(\\\"%d\\\", &a[i]);\\n    bucket_size = ceil(sqrt(n));\\n    scanf(\\\"%d\\\", &t);\\n    for (i = 0; i < t; i++) {\\n        scanf(\\\"%d %d\\\", &q[i].l, &q[i].r);\\n        q[i].l--;\\n        q[i].r--;\\n        q[i].i = i;\\n    }\\n    sort(q, q + t, mycmp);\\n    int left = 0, right = 0;\\n    for (i = 0; i < t; i++) {\\n        int L = q[i].l, R = q[i].r;\\n        while (left < L) {\\n            remove(left);\\n            left++;\\n        }\\n        while (left > L) {\\n            add(left - 1);\\n            left--;\\n        }\\n        while (right <= R) {\\n            add(right);\\n            right++;\\n        }\\n        while (right > R + 1) {\\n            remove(right - 1);\\n            right--;\\n        }\\n        bucket[q[i].i] = ans;\\n    }\\n    for (i = 0; i < t; i++) printf(\\\"%d\\\\n\\\", bucket[i]);\\n    return 0;\\n}\\n\"",
    "persistent seg tree lazy prop": "\"/**\\n * @file\\n * @brief [Persistent segment tree with range updates (lazy\\n * propagation)](https://en.wikipedia.org/wiki/Persistent_data_structure)\\n *\\n * @details\\n * A normal segment tree facilitates making point updates and range queries in\\n * logarithmic time. Lazy propagation preserves the logarithmic time with range\\n * updates. So, a segment tree with lazy propagation enables doing range updates\\n * and range queries in logarithmic time, but it doesn't save any information\\n * about itself before the last update. A persistent data structure always\\n * preserves the previous version of itself when it is modified. That is, a new\\n * version of the segment tree is generated after every update. It saves all\\n * previous versions of itself (before every update) to facilitate doing range\\n * queries in any version. More memory is used ,but the logarithmic time is\\n * preserved because the new version points to the same nodes, that the previous\\n * version points to, that are not affected by the update. That is, only the\\n * nodes that are affected by the update and their ancestors are copied. The\\n * rest is copied using lazy propagation in the next queries. Thus preserving\\n * the logarithmic time because the number of nodes copied after any update is\\n * logarithmic.\\n *\\n * @author [Magdy Sedra](https://github.com/MSedra)\\n */\\n#include <iostream>  /// for IO operations\\n#include <memory>    /// to manage dynamic memory\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace range_queries\\n * @brief Range queries algorithms\\n */\\nnamespace range_queries {\\n\\n/**\\n * @brief Range query here is range sum, but the code can be modified to make\\n * different queries like range max or min.\\n */\\nclass perSegTree {\\n private:\\n    class Node {\\n     public:\\n        std::shared_ptr<Node> left = nullptr;   /// pointer to the left node\\n        std::shared_ptr<Node> right = nullptr;  /// pointer to the right node\\n        int64_t val = 0,\\n                prop = 0;  /// val is the value of the node (here equals to the\\n                           /// sum of the leaf nodes children of that node),\\n                           /// prop is the value to be propagated/added to all\\n                           /// the leaf nodes children of that node\\n    };\\n\\n    uint32_t n = 0;  /// number of elements/leaf nodes in the segment tree\\n    std::vector<std::shared_ptr<Node>>\\n        ptrs{};  /// ptrs[i] holds a root pointer to the segment tree after the\\n                 /// ith update. ptrs[0] holds a root pointer to the segment\\n                 /// tree before any updates\\n    std::vector<int64_t> vec{};  /// values of the leaf nodes that the segment\\n                                 /// tree will be constructed with\\n\\n    /**\\n     * @brief Creating a new node with the same values of curr node\\n     * @param curr node that would be copied\\n     * @returns the new node\\n     */\\n    std::shared_ptr<Node> newKid(std::shared_ptr<Node> const &curr) {\\n        auto newNode = std::make_shared<Node>(Node());\\n        newNode->left = curr->left;\\n        newNode->right = curr->right;\\n        newNode->prop = curr->prop;\\n        newNode->val = curr->val;\\n        return newNode;\\n    }\\n\\n    /**\\n     * @brief If there is some value to be propagated to the passed node, value\\n     * is added to the node and the children of the node, if exist, are copied\\n     * and the propagated value is also added to them\\n     * @param i the left index of the range that the passed node holds its sum\\n     * @param j the right index of the range that the passed node holds its sum\\n     * @param curr pointer to the node to be propagated\\n     * @returns void\\n     */\\n    void lazy(const uint32_t &i, const uint32_t &j,\\n              std::shared_ptr<Node> const &curr) {\\n        if (!curr->prop) {\\n            return;\\n        }\\n        curr->val += (j - i + 1) * curr->prop;\\n        if (i != j) {\\n            curr->left = newKid(curr->left);\\n            curr->right = newKid(curr->right);\\n            curr->left->prop += curr->prop;\\n            curr->right->prop += curr->prop;\\n        }\\n        curr->prop = 0;\\n    }\\n\\n    /**\\n     * @brief Constructing the segment tree with the early passed vector. Every\\n     * call creates a node to hold the sum of the given range, set its pointers\\n     * to the children, and set its value to the sum of the children's values\\n     * @param i the left index of the range that the created node holds its sum\\n     * @param j the right index of the range that the created node holds its sum\\n     * @returns pointer to the newly created node\\n     */\\n    std::shared_ptr<Node> construct(const uint32_t &i, const uint32_t &j) {\\n        auto newNode = std::make_shared<Node>(Node());\\n        if (i == j) {\\n            newNode->val = vec[i];\\n        } else {\\n            uint32_t mid = i + (j - i) / 2;\\n            auto leftt = construct(i, mid);\\n            auto right = construct(mid + 1, j);\\n            newNode->val = leftt->val + right->val;\\n            newNode->left = leftt;\\n            newNode->right = right;\\n        }\\n        return newNode;\\n    }\\n\\n    /**\\n     * @brief Doing range update, checking at every node if it has some value to\\n     * be propagated. All nodes affected by the update are copied and\\n     * propagation value is added to the leaf of them\\n     * @param i the left index of the range that the passed node holds its sum\\n     * @param j the right index of the range that the passed node holds its sum\\n     * @param l the left index of the range to be updated\\n     * @param r the right index of the range to be updated\\n     * @param value the value to be added to every element whose index x\\n     * satisfies l<=x<=r\\n     * @param curr pointer to the current node, which has value = the sum of\\n     * elements whose index x satisfies i<=x<=j\\n     * @returns pointer to the current newly created node\\n     */\\n    std::shared_ptr<Node> update(const uint32_t &i, const uint32_t &j,\\n                                 const uint32_t &l, const uint32_t &r,\\n                                 const int64_t &value,\\n                                 std::shared_ptr<Node> const &curr) {\\n        lazy(i, j, curr);\\n        if (i >= l && j <= r) {\\n            std::shared_ptr<Node> newNode = newKid(curr);\\n            newNode->prop += value;\\n            lazy(i, j, newNode);\\n            return newNode;\\n        }\\n        if (i > r || j < l) {\\n            return curr;\\n        }\\n        auto newNode = std::make_shared<Node>(Node());\\n        uint32_t mid = i + (j - i) / 2;\\n        newNode->left = update(i, mid, l, r, value, curr->left);\\n        newNode->right = update(mid + 1, j, l, r, value, curr->right);\\n        newNode->val = newNode->left->val + newNode->right->val;\\n        return newNode;\\n    }\\n\\n    /**\\n     * @brief Querying the range from index l to index r, checking at every node\\n     * if it has some value to be propagated. Current node's value is returned\\n     * if its range is completely inside the wanted range, else 0 is returned\\n     * @param i the left index of the range that the passed node holds its sum\\n     * @param j the right index of the range that the passed node holds its sum\\n     * @param l the left index of the range whose sum should be returned as a\\n     * result\\n     * @param r the right index of the range whose sum should be returned as a\\n     * result\\n     * @param curr pointer to the current node, which has value = the sum of\\n     * elements whose index x satisfies i<=x<=j\\n     * @returns sum of elements whose index x satisfies l<=x<=r\\n     */\\n    int64_t query(const uint32_t &i, const uint32_t &j, const uint32_t &l,\\n                  const uint32_t &r, std::shared_ptr<Node> const &curr) {\\n        lazy(i, j, curr);\\n        if (j < l || r < i) {\\n            return 0;\\n        }\\n        if (i >= l && j <= r) {\\n            return curr->val;\\n        }\\n        uint32_t mid = i + (j - i) / 2;\\n        return query(i, mid, l, r, curr->left) +\\n               query(mid + 1, j, l, r, curr->right);\\n    }\\n\\n    /**\\n     * public methods that can be used directly from outside the class. They\\n     * call the private functions that do all the work\\n     */\\n public:\\n    /**\\n     * @brief Constructing the segment tree with the values in the passed\\n     * vector. Returned root pointer is pushed in the pointers vector to have\\n     * access to the original version if the segment tree is updated\\n     * @param vec vector whose values will be used to build the segment tree\\n     * @returns void\\n     */\\n    void construct(const std::vector<int64_t>\\n                       &vec)  // the segment tree will be built from the values\\n                              // in \\\"vec\\\", \\\"vec\\\" is 0 indexed\\n    {\\n        if (vec.empty()) {\\n            return;\\n        }\\n        n = vec.size();\\n        this->vec = vec;\\n        auto root = construct(0, n - 1);\\n        ptrs.push_back(root);\\n    }\\n\\n    /**\\n     * @brief Doing range update by passing the left and right indexes of the\\n     * range as well as the value to be added.\\n     * @param l the left index of the range to be updated\\n     * @param r the right index of the range to be updated\\n     * @param value the value to be added to every element whose index x\\n     * satisfies l<=x<=r\\n     * @returns void\\n     */\\n    void update(const uint32_t &l, const uint32_t &r,\\n                const int64_t\\n                    &value)  // all elements from index \\\"l\\\" to index \\\"r\\\" would\\n                             // by updated by \\\"value\\\", \\\"l\\\" and \\\"r\\\" are 0 indexed\\n    {\\n        ptrs.push_back(update(\\n            0, n - 1, l, r, value,\\n            ptrs[ptrs.size() -\\n                 1]));  // saving the root pointer to the new segment tree\\n    }\\n\\n    /**\\n     * @brief Querying the range from index l to index r, getting the sum of the\\n     * elements whose index x satisfies l<=x<=r\\n     * @param l the left index of the range whose sum should be returned as a\\n     * result\\n     * @param r the right index of the range whose sum should be returned as a\\n     * result\\n     * @param version the version to query on. If equals to 0, the original\\n     * segment tree will be queried\\n     * @returns sum of elements whose index x satisfies l<=x<=r\\n     */\\n    int64_t query(\\n        const uint32_t &l, const uint32_t &r,\\n        const uint32_t\\n            &version)  // querying the range from \\\"l\\\" to \\\"r\\\" in a segment tree\\n                       // after \\\"version\\\" updates, \\\"l\\\" and \\\"r\\\" are 0 indexed\\n    {\\n        return query(0, n - 1, l, r, ptrs[version]);\\n    }\\n\\n    /**\\n     * @brief Getting the number of versions after updates so far which is equal\\n     * to the size of the pointers vector\\n     * @returns the number of versions\\n     */\\n    uint32_t size()  // returns the number of segment trees (versions) , the\\n                     // number of updates done so far = returned value - 1\\n                     // ,because one of the trees is the original segment tree\\n    {\\n        return ptrs.size();\\n    }\\n};\\n}  // namespace range_queries\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    std::vector<int64_t> arr = {-5, 2, 3, 11, -2, 7, 0, 1};\\n    range_queries::perSegTree tree;\\n    std::cout << \\\"Elements before any updates are {\\\";\\n    for (uint32_t i = 0; i < arr.size(); ++i) {\\n        std::cout << arr[i];\\n        if (i != arr.size() - 1) {\\n            std::cout << \\\",\\\";\\n        }\\n    }\\n    std::cout << \\\"}\\\\n\\\";\\n    tree.construct(\\n        arr);  // constructing the original segment tree (version = 0)\\n    std::cout << \\\"Querying range sum on version 0 from index 2 to 4 = 3+11-2 = \\\"\\n              << tree.query(2, 4, 0) << '\\\\n';\\n    std::cout\\n        << \\\"Subtract 7 from all elements from index 1 to index 5 inclusive\\\\n\\\";\\n    tree.update(1, 5, -7);  // subtracting 7 from index 1 to index 5\\n    std::cout << \\\"Elements of the segment tree whose version = 1 (after 1 \\\"\\n                 \\\"update) are {\\\";\\n    for (uint32_t i = 0; i < arr.size(); ++i) {\\n        std::cout << tree.query(i, i, 1);\\n        if (i != arr.size() - 1) {\\n            std::cout << \\\",\\\";\\n        }\\n    }\\n    std::cout << \\\"}\\\\n\\\";\\n    std::cout << \\\"Add 10 to all elements from index 0 to index 7 inclusive\\\\n\\\";\\n    tree.update(0, 7, 10);  // adding 10 to all elements\\n    std::cout << \\\"Elements of the segment tree whose version = 2 (after 2 \\\"\\n                 \\\"updates) are {\\\";\\n    for (uint32_t i = 0; i < arr.size(); ++i) {\\n        std::cout << tree.query(i, i, 2);\\n        if (i != arr.size() - 1) {\\n            std::cout << \\\",\\\";\\n        }\\n    }\\n    std::cout << \\\"}\\\\n\\\";\\n    std::cout << \\\"Number of segment trees (versions) now = \\\" << tree.size()\\n              << '\\\\n';\\n    std::cout << \\\"Querying range sum on version 0 from index 3 to 5 = 11-2+7 = \\\"\\n              << tree.query(3, 5, 0) << '\\\\n';\\n    std::cout << \\\"Querying range sum on version 1 from index 3 to 5 = 4-9+0 = \\\"\\n              << tree.query(3, 5, 1) << '\\\\n';\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "prefix sum array": "\"/**\\r\\n * @file\\r\\n * @brief\\r\\n * [Prefix Sum\\r\\n * Array](https://en.wikipedia.org/wiki/Prefix_sum) data structure\\r\\n * implementation.\\r\\n *\\r\\n * @details\\r\\n * Prefix Sum Array is a data structure, that allows answering sum in some range\\r\\n * queries. It can answer most sum range queries in O(1), with a build time\\r\\n * complexity of O(N). But it hasn't an update querie.\\r\\n *\\r\\n * * Running Time Complexity \\\\n\\r\\n * * Build : O(N) \\\\n\\r\\n * * Range Query : O(1) \\\\n\\r\\n * @author [Paulo Vitor Lima Borges](https://github.com/PauloVLB)\\r\\n */\\r\\n\\r\\n#include <cassert>   /// for assert\\r\\n#include <iostream>  /// for IO operations\\r\\n#include <vector>    /// for std::vector\\r\\n\\r\\n/**\\r\\n * @namespace range_queries\\r\\n * @brief Range Queries algorithms\\r\\n */\\r\\nnamespace range_queries {\\r\\n/**\\r\\n * @namespace prefix_sum_array\\r\\n * @brief Range sum queries using prefix-sum-array\\r\\n */\\r\\nnamespace prefix_sum_array {\\r\\n\\r\\nstd::vector<int64_t> PSA(1, 0);\\r\\n\\r\\n/**\\r\\n * @brief function that builds the PSA\\r\\n * @param original_array original array of values\\r\\n * @returns void\\r\\n */\\r\\nvoid build(std::vector<int64_t> original_array) {\\r\\n    for (int i = 1; i <= static_cast<int>(original_array.size()); i++) {\\r\\n        PSA.push_back(PSA[i - 1] + original_array[i]);\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * @brief query function\\r\\n * @param beg begin of the interval to sum\\r\\n * @param end end of the interval to sum\\r\\n * @returns sum of the range [beg, end]\\r\\n */\\r\\nint64_t query(int64_t beg, int64_t end) { return PSA[end] - PSA[beg - 1]; }\\r\\n\\r\\n}  // namespace prefix_sum_array\\r\\n}  // namespace range_queries\\r\\n\\r\\n/**\\r\\n * @brief Self-test implementations\\r\\n * @returns void\\r\\n */\\r\\nstatic void test() {\\r\\n    std::vector<int64_t> values{0,  123, 0,  2,  -2, 5,\\r\\n                                24, 0,   23, -1, -1};  // original array\\r\\n\\r\\n    range_queries::prefix_sum_array::build(values);\\r\\n    // queries are of the type: sum of the range [a, b] = psa[b] - psa[a-1]\\r\\n\\r\\n    assert(range_queries::prefix_sum_array::query(1, 10) ==\\r\\n           173);  // sum of the entire array\\r\\n    assert(range_queries::prefix_sum_array::query(4, 6) ==\\r\\n           27);  // the sum of the interval [4, 6]\\r\\n    assert(range_queries::prefix_sum_array::query(5, 9) ==\\r\\n           51);  // the sum of the interval [5, 9]\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @returns 0 on exit\\r\\n */\\r\\nint main() {\\r\\n    test();  // run self-test implementations\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "segtree": "\"/**\\n * @file\\n * @brief   Implementation of [Segment Tree]\\n *          (https://en.wikipedia.org/wiki/Segment_tree) data structure\\n *\\n * @details\\n * A segment tree, also known as a statistic tree, is a tree data structure used\\n * for storing information about intervals, or segments. Its classical version\\n * allows querying which of the stored segments contain a given point, but our\\n * modification allows us to perform (query) any binary operation on any range\\n * in the array in O(logN) time. Here, we have used addition (+).\\n * For range updates, we have used lazy propagation.\\n *\\n * * Space Complexity : O(NlogN) \\\\n\\n * * Build Time Complexity : O(NlogN) \\\\n\\n * * Query Time Complexity : O(logN) \\\\n\\n *\\n * @author  [Madhav Gaba](https://github.com/madhavgaba)\\n * @author  [Soham Roy](https://github.com/sohamroy19)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <cmath>     /// for log2\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @brief   Constructs the initial segment tree\\n *\\n * @param   arr input to construct the tree out of\\n * @param   segtree the segment tree\\n * @param   low inclusive lowest index of arr to begin at\\n * @param   high inclusive highest index of arr to end at\\n * @param   pos index of segtree to fill (eg. root node)\\n * @returns void\\n */\\nvoid ConsTree(const std::vector<int64_t> &arr, std::vector<int64_t> *segtree,\\n              uint64_t low, uint64_t high, uint64_t pos) {\\n    if (low == high) {\\n        (*segtree)[pos] = arr[low];\\n        return;\\n    }\\n\\n    uint64_t mid = (low + high) / 2;\\n    ConsTree(arr, segtree, low, mid, 2 * pos + 1);\\n    ConsTree(arr, segtree, mid + 1, high, 2 * pos + 2);\\n    (*segtree)[pos] = (*segtree)[2 * pos + 1] + (*segtree)[2 * pos + 2];\\n}\\n\\n/**\\n * @brief   Returns the sum of all elements in a range\\n *\\n * @param   segtree the segment tree\\n * @param   lazy for lazy propagation\\n * @param   qlow lower index of the required query\\n * @param   qhigh higher index of the required query\\n * @param   low lower index of query for this function call\\n * @param   high higher index of query for this function call\\n * @param   pos index of segtree to consider (eg. root node)\\n * @return  result of the range query for this function call\\n */\\nint64_t query(std::vector<int64_t> *segtree, std::vector<int64_t> *lazy,\\n              uint64_t qlow, uint64_t qhigh, uint64_t low, uint64_t high,\\n              uint64_t pos) {\\n    if (low > high || qlow > high || low > qhigh) {\\n        return 0;\\n    }\\n\\n    if ((*lazy)[pos] != 0) {\\n        (*segtree)[pos] += (*lazy)[pos] * (high - low + 1);\\n\\n        if (low != high) {\\n            (*lazy)[2 * pos + 1] += (*lazy)[pos];\\n            (*lazy)[2 * pos + 2] += (*lazy)[pos];\\n        }\\n        (*lazy)[pos] = 0;\\n    }\\n\\n    if (qlow <= low && qhigh >= high) {\\n        return (*segtree)[pos];\\n    }\\n\\n    uint64_t mid = (low + high) / 2;\\n\\n    return query(segtree, lazy, qlow, qhigh, low, mid, 2 * pos + 1) +\\n           query(segtree, lazy, qlow, qhigh, mid + 1, high, 2 * pos + 2);\\n}\\n\\n/**\\n * @brief   Updates a range of the segment tree\\n *\\n * @param   segtree the segment tree\\n * @param   lazy for lazy propagation\\n * @param   start lower index of the required query\\n * @param   end higher index of the required query\\n * @param   delta integer to add to each element of the range\\n * @param   low lower index of query for this function call\\n * @param   high higher index of query for this function call\\n * @param   pos index of segtree to consider (eg. root node)\\n * @returns void\\n */\\nvoid update(std::vector<int64_t> *segtree, std::vector<int64_t> *lazy,\\n            int64_t start, int64_t end, int64_t delta, uint64_t low,\\n            uint64_t high, uint64_t pos) {\\n    if (low > high) {\\n        return;\\n    }\\n\\n    if ((*lazy)[pos] != 0) {\\n        (*segtree)[pos] += (*lazy)[pos] * (high - low + 1);\\n\\n        if (low != high) {\\n            (*lazy)[2 * pos + 1] += (*lazy)[pos];\\n            (*lazy)[2 * pos + 2] += (*lazy)[pos];\\n        }\\n        (*lazy)[pos] = 0;\\n    }\\n\\n    if (start > high || end < low) {\\n        return;\\n    }\\n\\n    if (start <= low && end >= high) {\\n        (*segtree)[pos] += delta * (high - low + 1);\\n\\n        if (low != high) {\\n            (*lazy)[2 * pos + 1] += delta;\\n            (*lazy)[2 * pos + 2] += delta;\\n        }\\n\\n        return;\\n    }\\n\\n    uint64_t mid = (low + high) / 2;\\n\\n    update(segtree, lazy, start, end, delta, low, mid, 2 * pos + 1);\\n    update(segtree, lazy, start, end, delta, mid + 1, high, 2 * pos + 2);\\n    (*segtree)[pos] = (*segtree)[2 * pos + 1] + (*segtree)[2 * pos + 2];\\n}\\n\\n/**\\n * @brief   Self-test implementation\\n *\\n * @returns void\\n */\\nstatic void test() {\\n    auto max = static_cast<int64_t>(2 * pow(2, ceil(log2(7))) - 1);\\n    assert(max == 15);\\n\\n    std::vector<int64_t> arr{1, 2, 3, 4, 5, 6, 7}, lazy(max), segtree(max);\\n    ConsTree(arr, &segtree, 0, 7 - 1, 0);\\n\\n    assert(query(&segtree, &lazy, 1, 5, 0, 7 - 1, 0) == 2 + 3 + 4 + 5 + 6);\\n\\n    update(&segtree, &lazy, 2, 4, 1, 0, 7 - 1, 0);\\n    assert(query(&segtree, &lazy, 1, 5, 0, 7 - 1, 0) == 2 + 4 + 5 + 6 + 6);\\n\\n    update(&segtree, &lazy, 0, 6, -2, 0, 7 - 1, 0);\\n    assert(query(&segtree, &lazy, 0, 4, 0, 7 - 1, 0) == -1 + 0 + 2 + 3 + 4);\\n}\\n\\n/**\\n * @brief   Main function\\n *\\n * @return  0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n\\n    std::cout << \\\"Enter number of elements: \\\";\\n\\n    uint64_t n = 0;\\n    std::cin >> n;\\n\\n    auto max = static_cast<uint64_t>(2 * pow(2, ceil(log2(n))) - 1);\\n    std::vector<int64_t> arr(n), lazy(max), segtree(max);\\n\\n    int choice = 0;\\n    std::cout << \\\"\\\\nDo you wish to enter each number?:\\\\n\\\"\\n                 \\\"1: Yes\\\\n\\\"\\n                 \\\"0: No (default initialize them to 0)\\\\n\\\";\\n\\n    std::cin >> choice;\\n    if (choice == 1) {\\n        std::cout << \\\"Enter \\\" << n << \\\" numbers:\\\\n\\\";\\n        for (int i = 1; i <= n; i++) {\\n            std::cout << i << \\\": \\\";\\n            std::cin >> arr[i];\\n        }\\n    }\\n\\n    ConsTree(arr, &segtree, 0, n - 1, 0);\\n\\n    do {\\n        std::cout << \\\"\\\\nMake your choice:\\\\n\\\"\\n                     \\\"1: Range update (input)\\\\n\\\"\\n                     \\\"2: Range query (output)\\\\n\\\"\\n                     \\\"0: Exit\\\\n\\\";\\n        std::cin >> choice;\\n\\n        if (choice == 1) {\\n            std::cout << \\\"Enter 1-indexed lower bound, upper bound & value:\\\\n\\\";\\n\\n            uint64_t p = 1, q = 1, v = 0;\\n            std::cin >> p >> q >> v;\\n            update(&segtree, &lazy, p - 1, q - 1, v, 0, n - 1, 0);\\n        } else if (choice == 2) {\\n            std::cout << \\\"Enter 1-indexed lower bound & upper bound:\\\\n\\\";\\n\\n            uint64_t p = 1, q = 1;\\n            std::cin >> p >> q;\\n            std::cout << query(&segtree, &lazy, p - 1, q - 1, 0, n - 1, 0);\\n            std::cout << \\\"\\\\n\\\";\\n        }\\n    } while (choice > 0);\\n\\n    return 0;\\n}\\n\"",
    "binary search": "\"/**\\n * @file\\n * @brief [Binary search\\n * algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm)\\n */\\n#include <iostream>\\n\\n/** binary_search function\\n * \\\\param [in] a array to sort\\n * \\\\param [in] r right hand limit = \\\\f$n-1\\\\f$\\n * \\\\param [in] key value to find\\n * \\\\returns index if T is found\\n * \\\\return -1 if T is not found\\n */\\nint binary_search(int a[], int r, int key) {\\n    int l = 0;\\n\\n    while (l <= r) {\\n        int m = l + (r - l) / 2;\\n        if (key == a[m])\\n            return m;\\n        else if (key < a[m])\\n            r = m - 1;\\n        else\\n            l = m + 1;\\n    }\\n    return -1;\\n}\\n\\n/** main function */\\nint main(int argc, char const* argv[]) {\\n    int n, key;\\n    std::cout << \\\"Enter size of array: \\\";\\n    std::cin >> n;\\n    std::cout << \\\"Enter array elements: \\\";\\n\\n    int* a = new int[n];\\n\\n    // this loop use for store value in Array\\n    for (int i = 0; i < n; i++) {\\n        std::cin >> a[i];\\n    }\\n\\n    std::cout << \\\"Enter search key: \\\";\\n    std::cin >> key;\\n\\n    // this is use for find value in given array\\n    int res = binary_search(a, n - 1, key);\\n    if (res != -1)\\n        std::cout << key << \\\" found at index \\\" << res << std::endl;\\n    else\\n        std::cout << key << \\\" not found\\\" << std::endl;\\n\\n    delete[] a;\\n    return 0;\\n}\\n\"",
    "exponential search": "\"/**\\n * \\\\file\\n * \\\\brief [Exponential search\\n * algorithm](https://en.wikipedia.org/wiki/Exponential_search)\\n * \\\\copyright 2020 Divide-et-impera-11\\n *\\n * The algorithm try to search the range where the key should be.\\n * If it has been found we do a binary search there.\\n * The range of the search grows by exponential every time.\\n * If the key is larger than the last element of array, the start of\\n * block(block_front) will be equal to the end of block(block_size) and the\\n * algorithm return null ponter, every other cases the algoritm return fom the\\n * loop.\\n */\\n#include <cassert>\\n#include <cmath>\\n#include <iostream>\\n#ifdef _MSC_VER\\n#include <string>  // use for MS Visual C++\\n#else\\n#include <cstring>  // for all other compilers\\n#endif\\n\\n/** Binary Search Algorithm (used by ::struzik_search)\\\\n\\n * * Time Complexity O(log n) where 'n' is the number of elements\\n * * Worst Time Complexity O(log n)\\n * * Best Time Complexity Ω(1)\\n * * Space Complexity O(1)\\n * * Auxiliary Space Complexity O(1)\\n * \\\\returns pointer to value in the array\\n * \\\\returns `nullptr` if value not found\\n */\\ntemplate <class Type>\\ninline Type* binary_s(Type* array, size_t size, Type key) {\\n    int32_t lower_index(0), upper_index(size - 1), middle_index;\\n\\n    while (lower_index <= upper_index) {\\n        middle_index = std::floor((lower_index + upper_index) / 2);\\n\\n        if (*(array + middle_index) < key)\\n            lower_index = (middle_index + 1);\\n        else if (*(array + middle_index) > key)\\n            upper_index = (middle_index - 1);\\n        else\\n            return (array + middle_index);\\n    }\\n\\n    return nullptr;\\n}\\n\\n/** Struzik Search Algorithm(Exponential)\\n * * Time Complexity O(log i) where i is the position of search key in the list\\n * * Worst Time Complexity O(log i)\\n * * Best Time Complexity Ω(1)\\n * * Space Complexity O(1)\\n * * Auxiliary Space Complexity O(1)\\n */\\ntemplate <class Type>\\nType* struzik_search(Type* array, size_t size, Type key) {\\n    uint32_t block_front(0), block_size = size == 0 ? 0 : 1;\\n    while (block_front != block_size) {\\n        if (*(array + block_size - 1) < key) {\\n            block_front = block_size;\\n            (block_size * 2 - 1 < size) ? (block_size *= 2) : block_size = size;\\n            continue;\\n        }\\n        return binary_s<Type>(array + block_front, (block_size - block_front),\\n                              key);\\n    }\\n    return nullptr;\\n}\\n\\n/** Main function */\\nint main() {\\n    // TEST CASES\\n    int* sorted_array = new int[7]{7, 10, 15, 23, 70, 105, 203};\\n    assert(struzik_search<int>(sorted_array, 7, 0) == nullptr);\\n    assert(struzik_search<int>(sorted_array, 7, 1000) == nullptr);\\n    assert(struzik_search<int>(sorted_array, 7, 50) == nullptr);\\n    assert(struzik_search<int>(sorted_array, 7, 7) == sorted_array);\\n    // TEST CASES\\n    delete[] sorted_array;\\n    return 0;\\n}\\n\"",
    "fibonacci search": "\"/**\\n * @author sprintyaf\\n * @file fibonacci_search.cpp\\n * @brief [Fibonacci search\\n * algorithm](https://en.wikipedia.org/wiki/Fibonacci_search_technique)\\n */\\n\\n#include <iostream>\\n#include <vector> // for std::vector class\\n#include <cassert> // for assert\\n#include <cstdlib> // for random numbers\\n#include <algorithm> // for sorting\\n\\n\\n\\n/**\\n * @brief using fibonacci search algorithm finds an index of a given element in a sorted array\\n * \\n * @param arr sorted array\\n * @param value value that we're looking for\\n * @returns if the array contains the value, returns an index of the element. otherwise -1.\\n */\\nint fibonacci_search(const std::vector<int> &arr, int value){\\n    // initialize last and current members of Fibonacci sequence \\n    int last = 0, current = 1;\\n    int length = arr.size(); // array size\\n    // next member of Fibonacci sequence which is \\\"last\\\" + \\\"current\\\"\\n    int next = last + current; \\n\\n    // \\\"next\\\" will store the smallest Fibonacci number greater or equal to \\\"length\\\"\\n    while(next < length){\\n        last = current;\\n        current = next;\\n        next = last + current;\\n    }\\n\\n    // \\\"offset\\\" is the end of eliminated range from front\\n    int offset = -1, index;\\n    // while loop until there are elements left to consider.\\n    // when \\\"next\\\" becomes 1, last is equal to 0, so search is done,\\n    // because arr[offset] will already be eliminated\\n    while(next > 1){\\n        // check if \\\"last\\\" is valid location\\n        index = std::min(offset + last, length-1);\\n        // if value is greater than the value at \\\"index\\\", eliminate the subarray from offset to index\\n        if(arr[index] < value){\\n            next = current;\\n            current = last;\\n            last = next - current;\\n            offset = index;\\n        // if value is less than the value at \\\"index\\\", eliminate the subarray after index+1\\n        } else if(arr[index] > value){\\n            next = last;\\n            current = current - last;\\n            last = next - current;\\n        // element is found\\n        } else {\\n            return index;\\n        }\\n    }\\n    // comparing the last element\\n    if(current && !arr.empty() && arr[offset+1] == value){\\n        return offset+1;\\n    }\\n    // value was not found, return -1\\n    return -1;\\n}\\n\\n/**\\n * @brief random tests for checking performance when an array doesn't contain an element\\n*/\\nbool no_occurence_tests(){\\n    bool passed = true;\\n    int rand_num, rand_value, index, num_tests = 1000;\\n    std::vector<int> arr;\\n    while(num_tests--){\\n        arr.clear();\\n        for(int i = 0; i < 100; i++){\\n            rand_num = std::rand() % 1000;\\n            arr.push_back(rand_num);\\n        }\\n        rand_value = std::rand() % 1000;\\n        while(std::find(arr.begin(), arr.end(), rand_value) != arr.end()){\\n            std::remove(arr.begin(), arr.end(), rand_value);\\n        }\\n        sort(arr.begin(), arr.end());\\n        index = fibonacci_search(arr, rand_value);\\n        passed = passed && (index == -1);\\n    }\\n    return passed;\\n}\\n\\n/**\\n * @brief random tests which cover cases when we have one, multiple or zero occurences of the value we're looking for\\n*/\\nbool random_tests(){\\n    bool passed = true;\\n    int rand_num, rand_value, index, real_value, num_tests = 10000;\\n    std::vector<int> arr;\\n    while(num_tests--){\\n        arr.clear();\\n        for(int i = 0; i < 100; i++){\\n            rand_num = std::rand() % 1000;\\n            arr.push_back(rand_num);\\n        }\\n        rand_value = std::rand() % 1000;\\n        std::sort(arr.begin(), arr.end());\\n        index = fibonacci_search(arr, rand_value);\\n        if(index != -1){\\n            real_value = arr[index];\\n            passed = passed && (real_value == rand_value);\\n        } else {\\n            passed = passed && (std::find(arr.begin(), arr.end(), rand_value) == arr.end());\\n        }\\n    }\\n    return passed;\\n}\\n\\n/**\\n * Main Function\\n * testing the algorithm\\n */\\nint main() {\\n    assert(no_occurence_tests());\\n    assert(random_tests());\\n    return 0;\\n}\\n\"",
    "floyd cycle detection algo": "\"/**\\n * @file\\n * @brief Implementation of [Floyd's Cycle\\n * Detection](https://en.wikipedia.org/wiki/Cycle_detection) algorithm\\n * @details\\n * Given an array of integers containing 'n + 1' integers, where each\\n * integer is in the range [1, n] inclusive. If there is only one duplicate\\n * number in the input array, this algorithm returns the duplicate number in\\n * O(1) space and the time complexity is less than O(n^2) without modifying the\\n * original array, otherwise, it returns -1.\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace search\\n * @brief Search algorithms\\n */\\nnamespace search {\\n/**\\n * @namespace cycle_detection\\n * @brief Functions for the [Floyd's Cycle\\n * Detection](https://en.wikipedia.org/wiki/Cycle_detection) algorithm\\n */\\nnamespace cycle_detection {\\n/**\\n * @brief The main function implements search algorithm\\n * @tparam T type of array\\n * @param in_arr the input array\\n * @param n size of array\\n * @returns the duplicate number\\n */\\ntemplate <typename T>\\nint32_t duplicateNumber(const std::vector<T> &in_arr, const uint32_t &n) {\\n    if (n == 0 ||\\n        n == 1) {  // to find duplicate in an array its size should be atleast 2\\n        return -1;\\n    }\\n    uint32_t tortoise = in_arr[0];  // variable tortoise is used for the longer\\n                                    // jumps in the array\\n    uint32_t hare =\\n        in_arr[0];  // variable hare is used for shorter jumps in the array\\n    do {\\n        tortoise = in_arr[tortoise];\\n        hare = in_arr[in_arr[hare]];\\n    } while (tortoise != hare);\\n    tortoise = in_arr[0];\\n    while (tortoise != hare) {\\n        tortoise = in_arr[tortoise];\\n        hare = in_arr[hare];\\n    }\\n    return tortoise;\\n}\\n}  // namespace cycle_detection\\n}  // namespace search\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st test\\n    // [3, 4, 8, 5, 9, 1, 2, 6, 7, 4] return 4\\n    std::vector<uint32_t> array1 = {3, 4, 8, 5, 9, 1, 2, 6, 7, 4};\\n    std::cout << \\\"Test 1... \\\";\\n    assert(search::cycle_detection::duplicateNumber(array1, array1.size()) ==\\n           4);  // here the duplicate number is 4\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 2nd test\\n    // [1, 2, 3, 4, 2] return 2\\n    std::vector<uint32_t> array2 = {1, 2, 3, 4, 2};\\n    std::cout << \\\"Test 2... \\\";\\n    assert(search::cycle_detection::duplicateNumber(array2, array2.size()) ==\\n           2);  // here the duplicate number is 2\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // 3rd test\\n    // [] return -1\\n    std::vector<uint32_t> array3 = {};\\n    std::cout << \\\"Test 3... \\\";\\n    assert(search::cycle_detection::duplicateNumber(array3, array3.size()) ==\\n           -1);  // since the input array is empty no duplicate number exists in\\n                 // this case\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "hash search": "\"/**\\n * \\\\file\\n * \\\\brief Hash Search Algorithm - Best Time Complexity Ω(1)\\n *\\n * \\\\copyright 2020 Arctic2333\\n *\\n * In this algorithm, we use the method of division and reservation remainder to\\n * construct the hash function, and use the method of chain address to solve the\\n * conflict, that is, we link a chain list after the data, and store all the\\n * records whose keywords are synonyms in the same linear chain list.\\n *\\n * @warning This program is only for educational purposes. It has serious flaws\\n * in implementation with regards to memory management resulting in large\\n * amounts of memory leaks.\\n * @todo fix the program for memory leaks and better structure in C++ and not C\\n * fashion\\n */\\n#include <cstdlib>\\n#include <iostream>\\n\\n#define MAX 6      ///< Determines how much data\\n#define HASHMAX 5  ///< Determines the length of the hash table\\n\\nint data[MAX] = {1, 10, 15, 5, 8, 7};  //!< test data\\n\\n/**\\n * a one-way linked list\\n */\\ntypedef struct list {\\n    int key;            //!< key value for node\\n    struct list* next;  //!< pointer to next link in the chain\\n} node,                 /**< define node as one item list */\\n    *link;              ///< pointer to nodes\\n\\nnode hashtab[HASHMAX];  ///< array of nodes\\n\\n// int counter = 1;\\n\\n/**\\n * Mode of hash detection :\\n * Division method\\n * \\\\param [in] key to hash\\n * \\\\returns hash value for `key`\\n */\\nint h(int key) { return key % HASHMAX; }\\n\\n/**\\n * The same after the remainder will be added after the same hash header\\n * To avoid conflict, zipper method is used\\n * Insert elements into the linked list in the header\\n * \\\\param [in] key key to add to list\\n * \\\\warning dynamic memory allocated to `n` never gets freed.\\n * \\\\todo fix memory leak\\n */\\nvoid create_list(int key) {  // Construct hash table\\n    link p, n;\\n    int index;\\n    n = (link)malloc(sizeof(node));\\n    n->key = key;\\n    n->next = NULL;\\n    index = h(key);\\n    p = hashtab[index].next;\\n    if (p != NULL) {\\n        n->next = p;\\n        hashtab[index].next = n;\\n    } else {\\n        hashtab[index].next = n;\\n    }\\n}\\n\\n/**\\n * Input the key to be searched, and get the hash header position through the H\\n * (int key) function, then one-dimensional linear search. If found @return\\n * element depth and number of searches If not found @return -1\\n */\\nint hash_search(int key, int* counter) {  // Hash lookup function\\n    link pointer;\\n    int index;\\n\\n    *counter = 0;\\n    index = h(key);\\n    pointer = hashtab[index].next;\\n\\n    std::cout << \\\"data[\\\" << index << \\\"]:\\\";\\n\\n    while (pointer != NULL) {\\n        counter[0]++;\\n        std::cout << \\\"data[\\\" << pointer->key << \\\"]:\\\";\\n        if (pointer->key == key)\\n            return 1;\\n        else\\n            pointer = pointer->next;\\n    }\\n\\n    return 0;\\n}\\n\\n/** main function */\\nint main() {\\n    link p;\\n    int key, index, i, counter;  // Key is the value to be found\\n    index = 0;\\n\\n    // You can write the input mode here\\n    while (index < MAX) {  // Construct hash table\\n        create_list(data[index]);\\n        index++;\\n    }\\n\\n    for (i = 0; i < HASHMAX; i++) {  // Output hash table\\n        std::cout << \\\"hashtab [\\\" << i << \\\"]\\\\n\\\";\\n\\n        p = hashtab[i].next;\\n\\n        while (p != NULL) {\\n            std::cout << \\\"please int key:\\\";\\n            if (p->key > 0)\\n                std::cout << \\\"[\\\" << p->key << \\\"]\\\";\\n            p = p->next;\\n        }\\n        std::cout << std::endl;\\n    }\\n\\n    while (key != -1) {\\n        // You can write the input mode here\\n        // test key = 10\\n        key = 10;\\n        if (hash_search(key, &counter))\\n            std::cout << \\\"search time = \\\" << counter << std::endl;\\n        else\\n            std::cout << \\\"no found!\\\\n\\\";\\n        key = -1;  // Exit test\\n        /* The test sample is returned as:\\n         * data[0]:data[5]:data[15]:data[10]:search time = 3 The search is\\n         * successful. There are 10 in this set of data */\\n    }\\n\\n    return 0;\\n}\\n\"",
    "interpolation search": "\"/**\\n * \\\\file\\n * \\\\brief [Interpolation\\n * search](https://en.wikipedia.org/wiki/Interpolation_search) algorithm\\n */\\n#include <iostream>\\n\\n/** function to search the value in an array using interpolation search\\n * \\\\param [in] arr array to search in\\n * \\\\param [in] value value to search for\\n * \\\\param [in] len length of array\\n * \\\\returns index where the value is found\\n * \\\\returns 0 if not found\\n */\\nint interpolation_search(int arr[], int value, int len) {\\n    int low = 0, high, mid;\\n    high = len - 1;\\n\\n    while (arr[low] <= value && arr[high] >= value) {\\n        mid = (low +\\n               ((value - arr[low]) * (high - low)) / (arr[high] - arr[low]));\\n        if (arr[mid] > value)\\n            high = mid - 1;\\n        else if (arr[mid] < value)\\n            low = mid + 1;\\n        else\\n            return mid;\\n    }\\n\\n    if (arr[low] == value)\\n        return low;\\n\\n    return -1;\\n}\\n\\n/** main function */\\nint main() {\\n    int n, value, re;\\n\\n    std::cout << \\\"Enter the size of array(less than 100) : \\\";\\n    std::cin >> n;\\n\\n    int *array = new int[n];\\n\\n    std::cout << \\\"array in ascending (increasing) order : \\\" << std::endl;\\n\\n    for (int i = 0; i < n; i++) std::cin >> array[i];\\n\\n    std::cout << \\\"Enter the value you want to search : \\\";\\n    std::cin >> value;\\n\\n    re = interpolation_search(array, value, n);\\n\\n    if (re == -1)\\n        std::cout << \\\"Entered value is not in the array\\\" << std::endl;\\n    else\\n        std::cout << \\\"The value is at the position \\\" << re << std::endl;\\n\\n    delete[] array;\\n    return 0;\\n}\\n\"",
    "interpolation search2": "\"/**\\r\\n * \\\\file\\r\\n * \\\\brief [Interpolation\\r\\n * search](https://en.wikipedia.org/wiki/Interpolation_search) algorithm\\r\\n */\\r\\n#include <iostream>\\r\\n\\r\\n/** function to search the value in an array using interpolation search\\r\\n * \\\\param [in] arr array to search in\\r\\n * \\\\param [in] value value to search for\\r\\n * \\\\param [in] len length of array\\r\\n * \\\\returns index where the value is found\\r\\n * \\\\returns -1 if not found\\r\\n */\\r\\nint InterpolationSearch(int A[], int n, int x) {\\r\\n    int low = 0;\\r\\n    int high = n - 1;\\r\\n    while (low <= high) {\\r\\n        int mid = low + (((high - 1) * (x - A[low])) / (A[high] - A[low]));\\r\\n        if (x == A[mid])\\r\\n            return mid;  // Found x, return (exit)\\r\\n        else if (x < A[mid])\\r\\n            high = mid - 1;  // X lies before mid\\r\\n        else\\r\\n            low = mid + 1;  // x lies after mid\\r\\n    }\\r\\n\\r\\n    return -1;\\r\\n}\\r\\n\\r\\n/** main function */\\r\\nint main() {\\r\\n    int A[] = {2, 4, 5, 7, 13, 14, 15, 23};\\r\\n    int x = 17;\\r\\n\\r\\n    ///< passed array A inside the InterpolationSearch function\\r\\n    int index = InterpolationSearch(A, 8, x);\\r\\n    if (index < 0)\\r\\n        std::cout << \\\"Number \\\" << x << \\\" not found\\\" << std::endl;\\r\\n    else\\r\\n        std::cout << \\\"Number \\\" << x << \\\" is at \\\" << index << std::endl;\\r\\n}\\r\\n\\r\\n// randomly set x bcoz array was defined by us , therefore not reasonable for\\r\\n// asking input. We could have asked for input if array elements were inputed by\\r\\n// the user.\\r\\n\"",
    "jump search": "\"/**\\n * \\\\file\\n * \\\\brief C++ program to implement [Jump\\n * Search](https://en.wikipedia.org/wiki/Jump_search)\\n */\\n#include <algorithm>\\n#include <cmath>\\n#include <iostream>\\n\\n/** jump search implementation\\n */\\nint jumpSearch(int arr[], int x, int n) {\\n    // Finding block size to be jumped\\n    int step = std::sqrt(n);\\n\\n    // Finding the block where element is\\n    // present (if it is present)\\n    int prev = 0;\\n    while (arr[std::min(step, n) - 1] < x) {\\n        prev = step;\\n        step += std::sqrt(n);\\n        if (prev >= n)\\n            return -1;\\n    }\\n\\n    // Doing a linear search for x in block\\n    // beginning with prev.\\n    while (arr[prev] < x) {\\n        prev++;\\n\\n        // If we reached next block or end of\\n        // array, element is not present.\\n        if (prev == std::min(step, n))\\n            return -1;\\n    }\\n    // If element is found\\n    if (arr[prev] == x)\\n        return prev;\\n\\n    return -1;\\n}\\n\\n// Driver program to test function\\nint main() {\\n    int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610};\\n    int x = 55;\\n    int n = sizeof(arr) / sizeof(arr[0]);\\n\\n    // Find the index of 'x' using Jump Search\\n    int index = jumpSearch(arr, x, n);\\n\\n    // Print the index where 'x' is located\\n    std::cout << \\\"\\\\nNumber \\\" << x << \\\" is at index \\\" << index;\\n    return 0;\\n}\\n\"",
    "linear search": "\"/**\\n * \\\\file\\n * \\\\brief [Linear search\\n * algorithm](https://en.wikipedia.org/wiki/Linear_search)\\n */\\n#include <iostream>\\n\\n/**\\n * Algorithm implementation\\n * \\\\param [in] array array to search in\\n * \\\\param [in] size length of array\\n * \\\\param [in] key key value to search for\\n * \\\\returns index where the key-value occurs in the array\\n * \\\\returns -1 if key-value not found\\n */\\nint LinearSearch(int *array, int size, int key) {\\n    for (int i = 0; i < size; ++i) {\\n        if (array[i] == key) {\\n            return i;\\n        }\\n    }\\n\\n    return -1;\\n}\\n\\n/** main function */\\nint main() {\\n    int size;\\n    std::cout << \\\"\\\\nEnter the size of the Array : \\\";\\n    std::cin >> size;\\n\\n    int *array = new int[size];\\n    int key;\\n\\n    // Input array\\n    std::cout << \\\"\\\\nEnter the Array of \\\" << size << \\\" numbers : \\\";\\n    for (int i = 0; i < size; i++) {\\n        std::cin >> array[i];\\n    }\\n\\n    std::cout << \\\"\\\\nEnter the number to be searched : \\\";\\n    std::cin >> key;\\n\\n    int index = LinearSearch(array, size, key);\\n    if (index != -1) {\\n        std::cout << \\\"\\\\nNumber found at index : \\\" << index;\\n    } else {\\n        std::cout << \\\"\\\\nNot found\\\";\\n    }\\n\\n    delete[] array;\\n    return 0;\\n}\\n\"",
    "median search": "\"/**\\n * @file median_search.cpp\\n * @brief Implementation of [Median search](https://en.wikipedia.org/wiki/Median_of_medians) algorithm.\\n * @cases from [here](https://brilliant.org/wiki/median-finding-algorithm/)\\n *\\n * @details\\n * Given an array A[1,...,n] of n numbers and an index i, where 1 ≤ i ≤ n, find the i-th smallest element of A.\\n * median_of_medians(A, i):\\n *  #divide A into sublists of len 5\\n *  sublists = [A[j:j+5] for j in range(0, len(A), 5)]\\n *  medians = [sorted(sublist)[len(sublist)/2] for sublist in sublists]\\n *  if len(medians) <= 5:\\n *\\tpivot = sorted(medians)[len(medians)/2]\\n *  else:\\n *      #the pivot is the median of the medians\\n *      pivot = median_of_medians(medians, len(medians)/2)\\n *  #partitioning step\\n *  low = [j for j in A if j < pivot]\\n *  high = [j for j in A if j > pivot]\\n *  k = len(low)\\n *   if i < k:\\n *      return median_of_medians(low,i)\\n *   elif i > k:\\n *      return median_of_medians(high,i-k-1)\\n *  else: #pivot = k\\n *       return pivot\\n *\\n * \\\\note this algorithm implements median search for only arrays which have distinct elements\\n *\\n * Here are some example lists you can use to see how the algorithm works\\n * A = [1,2,3,4,5,1000,8,9,99] (Contain Unique Elements)\\n * B = [1,2,3,4,5,6] (Contains Unique Elements)\\n * print median_of_medians(A, 0) #should be 1\\n * print median_of_medians(A,7) #should be 99\\n * print median_of_medians(B,4) #should be 5\\n *\\n * @author Unknown author\\n * @author [Sushil Kumar](https://github.com/Rp-sushil)\\n */\\n\\n#include <iostream>\\n#include <algorithm>\\n#include <vector>\\n#include <cassert>\\n\\n/**\\n * @namespace search\\n * @brief Search algorithms\\n */\\nnamespace search {\\n/**\\n * @namespace median_search\\n * @brief Functions for [Median search](https://en.wikipedia.org/wiki/Median_search) algorithm\\n */\\nnamespace median_search {\\n/**\\n* This function search the element in an array for the given index.\\n* @param A array where numbers are saved\\n* @param idx current index in array\\n* @returns corresponding element which we want to search.\\n*/  \\nint median_of_medians(const std::vector<int>& A,  const int& idx) {\\n\\tint pivot = 0;\\t\\t\\t\\t\\t// initialized with zero\\n\\tstd::vector<int> a(A.begin(), A.end());\\n\\tstd::vector<int> m;\\n\\tint r = a.size();\\n\\tfor(int i = 0; i < r; i += 5){\\n\\t\\tstd::sort(a.begin() + i, a.begin() + std::min(r, i + 5));\\n\\t\\tint mid = (i + std::min(r, i + 5)) / 2;\\n\\t\\tm.push_back(a[mid]);\\n\\t}\\n\\tint sz = int(m.size());\\n\\tif(sz <= 5){\\n\\t\\tstd::sort(m.begin(), m.end());\\n\\t\\tpivot = m[(sz- 1) / 2];\\n\\t}\\n\\telse{\\n\\t\\tpivot = median_of_medians(m, idx);\\n\\t}\\n\\tstd::vector<int> low;\\n\\tstd::vector<int> high;\\n\\tfor(int i = 0; i < r; i++){\\n\\t\\tif(a[i] < pivot){\\n\\t\\t\\tlow.push_back(a[i]);\\n\\t\\t}\\n\\t\\telse if(a[i] > pivot){\\n\\t\\t\\thigh.push_back(a[i]);\\n\\t\\t}\\n\\t}\\n\\tint k = int(low.size());\\n\\tif(idx < k){\\n\\t\\treturn median_of_medians(low, idx);\\n\\t}\\n\\telse if(idx > k){\\n\\t\\treturn median_of_medians(high, idx-k-1);\\n\\t}\\n\\telse{\\n\\t\\treturn pivot;\\n\\t}\\n}\\n}  // namespace median_search\\n}  // namespace search\\n\\n/**\\n * Function to test above algorithm\\n */\\nvoid test(){\\n\\tstd::vector<int> A{25,21,98,100,76,22,43,60,89,87};\\n\\tint i = 3;\\n\\tassert(A[6] == search::median_search::median_of_medians(A, i));\\t\\t// A[6]  = 43, is the fourth smallest element.\\n\\tstd::cout << \\\"test case:1 passed\\\\n\\\";\\n\\t\\n\\tstd::vector<int> B{1,2,3,4,5,6};\\n\\tint j = 4;\\n\\tassert(B[4] == search::median_search::median_of_medians(B, j));\\t\\t// B[4] = 5, is the fifth smallest element.\\n\\tstd::cout << \\\"test case:2 passed\\\\n\\\";\\n\\t\\n\\tstd::vector<int> C{1,2,3,4,5,1000,8,9,99};\\n\\tint k = 3;\\n\\tassert(C[3] == search::median_search::median_of_medians(C, k)); \\t// C[3] = 4, is the fourth smallest element.\\n\\tstd::cout << \\\"test case:3 passed\\\\n\\\";\\n\\tstd::cout << \\\"--All tests passed--\\\\n\\\";\\n}\\n\\n/**\\n * Main function\\n */\\nint main()\\n{\\n\\ttest();\\n\\tint n = 0;\\n\\tstd::cout << \\\"Enter Size of Array: \\\";\\n\\tstd::cin >> n;\\n\\tstd::vector<int> a(n);\\n\\tstd::cout << \\\"Enter Array: \\\";\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tstd::cin >> a[i];\\n\\t}\\n\\tstd::cout << \\\"Median: \\\";\\t\\t\\t// Median defination: https://en.wikipedia.org/wiki/Median\\n\\tint x = search::median_search::median_of_medians(a,  (n - 1) / 2);\\n\\tif(n % 2 == 0){\\n\\t\\tint y = search::median_search::median_of_medians(a, n / 2);\\n\\t\\tstd::cout << (float(x) + float(y))/2.0;\\n\\t}\\n\\telse{\\n\\t\\tstd::cout << x;\\n\\t}\\n\\tstd::cout << \\\"\\\\nTo find i-th smallest element \\\";\\n       \\tstd::cout << \\\"\\\\nEnter i: \\\";\\n\\tint idx = 0;\\n\\tstd::cin >> idx;\\n\\tidx--;\\n\\tstd::cout << idx + 1<< \\\"-th smallest element: \\\" << search::median_search::median_of_medians(a, idx) << '\\\\n';\\n\\treturn 0;\\n}\\n\\n\"",
    "saddleback search": "\"/**\\n * @file\\n * @brief Implementation of [Saddleback Algorithm](https://www.geeksforgeeks.org/saddleback-search-algorithm-in-a-2d-array) for 2D arrays.\\n *\\n * @details\\n * Saddleback Algorithm is an algorithm that searches 2D array in linear time,\\n * i.e, O(m + n), where m is number of rows and n is number of columns of 2D array. Also, each row and\\n * column of the matrix should be sorted beforehand for this algorithm to work.\\n *\\n * @author [Hashir Niazi](https://github.com/HashirGJ8842)\\n */\\n#include <cassert>      /// for assert\\n#include <iostream>     /// for io operations, and std::pair\\n#include <vector>       /// for std::vector\\n\\n/** \\\\namespace search\\n * \\\\brief Algorithms for searching\\n */\\nnamespace search {\\n/** \\\\namespace saddleback\\n * \\\\brief Function for implementing [Saddleback Algorithm](https://www.geeksforgeeks.org/saddleback-search-algorithm-in-a-2d-array).\\n */\\nnamespace saddleback {\\n/**\\n * This function implements [Saddleback Algorithm](https://www.geeksforgeeks.org/saddleback-search-algorithm-in-a-2d-array),\\n * on a sorted 2D array, and finds the location of the element needed to search\\n * @param matrix 2D matrix which is sorted on the basis of rows and columns\\n * @param element element to be searched\\n * @return An std::pair of with row and column populated within it, if the\\n * element is present.\\n * @return An std::pair with (0, 0), if the element is not present.\\n */\\nstd::pair<uint32_t, uint32_t> saddleback(std::vector<std::vector<int32_t>> matrix,\\n                               int32_t element) {\\n    uint32_t left_index = 0;\\n    uint32_t right_index = matrix[0].size() - 1;  // Start from top right corner\\n    while (left_index < matrix.size()) {  // Exit once the value of indexes get out of range.\\n        if (element ==\\n            matrix[left_index]\\n                  [right_index]) {  // If value on this position of matrix is\\n                                    // equal to element, return (row, column).\\n            return std::make_pair(left_index+1, right_index+1);\\n        } else if (element >\\n                   matrix[left_index]\\n                         [right_index]) {  // Else if value on this position of\\n                                           // matrix is less than the element,\\n                                           // move left.\\n            ++left_index;\\n        } else if (element <\\n                   matrix[left_index]\\n                         [right_index]) {  // Else if value on this position of\\n                                           // matrix is greater than the\\n                                           // element, move down.\\n            if(!right_index)\\n                break;\\n            else --right_index;\\n        }\\n    }\\n    return std::make_pair(\\n        0, 0);  // If the program reaches here, that means one of the index\\n                  // went out of index, hence no element present.\\n}\\n}  // namespace saddleback\\n}  // namespace search\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    std::vector<std::vector<int32_t>> matrix = {{1, 10, 100, 1000, 10000},\\n                                            {2, 20, 200, 2000, 20000},\\n                                            {3, 30, 300, 3000, 30000},\\n                                            {4, 40, 400, 4000, 40000},\\n                                            {5, 50, 500, 5000, 50000}};\\n\\n    std::pair<uint32_t, uint32_t> not_found = std::make_pair(0, 0);\\n    std::pair<uint32_t, uint32_t> test_answer;\\n    // Test 1\\n    std::pair<uint32_t, uint32_t> answer1 = search::saddleback::saddleback(matrix, 123);\\n    assert(not_found == answer1);\\n    // Test 2\\n    answer1 = search::saddleback::saddleback(matrix, 0);\\n    assert(not_found == answer1);\\n    // Test 3\\n    answer1 = search::saddleback::saddleback(matrix, 1);\\n    test_answer = std::make_pair(1, 1);\\n    assert(test_answer == answer1);\\n    // Test 4\\n    answer1 = search::saddleback::saddleback(matrix, 50000);\\n    test_answer = std::make_pair(5, 5);\\n    assert(test_answer == answer1);\\n    // Test 5\\n    answer1 = search::saddleback::saddleback(matrix, 300);\\n    test_answer = std::make_pair(3, 3);\\n    assert(test_answer == answer1);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();     // execute the tests\\n    return 0;\\n}\\n\"",
    "sublist search": "\"/**\\n * @file\\n * @brief Implementation of the [Sublist Search\\n * Algorithm](https://www.geeksforgeeks.org/sublist-search-search-a-linked-list-in-another-list)\\n * @details\\n *\\n * ### Algorithm\\n *\\n *  * Sublist search is used to detect a presence of one list in another list.\\n *  * Suppose we have a single-node list (let's say the first list), and we\\n *  want to ensure that the list is present in another list (let's say the\\n * second list), then we can perform the sublist search to find it.\\n *\\n *  * For instance, the first list contains these elements: 23 -> 30 -> 41,\\n *  and the second list contains these elements: 10 -> 15 -> 23 -> 30 -> 41\\n *  -> 49. At a glance, we see that the first list presents in the second list.\\n *\\n * ### Working\\n *\\n *  * The sublist search algorithm works by comparing the first element\\n *  of the first list with the first element of the second list.\\n *  * If the two values don't match, it goes to the next element of the\\n *  second list. It does this until the two values match.\\n *\\n * @author [Nitin Sharma](https://github.com/foo290)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace search\\n * @brief Searching algorithms\\n */\\nnamespace search {\\n/**\\n * @namespace sublist_search\\n * @brief Functions for the [Sublist\\n * Search](https://www.geeksforgeeks.org/sublist-search-search-a-linked-list-in-another-list)\\n * implementation\\n */\\nnamespace sublist_search {\\n/**\\n * @brief A Node structure representing a single link Node in a linked list\\n */\\nstruct Node {\\n    uint32_t data = 0;  ///< the key/value of the node\\n    Node *next{};       ///< pointer to the next node\\n};\\n\\n/**\\n * @brief A simple function to print the linked list\\n * @param start The head of the linked list\\n * @returns void\\n */\\nvoid printLinkedList(Node *start) {\\n    while (start != nullptr) {\\n        std::cout << \\\"->\\\" << start->data;\\n        start = start->next;\\n    }\\n    std::cout << std::endl;\\n}\\n\\n/**\\n * @brief Give a vector of data,\\n * it adds each element of vector in the linked list and return the address of\\n * head pointer.\\n * @param data A vector of \\\"int\\\" containing the data that is supposed to be\\n * stored in nodes of linked list.\\n * @returns Node* A head pointer to the linked list.\\n */\\nNode *makeLinkedList(const std::vector<uint64_t> &data) {\\n    /// This is used in test cases for rapidly creating linked list with 100+\\n    /// elements, instead of hard-coding 100 elements in test cases.\\n    Node *head = nullptr;\\n    Node *tail = nullptr;\\n    for (int i : data) {\\n        Node *node = new Node;\\n        node->data = i;\\n        node->next = nullptr;\\n        if (head == nullptr) {\\n            head = node;\\n            tail = node;\\n        } else {\\n            tail->next = node;\\n            tail = tail->next;\\n        }\\n    }\\n    return head;\\n}\\n\\n/**\\n * @brief Main searching function\\n * @param sublist A linked list which is supposed to be searched in mainList.\\n * @param mainList A linked list in which sublist will be searched.\\n * @returns true if the sublist is found\\n * @returns false if the sublist is NOT found\\n */\\nbool sublistSearch(Node *sublist, Node *mainList) {\\n    if (sublist == nullptr || mainList == nullptr) {\\n        return false;\\n    }\\n\\n    /// Initialize target pointer to the head node of sublist.\\n    Node *target_ptr = sublist;\\n\\n    while (mainList != nullptr) {\\n        /// Initialize main pointer to the current node of main list.\\n        Node *main_ptr = mainList;\\n\\n        while (target_ptr != nullptr) {\\n            if (main_ptr == nullptr) {\\n                return false;\\n\\n            } else if (main_ptr->data == target_ptr->data) {\\n                /// If the data of target node and main node is equal then move\\n                /// to the next node of both lists.\\n                target_ptr = target_ptr->next;\\n                main_ptr = main_ptr->next;\\n\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        if (target_ptr == nullptr) {\\n            /// Is target pointer becomes null that means the target list is\\n            /// been traversed without returning false. Which means the sublist\\n            /// has been found and return ture.\\n            return true;\\n        }\\n\\n        /// set the target pointer again to stating point of target list.\\n        target_ptr = sublist;\\n\\n        /// set the main pointer to the next element of the main list and repeat\\n        /// the algo.\\n        mainList = mainList->next;\\n    }\\n\\n    /// If the main list is exhausted, means sublist does not found, return\\n    /// false\\n    return false;\\n}\\n\\n}  // namespace sublist_search\\n}  // namespace search\\n\\n/**\\n * @brief class encapsulating the necessary test cases\\n */\\nclass TestCases {\\n private:\\n    /**\\n     * @brief A function to print given message on console.\\n     * @tparam T Type of the given message.\\n     * @returns void\\n     * */\\n    template <typename T>\\n    void log(T msg) {\\n        // It's just to avoid writing cout and endl\\n        std::cout << \\\"[TESTS] : ---> \\\" << msg << std::endl;\\n    }\\n\\n public:\\n    /**\\n     * @brief Executes test cases\\n     * @returns void\\n     * */\\n    void runTests() {\\n        log(\\\"Running Tests...\\\");\\n\\n        testCase_1();\\n        testCase_2();\\n        testCase_3();\\n\\n        log(\\\"Test Cases over!\\\");\\n        std::cout << std::endl;\\n    }\\n\\n    /**\\n     * @brief A test case contains edge case, Only contains one element.\\n     * @returns void\\n     * */\\n    void testCase_1() {\\n        const bool expectedOutput = true;  ///< Expected output of this test\\n\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n        log(\\\"This is test case 1 for sublist search Algorithm : \\\");\\n        log(\\\"Description:\\\");\\n        log(\\\"   EDGE CASE : Only contains one element\\\");\\n\\n        std::vector<uint64_t> sublistData = {\\n            6};  ///< Data to make linked list which will be the sublist\\n        std::vector<uint64_t> mainlistData = {\\n            2, 5, 6, 7,\\n            8};  ///< Data to make linked list which will be the main list\\n\\n        search::sublist_search::Node *sublistLL =\\n            search::sublist_search::makeLinkedList(\\n                sublistData);  ///< Sublist to be searched\\n        search::sublist_search::Node *mainlistLL =\\n            search::sublist_search::makeLinkedList(\\n                mainlistData);  ///< Main list in which sublist is to be\\n                                ///< searched\\n\\n        bool exists = search::sublist_search::sublistSearch(\\n            sublistLL, mainlistLL);  ///< boolean, if sublist exist or not\\n\\n        log(\\\"Checking assert expression...\\\");\\n        assert(exists == expectedOutput);\\n        log(\\\"Assertion check passed!\\\");\\n\\n        log(\\\"[PASS] : TEST CASE 1 PASS!\\\");\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n\\n        delete (sublistLL);\\n        delete (mainlistLL);\\n    }\\n\\n    /**\\n     * @brief A test case which contains main list of 100 elements and sublist\\n     * of 20.\\n     * @returns void\\n     * */\\n    void testCase_2() {\\n        const bool expectedOutput = true;  /// Expected output of this test\\n\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n        log(\\\"This is test case 2 for sublist search Algorithm : \\\");\\n        log(\\\"Description:\\\");\\n        log(\\\"   contains main list of 100 elements and sublist of 20\\\");\\n\\n        std::vector<uint64_t> sublistData(\\n            20);  ///< Data to make linked list which will be the sublist\\n        std::vector<uint64_t> mainlistData(\\n            100);  ///< Main list in which sublist is to be searched\\n\\n        for (int i = 0; i < 100; i++) {\\n            /// Inserts 100 elements in main list\\n            mainlistData[i] = i + 1;\\n        }\\n\\n        int temp = 0;\\n        for (int i = 45; i < 65; i++) {\\n            /// Inserts 20 elements in sublist\\n            sublistData[temp] = i + 1;\\n            temp++;\\n        }\\n\\n        search::sublist_search::Node *sublistLL =\\n            search::sublist_search::makeLinkedList(\\n                sublistData);  ///< Sublist to be searched\\n        search::sublist_search::Node *mainlistLL =\\n            search::sublist_search::makeLinkedList(\\n                mainlistData);  ///< Main list in which sublist is to be\\n                                ///< searched\\n\\n        bool exists = search::sublist_search::sublistSearch(\\n            sublistLL, mainlistLL);  ///< boolean, if sublist exist or not\\n\\n        log(\\\"Checking assert expression...\\\");\\n        assert(exists == expectedOutput);\\n        log(\\\"Assertion check passed!\\\");\\n\\n        log(\\\"[PASS] : TEST CASE 2 PASS!\\\");\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n    }\\n\\n    /**\\n     * @brief A test case which contains main list of 50 elements and sublist\\n     * of 20.\\n     * @returns void\\n     * */\\n    void testCase_3() {\\n        const bool expectedOutput = false;  ///< Expected output of this test\\n\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n        log(\\\"This is test case 3 for sublist search Algorithm : \\\");\\n        log(\\\"Description:\\\");\\n        log(\\\"   contains main list of 50 elements and sublist of 20\\\");\\n\\n        std::vector<uint64_t> sublistData(20);  ///< Sublist to be searched\\n        std::vector<uint64_t> mainlistData(\\n            50);  ///< Main list in which sublist is to be searched\\n\\n        for (int i = 0; i < 50; i++) {\\n            /// Inserts 100 elements in main list\\n            mainlistData.push_back(i + 1);\\n        }\\n\\n        for (int i = 45; i < 65; i++) {\\n            /// Inserts 20 elements in sublist\\n            sublistData.push_back(i + 1);\\n        }\\n\\n        search::sublist_search::Node *sublistLL =\\n            search::sublist_search::makeLinkedList(\\n                sublistData);  ///< Sublist to be searched\\n        search::sublist_search::Node *mainlistLL =\\n            search::sublist_search::makeLinkedList(\\n                mainlistData);  ///< Main list in which sublist is to be\\n                                ///< searched\\n\\n        bool exists = search::sublist_search::sublistSearch(\\n            sublistLL, mainlistLL);  ///< boolean, if sublist exist or not\\n\\n        log(\\\"Checking assert expression...\\\");\\n        assert(exists == expectedOutput);\\n        log(\\\"Assertion check passed!\\\");\\n\\n        log(\\\"[PASS] : TEST CASE 3 PASS!\\\");\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n    }\\n};\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    TestCases tc;\\n    tc.runTests();\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, char *argv[]) {\\n    test();  // run self-test implementations\\n\\n    std::vector<uint64_t> mainlistData = {\\n        2, 5, 6, 7, 8};  ///< Main list in which sublist is to be searched\\n    std::vector<uint64_t> sublistData = {6, 8};  ///< Sublist to be searched\\n\\n    search::sublist_search::Node *mainlistLL =\\n        search::sublist_search::makeLinkedList(mainlistData);\\n    search::sublist_search::Node *sublistLL =\\n        search::sublist_search::makeLinkedList(\\n            sublistData);  ///< Main list in which sublist is to be\\n                           ///< searched\\n\\n    bool exists = search::sublist_search::sublistSearch(\\n        sublistLL,\\n        mainlistLL);  ///< boolean to check if the sublist exists or not\\n\\n    std::cout << \\\"Sublist: \\\" << std::endl;\\n    search::sublist_search::printLinkedList(sublistLL);\\n\\n    std::cout << \\\"Main list: \\\" << std::endl;\\n    search::sublist_search::printLinkedList(mainlistLL);\\n    std::cout << std::endl;\\n\\n    if (exists) {\\n        std::cout << \\\"[TRUE] - sublist found in main list\\\\n\\\";\\n    } else {\\n        std::cout << \\\"[FALSE] - sublist NOT found in main list\\\\n\\\";\\n    }\\n    return 0;\\n}\\n\"",
    "ternary search": "\"/**\\n * \\\\file\\n * \\\\brief [Ternary search](https://en.wikipedia.org/wiki/Ternary_search)\\n * algorithm\\n *\\n * This is a divide and conquer algorithm.\\n * It does this by dividing the search space by 3 parts and\\n * using its property (usually monotonic property) to find\\n * the desired index.\\n *\\n * * Time Complexity : O(log3 n)\\n * * Space Complexity : O(1) (without the array)\\n */\\n\\n#include <iostream>\\n\\n/**\\n * The absolutePrecision can be modified to fit preference but\\n * it is recommended to not go lower than 10 due to errors that\\n * may occur.\\n */\\n#define absolutePrecision 10\\n/**\\n * The value of _target should be decided or can be decided later\\n * by using the variable of the function.\\n */\\n#define _target 10\\n\\n#define MAX 10000000  ///< Maximum length of array\\n\\n/**\\n * get_input function is to receive input from standard IO\\n * @todo @christianbender Get input from STDIO or write input to memory as done\\n * above.\\n */\\nvoid get_input() {}\\n\\n/**\\n * This is the iterative method of the ternary search which returns the index of\\n * the element.\\n * \\\\param[in] left lower interval limit\\n * \\\\param[in] right upper interval limit\\n * \\\\param[in] A array to search in\\n * \\\\param[in] target value to search for\\n * \\\\returns index where the target value was found\\n * \\\\returns -1 if target value not found\\n */\\nint it_ternary_search(int left, int right, int A[], int target) {\\n    while (1) {\\n        if (left < right) {\\n            if (right - left < absolutePrecision) {\\n                for (int i = left; i <= right; i++)\\n                    if (A[i] == target)\\n                        return i;\\n\\n                return -1;\\n            }\\n\\n            int oneThird = (left + right) / 3 + 1;\\n            int twoThird = (left + right) * 2 / 3 + 1;\\n\\n            if (A[oneThird] == target)\\n                return oneThird;\\n            else if (A[twoThird] == target)\\n                return twoThird;\\n\\n            else if (target > A[twoThird])\\n                left = twoThird + 1;\\n            else if (target < A[oneThird])\\n                right = oneThird - 1;\\n\\n            else\\n                left = oneThird + 1, right = twoThird - 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n\\n/**\\n * This is the recursive method of the ternary search which returns the index of\\n * the element.\\n * \\\\param[in] left lower interval limit\\n * \\\\param[in] right upper interval limit\\n * \\\\param[in] A array to search in\\n * \\\\param[in] target value to search for\\n * \\\\returns index where the target value was found\\n * \\\\returns -1 if target value not found\\n */\\nint rec_ternary_search(int left, int right, int A[], int target) {\\n    if (left < right) {\\n        if (right - left < absolutePrecision) {\\n            for (int i = left; i <= right; i++)\\n                if (A[i] == target)\\n                    return i;\\n\\n            return -1;\\n        }\\n\\n        int oneThird = (left + right) / 3 + 1;\\n        int twoThird = (left + right) * 2 / 3 + 1;\\n\\n        if (A[oneThird] == target)\\n            return oneThird;\\n        if (A[twoThird] == target)\\n            return twoThird;\\n\\n        if (target < A[oneThird])\\n            return rec_ternary_search(left, oneThird - 1, A, target);\\n        if (target > A[twoThird])\\n            return rec_ternary_search(twoThird + 1, right, A, target);\\n\\n        return rec_ternary_search(oneThird + 1, twoThird - 1, A, target);\\n    } else {\\n        return -1;\\n    }\\n}\\n\\n/**\\n * ternary_search is a template function\\n * You could either use it_ternary_search or rec_ternary_search according to\\n * preference.\\n * \\\\param [in] N length of array\\n * \\\\param[in] A array to search in\\n * \\\\param[in] target value to search for\\n */\\nvoid ternary_search(int N, int A[], int target) {\\n    std::cout << it_ternary_search(0, N - 1, A, target) << '\\\\t';\\n    std::cout << rec_ternary_search(0, N - 1, A, target) << '\\\\t';\\n    std::cout << std::endl;\\n}\\n\\n/** Main function */\\nint main() {\\n    int N = 21;\\n    int A[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 10};\\n    get_input();\\n    ternary_search(N, A, _target);\\n    return 0;\\n}\\n\"",
    "text search": "\"/**\\r\\n * \\\\file\\r\\n * \\\\brief Search for words in a long textual paragraph.\\r\\n */\\r\\n#include <cassert>\\r\\n#include <cstdlib>\\r\\n#include <iostream>\\r\\n#ifdef _MSC_VER\\r\\n#include <string>  // required for MS Visual C++\\r\\n#else\\r\\n#include <cstring>\\r\\n#endif\\r\\n\\r\\n/**\\r\\n * @brief function to convert a C++ string to lower case\\r\\n * @param word takes an std::string as input\\r\\n * @returns std::string\\r\\n */\\r\\nstd::string lower(std::string word) {\\r\\n    int length = word.length();\\r\\n    std::string lc = \\\"\\\";\\r\\n\\r\\n    for (int i = 0; i < length; i++) {\\r\\n        lc += tolower(word[i]);\\r\\n    }\\r\\n\\r\\n    return lc;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Self-test implementations\\r\\n * @returns void\\r\\n */\\r\\nstatic void test() {\\r\\n    assert(lower(\\\"abcd\\\").compare(\\\"abcd\\\") == 0);\\r\\n    assert(lower(\\\"abc\\\").compare(\\\"abcd\\\") == -1);\\r\\n    assert(lower(\\\"abcd\\\").compare(\\\"abc\\\") == 1);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @brief Main function\\r\\n * @returns 0 on exit\\r\\n */\\r\\nint main() {\\r\\n    test();  // run self-test implementations\\r\\n    std::string paragraph;\\r\\n    std::cout << \\\"Please enter your paragraph: \\\\n\\\";\\r\\n    std::getline(std::cin, paragraph);\\r\\n    std::cout << \\\"\\\\nHello, your paragraph is:\\\\n \\\" << paragraph << \\\"!\\\\n\\\";\\r\\n    std::cout << \\\"\\\\nThe size of your paragraph = \\\" << paragraph.size()\\r\\n              << \\\" characters. \\\\n\\\\n\\\";\\r\\n\\r\\n    if (paragraph.empty()) {\\r\\n        std::cout << \\\"\\\\nThe paragraph is empty\\\" << std::endl;\\r\\n    } else {\\r\\n        int ch = 0;\\r\\n        while (true) {\\r\\n            std::string word;\\r\\n            std::cout << \\\"Please enter the word you are searching for: \\\";\\r\\n            std::getline(std::cin, word);\\r\\n            std::cout << \\\"Ignore case-sensitive? 1 = Yes, 0 = No\\\" << std::endl;\\r\\n            std::cin >> ch;\\r\\n            if (ch == 1) {\\r\\n                std::string lowerCase = lower(\\r\\n                    paragraph);  // convert std::string paragraph to lowercase\\r\\n                                 // and store it in std::string lowerCase\\r\\n                std::string lowerCaseWord =\\r\\n                    lower(word);  // convert std::string paragraph to lowercase\\r\\n                                  // and store it in std::string lowerCase\\r\\n\\r\\n                std::cout << \\\"Hello, your word is \\\" << word << \\\"!\\\\n\\\";\\r\\n                if (lowerCase.find(lowerCaseWord) == std::string::npos) {\\r\\n                    std::cout << word << \\\" does not exist in the sentence\\\"\\r\\n                              << std::endl;\\r\\n                } else {\\r\\n                    std::cout << \\\"The word \\\" << word\\r\\n                              << \\\" is now found at location \\\"\\r\\n                              << lowerCase.find(lowerCaseWord) << std::endl\\r\\n                              << std::endl;\\r\\n                }\\r\\n            } else {\\r\\n                std::cout << \\\"Hello, your word is \\\" << word << \\\"!\\\\n\\\";\\r\\n                if (paragraph.find(word) == std::string::npos) {\\r\\n                    std::cout << word << \\\" does not exist in the sentence\\\"\\r\\n                              << std::endl;\\r\\n                } else {\\r\\n                    std::cout << \\\"The word \\\" << word\\r\\n                              << \\\" is now found at location \\\"\\r\\n                              << paragraph.find(word) << std::endl\\r\\n                              << std::endl;\\r\\n                }\\r\\n            }\\r\\n            std::cout << \\\"\\\\nPress Ctrl + C to exit the program.\\\\n\\\\n\\\";\\r\\n            std::cin.get();\\r\\n        }\\r\\n    }\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "bead sort": "\"// C++ program to implement gravity/bead sort\\n#include <cstdio>\\n#include <cstring>\\n\\n#define BEAD(i, j) beads[i * max + j]\\n\\n// function to perform the above algorithm\\nvoid beadSort(int *a, int len) {\\n    // Find the maximum element\\n    int max = a[0];\\n    for (int i = 1; i < len; i++)\\n        if (a[i] > max)\\n            max = a[i];\\n\\n    // allocating memory\\n    unsigned char *beads = new unsigned char[max * len];\\n    memset(beads, 0, static_cast<size_t>(max) * len);\\n\\n    // mark the beads\\n    for (int i = 0; i < len; i++)\\n        for (int j = 0; j < a[i]; j++) BEAD(i, j) = 1;\\n\\n    for (int j = 0; j < max; j++) {\\n        // count how many beads are on each post\\n        int sum = 0;\\n        for (int i = 0; i < len; i++) {\\n            sum += BEAD(i, j);\\n            BEAD(i, j) = 0;\\n        }\\n\\n        // Move beads down\\n        for (int i = len - sum; i < len; i++) BEAD(i, j) = 1;\\n    }\\n\\n    // Put sorted values in array using beads\\n    for (int i = 0; i < len; i++) {\\n        int j;\\n        for (j = 0; j < max && BEAD(i, j); j++) {\\n        }\\n\\n        a[i] = j;\\n    }\\n    delete[] beads;\\n}\\n\\n// driver function to test the algorithm\\nint main() {\\n    int a[] = {5, 3, 1, 7, 4, 1, 1, 20};\\n    int len = sizeof(a) / sizeof(a[0]);\\n\\n    beadSort(a, len);\\n\\n    for (int i = 0; i < len; i++) printf(\\\"%d \\\", a[i]);\\n\\n    return 0;\\n}\\n\"",
    "bitonic sort": "\"// Source : https://www.geeksforgeeks.org/bitonic-sort/\\n\\n/* C++ Program for Bitonic Sort. Note that this program\\n   works only when size of input is a power of 2. */\\n\\n#include <algorithm>\\n#include <iostream>\\n\\n/*The parameter dir indicates the sorting direction, ASCENDING\\n   or DESCENDING; if (a[i] > a[j]) agrees with the direction,\\n   then a[i] and a[j] are interchanged.*/\\nvoid compAndSwap(int a[], int i, int j, int dir) {\\n    if (dir == (a[i] > a[j]))\\n        std::swap(a[i], a[j]);\\n}\\n\\n/*It recursively sorts a bitonic sequence in ascending order,\\n  if dir = 1, and in descending order otherwise (means dir=0).\\n  The sequence to be sorted starts at index position low,\\n  the parameter cnt is the number of elements to be sorted.*/\\nvoid bitonicMerge(int a[], int low, int cnt, int dir) {\\n    if (cnt > 1) {\\n        int k = cnt / 2;\\n        for (int i = low; i < low + k; i++) compAndSwap(a, i, i + k, dir);\\n        bitonicMerge(a, low, k, dir);\\n        bitonicMerge(a, low + k, k, dir);\\n    }\\n}\\n\\n/* This function first produces a bitonic sequence by recursively\\n    sorting its two halves in opposite sorting orders, and then\\n    calls bitonicMerge to make them in the same order */\\nvoid bitonicSort(int a[], int low, int cnt, int dir) {\\n    if (cnt > 1) {\\n        int k = cnt / 2;\\n\\n        // sort in ascending order since dir here is 1\\n        bitonicSort(a, low, k, 1);\\n\\n        // sort in descending order since dir here is 0\\n        bitonicSort(a, low + k, k, 0);\\n\\n        // Will merge wole sequence in ascending order\\n        // since dir=1.\\n        bitonicMerge(a, low, cnt, dir);\\n    }\\n}\\n\\n/* Caller of bitonicSort for sorting the entire array of\\n   length N in ASCENDING order */\\nvoid sort(int a[], int N, int up) { bitonicSort(a, 0, N, up); }\\n\\n// Driver code\\nint main() {\\n    int a[] = {3, 7, 4, 8, 6, 2, 1, 5};\\n    int N = sizeof(a) / sizeof(a[0]);\\n\\n    int up = 1;  // means sort in ascending order\\n    sort(a, N, up);\\n\\n    std::cout << \\\"Sorted array: \\\\n\\\";\\n    for (int i = 0; i < N; i++) std::cout << a[i] << \\\" \\\";\\n    return 0;\\n}\\n\"",
    "bogo sort": "\"/**\\n * @file\\n * @brief Implementation of [Bogosort algorithm](https://en.wikipedia.org/wiki/Bogosort)\\n *\\n * @details\\n *      In computer science, bogosort (also known as permutation sort, stupid sort, slowsort, \\n *      shotgun sort, random sort, monkey sort, bobosort or shuffle sort) is a highly inefficient \\n *      sorting algorithm based on the generate and test paradigm. Two versions of this algorithm \\n *      exist: a deterministic version that enumerates all permutations until it hits a sorted one,\\n *      and a randomized version that randomly permutes its input.Randomized version is implemented here. \\n *\\n * ### Algorithm\\n * Shuffle the array untill array is sorted.\\n *\\n * @author [Deep Raval](https://github.com/imdeep2905)\\n */\\n#include <iostream>\\n#include <algorithm>\\n#include <array>\\n#include <cassert>\\n\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * Function to shuffle the elements of an array. (for reference)\\n * @tparam T typename of the array\\n * @tparam N length of array\\n * @param arr array to shuffle\\n * @returns new array with elements shuffled from a given array\\n */\\ntemplate <typename T, size_t N>\\nstd::array <T, N> shuffle (std::array <T, N> arr) {\\n    for (int i = 0; i < N; i++) {\\n        // Swaps i'th  index with random index (less than array size)\\n        std::swap(arr[i], arr[std::rand() % N]);\\n    }\\n    return arr;\\n}\\n/**\\n * Implement randomized Bogosort algorithm and sort the elements of a given array.\\n * @tparam T typename of the array\\n * @tparam N length of array\\n * @param arr array to sort\\n * @returns new array with elements sorted from a given array\\n */\\ntemplate <typename T, size_t N>\\nstd::array <T, N> randomized_bogosort (std::array <T, N> arr) {\\n    // Untill array is not sorted\\n    while (!std::is_sorted(arr.begin(), arr.end())) {\\n        std::random_shuffle(arr.begin(), arr.end());// Shuffle the array\\n    }\\n    return arr;\\n}\\n\\n}  // namespace sorting\\n\\n/**\\n * Function to display array on screen \\n * @tparam T typename of the array\\n * @tparam N length of array\\n * @param arr array to display\\n */\\ntemplate <typename T, size_t N>\\nvoid show_array (const std::array <T, N> &arr) {\\n    for (int x : arr) {\\n        std::cout << x << ' ';\\n    }\\n    std::cout << '\\\\n';\\n}\\n\\n/**\\n * Function to test above algorithm\\n */\\nvoid test() {\\n    // Test 1\\n    std::array <int, 5> arr1;\\n    for (int &x : arr1) {\\n        x = std::rand() % 100;\\n    }\\n    std::cout << \\\"Original Array : \\\";\\n    show_array(arr1);\\n    arr1 = sorting::randomized_bogosort(arr1);\\n    std::cout << \\\"Sorted Array : \\\";\\n    show_array(arr1);\\n    assert(std::is_sorted(arr1.begin(), arr1.end()));\\n    // Test 2\\n    std::array <int, 5> arr2;\\n    for (int &x : arr2) {\\n        x = std::rand() % 100;\\n    }\\n    std::cout << \\\"Original Array : \\\";\\n    show_array(arr2);\\n    arr2 = sorting::randomized_bogosort(arr2);\\n    std::cout << \\\"Sorted Array : \\\";\\n    show_array(arr2);\\n    assert(std::is_sorted(arr2.begin(), arr2.end()));\\n}\\n\\n/** Driver Code */\\nint main() {\\n    // Testing\\n    test();\\n    // Example Usage\\n    std::array <int, 5> arr = {3, 7, 10, 4, 1}; // Defining array which we want to sort\\n    std::cout << \\\"Original Array : \\\";\\n    show_array(arr);\\n    arr = sorting::randomized_bogosort(arr); // Callling bogo sort on it\\n    std::cout << \\\"Sorted Array : \\\";\\n    show_array(arr); // Printing sorted array\\n    return 0;\\n}\\n\"",
    "bubble sort": "\"/**\\n * @file\\n * @brief Bubble sort algorithm\\n *\\n * The working principle of the Bubble sort algorithm:\\n\\nBubble sort algorithm is the bubble sorting algorithm. The most important reason\\nfor calling the bubble is that the largest number is thrown at the end of this\\nalgorithm. This is all about the logic. In each iteration, the largest number is\\nexpired and when iterations are completed, the sorting takes place.\\n\\nWhat is Swap?\\n\\nSwap in the software means that two variables are displaced.\\nAn additional variable is required for this operation. x = 5, y = 10.\\nWe want x = 10, y = 5. Here we create the most variable to do it.\\n\\nint z;\\nz = x;\\nx = y;\\ny = z;\\n\\nThe above process is a typical displacement process.\\nWhen x assigns the value to x, the old value of x is lost.\\nThat's why we created a variable z to create the first value of the value of x,\\nand finally, we have assigned to y.\\n\\nBubble Sort Algorithm Analysis (Best Case - Worst Case - Average Case)\\n\\nBubble Sort Worst Case Performance is O (n²). Why is that? Because if you\\nremember Big O Notation, we were calculating the complexity of the algorithms in\\nthe nested loops. The n * (n - 1) product gives us O (n²) performance. In the\\nworst case all the steps of the cycle will occur. Bubble Sort (Avarage Case)\\nPerformance. Bubble Sort is not an optimal algorithm. in average, O (n²)\\nperformance is taken. Bubble Sort Best Case Performance. O (n). However, you\\ncan't get the best status in the code we shared above. This happens on the\\noptimized bubble sort algorithm. It's right down there.\\n*/\\n\\n#include <iostream>\\n#include <vector>\\n\\nint main() {\\n    int n;\\n    bool swap_check = true;\\n    std::cout << \\\"Enter the amount of numbers to sort: \\\";\\n    std::cin >> n;\\n    std::vector<int> numbers;\\n    std::cout << \\\"Enter \\\" << n << \\\" numbers: \\\";\\n    int num;\\n\\n    // Input\\n    for (int i = 0; i < n; i++) {\\n        std::cin >> num;\\n        numbers.push_back(num);\\n    }\\n\\n    // Bubble Sorting\\n    for (int i = 0; (i < n) && (swap_check); i++) {\\n        swap_check = false;\\n        for (int j = 0; j < n - 1 - i; j++) {\\n            if (numbers[j] > numbers[j + 1]) {\\n                swap_check = true;\\n                std::swap(numbers[j],\\n                          numbers[j + 1]);  // by changing swap location.\\n                                            // I mean, j. If the number is\\n                                            // greater than j + 1, then it\\n                                            // means the location.\\n            }\\n        }\\n    }\\n\\n    // Output\\n    std::cout << \\\"\\\\nSorted Array : \\\";\\n    for (int i = 0; i < numbers.size(); i++) {\\n        if (i != numbers.size() - 1) {\\n            std::cout << numbers[i] << \\\", \\\";\\n        } else {\\n            std::cout << numbers[i] << std::endl;\\n        }\\n    }\\n    return 0;\\n}\\n\"",
    "bucket sort": "\"// C++ program to sort an array using bucket sort\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n\\n// Function to sort arr[] of size n using bucket sort\\nvoid bucketSort(float arr[], int n) {\\n    // 1) Create n empty buckets\\n    std::vector<float> *b = new std::vector<float>[n];\\n\\n    // 2) Put array elements in different buckets\\n    for (int i = 0; i < n; i++) {\\n        int bi = n * arr[i];  // Index in bucket\\n        b[bi].push_back(arr[i]);\\n    }\\n\\n    // 3) Sort individual buckets\\n    for (int i = 0; i < n; i++) std::sort(b[i].begin(), b[i].end());\\n\\n    // 4) Concatenate all buckets into arr[]\\n    int index = 0;\\n    for (int i = 0; i < n; i++)\\n        for (int j = 0; j < b[i].size(); j++) arr[index++] = b[i][j];\\n    delete[] b;\\n}\\n\\n/* Driver program to test above funtion */\\nint main() {\\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\\n    int n = sizeof(arr) / sizeof(arr[0]);\\n    bucketSort(arr, n);\\n\\n    std::cout << \\\"Sorted array is \\\\n\\\";\\n    for (int i = 0; i < n; i++) std::cout << arr[i] << \\\" \\\";\\n    return 0;\\n}\\n\"",
    "cocktail selection sort": "\"// Returns Sorted elements after performing Cocktail Selection Sort\\n// It is a Sorting algorithm which chooses the minimum and maximum element in an\\n// array simultaneously, and swaps it with the lowest and highest available\\n// position iteratively or recursively\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n\\n// Iterative Version\\n\\nvoid CocktailSelectionSort(std::vector<int> *vec, int low, int high) {\\n    while (low <= high) {\\n        int minimum = (*vec)[low];\\n        int minimumindex = low;\\n        int maximum = (*vec)[high];\\n        int maximumindex = high;\\n\\n        for (int i = low; i <= high; i++) {\\n            if ((*vec)[i] >= maximum) {\\n                maximum = (*vec)[i];\\n                maximumindex = i;\\n            }\\n            if ((*vec)[i] <= minimum) {\\n                minimum = (*vec)[i];\\n                minimumindex = i;\\n            }\\n        }\\n        if (low != maximumindex || high != minimumindex) {\\n            std::swap((*vec)[low], (*vec)[minimumindex]);\\n            std::swap((*vec)[high], (*vec)[maximumindex]);\\n        } else {\\n            std::swap((*vec)[low], (*vec)[high]);\\n        }\\n\\n        low++;\\n        high--;\\n    }\\n}\\n\\n// Recursive Version\\n\\nvoid CocktailSelectionSort_v2(std::vector<int> *vec, int low, int high) {\\n    if (low >= high)\\n        return;\\n\\n    int minimum = (*vec)[low];\\n    int minimumindex = low;\\n    int maximum = (*vec)[high];\\n    int maximumindex = high;\\n\\n    for (int i = low; i <= high; i++) {\\n        if ((*vec)[i] >= maximum) {\\n            maximum = (*vec)[i];\\n            maximumindex = i;\\n        }\\n        if ((*vec)[i] <= minimum) {\\n            minimum = (*vec)[i];\\n            minimumindex = i;\\n        }\\n    }\\n    if (low != maximumindex || high != minimumindex) {\\n        std::swap((*vec)[low], (*vec)[minimumindex]);\\n        std::swap((*vec)[high], (*vec)[maximumindex]);\\n    } else {\\n        std::swap((*vec)[low], (*vec)[high]);\\n    }\\n\\n    CocktailSelectionSort(vec, low + 1, high - 1);\\n}\\n\\n// main function, select any one of iterative or recursive version\\n\\nint main() {\\n    int n;\\n    std::cout << \\\"Enter number of elements\\\\n\\\";\\n    std::cin >> n;\\n    std::vector<int> v(n);\\n    std::cout << \\\"Enter all the elements\\\\n\\\";\\n    for (int i = 0; i < n; ++i) {\\n        std::cin >> v[i];\\n    }\\n\\n    int method;\\n    std::cout << \\\"Enter method: \\\\n\\\\t0: iterative\\\\n\\\\t1: recursive:\\\\t\\\";\\n    std::cin >> method;\\n\\n    if (method == 0) {\\n        CocktailSelectionSort(&v, 0, n - 1);\\n    } else if (method == 1) {\\n        CocktailSelectionSort_v2(&v, 0, n - 1);\\n    } else {\\n        std::cerr << \\\"Unknown method\\\" << std::endl;\\n        return -1;\\n    }\\n    std::cout << \\\"Sorted elements are\\\\n\\\";\\n    for (int i = 0; i < n; ++i) {\\n        std::cout << v[i] << \\\" \\\";\\n    }\\n\\n    return 0;\\n}\\n\"",
    "comb sort": "\"/**\\n *\\n * \\\\file\\n * \\\\brief [Comb Sort Algorithm\\n * (Comb Sort)](https://en.wikipedia.org/wiki/Comb_sort)\\n *\\n * \\\\author\\n *\\n * \\\\details\\n * - A better version of bubble sort algorithm\\n * - Bubble sort compares adjacent values whereas comb sort uses gap larger\\n *   than 1\\n * - Best case Time complexity O(n)\\n *   Worst case Time complexity O(n^2)\\n *\\n */\\n\\n#include <algorithm>\\n#include <cassert>\\n#include <iostream>\\n\\n/**\\n *\\n * Find the next gap by shrinking the current gap by shrink factor of 1.3\\n * @param gap current gap\\n * @return new gap\\n *\\n */\\nint FindNextGap(int gap) {\\n    gap = (gap * 10) / 13;\\n\\n    return std::max(1, gap);\\n}\\n\\n/** Function to sort array\\n *\\n * @param arr array to be sorted\\n * @param l start index of array\\n * @param r end index of array\\n *\\n */\\nvoid CombSort(int *arr, int l, int r) {\\n    /**\\n     *\\n     * initial gap will be maximum and the maximum possible value is\\n     * the size of the array that is n and which is equal to r in this\\n     * case so to avoid passing an extra parameter n that is the size of\\n     * the array we are using r to initialize the initial gap.\\n     *\\n     */\\n    int gap = r;\\n\\n    /// Initialize swapped as true to make sure that loop runs\\n    bool swapped = true;\\n\\n    /// Keep running until gap = 1 or none elements were swapped\\n    while (gap != 1 || swapped) {\\n        /// Find next gap\\n        gap = FindNextGap(gap);\\n\\n        swapped = false;\\n\\n        /// Compare all elements with current gap\\n        for (int i = l; i < r - gap; ++i) {\\n            if (arr[i] > arr[i + gap]) {\\n                std::swap(arr[i], arr[i + gap]);\\n                swapped = true;\\n            }\\n        }\\n    }\\n}\\n\\nvoid tests() {\\n    /// Test 1\\n    int arr1[10] = {34, 56, 6, 23, 76, 34, 76, 343, 4, 76};\\n    CombSort(arr1, 0, 10);\\n    assert(std::is_sorted(arr1, arr1 + 10));\\n    std::cout << \\\"Test 1 passed\\\\n\\\";\\n\\n    /// Test 2\\n    int arr2[8] = {-6, 56, -45, 56, 0, -1, 8, 8};\\n    CombSort(arr2, 0, 8);\\n    assert(std::is_sorted(arr2, arr2 + 8));\\n    std::cout << \\\"Test 2 Passed\\\\n\\\";\\n}\\n\\n/** Main function */\\nint main() {\\n    /// Running predefined tests\\n    tests();\\n\\n    /// For user interaction\\n    int n;\\n    std::cin >> n;\\n    int *arr = new int[n];\\n    for (int i = 0; i < n; ++i) std::cin >> arr[i];\\n    CombSort(arr, 0, n);\\n    for (int i = 0; i < n; ++i) std::cout << arr[i] << ' ';\\n    delete[] arr;\\n    return 0;\\n}\\n\"",
    "counting sort": "\"#include <iostream>\\nusing namespace std;\\n\\nint Max(int Arr[], int N) {\\n    int max = Arr[0];\\n    for (int i = 1; i < N; i++)\\n        if (Arr[i] > max)\\n            max = Arr[i];\\n    return max;\\n}\\n\\nint Min(int Arr[], int N) {\\n    int min = Arr[0];\\n    for (int i = 1; i < N; i++)\\n        if (Arr[i] < min)\\n            min = Arr[i];\\n    return min;\\n}\\n\\nvoid Print(int Arr[], int N) {\\n    for (int i = 0; i < N; i++) cout << Arr[i] << \\\", \\\";\\n}\\n\\nint *Counting_Sort(int Arr[], int N) {\\n    int max = Max(Arr, N);\\n    int min = Min(Arr, N);\\n    int *Sorted_Arr = new int[N];\\n\\n    int *Count = new int[max - min + 1];\\n\\n    for (int i = 0; i < N; i++) Count[Arr[i] - min]++;\\n\\n    for (int i = 1; i < (max - min + 1); i++) Count[i] += Count[i - 1];\\n\\n    for (int i = N - 1; i >= 0; i--) {\\n        Sorted_Arr[Count[Arr[i] - min] - 1] = Arr[i];\\n        Count[Arr[i] - min]--;\\n    }\\n\\n    return Sorted_Arr;\\n}\\n\\nint main() {\\n    int Arr[] = {47, 65, 20, 66, 25, 53, 64, 69, 72, 22,\\n                 74, 25, 53, 15, 42, 36, 4,  69, 86, 19},\\n        N = 20;\\n    int *Sorted_Arr;\\n\\n    cout << \\\"\\\\n\\\\tOrignal Array = \\\";\\n    Print(Arr, N);\\n    Sorted_Arr = Counting_Sort(Arr, N);\\n    cout << \\\"\\\\n\\\\t Sorted Array = \\\";\\n    Print(Sorted_Arr, N);\\n    cout << endl;\\n\\n    return 0;\\n}\\n\"",
    "counting sort string": "\"// C++ Program for counting sort\\n#include <iostream>\\n\\nusing namespace std;\\n\\nvoid countSort(string arr) {\\n    string output;\\n\\n    int count[256], i;\\n    for (int i = 0; i < 256; i++) count[i] = 0;\\n\\n    for (i = 0; arr[i]; ++i) ++count[arr[i]];\\n\\n    for (i = 1; i < 256; ++i) count[i] += count[i - 1];\\n\\n    for (i = 0; arr[i]; ++i) {\\n        output[count[arr[i]] - 1] = arr[i];\\n        --count[arr[i]];\\n    }\\n\\n    for (i = 0; arr[i]; ++i) arr[i] = output[i];\\n\\n    cout << \\\"Sorted character array is \\\" << arr;\\n}\\n\\nint main() {\\n    string arr;\\n    cin >> arr;\\n\\n    countSort(arr);\\n\\n    return 0;\\n}\\n\"",
    "count inversions": "\"/**\\n * @file\\n * @brief Counting Inversions using [Merge\\n Sort](https://en.wikipedia.org/wiki/Merge_sort)\\n *\\n * @details\\n * Program to count the number of inversions in an array\\n * using merge-sort.\\n *\\n * The count of inversions help to determine how close the array\\n * is to be sorted in ASCENDING order.\\n *\\n * two elements a[i] and a[j] form an inversion if `a[i]` > `a[j]` and i < j\\n *\\n * Time Complexity --> `O(n.log n)`\\n\\n * Space Complexity --> `O(n)` ; additional array `temp[1..n]`\\n * ### Algorithm\\n\\n *   1. The idea is similar to merge sort, divide the array into two equal or\\n almost\\n *      equal halves in each step until the base case is reached.\\n *   2. Create a function merge that counts the number of inversions when two\\n halves of\\n *      the array are merged, create two indices i and j, i is the index for\\n first half\\n *      and j is an index of the second half. if `a[i]` is greater than `a[j]`,\\n then there are (mid – i)\\n *      inversions, Because left and right subarrays are sorted, so all the\\n remaining elements\\n *      in left-subarray (a[i+1], a[i+2] … a[mid]) will be greater than a[j].\\n *   3. Create a recursive function to divide the array into halves and find the\\n answer by summing\\n *      the number of inversions is the first half, number of inversion in the\\n second half and\\n *      the number of inversions by merging the two.\\n *   4. The base case of recursion is when there is only one element in the\\n given half.\\n *   5. Print the answer\\n *\\n * @author [Rakshit Raj](https://github.com/rakshitraj)\\n */\\n#include <cassert>   /// for assert\\n#include <cstdint>   /// for typedef datatype uint64_t\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * @namespace inversion\\n * @brief Functions for counting inversions using Merge Sort algorithm\\n */\\nnamespace inversion {\\n\\n// Functions used --->\\n// int mergeSort(int* arr, int* temp, int left, int right);\\n// int merge(int* arr, int* temp, int left, int mid, int right);\\n// int countInversion(int* arr, const int size);\\n// void show(int* arr, const int size);\\n\\n/**\\n * @brief Function to merge two sub-arrays.\\n *\\n * @details\\n * merge() function is called from mergeSort()\\n * to merge the array after it split for sorting\\n * by the mergeSort() funtion.\\n *\\n * In this case the merge fuction will also count and return\\n * inversions detected when merging the sub arrays.\\n *\\n * @param arr    input array, data-menber of vector\\n * @param temp   stores the resultant merged array\\n * @param left   lower bound of `arr[]` and left-sub-array\\n * @param mid    midpoint, upper bound of left sub-array,\\n *               `(mid+1)` gives the lower bound of right-sub-array\\n * @param right  upper bound of `arr[]` and right-sub-array\\n * @returns number of inversions found in merge step\\n */\\ntemplate <typename T>\\nuint32_t merge(T* arr, T* temp, uint32_t left, uint32_t mid, uint32_t right) {\\n    uint32_t i = left;       /* i --> index of left sub-array */\\n    uint32_t j = mid + 1;    /* j --> index for right sub-array */\\n    uint32_t k = left;       /* k --> index for resultant array temp */\\n    uint32_t inv_count = 0;  // inversion count\\n\\n    while ((i <= mid) && (j <= right)) {\\n        if (arr[i] <= arr[j]) {\\n            temp[k++] = arr[i++];\\n        } else {\\n            temp[k++] = arr[j++];\\n            inv_count +=\\n                (mid - i +\\n                 1);  // tricky; may vary depending on selection of sub-array\\n        }\\n    }\\n    // Add remaining elements from the larger subarray to the end of temp\\n    while (i <= mid) {\\n        temp[k++] = arr[i++];\\n    }\\n    while (j <= right) {\\n        temp[k++] = arr[j++];\\n    }\\n    // Copy temp[] to arr[]\\n    for (k = left; k <= right; k++) {\\n        arr[k] = temp[k];\\n    }\\n    return inv_count;\\n}\\n\\n/**\\n * @brief Implement merge Sort and count inverions while merging\\n *\\n * @details\\n * The mergeSort() function implements Merge Sort, a\\n * Divide and conquer algorithm, it divides the input\\n * array into two halves and calls itself for each\\n * sub-array and then calls the merge() function to\\n * merge the two halves.\\n *\\n * @param arr   - array to be sorted\\n * @param temp  - merged resultant array\\n * @param left  - lower bound of array\\n * @param right - upper bound of array\\n * @returns number of inversions in array\\n */\\ntemplate <typename T>\\nuint32_t mergeSort(T* arr, T* temp, uint32_t left, uint32_t right) {\\n    uint32_t mid = 0, inv_count = 0;\\n    if (right > left) {\\n        // midpoint to split the array\\n        mid = (right + left) / 2;\\n        // Add inversions in left and right sub-arrays\\n        inv_count += mergeSort(arr, temp, left, mid);  // left sub-array\\n        inv_count += mergeSort(arr, temp, mid + 1, right);\\n\\n        // inversions in the merge step\\n        inv_count += merge(arr, temp, left, mid, right);\\n    }\\n    return inv_count;\\n}\\n\\n/**\\n * @brief Function countInversion() returns the number of inversion\\n * present in the input array. Inversions are an estimate of\\n * how close or far off the array is to being sorted.\\n *\\n * @details\\n * Number of inversions in a sorted array is 0.\\n * Number of inversion in an array[1...n] sorted in\\n * non-ascending order is n(n-1)/2, since each pair of elements\\n * contitute an inversion.\\n *\\n * @param arr   - array, data member of std::vector<int>, input for counting\\n * inversions\\n * @param array_size    - number of elementa in the array\\n * @returns number of inversions in input array, sorts the array\\n */\\ntemplate <class T>\\nuint32_t countInversion(T* arr, const uint32_t size) {\\n    std::vector<T> temp;\\n    temp.reserve(size);\\n    temp.assign(size, 0);\\n    return mergeSort(arr, temp.data(), 0, size - 1);\\n}\\n\\n/**\\n * @brief UTILITY function to print array.\\n * @param arr[]   array to print\\n * @param array_size    size of input array arr[]\\n * @returns void\\n *\\n */\\ntemplate <typename T>\\nvoid show(T* arr, const uint32_t array_size) {\\n    std::cout << \\\"Printing array: \\\\n\\\";\\n    for (uint32_t i = 0; i < array_size; i++) {\\n        std::cout << \\\" \\\" << arr[i];\\n    }\\n    std::cout << \\\"\\\\n\\\";\\n}\\n\\n}  // namespace inversion\\n}  // namespace sorting\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // Test 1\\n    std::vector<uint64_t> arr1 = {\\n        100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84,\\n        83,  82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67,\\n        66,  65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50,\\n        49,  48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33,\\n        32,  31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,\\n        15,  14, 13, 12, 11, 10, 9,  8,  7,  6,  5,  4,  3,  2,  1};\\n    uint32_t size1 = arr1.size();\\n    uint32_t inv_count1 = 4950;\\n    uint32_t result1 = sorting::inversion::countInversion(arr1.data(), size1);\\n    assert(inv_count1 == result1);\\n    // Test 2\\n    std::vector<int> arr2 = {22, 66, 75, 23, 11, 87, 2, 44, 98, 43};\\n    uint32_t size2 = arr2.size();\\n    uint32_t inv_count2 = 20;\\n    uint32_t result2 = sorting::inversion::countInversion(arr2.data(), size2);\\n    assert(inv_count2 == result2);\\n    // Test 3\\n    std::vector<double> arr3 = {33.1, 45.2, 65.4, 76.5, 1.0,\\n                                2.9,  5.4,  7.7,  88.9, 12.4};\\n    uint32_t size3 = arr3.size();\\n    uint32_t inv_count3 = 21;\\n    uint32_t result3 = sorting::inversion::countInversion(arr3.data(), size3);\\n    assert(inv_count3 == result3);\\n    // Test 4\\n    std::vector<char> arr4 = {'a', 'b', 'c', 'd', 'e'};\\n    uint32_t size4 = arr4.size();\\n    uint32_t inv_count4 = 0;\\n    uint32_t result4 = sorting::inversion::countInversion(arr4.data(), size4);\\n    assert(inv_count4 == result4);\\n}\\n\\n// /**\\n//  * @brief Program Body contains all main funtionality\\n//  * @returns void\\n//  */\\n// template <typename T>\\n// static void body() {\\n//     // Input your own sequence\\n//     uint_t size;\\n//     T input;\\n//     std::cout << \\\"Enter number of elements:\\\";\\n//     std::cin >> size;\\n//\\n//     std::vector<T> arr;\\n//     arr.reserve(size);\\n//\\n//     std::cout << \\\"Enter elements -->\\\\n\\\";\\n//     for (uint64_t i=1; i<=size; i++) {\\n//         std::cout << \\\"Element \\\"<< i <<\\\" :\\\";\\n//         std::cin >> input;\\n//         arr.push_back(input);\\n//     }\\n//\\n//     if (size != arr.size()) {\\n//         size = arr.size();\\n//     }\\n//\\n//     std::cout << \\\"\\\\n\\\";\\n//     sorting::inversion::show(arr.data(), size);\\n//     std::cout << \\\"\\\\n\\\";\\n//\\n//     // Counting inversions\\n//     std::cout << \\\"\\\\nThe number of inversions: \\\"<<\\n//     sorting::inversion::countInversion(arr.data(), size) << \\\"\\\\n\\\";\\n//\\n//     // Output sorted array\\n//     std::cout << \\\"\\\\nSorted array -->  \\\\n\\\";\\n//     sorting::inversion::show(arr.data(), size);\\n// }\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // Run test implementations\\n    // body(); // test your own array\\n    return 0;\\n}\\n\"",
    "cycle sort": "\"/**\\n * @file\\n * @brief Implementation of [Cycle\\n * sort](https://en.wikipedia.org/wiki/Cycle_sort) algorithm\\n * @details\\n * Cycle Sort is a sorting algorithm that works in \\\\f$O(n^2)\\\\f$ time in the best\\n * case and works in \\\\f$O(n^2)\\\\f$ in worst case. If a element is already at its\\n * correct  position, do nothing. If a element is not at its correct position,\\n * we then need to move it to its correct position by computing the correct\\n * positions.Therefore, we should make sure the duplicate elements.\\n * @author [TsungHan Ho](https://github.com/dalaoqi)\\n */\\n\\n#include <algorithm>  /// for std::is_sorted, std::swap\\n#include <cassert>    /// for assert\\n#include <iostream>   /// for io operations\\n#include <vector>     /// for std::vector\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * @namespace cycle_sort\\n * @brief Functions for [Cycle sort](https://en.wikipedia.org/wiki/Cycle_sort)\\n * algorithm\\n */\\nnamespace cycle_sort {\\n/**\\n * @brief The main function implements cycleSort\\n * @tparam T type of array\\n * @param in_arr array to be sorted\\n * @returns void\\n */\\ntemplate <typename T>\\nstd::vector<T> cycleSort(const std::vector<T> &in_arr) {\\n    std::vector<T> arr(in_arr);\\n    for (int cycle_start = 0; cycle_start <= arr.size() - 1; cycle_start++) {\\n        // initialize item\\n        T item = arr[cycle_start];\\n\\n        // Count the number of elements smaller than item, this  number is the\\n        // correct index of item.\\n        int pos = cycle_start;\\n        for (int i = cycle_start + 1; i < arr.size(); i++) {\\n            if (arr[i] < item) {\\n                pos++;\\n            }\\n        }\\n\\n        // item is already in correct position\\n        if (pos == cycle_start) {\\n            continue;\\n        }\\n\\n        // duplicate  elements\\n        while (item == arr[pos]) pos += 1;\\n        if (pos == cycle_start) {\\n            continue;\\n        } else {\\n            std::swap(item, arr[pos]);\\n        }\\n        // Rest of the  elements\\n        while (pos != cycle_start) {\\n            pos = cycle_start;\\n            // Find position where we put the element\\n            for (size_t i = cycle_start + 1; i < arr.size(); i++) {\\n                if (arr[i] < item) {\\n                    pos += 1;\\n                }\\n            }\\n            // duplicate  elements\\n            while (item == arr[pos]) pos += 1;\\n            if (item == arr[pos]) {\\n                continue;\\n            } else {\\n                std::swap(item, arr[pos]);\\n            }\\n        }\\n    }\\n    return arr;\\n}\\n}  // namespace cycle_sort\\n}  // namespace sorting\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // Test 1\\n    // [4, 3, 2, 1] return [1, 2, 3, 4]\\n    std::vector<uint32_t> array1 = {4, 3, 2, 1};\\n    std::cout << \\\"Test 1... \\\";\\n    std::vector<uint32_t> arr1 = sorting::cycle_sort::cycleSort(array1);\\n    assert(std::is_sorted(std::begin(arr1), std::end(arr1)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // [4.3, -6.5, -7.4, 0, 2.7, 1.8] return [-7.4, -6.5, 0, 1.8, 2.7, 4.3]\\n    std::vector<double> array2 = {4.3, -6.5, -7.4, 0, 2.7, 1.8};\\n    std::cout << \\\"Test 2... \\\";\\n    std::vector<double> arr2 = sorting::cycle_sort::cycleSort(array2);\\n    assert(std::is_sorted(std::begin(arr2), std::end(arr2)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // Test 3\\n    // [3, 3, 3, 3] return [3, 3, 3, 3]\\n    std::vector<uint32_t> array3 = {3, 3, 3, 3};\\n    std::cout << \\\"Test 3... \\\";\\n    std::vector<uint32_t> arr3 = sorting::cycle_sort::cycleSort(array3);\\n    assert(std::is_sorted(std::begin(arr3), std::end(arr3)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // [9, 4, 6, 8, 14, 3] return [9, 4, 6, 8, 14, 3]\\n    std::vector<uint32_t> array4 = {3, 4, 6, 8, 9, 14};\\n    std::cout << \\\"Test 4... \\\";\\n    std::vector<uint32_t> arr4 = sorting::cycle_sort::cycleSort(array4);\\n    assert(std::is_sorted(std::begin(arr4), std::end(arr4)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // execute the test\\n    return 0;\\n}\\n\"",
    "dnf sort": "\"/**\\n * @file\\n * @brief Implementation of the [DNF\\n * sort](https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/)\\n * implementation\\n * @details\\n * C++ program to sort an array with 0, 1 and 2 in a single pass(DNF sort).\\n * Since one traversal of the array is there hence it works in O(n) time\\n * complexity.\\n * @author [Sujal Gupta](https://github.com/heysujal)\\n */\\n\\n#include <algorithm>  /// for std::is_sorted\\n#include <cassert>    /// for assert\\n#include <iostream>   /// for std::swap and io operations\\n#include <vector>     /// for std::vector\\n\\n/**\\n * @namespace sorting\\n * @breif Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * @namespace dnf_sort\\n * @brief Functions for the [DNF\\n * sort](https://en.wikipedia.org/wiki/Dutch_national_flag_problem)\\n * implementation\\n */\\nnamespace dnf_sort {\\n/**\\n * @brief The main function implements DNF sort\\n * @tparam T type of array\\n * @param a array to be sorted,\\n * @param arr_size size of array\\n * @returns void\\n */\\ntemplate <typename T>\\nstd::vector<T> dnfSort(const std::vector<T> &in_arr) {\\n    std::vector<T> arr(in_arr);\\n    uint64_t lo = 0;\\n    uint64_t hi = arr.size() - 1;\\n    uint64_t mid = 0;\\n\\n    // Iterate till all the elements\\n    // are sorted\\n    while (mid <= hi) {\\n        switch (arr[mid]) {\\n            // If the element is 0\\n            case 0:\\n                std::swap(arr[lo++], arr[mid++]);\\n                break;\\n\\n            // If the element is 1 .\\n            case 1:\\n                mid++;\\n                break;\\n\\n            // If the element is 2\\n            case 2:\\n                std::swap(arr[mid], arr[hi--]);\\n                break;\\n        }\\n    }\\n    return arr;\\n}\\n}  // namespace dnf_sort\\n}  // namespace sorting\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st test\\n    // [1, 0, 2, 1] return [0, 1, 1, 2]\\n    std::vector<uint64_t> array1 = {0, 1, 1, 2};\\n    std::cout << \\\"Test 1... \\\";\\n    std::vector<uint64_t> arr1 = sorting::dnf_sort::dnfSort(array1);\\n    assert(std::is_sorted(std::begin(arr1), std::end(arr1)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n    // 2nd test\\n    // [1, 0, 0, 1, 1, 0, 2, 1] return [0, 0, 0, 1, 1, 1, 1, 2]\\n    std::vector<uint64_t> array2 = {1, 0, 0, 1, 1, 0, 2, 1};\\n    std::cout << \\\"Test 2... \\\";\\n    std::vector<uint64_t> arr2 = sorting::dnf_sort::dnfSort(array2);\\n    assert(std::is_sorted(std::begin(arr2), std::end(arr2)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n    // 3rd test\\n    // [1, 1, 0, 0, 1, 2, 2, 0, 2, 1] return [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]\\n    std::vector<uint64_t> array3 = {1, 1, 0, 0, 1, 2, 2, 0, 2, 1};\\n    std::cout << \\\"Test 3... \\\";\\n    std::vector<uint64_t> arr3 = sorting::dnf_sort::dnfSort(array3);\\n    assert(std::is_sorted(std::begin(arr3), std::end(arr3)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n    // 4th test\\n    // [2, 2, 2, 0, 0, 1, 1] return [0, 0, 1, 1, 2, 2, 2]\\n    std::vector<uint64_t> array4 = {2, 2, 2, 0, 0, 1, 1};\\n    std::cout << \\\"Test 4... \\\";\\n    std::vector<uint64_t> arr4 = sorting::dnf_sort::dnfSort(array4);\\n    assert(std::is_sorted(std::begin(arr4), std::end(arr4)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // execute the test\\n    return 0;\\n}\\n\"",
    "gnome sort": "\"/**\\n * @file\\n * @brief Implementation of [gnome\\n * sort](https://en.wikipedia.org/wiki/Gnome_sort) algorithm.\\n * @author [beqakd](https://github.com/beqakd)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @details\\n * Gnome sort algorithm is not the best one but it is widely used.\\n * The algorithm iteratively checks the order of pairs in the array. If they are\\n * on right order it moves to the next successive pair, otherwise it swaps\\n * elements. This operation is repeated until no more swaps are made thus\\n * indicating the values to be in ascending order.\\n *\\n * The time Complexity of the algorithm is \\\\f$O(n^2)\\\\f$ and in some cases it\\n * can be \\\\f$O(n)\\\\f$.\\n */\\n\\n#include <algorithm>  // for std::swap\\n#include <array>      // for std::array\\n#include <cassert>    // for assertions\\n#include <iostream>   // for io operations\\n\\n/**\\n * @namespace sorting\\n * Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * This implementation is for a C-style array input that gets modified in place.\\n * @param [in,out] arr our array of elements.\\n * @param size size of given array\\n */\\ntemplate <typename T>\\nvoid gnomeSort(T *arr, int size) {\\n    // few easy cases\\n    if (size <= 1) {\\n        return;\\n    }\\n\\n    int index = 0;  // initialize some variables.\\n    while (index < size) {\\n        // check for swap\\n        if ((index == 0) || (arr[index] >= arr[index - 1])) {\\n            index++;\\n        } else {\\n            std::swap(arr[index], arr[index - 1]);  // swap\\n            index--;\\n        }\\n    }\\n}\\n\\n/**\\n * This implementation is for a C++-style array input. The function argument is\\n * a pass-by-value and hence a copy of the array gets created which is then\\n * modified by the function and returned.\\n * @tparam T type of data variables in the array\\n * @tparam size size of the array\\n * @param [in] arr our array of elements.\\n * @return array with elements sorted\\n */\\ntemplate <typename T, size_t size>\\nstd::array<T, size> gnomeSort(std::array<T, size> arr) {\\n    // few easy cases\\n    if (size <= 1) {\\n        return arr;\\n    }\\n\\n    int index = 0;  // initialize loop index\\n    while (index < size) {\\n        // check for swap\\n        if ((index == 0) || (arr[index] >= arr[index - 1])) {\\n            index++;\\n        } else {\\n            std::swap(arr[index], arr[index - 1]);  // swap\\n            index--;\\n        }\\n    }\\n    return arr;\\n}\\n}  // namespace sorting\\n\\n/**\\n * Test function\\n */\\nstatic void test() {\\n    // Example 1. Creating array of int,\\n    std::cout << \\\"Test 1 - as a C-array...\\\";\\n    const int size = 6;\\n    std::array<int, size> arr = {-22, 100, 150, 35, -10, 99};\\n    sorting::gnomeSort(arr.data(),\\n                       size);  // pass array data as a C-style array pointer\\n    assert(std::is_sorted(std::begin(arr), std::end(arr)));\\n    std::cout << \\\" Passed\\\\n\\\";\\n    for (int i = 0; i < size; i++) {\\n        std::cout << arr[i] << \\\", \\\";\\n    }\\n    std::cout << std::endl;\\n\\n    // Example 2. Creating array of doubles.\\n    std::cout << \\\"\\\\nTest 2 - as a std::array...\\\";\\n    std::array<double, size> double_arr = {-100.2, 10.2, 20.0, 9.0, 7.5, 7.2};\\n    std::array<double, size> sorted_arr = sorting::gnomeSort(double_arr);\\n    assert(std::is_sorted(std::begin(sorted_arr), std::end(sorted_arr)));\\n    std::cout << \\\" Passed\\\\n\\\";\\n    for (int i = 0; i < size; i++) {\\n        std::cout << double_arr[i] << \\\", \\\";\\n    }\\n    std::cout << std::endl;\\n\\n    // Example 3. Creating random array of float.\\n    std::cout << \\\"\\\\nTest 3 - 200 random numbers as a std::array...\\\";\\n    const int size2 = 200;\\n    std::array<float, size2> rand_arr{};\\n\\n    for (auto &a : rand_arr) {\\n        // generate random numbers between -5.0 and 4.99\\n        a = float(std::rand() % 1000 - 500) / 100.f;\\n    }\\n\\n    std::array<float, size2> float_arr = sorting::gnomeSort(rand_arr);\\n    assert(std::is_sorted(std::begin(float_arr), std::end(float_arr)));\\n    std::cout << \\\" Passed\\\\n\\\";\\n    // for (int i = 0; i < size; i++) std::cout << double_arr[i] << \\\", \\\";\\n    std::cout << std::endl;\\n}\\n\\n/**\\n * Our main function with example of sort method.\\n */\\nint main() {\\n    test();\\n    return 0;\\n}\\n\"",
    "heap sort": "\"/**\\n * \\\\file\\n * \\\\brief [Heap Sort Algorithm\\n * (heap sort)](https://en.wikipedia.org/wiki/Heapsort) implementation\\n *\\n * \\\\author [Ayaan Khan](http://github.com/ayaankhan98)\\n *\\n * \\\\details\\n *  Heap-sort is a comparison-based sorting algorithm.\\n *  Heap-sort can be thought of as an improved selection sort:\\n *  like selection sort, heap sort divides its input into a sorted\\n *  and an unsorted region, and it iteratively shrinks the unsorted\\n *  region by extracting the largest element from it and inserting\\n *  it into the sorted region. Unlike selection sort,\\n *  heap sort does not waste time with a linear-time scan of the\\n *  unsorted region; rather, heap sort maintains the unsorted region\\n *  in a heap data structure to more quickly find the largest element\\n *  in each step.\\n *\\n *  Time Complexity - \\\\f$O(n \\\\log(n))\\\\f$\\n *\\n */\\n#include <algorithm>\\n#include <cassert>\\n#include <iostream>\\n\\n/**\\n *\\n * Utility function to print the array after\\n * sorting.\\n *\\n * @param arr array to be printed\\n * @param sz size of array\\n *\\n */\\ntemplate <typename T>\\nvoid printArray(T *arr, int sz) {\\n    for (int i = 0; i < sz; i++) std::cout << arr[i] << \\\"  \\\";\\n    std::cout << \\\"\\\\n\\\";\\n}\\n\\n/**\\n *\\n * \\\\addtogroup sorting Sorting Algorithm\\n * @{\\n *\\n * The heapify procedure can be thought of as building a heap from\\n * the bottom up by successively sifting downward to establish the\\n * heap property.\\n *\\n * @param arr array to be sorted\\n * @param n size of array\\n * @param i node position in Binary Tress or element position in\\n *          Array to be compared with it's childern\\n *\\n */\\ntemplate <typename T>\\nvoid heapify(T *arr, int n, int i) {\\n    int largest = i;\\n    int l = 2 * i + 1;\\n    int r = 2 * i + 2;\\n\\n    if (l < n && arr[l] > arr[largest])\\n        largest = l;\\n\\n    if (r < n && arr[r] > arr[largest])\\n        largest = r;\\n\\n    if (largest != i) {\\n        std::swap(arr[i], arr[largest]);\\n        heapify(arr, n, largest);\\n    }\\n}\\n\\n/**\\n * Utilizes heapify procedure to sort\\n * the array\\n *\\n * @param arr array to be sorted\\n * @param n size of array\\n *\\n */\\ntemplate <typename T>\\nvoid heapSort(T *arr, int n) {\\n    for (int i = n - 1; i >= 0; i--) heapify(arr, n, i);\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        std::swap(arr[0], arr[i]);\\n        heapify(arr, i, 0);\\n    }\\n}\\n\\n/**\\n *\\n * @}\\n * Test cases to test the program\\n *\\n */\\nvoid test() {\\n    std::cout << \\\"Test 1\\\\n\\\";\\n    int arr[] = {-10, 78, -1, -6, 7, 4, 94, 5, 99, 0};\\n    int sz = sizeof(arr) / sizeof(arr[0]);  // sz - size of array\\n    printArray(arr, sz);  // displaying the array before sorting\\n    heapSort(arr, sz);    // calling heapsort to sort the array\\n    printArray(arr, sz);  // display array after sorting\\n    assert(std::is_sorted(arr, arr + sz));\\n    std::cout << \\\"Test 1 Passed\\\\n========================\\\\n\\\";\\n\\n    std::cout << \\\"Test 2\\\\n\\\";\\n    double arr2[] = {4.5, -3.6, 7.6, 0, 12.9};\\n    sz = sizeof(arr2) / sizeof(arr2[0]);\\n    printArray(arr2, sz);\\n    heapSort(arr2, sz);\\n    printArray(arr2, sz);\\n    assert(std::is_sorted(arr2, arr2 + sz));\\n    std::cout << \\\"Test 2 passed\\\\n\\\";\\n}\\n\\n/** Main function */\\nint main() {\\n    test();\\n    return 0;\\n}\\n\"",
    "insertion sort": "\"/**\\n *\\n * \\\\file\\n * \\\\brief [Insertion Sort Algorithm\\n * (Insertion Sort)](https://en.wikipedia.org/wiki/Insertion_sort)\\n *\\n * \\\\details\\n * Insertion sort is a simple sorting algorithm that builds the final\\n * sorted array one at a time. It is much less efficient compared to\\n * other sorting algorithms like heap sort, merge sort or quick sort.\\n * However it has several advantages such as\\n * 1. Easy to implement\\n * 2. For small set of data it is quite efficient\\n * 3. More efficient that other Quadratic complexity algorithms like\\n *    Selection sort or bubble sort.\\n * 4. It's stable that is it does not change the relative order of\\n *    elements with equal keys\\n * 5. Works on hand means it can sort the array or list as it receives.\\n *\\n * It is based on the same idea that people use to sort the playing cards in\\n * their hands.\\n * the algorithms goes in the manner that we start iterating over the array\\n * of elements as soon as we find a unsorted element that is a misplaced\\n * element we place it at a sorted position.\\n *\\n * Example execution steps:\\n * 1. Suppose initially we have\\n * \\\\f{bmatrix}{4 &3 &2 &5 &1\\\\f}\\n * 2. We start traversing from 4 till we reach 1\\n * when we reach at 3 we find that it is misplaced so we take 3 and place\\n * it at a correct position thus the array will become\\n * \\\\f{bmatrix}{3 &4 &2 &5 &1\\\\f}\\n * 3. In the next iteration we are at 2 we find that this is also misplaced so\\n * we place it at the correct sorted position thus the array in this iteration\\n * becomes\\n * \\\\f{bmatrix}{2 &3 &4 &5 &1\\\\f}\\n * 4. We do not do anything with 5 and move on to the next iteration and\\n * select 1 which is misplaced and place it at correct position. Thus, we have\\n * \\\\f{bmatrix}{1 &2 &3 &4 &5\\\\f}\\n */\\n\\n#include <algorithm>\\n#include <cassert>\\n#include <iostream>\\n#include <vector>\\n\\n/** \\\\namespace sorting\\n * \\\\brief Sorting algorithms\\n */\\nnamespace sorting {\\n/** \\\\brief\\n * Insertion Sort Function\\n *\\n * @tparam T type of array\\n * @param [in,out] arr Array to be sorted\\n * @param n Size of Array\\n */\\ntemplate <typename T>\\nvoid insertionSort(T *arr, int n) {\\n    for (int i = 1; i < n; i++) {\\n        T temp = arr[i];\\n        int j = i - 1;\\n        while (j >= 0 && temp < arr[j]) {\\n            arr[j + 1] = arr[j];\\n            j--;\\n        }\\n        arr[j + 1] = temp;\\n    }\\n}\\n\\n/** Insertion Sort Function\\n *\\n * @tparam T type of array\\n * @param [in,out] arr pointer to array to be sorted\\n */\\ntemplate <typename T>\\nvoid insertionSort(std::vector<T> *arr) {\\n    size_t n = arr->size();\\n\\n    for (size_t i = 1; i < n; i++) {\\n        T temp = arr[0][i];\\n        int32_t j = i - 1;\\n        while (j >= 0 && temp < arr[0][j]) {\\n            arr[0][j + 1] = arr[0][j];\\n            j--;\\n        }\\n        arr[0][j + 1] = temp;\\n    }\\n}\\n\\n}  // namespace sorting\\n\\n/**\\n * @brief Create a random array objecthelper function to create a random array\\n *\\n * @tparam T type of array\\n * @param arr array to fill (must be pre-allocated)\\n * @param N number of array elements\\n */\\ntemplate <typename T>\\nstatic void create_random_array(T *arr, int N) {\\n    while (N--) {\\n        double r = (std::rand() % 10000 - 5000) / 100.f;\\n        arr[N] = static_cast<T>(r);\\n    }\\n}\\n\\n/** Test Cases to test algorithm */\\nvoid tests() {\\n    int arr1[10] = {78, 34, 35, 6, 34, 56, 3, 56, 2, 4};\\n    std::cout << \\\"Test 1... \\\";\\n    sorting::insertionSort(arr1, 10);\\n    assert(std::is_sorted(arr1, arr1 + 10));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    int arr2[5] = {5, -3, 7, -2, 1};\\n    std::cout << \\\"Test 2... \\\";\\n    sorting::insertionSort(arr2, 5);\\n    assert(std::is_sorted(arr2, arr2 + 5));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    float arr3[5] = {5.6, -3.1, -3.0, -2.1, 1.8};\\n    std::cout << \\\"Test 3... \\\";\\n    sorting::insertionSort(arr3, 5);\\n    assert(std::is_sorted(arr3, arr3 + 5));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    std::vector<float> arr4({5.6, -3.1, -3.0, -2.1, 1.8});\\n    std::cout << \\\"Test 4... \\\";\\n    sorting::insertionSort(&arr4);\\n    assert(std::is_sorted(std::begin(arr4), std::end(arr4)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    int arr5[50];\\n    std::cout << \\\"Test 5... \\\";\\n    create_random_array(arr5, 50);\\n    sorting::insertionSort(arr5, 50);\\n    assert(std::is_sorted(arr5, arr5 + 50));\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    float arr6[50];\\n    std::cout << \\\"Test 6... \\\";\\n    create_random_array(arr6, 50);\\n    sorting::insertionSort(arr6, 50);\\n    assert(std::is_sorted(arr6, arr6 + 50));\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/** Main Function */\\nint main() {\\n    /// Running predefined tests to test algorithm\\n    tests();\\n\\n    /// For user insteraction\\n    size_t n;\\n    std::cout << \\\"Enter the length of your array (0 to exit): \\\";\\n    std::cin >> n;\\n    if (n == 0) {\\n        return 0;\\n    }\\n\\n    int *arr = new int[n];\\n    std::cout << \\\"Enter any \\\" << n << \\\" Numbers for Unsorted Array : \\\";\\n\\n    for (int i = 0; i < n; i++) {\\n        std::cin >> arr[i];\\n    }\\n\\n    sorting::insertionSort(arr, n);\\n\\n    std::cout << \\\"\\\\nSorted Array : \\\";\\n    for (int i = 0; i < n; i++) {\\n        std::cout << arr[i] << \\\" \\\";\\n    }\\n\\n    std::cout << std::endl;\\n    delete[] arr;\\n    return 0;\\n}\\n\"",
    "library sort": "\"#include <algorithm>\\n#include <iostream>\\n\\nvoid librarySort(int *index, int n) {\\n    int lib_size, index_pos,\\n        *gaps,        // gaps\\n        *library[2];  // libraries\\n\\n    bool target_lib, *numbered;\\n\\n    for (int i = 0; i < 2; i++) library[i] = new int[n];\\n\\n    gaps = new int[n + 1];\\n    numbered = new bool[n + 1];\\n\\n    lib_size = 1;\\n    index_pos = 1;\\n    target_lib = 0;\\n    library[target_lib][0] = index[0];\\n\\n    while (index_pos < n) {\\n        // binary search\\n        int insert = std::distance(\\n            library[target_lib],\\n            std::lower_bound(library[target_lib],\\n                             library[target_lib] + lib_size, index[index_pos]));\\n\\n        // if there is no gap to insert a new index ...\\n\\n        if (numbered[insert] == true) {\\n            int prov_size = 0, next_target_lib = !target_lib;\\n\\n            // update library and clear gaps\\n\\n            for (int i = 0; i <= n; i++) {\\n                if (numbered[i] == true) {\\n                    library[next_target_lib][prov_size] = gaps[i];\\n                    prov_size++;\\n                    numbered[i] = false;\\n                }\\n\\n                if (i <= lib_size) {\\n                    library[next_target_lib][prov_size] =\\n                        library[target_lib][i];\\n                    prov_size++;\\n                }\\n            }\\n\\n            target_lib = next_target_lib;\\n            lib_size = prov_size - 1;\\n        } else {\\n            numbered[insert] = true;\\n            gaps[insert] = index[index_pos];\\n            index_pos++;\\n        }\\n    }\\n\\n    int index_pos_for_output = 0;\\n    for (int i = 0; index_pos_for_output < n; i++) {\\n        if (numbered[i] == true) {\\n            // std::cout << gaps[i] << std::endl;\\n            index[index_pos_for_output] = gaps[i];\\n            index_pos_for_output++;\\n        }\\n\\n        if (i < lib_size) {\\n            // std::cout << library[target_lib][i] << std::endl;\\n            index[index_pos_for_output] = library[target_lib][i];\\n            index_pos_for_output++;\\n        }\\n    }\\n}\\n\\nint main() {\\n    // ---example--\\n    int index_ex[] = {-6, 5, 9, 1, 9, 1, 0, 1, -8, 4, -12};\\n    int n_ex = sizeof(index_ex) / sizeof(index_ex[0]);\\n\\n    librarySort(index_ex, n_ex);\\n    std::cout << \\\"sorted array :\\\" << std::endl;\\n    for (int i = 0; i < n_ex; i++) std::cout << index_ex[i] << \\\" \\\";\\n    std::cout << std::endl;\\n\\n    /* --output--\\n    sorted array :\\n    -12 -8 -6 0 1 1 1 4 5 9 9\\n    */\\n}\\n\"",
    "merge insertion sort": "\"/**\\n * @file\\n * @author [@sinkyoungdeok](https://github.com/sinkyoungdeok)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Algorithm that combines insertion sort and merge sort. [Wiki\\n * link](https://en.wikipedia.org/wiki/Merge-insertion_sort)\\n *\\n * @see Individual algorithms: insertion_sort.cpp and merge_sort.cpp\\n */\\n#include <algorithm>\\n#include <array>\\n#include <cassert>\\n#include <ctime>\\n#include <iostream>\\n#include <memory>\\n\\n/** \\\\namespace sorting\\n * \\\\brief Sorting algorithms\\n */\\nnamespace sorting {\\n/** \\\\namespace merge_insertion\\n * \\\\brief Combined Intersion-Merge sorting algorithm\\n */\\nnamespace merge_insertion {\\n\\n/**\\n * @brief Insertion merge algorithm\\n * @see insertion_sort.cpp\\n *\\n * @tparam T array data type\\n * @tparam N length of array\\n * @param A pointer to array to sort\\n * @param start start index of sorting window\\n * @param end end index of sorting window\\n */\\ntemplate <typename T, size_t N>\\nstatic void InsertionSort(std::array<T, N> *A, size_t start, size_t end) {\\n    size_t i = 0, j = 0;\\n    T *ptr = A->data();\\n\\n    for (i = start; i < end; i++) {\\n        T temp = ptr[i];\\n        j = i;\\n        while (j > start && temp < ptr[j - 1]) {\\n            ptr[j] = ptr[j - 1];\\n            j--;\\n        }\\n        //   for (j = i; j > start && temp < ptr[j - 1]; --j) {\\n        //       ptr[j] = ptr[j - 1];\\n        //   }\\n\\n        ptr[j] = temp;\\n    }\\n}\\n\\n/**\\n * @brief Perform merge of data in a window\\n *\\n * @tparam T array data type\\n * @tparam N length of array\\n * @param A pointer to array to sort\\n * @param min start index of window\\n * @param max end index of window\\n * @param mid mid-point of window\\n */\\ntemplate <typename T, size_t N>\\nstatic void merge(std::array<T, N> *array, size_t min, size_t max, size_t mid) {\\n    size_t firstIndex = min;\\n    size_t secondIndex = mid + 1;\\n\\n    auto ptr = array->data();\\n    std::array<T, N + 1> tempArray{0};\\n\\n    // While there are elements in the left or right runs\\n    for (size_t index = min; index <= max; index++) {\\n        // If left run head exists and is <= existing right run head.\\n        if (firstIndex <= mid &&\\n            (secondIndex > max || ptr[firstIndex] <= ptr[secondIndex])) {\\n            tempArray[index] = ptr[firstIndex];\\n            firstIndex++;\\n        } else {\\n            tempArray[index] = ptr[secondIndex];\\n            secondIndex++;\\n        }\\n    }\\n\\n    // transfer to the initial array\\n    memcpy(ptr + min, tempArray.data() + min, (max - min) * sizeof(T));\\n    //  for (int index = min; index <= max; index++) ptr[index] =\\n    //  tempArray[index];\\n}\\n\\n/**\\n * @brief Final combined algorithm.\\n * Algorithm utilizes ::sorting::merge_insertion::InsertionSort if window length\\n * is less than threshold, else performs merge sort recursively using\\n * ::sorting::merge_insertion::mergeSort\\n *\\n * @tparam T array data type\\n * @tparam N length of array\\n * @param A pointer to array to sort\\n * @param min start index of sort window\\n * @param max end index of sort window\\n * @param threshold window length threshold\\n */\\ntemplate <typename T, size_t N>\\nvoid mergeSort(std::array<T, N> *array, size_t min, size_t max,\\n               size_t threshold) {\\n    // prerequisite\\n    if ((max - min) <= threshold) {\\n        InsertionSort(array, min, max);\\n    } else {\\n        // get the middle point\\n        size_t mid = (max + min) >> 1;\\n\\n        // apply merge sort to both parts of this\\n        mergeSort(array, min, mid, threshold);\\n        mergeSort(array, mid, max, threshold);\\n\\n        // and finally merge all that sorted stuff\\n        merge(array, min, max, mid);\\n    }\\n}\\n\\n}  // namespace merge_insertion\\n}  // namespace sorting\\n\\n/**\\n * @brief Function to test code using random arrays\\n * @returns none\\n */\\nstatic void test() {\\n    constexpr size_t size = 30;\\n    std::array<int, size> array{0};\\n    // input\\n    for (int i = 0; i < size; i++) {\\n        array[i] = std::rand() % 100 - 50;\\n        std::cout << array[i] << \\\" \\\";\\n    }\\n    std::cout << std::endl;\\n\\n    sorting::merge_insertion::InsertionSort(&array, 0, size);\\n    //  sorting::merge_insertion::mergeSort(&array, 0, size, 10);\\n\\n    // output\\n    for (int i = 0; i < size; ++i) {\\n        std::cout << array[i] << \\\" \\\";\\n    }\\n    std::cout << std::endl;\\n\\n    assert(std::is_sorted(std::begin(array), std::end(array)));\\n    std::cout << \\\"Test passed\\\\n\\\";\\n}\\n\\n/**\\n * @brief Main function\\n * @return 0 on exit\\n */\\nint main() {\\n    std::srand(std::time(nullptr));\\n    test();\\n    return 0;\\n}\\n\"",
    "merge sort": "\"/**\\n *  \\\\addtogroup sorting Sorting Algorithms\\n *  @{\\n *  \\\\file\\n *  \\\\brief [Merege Sort Algorithm\\n *  (MEREGE SORT)](https://en.wikipedia.org/wiki/Merge_sort) implementation\\n *\\n *  \\\\author [Ayaan Khan](http://github.com/ayaankhan98)\\n *\\n *  \\\\details\\n *  Merge Sort is an efficient, general purpose, comparison\\n *  based sorting algorithm.\\n *  Merge Sort is a divide and conquer algorithm\\n *\\n */\\n#include <iostream>\\n\\n/**\\n *\\n * The merge() function is used for merging two halves.\\n * The merge(arr, l, m, r) is key process that assumes that\\n * arr[l..m] and arr[m+1..r] are sorted and merges the two\\n * sorted sub-arrays into one.\\n *\\n * @param arr - array with two halves arr[l...m] and arr[m+1...l]\\n * @param l - left index or start index of first half array\\n * @param m - right index or end index of first half array\\n *\\n * (The second array starts form m+1 and goes till l)\\n *\\n * @param l - end index or right index of second half array\\n */\\nvoid merge(int *arr, int l, int m, int r) {\\n    int i, j, k;\\n    int n1 = m - l + 1;\\n    int n2 = r - m;\\n\\n    int *L = new int[n1], *R = new int[n2];\\n\\n    for (i = 0; i < n1; i++) L[i] = arr[l + i];\\n    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];\\n\\n    i = 0;\\n    j = 0;\\n    k = l;\\n    while (i < n1 || j < n2) {\\n        if (j >= n2 || (i < n1 && L[i] <= R[j])) {\\n            arr[k] = L[i];\\n            i++;\\n        } else {\\n            arr[k] = R[j];\\n            j++;\\n        }\\n        k++;\\n    }\\n\\n    delete[] L;\\n    delete[] R;\\n}\\n\\n/**\\n * Merge sort is a divide and conquer algorithm, it divides the\\n * input array into two halves and calls itself for the two halves\\n * and then calls merge() to merge the two halves\\n *\\n * @param arr - array to be sorted\\n * @param l - left index or start index of array\\n * @param r - right index or end index of array\\n *\\n */\\nvoid mergeSort(int *arr, int l, int r) {\\n    if (l < r) {\\n        int m = l + (r - l) / 2;\\n        mergeSort(arr, l, m);\\n        mergeSort(arr, m + 1, r);\\n        merge(arr, l, m, r);\\n    }\\n}\\n\\n/**\\n * Utility function used to print the array after\\n * sorting\\n */\\nvoid show(int *arr, int size) {\\n    for (int i = 0; i < size; i++) std::cout << arr[i] << \\\" \\\";\\n    std::cout << \\\"\\\\n\\\";\\n}\\n\\n/** Main function */\\nint main() {\\n    int size;\\n    std::cout << \\\"Enter the number of elements : \\\";\\n    std::cin >> size;\\n    int *arr = new int[size];\\n    std::cout << \\\"Enter the unsorted elements : \\\";\\n    for (int i = 0; i < size; ++i) {\\n        std::cin >> arr[i];\\n    }\\n    mergeSort(arr, 0, size - 1);\\n    std::cout << \\\"Sorted array : \\\";\\n    show(arr, size);\\n    delete[] arr;\\n    return 0;\\n}\\n/** @} */\\n\"",
    "non recursive merge sort": "\"/**\\n * Copyright 2020 @author Albirair\\n * @file\\n *\\n * A generic implementation of non-recursive merge sort.\\n */\\n#include <cstddef>  // for size_t\\n#include <iostream>\\n#include <utility>  // for std::move & std::remove_reference_t\\n\\nnamespace sorting {\\ntemplate <class Iterator>\\nvoid merge(Iterator, Iterator, const Iterator, char[]);\\n/// bottom-up merge sort which sorts elements in a non-decreasing order\\n/**\\n * sorts elements non-recursively by breaking them into small segments,\\n * merging adjacent segments into larger sorted segments, then increasing\\n * the sizes of segments by factors of 2 and repeating the same process.\\n * best-case = worst-case = O(n log(n))\\n * @param first points to the first element\\n * @param last points to 1-step past the last element\\n * @param n the number of elements\\n */\\ntemplate <class Iterator>\\nvoid non_recursive_merge_sort(const Iterator first, const Iterator last,\\n                              const size_t n) {\\n    // create a buffer large enough to store all elements\\n    // dynamically allocated to comply with cpplint\\n    char* buffer = new char[n * sizeof(*first)];\\n    // buffer size can be optimized to largest power of 2 less than n\\n    // elements divide the container into equally-sized segments whose\\n    // length start at 1 and keeps increasing by factors of 2\\n    for (size_t length(1); length < n; length <<= 1) {\\n        // merge adjacent segments whose number is n / (length * 2)\\n        Iterator left(first);\\n        for (size_t counter(n / (length << 1)); counter; --counter) {\\n            Iterator right(left + length), end(right + length);\\n            merge(left, right, end, buffer);\\n            left = end;\\n        }\\n        // if the number of remaining elements (n * 2 % length) is longer\\n        // than a segment, merge the remaining elements\\n        if ((n & ((length << 1) - 1)) > length)\\n            merge(left, left + length, last, buffer);\\n    }\\n    delete[] buffer;\\n}\\n/// merges 2 sorted adjacent segments into a larger sorted segment\\n/**\\n * best-case = worst-case = O(n)\\n * @param l points to the left part\\n * @param r points to the right part, end of left part\\n * @param e points to end of right part\\n * @param b points at the buffer\\n */\\ntemplate <class Iterator>\\nvoid merge(Iterator l, Iterator r, const Iterator e, char b[]) {\\n    // create 2 pointers to point at the buffer\\n    auto p(reinterpret_cast<std::remove_reference_t<decltype(*l)>*>(b)), c(p);\\n    // move the left part of the segment\\n    for (Iterator t(l); r != t; ++t) *p++ = std::move(*t);\\n    // while neither the buffer nor the right part has been exhausted\\n    // move the smallest element of the two back to the container\\n    while (e != r && c != p) *l++ = std::move(*r < *c ? *r++ : *c++);\\n    // notice only one of the two following loops will be executed\\n    // while the right part hasn't bee exhausted, move it back\\n    while (e != r) *l++ = std::move(*r++);\\n    // while the buffer hasn't bee exhausted, move it back\\n    while (c != p) *l++ = std::move(*c++);\\n}\\n/// bottom-up merge sort which sorts elements in a non-decreasing order\\n/**\\n * @param first points to the first element\\n * @param n the number of elements\\n */\\ntemplate <class Iterator>\\nvoid non_recursive_merge_sort(const Iterator first, const size_t n) {\\n    non_recursive_merge_sort(first, first + n, n);\\n}\\n/// bottom-up merge sort which sorts elements in a non-decreasing order\\n/**\\n * @param first points to the first element\\n * @param last points to 1-step past the last element\\n */\\ntemplate <class Iterator>\\nvoid non_recursive_merge_sort(const Iterator first, const Iterator last) {\\n    non_recursive_merge_sort(first, last, last - first);\\n}\\n\\n}  // namespace sorting\\n\\nusing sorting::non_recursive_merge_sort;\\n\\nint main(int argc, char** argv) {\\n    int size;\\n    std::cout << \\\"Enter the number of elements : \\\";\\n    std::cin >> size;\\n    int* arr = new int[size];\\n    for (int i = 0; i < size; ++i) {\\n        std::cout << \\\"arr[\\\" << i << \\\"] = \\\";\\n        std::cin >> arr[i];\\n    }\\n    non_recursive_merge_sort(arr, size);\\n    std::cout << \\\"Sorted array\\\\n\\\";\\n    for (int i = 0; i < size; ++i)\\n        std::cout << \\\"arr[\\\" << i << \\\"] = \\\" << arr[i] << '\\\\n';\\n    delete[] arr;\\n    return 0;\\n}\\n\"",
    "numeric string sort": "\"// Using general algorithms to sort a collection of strings results in\\n// alphanumeric sort. If it is a numeric string, it leads to unnatural sorting\\n\\n// eg, an array of strings 1,10,100,2,20,200,3,30,300\\n// would be sorted in that same order by using conventional sorting,\\n// even though we know the correct sorting order is 1,2,3,10,20,30,100,200,300\\n\\n// This Programme uses a comparator to sort the array in Numerical order instead\\n// of Alphanumeric order\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <vector>\\n\\nbool NumericSort(std::string a, std::string b) {\\n    while (a[0] == '0') {\\n        a.erase(a.begin());\\n    }\\n    while (b[0] == '0') {\\n        b.erase(b.begin());\\n    }\\n    int n = a.length();\\n    int m = b.length();\\n    if (n == m)\\n        return a < b;\\n    return n < m;\\n}\\n\\nint main() {\\n    int n;\\n    std::cout << \\\"Enter number of elements to be sorted Numerically\\\\n\\\";\\n    std::cin >> n;\\n\\n    std::vector<std::string> v(n);\\n    std::cout << \\\"Enter the string of Numbers\\\\n\\\";\\n    for (int i = 0; i < n; i++) {\\n        std::cin >> v[i];\\n    }\\n\\n    sort(v.begin(), v.end());\\n    std::cout << \\\"Elements sorted normally \\\\n\\\";\\n    for (int i = 0; i < n; i++) {\\n        std::cout << v[i] << \\\" \\\";\\n    }\\n    std::cout << \\\"\\\\n\\\";\\n\\n    std::sort(v.begin(), v.end(), NumericSort);\\n    std::cout << \\\"Elements sorted Numerically \\\\n\\\";\\n    for (int i = 0; i < n; i++) {\\n        std::cout << v[i] << \\\" \\\";\\n    }\\n\\n    return 0;\\n}\\n\"",
    "odd even sort": "\"/* C++ implementation Odd Even Sort */\\n#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nvoid oddEven(vector<int> &arr, int size) {\\n    bool sorted = false;\\n    while (!sorted) {\\n        sorted = true;\\n        for (int i = 1; i < size - 1; i += 2)  // Odd\\n        {\\n            if (arr[i] > arr[i + 1]) {\\n                swap(arr[i], arr[i + 1]);\\n                sorted = false;\\n            }\\n        }\\n\\n        for (int i = 0; i < size - 1; i += 2)  // Even\\n        {\\n            if (arr[i] > arr[i + 1]) {\\n                swap(arr[i], arr[i + 1]);\\n                sorted = false;\\n            }\\n        }\\n    }\\n}\\n\\nvoid show(vector<int> A, int size) {\\n    int i;\\n    for (i = 0; i < size; i++) cout << A[i] << \\\"\\\\n\\\";\\n}\\n\\nint main() {\\n    int size, temp;\\n    cout << \\\"\\\\nEnter the number of elements : \\\";\\n    cin >> size;\\n\\n    vector<int> arr;\\n\\n    cout << \\\"\\\\nEnter the unsorted elements : \\\\n\\\";\\n\\n    for (int i = 0; i < size; ++i) {\\n        cin >> temp;\\n        arr.push_back(temp);\\n    }\\n\\n    oddEven(arr, size);\\n\\n    cout << \\\"Sorted array\\\\n\\\";\\n    show(arr, size);\\n    return 0;\\n}\\n\"",
    "pancake sort": "\"/**\\n * @file\\n * @brief pancake sort sorts a disordered stack of pancakes by flipping any\\n * number of pancakes using a spatula using minimum number of flips.\\n *\\n * @details\\n * Unlike a traditional sorting algorithm, which attempts to sort with the\\n * fewest comparisons possible, the goal is to sort the sequence in as few\\n * reversals as possible. Overall time complexity of pancake sort is O(n^2) For\\n * example: example 1:- Disordered pancake sizes: {2,5,3,7,8} Sorted:\\n * {2,3,5,7,8} For example: example 2:- Disordered pancake sizes:\\n * {22,51,37,73,81} Sorted: {22,37,51,73,81}\\n * @author [Divyansh Gupta](https://github.com/divyansh12323)\\n * @see more on [Pancake sort](https://en.wikipedia.org/wiki/Pancake_sorting)\\n * @see related problem at\\n * [Leetcode](https://leetcode.com/problems/pancake-sorting/)\\n */\\n\\n#include <algorithm>  // for std::is_sorted\\n#include <cassert>    // for std::assert\\n#include <iostream>   // for io operations\\n#include <vector>     // for std::vector\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * @namespace pancake_sort\\n * @brief Functions for [Pancake\\n * sort](https://en.wikipedia.org/wiki/Pancake_sorting) algorithm\\n */\\nnamespace pancake_sort {\\n/**\\n * @brief This implementation is for reversing elements in a a C-style array .\\n * @param [start,end] arr our vector of elements.\\n * @param start starting index of array\\n * @param end ending index of array\\n * @returns void\\n */\\ntemplate <typename T>\\nvoid reverse(std::vector<T> &arr, int start, int end) {\\n    T temp;  // Temporary variable\\n    while (start <= end) {\\n        temp = arr[start];\\n        arr[start] = arr[end];\\n        arr[end] = temp;\\n        start++;\\n        end--;\\n    }\\n}\\n/**\\n * @brief This implementation is for a C-style array input that gets modified in\\n * place.\\n * @param [start,end] arr our vector of elements.\\n * @param size size of given array\\n * @returns 0 on exit\\n */\\ntemplate <typename T>\\nint pancakeSort(std::vector<T> &arr, int size) {\\n    for (int i = size; i > 1; --i) {\\n        int max_index = 0, j = 0;  // intialize some variables.\\n        T max_value = 0;\\n        for (j = 0; j < i; j++) {\\n            if (arr[j] >= max_value) {\\n                max_value = arr[j];\\n                max_index = j;\\n            }\\n        }\\n        if (max_index != i - 1)  // check for reversing\\n        {\\n            reverse(arr, 0, max_index);\\n            reverse(arr, 0, i - 1);\\n        }\\n    }\\n    return 0;\\n}\\n}  // namespace pancake_sort\\n}  // namespace sorting\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // example 1: vector of int\\n    const int size1 = 7;\\n    std::cout << \\\"\\\\nTest 1- as std::vector<int>...\\\";\\n    std::vector<int> arr1 = {23, 10, 20, 11, 12, 6, 7};\\n    sorting::pancake_sort::pancakeSort(arr1, size1);\\n    assert(std::is_sorted(arr1.begin(), arr1.end()));\\n    std::cout << \\\"Passed\\\\n\\\";\\n    for (int i = 0; i < size1; i++) {\\n        std::cout << arr1[i] << \\\" ,\\\";\\n    }\\n    std::cout << std::endl;\\n\\n    // example 2: vector of double\\n    const int size2 = 8;\\n    std::cout << \\\"\\\\nTest 2- as std::vector<double>...\\\";\\n    std::vector<double> arr2 = {23.56, 10.62, 200.78, 111.484,\\n                                3.9,   1.2,   61.77,  79.6};\\n    sorting::pancake_sort::pancakeSort(arr2, size2);\\n    assert(std::is_sorted(arr2.begin(), arr2.end()));\\n    std::cout << \\\"Passed\\\\n\\\";\\n    for (int i = 0; i < size2; i++) {\\n        std::cout << arr2[i] << \\\", \\\";\\n    }\\n    std::cout << std::endl;\\n\\n    // example 3:vector of float\\n    const int size3 = 7;\\n    std::cout << \\\"\\\\nTest 3- as std::vector<float>...\\\";\\n    std::vector<float> arr3 = {6.56, 12.62, 200.78, 768.484, 19.27, 68.87, 9.6};\\n    sorting::pancake_sort::pancakeSort(arr3, size3);\\n    assert(std::is_sorted(arr3.begin(), arr3.end()));\\n    std::cout << \\\"Passed\\\\n\\\";\\n    for (int i = 0; i < size3; i++) {\\n        std::cout << arr3[i] << \\\", \\\";\\n    }\\n    std::cout << std::endl;\\n}\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();\\n    return 0;\\n}\\n\"",
    "pigeonhole sort": "\"/**\\n * @file\\n * @brief Implementation of [Pigeonhole Sort algorithm]\\n * (https://en.wikipedia.org/wiki/Pigeonhole_sort)\\n * @author [Lownish](https://github.com/Lownish)\\n * @details\\n * Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists\\n * of elements where the number of elements and the number of possible key\\n * values are approximately the same. It requires O(n + Range) time where n is\\n * number of elements in input array and ‘Range’ is number of possible values in\\n * array.\\n *\\n * The time Complexity of the algorithm is \\\\f$O(n+N)\\\\f$.\\n */\\n\\n#include <algorithm>  //for std::is_sorted\\n#include <array>      //for std::array\\n#include <cassert>    //for assert\\n#include <iostream>   //for io operations\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n\\n/**\\n * Pigeonhole sorting of array of size n\\n * The function will sort the array through Pigeonhole algorithm and print\\n * @param arr unsorted array of elements\\n * @returns sorted array of elements\\n */\\ntemplate <std::size_t N>\\nstd::array<int, N> pigeonSort(std::array<int, N> arr) {\\n    // Finding min and max*\\n    auto min = std::min_element(std::begin(arr), std::end(arr));\\n    auto max = std::max_element(std::begin(arr), std::end(arr));\\n\\n    // Range refers to the number of holes required\\n    int range = *max - *min + 1;\\n    int *hole = new int[range]();\\n\\n    // Copying all array values to pigeonhole\\n    for (int i = 0; i < N; i++) {\\n        hole[arr[i] - *min] = arr[i];\\n    }\\n\\n    // Deleting elements from list and storing to original array\\n    int count = 0;\\n    for (int i = 0; i < range; i++) {\\n        while (hole[i] != '\\\\0') {\\n            arr[count] = hole[i];\\n            hole[i] = {};\\n            count++;\\n        }\\n    }\\n    delete[] hole;\\n\\n    return arr;\\n}\\n}  // namespace sorting\\n\\n/**\\n * Test function 1 with unsorted array\\n * {8, 3, 2, 7, 4, 6, 8}\\n * @returns none\\n */\\nstatic void test_1() {\\n    const int n = 7;\\n    std::array<int, n> test_array = {8, 3, 2, 7, 4, 6, 8};\\n\\n    test_array = sorting::pigeonSort<n>(test_array);\\n\\n    assert(std::is_sorted(std::begin(test_array), std::end(test_array)));\\n\\n    // Printing sorted array\\n    for (int i = 0; i < n; i++) {\\n        std::cout << test_array.at(i) << \\\" \\\";\\n    }\\n    std::cout << \\\"\\\\nPassed\\\\n\\\";\\n}\\n\\n/**\\n * Test function 2 with unsorted array\\n * {802, 630, 20, 745, 52, 300, 612, 932, 78, 187}\\n * @returns none\\n */\\nstatic void test_2() {\\n    const int n = 10;\\n    std::array<int, n> test_array = {802, 630, 20,  745, 52,\\n                                     300, 612, 932, 78,  187};\\n\\n    test_array = sorting::pigeonSort<n>(test_array);\\n\\n    assert(std::is_sorted(std::begin(test_array), std::end(test_array)));\\n\\n    // Printing sorted array\\n    for (int i = 0; i < n; i++) {\\n        std::cout << test_array.at(i) << \\\" \\\";\\n    }\\n    std::cout << \\\"\\\\nPassed\\\\n\\\";\\n}\\n\\n/**\\n * Test function 1 with unsorted array\\n * {11,13,12,14}\\n * @returns none\\n */\\nstatic void test_3() {\\n    const int n = 4;\\n    std::array<int, n> test_array = {11, 13, 12, 14};\\n\\n    test_array = sorting::pigeonSort<n>(test_array);\\n\\n    assert(std::is_sorted(std::begin(test_array), std::end(test_array)));\\n\\n    // Printing sorted array\\n    for (int i = 0; i < n; i++) {\\n        std::cout << test_array.at(i) << \\\" \\\";\\n    }\\n    std::cout << \\\"\\\\nPassed\\\\n\\\";\\n}\\n\\n/**\\n * Main function\\n */\\nint main() {\\n    test_1();\\n    test_2();\\n    test_3();\\n\\n    return 0;\\n}\\n\"",
    "quick sort": "\"/**\\n * @file\\n * @brief Quick sort algorithm\\n *\\n * Implementation Details -\\n *      Quick Sort is a divide and conquer algorithm. It picks and element as\\n *      pivot and partition the given array around the picked pivot. There\\n *      are many different versions of quickSort that pick pivot in different\\n *      ways.\\n *\\n *      1. Always pick the first element as pivot\\n *      2. Always pick the last element as pivot (implemented below)\\n *      3. Pick a random element as pivot\\n *      4. Pick median as pivot\\n *\\n *      The key process in quickSort is partition(). Target of partition is,\\n *      given an array and an element x(say) of array as pivot, put x at it's\\n *      correct position in sorted array and put all smaller elements (samller\\n *      than x) before x, and put all greater elements (greater than x) after\\n *      x. All this should be done in linear time\\n *\\n */\\n\\n#include <cstdlib>\\n#include <iostream>\\n\\nnamespace sorting {\\n/**\\n *      This function takes last element as pivot, places\\n *      the pivot element at its correct position in sorted\\n *      array, and places all smaller (smaller than pivot)\\n *      to left of pivot and all greater elements to right\\n *      of pivot\\n *\\n */\\n\\nint partition(int arr[], int low, int high) {\\n    int pivot = arr[high];  // taking the last element as pivot\\n    int i = (low - 1);      // Index of smaller element\\n\\n    for (int j = low; j < high; j++) {\\n        // If current element is smaller than or\\n        // equal to pivot\\n        if (arr[j] <= pivot) {\\n            i++;  // increment index of smaller element\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n        }\\n    }\\n    int temp = arr[i + 1];\\n    arr[i + 1] = arr[high];\\n    arr[high] = temp;\\n    return (i + 1);\\n}\\n\\n/**\\n *      The main function that implements QuickSort\\n *      arr[] --> Array to be sorted,\\n *      low --> Starting index,\\n *      high --> Ending index\\n */\\nvoid quickSort(int arr[], int low, int high) {\\n    if (low < high) {\\n        int p = partition(arr, low, high);\\n        quickSort(arr, low, p - 1);\\n        quickSort(arr, p + 1, high);\\n    }\\n}\\n\\n}  // namespace sorting\\n\\nusing sorting::quickSort;\\n\\n// prints the array after sorting\\nvoid show(int arr[], int size) {\\n    for (int i = 0; i < size; i++) std::cout << arr[i] << \\\" \\\";\\n    std::cout << \\\"\\\\n\\\";\\n}\\n\\n/** Driver program to test above functions */\\nint main() {\\n    int size;\\n    std::cout << \\\"\\\\nEnter the number of elements : \\\";\\n\\n    std::cin >> size;\\n\\n    int *arr = new int[size];\\n\\n    std::cout << \\\"\\\\nEnter the unsorted elements : \\\";\\n\\n    for (int i = 0; i < size; ++i) {\\n        std::cout << \\\"\\\\n\\\";\\n        std::cin >> arr[i];\\n    }\\n    quickSort(arr, 0, size);\\n    std::cout << \\\"Sorted array\\\\n\\\";\\n    show(arr, size);\\n    delete[] arr;\\n    return 0;\\n}\\n\"",
    "quick sort 3": "\"/**\\n * @file\\n * @brief Implementation Details\\n * @details Quick sort 3 works on Dutch National Flag Algorithm\\n * The major difference between simple quicksort and quick sort 3 comes in the\\n * function partition3 In quick_sort_partition3 we divide the vector/array into\\n * 3 parts. quick sort 3 works faster in some cases as compared to simple\\n * quicksort.\\n * @author immortal-j\\n * @author [Krishna Vedala](https://github/kvedala)\\n */\\n#include <algorithm>\\n#include <cassert>\\n#include <ctime>\\n#include <iostream>\\n#include <vector>\\n\\nnamespace {\\n/**\\n * Operator to print the array.\\n * @param out std::ostream object to write to\\n * @param arr array to write\\n */\\ntemplate <typename T>\\nstd::ostream &operator<<(std::ostream &out, const std::vector<T> &arr) {\\n    for (size_t i = 0; i < arr.size(); ++i) {\\n        out << arr[i];\\n        if (i < arr.size() - 1) {\\n            out << \\\", \\\";\\n        }\\n    }\\n    return out;\\n}\\n\\n}  // namespace\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting Algorithms\\n */\\nnamespace sorting {\\nnamespace {  // using un-named namespace here to prevent partition function\\n             // being visible to end-users\\n/** This function partitions `arr[]` in three parts\\n * 1. \\\\f$arr[l\\\\ldots i]\\\\f$ contains all elements smaller than pivot\\n * 2. \\\\f$arr[(i+1)\\\\ldots (j-1)]\\\\f$ contains all occurrences of pivot\\n * 3. \\\\f$arr[j\\\\ldots r]\\\\f$ contains all elements greater than pivot\\n * @tparam T type of data in the vector array\\n * @param [in,out] arr vector array being partitioned\\n * @param [in] low lower limit of window to partition\\n * @param [in] high upper limit of window to partition\\n * @param [out] i updated lower limit of partition\\n * @param [out] j updated upper limit of partition\\n */\\ntemplate <typename T>\\nvoid partition3(std::vector<T> *arr, int32_t low, int32_t high, int32_t *i,\\n                int32_t *j) {\\n    // To handle 2 elements\\n    if (high - low <= 1) {\\n        if ((*arr)[high] < (*arr)[low]) {\\n            std::swap((*arr)[high], (*arr)[low]);\\n        }\\n        *i = low;\\n        *j = high;\\n        return;\\n    }\\n\\n    int32_t mid = low;\\n    T pivot = (*arr)[high];\\n    while (mid <= high) {\\n        if ((*arr)[mid] < pivot) {\\n            std::swap((*arr)[low++], (*arr)[mid++]);\\n        } else if ((*arr)[mid] == pivot) {\\n            mid++;\\n        } else if ((*arr)[mid] > pivot) {\\n            std::swap((*arr)[mid], (*arr)[high--]);\\n        }\\n    }\\n\\n    // update i and j\\n    *i = low - 1;\\n    *j = mid;  // or high-1\\n}\\n}  // namespace\\n\\n/** 3-way partition based quick sort. This function accepts array pointer and\\n * modified the input array.\\n * @tparam T type of data in the vector array\\n * @param [in,out] arr vector array to sort\\n * @param [in] low lower limit of window to partition\\n * @param [in] high upper limit of window to partition\\n */\\ntemplate <typename T>\\nvoid quicksort(std::vector<T> *arr, int32_t low, int32_t high) {\\n    if (low >= high) {  // 1 or 0 elements\\n        return;\\n    }\\n\\n    int32_t i = 0, j = 0;\\n\\n    // i and j are passed as reference\\n    partition3(arr, low, high, &i, &j);\\n\\n    // Recur two halves\\n    quicksort(arr, low, i);\\n    quicksort(arr, j, high);\\n}\\n\\n/** 3-way partition based quick sort. This function accepts array by value and\\n * creates a copy of it. The array copy gets sorted and returned by the\\n * function.\\n * @tparam T type of data in the vector array\\n * @param [in] arr vector array to sort\\n * @param [in] low lower limit of window to partition\\n * @param [in] high upper limit of window to partition\\n * @returns sorted array vector\\n */\\ntemplate <typename T>\\nstd::vector<T> quicksort(std::vector<T> arr, int32_t low, int32_t high) {\\n    if (low >= high) {  // 1 or 0 elements\\n        return arr;\\n    }\\n\\n    int32_t i = 0, j = 0;\\n\\n    // i and j are passed as reference\\n    partition3(&arr, low, high, &i, &j);\\n\\n    // Recur two halves\\n    quicksort(&arr, low, i);\\n    quicksort(&arr, j, high);\\n\\n    return arr;\\n}\\n}  // namespace sorting\\n\\n/** Test function for integer type arrays */\\nstatic void test_int() {\\n    std::cout << \\\"\\\\nTesting integer type arrays\\\\n\\\";\\n\\n    for (int num_tests = 1; num_tests < 21; num_tests++) {\\n        size_t size = std::rand() % 500;\\n        std::vector<int> arr(size);\\n        for (auto &a : arr) {\\n            a = std::rand() % 500 - 250;  // random numbers between -250, 249\\n        }\\n\\n        std::cout << \\\"Test \\\" << num_tests << \\\"\\\\t Array size:\\\" << size << \\\"\\\\t \\\";\\n        std::vector<int> sorted = sorting::quicksort(arr, 0, size - 1);\\n        if (size < 20) {\\n            std::cout << \\\"\\\\t Sorted Array is:\\\\n\\\\t\\\";\\n            std::cout << sorted << \\\"\\\\n\\\";\\n        }\\n        assert(std::is_sorted(std::begin(sorted), std::end(sorted)));\\n        std::cout << \\\"\\\\t Passed\\\\n\\\";\\n    }\\n}\\n\\n/** Test function for double type arrays */\\nstatic void test_double() {\\n    std::cout << \\\"\\\\nTesting Double type arrays\\\\n\\\";\\n    for (int num_tests = 1; num_tests < 21; num_tests++) {\\n        size_t size = std::rand() % 500;\\n        std::vector<double> arr(size);\\n        for (auto &a : arr) {\\n            a = double(std::rand() % 500) -\\n                250.f;   // random numbers between -250, 249\\n            a /= 100.f;  // convert to -2.5 to 2.49\\n        }\\n\\n        std::cout << \\\"Test \\\" << num_tests << \\\"\\\\t Array size:\\\" << size << \\\"\\\\t \\\";\\n        std::vector<double> sorted = sorting::quicksort(arr, 0, size - 1);\\n        if (size < 20) {\\n            std::cout << \\\"\\\\t Sorted Array is:\\\\n\\\\t\\\";\\n            std::cout << sorted << \\\"\\\\n\\\";\\n        }\\n        assert(std::is_sorted(std::begin(sorted), std::end(sorted)));\\n        std::cout << \\\"\\\\t Passed\\\\n\\\";\\n    }\\n}\\n\\n/** Driver program for above functions */\\nint main() {\\n    std::srand(std::time(nullptr));\\n    test_int();\\n    test_double();\\n    return 0;\\n}\\n\"",
    "radix sort": "\"#include <cmath>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n\\nvoid radixsort(int a[], int n) {\\n    int count[10];\\n    int* output = new int[n];\\n    memset(output, 0, n * sizeof(*output));\\n    memset(count, 0, sizeof(count));\\n    int max = 0;\\n    for (int i = 0; i < n; ++i) {\\n        if (a[i] > max) {\\n            max = a[i];\\n        }\\n    }\\n    int maxdigits = 0;\\n    while (max) {\\n        maxdigits++;\\n        max /= 10;\\n    }\\n    for (int j = 0; j < maxdigits; j++) {\\n        for (int i = 0; i < n; i++) {\\n            int t = std::pow(10, j);\\n            count[(a[i] % (10 * t)) / t]++;\\n        }\\n        int k = 0;\\n        for (int p = 0; p < 10; p++) {\\n            for (int i = 0; i < n; i++) {\\n                int t = std::pow(10, j);\\n                if ((a[i] % (10 * t)) / t == p) {\\n                    output[k] = a[i];\\n                    k++;\\n                }\\n            }\\n        }\\n        memset(count, 0, sizeof(count));\\n        for (int i = 0; i < n; ++i) {\\n            a[i] = output[i];\\n        }\\n    }\\n    delete[] output;\\n}\\n\\nvoid print(int a[], int n) {\\n    for (int i = 0; i < n; ++i) {\\n        std::cout << a[i] << \\\" \\\";\\n    }\\n    std::cout << std::endl;\\n}\\n\\nint main(int argc, char const* argv[]) {\\n    int a[] = {170, 45, 75, 90, 802, 24, 2, 66};\\n    int n = sizeof(a) / sizeof(a[0]);\\n    radixsort(a, n);\\n    print(a, n);\\n    return 0;\\n}\\n\"",
    "radix sort2": "\"/**\\n * @file\\n * @brief Algorithm of [Radix sort](https://en.wikipedia.org/wiki/Radix_sort)\\n * @author [Suyash Jaiswal](https://github.com/Suyashjaiswal)\\n * @details\\n * Sort the vector of unsigned integers using radix sort i.e. sorting digit by\\n * digit using [Counting Sort](https://en.wikipedia.org/wiki/Counting_sort) as\\n * subroutine. Running time of radix sort is O(d*(n+b)) where b is the base for\\n * representing numbers and d in the max digits in input integers and n is\\n * number of unsigned integers. consider example for n = 5, aray elements =\\n * 432,234,143,332,123 sorting digit by digit sorting according to 1) 1st digit\\n * place\\n * => 432, 332, 143, 123, 234\\n *\\n * 2) 2nd digit place\\n * => 123, 432, 332, 234, 143\\n *\\n * 3) 3rd digit place\\n * => 123, 143, 234, 332, 432\\n *\\n * using count sort at each step, which is stable.\\n * stable => already sorted according to previous digits.\\n */\\n\\n/// header files\\n#include <algorithm>  /// for collection of functions\\n#include <cassert>  /// for a macro called assert which can be used to verify assumptions\\n#include <iostream>  /// for io operations\\n#include <vector>    /// for std::vector\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * @namespace radix_sort\\n * @brief Functions for [Radix sort](https://en.wikipedia.org/wiki/Radix_sort)\\n * algorithm\\n */\\nnamespace radix_sort {\\n/**\\n * @brief Function to sort vector according to current digit using stable\\n * sorting.\\n * @param cur_digit - sort according to the cur_digit\\n * @param ar - vector to be sorted\\n * @returns std::vector sorted till ith digit\\n */\\nstd::vector<uint64_t> step_ith(\\n    uint16_t cur_digit,\\n    const std::vector<uint64_t>& ar) {  // sorting according to current digit.\\n    int n = ar.size();\\n    std::vector<uint32_t> position(10, 0);\\n    for (int i = 0; i < n; ++i) {\\n        position[(ar[i] / cur_digit) %\\n                 10]++;  // counting frequency of 0-9 at cur_digit.\\n    }\\n    int cur = 0;\\n    for (int i = 0; i < 10; ++i) {\\n        int a = position[i];\\n        position[i] = cur;  // assingning starting position of 0-9.\\n        cur += a;\\n    }\\n    std::vector<uint64_t> temp(n);\\n    for (int i = 0; i < n; ++i) {\\n        temp[position[(ar[i] / cur_digit) % 10]] =\\n            ar[i];  // storing ar[i] in ar[i]'s cur_digit expected position of\\n                    // this step.\\n        position[(ar[i] / cur_digit) %\\n                 10]++;  // incrementing ar[i]'s cur_digit position by 1, as\\n                         // current place used by ar[i].\\n    }\\n    return temp;\\n}\\n/**\\n * @brief Function to sort vector digit by digit.\\n * @param ar - vector to be sorted\\n * @returns sorted vector\\n */\\nstd::vector<uint64_t> radix(const std::vector<uint64_t>& ar) {\\n    uint64_t max_ele =\\n        *max_element(ar.begin(), ar.end());  // returns the max element.\\n    std::vector<uint64_t> temp = ar;\\n    for (int i = 1; max_ele / i > 0;\\n         i *= 10) {  // loop breaks when i > max_ele because no further digits\\n                     // left to makes changes in aray.\\n        temp = step_ith(i, temp);\\n    }\\n    for (uint64_t i : temp) {\\n        std::cout << i << \\\" \\\";\\n    }\\n    std::cout << \\\"\\\\n\\\";\\n    return temp;\\n}\\n}  // namespace radix_sort\\n}  // namespace sorting\\n\\n/**\\n * @brief Function to test the above algorithm\\n * @returns none\\n */\\nstatic void tests() {\\n    /// Test 1\\n    std::vector<uint64_t> ar1 = {432, 234, 143, 332, 123};\\n    ar1 = sorting::radix_sort::radix(ar1);\\n    assert(std::is_sorted(ar1.begin(), ar1.end()));\\n    /// Test 2\\n    std::vector<uint64_t> ar2 = {213, 3214, 123, 111, 112, 142,\\n                                 133, 132,  32,  12,  113};\\n    ar2 = sorting::radix_sort::radix(ar2);\\n    assert(std::is_sorted(ar2.begin(), ar2.end()));\\n}\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    tests();  // execute the tests\\n    return 0;\\n}\\n\"",
    "random pivot quick sort": "\"/**\\n * @file\\n * @brief Implementation of the [Random Pivot Quick\\n * Sort](https://www.sanfoundry.com/cpp-program-implement-quick-sort-using-randomisation)\\n * algorithm.\\n * @details\\n *          * A random pivot quick sort algorithm is pretty much same as quick\\n * sort with a difference of having a logic of selecting next pivot element from\\n * the input array.\\n *          * Where in quick sort is fast, but still can give you the time\\n * complexity of O(n^2) in worst case.\\n *          * To avoid hitting the time complexity of O(n^2), we use the logic\\n * of randomize the selection process of pivot element.\\n *\\n *          ### Logic\\n *              * The logic is pretty simple, the only change is in the\\n * partitioning algorithm, which is selecting the pivot element.\\n *              * Instead of selecting the last or the first element from array\\n * for pivot we use a random index to select pivot element.\\n *              * This avoids hitting the O(n^2) time complexity in practical\\n * use cases.\\n *\\n *       ### Partition Logic\\n *           * Partitions are done such as numbers lower than the \\\"pivot\\\"\\n * element is arranged on the left side of the \\\"pivot\\\", and number larger than\\n * the \\\"pivot\\\" element are arranged on the right part of the array.\\n *\\n *       ### Algorithm\\n *           * Select the pivot element randomly using getRandomIndex() function\\n * from this namespace.\\n *           * Initialize the pInd (partition index) from the start of the\\n * array.\\n *           * Loop through the array from start to less than end. (from start\\n * to < end). (Inside the loop) :-\\n *                   * Check if the current element (arr[i]) is less than the\\n * pivot element in each iteration.\\n *                   * If current element in the iteration is less than the\\n * pivot element, then swap the elements at current index (i) and partition\\n * index (pInd) and increment the partition index by one.\\n *           * At the end of the loop, swap the pivot element with partition\\n * index element.\\n *           * Return the partition index from the function.\\n *\\n * @author [Nitin Sharma](https://github.com/foo290)\\n */\\n\\n#include <algorithm>  /// for std::is_sorted(), std::swap()\\n#include <array>      /// for std::array\\n#include <cassert>    /// for assert\\n#include <ctime>      /// for initializing random number generator\\n#include <iostream>   /// for IO operations\\n#include <tuple>      /// for returning multiple values form a function at once\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * @brief Functions for the [Random Pivot Quick\\n * Sort](https://www.sanfoundry.com/cpp-program-implement-quick-sort-using-randomisation)\\n * implementation\\n * @namespace random_pivot_quick_sort\\n */\\nnamespace random_pivot_quick_sort {\\n/**\\n * @brief Utility function to print the array\\n * @tparam T size of the array\\n * @param arr array used to print its content\\n * @returns void\\n * */\\ntemplate <size_t T>\\nvoid showArray(std::array<int64_t, T> arr) {\\n    for (int64_t i = 0; i < arr.size(); i++) {\\n        std::cout << arr[i] << \\\" \\\";\\n    }\\n    std::cout << std::endl;\\n}\\n\\n/**\\n * @brief Takes the start and end indices of an array and returns a random\\n * int64_teger between the range of those two for selecting pivot element.\\n *\\n * @param start The starting index.\\n * @param end The ending index.\\n * @returns int64_t A random number between start and end index.\\n * */\\nint64_t getRandomIndex(int64_t start, int64_t end) {\\n    srand(time(nullptr));  // Initialize random number generator.\\n    int64_t randomPivotIndex = start + rand() % (end - start + 1);\\n    return randomPivotIndex;\\n}\\n\\n/**\\n * @brief A partition function which handles the partition logic of quick sort.\\n * @tparam size size of the array to be passed as argument.\\n * @param start The start index of the passed array\\n * @param end The ending index of the passed array\\n * @returns std::tuple<int64_t , std::array<int64_t , size>> A tuple of pivot\\n * index and pivot sorted array.\\n */\\ntemplate <size_t size>\\nstd::tuple<int64_t, std::array<int64_t, size>> partition(\\n    std::array<int64_t, size> arr, int64_t start, int64_t end) {\\n    int64_t pivot = arr[end];  // Randomly selected element will be here from\\n                               // caller function (quickSortRP()).\\n    int64_t pInd = start;\\n\\n    for (int64_t i = start; i < end; i++) {\\n        if (arr[i] <= pivot) {\\n            std::swap(arr[i], arr[pInd]);  // swapping the elements from current\\n                                           // index to pInd.\\n            pInd++;\\n        }\\n    }\\n    std::swap(arr[pInd],\\n              arr[end]);  // swapping the pivot element to its sorted position\\n    return std::make_tuple(pInd, arr);\\n}\\n\\n/**\\n * @brief Random pivot quick sort function. This function is the starting point\\n * of the algorithm.\\n * @tparam size size of the array to be passed as argument.\\n * @param start The start index of the passed array\\n * @param end The ending index of the passed array\\n * @returns std::array<int64_t , size> A fully sorted array in ascending order.\\n */\\ntemplate <size_t size>\\nstd::array<int64_t, size> quickSortRP(std::array<int64_t, size> arr,\\n                                      int64_t start, int64_t end) {\\n    if (start < end) {\\n        int64_t randomIndex = getRandomIndex(start, end);\\n\\n        // switching the pivot with right most bound.\\n        std::swap(arr[end], arr[randomIndex]);\\n\\n        int64_t pivotIndex = 0;\\n        // getting pivot index and pivot sorted array.\\n        std::tie(pivotIndex, arr) = partition(arr, start, end);\\n\\n        // Recursively calling\\n        std::array<int64_t, arr.size()> rightSortingLeft =\\n            quickSortRP(arr, start, pivotIndex - 1);\\n        std::array<int64_t, arr.size()> full_sorted =\\n            quickSortRP(rightSortingLeft, pivotIndex + 1, end);\\n        arr = full_sorted;\\n    }\\n    return arr;\\n}\\n\\n/**\\n * @brief A function utility to generate unsorted array of given size and range.\\n * @tparam size Size of the output array.\\n * @param from Stating of the range.\\n * @param to Ending of the range.\\n * @returns std::array<int64_t , size> Unsorted array of specified size.\\n * */\\ntemplate <size_t size>\\nstd::array<int64_t, size> generateUnsortedArray(int64_t from, int64_t to) {\\n    srand(time(nullptr));\\n    std::array<int64_t, size> unsortedArray{};\\n    assert(from < to);\\n    int64_t i = 0;\\n    while (i < size) {\\n        int64_t randomNum = from + rand() % (to - from + 1);\\n        if (randomNum) {\\n            unsortedArray[i] = randomNum;\\n            i++;\\n        }\\n    }\\n    return unsortedArray;\\n}\\n\\n}  // namespace random_pivot_quick_sort\\n}  // namespace sorting\\n\\n/**\\n * @brief a class containing the necessary test cases\\n */\\nclass TestCases {\\n private:\\n    /**\\n     * @brief A function to print64_t given message on console.\\n     * @tparam T Type of the given message.\\n     * @returns void\\n     * */\\n    template <typename T>\\n    void log(T msg) {\\n        // It's just to avoid writing cout and endl\\n        std::cout << \\\"[TESTS] : ---> \\\" << msg << std::endl;\\n    }\\n\\n public:\\n    /**\\n     * @brief Executes test cases\\n     * @returns void\\n     * */\\n    void runTests() {\\n        log(\\\"Running Tests...\\\");\\n\\n        testCase_1();\\n        testCase_2();\\n        testCase_3();\\n\\n        log(\\\"Test Cases over!\\\");\\n        std::cout << std::endl;\\n    }\\n\\n    /**\\n     * @brief A test case with single input\\n     * @returns void\\n     * */\\n    void testCase_1() {\\n        const int64_t inputSize = 1;\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n        log(\\\"This is test case 1 for Random Pivot Quick Sort Algorithm : \\\");\\n        log(\\\"Description:\\\");\\n        log(\\\"   EDGE CASE : Only contains one element\\\");\\n        std::array<int64_t, inputSize> unsorted_arr{2};\\n\\n        int64_t start = 0;\\n        int64_t end = unsorted_arr.size() - 1;  // length - 1\\n\\n        log(\\\"Running algorithm of data of length 50 ...\\\");\\n        std::array<int64_t, unsorted_arr.size()> sorted_arr =\\n            sorting::random_pivot_quick_sort::quickSortRP(unsorted_arr, start,\\n                                                          end);\\n        log(\\\"Algorithm finished!\\\");\\n\\n        log(\\\"Checking assert expression...\\\");\\n        assert(std::is_sorted(sorted_arr.begin(), sorted_arr.end()));\\n        log(\\\"Assertion check passed!\\\");\\n\\n        log(\\\"[PASS] : TEST CASE 1 PASS!\\\");\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n    }\\n\\n    /**\\n     * @brief A test case with input array of length 500\\n     * @returns void\\n     * */\\n    void testCase_2() {\\n        const int64_t inputSize = 500;\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n        log(\\\"Description:\\\");\\n        log(\\\"   BIG INPUT : Contains 500 elements and repeated elements\\\");\\n        log(\\\"This is test case 2 for Random Pivot Quick Sort Algorithm : \\\");\\n        std::array<int64_t, inputSize> unsorted_arr =\\n            sorting::random_pivot_quick_sort::generateUnsortedArray<inputSize>(\\n                1, 10000);\\n\\n        int64_t start = 0;\\n        int64_t end = unsorted_arr.size() - 1;  // length - 1\\n\\n        log(\\\"Running algorithm of data of length 500 ...\\\");\\n        std::array<int64_t, unsorted_arr.size()> sorted_arr =\\n            sorting::random_pivot_quick_sort::quickSortRP(unsorted_arr, start,\\n                                                          end);\\n        log(\\\"Algorithm finished!\\\");\\n\\n        log(\\\"Checking assert expression...\\\");\\n        assert(std::is_sorted(sorted_arr.begin(), sorted_arr.end()));\\n        log(\\\"Assertion check passed!\\\");\\n\\n        log(\\\"[PASS] : TEST CASE 2 PASS!\\\");\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n    }\\n\\n    /**\\n     * @brief A test case with array of length 1000.\\n     * @returns void\\n     * */\\n    void testCase_3() {\\n        const int64_t inputSize = 1000;\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n        log(\\\"This is test case 3 for Random Pivot Quick Sort Algorithm : \\\");\\n        log(\\\"Description:\\\");\\n        log(\\\"   LARGE INPUT : Contains 1000 elements and repeated elements\\\");\\n        std::array<int64_t, inputSize> unsorted_arr =\\n            sorting::random_pivot_quick_sort::generateUnsortedArray<inputSize>(\\n                1, 10000);\\n\\n        int64_t start = 0;\\n        int64_t end = unsorted_arr.size() - 1;  // length - 1\\n\\n        log(\\\"Running algorithm...\\\");\\n        std::array<int64_t, unsorted_arr.size()> sorted_arr =\\n            sorting::random_pivot_quick_sort::quickSortRP(unsorted_arr, start,\\n                                                          end);\\n        log(\\\"Algorithm finished!\\\");\\n\\n        log(\\\"Checking assert expression...\\\");\\n        assert(std::is_sorted(sorted_arr.begin(), sorted_arr.end()));\\n        log(\\\"Assertion check passed!\\\");\\n\\n        log(\\\"[PASS] : TEST CASE 3 PASS!\\\");\\n        log(\\\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\"\\n            \\\"~\\\");\\n    }\\n};\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    TestCases tc = TestCases();\\n    tc.runTests();\\n}\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, char *argv[]) {\\n    test();  // Executes various test cases.\\n\\n    const int64_t inputSize = 10;\\n    std::array<int64_t, inputSize> unsorted_array =\\n        sorting::random_pivot_quick_sort::generateUnsortedArray<inputSize>(\\n            50, 1000);\\n    std::cout << \\\"Unsorted array is : \\\" << std::endl;\\n    sorting::random_pivot_quick_sort::showArray(unsorted_array);\\n\\n    std::array<int64_t, inputSize> sorted_array =\\n        sorting::random_pivot_quick_sort::quickSortRP(\\n            unsorted_array, 0, unsorted_array.size() - 1);\\n    std::cout << \\\"Sorted array is : \\\" << std::endl;\\n    sorting::random_pivot_quick_sort::showArray(sorted_array);\\n    return 0;\\n}\\n\"",
    "recursive bubble sort": "\"/**\\n * @file\\n * @author [Aditya Prakash](https://adityaprakash.tech)\\n * @brief This is an implementation of a recursive version of the [Bubble sort algorithm](https://www.geeksforgeeks.org/recursive-bubble-sort/)\\n *\\n * @details\\n * The working principle of the Bubble sort algorithm.\\n\\n * Bubble sort is a simple sorting algorithm used to rearrange a set of ascending or descending order elements.\\n * Bubble sort gets its name from the fact that data \\\"bubbles\\\" to the top of the dataset.\\n \\n * ### Algorithm\\n\\n * What is Swap?\\n\\n * Swapping two numbers means that we interchange their values.\\n * Often, an additional variable is required for this operation. \\n * This is further illustrated in the following:\\n\\n * void swap(int x, int y){\\n *     int z = x;\\n *     x = y;\\n *     y = z;\\n * }\\n\\n * The above process is a typical displacement process.\\n * When we assign a value to x, the old value of x is lost.\\n * That's why we create a temporary variable z to store the initial value of x.\\n * z is further used to assign the initial value of x to y, to complete swapping.\\n\\n * Recursion\\n\\n * While the recursive method does not necessarily have advantages over iterative\\n * versions, but it is useful to enhance the understanding of the algorithm and\\n * recursion itself. In Recursive Bubble sort algorithm, we firstly call the\\n * function on the entire array, and for every subsequent function call, we exclude\\n * the last element. This fixes the last element for that sub-array.Formally, for\\n * `ith` iteration, we consider elements up to n-i, where n is the number of\\n * elements in the array. Exit condition: n==1; i.e. the sub-array contains only\\n * one element.\\n\\n * Complexity\\n * Time complexity: O(n) best case; O(n²) average case; O(n²) worst case\\n * Space complexity: O(n)\\n\\n * We need to traverse the array `n * (n-1)` times. However, if the entire array is\\n * already sorted, then we need to traverse it only once. Hence, O(n) is the best case\\n * complexity\\n*/\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector\\n#include <array>     /// for std::array\\n#include <algorithm> /// for std::is_sorted\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n\\n/**\\n * @brief This is an implementation of the recursive_bubble_sort. A vector is passed\\n * to the function which is then dereferenced, so that the changes are\\n * reflected in the original vector. It also accepts a second parameter of\\n * type `int` and name `n`, which is the size of the array.\\n * \\n * @tparam T type of data variables in the array\\n * @param nums our array of elements.\\n * @param n size of the array\\n */\\ntemplate <typename T>\\nvoid recursive_bubble_sort(std::vector<T> *nums, uint64_t n) {\\n    if (n == 1) {  //!< base case; when size of the array is 1\\n        return;\\n    }\\n\\n    for (uint64_t i = 0; i < n - 1; i++) {  //!< iterating over the entire array\\n        //!< if a larger number appears before the smaller one, swap them.\\n        if ((*nums)[i] > (*nums)[i + 1]) {\\n            std::swap((*nums)[i], (*nums)[i + 1]);\\n        }\\n    }\\n\\n    //!< calling the function after we have fixed the last element\\n    recursive_bubble_sort(nums, n - 1);\\n}\\n}  // namespace sorting\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st example. Creating an array of type `int`.\\n    std::cout << \\\"1st test using `int`\\\\n\\\";\\n    const uint64_t size = 6;\\n    std::vector<int64_t> arr;\\n    // populating the array\\n    arr.push_back(22);\\n    arr.push_back(46);\\n    arr.push_back(94);\\n    arr.push_back(12);\\n    arr.push_back(37);\\n    arr.push_back(63);\\n    // array populating ends\\n\\n    sorting::recursive_bubble_sort(&arr, size);\\n    assert(std::is_sorted(std::begin(arr), std::end(arr)));\\n    std::cout << \\\" 1st test passed!\\\\n\\\";\\n    // printing the array\\n    for (uint64_t i = 0; i < size; i++) {\\n        std::cout << arr[i] << \\\", \\\";\\n    }\\n    std::cout << std::endl;\\n\\n    // 2nd example. Creating an array of type `double`.\\n    std::cout << \\\"2nd test using doubles\\\\n\\\";\\n    std::vector<double> double_arr;\\n\\n    // populating the array\\n    double_arr.push_back(20.4);\\n    double_arr.push_back(62.7);\\n    double_arr.push_back(12.2);\\n    double_arr.push_back(43.6);\\n    double_arr.push_back(74.1);\\n    double_arr.push_back(57.9);\\n    // array populating ends\\n\\n    sorting::recursive_bubble_sort(&double_arr, size);\\n    assert(std::is_sorted(std::begin(double_arr), std::end(double_arr)));\\n    std::cout << \\\" 2nd test passed!\\\\n\\\";\\n    // printing the array\\n    for (uint64_t i = 0; i < size; i++) {\\n        std::cout << double_arr[i] << \\\", \\\";\\n    }\\n    std::cout << std::endl;\\n\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() { \\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "selection sort iterative": "\"/******************************************************************************\\n * @file\\n * @brief Implementation of the [Selection\\n * sort](https://en.wikipedia.org/wiki/Selection_sort) implementation using\\n * swapping\\n * @details\\n * The selection sort algorithm divides the input vector into two parts: a\\n * sorted subvector of items which is built up from left to right at the front\\n * (left) of the vector, and a subvector of the remaining unsorted items that\\n * occupy the rest of the vector. Initially, the sorted subvector is empty, and\\n * the unsorted subvector is the entire input vector. The algorithm proceeds by\\n * finding the smallest (or largest, depending on the sorting order) element in\\n * the unsorted subvector, exchanging (swapping) it with the leftmost unsorted\\n * element (putting it in sorted order), and moving the subvector boundaries one\\n * element to the right.\\n *\\n * ### Implementation\\n *\\n * SelectionSort\\n * The algorithm divides the input vector into two parts: the subvector of items\\n * already sorted, which is built up from left to right. Initially, the sorted\\n * subvector is empty and the unsorted subvector is the entire input vector. The\\n * algorithm proceeds by finding the smallest element in the unsorted subvector,\\n * exchanging (swapping) it with the leftmost unsorted element (putting it in\\n * sorted order), and moving the subvector boundaries one element to the right.\\n *\\n * @author [Lajat Manekar](https://github.com/Lazeeez)\\n * @author Unknown author\\n *******************************************************************************/\\n#include <algorithm>  /// for std::is_sorted\\n#include <cassert>    /// for std::assert\\n#include <iostream>   /// for IO operations\\n#include <vector>     /// for std::vector\\n\\n/******************************************************************************\\n * @namespace sorting\\n * @brief Sorting algorithms\\n *******************************************************************************/\\nnamespace sorting {\\n/******************************************************************************\\n * @brief The main function which implements Selection sort\\n * @param arr vector to be sorted\\n * @param len length of vector to be sorted\\n * @returns @param array resultant sorted vector\\n *******************************************************************************/\\n\\nstd::vector<uint64_t> selectionSort(const std::vector<uint64_t> &arr,\\n                                    uint64_t len) {\\n    std::vector<uint64_t> array(\\n        arr.begin(),\\n        arr.end());  // declare a vector in which result will be stored\\n    for (uint64_t it = 0; it < len; ++it) {\\n        uint64_t min = it;  // set min value\\n        for (uint64_t it2 = it + 1; it2 < len; ++it2) {\\n            if (array[it2] < array[min]) {  // check which element is smaller\\n                min = it2;  // store index of smallest element to min\\n            }\\n        }\\n\\n        if (min != it) {  // swap if min does not match to i\\n            uint64_t tmp = array[min];\\n            array[min] = array[it];\\n            array[it] = tmp;\\n        }\\n    }\\n\\n    return array;  // return sorted vector\\n}\\n}  // namespace sorting\\n\\n/*******************************************************************************\\n * @brief Self-test implementations\\n * @returns void\\n *******************************************************************************/\\nstatic void test() {\\n    // testcase #1\\n    // [1, 0, 0, 1, 1, 0, 2, 1] returns [0, 0, 0, 1, 1, 1, 1, 2]\\n    std::vector<uint64_t> vector1 = {1, 0, 0, 1, 1, 0, 2, 1};\\n    uint64_t vector1size = vector1.size();\\n    std::cout << \\\"1st test... \\\";\\n    std::vector<uint64_t> result_test1;\\n    result_test1 = sorting::selectionSort(vector1, vector1size);\\n    assert(std::is_sorted(result_test1.begin(), result_test1.end()));\\n    std::cout << \\\"Passed\\\" << std::endl;\\n\\n    // testcase #2\\n    // [19, 22, 540, 241, 156, 140, 12, 1] returns [1, 12, 19, 22, 140, 156,\\n    // 241,540]\\n    std::vector<uint64_t> vector2 = {19, 22, 540, 241, 156, 140, 12, 1};\\n    uint64_t vector2size = vector2.size();\\n    std::cout << \\\"2nd test... \\\";\\n    std::vector<uint64_t> result_test2;\\n    result_test2 = sorting::selectionSort(vector2, vector2size);\\n    assert(std::is_sorted(result_test2.begin(), result_test2.end()));\\n    std::cout << \\\"Passed\\\" << std::endl;\\n\\n    // testcase #3\\n    // [11, 20, 30, 41, 15, 60, 82, 15] returns [11, 15, 15, 20, 30, 41, 60, 82]\\n    std::vector<uint64_t> vector3 = {11, 20, 30, 41, 15, 60, 82, 15};\\n    uint64_t vector3size = vector3.size();\\n    std::cout << \\\"3rd test... \\\";\\n    std::vector<uint64_t> result_test3;\\n    result_test3 = sorting::selectionSort(vector3, vector3size);\\n    assert(std::is_sorted(result_test3.begin(), result_test3.end()));\\n    std::cout << \\\"Passed\\\" << std::endl;\\n\\n    // testcase #4\\n    // [1, 9, 11, 546, 26, 65, 212, 14, -11] returns [-11, 1, 9, 11, 14, 26, 65,\\n    // 212, 546]\\n    std::vector<uint64_t> vector4 = {1, 9, 11, 546, 26, 65, 212, 14};\\n    uint64_t vector4size = vector2.size();\\n    std::cout << \\\"4th test... \\\";\\n    std::vector<uint64_t> result_test4;\\n    result_test4 = sorting::selectionSort(vector4, vector4size);\\n    assert(std::is_sorted(result_test4.begin(), result_test4.end()));\\n    std::cout << \\\"Passed\\\" << std::endl;\\n}\\n\\n/*******************************************************************************\\n * @brief Main function\\n * @returns 0 on exit\\n *******************************************************************************/\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "selection sort recursive": "\"/**\\n * @file\\n * @brief Implementation of the [Selection\\n * sort](https://en.wikipedia.org/wiki/Selection_sort)\\n * implementation using recursion\\n * @details\\n * The selection sort algorithm divides the input list into two parts: a sorted\\n * sublist of items which is built up from left to right at the front (left) of\\n * the list, and a sublist of the remaining unsorted items that occupy the rest\\n * of the list. Initially, the sorted sublist is empty, and the unsorted sublist\\n * is the entire input list. The algorithm proceeds by finding the smallest (or\\n * largest, depending on the sorting order) element in the unsorted sublist,\\n * exchanging (swapping) it with the leftmost unsorted element (putting it in\\n * sorted order), and moving the sublist boundaries one element to the right.\\n *\\n * ### Implementation\\n * FindMinIndex\\n * This function finds the minimum element of the array(list) recursively by\\n * simply comparing the minimum element of array reduced size by 1 and compares\\n * it to the last element of the array to find the minimum of the whole array.\\n *\\n * SelectionSortRecursive\\n * Just like selection sort, it divides the list into two parts (i.e.: sorted\\n * and unsorted) and finds the minimum of the unsorted array. By calling the\\n * `FindMinIndex` function, it swaps the minimum element with the first element\\n * of the list, and then solves recursively for the remaining unsorted list.\\n * @author [Tushar Khanduri](https://github.com/Tushar-K24)\\n */\\n\\n#include <algorithm>  /// for std::is_sorted\\n#include <cassert>    /// for assert\\n#include <iostream>   /// for std::swap and io operations\\n#include <vector>     /// for std::vector\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * @namespace selection_sort_recursive\\n * @brief Functions for the [Selection\\n * sort](https://en.wikipedia.org/wiki/Selection_sort)\\n * implementation using recursion\\n */\\nnamespace selection_sort_recursive {\\n/**\\n * @brief The main function finds the index of the minimum element\\n * @tparam T type of array\\n * @param in_arr array whose minimum element is to be returned\\n * @param current_position position/index from where the in_arr starts\\n * @returns index of the minimum element\\n */\\ntemplate <typename T>\\nuint64_t findMinIndex(const std::vector<T> &in_arr,\\n                      uint64_t current_position = 0) {\\n    if (current_position + 1 == in_arr.size()) {\\n        return current_position;\\n    }\\n    uint64_t answer = findMinIndex(in_arr, current_position + 1);\\n    if (in_arr[current_position] < in_arr[answer]) {\\n        answer = current_position;\\n    }\\n    return answer;\\n}\\n\\n/**\\n * @brief The main function implements Selection sort\\n * @tparam T type of array\\n * @param in_arr array to be sorted,\\n * @param current_position position/index from where the in_arr starts\\n * @returns void\\n */\\ntemplate <typename T>\\nvoid selectionSortRecursive(std::vector<T> &in_arr,\\n                            uint64_t current_position = 0) {\\n    if (current_position == in_arr.size()) {\\n        return;\\n    }\\n    uint64_t min_element_idx =\\n        selection_sort_recursive::findMinIndex(in_arr, current_position);\\n    if (min_element_idx != current_position) {\\n        std::swap(in_arr[min_element_idx], in_arr[current_position]);\\n    }\\n    selectionSortRecursive(in_arr, current_position + 1);\\n}\\n}  // namespace selection_sort_recursive\\n}  // namespace sorting\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // 1st test\\n    // [1, 0, 2, 1] return [0, 1, 1, 2]\\n    std::vector<uint64_t> array1 = {0, 1, 1, 2};\\n    std::cout << \\\"1st test... \\\";\\n    sorting::selection_sort_recursive::selectionSortRecursive(array1);\\n    assert(std::is_sorted(std::begin(array1), std::end(array1)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n    // 2nd test\\n    // [1, 0, 0, 1, 1, 0, 2, 1] return [0, 0, 0, 1, 1, 1, 1, 2]\\n    std::vector<uint64_t> array2 = {1, 0, 0, 1, 1, 0, 2, 1};\\n    std::cout << \\\"2nd test... \\\";\\n    sorting::selection_sort_recursive::selectionSortRecursive(array2);\\n    assert(std::is_sorted(std::begin(array2), std::end(array2)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n    // 3rd test\\n    // [1, 1, 0, 0, 1, 2, 2, 0, 2, 1] return [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]\\n    std::vector<uint64_t> array3 = {1, 1, 0, 0, 1, 2, 2, 0, 2, 1};\\n    std::cout << \\\"3rd test... \\\";\\n    sorting::selection_sort_recursive::selectionSortRecursive(array3);\\n    assert(std::is_sorted(std::begin(array3), std::end(array3)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n    // 4th test\\n    // [2, 2, 2, 0, 0, 1, 1] return [0, 0, 1, 1, 2, 2, 2]\\n    std::vector<uint64_t> array4 = {2, 2, 2, 0, 0, 1, 1};\\n    std::cout << \\\"4th test... \\\";\\n    sorting::selection_sort_recursive::selectionSortRecursive(array4);\\n    assert(std::is_sorted(std::begin(array4), std::end(array4)));\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "shell sort": "\"#include <iostream>\\n\\nint main() {\\n    int size = 10;\\n    int* array = new int[size];\\n    // Input\\n    std::cout << \\\"\\\\nHow many numbers do want to enter in unsorted array : \\\";\\n    std::cin >> size;\\n    std::cout << \\\"\\\\nEnter the numbers for unsorted array : \\\";\\n    for (int i = 0; i < size; i++) {\\n        std::cin >> array[i];\\n    }\\n\\n    // Sorting\\n    for (int i = size / 2; i > 0; i = i / 2) {\\n        for (int j = i; j < size; j++) {\\n            for (int k = j - i; k >= 0; k = k - i) {\\n                if (array[k] < array[k + i]) {\\n                    break;\\n                } else {\\n                    int temp = array[k + i];\\n                    array[k + i] = array[k];\\n                    array[k] = temp;\\n                }\\n            }\\n        }\\n    }\\n\\n    // Output\\n    std::cout << \\\"\\\\nSorted array : \\\";\\n    for (int i = 0; i < size; ++i) {\\n        std::cout << array[i] << \\\"\\\\t\\\";\\n    }\\n\\n    delete[] array;\\n    return 0;\\n}\\n\"",
    "shell sort2": "\"/**\\r\\n * \\\\file\\r\\n * \\\\brief [Shell sort](https://en.wikipedia.org/wiki/Shell_sort) algorithm\\r\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\r\\n */\\r\\n#include <cassert>\\r\\n#include <cstdlib>\\r\\n#include <ctime>\\r\\n#include <iostream>\\r\\n#include <utility>  // for std::swap\\r\\n#include <vector>\\r\\n\\r\\n/** pretty print array\\r\\n * \\\\param[in] arr array to print\\r\\n * \\\\param[in] LEN length of array to print\\r\\n */\\r\\ntemplate <class T>\\r\\nvoid show_data(T *arr, size_t LEN) {\\r\\n    size_t i;\\r\\n\\r\\n    for (i = 0; i < LEN; i++) {\\r\\n        std::cout << arr[i] << \\\", \\\";\\r\\n    }\\r\\n    std::cout << std::endl;\\r\\n}\\r\\n\\r\\n/** pretty print array\\r\\n * \\\\param[in] arr array to print\\r\\n * \\\\param[in] N length of array to print\\r\\n */\\r\\ntemplate <typename T, size_t N>\\r\\nvoid show_data(T (&arr)[N]) {\\r\\n    show_data(arr, N);\\r\\n}\\r\\n\\r\\n/** \\\\namespace sorting\\r\\n * \\\\brief Sorting algorithms\\r\\n */\\r\\nnamespace sorting {\\r\\n/**\\r\\n * Optimized algorithm - takes half the time by utilizing\\r\\n * Mar\\r\\n **/\\r\\ntemplate <typename T>\\r\\nvoid shell_sort(T *arr, size_t LEN) {\\r\\n    const unsigned int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};\\r\\n    const unsigned int gap_len = 8;\\r\\n    size_t i, j, g;\\r\\n\\r\\n    for (g = 0; g < gap_len; g++) {\\r\\n        unsigned int gap = gaps[g];\\r\\n        for (i = gap; i < LEN; i++) {\\r\\n            T tmp = arr[i];\\r\\n\\r\\n            for (j = i; j >= gap && (arr[j - gap] - tmp) > 0; j -= gap) {\\r\\n                arr[j] = arr[j - gap];\\r\\n            }\\r\\n\\r\\n            arr[j] = tmp;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/** function overload - when input array is of a known length array type\\r\\n */\\r\\ntemplate <typename T, size_t N>\\r\\nvoid shell_sort(T (&arr)[N]) {\\r\\n    shell_sort(arr, N);\\r\\n}\\r\\n\\r\\n/** function overload - when input array is of type std::vector,\\r\\n * simply send the data content and the data length to the above function.\\r\\n */\\r\\ntemplate <typename T>\\r\\nvoid shell_sort(std::vector<T> *arr) {\\r\\n    shell_sort(arr->data(), arr->size());\\r\\n}\\r\\n\\r\\n}  // namespace sorting\\r\\n\\r\\nusing sorting::shell_sort;\\r\\n\\r\\n/**\\r\\n * function to compare sorting using cstdlib's qsort\\r\\n **/\\r\\ntemplate <typename T>\\r\\nint compare(const void *a, const void *b) {\\r\\n    T arg1 = *static_cast<const T *>(a);\\r\\n    T arg2 = *static_cast<const T *>(b);\\r\\n\\r\\n    if (arg1 < arg2)\\r\\n        return -1;\\r\\n    if (arg1 > arg2)\\r\\n        return 1;\\r\\n    return 0;\\r\\n\\r\\n    //  return (arg1 > arg2) - (arg1 < arg2); // possible shortcut\\r\\n    //  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Test implementation of shell_sort on integer arrays by comparing results\\r\\n * against std::qsort.\\r\\n */\\r\\nvoid test_int(const int NUM_DATA) {\\r\\n    // int array = new int[NUM_DATA];\\r\\n    int *data = new int[NUM_DATA];\\r\\n    int *data2 = new int[NUM_DATA];\\r\\n    // int array2 = new int[NUM_DATA];\\r\\n    int range = 1800;\\r\\n\\r\\n    for (int i = 0; i < NUM_DATA; i++)\\r\\n        data[i] = data2[i] = (std::rand() % range) - (range >> 1);\\r\\n\\r\\n    /* sort using our implementation */\\r\\n    std::clock_t start = std::clock();\\r\\n    shell_sort(data, NUM_DATA);\\r\\n    std::clock_t end = std::clock();\\r\\n    double elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;\\r\\n    std::cout << \\\"Time spent sorting using shell_sort2: \\\" << elapsed_time\\r\\n              << \\\"s\\\\n\\\";\\r\\n\\r\\n    /* sort using std::qsort */\\r\\n    start = std::clock();\\r\\n    std::qsort(data2, NUM_DATA, sizeof(data2[0]), compare<int>);\\r\\n    end = std::clock();\\r\\n\\r\\n    elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;\\r\\n    std::cout << \\\"Time spent sorting using std::qsort: \\\" << elapsed_time\\r\\n              << \\\"s\\\\n\\\";\\r\\n\\r\\n    for (int i = 0; i < NUM_DATA; i++) {\\r\\n        assert(data[i] == data2[i]);  // ensure that our sorting results match\\r\\n                                      // the standard results\\r\\n    }\\r\\n\\r\\n    delete[] data;\\r\\n    delete[] data2;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Test implementation of shell_sort on float arrays by comparing results\\r\\n * against std::qsort.\\r\\n */\\r\\nvoid test_f(const int NUM_DATA) {\\r\\n    // int array = new int[NUM_DATA];\\r\\n    float *data = new float[NUM_DATA];\\r\\n    float *data2 = new float[NUM_DATA];\\r\\n    // int array2 = new int[NUM_DATA];\\r\\n    int range = 1000;\\r\\n\\r\\n    for (int i = 0; i < NUM_DATA; i++) {\\r\\n        data[i] = data2[i] = ((std::rand() % range) - (range >> 1)) / 100.;\\r\\n    }\\r\\n\\r\\n    /* sort using our implementation */\\r\\n    std::clock_t start = std::clock();\\r\\n    shell_sort(data, NUM_DATA);\\r\\n    std::clock_t end = std::clock();\\r\\n    double elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;\\r\\n    std::cout << \\\"Time spent sorting using shell_sort2: \\\" << elapsed_time\\r\\n              << \\\"s\\\\n\\\";\\r\\n\\r\\n    /* sort using std::qsort */\\r\\n    start = std::clock();\\r\\n    std::qsort(data2, NUM_DATA, sizeof(data2[0]), compare<float>);\\r\\n    end = std::clock();\\r\\n\\r\\n    elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;\\r\\n    std::cout << \\\"Time spent sorting using std::qsort: \\\" << elapsed_time\\r\\n              << \\\"s\\\\n\\\";\\r\\n\\r\\n    for (int i = 0; i < NUM_DATA; i++) {\\r\\n        assert(data[i] == data2[i]);  // ensure that our sorting results match\\r\\n                                      // the standard results\\r\\n    }\\r\\n\\r\\n    delete[] data;\\r\\n    delete[] data2;\\r\\n}\\r\\n\\r\\n/** Main function */\\r\\nint main(int argc, char *argv[]) {\\r\\n    // initialize random number generator - once per program\\r\\n    std::srand(std::time(NULL));\\r\\n\\r\\n    test_int(100);  // test with sorting random array of 100 values\\r\\n    std::cout << \\\"Test 1 - 100 int values - passed. \\\\n\\\";\\r\\n    test_int(1000);  // test with sorting random array of 1000 values\\r\\n    std::cout << \\\"Test 2 - 1000 int values - passed.\\\\n\\\";\\r\\n    test_int(10000);  // test with sorting random array of 10000 values\\r\\n    std::cout << \\\"Test 3 - 10000 int values - passed.\\\\n\\\";\\r\\n\\r\\n    test_f(100);  // test with sorting random array of 100 values\\r\\n    std::cout << \\\"Test 1 - 100 float values - passed. \\\\n\\\";\\r\\n    test_f(1000);  // test with sorting random array of 1000 values\\r\\n    std::cout << \\\"Test 2 - 1000 float values - passed.\\\\n\\\";\\r\\n    test_f(10000);  // test with sorting random array of 10000 values\\r\\n    std::cout << \\\"Test 3 - 10000 float values - passed.\\\\n\\\";\\r\\n\\r\\n    int i, NUM_DATA;\\r\\n\\r\\n    if (argc == 2)\\r\\n        NUM_DATA = atoi(argv[1]);\\r\\n    else\\r\\n        NUM_DATA = 200;\\r\\n\\r\\n    // int array = new int[NUM_DATA];\\r\\n    int *data = new int[NUM_DATA];\\r\\n    // int array2 = new int[NUM_DATA];\\r\\n    int range = 1800;\\r\\n\\r\\n    std::srand(time(NULL));\\r\\n    for (i = 0; i < NUM_DATA; i++) {\\r\\n        // allocate random numbers in the given range\\r\\n        data[i] = (std::rand() % range) - (range >> 1);\\r\\n    }\\r\\n\\r\\n    std::cout << \\\"Unsorted original data: \\\" << std::endl;\\r\\n    show_data(data, NUM_DATA);\\r\\n    std::clock_t start = std::clock();\\r\\n    shell_sort(data, NUM_DATA);  // perform sorting\\r\\n    std::clock_t end = std::clock();\\r\\n\\r\\n    std::cout << std::endl\\r\\n              << \\\"Data Sorted using custom implementation: \\\" << std::endl;\\r\\n    show_data(data, NUM_DATA);\\r\\n\\r\\n    double elapsed_time = (end - start) * 1.f / CLOCKS_PER_SEC;\\r\\n    std::cout << \\\"Time spent sorting: \\\" << elapsed_time << \\\"s\\\\n\\\" << std::endl;\\r\\n\\r\\n    delete[] data;\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "slow sort": "\"// Returns the sorted vector after performing SlowSort\\n// It is a sorting algorithm that is of humorous nature and not useful.\\n// It's based on the principle of multiply and surrender, a tongue-in-cheek joke\\n// of divide and conquer. It was published in 1986 by Andrei Broder and Jorge\\n// Stolfi in their paper Pessimal Algorithms and Simplexity Analysis. This\\n// algorithm multiplies a single problem into multiple subproblems It is\\n// interesting because it is provably the least efficient sorting algorithm that\\n// can be built asymptotically, and with the restriction that such an algorithm,\\n// while being slow, must still all the time be working towards a result.\\n\\n#include <iostream>\\n\\nvoid SlowSort(int a[], int i, int j) {\\n    if (i >= j)\\n        return;\\n    int m = i + (j - i) / 2;  // midpoint, implemented this way to avoid\\n                              // overflow\\n    int temp;\\n    SlowSort(a, i, m);\\n    SlowSort(a, m + 1, j);\\n    if (a[j] < a[m]) {\\n        temp = a[j];  // swapping a[j] & a[m]\\n        a[j] = a[m];\\n        a[m] = temp;\\n    }\\n    SlowSort(a, i, j - 1);\\n}\\n\\n// Sample Main function\\n\\nint main() {\\n    int size;\\n    std::cout << \\\"\\\\nEnter the number of elements : \\\";\\n\\n    std::cin >> size;\\n\\n    int *arr = new int[size];\\n\\n    std::cout << \\\"\\\\nEnter the unsorted elements : \\\";\\n\\n    for (int i = 0; i < size; ++i) {\\n        std::cout << \\\"\\\\n\\\";\\n        std::cin >> arr[i];\\n    }\\n\\n    SlowSort(arr, 0, size);\\n\\n    std::cout << \\\"Sorted array\\\\n\\\";\\n\\n    for (int i = 0; i < size; ++i) {\\n        std::cout << arr[i] << \\\" \\\";\\n    }\\n\\n    delete[] arr;\\n    return 0;\\n}\\n\"",
    "strand sort": "\"/**\\n * @file strand_sort.cpp\\n * @brief Implementation of [Strand Sort](https://en.wikipedia.org/wiki/Strand_sort) algorithm.\\n *\\n * @details\\n * Strand Sort is a sorting algorithm that works in \\\\f$O(n)\\\\f$ time if list is already sorted and works in \\\\f$O(n^2)\\\\f$ in worst case.\\n * \\n * It is passed over the array to be sorted once and the ascending (sequential) numbers are taken.\\n * After the first iteration, the sequential sub-array is put on the empty sorted array.\\n * The main sequence is passed over again and a new sub-sequence is created in order.\\n * Now that the sorted array is not empty, the newly extracted substring is merged with the sorted array.\\n * Repeat types 3 and 4 until the sub-sequence and main sequence are empty.\\n * \\n * @author [Mertcan Davulcu](https://github.com/mertcandav)\\n */\\n#include <iostream>\\n#include <list>\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n    /**\\n    * @namespace strand\\n    * @brief Functions for [Strand Sort](https://en.wikipedia.org/wiki/Strand_sort) algorithm\\n    */\\n    namespace strand {\\n        /**\\n        * @brief Apply sorting\\n        * @tparam element type of list\\n        * @param lst List to be sorted\\n        * @returns Sorted list<T> instance\\n        */\\n        template <typename T>\\n        std::list<T> strand_sort(std::list<T> lst) {\\n            if (lst.size() < 2) { // Returns list if empty or contains only one element\\n                return lst; // Returns list\\n            }\\n            std::list<T> result; // Define new \\\"result\\\" named list instance.\\n            std::list<T> sorted; // Define new \\\"sorted\\\" named list instance.\\n            while(!lst.empty()) /* if lst is not empty */ {\\n                sorted.push_back(lst.front()); // Adds the first element of \\\"lst\\\" list to the bottom of the \\\"sorted\\\" list.\\n                lst.pop_front(); // Remove first element of \\\"lst\\\" list.\\n                for (auto it = lst.begin(); it != lst.end(); ) { // Return the loop as long as the current iterator is not equal to the last literator of the \\\"lst\\\" list.\\n                    if (sorted.back() <= *it) { // If the last reference of the \\\"sorted\\\" list is less than or equal to the current iterator reference.\\n                        sorted.push_back(*it); // Adds the iterator retrieved in the loop under the \\\"sorted\\\" list.\\n                        it = lst.erase(it); // Deletes the element with the current iterator and assigns the deleted element to the iterator.\\n                    } else {\\n                        it++; // Next iterator.\\n                    }\\n                }\\n                result.merge(sorted); // Merge \\\"result\\\" list with \\\"sorted\\\" list.\\n            }\\n            return result; // Returns sorted list\\n        }\\n    }  // namespace strand\\n}  // namespace sorting\\n\\n/**\\n * @brief Function for testing\\n * @return N/A\\n */\\nstatic void test() {\\n    std::list<int> lst = { -333, 525, 1, 0, 94, 52, 33 };\\n\\n    std::cout << \\\"Before: \\\";\\n    for(auto item: lst) {\\n        std::cout << item << \\\" \\\";\\n    }\\n\\n    lst = sorting::strand::strand_sort(lst); // Sort list.\\n\\n    std::cout << \\\"\\\\nAfter: \\\";\\n    for(auto item: lst) {\\n        std::cout << item << \\\" \\\";\\n    }\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();\\n    return 0;\\n}\\n\"",
    "swap sort": "\"// C++ program to find minimum number of swaps required to sort an array\\n#include <algorithm>\\n#include <iostream>\\n#include <utility>\\n#include <vector>\\n\\n// Function returns the minimum number of swaps\\n// required to sort the array\\nint minSwaps(int arr[], int n) {\\n    // Create an array of pairs where first\\n    // element is array element and second element\\n    // is position of first element\\n    std::pair<int, int> *arrPos = new std::pair<int, int>[n];\\n    for (int i = 0; i < n; i++) {\\n        arrPos[i].first = arr[i];\\n        arrPos[i].second = i;\\n    }\\n\\n    // Sort the array by array element values to\\n    // get right position of every element as second\\n    // element of pair.\\n    std::sort(arrPos, arrPos + n);\\n\\n    // To keep track of visited elements. Initialize\\n    // all elements as not visited or false.\\n    std::vector<bool> vis(n, false);\\n\\n    // Initialize result\\n    int ans = 0;\\n\\n    // Traverse array elements\\n    for (int i = 0; i < n; i++) {\\n        // already swapped and corrected or\\n        // already present at correct pos\\n        if (vis[i] || arrPos[i].second == i)\\n            continue;\\n\\n        // find out the number of node in\\n        // this cycle and add in ans\\n        int cycle_size = 0;\\n        int j = i;\\n        while (!vis[j]) {\\n            vis[j] = 1;\\n\\n            // move to next node\\n            j = arrPos[j].second;\\n            cycle_size++;\\n        }\\n\\n        // Update answer by adding current cycle.\\n        if (cycle_size > 0) {\\n            ans += (cycle_size - 1);\\n        }\\n    }\\n\\n    delete[] arrPos;\\n\\n    // Return result\\n    return ans;\\n}\\n\\n// program to test\\nint main() {\\n    int arr[] = {6, 7, 8, 1, 2, 3, 9, 12};\\n    int n = (sizeof(arr) / sizeof(int));\\n    std::cout << minSwaps(arr, n);\\n    return 0;\\n}\\n\"",
    "tim sort": "\"// C++ program to perform TimSort.\\n#include <algorithm>\\n#include <iostream>\\n\\nconst int RUN = 32;\\n\\n// this function sorts array from left index to to right index which is of size\\n// atmost RUN\\nvoid insertionSort(int arr[], int left, int right) {\\n    for (int i = left + 1; i <= right; i++) {\\n        int temp = arr[i];\\n        int j = i - 1;\\n        while (arr[j] > temp && j >= left) {\\n            arr[j + 1] = arr[j];\\n            j--;\\n        }\\n        arr[j + 1] = temp;\\n    }\\n}\\n\\n// merge function merges the sorted runs\\nvoid merge(int arr[], int l, int m, int r) {\\n    // original array is broken in two parts, left and right array\\n    int len1 = m - l + 1, len2 = r - m;\\n    int *left = new int[len1], *right = new int[len2];\\n    for (int i = 0; i < len1; i++) left[i] = arr[l + i];\\n    for (int i = 0; i < len2; i++) right[i] = arr[m + 1 + i];\\n\\n    int i = 0;\\n    int j = 0;\\n    int k = l;\\n\\n    // after comparing, we merge those two array in larger sub array\\n    while (i < len1 && j < len2) {\\n        if (left[i] <= right[j]) {\\n            arr[k] = left[i];\\n            i++;\\n        } else {\\n            arr[k] = right[j];\\n            j++;\\n        }\\n        k++;\\n    }\\n\\n    // copy remaining elements of left, if any\\n    while (i < len1) {\\n        arr[k] = left[i];\\n        k++;\\n        i++;\\n    }\\n\\n    // copy remaining element of right, if any\\n    while (j < len2) {\\n        arr[k] = right[j];\\n        k++;\\n        j++;\\n    }\\n    delete[] left;\\n    delete[] right;\\n}\\n\\n// iterative Timsort function to sort the array[0...n-1] (similar to merge sort)\\nvoid timSort(int arr[], int n) {\\n    // Sort individual subarrays of size RUN\\n    for (int i = 0; i < n; i += RUN)\\n        insertionSort(arr, i, std::min((i + 31), (n - 1)));\\n\\n    // start merging from size RUN (or 32). It will merge to form size 64, then\\n    // 128, 256 and so on ....\\n    for (int size = RUN; size < n; size = 2 * size) {\\n        // pick starting point of left sub array. We are going to merge\\n        // arr[left..left+size-1] and arr[left+size, left+2*size-1] After every\\n        // merge, we increase left by 2*size\\n        for (int left = 0; left < n; left += 2 * size) {\\n            // find ending point of left sub array\\n            // mid+1 is starting point of right sub array\\n            int mid = left + size - 1;\\n            int right = std::min((left + 2 * size - 1), (n - 1));\\n\\n            // merge sub array arr[left.....mid] & arr[mid+1....right]\\n            merge(arr, left, mid, right);\\n        }\\n    }\\n}\\n\\n// utility function to print the Array\\nvoid printArray(int arr[], int n) {\\n    for (int i = 0; i < n; i++) printf(\\\"%d  \\\", arr[i]);\\n    std::cout << std::endl;\\n}\\n\\n// Driver program to test above function\\nint main() {\\n    int arr[] = {5, 21, 7, 23, 19};\\n    int n = sizeof(arr) / sizeof(arr[0]);\\n    printf(\\\"Given Array is\\\\n\\\");\\n    printArray(arr, n);\\n\\n    timSort(arr, n);\\n\\n    printf(\\\"After Sorting Array is\\\\n\\\");\\n    printArray(arr, n);\\n    return 0;\\n}\\n\"",
    "wave sort": "\"/**\\n * @file\\n * @brief Implementation of the [Wave\\n * sort](https://www.geeksforgeeks.org/sort-array-wave-form-2/) algorithm\\n * @details\\n * Wave Sort is a sorting algorithm that works in \\\\f$O(nlogn)\\\\f$ time assuming\\n * the sort function used works in \\\\f$O(nlogn)\\\\f$ time.\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n */\\n\\n#include <algorithm>  /// for std::is_sorted, std::swap\\n#include <cassert>    /// for assert\\n#include <iostream>   /// for IO operations\\n#include <vector>     /// for std::vector\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * @namespace wave_sort\\n * @brief Functions for the [Wave\\n * sort](https://www.geeksforgeeks.org/sort-array-wave-form-2/) implementation\\n */\\nnamespace wave_sort {\\n/**\\n * @brief The main function implements that implements the Wave Sort algorithm\\n * @tparam T type of array\\n * @param in_arr array to be sorted\\n * @returns arr the wave sorted array\\n */\\ntemplate <typename T>\\nstd::vector<T> waveSort(const std::vector<T> &in_arr, int64_t n) {\\n    std::vector<T> arr(in_arr);\\n\\n    for (int64_t i = 0; i < n; i++) {\\n        arr[i] = in_arr[i];\\n    }\\n    std::sort(arr.begin(), arr.end());\\n    for (int64_t i = 0; i < n - 1; i += 2) {  // swap all the adjacent elements\\n        std::swap(arr[i], arr[i + 1]);\\n    }\\n    return arr;\\n}\\n}  // namespace wave_sort\\n}  // namespace sorting\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // [10, 90, 49, 2, 1, 5, 23] return [2, 1, 10, 5, 49, 23, 90]\\n    std::vector<int64_t> array1 = {10, 90, 49, 2, 1, 5, 23};\\n    std::cout << \\\"Test 1... \\\";\\n    std::vector<int64_t> arr1 = sorting::wave_sort::waveSort(array1, 7);\\n    const std::vector<int64_t> o1 = {2, 1, 10, 5, 49, 23, 90};\\n    assert(arr1 == o1);\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // [1, 3, 4, 2, 7, 8] return [2, 1, 4, 3, 8, 7]\\n    std::vector<int64_t> array2 = {1, 3, 4, 2, 7, 8};\\n    std::cout << \\\"Test 2... \\\";\\n    std::vector<int64_t> arr2 = sorting::wave_sort::waveSort(array2, 6);\\n    const std::vector<int64_t> o2 = {2, 1, 4, 3, 8, 7};\\n    assert(arr2 == o2);\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // [3, 3, 3, 3] return [3, 3, 3, 3]\\n    std::vector<int64_t> array3 = {3, 3, 3, 3};\\n    std::cout << \\\"Test 3... \\\";\\n    std::vector<int64_t> arr3 = sorting::wave_sort::waveSort(array3, 4);\\n    const std::vector<int64_t> o3 = {3, 3, 3, 3};\\n    assert(arr3 == o3);\\n    std::cout << \\\"passed\\\" << std::endl;\\n\\n    // [9, 4, 6, 8, 14, 3] return [4, 3, 8, 6, 14, 9]\\n    std::vector<int64_t> array4 = {9, 4, 6, 8, 14, 3};\\n    std::cout << \\\"Test 4... \\\";\\n    std::vector<int64_t> arr4 = sorting::wave_sort::waveSort(array4, 6);\\n    const std::vector<int64_t> o4 = {4, 3, 8, 6, 14, 9};\\n    assert(arr4 == o4);\\n    std::cout << \\\"passed\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "wiggle sort": "\"/**\\n * \\\\addtogroup sorting Sorting Algorithms\\n * @{\\n * \\\\file\\n * \\\\brief [Wiggle Sort Algorithm]\\n * (https://leetcode.com/problems/wiggle-sort-ii/) Implementation\\n *\\n * \\\\author [Roshan Kanwar](http://github.com/roshan0708)\\n *\\n * \\\\details\\n * Wiggle Sort sorts the array into a wave like array.\\n * An array ‘arr[0..n-1]’ is sorted in wave form,\\n * if arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= …..\\n *\\n * \\\\example\\n * arr = [1,1,5,6,1,4], after wiggle sort arr will become equal to [1,1,6,1,5,4]\\n * arr = [2,8,9,1,7], after wiggle sort arr will become equal to [8,2,9,1,7]\\n */\\n\\n#include <algorithm>\\n#include <cassert>\\n#include <ctime>\\n#include <iostream>  /// for io operations\\n#include <vector>\\n\\n/**\\n * @namespace sorting\\n * @brief Sorting algorithms\\n */\\nnamespace sorting {\\n/**\\n * @namespace wiggle_sort\\n * @brief Functions for [Wiggle\\n * Sort](https://leetcode.com/problems/wiggle-sort-ii/) algorithm\\n */\\nnamespace wiggle_sort {\\n\\n/**\\n *\\n * @brief Function used for sorting the elements in wave form.\\n * @details\\n * Checking whether the even indexed elements are greater than\\n * their adjacent odd elements.\\n * Traversing all even indexed elements of the input arr.\\n * If current element is smaller than the previous odd element, swap them.\\n * If current element is smaller than the next odd element, swap them.\\n *\\n * @param arr input array (unsorted elements)\\n *\\n */\\ntemplate <typename T>  // this allows to have vectors of ints, double, float,\\n                       // etc\\n                       std::vector<T> wiggleSort(const std::vector<T> &arr) {\\n    uint32_t size = arr.size();\\n\\n    std::vector<T> out(\\n        arr);  // create a copy of input vector. this way, the original input\\n               // vector does not get modified. a sorted array is is returned.\\n\\n    for (int i = 0; i < size; i += 2) {\\n        if (i > 0 && out[i - 1] > out[i]) {\\n            std::swap(out[i], out[i - 1]);  // swapping the two values\\n        }\\n\\n        if (i < size - 1 && out[i] < out[i + 1]) {\\n            std::swap(out[i], out[i + 1]);  // swapping the two values\\n        }\\n    }\\n\\n    return out;  // returns the sorted vector\\n}\\n}  // namespace wiggle_sort\\n}  // namespace sorting\\n\\n/**\\n *\\n * @brief Utility function used for printing the elements.\\n * Prints elements of the array after they're sorted using wiggle sort\\n * algorithm.\\n *\\n * @param arr array containing the sorted elements\\n *\\n */\\ntemplate <typename T>\\nstatic void displayElements(const std::vector<T> &arr) {\\n    uint32_t size = arr.size();\\n\\n    std::cout << \\\"Sorted elements are as follows: \\\";\\n\\n    std::cout << \\\"[\\\";\\n\\n    for (int i = 0; i < size; i++) {\\n        std::cout << arr[i];\\n        if (i != size - 1) {\\n            std::cout << \\\", \\\";\\n        }\\n    }\\n\\n    std::cout << \\\"]\\\" << std::endl;\\n}\\n\\n/**\\n * Test function\\n * @returns void\\n */\\nstatic void test() {\\n    std::srand(std::time(nullptr));  // initialize random number generator\\n\\n    std::vector<float> data1(100);\\n    for (auto &d : data1) {  // generate random numbers between -5.0 and 4.99\\n        d = float(std::rand() % 1000 - 500) / 100.f;\\n    }\\n\\n    std::vector<float> sorted = sorting::wiggle_sort::wiggleSort<float>(data1);\\n\\n    displayElements(sorted);\\n\\n    for (uint32_t j = 0; j < data1.size(); j += 2) {\\n        assert(data1[j] <= data1[j + 1] &&\\n               data1[j + 1] >= data1[j + 2]);  // check the validation condition\\n    }\\n\\n    std::cout << \\\"Test 1 passed\\\\n\\\";\\n}\\n\\n/** Driver Code */\\nint main() {\\n    test();\\n    return 0;\\n}\\n\\n/** @} */\\n\"",
    "brute force string searching": "\"/**\\n * @file\\n * @brief          String pattern search - brute force\\n */\\n#include <iostream>\\n#ifdef _MSC_VER\\n#include <string>  // use this for MS Visual C++\\n#else\\n#include <cstring>\\n#endif\\n#include <vector>\\n\\nnamespace string_search {\\n/**\\n * Find a pattern in a string by comparing the pattern to every substring.\\n * @param text     Any string that might contain the pattern.\\n * @param pattern  String that we are searching for.\\n * @return         Index where the pattern starts in the text\\n * @return         -1 if the pattern was not found.\\n */\\nint brute_force(const std::string &text, const std::string &pattern) {\\n    size_t pat_l = pattern.length();\\n    size_t txt_l = text.length();\\n    int index = -1;\\n    if (pat_l <= txt_l) {\\n        for (size_t i = 0; i < txt_l - pat_l + 1; i++) {\\n            std::string s = text.substr(i, pat_l);\\n            if (s == pattern) {\\n                index = i;\\n                break;\\n            }\\n        }\\n    }\\n    return index;\\n}\\n}  // namespace string_search\\n\\nusing string_search::brute_force;\\n\\n/** set of test cases */\\nconst std::vector<std::vector<std::string>> test_set = {\\n    // {text, pattern, expected output}\\n    {\\\"a\\\", \\\"aa\\\", \\\"-1\\\"},  {\\\"a\\\", \\\"a\\\", \\\"0\\\"},    {\\\"ba\\\", \\\"b\\\", \\\"0\\\"},\\n    {\\\"bba\\\", \\\"bb\\\", \\\"0\\\"}, {\\\"bbca\\\", \\\"c\\\", \\\"2\\\"}, {\\\"ab\\\", \\\"b\\\", \\\"1\\\"}};\\n\\n/** Main function */\\nint main() {\\n    for (size_t i = 0; i < test_set.size(); i++) {\\n        int output = brute_force(test_set[i][0], test_set[i][1]);\\n\\n        if (std::to_string(output) == test_set[i][2])\\n            std::cout << \\\"success\\\\n\\\";\\n        else\\n            std::cout << \\\"failure\\\\n\\\";\\n    }\\n    return 0;\\n}\\n\"",
    "horspool": "\"/**\\n * @file\\n * @brief Horspool's algorithm that finds if a string contains a substring (https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm)\\n * @author [Harry Kontakis](https://github.com/ckontakis)\\n */\\n\\n#include <iostream>\\n#include <unordered_map>\\n#include <cassert>\\n\\n/**\\n * @namespace strings\\n * @brief Algorithms with strings\\n */\\nnamespace strings {\\n/**\\n * @namespace horspool\\n * @brief Functions for [Horspool's](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm) algorithm\\n */\\nnamespace horspool {\\n/**\\n * A function that finds the shift table of the given prototype string that we need in Horpool's algorithm.\\n * @param prototype is the substring that we use to find shift table\\n * @return Shift Table of Horspool's algorithm\\n */\\nstd::unordered_map<char, int> findShiftTable(const std::string &prototype) {\\n    std::unordered_map<char, int>\\n        shiftTable;  // A HashMap for shift table that has characters for keys and integers for values\\n\\n    for (int i = 0; i < prototype.size();\\n         i++) {  // Checking all characters of prototype string\\n        if (shiftTable.find(prototype[i]) ==\\n            shiftTable.end()) {  // If character does not exist in HashMap\\n            if (i != prototype.size() - 1) {\\n                shiftTable.insert(std::make_pair(\\n                    prototype[i], prototype.size() - i -\\n                                      1));  // Insert the character as key and the size of prototype string - index of character - 1 as value\\n            } else {\\n                shiftTable.insert(std::make_pair(\\n                    prototype[i],\\n                    prototype.size()));  // Insert the character as key and the size of prototype string as value\\n            }\\n        } else {\\n            if (i != prototype.size() - 1) {\\n                shiftTable[prototype[i]] = prototype.size() - i - 1;\\n            }\\n        }\\n    }\\n    return shiftTable;\\n}\\n\\n/**\\n * A function that implements Horspool's algorithm.\\n * @param text is the string that we are searching if there is a substring\\n * @param prototype is the substring that we are searching in text\\n * @returns true if text string contains prototype string\\n * @returns false if text string does not contain prototype string\\n */\\nbool horspool(const std::string &text, const std::string &prototype) {\\n    std::unordered_map<char, int> shiftTable = findShiftTable(\\n        prototype);  // Initialise shift table calling findShiftTable function\\n\\n    int i = static_cast<int>(\\n        prototype.size() -\\n        1);  // Index that we shift in text to find the substring\\n    while (i < text.size()) {\\n        int j = i, k = 0;\\n        bool flag = true;\\n\\n        for (int z = static_cast<int>(prototype.size() - 1); z >= 0 && flag;\\n             z--) {  // Checking if all characters of substring are equal with all characters of string\\n            if (text[j] == prototype[z]) {\\n                k++;\\n                j--;\\n            } else {\\n                flag = false;  // If two characters are not equal set flag to false and break from loop\\n            }\\n        }\\n\\n        if (k ==\\n            prototype.size()) {  // If all characters match then return true\\n            return true;\\n        } else {\\n            if (shiftTable.find(text[i]) != shiftTable.end()) {\\n                i += shiftTable[text[i]];  // If shift table contains the character then shift index as many steps as value\\n            } else {\\n                i += prototype.size();  // If character does not exist in shift table then shift index as many steps as size of prototype string\\n            }\\n        }\\n    }\\n    return false;\\n}\\n} // namespace horspool\\n} // namespace strings\\n\\n/**\\n * @brief Function with test cases for Horspool's algorithm\\n * @returns void\\n */\\nstatic void test(){\\n    assert(strings::horspool::horspool(\\\"Hello World\\\",\\\"World\\\") == true);\\n    assert(strings::horspool::horspool(\\\"Hello World\\\",\\\" World\\\") == true);\\n    assert(strings::horspool::horspool(\\\"Hello World\\\",\\\"ello\\\") == true);\\n    assert(strings::horspool::horspool(\\\"Hello World\\\",\\\"rld\\\") == true);\\n    assert(strings::horspool::horspool(\\\"Hello\\\",\\\"Helo\\\") == false);\\n    assert(strings::horspool::horspool(\\\"c++_algorithms\\\",\\\"c++_algorithms\\\") == true);\\n    assert(strings::horspool::horspool(\\\"c++_algorithms\\\",\\\"c++_\\\") == true);\\n    assert(strings::horspool::horspool(\\\"Hello\\\",\\\"Hello World\\\") == false);\\n    assert(strings::horspool::horspool(\\\"c++_algorithms\\\",\\\"\\\") == false);\\n    assert(strings::horspool::horspool(\\\"c++\\\",\\\"c\\\") == true);\\n    assert(strings::horspool::horspool(\\\"3458934793\\\",\\\"4793\\\") == true);\\n    assert(strings::horspool::horspool(\\\"3458934793\\\",\\\"123\\\") == false);\\n}\\n\\n/**\\n * @brief Main Function that calls test function\\n * @returns 0 on exit\\n */\\nint main(){\\n    test();\\n    return 0;\\n}\\n\"",
    "knuth morris pratt": "\"/**\\n * \\\\file\\n * \\\\brief The [Knuth-Morris-Pratt\\n * Algorithm](https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm) for\\n * finding a pattern within a piece of text with complexity O(n + m)\\n *\\n * 1. Preprocess pattern to identify any suffixes that are identical to\\n * prefixes. This tells us where to continue from if we get a mismatch between a\\n * character in our pattern and the text.\\n * 2. Step through the text one character at a time and compare it to a\\n * character in the pattern updating our location within the pattern if\\n * necessary\\n */\\n\\n#include <iostream>\\n#ifdef _MSC_VER\\n#include <string>  // use this for MS Visual C++\\n#else\\n#include <cstring>\\n#endif\\n#include <vector>\\n\\n/** \\\\namespace string_search\\n * \\\\brief String search algorithms\\n */\\nnamespace string_search {\\n/**\\n * Generate the partial match table aka failure function for a pattern to\\n * search.\\n * \\\\param[in] pattern text for which to create the partial match table\\n * \\\\returns the partial match table as a vector array\\n */\\nstd::vector<int> getFailureArray(const std::string &pattern) {\\n    int pattern_length = pattern.size();\\n    std::vector<int> failure(pattern_length + 1);\\n    failure[0] = -1;\\n    int j = -1;\\n\\n    for (int i = 0; i < pattern_length; i++) {\\n        while (j != -1 && pattern[j] != pattern[i]) {\\n            j = failure[j];\\n        }\\n        j++;\\n        failure[i + 1] = j;\\n    }\\n    return failure;\\n}\\n\\n/**\\n * KMP algorithm to find a pattern in a text\\n * \\\\param[in] pattern string pattern to search\\n * \\\\param[in] text text in which to search\\n * \\\\returns `true` if pattern was found\\n * \\\\returns `false` if pattern was not found\\n */\\nbool kmp(const std::string &pattern, const std::string &text) {\\n    int text_length = text.size(), pattern_length = pattern.size();\\n    std::vector<int> failure = getFailureArray(pattern);\\n\\n    int k = 0;\\n    for (int j = 0; j < text_length; j++) {\\n        while (k != -1 && pattern[k] != text[j]) {\\n            k = failure[k];\\n        }\\n        k++;\\n        if (k == pattern_length)\\n            return true;\\n    }\\n    return false;\\n}\\n}  // namespace string_search\\n\\nusing string_search::kmp;\\n\\n/** Main function */\\nint main() {\\n    std::string text = \\\"alskfjaldsabc1abc1abc12k23adsfabcabc\\\";\\n    std::string pattern = \\\"abc1abc12l\\\";\\n\\n    if (kmp(pattern, text) == true) {\\n        std::cout << \\\"Found\\\" << std::endl;\\n    } else {\\n        std::cout << \\\"Not Found\\\" << std::endl;\\n    }\\n\\n    text = \\\"abcabc\\\";\\n    pattern = \\\"bca\\\";\\n    if (kmp(pattern, text) == true) {\\n        std::cout << \\\"Found\\\" << std::endl;\\n    } else {\\n        std::cout << \\\"Not Found\\\" << std::endl;\\n    }\\n\\n    return 0;\\n}\\n\"",
    "manacher algorithm": "\"/**\\n * @file\\n * @brief Implementation of [Manacher's\\n * Algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring)\\n * @details\\n * Manacher's Algorithm is used to find the longest palindromic substring within\\n * a string in O(n) time. It exploits the property of a palindrome that its\\n * first half is symmetric to the last half, and thus if the first half is a\\n * palindrome, then last half is also a palindrome.\\n * @author [Riti Kumari](https://github.com/riti2409)\\n */\\n\\n#include <cassert>   /// for assert\\n#include <iostream>  /// for IO operations\\n#include <vector>    /// for std::vector STL\\n#ifdef _MSC_VER\\n#include <string>  /// for string (required for MS Visual C++)\\n#else\\n#include <cstring>  /// for string\\n#endif\\n\\n/**\\n * @namespace strings\\n * @brief Algorithms with strings\\n */\\nnamespace strings {\\n/**\\n * @namespace manacher\\n * @brief Functions for [Manacher's\\n * Algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring)\\n * implementation\\n */\\nnamespace manacher {\\n/**\\n * @brief A function that implements Manacher's algorithm\\n * @param prototype is the string where algorithm finds a palindromic substring.\\n * This string can contain any character except `@` `#` `&`\\n * @returns the largest palindromic substring\\n */\\nstd::string manacher(const std::string &prototype) {\\n    if (prototype.size() > 0) {\\n        // stuffing characters between the input string to handle cases with\\n        // even length palindrome\\n        std::string stuffed_string = \\\"\\\";\\n        for (auto str : prototype) {\\n            stuffed_string += str;\\n            stuffed_string += \\\"#\\\";\\n        }\\n        stuffed_string = \\\"@#\\\" + stuffed_string + \\\"&\\\";\\n\\n        std::vector<uint64_t> palindrome_max_half_length(\\n            stuffed_string.size(),\\n            0);  // this array will consist of largest possible half length of\\n                 // palindrome centered at index (say i with respect to the\\n                 // stuffed string). This value will be lower bound of half\\n                 // length since single character is a palindrome in itself.\\n\\n        uint64_t bigger_center =\\n            0;  // this is the index of the center of palindromic\\n                // substring which would be considered as the larger\\n                // palindrome, having symmetric halves\\n\\n        uint64_t right = 0;  // this is the maximum length of the palindrome\\n                             // from 'bigger_center' to the rightmost end\\n\\n        // i is considered as center lying within one half of the palindrone\\n        // which is centered at 'bigger_center'\\n        for (uint64_t i = 1; i < stuffed_string.size() - 1; i++) {\\n            if (i < right) {  // when i is before right end, considering\\n                              // 'bigger_center' as center of palindrome\\n                uint64_t opposite_to_i =\\n                    2 * bigger_center -\\n                    i;  // this is the opposite end of string, if\\n                        // centered at center, and having one end as i\\n\\n                // finding the minimum possible half length among\\n                // the palindrome on having center at opposite end,\\n                // and the string between i and right end,\\n                // considering 'bigger_center' as center of palindrome\\n                palindrome_max_half_length[i] = std::min(\\n                    palindrome_max_half_length[opposite_to_i], right - i);\\n            }\\n\\n            // expanding the palindrome across the maximum stored length in the\\n            // array, centered at i\\n            while (stuffed_string[i + (palindrome_max_half_length[i] + 1)] ==\\n                   stuffed_string[i - (palindrome_max_half_length[i] + 1)]) {\\n                palindrome_max_half_length[i]++;\\n            }\\n\\n            // if palindrome centered at i exceeds the rightmost end of\\n            // palindrome centered at 'bigger_center', then i will be made the\\n            // 'bigger_center' and right value will also be updated with respect\\n            // to center i\\n            if (i + palindrome_max_half_length[i] > right) {\\n                bigger_center = i;\\n                right = i + palindrome_max_half_length[i];\\n            }\\n        }\\n\\n        // now extracting the first largest palindrome\\n        uint64_t half_length = 0;   // half length of the largest palindrome\\n        uint64_t center_index = 0;  // index of center of the largest palindrome\\n\\n        for (uint64_t i = 1; i < stuffed_string.size() - 1; i++) {\\n            if (palindrome_max_half_length[i] > half_length) {\\n                half_length = palindrome_max_half_length[i];\\n                center_index = i;\\n            }\\n        }\\n\\n        std::string palindromic_substring =\\n            \\\"\\\";  // contains the resulting largest palindrome\\n\\n        if (half_length > 0) {\\n            // extra information: when '#' is the center, then palindromic\\n            // substring will have even length, else palindromic substring will\\n            // have odd length\\n\\n            uint64_t start =\\n                center_index - half_length +\\n                1;  // index of first character of palindromic substring\\n            uint64_t end =\\n                center_index + half_length -\\n                1;  // index of last character of palindromic substring\\n            for (uint64_t index = start; index <= end; index += 2) {\\n                palindromic_substring += stuffed_string[index];\\n            }\\n        } else {\\n            // if length = 0, then there does not exist any palindrome of length\\n            // > 1 so we can assign any character of length 1 from string as the\\n            // palindromic substring\\n            palindromic_substring = prototype[0];\\n        }\\n        return palindromic_substring;\\n\\n    } else {\\n        // handling case when string is empty\\n        return \\\"\\\";\\n    }\\n}\\n\\n}  // namespace manacher\\n}  // namespace strings\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    assert(strings::manacher::manacher(\\\"\\\") == \\\"\\\");\\n    assert(strings::manacher::manacher(\\\"abababc\\\") == \\\"ababa\\\");\\n    assert(strings::manacher::manacher(\\\"cbaabd\\\") == \\\"baab\\\");\\n    assert(strings::manacher::manacher(\\\"DedzefDeD\\\") == \\\"DeD\\\");\\n    assert(strings::manacher::manacher(\\\"XZYYXXYZXX\\\") == \\\"YXXY\\\");\\n    assert(strings::manacher::manacher(\\\"1sm222m10abc\\\") == \\\"m222m\\\");\\n    assert(strings::manacher::manacher(\\\"798989591\\\") == \\\"98989\\\");\\n    assert(strings::manacher::manacher(\\\"xacdedcax\\\") == \\\"xacdedcax\\\");\\n    assert(strings::manacher::manacher(\\\"xaccax\\\") == \\\"xaccax\\\");\\n    assert(strings::manacher::manacher(\\\"a\\\") == \\\"a\\\");\\n    assert(strings::manacher::manacher(\\\"xy\\\") == \\\"x\\\");\\n    assert(strings::manacher::manacher(\\\"abced\\\") == \\\"a\\\");\\n\\n    std::cout << \\\"All tests have passed!\\\" << std::endl;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "rabin karp": "\"/**\\n * \\\\file\\n * \\\\brief The [Rabin-Karp\\n * Algorithm](https://en.wikipedia.org/wiki/Rabin–Karp_algorithm) for finding a\\n * pattern within a piece of text with complexity O(n + m)\\n */\\n#include <cassert>\\n#include <cmath>\\n#include <iostream>\\n#ifdef _MSC_VER\\n#include <string>  // use this for MS Visucal C++\\n#else\\n#include <cstring>\\n#endif\\n\\n#define PRIME 5  ///< Prime modulus for hash functions\\n\\nnamespace string_search {\\n/**\\n * convert a string to an intger - called as hashing function\\n * \\\\param[in] s source of string to hash\\n * \\\\param[in] n length of substring to hash\\n * \\\\returns hash integer\\n */\\nint64_t create_hash(const std::string& s, int n) {\\n    int64_t result = 0;\\n    for (int i = 0; i < n; ++i) {\\n        result += (int64_t)(s[i] * (int64_t)pow(PRIME, i));\\n    }\\n    return result;\\n}\\n\\n/**\\n * re-hash a string using known existing hash\\n * \\\\param[in] s source of string to hash\\n * \\\\param[in] old_index previous index of string\\n * \\\\param[in] new_index new index of string\\n * \\\\param[in] old_hash previous hash of substring\\n * \\\\param[in] patLength length of substring to hash\\n * \\\\returns new hash integer\\n */\\nint64_t recalculate_hash(const std::string& s, int old_index, int new_index,\\n                         int64_t old_hash, int patLength) {\\n    int64_t new_hash = old_hash - s[old_index];\\n    new_hash /= PRIME;\\n    new_hash += (int64_t)(s[new_index] * (int64_t)pow(PRIME, patLength - 1));\\n    return new_hash;\\n}\\n\\n/**\\n * compare if two sub-strings are equal\\n * \\\\param[in] str1 string pattern to search\\n * \\\\param[in] str2 text in which to search\\n * \\\\param[in] start1,end1 start and end indices for substring in str1\\n * \\\\param[in] start2,end2 start and end indices for substring in str2\\n * \\\\returns `true` if pattern was found\\n * \\\\returns `false` if pattern was not found\\n * @note can this be replaced by std::string::compare?\\n */\\nbool check_if_equal(const std::string& str1, const std::string& str2,\\n                    int start1, int end1, int start2, int end2) {\\n    if (end1 - start1 != end2 - start2) {\\n        return false;\\n    }\\n    while (start1 <= end1 && start2 <= end2) {\\n        if (str1[start1] != str2[start2]) {\\n            return false;\\n        }\\n        start1++;\\n        start2++;\\n    }\\n    return true;\\n}\\n\\n/**\\n *  Perform string pattern search using Rabin-Karp algorithm\\n *  @param[in] str string to search in\\n *  @param[in] pat pattern to search for\\n *  @return index of first occurrence of pattern\\n *  @return -1 if pattern not found\\n */\\n\\nint rabin_karp(const std::string& str, const std::string& pat) {\\n    int64_t pat_hash = create_hash(pat, pat.size());\\n    int64_t str_hash = create_hash(str, pat.size());\\n    for (int i = 0; i <= str.size() - pat.size(); ++i) {\\n        if (pat_hash == str_hash &&\\n            check_if_equal(str, pat, i, i + pat.size() - 1, 0,\\n                           pat.size() - 1)) {\\n            return i;\\n        }\\n        if (i < str.size() - pat.size()) {\\n            str_hash =\\n                recalculate_hash(str, i, i + pat.size(), str_hash, pat.size());\\n        }\\n    }\\n    return -1;  // return -1 if given pattern not found\\n}\\n\\n}  // namespace string_search\\n\\nusing string_search::rabin_karp;\\n\\n/** Main function */\\nint main(void) {\\n    assert(rabin_karp(\\\"helloWorld\\\", \\\"world\\\") == -1);\\n    assert(rabin_karp(\\\"helloWorld\\\", \\\"World\\\") == 5);\\n    assert(rabin_karp(\\\"this_is_c++\\\", \\\"c++\\\") == 8);\\n    assert(rabin_karp(\\\"happy_coding\\\", \\\"happy\\\") == 0);\\n    return 0;\\n}\\n\"",
    "z function": "\"/**\\n * @file\\n * @brief The [Z function](https://cp-algorithms.com/string/z-function.html) for\\n * finding occurences of a pattern within a piece of text with time and space\\n * complexity O(n + m)\\n * @details\\n * 1. The Z-function for a string is an array of length n where the\\n * i-th element is equal to the greatest number of characters starting\\n * from the position i that coincide with the first characters of s.\\n * 2. E.g.: string: ababb then z[2]=2 as s[2]=s[0] and s[3]=s[1] and s[4]!=s[2]\\n * @author [Ritika Gupta](https://github.com/RitikaGupta8734)\\n */\\n\\n#include <iostream>  /// for IO operations\\n#ifdef _MSC_VER\\n#include <string>  /// for string (use this for MS Visual C++)\\n#else\\n#include <cstring>  /// for string\\n#endif\\n#include <cassert>  /// for assert\\n#include <vector>   /// for std::vector\\n\\n/**\\n * @brief Generate the Z-function for the inputted string.\\n * \\\\param[in] pattern text on which to apply the Z-function\\n * \\\\returns the Z-function output as a vector array\\n */\\nstd::vector<uint64_t> Z_function(const std::string &pattern) {\\n    uint64_t pattern_length = pattern.size();\\n    std::vector<uint64_t> z(pattern_length, 0);\\n\\n    for (uint64_t i = 1, l = 0, r = 0; i < pattern_length; i++) {\\n        if (i <= r) {\\n            z[i] = std::min(r - i + 1, z[i - l]);\\n        }\\n        while (i + z[i] < pattern_length &&\\n               pattern[z[i]] == pattern[i + z[i]]) {\\n            z[i]++;\\n        }\\n        if (i + z[i] - 1 > r) {\\n            r = i + z[i] - 1;\\n        }\\n    }\\n    return z;\\n}\\n\\n/**\\n * @brief Using Z_function to find a pattern in a text\\n * \\\\param[in] pattern string pattern to search\\n * \\\\param[in] text text in which to search\\n * \\\\returns a vector of starting indexes where pattern is found in the text\\n */\\nstd::vector<uint64_t> find_pat_in_text(const std::string &pattern,\\n                                       const std::string &text) {\\n    uint64_t text_length = text.size(), pattern_length = pattern.size();\\n    std::vector<uint64_t> z = Z_function(pattern + '#' + text);\\n    std::vector<uint64_t> matching_indexes;\\n\\n    for (uint64_t i = 0; i < text_length; i++) {\\n        if (z[i + pattern_length + 1] == pattern_length) {\\n            matching_indexes.push_back(i);\\n        }\\n    }\\n    return matching_indexes;\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    // usual case\\n    std::string text1 = \\\"alskfjaldsabc1abc1abcbksbcdnsdabcabc\\\";\\n    std::string pattern1 = \\\"abc\\\";\\n\\n    // matching_indexes1 gets the indexes where pattern1 exists in text1\\n    std::vector<uint64_t> matching_indexes1 = find_pat_in_text(pattern1, text1);\\n    assert((matching_indexes1 == std::vector<uint64_t>{10, 14, 18, 30, 33}));\\n\\n    // corner case\\n    std::string text2 = \\\"greengrass\\\";\\n    std::string pattern2 = \\\"abc\\\";\\n\\n    // matching_indexes2 gets the indexes where pattern2 exists in text2\\n    std::vector<uint64_t> matching_indexes2 = find_pat_in_text(pattern2, text2);\\n    assert((matching_indexes2 == std::vector<uint64_t>{}));\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\""
  }
}
