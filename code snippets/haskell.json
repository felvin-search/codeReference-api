{
  "haskell": {
    "binary search tree": "\"module BinaryTree.BinarySearchTree where\\n\\ndata BTree a = Empty | Node a (BTree a) (BTree a) deriving (Show)\\ndata Side = LeftSide | RightSide deriving (Eq, Show)\\n\\n-- Function to get the data associated with the node.\\nnodeKey :: BTree a -> Maybe a\\nnodeKey Empty = Nothing\\nnodeKey (Node x _ _) = Just x\\n\\n-- Perform inorder walk of the binary search tree.\\n-- Cormen, Thomas H., et al. Introduction to algorithms.  pg. 288, MIT press, 2009.\\ninorderWalk :: (Eq a, Ord a) => BTree a -> [a]\\ninorderWalk Empty = []\\ninorderWalk (Node x l r) = (inorderWalk l) ++ [x] ++ (inorderWalk r)\\n\\n-- Function to insert a value into the tree. Returns the new tree.\\n-- Cormen, Thomas H., et al. Introduction to algorithms.  pg. 294, MIT press, 2009.\\nbstInsert :: (Eq a, Ord a) => BTree a -> a -> BTree a\\nbstInsert Empty z = Node z Empty Empty\\nbstInsert (Node x l r) z\\n    | z < x = Node x (bstInsert l z) r\\n    | otherwise = Node x l (bstInsert r z)\\n\\n-- Function to find the maximum value in the BST.\\nbstMax :: (Eq a, Ord a) => BTree a -> Maybe a\\nbstMax Empty = Nothing\\nbstMax (Node x Empty Empty) = Just x\\nbstMax (Node x l Empty) = Just x\\nbstMax (Node x l r) = bstMax r\\n\\n-- Function to find the minimum value in the BST.\\nbstMin :: (Eq a, Ord a) => BTree a -> Maybe a\\nbstMin Empty = Nothing\\nbstMin (Node x Empty Empty) = Just x\\nbstMin (Node x Empty r) = Just x\\nbstMin (Node x l r) = bstMin l\\n\\n-- Function to build BST from a list of values using a fold.\\nbstFromList :: (Eq a, Ord a) => [a] -> BTree a\\nbstFromList [] = Empty\\nbstFromList lst = foldl (\\\\tree elem -> bstInsert tree elem) Empty lst\\n\\nsampleTree = bstFromList [10, 7, 3, 11, 12, 1, 3, 2]\\n\\n-- Function to check if a given tree is a Binary Search Tree.\\n-- Property: \\n--     x is a node in the BST. If y is a node in the left subtree of x then \\n--     y.key <= x.key. If y is a node in the right subtree of x then\\n--     y.key >= x.key.\\n--     Cormen, Thomas H., et al. Introduction to algorithms. MIT press, 2009.\\nisBST :: (Ord a, Eq a) => BTree a -> Bool\\nisBST Empty = True\\nisBST (Node x Empty Empty) = True\\nisBST (Node x Empty r) = (x < (nkey r)) && (isBST r) where nkey = (\\\\(Node n ll rr) -> n)\\nisBST (Node x l Empty) = (x >= (nkey l)) && (isBST l) where nkey = (\\\\(Node n ll rr) -> n)\\nisBST (Node x l r) = (x >= (nkey l)) && (x < (nkey r)) && (isBST l) && (isBST r) where nkey = (\\\\(Node n ll rr) -> n)\"",
    "binary tree": "\"module BinaryTree.BinaryTree where\\n\\nimport qualified Data.List as L\\n\\ndata BTree a = Empty | Node a (BTree a) (BTree a) deriving (Show)\\ndata Side = LeftSide | RightSide deriving (Eq, Show)\\n\\n-- Get subtree on specified side\\ngetSubTree :: Side -> BTree a -> BTree a\\ngetSubTree _ Empty = Empty\\ngetSubTree s (Node _ l r) = if s == LeftSide then l else r\\n\\n-- Get Left Subtree\\ngetLeftTree :: BTree a -> BTree a\\ngetLeftTree Empty = Empty\\ngetLeftTree (Node _ l _) = l\\n\\n-- Get Right Subtree\\ngetRightTree :: BTree a -> BTree a\\ngetRightTree Empty = Empty\\ngetRightTree (Node _ _ r) = r\\n\\n-- Get string representation of node Data\\nnodeShow :: (Show a) => BTree a -> String\\nnodeShow Empty = \\\"\\\"\\nnodeShow (Node val _ _) = show val\\n\\n-- Depth first traversal\\ndfsList :: BTree a -> [a]\\ndfsList Empty = []\\ndfsList (Node n l r) = [n] ++ (dfsList l) ++ (dfsList r)\\n\\n-- Breadth first traversal.\\nbfsList :: BTree a -> [a]\\nbfsList Empty = []\\nbfsList t = concat $ takeWhile (\\\\l -> (length l) > 0) [getLevel i 0 t | i <- [0..]]\\n\\n-- Get all nodes from a single level in the tree.\\ngetLevel :: (Num b, Enum b, Eq b) => b -> b -> BTree a -> [a]\\ngetLevel _ _ Empty = []\\ngetLevel 0 _ (Node n l r) = [n]\\ngetLevel level i (Node n l r)\\n    | i == level = [n]\\n    | otherwise = (getLevel level (i+1) l) ++ (getLevel level (i+1) r)\\n\\n-- Get a list of lists of nodes in each level\\ngetLevels :: BTree a -> [[a]]\\ngetLevels t = takeWhile (\\\\l -> (length l) > 0) [getLevel i 0 t | i <- [0..]]\\n\\n-- Get the depth of the tree\\ngetDepth :: BTree a -> Int\\ngetDepth t = length $ getLevels t\\n\\n-- Generate a Binary Tree from a list of values.\\n-- Assume list is in breadth first order.\\nfromList :: [a] -> BTree a\\nfromList lst = fromListInt 0 lst\\n-- Internal function to convert list to tree.\\nfromListInt :: Int -> [a] -> BTree a\\nfromListInt _ [] = Empty\\nfromListInt i lst@(x:xs) = Node x (fromListInt (2*i + 1) (drop (i+1) lst)) \\n                                  (fromListInt (2*i + 2) (drop (i+2) lst))\\n\\n-- Count number of nodes in the tree.\\nnumNodes :: BTree a -> Int\\nnumNodes t = length $ bfsList t\\n\\n-- Pretty Print a Binary Tree\\nsimplePrint :: (Show a) => BTree a -> String\\nsimplePrint Empty = \\\"\\\"\\nsimplePrint t = (nodeShow t) ++ \\\" \\\" ++ (simplePrint $ getLeftTree t) ++ (simplePrint $ getRightTree t)\"",
    "max heap": "\"module DataStructures.MaxHeap where\\n\\n-- Construct a max heap (represented as a list) from a given input list\\nmaxHeap :: Ord a => [a] -> [a]\\nmaxHeap [] = []\\nmaxHeap [x] = [x]\\nmaxHeap xs = maxHeap' xs (div (length xs) 2)\\n\\n-- Insert an element into a heap and then fix the heap\\ninsert :: Ord a => [a] -> a -> [a]\\ninsert [] e = [e]\\ninsert xs e = upHeapify (xs ++ [e]) (length xs)\\n\\n\\n-- Recursive helper function for maxHeap\\nmaxHeap' :: Ord a => [a] -> Int -> [a]\\nmaxHeap' xs 0 = maxHeapify xs 0\\nmaxHeap' xs i = maxHeap' (maxHeapify xs i) (i-1)\\n\\n-- Given a heap and an index (i), move the element at i up the heap until it is in the right position \\nupHeapify :: Ord a => [a] -> Int -> [a]\\nupHeapify xs 0 = xs\\nupHeapify xs i | xs !! i <= xs !! ip = xs\\n               | otherwise = upHeapify (swap xs i ip) ip\\n                where\\n                    ip = parent i\\n\\n-- Given a heap and an index (i), move the element at i down the heap until it is in the right position\\nmaxHeapify :: (Ord a) => [a] -> Int -> [a]\\nmaxHeapify xs i | not (hasAnyChild xs i) = xs\\n                | hasLeftChild xs i && hasRightChild xs i = \\n                    let largestChild = if xs !! (leftChild i) > xs !! (rightChild i) then leftChild i else rightChild i\\n                    in if xs !! largestChild > xs !! i then maxHeapify (swap xs largestChild i) largestChild else xs\\n                | hasLeftChild xs i =\\n                    if xs !! (leftChild i) > xs !! i then maxHeapify (swap xs (leftChild i) i) (leftChild i) else xs\\n                | otherwise =\\n                    if xs !! (rightChild i) > xs !! i then maxHeapify (swap xs (rightChild i) i) (rightChild i) else xs\\n\\n\\n-- Remove the largest element from the heap, and then fix the heap\\nextract :: Ord a => [a] -> [a]\\nextract [] = []\\nextract [_] = []\\nextract xs = maxHeapify ((last xs):take (length xs - 2) (tail xs)) 0\\n\\n-- Delete an element from a heap and then fix the heap\\n-- If the element is not present, return the heap as is\\ndelete :: Ord a => [a] -> a -> [a]\\ndelete [] _ = []\\ndelete xs e = let i' = (search xs e)\\n                  f = if xs !! (length xs - 1) > e then upHeapify else maxHeapify\\n                  in case i' of \\n                      Nothing -> xs\\n                      Just i  -> f (take ((length xs) - 1) (swap xs i ((length xs) - 1))) i\\n\\n-- Find the index of an element in a heap\\n-- Returns Nothing if the element is not present\\nsearch :: Eq a => [a] -> a -> Maybe Int\\nsearch xs e = search' xs e 0 \\n\\n-- Recursive helper function for search\\nsearch' :: Eq a => [a] -> a -> Int -> Maybe Int\\nsearch' [] _ _ = Nothing\\nsearch' (x:xs) e i | e == x = Just i\\n                   | otherwise = search' xs e (i+1)\\n\\n\\n-- Swap the values stored in two positions in a list\\nswap :: [a] -> Int -> Int -> [a]\\nswap xs i1 i2 = map snd . foldr (\\\\x a -> \\n        if fst x == i1 then ys !! i2 : a\\n        else if fst x == i2 then ys !! i1 : a\\n        else x : a) [] $ ys\\n    where ys = zip [0..] xs\\n\\n-- Index where the left child of the node at the given index should be located\\nleftChild :: Int -> Int\\nleftChild i = 2 * i + 1\\n\\n-- Index where the right child of the node at the given index should be located\\nrightChild :: Int -> Int\\nrightChild i = 2 * i + 2\\n\\n-- Index where the parent of the node at the given index should be located\\nparent ::  Int -> Int\\nparent i = floor (fromIntegral (div (i-1) 2))\\n\\n-- Helper functions to determine which, if any, child nodes are present in the heap for the node at a given index\\nhasLeftChild, hasRightChild, hasAnyChild :: [a] -> Int -> Bool\\nhasLeftChild xs i = leftChild i < length xs\\n\\nhasRightChild xs i = rightChild i < length xs\\n\\nhasAnyChild xs i = hasLeftChild xs i || hasRightChild xs i\"",
    "dfs": "\"module Graph.Dfs where\\n\\nimport Data.List\\n\\ntype Node = Int\\ntype Edge = (Node,Node)\\ntype Graph = ([Node],[Edge])\\n\\ndepthfirst :: Graph -> Node -> [Node]\\ndepthfirst (v,e) n\\n    | [x|x<-v,x==n] == [] = []\\n    | otherwise = dfrecursive (v,e) [n]\\n    \\ndfrecursive :: Graph -> [Node] -> [Node]\\ndfrecursive ([],_) _ = []\\ndfrecursive (_,_) [] = []\\ndfrecursive (v,e) (top:stack)\\n    | [x|x<-v,x==top] == [] = dfrecursive (newv, e) stack\\n    | otherwise = top : dfrecursive (newv, e) (adjacent ++ stack)\\n    where\\n        adjacent = [x | (x,y)<-e,y==top] ++ [x | (y,x)<-e,y==top]\\n        newv = [x|x<-v,x/=top]\\n        \\nconnectedcomponents :: Graph -> [[Node]]\\nconnectedcomponents ([],_) = []\\nconnectedcomponents (top:v,e) \\n    | remaining == [] = [connected]\\n    | otherwise = connected : connectedcomponents (remaining, e)\\n    where\\n        connected = depthfirst (top:v,e) top\\n        remaining = (top:v) \\\\\\\\ connected\\n        \\n        \\ndfsbipartite :: Graph -> [(Node, Int)] -> [Node] -> [Node] -> Bool\\ndfsbipartite ([],_) _ _ _ = True\\ndfsbipartite (_,_) [] _ _ = True\\ndfsbipartite (v,e) ((nv, 0):stack) odd even\\n    | [x|x<-v,x==nv] == [] = dfsbipartite (v, e) stack odd even\\n    | [] == intersect adjacent even = dfsbipartite (newv, e) ([(x,1)|x<-adjacent] ++ stack) odd (nv : even)\\n    | otherwise = False\\n    where\\n        adjacent = [x | (x,y)<-e,y==nv] ++ [x | (y,x)<-e,y==nv]\\n        newv = [x|x<-v,x/=nv]\\ndfsbipartite (v,e) ((nv, 1):stack) odd even\\n    | [x|x<-v,x==nv] == [] = dfsbipartite (v, e) stack odd even    \\n    | [] == intersect adjacent odd = dfsbipartite (newv, e) ([(x,0)|x<-adjacent] ++ stack) (nv : odd) even\\n    | otherwise = False\\n    where\\n        adjacent = [x | (x,y)<-e,y==nv] ++ [x | (y,x)<-e,y==nv]\\n        newv = [x|x<-v,x/=nv]\\n\\nbipartite :: Graph -> Bool\\nbipartite ([],_) = True\\nbipartite (top:v,e) = dfsbipartite (top:v, e) [(top,0)] [] []\\n\"",
    "directed graph": "\"{-# LANGUAGE TupleSections #-}\\nmodule Graph.DirectedGraph where\\n\\nimport qualified Data.Set as Set\\nimport qualified Data.Map as Map\\n\\ntype Graph a = Map.Map a (Set.Set a)\\n\\nempty :: Ord a => Graph a\\nempty = Map.empty\\n\\ninsertNode :: Ord a => a -> Graph a -> Graph a\\ninsertNode u g\\n    | Map.member u g = g\\n    | otherwise      = Map.insert u Set.empty g\\n\\ninsertEdge :: Ord a => (a, a) -> Graph a -> Graph a\\ninsertEdge (u, v) = Map.insertWith Set.union u (Set.singleton v) . insertNode u . insertNode v\\n\\ndeleteNode :: Ord a => a -> Graph a -> Graph a\\ndeleteNode u = Map.delete u . Map.map (Set.delete u)\\n\\nadjacentNodes :: Ord a => a -> Graph a -> Maybe (Set.Set a)\\nadjacentNodes = Map.lookup\\n\\nnodes :: Ord a => Graph a -> Set.Set a\\nnodes = Map.keysSet\\n\\nedges :: Ord a => Graph a -> [(a, a)]\\nedges = concat . Map.elems . Map.mapWithKey (\\\\u -> map (u,) . Set.toList)\\n\\n-- Creates graph from list of edges\\nfromList :: Ord a => [(a, a)] -> Graph a\\nfromList = foldr insertEdge Map.empty\\n\\n-- Creates new graph by flipping every edge\\ntranspose :: Ord a => Graph a -> Graph a\\ntranspose = fromList . map (\\\\(a, b)->(b, a)) . edges\\n\"",
    "factorial": "\"module Maths.Factorial where\\n\\nfac :: Integer -> Integer \\nfac 0 = 1\\nfac n = n * fac (n - 1)\\n\\nmain :: IO ()\\nmain = do\\n    print (fac 4)\"",
    "fibonacci": "\"module Maths.Fibonacci where\\n\\nfib :: Integer -> Integer\\nfib 0 = 0\\nfib 1 = 1\\nfib n = fib (n-1) + fib (n-2)\\n\\nmain :: IO ()\\nmain = do\\n    print (fib 10)\"",
    "graph dist": "\"module Maths.GraphDist where\\n\\n-- calculates the distance from the origin\\ncalcDistOrigin :: Floating a => a -> a -> a -> a\\ncalcDistOrigin x y z = sqrt ((x ** 2) + (y ** 2) + (z ** 2))\\n\\n-- calculates the distance between two points\\ncalcDist :: Floating a => a -> a -> a -> a -> a -> a -> a\\ncalcDist x1 x2 y1 y2 z1 z2 = sqrt ((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\\n\\nmain :: IO ()\\nmain = do\\n  print (calcDistOrigin 4 5 6)\\n  print (calcDist 4 6 5 9 6 10)\"",
    "kadane algorithm": "\"module Maths.KadaneAlgorithm where\\n\\n-- Sample Input List \\ninputList :: [Integer]\\ninputList = [1, -2, 3, 4, -5, 6, -7, 8, 9, 10]\\n\\n\\n-- Helper function that updates values of maxSoFar and maxEndingHere\\n-- and call itself recursively over the values of the list \\n-- and when the list is empty, return the maxSoFar value\\n-- with the start and end indices.\\nmaxSubArrayHelper :: Integer -> Integer -> Integer -> Integer -> Integer -> [Integer] -> (Integer, Integer, Integer)\\nmaxSubArrayHelper maxSoFar _ _ start end [] = (maxSoFar, start, end)\\nmaxSubArrayHelper maxSoFar maxEndingHere i start end (x:xs) = \\n    let i' = i + 1\\n        maxEndingHere' = maxEndingHere + x\\n    in \\n        if maxSoFar < maxEndingHere' then \\n            maxSubArrayHelper maxEndingHere' maxEndingHere' i' start i xs\\n        else if maxEndingHere' < 0 then\\n            maxSubArrayHelper maxSoFar 0 i' i' i' xs\\n        else \\n            maxSubArrayHelper maxSoFar maxEndingHere' i' start end xs\\n\\n-- Initially maxSoFar (maximum sum till the previous iteration), \\n-- maxEndingHere (maximum sum till end index of the current iteration),\\n-- start (start index) and end (end index) are sent as 0\\nmaxSubArray :: [Integer] -> (Integer, Integer, Integer)\\nmaxSubArray = maxSubArrayHelper 0 0 0 0 0\\n\\n-- Outputs (sum, start, end)\\n-- sum - sum from start to end indices of the input array\\n-- start:end - the subarray with max sum\\nmain :: IO ()\\nmain = do\\n    print (maxSubArray inputList)\"",
    "palindrome": "\"module Maths.Palindrome where\\n\\npalinedrome :: Eq a => [a] -> Bool\\npalinedrome xs = (xs == reverse xs)\\n\\nmain :: IO ()\\nmain = do\\n  print (palinedrome [1, 3, 1])\"",
    "binary search": "\"module Misc.BinarySearch where\\n\\nbsWithIndex :: (Ord a) => [a] -> a -> Int -> Maybe Int\\nbsWithIndex list n i\\n    | n == head list        = Just i\\n    | len == 1              = Nothing   -- only candidate in list is not the right elem\\n    | n < head ys           = bsWithIndex xs n i\\n    | otherwise             = bsWithIndex ys n (i + half)\\n    where \\n        len         = length list\\n        half        = len `div` 2 \\n        (xs, ys)    = splitAt half list\\n\\nbs :: (Ord a) => [a] -> a -> Int\\nbs list n = case bsWithIndex list n 0 of\\n    Just x  -> x\\n    Nothing -> -1\\n\\nmain :: IO ()\\nmain = do\\n    let intList = [1,4,7,10,25,30]\\n    print $ bs intList 29  -- 29 -> -1 as not in list\\n    print $ bs intList 7   --  7 ->  2 as in list\\n\"",
    "n queens": "\"module Misc.NQueens where\\n{-\\nThe n-Queens search is a backtracking algorithm. The n-Queens problem fits n \\nnumber of Queens onto a Chess board. As only one Queen can fit per row, a \\none-dimensional integer array is used to represent the Queen's offset on each \\nrow.\\n-}\\n\\nimport Data.List (permutations)\\n\\nmain = nqueens 8\\nnqueens size = mapM_ (printBoard size) $ take 1 $ filter (evaluateBoard size) $ board_permutations size\\n\\n--N sized Chess boards are represented as a one-dimension array.\\nboard_permutations size = permutations [0..size - 1]\\n\\n--Count the number of valid boards for a specified Chess board size.\\ncount_boards size = length $ filter (evaluateBoard size) $ board_permutations size\\n\\n--Show every valid board \\nnqueens_list size = mapM_ (printBoard size) $ filter (evaluateBoard size) $ board_permutations size\\n\\n--Board printing function\\nprintBoard size board = do \\n    printBoard2 size board \\n    putStrLn \\\"\\\" where\\n        printBoard2 _ [] = return ()\\n        printBoard2 size board = do\\n            let row = head board\\n            printRow size row\\n            printBoard2 size $ tail board\\n\\nprintRow size row = do\\n    let lstring = (replicate row \\\". \\\")\\n    let rstring = replicate (size - row - 1) \\\". \\\"\\n    putStrLn $ concat (lstring ++ [\\\"Q \\\"] ++ rstring)\\n    return ()\\n\\n--Recursively check that prior rows are valid.\\nevaluateBoard _ [] = True\\nevaluateBoard size rows = (evaluateBoard size $ cut_last rows) && validate size (cut_last rows) (last_row - 1) (last_row + 1) last_row where\\n    last_row = last rows\\n\\n--Validate that a Queen on a row doesn't have conflicts with earlier rows.\\nvalidate _ [] _ _ _ = True\\nvalidate size rows left right position = if check_row == left || check_row == right || check_row == position then False else validate size (cut_last rows) (left - 1) (right + 1) position where\\n    check_row = last rows\\n\\ncut_last x = reverse $ drop 1 $ reverse x\\n\"",
    "powerset": "\"module Misc.Powerset where\\n\\npowerset :: [a] -> [[a]]\\npowerset [] = [[]]\\npowerset (x:xs) = (powerset xs) ++ (map (\\\\ys -> x:ys) (powerset xs)) \\n\\nxs = [1,2,3,4]\\n\\nmain :: IO ()\\nmain = do\\n    putStrLn (show (powerset xs))\\n\"",
    "towers of hanoi": "\"module Misc.TowersOfHanoi where\\n\\nhanoi :: (Eq a, Num a) => a -> [Char] -> [Char] -> [Char] -> IO ()\\nhanoi 0 _ _ _ = return ()\\nhanoi n startPole intermediatePole endPole = do\\n    hanoi (n - 1) startPole endPole intermediatePole\\n    putStrLn (\\\"Move from \\\" ++ startPole ++ \\\" to \\\" ++ endPole)\\n    hanoi (n - 1) intermediatePole startPole endPole\\n\\nmain :: IO ()\\nmain = do\\n    hanoi 3 \\\"startPole\\\" \\\"intermediatePole\\\" \\\"endPole\\\"\\n\"",
    "bubble sort": "\"module Sorts.BubbleSort where\\n\\nlistToSort :: [Int]\\nlistToSort = [13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20]\\n\\n\\n-- The bubble sort function\\nbubbleSort :: (Ord a) => [a] -> [a]\\nbubbleSort lst = if bpassed == lst then lst\\n                 else bubbleSort bpassed\\n                 where bpassed = bubblePass lst\\n\\n-- A single pass of bubble sort\\nbubblePass :: (Ord a) => [a] -> [a]\\nbubblePass [] = [] -- Empty list is empty.\\nbubblePass [x] = [x] -- Singleton list is always trivially sorted.\\nbubblePass (x1:x2:xs) = if x1 > x2\\n                        then [x2] ++ (bubblePass ([x1] ++ xs))\\n                        else [x1] ++ (bubblePass ([x2] ++ xs))\\n\\nmain = do\\n    putStrLn $ \\\"Unsorted: \\\" ++ show listToSort\\n    putStrLn $ \\\"Sorted: \\\" ++ show (bubbleSort listToSort)\"",
    "heap sort": "\"module Sorts.HeapSort where\\n\\nlistToSort :: [Integer]\\nlistToSort = [13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20]\\n\\n-- Sort the input list with the heap sort algorithm\\nheapSort :: (Ord a) => [a] -> [a]\\nheapSort [] = []\\nheapSort [x] = [x]\\nheapSort xs = heapSort' (maxHeap xs) []\\n\\n-- Recursive helper function for heapSort\\nheapSort' :: Ord a => [a] -> [a] -> [a]\\nheapSort' [] out = out\\nheapSort' h out = heapSort' (extract h) out ++ [head h] \\n\\n-- Construct a max heap (represented as a list) from a given input list\\nmaxHeap :: Ord a => [a] -> [a]\\nmaxHeap [] = []\\nmaxHeap [x] = [x]\\nmaxHeap xs = maxHeap' xs (div (length xs) 2)\\n\\n-- Recursive helper function for maxHeap\\nmaxHeap' :: Ord a => [a] -> Int -> [a]\\nmaxHeap' xs 0 = maxHeapify xs 0\\nmaxHeap' xs i = maxHeap' (maxHeapify xs i) (i-1)\\n\\n-- Given a heap and an index (i), move the element at i down the heap until it is in the right position\\nmaxHeapify :: (Ord a) => [a] -> Int -> [a]\\nmaxHeapify xs i | not (hasAnyChild xs i) = xs\\n                | hasLeftChild xs i && hasRightChild xs i = \\n                    let largestChild = if xs !! (leftChild i) > xs !! (rightChild i) then leftChild i else rightChild i\\n                    in if xs !! largestChild > xs !! i then maxHeapify (swap xs largestChild i) largestChild else xs\\n                | hasLeftChild xs i =\\n                    if xs !! (leftChild i) > xs !! i then maxHeapify (swap xs (leftChild i) i) (leftChild i) else xs\\n                | otherwise =\\n                    if xs !! (rightChild i) > xs !! i then maxHeapify (swap xs (rightChild i) i) (rightChild i) else xs\\n\\n\\n-- Remove the largest element from the heap, and then fix the heap\\nextract :: Ord a => [a] -> [a]\\nextract [] = []\\nextract [_] = []\\nextract xs = maxHeapify ((last xs):take (length xs - 2) (tail xs)) 0\\n\\n\\n-- Swap the values stored in two positions in a list\\nswap :: [a] -> Int -> Int -> [a]\\nswap xs i1 i2 = map snd . foldr (\\\\x a -> \\n        if fst x == i1 then ys !! i2 : a\\n        else if fst x == i2 then ys !! i1 : a\\n        else x : a) [] $ ys\\n    where ys = zip [0..] xs\\n\\n-- Index where the left child of the node at the given index should be located\\nleftChild :: Int -> Int\\nleftChild i = 2 * i + 1\\n\\n-- Index where the right child of the node at the given index should be located\\nrightChild :: Int -> Int\\nrightChild i = 2 * i + 2\\n\\n-- Helper functions to determine which, if any, child nodes are present in the heap for the node at a given index\\nhasLeftChild, hasRightChild, hasAnyChild :: [a] -> Int -> Bool\\nhasLeftChild xs i = leftChild i < length xs\\n\\nhasRightChild xs i = rightChild i < length xs\\n\\nhasAnyChild xs i = hasLeftChild xs i || hasRightChild xs i\\n\\n\\nmain :: IO ()\\nmain = do\\n    putStrLn $ \\\"Unsorted: \\\" ++ show listToSort\\n    putStrLn $ \\\"Sorted: \\\" ++ show (heapSort listToSort)\"",
    "insertion sort": "\"module Sorts.InsertionSort where\\n\\nlistToSort = [13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20]\\n\\ninsertionSort:: (Ord a) => [a] -> [a]\\ninsertionSort [] = [] -- Empty list is empty\\ninsertionSort [x] = [x] -- Singleton lists are trivially sorted.\\ninsertionSort (x:xs) = insert x (insertionSort xs)\\n\\n-- Assumes that the second argument is an alread-sorted list,\\n-- and inserts the first argument in the appropriate position\\ninsert :: (Ord a) => a -> [a] -> [a]\\ninsert x [] = [x]\\ninsert x lst@(y:ys) = if x <= y then x:lst else y:(insert x ys)\\n\\n\\nmain = do\\n    putStrLn $ \\\"Unsorted: \\\" ++ show listToSort\\n    putStrLn $ \\\"Sorted: \\\" ++ show (insertionSort listToSort)\\n\"",
    "merge sort": "\"module Sorts.MergeSort where\\n\\nlistToSort = [13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20]\\n\\nmergeSort :: (Ord a) => [a] -> [a]\\nmergeSort [] = [] -- Empty list is empty\\nmergeSort [x] = [x] -- Singleton lists are trivially sorted.\\nmergeSort [x, y] = [(min x y), (max x y)]\\nmergeSort lst = merge (mergeSort leftL) (mergeSort rightL)\\n                where leftL = take splitPoint lst\\n                      rightL = drop splitPoint lst\\n                      splitPoint = (length lst) `div` 2\\n\\n-- Function to execute a merge of two sorted lists\\nmerge :: (Ord a) => [a] -> [a] -> [a]\\nmerge l1 [] = l1\\nmerge [] l2 = l2\\nmerge lst1@(x:xs) lst2@(y:ys) = if x < y \\n                                then x:(merge xs lst2)\\n                                else y:(merge lst1 ys)\\n\\nmain = do\\n    putStrLn $ \\\"Unsorted: \\\" ++ show listToSort\\n    putStrLn $ \\\"Sorted: \\\" ++ show (mergeSort listToSort)\"",
    "quick sort": "\"module Sorts.QuickSort where\\n\\nlistToSort :: [Int]\\nlistToSort = [13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20]\\n\\nquicksort :: (Ord a) => [a] -> [a]\\nquicksort [] = [] -- Empty list is empty.\\nquicksort [x] = [x] -- Singleton list is always trivially sorted.\\nquicksort [x, y] = [(min x y), (max x y)]\\nquicksort (x:xs) =\\n  quicksort [a | a <- xs, a <= x] ++ [x] ++ quicksort [a | a <- xs, a > x]\\n  -- x is the pivot, left quicksort returns smaller sorted and right quicksort bigger sorted\\n\\nmain = do\\n    putStrLn $ \\\"Unsorted: \\\" ++ show listToSort\\n    putStrLn $ \\\"Sorted: \\\" ++ show (quicksort listToSort)\\n\\n\"",
    "selection sort": "\"module Sorts.SelectionSort where\\n\\nlistToSort :: [Int]\\nlistToSort = [13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20]\\n\\n\\n-- The selection sort function\\nselectionSort :: (Ord a) => [a] -> [a]\\nselectionSort [] = []\\nselectionSort (x:xs) =\\n    let (y, ys) = leastUnsorted (x:xs)\\n    in y : selectionSort ys\\n\\n-- select least element from unsorted list, return it and the rest of unsorted list\\nleastUnsorted :: (Ord a) => [a] -> (a, [a])\\nleastUnsorted [x] = (x, [])\\nleastUnsorted (x:xs) =\\n    let (y, ys) = leastUnsorted xs\\n    in if x <= y then (x, xs) else (y, x:ys)\\n\\nmain = do\\n    putStrLn $ \\\"Unsorted: \\\" ++ show listToSort\\n    putStrLn $ \\\"Sorted: \\\" ++ show (selectionSort listToSort)\"",
    "shell sort": "\"module Sorts.ShellSort where\\n-- Shell sort uses insertion sort for sorting individual sublists\\nimport Sorts.InsertionSort\\n\\n-- Produces the sequence of gaps to use for sorting a list of size n\\ngaps :: Int -> [Int]\\ngaps n = reverse (takeWhile (< n) tokuda)\\n\\n-- Produces Tokuda's sequence\\ntokuda :: [Int]\\ntokuda = [gap n | n <- [1..]]\\n\\n-- Computes term k in Tokuda's sequence\\ngap :: (Integral a) => a -> a\\ngap k = ceiling (gap' k)\\n\\n-- Recursize helper function for gap\\ngap' :: (Integral a) => a -> Double\\ngap' 1 = 1\\ngap' k = 2.25 * gap' (k - 1) + 1\\n\\n-- Sort an input sequence using the shell sort algorithm\\nshellSort :: (Ord a) => [a] -> [a]\\nshellSort xs = shellSort' xs (gaps (length xs))\\n\\n-- Recursive helper function for shellSort\\nshellSort' :: (Ord a) => [a] -> [Int] -> [a]\\nshellSort' [] _ = []\\nshellSort' [x] _ = [x]\\nshellSort' l [] = l\\nshellSort' l (g:gs) = shellSort' (combine [insertionSort (getSub l g i) | i <- [0..g-1]]) gs\\n\\n-- Get the sublist of l formed by taking elements with gap g between them, starting at index i\\ngetSub :: (Ord a) => [a] -> Int -> Int -> [a]\\ngetSub [] _ _ = []\\ngetSub l g i = [l !! e | e <- [i, i+g..length l - 1]] \\n\\n\\n-- Combine a list of sublists into a single list in the correct order\\n-- Required after individual sublists have been sorted, to rebuild the main list\\ncombine :: [[a]] -> [a]\\ncombine [] = []\\ncombine l@(xs:_)\\n        | length xs == 0 = []\\n        | otherwise = [x | (x:_) <- l] ++ combine (map (drop 1) l)\\n\\nmain :: IO ()\\nmain = do\\n    putStrLn $ \\\"Unsorted: \\\" ++ show listToSort\\n    putStrLn $ \\\"Sorted: \\\" ++ show (shellSort listToSort)\"",
    "merge find set": "\"module SpecializedStructure.MergeFindSet where\\n\\nimport qualified Data.Map as Map\\nimport qualified Data.Set as Set\\n\\ntype Mfset a = (Map.Map a a, Map.Map a Int)\\n\\nfromSet :: Ord a => Set.Set a -> Mfset a\\nfromSet ns = (fathers, ranks)\\n    where\\n        fathers = Map.fromList [(i, i) | i <- Set.toList ns]\\n        ranks   = Map.fromList [(i, 0) | i <- Set.toList ns]\\n\\nfind :: Ord a => a -> Mfset a -> a\\nfind x mfset = let father = fst mfset Map.! x\\n               in if father == x then x else find father mfset\\n\\nmerge :: Ord a => a -> a -> Mfset a -> Mfset a\\nmerge x y mfset\\n    | x' == y'  = mfset\\n    | rx == ry  = (x' `connectTo` y', Map.adjust (+1) y' ranks)\\n    | rx < ry   = (x' `connectTo` y', ranks)\\n    | otherwise = (y' `connectTo` x', ranks)\\n    where\\n        (fathers, ranks) = mfset\\n        connectTo a b = Map.adjust (const b) a fathers\\n        findWithRank a = (\\\\f -> (f, ranks Map.! f)) $ find a mfset\\n        (x', rx) = findWithRank x\\n        (y', ry) = findWithRank y\\n\"",
    "center": "\"module Statistics.Center where\\n\\nimport qualified Data.Sort as S\\nimport qualified Data.Vector.Generic as VG\\nimport qualified Data.Vector.Algorithms.Intro as VGAI\\n\\n-- Measures of central tendency.\\n\\narithmeticMean :: (Foldable t, Fractional a) => t a -> a\\narithmeticMean vals = (sum vals) / (fromIntegral $ length vals)\\n\\ngeometricMean :: (Foldable t, Floating a) => t a -> a\\ngeometricMean vals = (product vals) ** (1/(fromIntegral $ length vals))\\n\\nharmonicMean :: (Foldable t, Functor t, Fractional a) => t a -> a\\nharmonicMean vals = (sum $ fmap (1/) vals) / (fromIntegral $ length vals)\\n\\n-- For median, since the containers are sorted differently, we need to use\\n-- different methods\\n\\nmedianList :: (Fractional a, Ord a) => [a] -> a\\nmedianList = medianListSorted . S.sort\\n\\nmedianVector\\n  :: (VG.Vector vector a, Foldable vector, Fractional a, Ord a)\\n  => vector a -> a\\nmedianVector = medianVectorSorted . VG.modify VGAI.sort\\n\\n-- When sorted, the two median algorithms are quite similar. We can reduce\\n-- duplication by adding an export list to the module and using more\\n-- higher-order functions but let's leave this for a different PR.\\n\\nmedianListSorted :: Fractional a => [a] -> a\\nmedianListSorted vals\\n  | odd n = vals !! mid\\n  | otherwise = arithmeticMean $ take 2 $ drop (mid - 1) vals\\n  where\\n    n = length vals\\n    mid = n `div` 2\\n\\nmedianVectorSorted\\n  :: (VG.Vector vector a, Foldable vector, Fractional a)\\n  => vector a -> a\\nmedianVectorSorted vals\\n  | odd n = vals VG.! mid\\n  | otherwise = arithmeticMean $ VG.take 2 $ VG.drop (mid - 1) vals\\n  where\\n    n = length vals\\n    mid = n `div` 2\\n\"",
    "dispersion": "\"module Statistics.Dispersion where\\n\\nimport Statistics.Center\\n\\nvariance :: (Foldable t, Functor t, Fractional a) => t a -> a\\nvariance vals = (sum $ fmap (\\\\x -> x * x) deviations) / n\\n    where n = (fromIntegral $ length vals)\\n          mu = arithmeticMean vals\\n          deviations = fmap (\\\\x -> x-mu) vals\\n\\nstdev :: (Foldable t, Functor t, Floating a) => t a -> a\\nstdev vals = sqrt $ variance vals\\n\""
  }
}
