{
  "c": {
    "client": "\"/**\\n * @file\\n * @author [Nairit11](https://github.com/Nairit11)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Client side implementation of Server-Client system.\\n * @see client_server/server.c\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#ifdef _WIN32                            // if compiling for Windows\\n#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next\\n                                         // MSVC compiler versions\\n#include <winsock2.h>\\n#define bzero(b, len) \\\\\\n    (memset((b), '\\\\0', (len)), (void)0) /**< BSD name not in windows */\\n#define read(a, b, c) recv(a, b, c, 0)  /**< map BSD name to Winsock */\\n#define write(a, b, c) send(a, b, c, 0) /**< map BSD name to Winsock */\\n#define close closesocket               /**< map BSD name to Winsock */\\n#else                                   // if not windows platform\\n#include <arpa/inet.h>\\n#include <netdb.h>\\n#include <sys/socket.h>\\n#include <unistd.h>\\n#endif\\n\\n#define MAX 80             /**< max. characters per message */\\n#define PORT 8080          /**< port number to connect to */\\n#define SA struct sockaddr /**< shortname for sockaddr */\\n\\n/**\\n * Continuous loop to send and receive over the socket.\\n * Exits when \\\"exit\\\" is sent from commandline.\\n * @param sockfd socket handle number\\n */\\nvoid func(int sockfd)\\n{\\n    char buff[MAX];\\n    int n;\\n    for (;;)\\n    {\\n        bzero(buff, sizeof(buff));\\n        printf(\\\"Enter the string : \\\");\\n        n = 0;\\n        while ((buff[n++] = getchar()) != '\\\\n')\\n        {\\n            ;\\n        }\\n        write(sockfd, buff, sizeof(buff));\\n        bzero(buff, sizeof(buff));\\n        read(sockfd, buff, sizeof(buff));\\n        printf(\\\"From Server : %s\\\", buff);\\n        if ((strncmp(buff, \\\"exit\\\", 4)) == 0)\\n        {\\n            printf(\\\"Client Exit...\\\\n\\\");\\n            break;\\n        }\\n    }\\n}\\n\\n#ifdef _WIN32\\n/** Cleanup function will be automatically called on program exit */\\nvoid cleanup() { WSACleanup(); }\\n#endif\\n\\n/**\\n * @brief Driver code\\n */\\nint main()\\n{\\n#ifdef _WIN32\\n    // when using winsock2.h, startup required\\n    WSADATA wsData;\\n    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)\\n    {\\n        perror(\\\"WSA Startup error: \\\\n\\\");\\n        return 0;\\n    }\\n\\n    atexit(cleanup);  // register at-exit function\\n#endif\\n\\n    int sockfd, connfd;\\n    struct sockaddr_in servaddr, cli;\\n\\n    // socket create and verification\\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\\n    if (sockfd == -1)\\n    {\\n        printf(\\\"socket creation failed...\\\\n\\\");\\n        exit(0);\\n    }\\n    else\\n    {\\n        printf(\\\"Socket successfully created..\\\\n\\\");\\n    }\\n    bzero(&servaddr, sizeof(servaddr));\\n\\n    // assign IP, PORT\\n    servaddr.sin_family = AF_INET;\\n    servaddr.sin_addr.s_addr = inet_addr(\\\"127.0.0.1\\\");\\n    servaddr.sin_port = htons(PORT);\\n\\n    // connect the client socket to server socket\\n    if (connect(sockfd, (SA *)&servaddr, sizeof(servaddr)) != 0)\\n    {\\n        printf(\\\"connection with the server failed...\\\\n\\\");\\n        exit(0);\\n    }\\n    else\\n    {\\n        printf(\\\"connected to the server..\\\\n\\\");\\n    }\\n\\n    // function for chat\\n    func(sockfd);\\n\\n    // close the socket\\n    close(sockfd);\\n    return 0;\\n}\\n\"",
    "server": "\"/**\\n * @file\\n * @author [Nairit11](https://github.com/Nairit11)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Server side implementation of Server-Client system.\\n * @see client_server/client.c\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n// #ifdef HAS_UNISTD\\n// #include <unistd.h>\\n// #endif\\n\\n#ifdef _WIN32\\n#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next\\n                                         // MSVC compiler versions\\n#include <winsock2.h>\\n#define bzero(b, len) \\\\\\n    (memset((b), '\\\\0', (len)), (void)0) /**< BSD name not in windows */\\n#define read(a, b, c) recv(a, b, c, 0)  /**< map BSD name to Winsock */\\n#define write(a, b, c) send(a, b, c, 0) /**< map BSD name to Winsock */\\n#define close closesocket               /**< map BSD name to Winsock */\\n#else\\n// if not windows platform\\n#include <arpa/inet.h>\\n#include <netdb.h>\\n#include <sys/socket.h>\\n#include <unistd.h>\\n#endif\\n\\n#define MAX 80             /**< max. characters per message */\\n#define PORT 8080          /**< port number to connect to */\\n#define SA struct sockaddr /**< shortname for sockaddr */\\n\\n#ifdef _WIN32\\n/** Cleanup function will be automatically called on program exit */\\nvoid cleanup() { WSACleanup(); }\\n#endif\\n\\n/**\\n * Continuous loop to send and receive over the socket.\\n * Exits when \\\"exit\\\" is sent from commandline.\\n * @param sockfd socket handle number\\n */\\nvoid func(int sockfd)\\n{\\n    char buff[MAX];\\n    int n;\\n    // infinite loop for chat\\n    for (;;)\\n    {\\n        bzero(buff, MAX);\\n\\n        // read the message from client and copy it in buffer\\n        read(sockfd, buff, sizeof(buff));\\n        // print buffer which contains the client contents\\n        printf(\\\"From client: %s\\\\t To client : \\\", buff);\\n        bzero(buff, MAX);\\n        n = 0;\\n        // copy server message in the buffer\\n        while ((buff[n++] = getchar()) != '\\\\n')\\n        {\\n            ;\\n        }\\n\\n        // and send that buffer to client\\n        write(sockfd, buff, sizeof(buff));\\n\\n        // if msg contains \\\"Exit\\\" then server exit and chat ended.\\n        if (strncmp(\\\"exit\\\", buff, 4) == 0)\\n        {\\n            printf(\\\"Server Exit...\\\\n\\\");\\n            break;\\n        }\\n    }\\n}\\n\\n/** Driver code */\\nint main()\\n{\\n#ifdef _WIN32\\n    // when using winsock2.h, startup required\\n    WSADATA wsData;\\n    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)\\n    {\\n        perror(\\\"WSA Startup error: \\\\n\\\");\\n        return 0;\\n    }\\n\\n    atexit(cleanup);  // register at-exit function\\n#endif\\n\\n    int sockfd, connfd;\\n    unsigned int len;\\n    struct sockaddr_in servaddr, cli;\\n\\n    // socket create and verification\\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\\n    if (sockfd == -1)\\n    {\\n        perror(\\\"socket creation failed...\\\\n\\\");\\n        exit(0);\\n    }\\n    else\\n    {\\n        printf(\\\"Socket successfully created..\\\\n\\\");\\n    }\\n    bzero(&servaddr, sizeof(servaddr));\\n\\n    // assign IP, PORT\\n    servaddr.sin_family = AF_INET;\\n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\\n    servaddr.sin_port = htons(PORT);\\n\\n    // Binding newly created socket to given IP and verification\\n    if ((bind(sockfd, (SA *)&servaddr, sizeof(servaddr))) != 0)\\n    {\\n        perror(\\\"socket bind failed...\\\\n\\\");\\n        exit(0);\\n    }\\n    else\\n    {\\n        printf(\\\"Socket successfully binded..\\\\n\\\");\\n    }\\n\\n    // Now server is ready to listen and verification\\n    if ((listen(sockfd, 5)) != 0)\\n    {\\n        perror(\\\"Listen failed...\\\\n\\\");\\n        exit(0);\\n    }\\n    else\\n    {\\n        printf(\\\"Server listening..\\\\n\\\");\\n    }\\n    len = sizeof(cli);\\n\\n    // Accept the data packet from client and verification\\n    connfd = accept(sockfd, (SA *)&cli, &len);\\n    if (connfd < 0)\\n    {\\n        perror(\\\"server acccept failed...\\\\n\\\");\\n        exit(0);\\n    }\\n    else\\n    {\\n        printf(\\\"server acccept the client...\\\\n\\\");\\n    }\\n\\n    // Function for chatting between client and server\\n    func(connfd);\\n\\n    // After chatting close the socket\\n    close(sockfd);\\n    return 0;\\n}\\n\"",
    "tcp full duplex client": "\"/**\\n * @file\\n * @author [NVombat](https://github.com/NVombat)\\n * @brief Client-side implementation of [TCP Full Duplex\\n * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)\\n * @see tcp_full_duplex_server.c\\n *\\n * @details\\n * The algorithm is based on the simple TCP client and server model. However,\\n * instead of the server only sending and the client only receiving data,\\n * The server and client can both send and receive data simultaneously. This is\\n * implemented by using the `fork` function call so that in the server the child\\n * process can recieve data and  parent process can send data, and in the client\\n * the child process can send data and the parent process can receive data. It\\n * runs an infinite loop and can send and receive messages indefinitely until\\n * the user exits the loop. In this way, the Full Duplex Form of communication\\n * can be represented using the TCP server-client model & socket programming\\n */\\n\\n#include <arpa/inet.h>             /// For the type in_addr_t and in_port_t\\n#include <netdb.h>                /// For structures returned by the network database library - formatted internet addresses and port numbers\\n#include <netinet/in.h>          /// For in_addr and sockaddr_in structures\\n#include <stdint.h>             /// For specific bit size values of variables\\n#include <stdio.h>             /// Variable types, several macros, and various functions for performing input and output\\n#include <stdlib.h>           /// Variable types, several macros, and various functions for performing general functions\\n#include <string.h>          /// Various functions for manipulating arrays of characters\\n#include <sys/socket.h>     /// For macro definitions related to the creation of sockets\\n#include <sys/types.h>     /// For definitions to allow for the porting of BSD programs\\n#include <unistd.h>       /// For miscellaneous symbolic constants and types, and miscellaneous functions\\n\\n#define PORT 10000  /// Define port over which communication will take place\\n\\n/**\\n * @brief Utility function used to print an error message to `stderr`.\\n * It prints `str` and an implementation-defined error\\n * message corresponding to the global variable `errno`.\\n * @returns void\\n */\\nvoid error()\\n{\\n    perror(\\\"Socket Creation Failed\\\");\\n    exit(EXIT_FAILURE);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    /** Variable Declarations */\\n    uint32_t\\n        sockfd;  ///< socket descriptors - Like file handles but for sockets\\n    char sendbuff[1024],\\n        recvbuff[1024];  ///< character arrays to read and store string data\\n                         /// for communication\\n\\n    struct sockaddr_in\\n        server_addr;  ///< asic structures for all syscalls and functions that\\n                      /// deal with internet addresses. Structures for handling\\n                      /// internet addresses\\n\\n    /**\\n     * The TCP socket is created using the socket function.\\n     *\\n     * AF_INET (Family) - it is an address family that is used to designate the\\n     * type of addresses that your socket can communicate with\\n     *\\n     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides\\n     * for the bidirectional, reliable, sequenced, and unduplicated flow of data\\n     * without record boundaries. Aside from the bidirectionality of data flow,\\n     * a pair of connected stream sockets provides an interface nearly identical\\n     * to pipes.\\n     *\\n     * 0 (Protocol) - Specifies a particular protocol to be used with the\\n     * socket. Specifying a protocol of 0 causes socket() to use an unspecified\\n     * default protocol appropriate for the requested socket type.\\n     */\\n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\\n    {\\n        error();\\n    }\\n\\n    /**\\n     * Server Address Information\\n     *\\n     * The bzero() function erases the data in the n bytes of the memory\\n     * starting at the location pointed to, by writing zeros (bytes\\n     * containing '\\\\0') to that area.\\n     *\\n     * We bind the server_addr to the internet address and port number thus\\n     * giving our socket an identity with an address and port where it can\\n     * listen for connections\\n     *\\n     * htons - The htons() function translates a short integer from host byte\\n     * order to network byte order\\n     *\\n     * htonl - The htonl() function translates a long integer from host byte\\n     * order to network byte order\\n     *\\n     * These functions are necessary so that the binding of address and port\\n     * takes place with data in the correct format\\n     */\\n    bzero(&server_addr, sizeof(server_addr));\\n    server_addr.sin_family = AF_INET;\\n    server_addr.sin_port = htons(PORT);\\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\\n\\n    printf(\\\"Client is running...\\\\n\\\");\\n\\n    /**\\n     * Connects the client to the server address using the socket descriptor\\n     * This enables the two to communicate and exchange data\\n     */\\n    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));\\n\\n    printf(\\\"Client is connected...\\\\n\\\");\\n\\n    /**\\n     * Communication between client and server\\n     *\\n     * The bzero() function erases the data in the n bytes of the memory\\n     * starting at the location pointed to, by writing zeros (bytes\\n     * containing '\\\\0') to that area. The variables are emptied and then\\n     * ready for use\\n     *\\n     * The fork function call is used to create a child and parent process\\n     * which run and execute code simultaneously\\n     *\\n     * The child process is used to send data and after doing so\\n     * sleeps for 5 seconds to wait for the parent to receive data\\n     *\\n     * The parent process is used to receive data and after doing so\\n     * sleeps for 5 seconds to wait for the child to send data\\n     *\\n     * The server and client can communicate indefinitely till one of them\\n     * exits the connection\\n     *\\n     * Since the exchange of information between the server and client takes\\n     * place simultaneously this represents FULL DUPLEX COMMUNICATION\\n     */\\n    pid_t pid;\\n    pid = fork();\\n    if (pid == 0)  /// Value of 0 is for child process\\n    {\\n        while (1)\\n        {\\n            bzero(&sendbuff, sizeof(sendbuff));\\n            printf(\\\"\\\\nType message here: \\\");\\n            fgets(sendbuff, 1024, stdin);\\n            send(sockfd, sendbuff, strlen(sendbuff) + 1, 0);\\n            printf(\\\"\\\\nMessage sent!\\\\n\\\");\\n            sleep(5);\\n            // break;\\n        }\\n    }\\n    else  /// Parent Process\\n    {\\n        while (1)\\n        {\\n            bzero(&recvbuff, sizeof(recvbuff));\\n            recv(sockfd, recvbuff, sizeof(recvbuff), 0);\\n            printf(\\\"\\\\nSERVER: %s\\\\n\\\", recvbuff);\\n            sleep(5);\\n            // break;\\n        }\\n    }\\n\\n    /// Close Socket\\n    close(sockfd);\\n    printf(\\\"Client is offline...\\\\n\\\");\\n    return 0;\\n}\\n\"",
    "tcp full duplex server": "\"/**\\n * @file\\n * @author [NVombat](https://github.com/NVombat)\\n * @brief Server-side implementation of [TCP Full Duplex\\n * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)\\n * @see tcp_full_duplex_server.c\\n *\\n * @details\\n * The algorithm is based on the simple TCP client and server model. However,\\n * instead of the server only sending and the client only receiving data,\\n * The server and client can both send and receive data simultaneously. This is\\n * implemented by using the `fork` function call so that in the server the child\\n * process can recieve data and  parent process can send data, and in the client\\n * the child process can send data and the parent process can receive data. It\\n * runs an infinite loop and can send and receive messages indefinitely until\\n * the user exits the loop. In this way, the Full Duplex Form of communication\\n * can be represented using the TCP server-client model & socket programming\\n */\\n\\n#include <arpa/inet.h>             /// For the type in_addr_t and in_port_t\\n#include <netdb.h>                /// For structures returned by the network database library - formatted internet addresses and port numbers\\n#include <netinet/in.h>          /// For in_addr and sockaddr_in structures\\n#include <stdint.h>             /// For specific bit size values of variables\\n#include <stdio.h>             /// Variable types, several macros, and various functions for performing input and output\\n#include <stdlib.h>           /// Variable types, several macros, and various functions for performing general functions\\n#include <string.h>          /// Various functions for manipulating arrays of characters\\n#include <sys/socket.h>     /// For macro definitions related to the creation of sockets\\n#include <sys/types.h>     /// For definitions to allow for the porting of BSD programs\\n#include <unistd.h>       /// For miscellaneous symbolic constants and types, and miscellaneous functions\\n\\n#define PORT 10000  /// Define port over which communication will take place\\n\\n/**\\n * @brief Utility function used to print an error message to `stderr`.\\n * It prints `str` and an implementation-defined error\\n * message corresponding to the global variable `errno`.\\n * @returns void\\n */\\nvoid error()\\n{\\n    perror(\\\"Socket Creation Failed\\\");\\n    exit(EXIT_FAILURE);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    /** Variable Declarations */\\n    uint32_t sockfd,\\n        conn;  ///< socket descriptors - Like file handles but for sockets\\n    char recvbuff[1024],\\n        sendbuff[1024];  ///< character arrays to read and store string data\\n                         /// for communication\\n\\n    struct sockaddr_in server_addr,\\n        client_addr;  ///< asic structures for all syscalls and functions that\\n                      /// deal with internet addresses. Structures for handling\\n                      /// internet addresses\\n    socklen_t ClientLen;  /// size of address\\n\\n    /**\\n     * The TCP socket is created using the socket function\\n     *\\n     * AF_INET (Family) - it is an address family that is used to designate the\\n     * type of addresses that your socket can communicate with\\n     *\\n     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides\\n     * for the bidirectional, reliable, sequenced, and unduplicated flow of data\\n     * without record boundaries. Aside from the bidirectionality of data flow,\\n     * a pair of connected stream sockets provides an interface nearly identical\\n     * to pipes\\n     *\\n     * 0 (Protocol) - Specifies a particular protocol to be used with the\\n     * socket. Specifying a protocol of 0 causes socket() to use an unspecified\\n     * default protocol appropriate for the requested socket type\\n     */\\n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\\n    {\\n        error();  ///< Error if the socket descriptor has a value lower than 0 -\\n                  /// socket wasnt created\\n    }\\n\\n    /**\\n     * Server Address Information\\n     *\\n     * The bzero() function erases the data in the n bytes of the memory\\n     * starting at the location pointed to, by writing zeros (bytes\\n     * containing '\\\\0') to that area\\n     *\\n     * We bind the server_addr to the internet address and port number thus\\n     * giving our socket an identity with an address and port where it can\\n     * listen for connections\\n     *\\n     * htons - The htons() function translates a short integer from host byte\\n     * order to network byte order\\n     *\\n     * htonl - The htonl() function translates a long integer from host byte\\n     * order to network byte order\\n     *\\n     * These functions are necessary so that the binding of address and port\\n     * takes place with data in the correct format\\n     */\\n    bzero(&server_addr, sizeof(server_addr));\\n    server_addr.sin_family = AF_INET;\\n    server_addr.sin_port = htons(PORT);\\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\\n\\n    printf(\\\"Server is running...\\\\n\\\");\\n\\n    /**\\n     * This binds the socket descriptor to the server thus enabling the server\\n     * to listen for connections and communicate with other clients\\n     */\\n    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)\\n    {\\n        error();  /// If binding is unsuccessful\\n    }\\n    /**\\n     * This is to listen for clients or connections made to the server\\n     *\\n     * The limit is currently at 5 but can be increased to listen for\\n     * more connections\\n     *\\n     * It listens to connections through the socket descriptor\\n     */\\n    listen(sockfd, 5);\\n\\n    printf(\\\"Server is listening...\\\\n\\\");\\n\\n    /**\\n     * When a connection is found, a socket is created and connection is\\n     * accepted and established through the socket descriptor\\n     */\\n    conn = accept(sockfd, (struct sockaddr *)NULL, NULL);\\n\\n    printf(\\\"Server is connected...\\\\n\\\");\\n\\n    /**\\n     * Communication between client and server\\n     *\\n     * The bzero() function erases the data in the n bytes of the memory\\n     * starting at the location pointed to, by writing zeros (bytes\\n     * containing '\\\\0') to that area. The variables are emptied and then\\n     * ready for use\\n     *\\n     * The fork function call is used to create a child and parent process\\n     * which run and execute code simultaneously\\n     *\\n     * The child process is used to receive data and after doing so\\n     * sleeps for 5 seconds to wait for the parent to send data\\n     *\\n     * The parent process is used to send data and after doing so\\n     * sleeps for 5 seconds to wait for the child to receive data\\n     *\\n     * The server and client can communicate indefinitely till one of them\\n     * exits the connection\\n     *\\n     * Since the exchange of information between the server and client takes\\n     * place simultaneously this represents FULL DUPLEX COMMUNICATION\\n     */\\n    pid_t pid;\\n    pid = fork();\\n    if (pid == 0)  /// Value of 0 is for child process\\n    {\\n        while (1)\\n        {\\n            bzero(&recvbuff, sizeof(recvbuff));\\n            recv(conn, recvbuff, sizeof(recvbuff), 0);\\n            printf(\\\"\\\\nCLIENT : %s\\\\n\\\", recvbuff);\\n            sleep(5);\\n            // break;\\n        }\\n    }\\n    else  /// Parent process\\n    {\\n        while (1)\\n        {\\n            bzero(&sendbuff, sizeof(sendbuff));\\n            printf(\\\"\\\\nType message here: \\\");\\n            fgets(sendbuff, 1024, stdin);\\n            send(conn, sendbuff, strlen(sendbuff) + 1, 0);\\n            printf(\\\"\\\\nMessage Sent!\\\\n\\\");\\n            sleep(5);\\n            // break;\\n        }\\n    }\\n\\n    /// Close socket\\n    close(sockfd);\\n    printf(\\\"Server is offline...\\\\n\\\");\\n    return 0;\\n}\\n\"",
    "tcp half duplex client": "\"/**\\n * @file\\n * @author [Nikhill Vombatkere](https://github.com/NVombat)\\n * @brief Client-side implementation of [TCP Half Duplex\\n * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)\\n * @see tcp_half_duplex_server.c\\n *\\n * @details\\n * The algorithm is based on the simple TCP client and server model. However,\\n * instead of the server only sending and the client only receiving data,\\n * the server and client can both send data but only one at a time. This is\\n * implemented by using a particular ordering of the `send()` and `recv()`\\n * functions. When one of the clients or servers is sending, the other can only\\n * receive and vice-versa. In this way, the Half Duplex Form of communication\\n * can be represented using the TCP server-client model & socket programming\\n */\\n\\n#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers\\n#include <netinet/in.h>  /// For in_addr and sockaddr_in structures\\n#include <stdint.h>      /// For specific bit size values of variables\\n#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output\\n#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions\\n#include <string.h>  /// Various functions for manipulating arrays of characters\\n#include <sys/socket.h>  /// For macro definitions related to the creation of sockets\\n#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs\\n#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions\\n\\n#define PORT 8100  /// Define port over which communication will take place\\n\\n/**\\n * @brief Utility function used to print an error message to `stderr`.\\n * It prints `str` and an implementation-defined error\\n * message corresponding to the global variable `errno`.\\n * @returns void\\n */\\nvoid error()\\n{\\n    perror(\\\"Socket Creation Failed\\\");\\n    exit(EXIT_FAILURE);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    /** Variable Declarations */\\n    uint32_t\\n        sockfd;  ///< socket descriptors - Like file handles but for sockets\\n    struct sockaddr_in\\n        server_addr;  ///< basic structures for all syscalls and functions that\\n                      /// deal with internet addresses. Structures for handling\\n                      /// internet addresses\\n    char serverResponse[10000],\\n        clientResponse[10000];  ///< Character arrays to read and store string\\n                                /// data for communication\\n\\n    /**\\n     * The TCP socket is created using the socket function.\\n     *\\n     * AF_INET (Family) - it is an address family that is used to designate the\\n     * type of addresses that your socket can communicate with\\n     *\\n     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides\\n     * for the bidirectional, reliable, sequenced, and unduplicated flow of data\\n     * without record boundaries. Aside from the bidirectionality of data flow,\\n     * a pair of connected stream sockets provides an interface nearly identical\\n     * to pipes.\\n     *\\n     * 0 (Protocol) - Specifies a particular protocol to be used with the\\n     * socket. Specifying a protocol of 0 causes socket() to use an unspecified\\n     * default protocol appropriate for the requested socket type.\\n     */\\n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\\n    {\\n        error();\\n    }\\n\\n    /**\\n     * Server Address Information\\n     *\\n     * The bzero() function erases the data in the n bytes of the memory\\n     * starting at the location pointed to, by writing zeros (bytes\\n     * containing '\\\\0') to that area.\\n     *\\n     * We bind the server_addr to the internet address and port number thus\\n     * giving our socket an identity with an address and port where it can\\n     * listen for connections\\n     *\\n     * htons - The htons() function translates a short integer from host byte\\n     * order to network byte order\\n     *\\n     * htonl - The htonl() function translates a long integer from host byte\\n     * order to network byte order\\n     *\\n     * These functions are necessary so that the binding of address and port\\n     * takes place with data in the correct format\\n     */\\n    bzero(&server_addr, sizeof(server_addr));\\n    server_addr.sin_family = AF_INET;\\n    server_addr.sin_port = htons(PORT);\\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\\n\\n    printf(\\\"Client is running...\\\\n\\\");\\n\\n    /**\\n     * Connects the client to the server address using the socket descriptor\\n     * This enables the two to communicate and exchange data\\n     */\\n    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));\\n\\n    printf(\\\"Client is connected...\\\\n\\\");\\n\\n    /**\\n     * Communication between client and server\\n     *\\n     * The bzero() function erases the data in the n bytes of the memory\\n     * starting at the location pointed to, by writing zeros (bytes\\n     * containing '\\\\0') to that area. The variables are emptied and then\\n     * ready for use\\n     *\\n     * First the CLIENT receives the servers message and displays it (recv())\\n     *\\n     * The CLIENT is then prompted to type in a message and send it to the\\n     * server. (send())\\n     *\\n     * The server and client can communicate till one of them exits the\\n     * connection\\n     *\\n     * Since the exchange of information between the server and client take\\n     * place one at a time this represents HALF DUPLEX COMMUNICATION\\n     */\\n    while (1)\\n    {\\n        bzero(&serverResponse, sizeof(serverResponse));\\n        bzero(&clientResponse, sizeof(clientResponse));\\n\\n        /// Receive Message\\n        recv(sockfd, serverResponse, sizeof(serverResponse), 0);\\n        printf(\\\"\\\\nServer message: %s \\\\n\\\", serverResponse);\\n\\n        /// Send Message\\n        printf(\\\"\\\\nEnter message here: \\\");\\n        fgets(clientResponse, 10000, stdin);\\n        send(sockfd, clientResponse, strlen(clientResponse) + 1, 0);\\n    }\\n\\n    /// Close Socket\\n    close(sockfd);\\n    printf(\\\"Client is offline...\\\\n\\\");\\n    return 0;\\n}\\n\"",
    "tcp half duplex server": "\"/**\\n * @file\\n * @author [NVombat](https://github.com/NVombat)\\n * @brief Server-side implementation of [TCP Half Duplex\\n * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)\\n * @see tcp_half_duplex_server.c\\n *\\n * @details\\n * The algorithm is based on the simple TCP client and server model. However,\\n * instead of the server only sending and the client only receiving data,\\n * The server and client can both send data but only one at a time. This is\\n * implemented by using a particular ordering of the `send()` and `recv()`\\n * functions. When one of the clients or servers is sending, the other can only\\n * receive and vice-versa. In this way, the Half Duplex Form of communication\\n * can be represented using the TCP server-client model & socket programming\\n */\\n\\n#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers\\n#include <netinet/in.h>  /// For in_addr and sockaddr_in structures\\n#include <stdint.h>      /// For specific bit size values of variables\\n#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output\\n#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions\\n#include <string.h>  /// Various functions for manipulating arrays of characters\\n#include <sys/socket.h>  /// For macro definitions related to the creation of sockets\\n#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs\\n#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions\\n\\n#define PORT 8100  /// Define port over which communication will take place\\n\\n/**\\n * @brief Utility function used to print an error message to `stderr`.\\n * It prints `str` and an implementation-defined error\\n * message corresponding to the global variable `errno`.\\n * @returns void\\n */\\nvoid error()\\n{\\n    perror(\\\"Socket Creation Failed\\\");\\n    exit(EXIT_FAILURE);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    /** Variable Declarations */\\n    uint32_t sockfd,\\n        conn;  ///< socket descriptors - Like file handles but for sockets\\n    char server_msg[10000],\\n        client_msg[10000];  ///< character arrays to read and store string data\\n                            /// for communication\\n    struct sockaddr_in server_addr,\\n        client_addr;  ///< asic structures for all syscalls and functions that\\n                      /// deal with internet addresses. Structures for handling\\n                      /// internet addresses\\n\\n    /**\\n     * The TCP socket is created using the socket function\\n     *\\n     * AF_INET (Family) - it is an address family that is used to designate the\\n     * type of addresses that your socket can communicate with\\n     *\\n     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides\\n     * for the bidirectional, reliable, sequenced, and unduplicated flow of data\\n     * without record boundaries. Aside from the bidirectionality of data flow,\\n     * a pair of connected stream sockets provides an interface nearly identical\\n     * to pipes\\n     *\\n     * 0 (Protocol) - Specifies a particular protocol to be used with the\\n     * socket. Specifying a protocol of 0 causes socket() to use an unspecified\\n     * default protocol appropriate for the requested socket type\\n     */\\n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\\n    {\\n        error();  ///< Error if the socket descriptor has a value lower than 0 -\\n                  /// socket wasnt created\\n    }\\n\\n    /**\\n     * Server Address Information\\n     *\\n     * The bzero() function erases the data in the n bytes of the memory\\n     * starting at the location pointed to, by writing zeros (bytes\\n     * containing '\\\\0') to that area\\n     *\\n     * We bind the server_addr to the internet address and port number thus\\n     * giving our socket an identity with an address and port where it can\\n     * listen for connections\\n     *\\n     * htons - The htons() function translates a short integer from host byte\\n     * order to network byte order\\n     *\\n     * htonl - The htonl() function translates a long integer from host byte\\n     * order to network byte order\\n     *\\n     * These functions are necessary so that the binding of address and port\\n     * takes place with data in the correct format\\n     */\\n    bzero(&server_addr, sizeof(server_addr));\\n    server_addr.sin_family = AF_INET;    /// Domain/Family to be used\\n    server_addr.sin_port = htons(PORT);  /// Port to be used\\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\\n\\n    printf(\\\"Server is running...\\\\n\\\");\\n\\n    /**\\n     * This binds the socket descriptor to the server thus enabling the server\\n     * to listen for connections and communicate with other clients\\n     */\\n    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)\\n    {\\n        error();  /// If binding is unsuccessful\\n    }\\n\\n    /**\\n     * This is to listen for clients or connections made to the server\\n     *\\n     * The limit is currently at 5 but can be increased to listen for\\n     * more connections\\n     *\\n     * It listens to connections through the socket descriptor\\n     */\\n    listen(sockfd, 5);\\n\\n    printf(\\\"Server is listening...\\\\n\\\");\\n\\n    /**\\n     * When a connection is found, a socket is created and connection is\\n     * accepted and established through the socket descriptor\\n     */\\n    conn = accept(sockfd, (struct sockaddr *)NULL, NULL);\\n\\n    printf(\\\"Server is connected...\\\\n\\\");\\n\\n    /**\\n     * Communication between client and server\\n     *\\n     * The bzero() function erases the data in the n bytes of the memory\\n     * starting at the location pointed to, by writing zeros (bytes\\n     * containing '\\\\0') to that area. The variables are emptied and then\\n     * ready for use\\n     *\\n     * First the SERVER is prompted to type a message which is read from\\n     * stdin and then sent over the connection that was established - the socket\\n     * - to be received by the client (send())\\n     *\\n     * The SERVER then waits for the client to reply. It then receives the reply\\n     * in the string variable and displays it (recv())\\n     *\\n     * The server and client can communicate till one of them exits the\\n     * connection\\n     *\\n     * Since the exchange of information between the server and client take\\n     * place one at a time this represents HALF DUPLEX COMMUNICATION\\n     */\\n    while (1)\\n    {\\n        bzero(&server_msg, sizeof(server_msg));\\n        bzero(&client_msg, sizeof(client_msg));\\n\\n        /// Send message\\n        printf(\\\"\\\\nEnter message here: \\\");\\n        fgets(server_msg, 10000, stdin);\\n        send(conn, server_msg, strlen(server_msg) + 1, 0);\\n\\n        /// Receive Message\\n        recv(conn, client_msg, sizeof(client_msg), 0);\\n        printf(\\\"\\\\nClient Message: %s\\\\n\\\", client_msg);\\n    }\\n\\n    /// Close socket\\n    close(sockfd);\\n    printf(\\\"Server is offline...\\\\n\\\");\\n    return 0;\\n}\\n\"",
    "udp client": "\"/**\\n * @file\\n * @author [TheShubham99](https://github.com/TheShubham99)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Client side implementation of UDP client-server model\\n * @see client_server/udp_server.c\\n */\\n#ifdef _WIN32                            // if compiling for Windows\\n#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next\\n                                         // MSVC compiler versions\\n#include <winsock2.h>\\n#define close closesocket /**< map BSD name to Winsock */\\n#else                     // if not windows platform\\n#include <arpa/inet.h>\\n#include <netdb.h>\\n#include <netinet/in.h>\\n#include <sys/socket.h>\\n#include <sys/types.h>\\n#include <unistd.h>\\n#endif\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define PORT 8080    /**< port number to connect to */\\n#define MAXLINE 1024 /**< maximum characters per line */\\n\\n#ifdef _WIN32\\n/** Cleanup function will be automatically called on program exit */\\nvoid cleanup() { WSACleanup(); }\\n#endif\\n\\n/** Driver code */\\nint main()\\n{\\n#ifdef _WIN32\\n    // when using winsock2.h, startup required\\n    WSADATA wsData;\\n    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)\\n    {\\n        perror(\\\"WSA Startup error: \\\\n\\\");\\n        return 0;\\n    }\\n\\n    atexit(cleanup);  // register at-exit function\\n#endif\\n\\n    int sockfd;\\n    char buffer[MAXLINE];\\n    char *hello = \\\"Hello from client\\\";\\n    struct sockaddr_in servaddr;\\n\\n    // Creating socket file descriptor\\n    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\\n    {\\n        perror(\\\"socket creation failed\\\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    memset(&servaddr, 0, sizeof(servaddr));\\n\\n    // Filling server information\\n    servaddr.sin_family = AF_INET;\\n    servaddr.sin_port = htons(PORT);\\n    servaddr.sin_addr.s_addr = INADDR_ANY;\\n\\n    int n;\\n    unsigned int len;\\n\\n    sendto(sockfd, (const char *)hello, strlen(hello), 0,\\n           (const struct sockaddr *)&servaddr, sizeof(servaddr));\\n    printf(\\\"Hello message sent.\\\\n\\\");\\n\\n    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,\\n                 (struct sockaddr *)&servaddr, &len);\\n    buffer[n] = '\\\\0';\\n    printf(\\\"Server : %s\\\\n\\\", buffer);\\n\\n    close(sockfd);\\n    return 0;\\n}\\n\"",
    "udp server": "\"/**\\n * @file\\n * @author [TheShubham99](https://github.com/TheShubham99)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Server side implementation of UDP client-server model\\n * @see client_server/udp_client.c\\n */\\n#ifdef _WIN32                            // if compiling for Windows\\n#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next\\n                                         // MSVC compiler versions\\n#define close closesocket                /**< map BSD name to Winsock */\\n#include <winsock2.h>\\n#else  // if not windows platform\\n#include <arpa/inet.h>\\n#include <netdb.h>\\n#include <netinet/in.h>\\n#include <sys/socket.h>\\n#include <sys/types.h>\\n#include <unistd.h>\\n#endif\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define PORT 8080    /**< port number to connect to */\\n#define MAXLINE 1024 /**< maximum characters per line */\\n\\n#ifdef _WIN32\\n/** Cleanup function will be automatically called on program exit */\\nvoid cleanup() { WSACleanup(); }\\n#endif\\n\\n/** Driver code */\\nint main()\\n{\\n#ifdef _WIN32\\n    // when using winsock2.h, startup required\\n    WSADATA wsData;\\n    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)\\n    {\\n        perror(\\\"WSA Startup error: \\\\n\\\");\\n        return 0;\\n    }\\n\\n    atexit(cleanup);  // register at-exit function\\n#endif\\n\\n    int sockfd;\\n    char buffer[MAXLINE];\\n    char *hello = \\\"Hello from server\\\";\\n    struct sockaddr_in servaddr, cliaddr;\\n\\n    // Creating socket file descriptor\\n    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\\n    {\\n        perror(\\\"socket creation failed\\\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    memset(&servaddr, 0, sizeof(servaddr));\\n    memset(&cliaddr, 0, sizeof(cliaddr));\\n\\n    // Filling server information\\n    servaddr.sin_family = AF_INET;  // IPv4\\n    servaddr.sin_addr.s_addr = INADDR_ANY;\\n    servaddr.sin_port = htons(PORT);\\n\\n    // Bind the socket with the server address\\n    if (bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)\\n    {\\n        perror(\\\"bind failed\\\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    unsigned int len;\\n    int n;\\n    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,\\n                 (struct sockaddr *)&cliaddr, &len);\\n    buffer[n] = '\\\\0';\\n    printf(\\\"Client : %s\\\\n\\\", buffer);\\n    sendto(sockfd, (const char *)hello, strlen(hello), 0,\\n           (const struct sockaddr *)&cliaddr, len);\\n    printf(\\\"Hello message sent.\\\\n\\\");\\n\\n    close(sockfd);\\n\\n    return 0;\\n}\\n\"",
    "binary to decimal": "\"/**\\n * Modified 07/12/2017, Kyler Smith\\n *\\n */\\n\\n#include <stdio.h>\\n\\nint main()\\n{\\n    int remainder, number = 0, decimal_number = 0, temp = 1;\\n    printf(\\\"\\\\n Enter any binary number= \\\");\\n    scanf(\\\"%d\\\", &number);\\n\\n    // Iterate over the number until the end.\\n    while (number > 0)\\n    {\\n        remainder = number % 10;\\n        number = number / 10;\\n        decimal_number += remainder * temp;\\n        temp = temp * 2;  // used as power of 2\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", decimal_number);\\n}\\n\"",
    "binary to hexadecimal": "\"/*\\r\\n * C Program to Convert Binary to Hexadecimal\\r\\n */\\r\\n#include <stdio.h>\\r\\n\\r\\nint main()\\r\\n{\\r\\n    long int binary, hexa = 0, i = 1, remainder;\\r\\n\\r\\n    printf(\\\"Enter the binary number: \\\");\\r\\n    scanf(\\\"%ld\\\", &binary);\\r\\n    while (binary != 0)\\r\\n    {\\r\\n        remainder = binary % 10;\\r\\n        hexa = hexa + remainder * i;\\r\\n        i = i * 2;\\r\\n        binary = binary / 10;\\r\\n    }\\r\\n    printf(\\\"The equivalent hexadecimal value: %lX\\\", hexa);\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "binary to octal": "\"// Binary number to octal number conversion\\n#include <stdio.h>\\n\\n// Function that returns the last three digits\\nint three_digits(int n)\\n{\\n    int r, d = 0, p = 1;\\n\\n    for (int i = 0; i < 3; i++)\\n    {\\n        r = n % 10;\\n        d += r * p;\\n        p *= 10;\\n        n /= 10;\\n    }\\n    return d;\\n}\\n\\nint main(void)\\n{\\n    int binary_num, d = 0, base = 1, remainder, td, res = 0, ord = 1;\\n\\n    printf(\\\"Enter the binary no: \\\");\\n    scanf(\\\"%d\\\", &binary_num);\\n\\n    while (binary_num > 0)\\n    {\\n        if (binary_num >\\n            111)  // Checking if binary number is greater than three digits\\n            td = three_digits(binary_num);\\n\\n        else\\n            td = binary_num;\\n\\n        binary_num /= 1000;\\n\\n        d = 0, base = 1;\\n\\n        // Converting the last three digits to decimal\\n        while (td > 0)\\n        {\\n            remainder = td % 10;\\n            td /= 10;\\n            d += (base * remainder);\\n            base *= 2;\\n        }\\n\\n        res += d * ord;  // Calculating the octal value\\n        ord *= 10;\\n    }\\n\\n    printf(\\\"\\\\nOctal equivalent is: %d\\\", res);\\n    return 0;\\n}\\n\"",
    "c atoi str to integer": "\"/**\\n * \\\\file\\n * \\\\brief Recoding the original atoi function in stdlib.h\\n * \\\\author [Mohammed YMIK](https://github.com/medymik)W\\n * The function convert a string passed to an integer\\n */\\n#include <assert.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n/**\\n * the function take a string and return an integer\\n * \\\\param[out] str pointer to a char address\\n */\\nint c_atoi(const char *str)\\n{\\n    int i;\\n    int sign;\\n    long value;\\n    long prev;\\n\\n    i = 0;\\n    sign = 1;\\n    value = 0;\\n\\n    /* skipping the spaces */\\n    while (((str[i] <= 13 && str[i] >= 9) || str[i] == 32) && str[i] != '\\\\0')\\n        i++;\\n\\n    /* store the sign if it is negative sign */\\n    if (str[i] == '-')\\n\\t{\\n        sign = -1;\\n\\ti++;\\n\\t}\\n    else if (str[i] == '+')\\n\\t{\\n        sign = 1;\\n\\ti++;\\n\\t}\\n\\n    /* converting char by char to a numeric value */\\n    while (str[i] >= 48 && str[i] <= 57 && str[i] != '\\\\0')\\n    {\\n        prev = value;\\n        value = value * 10 + sign * (str[i] - '0');\\n\\n        /* managing the overflow */\\n        if (sign == 1 && prev > value)\\n            return (-1);\\n        else if (sign == -1 && prev < value)\\n            return (0);\\n        i++;\\n    }\\n    return (value);\\n}\\n\\n/**\\n * test the function implementation\\n */\\nvoid test_c_atoi()\\n{\\n    printf(\\\"<<<< TEST FUNCTION >>>>\\\\n\\\");\\n    assert(c_atoi(\\\"123\\\") == atoi(\\\"123\\\"));\\n    assert(c_atoi(\\\"-123\\\") == atoi(\\\"-123\\\"));\\n    assert(c_atoi(\\\"\\\") == atoi(\\\"\\\"));\\n    assert(c_atoi(\\\"-h23\\\") == atoi(\\\"-h23\\\"));\\n    assert(c_atoi(\\\"         23\\\") == atoi(\\\"         23\\\"));\\n    assert(c_atoi(\\\"999999999\\\") == atoi(\\\"999999999\\\"));\\n    printf(\\\"<<<< TEST DONE >>>>\\\\n\\\");\\n}\\n\\n/**\\n * the main function take one argument of type char*\\n * example : ./program 123\\n */\\nint main(int argc, char **argv)\\n{\\n    test_c_atoi();\\n\\n    if (argc == 2)\\n    {\\n        printf(\\\"Your number + 5 is %d\\\\n\\\", c_atoi(argv[1]) + 5);\\n        return (0);\\n    }\\n    printf(\\\"wrong number of parmeters\\\\n\\\");\\n    return (1);\\n}\\n\"",
    "decimal to any base": "\"/**\\n * @file\\n * @author [jucollet972](https://github.com/jucollet972)\\n * @brief [Decimal to any-base](http://codeofthedamned.com/index.php/number-base-conversion) is a C function wich convert positive decimal\\n * integer to any positive ascii base with the base's alphabet given in input and return it in a dynamically allocated string(recursive way)\\n */\\n\\n#include <stdio.h>   /// for IO operations\\n#include <string.h>  /// for strchr and strlen\\n#include <stdint.h>  /// for CPU arch's optimized int types\\n#include <stdbool.h> /// for boolean types\\n#include <assert.h>  /// for assert\\n#include <stdlib.h>  /// for malloc and free\\n\\n/**\\n * @brief Checking if alphabet is valid\\n * @param base alphabet inputed by user\\n * @return int64_t as success or not\\n */\\nbool isbad_alphabet(const char* alphabet) {\\n\\tuint64_t len = strlen(alphabet);\\n\\t\\n\\t/* Checking th lenght */\\t\\n\\tif (len < 2) {\\n\\t\\treturn true;\\n\\t}\\n\\t/* Browse the alphabet */\\n\\tfor (int i = 0; i < len ; i++) {\\n\\t\\t/* Searching for duplicates */ \\n\\t\\tif (strchr(alphabet + i + 1, alphabet[i]))\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\n/**\\n * @brief Calculate the final length of the converted number\\n * @param nb to convert\\n * @param base calculated from alphabet\\n * @return Converted nb string length \\n */\\nuint64_t converted_len(uint64_t nb, short base) {\\n\\t/* Counting the number of characters translated to the base*/\\n\\tif (nb > base - 1) {\\n\\t\\treturn (converted_len(nb/base, base) + 1);\\n\\t}\\n\\treturn 1;\\n}\\n\\n/**\\n * @brief Convert positive decimal integer into anybase recursively\\n * @param nb to convert\\n * @param alphabet inputed by user used for base convertion\\n * @param base calculated from alphabet\\n * @param converted string filled with the convertion's result\\n * @return void\\n */\\nvoid convertion(uint64_t nb, const char* alphabet, short base, char* converted) {\\n\\t/* Recursive convertion */\\n\\t*(converted) = *(alphabet + nb%base);\\n\\tif (nb > base - 1) {\\n\\t\\tconvertion(nb/base, alphabet, base, --converted);\\n\\t}\\n}\\n\\n/**\\n * @brief decimal_to_anybase ensure the validity of the parameters and convert any unsigned integers into any ascii positive base\\n * @param nb to convert\\n * @param base's alphabet\\n * @returns nb converted on success\\n * @returns NULL on error\\n */\\nchar* decimal_to_anybase(uint64_t nb, const char* alphabet) {\\n\\tchar* converted;\\n\\n\\t/* Verify that alphabet is valid */\\n\\tif (isbad_alphabet(alphabet)) {\\n\\t\\treturn NULL;\\n\\t}\\n\\t/* Convertion */\\n\\tuint64_t base = strlen(alphabet);\\n\\tuint64_t final_len = converted_len(nb, base);\\n\\tconverted = malloc(sizeof(char) * (final_len + 1));\\n\\tconverted[final_len] = 0;\\n\\tconvertion(nb, alphabet, base, converted + final_len - 1);\\n\\treturn converted;\\n}\\n\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test()\\n{\\n\\tchar* ret = NULL;\\n\\tchar* reference = NULL;\\n\\n\\t/* min dec*/\\n\\treference = \\\"0\\\";\\n\\tret = decimal_to_anybase(0, \\\"0123456789\\\");\\n\\tfor (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {\\n\\t\\tassert(ret[i] == reference[i]);\\n\\t}\\n\\tif (ret != NULL) {\\n\\t\\tfree(ret);\\n\\t}\\n\\t\\n\\t/* max dec*/\\n\\treference = \\\"18446744073709551615\\\";\\n\\tret = decimal_to_anybase(18446744073709551615, \\\"0123456789\\\");\\n\\tfor (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {\\n\\t\\tassert(ret[i] == reference[i]);\\n\\t}\\n\\tif (ret != NULL) {\\n\\t\\tfree(ret);\\n\\t}\\n\\t\\n\\t/* negative dec*/\\n\\treference = \\\"18446744073709551615\\\";\\n\\tret = decimal_to_anybase(-1, \\\"0123456789\\\");\\n\\tfor (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {\\n\\t\\tassert(ret[i] == reference[i]);\\n\\t}\\n\\tif (ret != NULL) {\\n\\t\\tfree(ret);\\n\\t}\\n\\n\\t/* bin */\\n\\treference = \\\"101010\\\";\\n\\tret = decimal_to_anybase(42, \\\"01\\\");\\n\\tfor (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {\\n\\t\\tassert(ret[i] == reference[i]);\\n\\t}\\n\\tif (ret != NULL) {\\n\\t\\tfree(ret);\\n\\t}\\n\\t\\n\\t/* octal */\\n\\treference = \\\"52\\\";\\n\\tret = decimal_to_anybase(42, \\\"01234567\\\");\\n\\tfor (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {\\n\\t\\tassert(ret[i] == reference[i]);\\n\\t}\\n\\tif (ret != NULL) {\\n\\t\\tfree(ret);\\n\\t}\\n\\t\\n\\t/* hexa */\\n\\treference = \\\"2A\\\";\\n\\tret = decimal_to_anybase(42, \\\"0123456789ABCDEF\\\");\\n\\tfor (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {\\n\\t\\tassert(ret[i] == reference[i]);\\n\\t}\\n\\tif (ret != NULL) {\\n\\t\\tfree(ret);\\n\\t}\\n\\tprintf(\\\"[+] All tests have successfully passed!\\\\n\\\");\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit \\n */\\nint main()\\n{\\n\\ttest(); // run self-test implementations\\n\\treturn 0;\\n}\\n\"",
    "decimal to binary": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAXBITS 100\\n\\nint main()\\n{\\n    // input of the user\\n    int inputNumber;\\n\\n    // for the remainder\\n    int re;\\n\\n    // contains the bits 0/1\\n    int bits[MAXBITS];\\n\\n    // for the loops\\n    int j;\\n    int i = 0;\\n\\n    printf(\\\"\\\\t\\\\tConverter decimal --> binary\\\\n\\\\n\\\");\\n\\n    // reads a decimal number from the user.\\n    printf(\\\"\\\\nenter a positive integer number: \\\");\\n    scanf(\\\"%d\\\", &inputNumber);\\n\\n    // make sure the input number is a positive integer.\\n    if (inputNumber < 0)\\n    {\\n        printf(\\\"only positive integers >= 0\\\\n\\\");\\n        return 1;\\n    }\\n\\n    // actual processing\\n    while (inputNumber > 0)\\n    {\\n        // computes the remainder by modulo 2\\n        re = inputNumber % 2;\\n\\n        // computes the quotient of division by 2\\n        inputNumber = inputNumber / 2;\\n\\n        bits[i] = re;\\n        i++;\\n    }\\n\\n    printf(\\\"\\\\n the number in binary is: \\\");\\n\\n    // iterates backwards over all bits\\n    for (j = i - 1; j >= 0; j--)\\n    {\\n        printf(\\\"%d\\\", bits[j]);\\n    }\\n\\n    // for the case the input number is 0\\n    if (i == 0)\\n    {\\n        printf(\\\"0\\\");\\n    }\\n\\n    return 0;\\n}\\n\"",
    "decimal to binary recursion": "\"/**\\n * @file\\n * @brief Convert decimal to binary using recursion algorithm\\n */\\n#include <assert.h>\\n\\n/**\\n * Decimal to binary using recursion algorithm.\\n * For example, if number = 5, the function returns the decimal integer 101.\\n * @param number positive integer number to convert\\n * @returns integer with digits representing binary value representation of\\n * number.\\n */\\nint decimal_to_binary(unsigned int number)\\n{\\n    return number == 0 ? 0 : number % 2 + 10 * decimal_to_binary(number / 2);\\n}\\n\\n/** Test function */\\nvoid test()\\n{\\n    const int sets[][2] = {\\n        {0, 0}, {1, 1}, {2, 10}, {3, 11}, {4, 100}, {6, 110}, {7, 111},\\n        /* add more data sets to test */\\n    };\\n\\n    for (int i = 0, size = sizeof(sets) / sizeof(sets[0]); i < size; ++i)\\n    {\\n        assert(decimal_to_binary(sets[i][0]) == sets[i][1]);\\n    }\\n}\\n\\n/** Driver Code */\\nint main()\\n{\\n    test();\\n    return 0;\\n}\\n\"",
    "decimal to hexa": "\"/*****Decimal to Hexadecimal conversion*******************/\\n#include <stdio.h>\\nvoid decimal2Hexadecimal(long num);\\n\\nint main()\\n{\\n    long decimalnum;\\n\\n    printf(\\\"Enter decimal number: \\\");\\n    scanf(\\\"%ld\\\", &decimalnum);\\n\\n    decimal2Hexadecimal(decimalnum);\\n\\n    return 0;\\n}\\n\\n/********function for convert decimal number to hexadecimal\\n * number****************/\\nvoid decimal2Hexadecimal(long num)\\n{\\n    long decimalnum = num;\\n    long quotient, remainder;\\n    int i, j = 0;\\n    char hexadecimalnum[100];\\n\\n    quotient = decimalnum;\\n\\n    while (quotient != 0)\\n    {\\n        remainder = quotient % 16;\\n        if (remainder < 10)\\n            hexadecimalnum[j++] = 48 + remainder;\\n\\n        else\\n            hexadecimalnum[j++] = 55 + remainder;\\n\\n        quotient = quotient / 16;\\n    }\\n\\n    // print the hexadecimal number\\n\\n    for (i = j; i >= 0; i--)\\n    {\\n        printf(\\\"%c\\\", hexadecimalnum[i]);\\n    }\\n\\n    printf(\\\"\\\\n\\\");\\n}\\n\"",
    "decimal to octal": "\"/*****Decimal to octal conversion*******************/\\n#include <stdio.h>\\nvoid decimal2Octal(long decimalnum);\\n\\nint main()\\n{\\n    long decimalnum;\\n\\n    printf(\\\"Enter the decimal number: \\\");\\n    scanf(\\\"%ld\\\", &decimalnum);\\n\\n    decimal2Octal(decimalnum);\\n\\n    return 0;\\n}\\n\\n/********function for convert decimal numbers to octal numbers************/\\nvoid decimal2Octal(long decimalnum)\\n{\\n    long remainder, quotient;\\n\\n    int octalNumber[100], i = 1, j;\\n    quotient = decimalnum;\\n\\n    while (quotient != 0)\\n    {\\n        octalNumber[i++] = quotient % 8;\\n\\n        quotient = quotient / 8;\\n    }\\n\\n    for (j = i - 1; j > 0; j--) printf(\\\"%d\\\", octalNumber[j]);\\n\\n    printf(\\\"\\\\n\\\");\\n}\\n\"",
    "decimal to octal recursion": "\"// Program to convert decimal number to octal (Using Reccursion)\\n// This program only works for integer decimals\\n// Created by Aromal Anil\\n\\n#include <stdio.h>\\nint decimal_to_octal(int decimal)\\n{\\n    if ((decimal < 8) && (decimal > 0))\\n    {\\n        return decimal;\\n    }\\n    else if (decimal == 0)\\n    {\\n        return 0;\\n    }\\n    else\\n    {\\n        return ((decimal_to_octal(decimal / 8) * 10) + decimal % 8);\\n    }\\n}\\nint main()\\n{\\n    int octalNumber, decimalNumber;\\n    printf(\\\"\\\\nEnter your decimal number : \\\");\\n    scanf(\\\"%d\\\", &decimalNumber);\\n    octalNumber = decimal_to_octal(decimalNumber);\\n    printf(\\\"\\\\nThe octal of %d is : %d\\\", decimalNumber, octalNumber);\\n    return 0;\\n}\\n\"",
    "hexadecimal to octal": "\"/* C program to convert Hexadecimal to Octal number system */\\n\\n#include <stdio.h>\\n\\nint main()\\n{\\n#define MAX_STR_LEN 17\\n    char hex[MAX_STR_LEN];\\n    long long octal, bin, place;\\n    int i = 0, rem, val;\\n\\n    /* Input hexadecimal number from user */\\n    printf(\\\"Enter any hexadecimal number: \\\");\\n    fgets(hex, MAX_STR_LEN, stdin);\\n\\n    octal = 0ll;\\n    bin = 0ll;\\n    place = 0ll;\\n\\n    /* Hexadecimal to binary conversion */\\n    for (i = 0; hex[i] != '\\\\0'; i++)\\n    {\\n        bin = bin * place;\\n\\n        switch (hex[i])\\n        {\\n        case '0':\\n            bin += 0;\\n            break;\\n        case '1':\\n            bin += 1;\\n            break;\\n        case '2':\\n            bin += 10;\\n            break;\\n        case '3':\\n            bin += 11;\\n            break;\\n        case '4':\\n            bin += 100;\\n            break;\\n        case '5':\\n            bin += 101;\\n            break;\\n        case '6':\\n            bin += 110;\\n            break;\\n        case '7':\\n            bin += 111;\\n            break;\\n        case '8':\\n            bin += 1000;\\n            break;\\n        case '9':\\n            bin += 1001;\\n            break;\\n        case 'a':\\n        case 'A':\\n            bin += 1010;\\n            break;\\n        case 'b':\\n        case 'B':\\n            bin += 1011;\\n            break;\\n        case 'c':\\n        case 'C':\\n            bin += 1100;\\n            break;\\n        case 'd':\\n        case 'D':\\n            bin += 1101;\\n            break;\\n        case 'e':\\n        case 'E':\\n            bin += 1110;\\n            break;\\n        case 'f':\\n        case 'F':\\n            bin += 1111;\\n            break;\\n        default:\\n            printf(\\\"Invalid hexadecimal input.\\\");\\n        }\\n\\n        place = 10000;\\n    }\\n\\n    place = 1;\\n\\n    /* Binary to octal conversion */\\n    while (bin > 0)\\n    {\\n        rem = bin % 1000;\\n\\n        switch (rem)\\n        {\\n        case 0:\\n            val = 0;\\n            break;\\n        case 1:\\n            val = 1;\\n            break;\\n        case 10:\\n            val = 2;\\n            break;\\n        case 11:\\n            val = 3;\\n            break;\\n        case 100:\\n            val = 4;\\n            break;\\n        case 101:\\n            val = 5;\\n            break;\\n        case 110:\\n            val = 6;\\n            break;\\n        case 111:\\n            val = 7;\\n            break;\\n        }\\n\\n        octal = (val * place) + octal;\\n        bin /= 1000;\\n\\n        place *= 10;\\n    }\\n\\n    printf(\\\"Hexadecimal number = %s\\\\n\\\", hex);\\n    printf(\\\"Octal number = %lld\\\", octal);\\n\\n    return 0;\\n}\\n\"",
    "hexadecimal to octal2": "\"/**\\n * @file\\n * @brief Convert hexadecimal number to octal number (with decimal intermediary)\\n * @details\\n * The input is valid from 0 to 0xFFFF_FFFF_FFFF_FFFF.\\n *\\n * At first, this program converts a hex string to an unsigned long long\\n * decimal, and then to an octal string.\\n *\\n * When there is an invalid character in input string, this program stops\\n * parsing and converts the string until that character.\\n *\\n * @see hexadecimal_to_octal.c\\n */\\n\\n#include <stdio.h>  /// for printf() and fgets()\\n#include <string.h> /// for memset()\\n\\n/**\\n * @brief Convert a hexadecimal number to octal number.\\n * @param hex Hexadecimal number to convert.\\n * @returns A pointer to the converted octal string.\\n */\\nconst char *hex_to_oct(const char *hex)\\n{\\n#define MAX_OCT_STR_LEN 23 /* 17_7777_7777_7777_7777_7777 */\\n    static char octal[MAX_OCT_STR_LEN];\\n    memset(octal, '\\\\0', MAX_OCT_STR_LEN); // Initialize as NULL string\\n\\n    unsigned long long decimal = 0;\\n    int i = 0;\\n    int len;\\n\\n    if (hex == NULL)\\n    {\\n        // Return an empty string\\n        return octal;\\n    }\\n\\n    /* Hexadecimal to decimal conversion */\\n    while (*hex != '\\\\n' && *hex != '\\\\0')\\n    {\\n        char ch = *hex;\\n\\n        if (ch >= '0' && ch <= '9')\\n        {\\n            ch -= '0';\\n        }\\n        else if (ch >= 'a' && ch <= 'f')\\n        {\\n            ch = ch - 'a' + 10;\\n        }\\n        else if (ch >= 'A' && ch <= 'F')\\n        {\\n            ch = ch - 'A' + 10;\\n        }\\n        else\\n        {\\n            printf(\\\"Invalid hexadecimal input: %c\\\\n\\\", ch);\\n            break;\\n        }\\n\\n        decimal *= 16;\\n        decimal += ch;\\n        hex++;\\n    }\\n\\n    /* Decimal to octal conversion */\\n    if (decimal == 0)\\n    {\\n        octal[0] = '0';\\n        len = 1;\\n    }\\n    else\\n    {\\n        i = 0;\\n        while (decimal > 0)\\n        {\\n            octal[i] = '0' + decimal % 8;\\n            i++;\\n            decimal /= 8;\\n        }\\n\\n        len = i;\\n    }\\n\\n    octal[len] = '\\\\0';\\n\\n    /* Reverse the octal string */\\n    for (i = 0; i < len / 2; i++)\\n    {\\n        char tmp = octal[i];\\n        octal[i] = octal[len - i - 1];\\n        octal[len - i - 1] = tmp;\\n    }\\n\\n    return octal;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n#define MAX_HEX_STR_LEN 17 /* FFFF_FFFF_FFFF_FFFF */\\n    char hex[MAX_HEX_STR_LEN];\\n\\n    /* Input hexadecimal number from user */\\n    printf(\\\"Enter any hexadecimal number: \\\");\\n    fgets(hex, MAX_HEX_STR_LEN, stdin);\\n\\n    const char *octal = hex_to_oct(hex);\\n\\n    printf(\\\"Hexadecimal number = %s\\\\n\\\", hex);\\n    printf(\\\"Octal number = %s\\\\n\\\", octal);\\n\\n    return 0;\\n}\\n\"",
    "infix to postfix": "\"/**\\n * @file\\n * @brief [Infix to\\n * Postfix](https://condor.depaul.edu/ichu/csc415/notes/notes9/Infix.htm)\\n * Expression Conversion\\n * @details Convert Infixed expressions to Postfix expression.\\n * @author [Harsh Karande](https://github.com/harshcut)\\n */\\n\\n// include header files\\n#include <stdio.h>  /// for printf() and scanf()\\n\\n/**\\n * @brief a globally declared structure with an array and an variable that\\n * points to the topmost index of the array\\n */\\nstruct Stack\\n{\\n    char arr[10];  ///> static array of integers\\n    int tos;       ///> stores index on topmost element in stack\\n};\\n\\n// function headers\\nvoid push(struct Stack *p, char ch);  // pust element in stack\\nchar pop(struct Stack *p);            // pop topmost element from the stack\\nint isOprnd(char ch);                 // check if element is operand or not\\nint isEmpty(struct Stack s);          // check if stack is empty\\nint getPrecedence (char op1, char op2);        // check operator precedence\\nvoid convert(char infix[],\\n             char postfix[]);  // convert infix to postfix expression\\n\\n/**\\n * @brief main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    char infix[20], postfix[20];  // initialize empty infix and postfix array\\n\\n    printf(\\\"Enter infix expression: \\\");  // example : A+B-C*D/E$F\\n    scanf(\\\"%s\\\", infix);                  // get values for infix array\\n\\n    convert(infix, postfix);\\n    printf(\\\"Postfix expression is %s\\\", postfix);  // output : AB+CD*EF$/-\\n\\n    return 0;\\n}\\n\\n/**\\n * @brief push function\\n * @param *p : used as a pointer variable of stack\\n * @param x : char to be pushed in stack\\n * @returns void\\n */\\nvoid push(struct Stack *p, char x)\\n{\\n    if (p->tos == 9)  // check if stack has reached its max limit\\n    {\\n        printf(\\\"Stack Overflow!\\\");\\n        return;\\n    }\\n\\n    p->tos += 1;         // increment tos\\n    p->arr[p->tos] = x;  // assign char x to index of stack pointed by tos\\n}\\n\\n/**\\n * @brief pop function\\n * @param *p : used as a pointer variable of stack\\n * @returns x or \\\\0 on exit\\n */\\nchar pop(struct Stack *p)\\n{\\n    char x;\\n\\n    if (p->tos == -1)\\n    {\\n        printf(\\\"Stack Underflow!\\\");\\n        return '\\\\0';\\n    }\\n\\n    x = p->arr[p->tos];  // assign the value of stack at index tos to x\\n    p->tos -= 1;         // decrement tos\\n\\n    return x;\\n}\\n\\n/**\\n * @brief isOprnd function\\n * @param ch : this is the element from the infix array\\n * @returns 1 or 0 on exit\\n */\\nint isOprnd(char ch)\\n{\\n    if ((ch >= 65 && ch <= 90) ||\\n        (ch >= 97 && ch <= 122) ||  // check if ch is an operator or\\n        (ch >= 48 && ch <= 57))     // operand using ASCII values\\n    {\\n        return 1;  // return for true result\\n    }\\n    else\\n    {\\n        return 0;  // return for false result\\n    }\\n}\\n\\n/**\\n * @brief isEmpty function\\n * @param s : it is the object reference of stack\\n * @returns 1 or 0 on exit\\n */\\nint isEmpty(struct Stack s)\\n{\\n    if (s.tos == -1)  // check if stack is empty\\n    {\\n        return 1;  // return for true result\\n    }\\n    else\\n    {\\n        return 0;  // return for false result\\n    }\\n}\\n\\n/**\\n * @brief convert function\\n * @param infix[] : infix array provided by user\\n * @param postfix[] : empty array to be given to convert()\\n * @returns postfixed expresion or \\\\0 on exit\\n */\\nvoid convert(char infix[], char postfix[])\\n{\\n    struct Stack s;  // initialze object reference of stack\\n    s.tos = -1;      // initalize the tos\\n\\n    int i, j = 0, pr;\\n    char ch, temp;\\n\\n    for (i = 0; infix[i] != '\\\\0'; i++)\\n    {\\n        ch = infix[i];\\n\\n        if (isOprnd(ch) == 1)  // check if char is operand or operator\\n        {\\n            postfix[j] = ch;  // assign ch to postfix array with index j\\n            j++;              // incement j\\n        }\\n        else\\n        {\\n            if (ch == '(')\\n            {\\n                push(&s, ch);\\n            }\\n            else\\n            {\\n                if (ch == ')')\\n                {\\n                    while ((temp = pop(&s)) != '(')\\n                    {\\n                        postfix[j] = temp;\\n                        j++;\\n                    }\\n                }\\n                else\\n                {\\n                    while (isEmpty(s) == 0)  // check if stack is empty\\n                    {\\n                        pr = getPrecedence (ch,\\n                                   s.arr[s.tos]);  // check operator precedence\\n\\n                        if (pr == 1)\\n                        {\\n                            break;  // if ch has a greater precedence than\\n                                    // s.arr[s.top]\\n                        }\\n\\n                        postfix[j] = pop(&s);\\n                        j++;\\n                    }\\n\\n                    push(&s, ch);  // push ch to stack\\n                }\\n            }\\n        }\\n    }\\n\\n    while (isEmpty(s) == 0)  // check if stack is empty\\n    {\\n        postfix[j] = pop(&s);\\n        j++;\\n    }\\n\\n    postfix[j] = '\\\\0';\\n}\\n\\n/**\\n * @brief getPrecedence function returns the precedence after comparing two operators passed as parameter.\\n * @param op1 : first operator\\n * @param op2 : second operator\\n * @returns 1 or 0 on exit\\n */\\nint getPrecedence (char op1, char op2)\\n{\\n    if (op2 == '$')\\n    {\\n        return 0;\\n    }\\n    else if (op1 == '$')\\n    {\\n        return 1;\\n    }\\n    else if (op2 == '*' || op2 == '/' || op2 == '%')\\n    {\\n        return 0;\\n    }\\n    else if (op1 == '*' || op1 == '/' || op1 == '%')\\n    {\\n        return 1;\\n    }\\n    else if (op2 == '+' || op2 == '-')\\n    {\\n        return 0;\\n    }\\n    else\\n    {\\n        return 1;\\n    }\\n}\\n\"",
    "infix to postfix 2": "\"/**\\n * @file\\n * @brief [Infix to Postfix converter](https://www.includehelp.com/c/infix-to-postfix-conversion-using-stack-with-c-program.aspx) implementation\\n * @details\\n * The input infix expression is of type string upto 24 characters.\\n * Supported operations- '+', '-', '/', '*', '%'\\n * @author [Kumar Yash](https://github.com/kumaryash18)\\n * @see infix_to_postfix.c\\n */\\n \\n#include <stdio.h>\\t/// for IO operations\\n#include <string.h>\\t/// for strlen(), strcmp()\\n#include <ctype.h>\\t/// for isalnum()\\n#include <stdlib.h>\\t/// for exit()\\n#include <stdint.h>\\t/// for uint16_t, int16_t\\n#include <assert.h>\\t/// for assert\\n\\n/**\\n * @brief array implementation of stack using structure\\n */\\nstruct Stack {\\n\\tchar stack[10];\\t\\t///< array stack\\n\\tint top;\\t\\t///< stores index of the top element\\n};\\nstruct Stack st;\\t\\t///< global declaration of stack st\\n\\n/**\\n * @brief Function to push on the stack\\n * @param opd character to be pushed in the stack\\n * @returns void\\n */\\nvoid push(char opd) {\\n\\tif(st.top == 9)\\t{\\t\\t// overflow condition\\n\\t\\tprintf(\\\"Stack overflow...\\\");\\n\\t\\texit(1);\\n\\t}\\n\\tst.top++;\\n\\tst.stack[st.top] = opd;\\n}\\n\\n/**\\n * @brief Function to pop from the stack\\n * @returns popped character\\n */\\nchar pop() {\\n\\tchar item;\\t\\t\\t\\t///< to store the popped value to be returned\\n\\tif(st.top == -1) {\\t\\t// underflow condition\\n\\t\\tprintf(\\\"Stack underflow...\\\");\\n\\t\\texit(1);\\n\\t}\\n\\titem = st.stack[st.top];\\n\\tst.top--;\\n\\treturn item;\\n}\\n\\n/**\\n * @brief Function to check whether the stack is empty or not\\n * @returns 1 if the stack IS empty\\n * @returns 0 if the stack is NOT empty\\n */\\nuint16_t isEmpty() {\\n\\tif(st.top == -1) {\\n\\t\\treturn 1;\\n\\t}\\n\\treturn 0;\\n}\\n\\n/**\\n * @brief Function to get top of the stack\\n * @returns top of stack\\n */\\nchar Top() {\\n\\treturn st.stack[st.top];\\n}\\n\\n/**\\n * @brief Function to check priority of operators\\n * @param opr operator whose priority is to be checked\\n * @returns 0 if operator is '+' or '-'\\n * @returns 1 if operator is '/' or '*' or '%'\\n * @returns -1 otherwise\\n */\\nint16_t priority(char opr) {\\n\\tif(opr == '+' || opr == '-') {\\n\\t\\treturn 0;\\n\\t}\\n\\telse if(opr == '/' || opr == '*' || opr == '%') {\\n\\t\\treturn 1;\\n\\t}\\n\\telse {\\n\\t\\treturn -1;\\n\\t}\\n}\\n\\n/**\\n * @brief Function to convert infix expression to postfix expression\\n * @param inf the input infix expression\\n * @returns output postfix expression\\n */\\nchar *convert(char inf[]) {\\n\\tstatic char post[25];\\t\\t\\t\\t///< to store the postfix expression\\n\\tint i;\\t\\t\\t\\t\\t\\t\\t\\t///< loop iterator\\n\\tint j = 0;\\t\\t\\t\\t\\t\\t\\t///< keeps track of end of postfix string\\n\\tfor(i = 0; i < strlen(inf); i++) {\\n\\t\\tif(isalnum(inf[i]))\\t{\\t\\t\\t// if scanned element is an alphabet or number\\n\\t\\t\\tpost[j] = inf[i];\\t\\t\\t// append in postfix expression\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\telse if(inf[i] == '(') {\\t\\t// if scanned element is opening parentheses\\n\\t\\t\\tpush(inf[i]);\\t\\t\\t\\t// push on stack.\\n\\t\\t}\\n\\t\\telse if(inf[i] == ')') {\\t\\t// if scanned element is closing parentheses,\\n\\t\\t\\twhile(Top() != '(') {\\t\\t// pop elements from stack and append in postfix expression\\n\\t\\t\\t\\tpost[j] = pop();\\t\\t// until opening parentheses becomes top.\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tpop();\\t\\t\\t\\t\\t\\t// pop opening parentheses\\n\\t\\t}\\n\\t\\telse {\\t\\t\\t\\t\\t\\t\\t// if scanned element is an operator\\n\\t\\t\\twhile( (!isEmpty()) && (priority(inf[i]) <= priority(Top())) ) {\\t// pop and append until stack becomes\\n\\t\\t\\t\\tpost[j] = pop();\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// empty or priority of top operator\\n\\t\\t\\t\\tj++;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// becomes smaller than scanned operator\\n\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// '(' has priority -1\\n\\t\\t\\tpush(inf[i]);\\t\\t\\t\\t// push the scanned operator\\n\\t\\t}\\n\\t}\\n\\twhile(!isEmpty()) {\\t\\t\\t\\t\\t// pop and append residual operators from stack\\n\\t\\tpost[j] = pop();\\n\\t\\tj++;\\n\\t}\\n\\tpost[j] = '\\\\0';\\t\\t\\t\\t\\t\\t// end postfix string with null character\\n\\treturn post;\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    /* check sample test case\\n\\t   input- \\\"(A/(B-C)*D+E)\\\"\\n\\t   expected output- \\\"ABC-/D*E+\\\"\\n\\t */\\n\\tassert(strcmp(convert(\\\"(A/(B-C)*D+E)\\\"), \\\"ABC-/D*E+\\\") == 0); \\t\\t\\t/// this ensures that the algorithm works as expected\\n\\t/* input- \\\"7-(2*3+5)*(8-4/2)\\\"\\n\\t   expected output- \\\"723*5+842/-*-\\\"\\n\\t */\\n\\tassert(strcmp(convert(\\\"7-(2*3+5)*(8-4/2)\\\"), \\\"723*5+842/-*-\\\") == 0); \\t\\t\\t/// this ensures that the algorithm works as expected\\n\\tprintf(\\\"All tests have successfully passed!\\\\n\\\");\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n\\tst.top = -1;\\t\\t\\t/// initialize\\n\\ttest();\\t\\t\\t\\t/// run self-test implementations\\n\\tchar inf[25];\\t\\t\\t///< to store input infix expression\\n\\tprintf(\\\"Enter infix: \\\");\\n\\tscanf(\\\"%s\\\", inf);\\n\\tprintf(\\\"Postfix: %s\\\", convert(inf));\\n\\treturn 0;\\n}\\n\"",
    "int to string": "\"/**\\n * @file\\n * @brief Convert a positive integer to string (non-standard function)\\n * representation.\\n */\\n#include <assert.h>\\n#include <inttypes.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <time.h>\\n\\n/**\\n * Converts an integer value to a null-terminated string using the specified\\n * base and stores the result in the array given by str parameter.\\n * @param value Value to be converted to a string.\\n * @param dest pointer to array in memory to store the resulting null-terminated\\n * string.\\n * @param base Numerical base used to represent the value as a string, between 2\\n * and 16, where 10 means decimal base, 16 hexadecimal, 8 octal, and 2 binary.\\n * @returns A pointer to the resulting null-terminated string, same as parameter\\n * str.\\n * @note The destination array must be pre-allocated by the calling function.\\n */\\nchar *int_to_string(uint16_t value, char *dest, int base)\\n{\\n    const char hex_table[] = {'0', '1', '2', '3', '4', '5', '6', '7',\\n                              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\\n\\n    int len = 0;\\n    do\\n    {\\n        dest[len++] = hex_table[value % base];\\n        value /= base;\\n    } while (value != 0);\\n\\n    /* reverse characters */\\n    for (int i = 0, limit = len / 2; i < limit; ++i)\\n    {\\n        char t = dest[i];\\n        dest[i] = dest[len - 1 - i];\\n        dest[len - 1 - i] = t;\\n    }\\n    dest[len] = '\\\\0';\\n    return dest;\\n}\\n\\n/** Test function\\n * @returns `void`\\n */\\nstatic void test()\\n{\\n    const int MAX_SIZE = 100;\\n    char *str1 = (char *)calloc(sizeof(char), MAX_SIZE);\\n    char *str2 = (char *)calloc(sizeof(char), MAX_SIZE);\\n\\n    for (int i = 1; i <= 100; ++i) /* test 100 random numbers */\\n    {\\n        /* Generate value from 0 to 100 */\\n        int value = rand() % 100;\\n\\n        // assert(strcmp(itoa(value, str1, 2), int_to_string(value, str2, 2)) ==\\n        //        0);\\n        snprintf(str1, MAX_SIZE, \\\"%o\\\", value);  //* standard C - to octal */\\n        assert(strcmp(str1, int_to_string(value, str2, 8)) == 0);\\n        snprintf(str1, MAX_SIZE, \\\"%d\\\", value); /* standard C - to decimal */\\n        assert(strcmp(str1, int_to_string(value, str2, 10)) == 0);\\n        snprintf(str1, MAX_SIZE, \\\"%x\\\", value); /* standard C - to hexadecimal */\\n        assert(strcmp(str1, int_to_string(value, str2, 16)) == 0);\\n    }\\n\\n    free(str1);\\n    free(str2);\\n}\\n\\n/** Driver Code */\\nint main()\\n{\\n    /* Intializes random number generator */\\n    srand(time(NULL));\\n    test();\\n    return 0;\\n}\\n\"",
    "octal to binary": "\"/**\\n * @brief Octal to binay conversion by scanning user input\\n * @details\\n * The octalTobinary function take the octal number as long\\n * return a long binary nuber after conversion\\n * @author [Vishnu P](https://github.com/vishnu0pothan)\\n */\\n#include <math.h>\\n#include <stdio.h>\\n\\n/**\\n * @brief Converet  octal number to binary\\n * @param octalnum octal value that need to convert\\n * @returns A binary number after conversion\\n */\\nlong octalToBinary(int octalnum)\\n{\\n    int decimalnum = 0, i = 0;\\n    long binarynum = 0;\\n\\n    /* This loop converts octal number \\\"octalnum\\\" to the\\n     * decimal number \\\"decimalnum\\\"\\n     */\\n    while (octalnum != 0)\\n    {\\n        decimalnum = decimalnum + (octalnum % 10) * pow(8, i);\\n        i++;\\n        octalnum = octalnum / 10;\\n    }\\n\\n    // i is re-initialized\\n    i = 1;\\n\\n    /* This loop converts the decimal number \\\"decimalnum\\\" to the binary\\n     * number \\\"binarynum\\\"\\n     */\\n    while (decimalnum != 0)\\n    {\\n        binarynum = binarynum + (long)(decimalnum % 2) * i;\\n        decimalnum = decimalnum / 2;\\n        i = i * 10;\\n    }\\n\\n    // Returning the binary number that we got from octal number\\n    return binarynum;\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    int octalnum;\\n\\n    printf(\\\"Enter an octal number: \\\");\\n    scanf(\\\"%d\\\", &octalnum);\\n\\n    // Calling the function octaltoBinary\\n    printf(\\\"Equivalent binary number is: %ld\\\", octalToBinary(octalnum));\\n    return 0;\\n}\\n\"",
    "octal to decimal": "\"#include <math.h>\\n#include <stdio.h>\\n\\n// Converts octal number to decimal\\nint convertValue(int num, int i) { return num * pow(8, i); }\\n\\nlong long toDecimal(int octal_value)\\n{\\n    int decimal_value = 0, i = 0;\\n\\n    while (octal_value)\\n    {\\n        // Extracts right-most digit and then multiplies by 8^i\\n        decimal_value += convertValue(octal_value % 10, i++);\\n\\n        // Shift right in base 10\\n        octal_value /= 10;\\n    }\\n\\n    return decimal_value;\\n}\\n\\nint main()\\n{\\n    printf(\\\"Enter octal value: \\\");\\n\\n    int octal_value;\\n\\n    scanf(\\\"%d\\\", &octal_value);\\n\\n    long long result = toDecimal(octal_value);\\n\\n    printf(\\\"%d in decimal is %lld\\\\n\\\", octal_value, result);\\n\\n    return 0;\\n}\\n\"",
    "octal to hexadecimal": "\"/**\\n * @file\\n * @brief Octal to hexadecimal conversion by scanning user input\\n * @details\\n * The octalToHexadecimal function take the octal number as long\\n * return a string hexadecimal value after conversion\\n * @author [Rachit Bhalla](https://github.com/rachitbhalla)\\n */\\n#include <assert.h> // for assert\\n#include <math.h> // for pow function\\n#include <stdio.h> // for scanf and printf functions\\n#include <stdlib.h> // for malloc and free functions\\n#include <string.h> // for strcmp function\\n\\n/**\\n * @brief Convert octal number to decimal number\\n * @param octalValue is the octal number that needs to be converted\\n * @returns a decimal number after conversion\\n */\\nlong octalToDecimal(long octalValue){\\n    long decimalValue = 0;\\n    int i = 0;\\n    while (octalValue) {\\n        // Extracts right-most digit, multiplies it with 8^i, and increment i by 1\\n        decimalValue += (long)(octalValue % 10) * pow(8, i++);\\n        // Shift right in base 10\\n        octalValue /= 10;\\n    }\\n    return decimalValue;\\n}\\n\\n/**\\n * @brief Convert octal number to hexadecimal number\\n * dynamically allocated memory needs to be freed by the calling the function free\\n * @param octalValue is the octal number that needs to be converted\\n * @returns a hexadecimal value as a string after conversion\\n */\\nchar *octalToHexadecimal(long octalValue){\\n    char *hexadecimalValue = malloc(256 * sizeof(char));\\n    sprintf(hexadecimalValue, \\\"%lX\\\", octalToDecimal(octalValue));\\n    return hexadecimalValue;\\n}\\n\\n/**\\n * @brief Test function\\n * @returns void\\n */\\nstatic void test() {\\n    /* test that hexadecimal value of octal number 213 is 8B */\\n    assert(strcmp(octalToHexadecimal(213), \\\"8B\\\") == 0);\\n\\n    /* test that hexadecimal value of octal number 174 is 7C */\\n    assert(strcmp(octalToHexadecimal(174), \\\"7C\\\") == 0);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    // execute the tests\\n    test();\\n\\n    // get the value of octal number as input\\n    int octalValue;\\n    printf(\\\"Enter an octal number: \\\");\\n    scanf(\\\"%d\\\", &octalValue);\\n\\n    // call the function octalToHexadecimal and print the hexadecimal value\\n    char *hexadecimalValue = octalToHexadecimal(octalValue);\\n    printf(\\\"Equivalent hexadecimal number is: %s\\\", hexadecimalValue);\\n\\n    // free the memory allocated dynamically in function octalToHexadecimal\\n    free(hexadecimalValue);\\n\\n    // return 0 and exit\\n    return 0;\\n}\\n\"",
    "to decimal": "\"/*\\n * convert from any base to decimal\\n */\\n\\n#include <ctype.h>\\n#include <stdio.h>\\n\\nint main(void)\\n{\\n    int base, i, j;\\n    char number[100];\\n    unsigned long decimal = 0;\\n\\n    printf(\\\"Enter the base: \\\");\\n    scanf(\\\"%d\\\", &base);\\n    printf(\\\"Enter the number: \\\");\\n    scanf(\\\"%s\\\", &number[0]);\\n\\n    for (i = 0; number[i] != '\\\\0'; i++)\\n    {\\n        if (isdigit(number[i]))\\n            number[i] -= '0';\\n        else if (isupper(number[i]))\\n            number[i] -= 'A' - 10;\\n        else if (islower(number[i]))\\n            number[i] -= 'a' - 10;\\n        else\\n            number[i] = base + 1;\\n\\n        if (number[i] >= base)\\n        {\\n            printf(\\\"invalid number\\\\n\\\");\\n            return 0;\\n        }\\n    }\\n\\n    for (j = 0; j < i; j++)\\n    {\\n        decimal *= base;\\n        decimal += number[j];\\n    }\\n\\n    printf(\\\"%lu\\\\n\\\", decimal);\\n}\\n\"",
    "stack": "\"/**\\n * Kyler Smith, 2017\\n * Stack data structure implementation.\\n */\\n\\n////////////////////////////////////////////////////////////////////////////////\\n// INCLUDES\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n////////////////////////////////////////////////////////////////////////////////\\n// MACROS: CONSTANTS\\n\\n////////////////////////////////////////////////////////////////////////////////\\n// DATA STRUCTURES\\n/**\\n * creating a stucture with 'data'(type:int), two pointers 'next','pre' (type: struct node) .\\n */\\nstruct node\\n{\\n    int data;\\n    struct node *next;\\n    struct node *pre;\\n} * head, *tmp;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n// GLOBAL VARIABLES\\nint count = 0;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n// FUNCTION PROTOTYPES\\nvoid create();\\nvoid push(int x);\\nint pop();\\nint peek();\\nint size();\\nint isEmpty();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n// MAIN ENTRY POINT\\n\\nint main(int argc, char const *argv[])\\n{\\n    int x, y, z;\\n\\n    create();\\n    push(4);\\n    x = pop();\\n    // 4. Count: 0. Empty: 1.\\n    printf(\\\"%d.\\\\t\\\\tCount: %d.\\\\tEmpty: %d.\\\\n\\\", x, size(), isEmpty());\\n\\n    push(1);\\n    push(2);\\n    push(3);\\n    x = pop();\\n    y = pop();\\n    // 3, 2. Count: 1. Empty: 0;\\n    printf(\\\"%d, %d.\\\\t\\\\tCount: %d.\\\\tEmpty: %d.\\\\n\\\", x, y, size(), isEmpty());\\n    pop();  // Empty the stack.\\n\\n    push(5);\\n    push(6);\\n    x = peek();\\n    push(7);\\n    y = pop();\\n    push(8);\\n    z = pop();\\n    // 1, 6, 7, 8. Count: 2. Empty: 0.\\n    printf(\\\"%d, %d, %d.\\\\tCount: %d.\\\\tEmpty: %d.\\\\n\\\", x, y, z, size(), isEmpty());\\n\\n    return 0;\\n}\\n\\n/**\\n * Initialize the stack to NULL.\\n */\\nvoid create() { head = NULL; }\\n\\n/**\\n * Push data onto the stack.\\n */\\nvoid push(int x)\\n{\\n    if (head == NULL)\\n    {\\n        head = (struct node *)malloc(1 * sizeof(struct node));\\n        head->next = NULL;\\n        head->pre = NULL;\\n        head->data = x;\\n    }\\n    else\\n    {\\n        tmp = (struct node *)malloc(1 * sizeof(struct node));\\n        tmp->data = x;\\n        tmp->next = NULL;\\n        tmp->pre = head;\\n        head->next = tmp;\\n        head = tmp;\\n    }\\n    ++count;\\n}\\n\\n/**\\n * Pop data from the stack\\n */\\nint pop()\\n{\\n    int returnData;\\n    if (head == NULL)\\n    {\\n        printf(\\\"ERROR: Pop from empty stack.\\\\n\\\");\\n        exit(1);\\n    }\\n    else\\n    {\\n        returnData = head->data;\\n\\n        if (head->pre == NULL)\\n        {\\n            free(head);\\n            head = NULL;\\n        }\\n        else\\n        {\\n            head = head->pre;\\n            free(head->next);\\n        }\\n    }\\n    --count;\\n    return returnData;\\n}\\n\\n/**\\n * Returns the next value to be popped.\\n */\\nint peek()\\n{\\n    if (head != NULL)\\n        return head->data;\\n    else\\n    {\\n        printf(\\\"ERROR: Peeking from empty stack.\\\");\\n        exit(1);\\n    }\\n}\\n\\n/**\\n * Returns the size of the stack.\\n */\\nint size() { return count; }\\n\\n/**\\n * Returns 1 if stack is empty, returns 0 if not empty.\\n */\\nint isEmpty()\\n{\\n    if (count == 0)\\n        return 1;\\n    return 0;\\n}\\n\"",
    "malloc dbg": "\"/**\\r\\n * @file\\r\\n * @brief Header file that contains macros used to replace malloc/calloc and free.\\r\\n * @details\\r\\n * Macros malloc, calloc and free respectively calls malloc_dbg, calloc_dbg and free_dbg.\\r\\n * malloc_dbg and calloc_dbg allocates memory using the \\\"real\\\" malloc and calloc and store\\r\\n * the pointer returned (with additional informations) in a linked list.\\r\\n * Thanks to this linked list, it is possible to check memory leaks.\\r\\n * @author [tinouduart33](https://github.com/tinouduart33)\\r\\n * @see malloc_dbg.c\\r\\n */\\r\\n\\r\\n#ifndef MALLOC_DBG_H\\r\\n#define MALLOC_DBG_H\\r\\n\\r\\n /** This macro replace the standard malloc function with malloc_dbg.\\r\\n  * */\\r\\n#define malloc(bytes) malloc_dbg(bytes, __LINE__, __FILE__, __FUNCTION__)\\r\\n\\r\\n  /** This macro replace the standard calloc function with calloc_dbg.\\r\\n   * */\\r\\n#define calloc(elemCount, elemSize) calloc_dbg(elemCount, elemSize, __LINE__, __FILE__, __FUNCTION__)\\r\\n\\r\\n   /** This macro replace the standard free function with free_dbg.\\r\\n\\t* */\\r\\n#define free(ptr) free_dbg(ptr)\\r\\n\\r\\nvoid* malloc_dbg(size_t bytes, int line, const char* filename, const char* functionName);\\r\\n\\r\\nvoid* calloc_dbg(size_t elementCount, size_t elementSize, int line, const char* filename, const char* functionName);\\r\\n\\r\\nvoid free_dbg(void* ptrToFree);\\r\\n\\r\\nvoid printLeaks(void);\\r\\n\\r\\n#endif /* MALLOC_DBG_H */\\r\\n\"",
    "min printf": "\"/**\\n * @file\\n * @brief Implementation of a [function](https://www.geeksforgeeks.org/variable-length-argument-c) similar to `printf`\\n * @details\\n * `printf` statement rewritten (as `min_printf`) in C without using the `stdio.h` library \\n * Syntax of `min_printf` is same as `printf`\\n * Currently min_printf handles:\\n * \\tIntegers, Doubles, floats, characters and strings\\n * The format specifiers and escape sequence is the same as for `printf`\\n * User can also specify the width and precision if required, just like in the case of `printf`\\n * How to use it:\\n * \\t- First include min_printf.h in your code\\n * \\t- Then type `min_printf()`, and pass required parameters to it\\n * \\t- As already specified, it's syntax is same as printf \\n * @author [Jaskarn Singh](https://github.com/Jaskarn7)\\n*/\\n\\n#ifndef MIN_PRINTF_H\\n#define MIN_PRINTF_H\\n\\n#include <stdlib.h> /// for `malloc` and `free` functions\\n#include <unistd.h> /// for `write` function\\n#include <stdarg.h> /// for `va_start` and `va_arg` functions\\n\\n#define INT_MAX_LENGTH 10       /// used as standard length of string to store integers\\n#define PRECISION_FOR_FLOAT 8   /// default precision for float or double if not specified\\n\\n/**\\n * @brief struct used to store character in certain times\\n*/\\ntypedef struct buffer {\\n\\tchar buffr_char; // Character will be stored in this variable\\n\\tint buf_size; // Checks if character is present in buffr_char or not, 0 if no and 1 if yes\\n} Buffer;\\n\\n/**\\n * @details \\n * This function return ten to the power a(The parameter specified to it) like:\\n * \\t\\tif the parameter specified is 4 i.e. -> power_of_ten(4) is called then\\n * \\t\\tthis function will return ten to the power four (10000);\\n * @param a The power of ten which is to be returned\\n * @return Ten to the power a\\n */\\nint power_of_ten(int a)\\n{\\n\\tint n = 1; ///< This number will be returned as ten to power of a\\n\\tfor (int i = 1; i <= a; ++i)\\n\\t\\tn *= 10 ;\\n\\treturn n;\\n}\\n\\n/**\\n * @brief Checks if a character is a number\\n * @param c character to be checked if it's a number or not\\n * @return `true`(1) if the character is a number \\n * @return `false`(0) if the character is NOT a number\\n*/\\nint is_number(char *c)\\n{\\n\\treturn (*c >= '0' && *c <= '9') ? 1 : 0;\\n}\\n\\n/**\\n * @brief Returns specific required next character\\n * @param p pointer to a format string of `min_printf()`\\n * @param buffer struct for checking if buffr_char character is present or not\\n * @return character inside `buffer->buffr_char`, if `buffer->buf_size` is one\\n * @return character at which p is pointing, if `buffer->buf_size` is zero\\n */\\nchar get_ch(char *p, Buffer *buffer)\\n{\\n\\tif (buffer->buf_size) {\\n\\t\\tbuffer->buf_size = 0; ///< Since character is used, this sets `buffer->buf_size` to zero\\n\\t\\treturn buffer->buffr_char; // Returns character inside buffer->buffr_char\\n\\t}\\n\\treturn *p++;\\n}\\n\\n/**\\n * @brief Stores character to the `buffer->buffr_char`\\n * @param c character to be stored in the `buffer->buffr_char`\\n * @param buffer struct where character will be stored\\n*/\\nvoid unget_ch(char *c, Buffer *buffer)\\n{\\n\\tbuffer->buffr_char = *c;\\t// Character initializes inside buffer->buffr_char\\n\\tbuffer->buf_size = 1; // Sets bufsize to one as new character is stored in buffr_char\\n}\\n\\n\\n/**\\n * @brief Calculates the number of digits in a number\\n * @param n number whose digits are to be counted\\n * @return number of digits in n\\n*/\\nint get_number_of_digits(int n)\\n{\\n\\tint digits = 0; // Stores encountered number of digits\\n\\twhile (n > 0) {\\n\\t\\t++digits; // Since number still contains a digit, so increment digit variable\\n\\t\\tn /= 10; // Removes last digit from number\\n\\t}\\n\\treturn digits;\\n}\\n\\n/**\\n * @brief Prints one character on screen\\n * @param s character to be printed on the screen\\n*/\\nvoid put_char(char s)\\n{\\n\\t/* buf used for storing character to be printed in an array (+1 for '\\\\0')*/\\n\\tchar *buf = (char *) malloc(sizeof(char) + 1); \\n\\t*buf = s;\\n\\t*(buf + 1) = '\\\\0';\\n\\twrite(1, buf, 1);\\n\\tfree(buf);\\n}\\n\\n/**\\n * @brief Reverses a string using [two pointer algorithm](https://www.geeksforgeeks.org/program-reverse-array-using-pointers/?ref=rp)\\n * @param p pointer to the string which is to be reversed\\n*/\\nvoid reverse_str(char *p)\\n{\\n\\tchar *l = p; // Points to first character of p\\n\\tchar *h = p; // Will be used to point to last character of p\\n\\tchar temp; // Temporarily stores a character, Used in swapping\\n\\n\\twhile (*h != '\\\\0') \\n\\t\\t++h;\\n\\t--h; // Now h point to last valid character of string \\n\\n\\t/* Swap character which lower and higher are pointing until lower < higher. At that point string will be reversed.*/\\n\\twhile (l < h) {\\n\\t\\ttemp = *l;\\n\\t\\t*l = *h;\\n\\t\\t*h = temp;\\n\\t\\t++l; // Increment lower to next character\\n\\t\\t--h; // Decrement higher to previous character from current character\\n\\t}\\n}\\n\\n/**\\n * @details\\n * The algorithm here is to first convert the number into \\n * string and then reverse it be passing it to reverse_str function\\n * and then printing on the screen\\n * @param n Number to be printed\\n * @param width Total characters to be printed (Prints ' ' if (size < width)\\n * @param precision Total character of number to be printed (prints 0 before number if size of number < precision)\\n * \\n*/\\nvoid print_int_value(int n, int width, int precision)\\n{\\n\\tchar *p = (char *) malloc(INT_MAX_LENGTH * sizeof(char) + 1); /* +1 for '\\\\0' */\\n\\tchar *s = p; // Temporary pointer\\n\\tint size = 0; //!< Used to store number of digits in number\\n\\n\\twhile (n > 0) {\\n\\t\\t*s++ = n % 10 + '0'; // Converts last digit of number to character and store it in p\\n\\t\\t++size; // Increment size variable as one more digit is occured\\n\\t\\tn /= 10; // Removes the last digit from the number n as we have successfully stored it in p\\n\\t}\\n\\t*s = '\\\\0';\\n\\n\\ts = p; // Again point back s to starting of p\\n\\n\\treverse_str(p);\\n\\n\\t/*!\\n\\t * The next two conditions check weather it is required to \\n\\t * add blanks before printing the number (ie: width)and is it specified how many\\n\\t * zeros to be printed before the number is printed (ie: precision)\\n\\t*/\\n\\tif (width > 0 && size < width)\\n\\t\\tfor (int i = 0; i < (width - precision); ++i) \\n\\t\\t\\tput_char(' ');\\n\\n\\tif (precision > 0 && precision > size)\\n\\t\\tfor (int i = 0; i < (precision - size); ++i)\\n\\t\\t\\tput_char('0');\\n\\n\\t/* Prints the number.*/\\n\\twhile (*s != '\\\\0')\\n\\t\\tput_char(*s++);\\n\\n\\tfree(p);\\n}\\n\\n/**\\n* @brief The algorithm here is also the same as the `print_int_value` function\\n *\\n * @details\\n * First, the digits before decimal is printed by converting the double \\n * to int. Then after printed a `.`, the double number is subtracted with\\n * the integer value of the number, leaving us with 0 before the decimal.\\n * Then, we multiply the number with 10 raised to the power precision (\\n * precision means how many digits to be printed after the decimal.)\\n * By default, the precision is 8 if it is not specified.\\n * Then, the remaining number is printed on the screen.\\n * @param dval double number to be printed\\n * @param width similar to width parameter of print_int_value()\\n * @param precision tells the number of digits to be printed after the decimal (By default it is 8)\\n */\\nvoid print_double_value(double dval, int width, int precision)\\n{\\n\\tint ndigits = get_number_of_digits((int) dval); // Store number of digits before decimal in dval\\n\\tint reqd_blanks = width - (precision + 1) - ndigits; // Blanks to be printed before printing dval, just to cover the width\\n\\t\\n\\tprint_int_value((int) dval, reqd_blanks, 0); // Prints the part before decimal\\n\\n\\tput_char('.'); // Print decimal\\n\\n\\t/*Deletes digits before decimal and makes them zero. For example:\\n\\t\\tif dval = 1923.79022, them this will make dval = 0.79022\\n\\t*/\\n\\tdval = dval - (int) dval;\\n\\n\\tdval *= power_of_ten(precision); // Brings precision number of digits after decimal to before decimal\\n\\t\\n\\tprint_int_value((int) dval, 0, precision); // Prints the remaining number\\n}\\n\\n/**\\n * @details\\n* First size of the string is calculated to check whether\\n* width and precision are to be taken into account or not.\\n* Then, the string is printed in accordingly.\\n* @param p pointer to string to be printed\\n* @param width if (width > sizeof string) then, blanks will be printed before sting to cover up the width\\n* @param precision total characters of the string to be printed (prints the whole string if 0 or greater than size of string)\\n*/\\nvoid print_string(char *p, int width, int precision)\\n{\\n\\tint size = 0; // Stores number of character in string\\n\\tchar *s = p; // Temporary pointer\\n\\n\\t/* Calculates size of string p*/\\n\\twhile (*s != '\\\\0') { \\n\\t\\t++size;\\n\\t\\t++s;\\n\\t}\\n\\n\\ts = p; // Point s to starting of p\\n\\n\\t/* Checks how many characters to be printed.\\n\\t\\tif precision is defined then size variable is changed to precision so that only precision\\n\\t\\tnumber of characters were printed.\\n\\t*/\\n\\tif (precision != 0 && precision < size)\\n\\t\\tsize = precision;\\n\\n\\t/* Prints blanks to cover the width if required*/\\n\\tfor (int i = 0; i < (width - size); ++i)\\n\\t\\tput_char(' ');\\n\\n\\t/* Print the string.*/\\n\\tfor (int i = 0; i < size; ++i)\\n\\t\\tput_char(*s++);\\n\\n}\\n\\n/**\\n* @brief Takes width and precision specified from the format of the string\\n* @param p pointer of the format string\\n* @param width variable in which width will be stored\\n* @param precision variable in which precision will be stored\\n* @return character pointer to the current pointer of string p (used to update value of p)\\n*/\\nchar *get_width_and_precision(char *p, Buffer *buffer, int *width, int *precision)\\n{\\n\\t/* Skip % if p is pointing to it.*/\\n\\tif (*p == '%')\\n\\t\\t++p;\\n\\t\\n\\t/* Calculates the width specified. */\\n\\twhile (*p != '.' && is_number(p)) \\n\\t\\t*width = *width * 10 + (*p++ - '0');\\n\\n\\t/* Calculates the precision specified.*/\\n\\tif (*p == '.' /* Since a precision is always specified after a '.'. */) { \\n\\t\\twhile (is_number(++p))\\n\\t\\t\\t*precision = *precision * 10 + (*p - '0'); \\n\\t\\tunget_ch(p, buffer); // The non number will be stored in `buffer->buffr`\\n\\t}\\n\\treturn p;\\n}\\n\\n/**\\n * min_printf is the function same as printf\\n * @param fmt format of string\\n * @param ... arguments passed according to the format\\n*/\\nvoid min_printf(char *fmt, ...)\\n{\\n\\tva_list ap; // Points to each unnamed arg in turn\\n\\tchar *p, *sval; // p will be used to point to fmt and sval will store string value\\n\\tchar cval; // Stores character value\\n\\tint ival; // For integer values\\n\\tdouble dval; // For double or float values\\n\\tva_start(ap, fmt); // Makes ap points to first unnames argument\\n\\n\\t/* Initializing the buffer for storing character. */\\n\\tBuffer *buffer = (Buffer *) malloc(sizeof(Buffer));\\n\\tbuffer->buf_size = 0; // Initially set buffer size to zero as no character is inserted\\n\\n\\tfor (p = fmt; *p != '\\\\0'; ++p) {\\n\\t\\t\\n\\t\\t/* If p != '%' then the character is printed to screen. */\\n\\t\\tif (*p != '%') {\\n\\t\\t\\tput_char(*p);\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint width = 0; // Stores width specified\\n\\t\\tint precision = 0; // Stores precision specified\\n\\n\\t\\t/* Updates values of width, precision and p. */\\n\\t\\tp = get_width_and_precision(p, buffer, &width, &precision); \\n\\t\\t\\n\\t\\t/* Checks format of next argument.*/\\n\\t\\tswitch (get_ch(p, buffer)) {\\n\\t\\t\\tcase 'd': // Integer\\n\\t\\t\\t\\tival = va_arg(ap, int);\\n\\t\\t\\t\\tprint_int_value(ival, width, precision);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'c': // Character\\n\\t\\t\\t\\tcval = va_arg(ap, int);\\n\\t\\t\\t\\tput_char(cval);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'f': // Float or Double\\n\\t\\t\\t\\tdval = va_arg(ap, double);\\n\\n\\t\\t\\t\\t// If precision is not specified then default value is applied\\n\\t\\t\\t\\tif (precision == 0)\\n\\t\\t\\t\\t\\tprecision = PRECISION_FOR_FLOAT;\\n\\t\\t\\t\\tprint_double_value(dval, width, precision);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 's': // String pointer\\n\\t\\t\\t\\tsval = va_arg(ap, char *);\\n\\t\\t\\t\\tprint_string(sval, width, precision);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tput_char(*p);\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tva_end(ap);\\n}\\n\\n#endif /* MIN_PRINTF_H */\\n\"",
    "test malloc dbg": "\"/**\\n * @file\\n * @brief File used to test the malloc_dbg, calloc_dbg and free_dbg functions.\\n * @details\\n * This file only have a main function that calls malloc, calloc and free.\\n * When the program exits, memory leaks must be printed.\\n * @author [tinouduart33](https://github.com/tinouduart33)\\n * @see malloc_dbg.c, malloc_dbg.h\\n */\\n\\n#include <stdio.h> /// For IO operations if needed.\\n#include <stdlib.h> /// For the EXIT_SUCCESS macro and the \\\"real\\\" malloc, calloc and free functions.\\n#include \\\"malloc_dbg.h\\\" /// For the macros malloc, calloc and free and the malloc_dbg, calloc_dbg and free_dbg functions.\\n\\n\\n/**\\n * @brief Main function\\n * @param argc number of arguments (not used)\\n * @param argv list of arguments (not used)\\n * @returns 0 on exit\\n */\\nint main(int argc, char* argv[])\\n{\\n\\tint* iptr = malloc(10 * sizeof(int));\\n\\tchar* cptr = calloc(256, sizeof(char));\\n\\n\\tfree(iptr);\\n\\t// free(cptr);\\n\\n\\treturn 0;\\n}\\n\"",
    "test min printf": "\"/**\\n * @file\\n * @brief File used to test min_printf function.\\n * @details\\n * The test will be executed by comparing the result of both `min_printf` and `printf` functions\\n * @author [Jaskarn7](https://github.com/Jaskarn7)\\n * @see min_printf.h\\n*/\\n\\n#include \\\"min_printf.h\\\" /// for `min_printf` function\\n#include <stdio.h> /// for `printf` function\\n\\n/**\\n * @brief Main function\\n * @details\\n * This function is used to test `min_printf` function.\\n * The numbers and string used for the test is generated randomly (The user can also specify their own value for tests)\\n * First integers were tested then floats and at last strings\\n * After running the program the user will see three pair of lines with each pair followed by an empty line\\n * In each pair of lines, the first line will be printed by `min_printf` function and next line by the actual `printf` function\\n * In each line user will see number or string covered with two colons, they are used to check from where the printing was started and where it ends\\n * @returns 0 on exit\\n*/\\nint main()\\n{\\n    // print strings using `printf` and `min_printf`\\n    min_printf(\\\":%d: :%1.6d:\\\\n\\\", 12, 56);\\n    printf(\\\":%d: :%1.6d:\\\\n\\\", 12, 56);\\n\\n    printf(\\\"\\\\n\\\"); /// Printing an empty new line\\n\\n    // print floats or doubles using `printf` and `min_printf`\\n    min_printf(\\\":%f: :%3.6f:\\\\n\\\", 104.5654, 43.766443332);\\n    printf(\\\":%f: :%3.6f:\\\\n\\\", 104.5654, 43.766443332);\\n\\n    printf(\\\"\\\\n\\\");\\n\\n    // print integers `printf` and `min_printf`\\n    min_printf(\\\":%s: :%4.3s:\\\\n\\\", \\\"Hello, World!\\\", \\\"Hello, World!\\\");\\n    printf(\\\":%s: :%4.3s:\\\\n\\\", \\\"Hello, World!\\\", \\\"Hello, World!\\\");\\n\\n}\\n\"",
    "naval battle": "\"/**\\n * @file\\n * @author [Carlos Rafael](https://github.com/CarlosZoft)\\n * @author [Herick Lima](https://github.com/hericklima22)\\n * @brief [naval_battle](https://en.wikipedia.org/wiki/Battleship_(game))\\n * implementation in C using only the stdio.h for Standard Input and Output.\\n * @details  Naval battle is a game, to be played by two people. It consists of\\n * knocking down the enemy ship, through shots , when hit the ship is\\n * revealed with the respective number of its size. Example: size 3 = 3 3 3 on\\n * the board.\\n * To play - boats over size 1, need direction; V -> vertical and H ->\\n * horizontal. Example Input 1 A H -> line 1, column A, direction H\\n * (Horizontal).\\n */\\n\\n#include <stdio.h>  /// for Standard Input Output\\n\\n/**\\n * @brief Function validEntryLineColumn\\n * Responsible for validating entries, for positioning boats\\n * @param line matrix row\\n * @param column matrix column\\n * @returns if the row and column are valid\\n */\\nint validEntryLineColumn(int line, char column)\\n{\\n    if ((line >= 1 && line <= 10) && (column >= 65 && column <= 74))\\n    {\\n        return 1;\\n    }\\n\\n    return 0;\\n}\\n/**\\n * @brief Function validatePosition\\n * Responsible for checking if the position can receive the boat.\\n * @param mat board\\n * @param boat boat\\n * @param line matrix row\\n * @param column matrix column\\n * @returns if the position is valid\\n */\\nint validatePosition(int mat[10][10], int boat, int line, int column,\\n                     char guide)\\n{\\n    int cont = 0;\\n    int i, j;\\n\\n    if (line < 0 || line > 9 || column < 0 || column > 9 ||\\n        (guide != 'H' && guide != 'V') || boat < 1 || boat > 3)\\n    {\\n        return 0;\\n    }\\n\\n    if (guide == 'H')\\n    {\\n        if ((10 - column) < boat)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for (j = column; j < (column + boat); j++)\\n            {\\n                if (mat[line][j] == 0)\\n                {\\n                    cont++;\\n                }\\n            }\\n        }\\n    }\\n\\n    if (guide == 'V')\\n    {\\n        if ((10 - line) < boat)\\n        {\\n            return 0;\\n        }\\n\\n        else\\n        {\\n            for (i = line; i < (line + boat); i++)\\n            {\\n                if (mat[i][column] == 0)\\n                {\\n                    cont++;\\n                }\\n            }\\n        }\\n    }\\n\\n    if (cont == boat)\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\n/**\\n * @brief Function canShoot\\n * Responsible to verify that it is a valid position to shoot\\n * @param mat board\\n * @param line matrix row\\n * @param column matrix column\\n * @returns if the position is valid for shooting\\n */\\n\\nint canShoot(int mat[10][10], int line, int column)\\n{\\n    if (mat[line][column] == -2 || mat[line][column] == 10 ||\\n        mat[line][column] == 20 || mat[line][column] == 30 ||\\n        mat[line][column] == 50)\\n    {\\n        return 0;\\n    }\\n\\n    return 1;\\n}\\n/**\\n * @brief Function positionBoat\\n * Responsible for placing the boats on the board, according to the size.\\n * @param mat board\\n * @param boat boat\\n */\\nvoid positionBoat(int mat[10][10], int boat)\\n{\\n    int line, j;\\n    char column, guide;\\n\\n    if (boat == 1)\\n    {\\n        scanf(\\\"%d %c\\\", &line, &column);\\n\\n        while (validEntryLineColumn(line, column) != 1 ||\\n               validatePosition(mat, boat, (line - 1), (column - 65), 'H') != 1)\\n        {\\n            printf(\\\"Position unavailable!\\\\n\\\");\\n            scanf(\\\"%d %c\\\", &line, &column);\\n        }\\n    }\\n\\n    else\\n    {\\n        scanf(\\\"%d %c %c\\\", &line, &column, &guide);\\n\\n        while (validEntryLineColumn(line, column) == 0 ||\\n               validatePosition(mat, boat, (line - 1), (column - 65), guide) ==\\n                   0)\\n        {\\n            printf(\\\"Position unavailable!\\\\n\\\");\\n            scanf(\\\"%d %c %c\\\", &line, &column, &guide);\\n        }\\n    }\\n\\n    int aux = column - 'A';\\n    line -= 1;\\n\\n    if (boat == 1)\\n    {\\n        for (j = aux; j < (aux + boat); j++)\\n        {\\n            mat[line][j] = boat;\\n        }\\n\\n        for (int a = line - 1; a < (line + boat + 1); a++)\\n        {\\n            for (int b = aux - 1; b < (aux + boat + 1); b++)\\n            {\\n                if (a >= 0 && a <= 9 && b >= 0 && b <= 9)\\n                {\\n                    if (mat[a][b] != boat)\\n                    {\\n                        mat[a][b] = -1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    if (guide == 'H')\\n    {\\n        for (j = aux; j < (aux + boat); j++)\\n        {\\n            mat[line][j] = boat;\\n        }\\n        if (boat == 3)\\n        {\\n            for (int a = line - 1; a < (line + boat - 1); a++)\\n            {\\n                for (int b = aux - 1; b < (aux + boat + 1); b++)\\n                {\\n                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)\\n                    {\\n                        if (mat[a][b] != boat)\\n                        {\\n                            mat[a][b] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        else\\n        {\\n            for (int a = line - 1; a < (line + boat); a++)\\n            {\\n                for (int b = aux - 1; b < (aux + boat + 1); b++)\\n                {\\n                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)\\n                    {\\n                        if (mat[a][b] != boat)\\n                        {\\n                            mat[a][b] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    if (guide == 'V')\\n    {\\n        for (j = line; j < (line + boat); j++)\\n        {\\n            mat[j][aux] = boat;\\n        }\\n        if (boat == 3)\\n        {\\n            for (int a = line - 1; a < (line + boat + 1); a++)\\n            {\\n                for (int b = aux - 1; b < (aux + boat - 1); b++)\\n                {\\n                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)\\n                    {\\n                        if (mat[a][b] != boat)\\n                        {\\n                            mat[a][b] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        else\\n        {\\n            for (int a = line - 1; a < (line + boat + 1); a++)\\n            {\\n                for (int b = aux - 1; b < (aux + boat); b++)\\n                {\\n                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)\\n                    {\\n                        if (mat[a][b] != boat)\\n                        {\\n                            mat[a][b] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n/**\\n * @brief Function printMessage\\n * Responsible for printing the auxiliary message\\n * @param msg msg with board\\n */\\nvoid printMessage(char *msg)\\n{\\n    printf(\\\"************************\\\\n\\\");\\n    printf(\\\"*\\\\n\\\");\\n    printf(\\\"* %s\\\\n\\\", msg);\\n    printf(\\\"*\\\\n\\\");\\n    printf(\\\"************************\\\\n\\\");\\n}\\n/**\\n * @brief Function printMessageScore\\n * Responsible for printing the score messages\\n * @param pts1 player 1 score\\n * @param pts2 player 2 score\\n */\\nvoid printMessageScore(int pts1, int pts2)\\n{\\n    printf(\\\"************************\\\\n\\\");\\n    printf(\\\"*\\\\n\\\");\\n    printf(\\\"* Player'S SCORE 1: %02d\\\\n\\\", pts1);\\n    printf(\\\"* Player'S SCORE 2: %02d\\\\n\\\", pts2);\\n    printf(\\\"*\\\\n\\\");\\n    printf(\\\"************************\\\\n\\\");\\n}\\n/**\\n * @brief Function printTable\\n * Responsible for printing the board\\n * @param logic return of the logical matrix\\n * @param stage game step\\n * @returns char for visual matrix\\n */\\nchar printTable(int logic, int stage)\\n{\\n    if (stage == 0)\\n    {\\n        if (logic == 0)\\n        {\\n            return '.';\\n        }\\n\\n        else if (logic == -1)\\n        {\\n            return '*';\\n        }\\n\\n        else if (logic == 1)\\n        {\\n            return '1';\\n        }\\n\\n        else if (logic == 2)\\n        {\\n            return '2';\\n        }\\n\\n        else\\n        {\\n            return '3';\\n        }\\n    }\\n\\n    else\\n    {\\n        if (logic == 0 || logic == -1 || logic == 1 || logic == 2 || logic == 3)\\n        {\\n            return '.';\\n        }\\n\\n        else if (logic == -2)\\n        {\\n            return 'x';\\n        }\\n\\n        else if (logic == 10 || logic == 20 || logic == 30)\\n        {\\n            return 'N';\\n        }\\n\\n        else\\n        {\\n            return 'A';\\n        }\\n    }\\n}\\n/**\\n * @brief Function printsTray\\n * Responsible for printing the visual board for the user\\n * @param mat Matrix\\n * @param stage game step\\n */\\nvoid printsTray(int mat[10][10], int stage)\\n{\\n    int logic;\\n    char imp;\\n\\n    printf(\\\"     \\\");\\n    for (int i = 65; i < 75; i++)\\n    {\\n        printf(\\\"%c\\\", i);\\n        if (i < 74)\\n        {\\n            printf(\\\" \\\");\\n        }\\n    }\\n    printf(\\\"\\\\n\\\");\\n\\n    for (int i = 0; i < 12; i++)\\n    {\\n        if (i > 0 && i < 11)\\n        {\\n            printf(\\\"%02d \\\", i);\\n        }\\n\\n        else\\n        {\\n            printf(\\\"   \\\");\\n        }\\n\\n        for (int j = 0; j < 12; j++)\\n        {\\n            if ((i > 0 && i < 11) && (j > 0 && j < 11))\\n            {\\n                logic = mat[i - 1][j - 1];\\n                imp = printTable(logic, stage);\\n                printf(\\\"%c\\\", imp);\\n            }\\n            else\\n            {\\n                printf(\\\"#\\\");\\n            }\\n\\n            if (j < 11)\\n            {\\n                printf(\\\" \\\");\\n            }\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n/**\\n * @brief Function shoot\\n * Responsible for saying if he hit a boat\\n * @param mat board\\n * @param line matrix row\\n * @param column matrix column\\n */\\nvoid shoot(int mat[10][10], int line, int column)\\n{\\n    if (mat[line][column] == 0 || mat[line][column] == -1)\\n    {\\n        mat[line][column] = -2;\\n    }\\n\\n    else if (mat[line][column] == 1)\\n    {\\n        mat[line][column] = 10;\\n    }\\n\\n    else if (mat[line][column] == 2)\\n    {\\n        mat[line][column] = 20;\\n    }\\n\\n    else if (mat[line][column] == 3)\\n    {\\n        mat[line][column] = 30;\\n    }\\n}\\n/**\\n * @brief Function calculateScore\\n * Responsible for calculating the score obtained during the game\\n * @param mat board\\n * @param line matrix row\\n * @param column matrix column\\n * @returns resulting score\\n */\\n\\nint calculateScore(int mat[10][10], int line, int column)\\n{\\n    int c = 0, b = 0, e = 0, d = 0;\\n\\n    if (mat[line][column] == 10)\\n    {\\n        mat[line][column] = 50;\\n        return 2;\\n    }\\n\\n    else if (mat[line][column] == 20)\\n    {\\n        if (mat[line + 1][column] == 20)\\n        {\\n            b = 1;\\n        }\\n\\n        if (mat[line - 1][column] == 20)\\n        {\\n            c = 1;\\n        }\\n\\n        if (mat[line][column + 1] == 20)\\n        {\\n            d = 1;\\n        }\\n\\n        if (mat[line][column - 1] == 20)\\n        {\\n            e = 1;\\n        }\\n\\n        if (b == 1)\\n        {\\n            if (mat[line + 1][column] == 20)\\n            {\\n                mat[line][column] = 50;\\n                mat[line + 1][column] = 50;\\n                return 4;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n\\n        if (c == 1)\\n        {\\n            if (mat[line - 1][column] == 20)\\n            {\\n                mat[line][column] = 50;\\n                mat[line - 1][column] = 50;\\n                return 4;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n\\n        if (d == 1)\\n        {\\n            if (mat[line][column + 1] == 20)\\n            {\\n                mat[line][column] = 50;\\n                mat[line][column + 1] = 50;\\n                return 4;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n\\n        if (e == 1)\\n        {\\n            if (mat[line][column - 1] == 20)\\n            {\\n                mat[line][column] = 50;\\n                mat[line][column - 1] = 50;\\n                return 4;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n    }\\n\\n    else if (mat[line][column] == 30)\\n    {\\n        if (mat[line + 1][column] == 30)\\n        {\\n            b = 1;\\n        }\\n\\n        if (mat[line - 1][column] == 30)\\n        {\\n            c = 1;\\n        }\\n        if (mat[line][column + 1] == 30)\\n        {\\n            d = 1;\\n        }\\n\\n        if (mat[line][column - 1] == 30)\\n        {\\n            e = 1;\\n        }\\n\\n        if (b == 1 && c == 1)\\n        {\\n            if (mat[line + 1][column] == 30 && mat[line - 1][column] == 30)\\n            {\\n                mat[line][column] = 50;\\n                mat[line + 1][column] = 50;\\n                mat[line - 1][column] = 50;\\n                return 7;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n\\n        else if (d == 1 && e == 1)\\n        {\\n            if (mat[line][column + 1] == 30 && mat[line][column - 1] == 30)\\n            {\\n                mat[line][column] = 50;\\n                mat[line][column - 1] = 50;\\n                mat[line][column + 1] = 50;\\n                return 7;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n\\n        else if (d == 1)\\n        {\\n            if (mat[line][column + 1] == 30 && mat[line][column + 2] == 30)\\n            {\\n                mat[line][column] = 50;\\n                mat[line][column + 1] = 50;\\n                mat[line][column + 2] = 50;\\n                return 7;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n\\n        else if (e == 1)\\n        {\\n            if (mat[line][column - 1] == 30 && mat[line][column - 2] == 30)\\n            {\\n                mat[line][column] = 50;\\n                mat[line][column - 1] = 50;\\n                mat[line][column - 2] = 50;\\n                return 7;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n\\n        else if (c == 1)\\n        {\\n            if (mat[line - 1][column] == 30 && mat[line - 2][column] == 30)\\n            {\\n                mat[line][column] = 50;\\n                mat[line - 1][column] = 50;\\n                mat[line - 2][column] = 50;\\n                return 7;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n\\n        else if (b == 1)\\n        {\\n            if (mat[line + 1][column] == 30 && mat[line + 2][column] == 30)\\n            {\\n                mat[line][column] = 50;\\n                mat[line + 1][column] = 50;\\n                mat[line + 2][column] = 50;\\n                return 7;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n/**\\n * @brief Function printPositioning\\n * Responsible for printing messages for positioning boats on the board; of\\n * player 1 and 2\\n * @param Player number representing the Player\\n * @param boat number that represents the boat\\n * @param nm which message to print\\n */\\nvoid printPositioning(int Player, int boat, int nm)\\n{\\n    if (Player == 1)\\n    {\\n        char msg1[60] = \\\"Player 1 - Position the size boat 1 (1/6)\\\";\\n        char msg2[60] = \\\"Player 1 - Position the size boat 1 (2/6)\\\";\\n        char msg3[60] = \\\"Player 1 - Position the size boat 1 (3/6)\\\";\\n        char msg4[60] = \\\"Player 1 - Position the size boat 1 (4/6)\\\";\\n        char msg5[60] = \\\"Player 1 - Position the size boat 1 (5/6)\\\";\\n        char msg6[60] = \\\"Player 1 - Position the size boat 1 (6/6)\\\";\\n\\n        char msg7[60] = \\\"Player 1 - Position the size boat 2 (1/4)\\\";\\n        char msg8[60] = \\\"Player 1 - Position the size boat 2 (2/4)\\\";\\n        char msg9[60] = \\\"Player 1 - Position the size boat 2 (3/4)\\\";\\n        char msg10[60] = \\\"Player 1 - Position the size boat 2 (4/4)\\\";\\n\\n        char msg11[60] = \\\"Player 1 - Position the size boat 3 (1/2)\\\";\\n        char msg12[60] = \\\"Player 1 - Position the size boat 3 (2/2)\\\";\\n\\n        if (boat == 1)\\n        {\\n            if (nm == 1)\\n            {\\n                printMessage(msg1);\\n            }\\n            else if (nm == 2)\\n            {\\n                printMessage(msg2);\\n            }\\n            else if (nm == 3)\\n            {\\n                printMessage(msg3);\\n            }\\n\\n            else if (nm == 4)\\n            {\\n                printMessage(msg4);\\n            }\\n\\n            else if (nm == 5)\\n            {\\n                printMessage(msg5);\\n            }\\n\\n            else if (nm == 6)\\n            {\\n                printMessage(msg6);\\n            }\\n        }\\n        else if (boat == 2)\\n        {\\n            if (nm == 1)\\n            {\\n                printMessage(msg7);\\n            }\\n            else if (nm == 2)\\n            {\\n                printMessage(msg8);\\n            }\\n            else if (nm == 3)\\n            {\\n                printMessage(msg9);\\n            }\\n            else if (nm == 4)\\n            {\\n                printMessage(msg10);\\n            }\\n        }\\n        else if (boat == 3)\\n        {\\n            if (nm == 1)\\n            {\\n                printMessage(msg11);\\n            }\\n            if (nm == 2)\\n            {\\n                printMessage(msg12);\\n            }\\n        }\\n    }\\n\\n    if (Player == 2)\\n    {\\n        char msg1[60] = \\\"Player 2 - Position the size boat 1 (1/6)\\\";\\n        char msg2[60] = \\\"Player 2 - Position the size boat 1 (2/6)\\\";\\n        char msg3[60] = \\\"Player 2 - Position the size boat 1 (3/6)\\\";\\n        char msg4[60] = \\\"Player 2 - Position the size boat 1 (4/6)\\\";\\n        char msg5[60] = \\\"Player 2 - Position the size boat 1 (5/6)\\\";\\n        char msg6[60] = \\\"Player 2 - Position the size boat 1 (6/6)\\\";\\n\\n        char msg7[60] = \\\"Player 2 - Position the size boat 2 (1/4)\\\";\\n        char msg8[60] = \\\"Player 2 - Position the size boat 2 (2/4)\\\";\\n        char msg9[60] = \\\"Player 2 - Position the size boat 2 (3/4)\\\";\\n        char msg10[60] = \\\"Player 2 - Position the size boat 2 (4/4)\\\";\\n\\n        char msg11[60] = \\\"Player 2 - Position the size boat 3 (1/2)\\\";\\n        char msg12[60] = \\\"Player 2 - Position the size boat 3 (2/2)\\\";\\n\\n        if (boat == 1)\\n        {\\n            if (nm == 1)\\n            {\\n                printMessage(msg1);\\n            }\\n            else if (nm == 2)\\n            {\\n                printMessage(msg2);\\n            }\\n            else if (nm == 3)\\n            {\\n                printMessage(msg3);\\n            }\\n            else if (nm == 4)\\n            {\\n                printMessage(msg4);\\n            }\\n            else if (nm == 5)\\n            {\\n                printMessage(msg5);\\n            }\\n            else if (nm == 6)\\n            {\\n                printMessage(msg6);\\n            }\\n        }\\n        else if (boat == 2)\\n        {\\n            if (nm == 1)\\n            {\\n                printMessage(msg7);\\n            }\\n            else if (nm == 2)\\n            {\\n                printMessage(msg8);\\n            }\\n            else if (nm == 3)\\n            {\\n                printMessage(msg9);\\n            }\\n            else if (nm == 4)\\n            {\\n                printMessage(msg10);\\n            }\\n        }\\n        else if (boat == 3)\\n        {\\n            if (nm == 1)\\n            {\\n                printMessage(msg11);\\n            }\\n            else if (nm == 2)\\n            {\\n                printMessage(msg12);\\n            }\\n        }\\n    }\\n}\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    int Player1[10][10];\\n    int Player2[10][10];\\n    int plays = 1;\\n    int pts1 = 0, pts2 = 0, a1 = 0, a2 = 0;\\n    int line, col = 0, lin = 0;\\n    char column;\\n\\n    // filling matrix with 0\\n    for (int i = 0; i < 10; i++)\\n    {\\n        for (int j = 0; j < 10; j++)\\n        {\\n            Player1[i][j] = 0;\\n            Player2[i][j] = 0;\\n        }\\n    }\\n\\n    // positioning boats\\n    for (int i = 1; i <= 2; i++)\\n    {\\n        for (int j = 1; j <= 6; j++)\\n        {\\n            if (i == 1)\\n            {\\n                printPositioning(i, 1, j);\\n                printsTray(Player1, 0);\\n                positionBoat(Player1, 1);\\n            }\\n            else if (i == 2)\\n            {\\n                printPositioning(i, 1, j);\\n                printsTray(Player2, 0);\\n                positionBoat(Player2, 1);\\n            }\\n        }\\n        for (int j = 1; j <= 4; j++)\\n        {\\n            if (i == 1)\\n            {\\n                printPositioning(i, 2, j);\\n                printsTray(Player1, 0);\\n                positionBoat(Player1, 2);\\n            }\\n            else if (i == 2)\\n            {\\n                printPositioning(i, 2, j);\\n                printsTray(Player2, 0);\\n                positionBoat(Player2, 2);\\n            }\\n        }\\n        for (int j = 1; j <= 2; j++)\\n        {\\n            if (i == 1)\\n            {\\n                printPositioning(i, 3, j);\\n                printsTray(Player1, 0);\\n                positionBoat(Player1, 3);\\n            }\\n            else if (i == 2)\\n            {\\n                printPositioning(i, 3, j);\\n                printsTray(Player2, 0);\\n                positionBoat(Player2, 3);\\n            }\\n        }\\n    }\\n\\n    // starting the game\\n    while (plays <= 40)\\n    {\\n        if (plays % 2 != 0)\\n        {\\n            printMessageScore(pts1, pts2);\\n            printMessage(\\\"Player's turn 1\\\");\\n            printsTray(Player2, 1);\\n            scanf(\\\"%d %c\\\", &line, &column);\\n\\n            while (validEntryLineColumn(line, column) != 1 ||\\n                   canShoot(Player2, line - 1, column - 65) != 1)\\n            {\\n                line = 0;\\n                column = 'a';\\n                printf(\\\"Position unavailable!\\\\n\\\");\\n                scanf(\\\"%d %c\\\", &line, &column);\\n            }\\n            lin = line - 1;\\n            col = column - 65;\\n            shoot(Player2, lin, col);\\n            a1 = pts1;\\n            pts1 += calculateScore(Player2, lin, col);\\n\\n            if (a1 != pts1)\\n            {\\n                printMessage(\\\"Player 1 DROPPED A BOAT!\\\");\\n            }\\n        }\\n        else\\n        {\\n            printMessageScore(pts1, pts2);\\n            printMessage(\\\"Player's turn 1\\\");\\n            printsTray(Player1, 1);\\n            scanf(\\\"%d %c\\\", &line, &column);\\n\\n            while (validEntryLineColumn(line, column) != 1 ||\\n                   canShoot(Player1, line - 1, column - 65) != 1)\\n            {\\n                printf(\\\"Position unavailable!\\\\n\\\");\\n                scanf(\\\"%d %c\\\", &line, &column);\\n            }\\n            lin = line - 1;\\n            col = column - 65;\\n            shoot(Player1, lin, col);\\n            a2 = pts2;\\n            pts2 += calculateScore(Player1, lin, col);\\n\\n            if (a2 != pts2)\\n            {\\n                printMessage(\\\"Player 2 DROPPED A BOAT!\\\");\\n            }\\n        }\\n\\n        plays++;\\n    }\\n    /**\\n     * the one with the most points wins, or the one who knocks down all boats\\n     * first.\\n     */\\n    printMessage(\\\"END GAME\\\\n\\\");\\n    printMessageScore(pts1, pts2);\\n\\n    return 0;\\n}\\n\"",
    "tic tac toe": "\"/**\\n * @file tic-tac-toe.c\\n * @author [vivekboss99](github.com/vivekboss99)\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief [Tic-Tac-Toe game](https://en.wikipedia.org/wiki/Tic-tac-toe)\\n * implementation in C\\n * @details  Tic-Tac-Toe Game, where the user can decide to play with the\\n * computer(single player mode) or with other user(double player mode), the\\n * code as an array named 'game_table' which is the table and user needs to enter the\\n * position inside the array(from 1-9) where he/she wants to place 'X' or 'O' on the\\n * table.\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\n// Functions Declarations\\nstatic void singlemode();\\nstatic void doublemode();\\nstatic void placex(int);  // used for placing position of X by the 1st player\\nstatic void place();      // used by the computer to place O\\nstatic void placey(int);  // used in Double Player mode by the 2nd player to\\n                          // place the position of O\\nint checkwin();  // checks everytime when a player or computer places 'X' or 'O'\\n\\n/** Tic-Tac-Toe table, so basically we are using variable 'game_table' as the table(size:3X3) and\\n * updating it regularly\\n */\\nstatic char game_table[9];\\n\\n/**\\n * Main program function.\\n * @returns 0 on clean exit. \\n * @note No checks are included for program execution failures!\\n */\\nint main()\\n{   \\n    srand( (unsigned int)time(NULL));\\n    int l = 0;\\n    do\\n    {\\n        int n = 0;\\n\\n        // filling the table with multiple asterisks\\n        for (int i = 0; i < 9; i++) game_table[i] = '*';\\n\\n        // displaying the main menu\\n        printf(\\\"***************************************\\\\n\\\");\\n        printf(\\\"*************TIC TAC TOE***************\\\\n\\\");\\n        printf(\\\"***************************************\\\\n\\\");\\n        printf(\\\"***********1. YOU vs COMPUTER ***********\\\\n\\\");\\n        printf(\\\"***********2. YOU vs PLAYER ***********\\\\n\\\");\\n        printf(\\\"***********3.EXIT *********************\\\\n\\\");\\n        printf(\\\"Enter your choice : \\\");\\n        scanf(\\\"%d\\\", &n);\\n\\n        switch (n)  // switch case to select between single player mode or\\n                    // double player mode\\n        {\\n        case 1:\\n            singlemode();\\n            break;\\n        case 2:\\n            doublemode();\\n            break;\\n        default:\\n            printf(\\\"THANK YOU and EXIT!\\\");\\n        }\\n\\n        printf(\\\"Next game ? : \\\");\\n        printf(\\\"Enter 1 – YES and 0 - NO \\\");\\n        scanf(\\\"%d\\\", &l);\\n\\n    } while (l == 1);\\n\\n    return 0;\\n}\\n\\n/**\\n * @brief Implementation of game vs computer\\n *\\n * @returns None\\n */\\nvoid singlemode()\\n{\\n    int m;\\n    int k = 0;\\n    int table_fill_count=0;\\n\\n    for (int i = 0; i < 3; i++)\\n    {\\n        for (int j = 0; j < 3; j++)\\n        {\\n            printf(\\\"%c \\\", game_table[k]);\\n            k++;\\n        }\\n\\n        printf(\\\"\\\\n\\\");\\n    }\\n\\n    for (int x = 1; x < 10; x++)\\n    {\\n        k = 0;\\n\\n        printf(\\\"Where would you like to place 'x' \\\");\\n        scanf(\\\"%d\\\", &m);\\n\\n        placex(m);\\n        if(table_fill_count<4)\\n        {\\n          place();\\n        }\\n\\n        for (int i = 0; i < 3; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                printf(\\\"%c \\\", game_table[k]);\\n                k++;\\n\\n            }\\n\\n            printf(\\\"\\\\n\\\");\\n        }\\n        table_fill_count++;\\n        int o = checkwin();\\n\\n        if (o == -1 || o == -2)\\n        {\\n            if (o == -1)\\n            {\\n                printf(\\\"YOU WIN\\\\n\\\");\\n            }\\n            if (o == -2)\\n            {\\n                printf(\\\"YOU LOSE\\\\n\\\");\\n            }\\n\\n            break;\\n        }\\n\\n        if (table_fill_count==4)\\n        {\\n            printf(\\\"\\\\nDRAW \\\");\\n            break;\\n        }\\n    }\\n}\\n\\n/**\\n * @brief Implementation of game vs another player.\\n *\\n * @returns None\\n */\\nvoid doublemode()\\n{\\n    int m;\\n    int e1;\\n    int k = 0;\\n    int doublemode_table_count=0;\\n\\n    for (int i = 0; i < 3; i++)\\n    {\\n        for (int j = 0; j < 3; j++)\\n        {\\n            printf(\\\"%c \\\", game_table[k]);\\n            k++;\\n        }\\n\\n        printf(\\\"\\\\n\\\");\\n    }\\n    for (int x = 1; x < 10; x++)\\n    {\\n        k = 0;\\n\\n        printf(\\\"PLAYER1 - where would you like to place 'x' : \\\");\\n        scanf(\\\"%d\\\", &m);\\n\\n        placex(m);\\n        if(doublemode_table_count<4)\\n        {\\n        printf(\\\"PLAYER2 - where would you like to place 'o' : \\\");\\n        scanf(\\\"%d\\\", &e1);\\n\\n        placey(e1);\\n        }\\n\\n        for (int i = 0; i < 3; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                printf(\\\"%c \\\", game_table[k]);\\n                k++;\\n            }\\n\\n            printf(\\\"\\\\n\\\");\\n        }\\n        doublemode_table_count++;\\n        int o = checkwin();\\n\\n        if (o == -1 || o == -2)\\n        {\\n            if (o == -1)\\n            {\\n                printf(\\\"Player 1 WIN\\\\n\\\");\\n            }\\n            if (o == -2)\\n            {\\n                printf(\\\"Player 2 WIN\\\\n\\\");\\n            }\\n\\n            break;\\n        }\\n        if (doublemode_table_count==4)\\n        {\\n            printf(\\\"\\\\nDRAW \\\");\\n            break;\\n        }\\n    }\\n}\\n\\nint check_placex(){\\n\\tchar input[50];\\n\\tint n1;\\n\\twhile (1){\\n\\t\\tfgets(input,49,stdin);\\n\\t\\tif ( strlen(input) > 2 || strlen(input)  == 0){\\n\\t\\t\\tfprintf(stderr,\\\"Invalid move, Enter number 1 - 9: \\\");\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif(sscanf(input,\\\"%d\\\",&n1) != 1){\\n\\t\\t\\tfprintf(stderr,\\\"Invalid move, Enter number 1 - 9: \\\");\\n\\t\\t\\tcontinue;\\n\\t\\t} \\n\\t\\tif ((game_table[n1-1] == 'x') || (game_table[n1-1]) == 'o' || (n1== 0)){\\n\\t\\t\\tfprintf(stderr,\\\"Already allocated, Enter number: \\\");\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\treturn n1;\\n\\t}\\n}\\t\\n\\n\\n\\n\\n\\n/**\\n * @brief Update table by placing an `X`\\n *\\n * @param m location to place `X`\\n *\\n * @returns None\\n */\\nvoid placex(int m)\\n{\\n    int n1 = 0;\\n    if (m >= 1 && m <= 9)\\n    {\\n        if (game_table[m - 1] != 'x' && game_table[m - 1] != 'o')\\n        {\\n            game_table[m - 1] = 'x';\\n        }\\n        else\\n        {\\n\\t\\t\\tint n = check_placex();\\n\\t\\t\\tplacex(n);\\n        }\\n    }\\n    else\\n    {\\n\\t\\tint n = check_placex();\\n\\t\\tplacex(n);\\n    }\\n}\\n/**\\n * @brief Update table by placing an `O`\\n *\\n * @returns None\\n */\\nvoid place()\\n{\\n\\n    int e = rand() % 9;\\n\\n    if (e >= 0 && e <= 8)\\n    {\\n        if (game_table[e] != 'x' && game_table[e] != 'o')\\n        {\\n            game_table[e] = 'o';\\n            printf(\\\"\\\\n Computer placed at %d position\\\\n\\\", e + 1);\\n        }\\n        else\\n        {\\n            place();\\n        }\\n    }\\n}\\n/**\\n * @brief Update table by placing an `O`\\n *\\n * @param e1 location to place `O`\\n *\\n * @returns None\\n */\\nvoid placey(int e1)\\n{\\n    int n1 = 0;\\n    if (e1 >= 1 && e1 <= 9)\\n    {\\n        if (game_table[e1 - 1] != 'x' && game_table[e1 - 1] != 'o')\\n        {\\n            game_table[e1 - 1] = 'o';\\n        }\\n        else\\n        {\\n\\t\\t\\tint n = check_placex();\\n\\t\\t\\tplacex(n);\\n        }\\n    }\\n    else\\n    {\\n\\t\\tint n = check_placex();\\n\\t\\tplacex(n);\\n    }\\n}\\n/**\\n * @brief Implementation of win conditon checker for 'X' or 'O' whenever the table is updated\\n *\\n * @returns -1: if 'X' won \\n * @returns -2: if 'O' won\\n * @returns 0: if there is no win condition for 'X' or 'O' \\n */\\nint checkwin()\\n{\\n    if (game_table[0] == game_table[1] && game_table[1] == game_table[2])\\n    {\\n        if (game_table[0] == 'x' && game_table[1] == 'x' &&\\n            game_table[2] == 'x')\\n        {\\n            return -1;\\n        }\\n\\n        if (game_table[0] == 'o' && game_table[1] == 'o' &&\\n            game_table[2] == 'o')\\n        {\\n            return -2;\\n        }\\n    }\\n    else if (game_table[0] == game_table[4] && game_table[4] == game_table[8])\\n    {\\n        if (game_table[0] == 'x' && game_table[4] == 'x' &&\\n            game_table[8] == 'x')\\n        {\\n            return -1;\\n        }\\n\\n        if (game_table[0] == 'o' && game_table[4] == 'o' &&\\n            game_table[8] == 'o')\\n        {\\n            return -2;\\n        }\\n    }\\n    else if (game_table[0] == game_table[3] && game_table[3] == game_table[6])\\n    {\\n        if (game_table[0] == 'x' && game_table[3] == 'x' &&\\n            game_table[6] == 'x')\\n        {\\n            return -1;\\n        }\\n\\n        if (game_table[0] == 'o' && game_table[3] == 'o' &&\\n            game_table[6] == 'o')\\n        {\\n            return -2;\\n        }\\n    }\\n    else if (game_table[3] == game_table[4] && game_table[4] == game_table[5])\\n    {\\n        if (game_table[3] == 'x' && game_table[4] == 'x' &&\\n            game_table[5] == 'x')\\n        {\\n            return -1;\\n        }\\n\\n        if (game_table[3] == 'o' && game_table[4] == 'o' &&\\n            game_table[5] == 'o')\\n        {\\n            return -2;\\n        }\\n    }\\n    else if (game_table[6] == game_table[7] && game_table[7] == game_table[8])\\n    {\\n        if (game_table[6] == 'x' && game_table[7] == 'x' &&\\n            game_table[8] == 'x')\\n        {\\n            return -1;\\n        }\\n\\n        if (game_table[6] == 'o' && game_table[7] == 'o' &&\\n            game_table[8] == 'o')\\n        {\\n            return -2;\\n        }\\n    }\\n    else if (game_table[1] == game_table[4] && game_table[4] == game_table[7])\\n    {\\n        if (game_table[1] == 'x' && game_table[4] == 'x' &&\\n            game_table[7] == 'x')\\n        {\\n            return -1;\\n        }\\n\\n        if (game_table[1] == 'o' && game_table[4] == 'o' &&\\n            game_table[7] == 'o')\\n        {\\n            return -2;\\n        }\\n    }\\n    else if (game_table[2] == game_table[5] && game_table[5] == game_table[8])\\n    {\\n        if (game_table[2] == 'x' && game_table[5] == 'x' &&\\n            game_table[8] == 'x')\\n        {\\n            return -1;\\n        }\\n\\n        if (game_table[2] == 'o' && game_table[5] == 'o' &&\\n            game_table[8] == 'o')\\n        {\\n            return -2;\\n        }\\n    }\\n    else if (game_table[2] == game_table[4] && game_table[4] == game_table[6])\\n    {\\n        if (game_table[2] == 'x' && game_table[4] == 'x' &&\\n            game_table[6] == 'x')\\n        {\\n            return -1;\\n        }\\n\\n        if (game_table[2] == 'o' && game_table[4] == 'o' &&\\n            game_table[6] == 'o')\\n        {\\n            return -2;\\n        }\\n    }\\n    return 0;\\n}\\n\"",
    "geometry datatypes": "\"/**\\n * @addtogroup quaternions Library for 3D Vectors & Quaternions\\n * @{\\n * @file\\n * @brief Generic header that provides data types for 3D vectors and quaternions\\n * @author Krishna Vedala\\n */\\n\\n#ifndef __LIBQUAT_H_\\n#define __LIBQUAT_H_\\n\\n/** Minimum recognizable value. Any value less than this is considered to be\\n * @f$=0@f$ */\\n#define EPSILON 1e-9\\n\\n/**\\n * @addtogroup vec_3d 3D Vector operations\\n * @{\\n */\\n/** 3D vector type */\\ntypedef struct vec_3d_\\n{\\n    float x; /**< X co-ordinate */\\n    float y; /**< Y co-ordinate */\\n    float z; /**< Z co-ordinate */\\n} vec_3d;\\n/** @} */\\n\\n/**\\n * @addtogroup matrix Matrix operations\\n * @{\\n */\\n/** A 3x3 Matrix type definition */\\ntypedef struct mat_3x3_\\n{\\n    union\\n    { /**< 3 element row 1 */\\n        float row1[3];\\n        vec_3d vec1;\\n    };\\n    union\\n    { /**< 3 element row 2 */\\n        float row2[3];\\n        vec_3d vec2;\\n    };\\n    union\\n    { /**< 3 element row 3 */\\n        float row3[3];\\n        vec_3d vec3;\\n    };\\n} mat_3x3;\\n/** @} */\\n\\n/** @addtogroup quats 3D Quaternion operations\\n * @{\\n */\\n/** a Quaternion type represented using a scalar \\\\f$w\\\\f$ or \\\\f$q_0\\\\f$ and a\\n * 3D vector \\\\f$\\\\left(q_1,q_2,q_3\\\\right)\\\\f$\\n */\\ntypedef struct quaternion_\\n{\\n    union\\n    {\\n        float w;  /**< real part of quaternion */\\n        float q0; /**< real part of quaternion */\\n    };\\n    /**< dual part of quaternion */\\n    union\\n    {\\n        vec_3d dual; /**< can be a 3D vector */\\n        /** or individual values */\\n        struct\\n        {\\n            float q1, q2, q3;\\n        };\\n    };\\n} quaternion;\\n\\n/** 3D Euler or Tait-Bryan angles (in radian) */\\ntypedef struct euler_\\n{\\n    union\\n    {\\n        float roll; /**< or bank \\\\f$\\\\phi\\\\f$ = rotation about X axis */\\n        float bank; /**< or roll \\\\f$\\\\phi\\\\f$ = rotation about X axis */\\n    };\\n    union\\n    {\\n        float pitch; /**< or elevation \\\\f$\\\\theta\\\\f$ = rotation about Y axis */\\n        float elevation; /**< or pitch \\\\f$\\\\theta\\\\f$ = rotation about Y axis */\\n    };\\n    union\\n    {\\n        float yaw;     /**< or heading \\\\f$\\\\psi\\\\f$ = rotation about Z axis */\\n        float heading; /**< or yaw \\\\f$\\\\psi\\\\f$ = rotation about Z axis */\\n    };\\n} euler;\\n\\n/** @} */\\n\\n/** @addtogroup dual_quats 3D Dual-Quaternion operations\\n * @{\\n */\\n/** a dual quaternion type */\\ntypedef struct dual_quat_\\n{\\n    quaternion real; /**< real part of dual quaternion */\\n    quaternion dual; /**< dual part of dual quaternion */\\n} dual_quat;\\n\\n/** @} */\\n\\n#endif  // __LIBQUAT_H_\\n\\n/** @} */\\n\"",
    "quaternions": "\"/**\\n * @file\\n * @brief Functions related to 3D quaternions and Euler angles.\\n * @author Krishna Vedala\\n */\\n\\n#include <stdio.h>\\n#ifdef __arm__  // if compiling for ARM-Cortex processors\\n#define LIBQUAT_ARM\\n#include <arm_math.h>\\n#else\\n#include <math.h>\\n#endif\\n#include <assert.h>\\n\\n#include \\\"geometry_datatypes.h\\\"\\n\\n/**\\n * @addtogroup quats 3D Quaternion operations\\n * @{\\n */\\n\\n/**\\n * Function to convert given Euler angles to a quaternion.\\n * \\\\f{eqnarray*}{\\n * q_{0} & =\\n * &\\\\cos\\\\left(\\\\frac{\\\\phi}{2}\\\\right)\\\\cos\\\\left(\\\\frac{\\\\theta}{2}\\\\right)\\\\cos\\\\left(\\\\frac{\\\\psi}{2}\\\\right)\\n * +\\n * \\\\sin\\\\left(\\\\frac{\\\\phi}{2}\\\\right)\\\\sin\\\\left(\\\\frac{\\\\theta}{2}\\\\right)\\\\sin\\\\left(\\\\frac{\\\\psi}{2}\\\\right)\\\\\\\\\\n * q_{1} & =\\n * &\\\\sin\\\\left(\\\\frac{\\\\phi}{2}\\\\right)\\\\cos\\\\left(\\\\frac{\\\\theta}{2}\\\\right)\\\\cos\\\\left(\\\\frac{\\\\psi}{2}\\\\right)\\n * -\\n * \\\\cos\\\\left(\\\\frac{\\\\phi}{2}\\\\right)\\\\sin\\\\left(\\\\frac{\\\\theta}{2}\\\\right)\\\\sin\\\\left(\\\\frac{\\\\psi}{2}\\\\right)\\\\\\\\\\n * q_{2} & =\\n * &\\\\cos\\\\left(\\\\frac{\\\\phi}{2}\\\\right)\\\\sin\\\\left(\\\\frac{\\\\theta}{2}\\\\right)\\\\cos\\\\left(\\\\frac{\\\\psi}{2}\\\\right)\\n * +\\n * \\\\sin\\\\left(\\\\frac{\\\\phi}{2}\\\\right)\\\\cos\\\\left(\\\\frac{\\\\theta}{2}\\\\right)\\\\sin\\\\left(\\\\frac{\\\\psi}{2}\\\\right)\\\\\\\\\\n * q_{3} & =\\n * &\\\\cos\\\\left(\\\\frac{\\\\phi}{2}\\\\right)\\\\cos\\\\left(\\\\frac{\\\\theta}{2}\\\\right)\\\\sin\\\\left(\\\\frac{\\\\psi}{2}\\\\right)\\n * -\\n * \\\\sin\\\\left(\\\\frac{\\\\phi}{2}\\\\right)\\\\sin\\\\left(\\\\frac{\\\\theta}{2}\\\\right)\\\\cos\\\\left(\\\\frac{\\\\psi}{2}\\\\right)\\\\\\\\\\n * \\\\f}\\n *\\n * @param [in] in_euler input Euler angles instance\\n * @returns converted quaternion\\n */\\nquaternion quat_from_euler(const euler *in_euler)\\n{\\n    quaternion out_quat;\\n\\n    if (!in_euler)  // if null\\n    {\\n        fprintf(stderr, \\\"%s: Invalid input.\\\", __func__);\\n        return out_quat;\\n    }\\n\\n    quaternion temp;\\n\\n    float cy = cosf(in_euler->yaw * 0.5f);\\n    float sy = sinf(in_euler->yaw * 0.5f);\\n    float cp = cosf(in_euler->pitch * 0.5f);\\n    float sp = sinf(in_euler->pitch * 0.5f);\\n    float cr = cosf(in_euler->roll * 0.5f);\\n    float sr = sinf(in_euler->roll * 0.5f);\\n\\n    temp.w = cr * cp * cy + sr * sp * sy;\\n    temp.q1 = sr * cp * cy - cr * sp * sy;\\n    temp.q2 = cr * sp * cy + sr * cp * sy;\\n    temp.q3 = cr * cp * sy - sr * sp * cy;\\n\\n    return temp;\\n}\\n\\n/**\\n * Function to convert given quaternion to Euler angles.\\n * \\\\f{eqnarray*}{\\n * \\\\phi & = &\\n * \\\\tan^{-1}\\\\left[\\\\frac{2\\\\left(q_0q_1+q_2q_3\\\\right)}{1-2\\\\left(q_1^2+q_2^2\\\\right)}\\\\right]\\\\\\\\\\n * \\\\theta & =\\n * &-\\\\sin^{-1}\\\\left[2\\\\left(q_0q_2-q_3q_1\\\\right)\\\\right]\\\\\\\\\\n * \\\\psi & = &\\n * \\\\tan^{-1}\\\\left[\\\\frac{2\\\\left(q_0q_3+q_1q_2\\\\right)}{1-2\\\\left(q_2^2+q_3^2\\\\right)}\\\\right]\\\\\\\\\\n * \\\\f}\\n *\\n * @param [in] in_quat input quaternion instance\\n * @returns converted euler angles\\n */\\neuler euler_from_quat(const quaternion *in_quat)\\n{\\n    euler out_euler;\\n    if (!in_quat)  // if null\\n    {\\n        fprintf(stderr, \\\"%s: Invalid input.\\\", __func__);\\n        return out_euler;\\n    }\\n\\n    out_euler.roll = atan2f(\\n        2.f * (in_quat->w * in_quat->q1 + in_quat->q2 * in_quat->q3),\\n        1.f - 2.f * (in_quat->q1 * in_quat->q1 + in_quat->q2 * in_quat->q2));\\n    out_euler.pitch =\\n        asinf(2.f * (in_quat->w * in_quat->q2 + in_quat->q1 * in_quat->q3));\\n    out_euler.yaw = atan2f(\\n        2.f * (in_quat->w * in_quat->q3 + in_quat->q1 * in_quat->q2),\\n        1.f - 2.f * (in_quat->q2 * in_quat->q2 + in_quat->q3 * in_quat->q3));\\n\\n    return out_euler;\\n}\\n\\n/**\\n * Function to multiply two quaternions.\\n * \\\\f{eqnarray*}{\\n * \\\\mathbf{c} & = & \\\\mathbf{a}\\\\otimes\\\\mathbf{b}\\\\\\\\\\n * & = & \\\\begin{bmatrix}a_{0} & a_{1} & a_{2} &\\n *  a_{3}\\\\end{bmatrix}\\\\otimes\\\\begin{bmatrix}b_{0} & b_{1} & b_{2} &\\n *  b_{3}\\\\end{bmatrix}\\\\\\\\\\n * & = &\\n * \\\\begin{bmatrix}\\n *  a_{0}b_{0}-a_{1}b_{1}-a_{2}b_{2}-a_{3}b_{3}\\\\\\\\\\n *  a_{0}b_{1}+a_{1}b_{0}+a_{2}b_{3}-a_{3}b_{2}\\\\\\\\\\n *  a_{0}b_{2}-a_{1}b_{3}+a_{2}b_{0}+a_{3}b_{1}\\\\\\\\\\n *  a_{0}b_{3}+a_{1}b_{2}-a_{2}b_{1}+a_{3}b_{0}\\n * \\\\end{bmatrix}^{T}\\n * \\\\f}\\n *\\n * @param [in] in_quat1 first input quaternion instance\\n * @param [in] in_quat2 second input quaternion instance\\n * @returns resultant quaternion\\n */\\nquaternion quaternion_multiply(const quaternion *in_quat1,\\n                               const quaternion *in_quat2)\\n{\\n    quaternion out_quat;\\n    if (!in_quat1 || !in_quat2)  // if null\\n    {\\n        fprintf(stderr, \\\"%s: Invalid input.\\\", __func__);\\n        return out_quat;\\n    }\\n\\n    out_quat.w = in_quat1->w * in_quat2->w - in_quat1->q1 * in_quat2->q1 -\\n                 in_quat1->q2 * in_quat2->q2 - in_quat1->q3 * in_quat2->q3;\\n    out_quat.q1 = in_quat1->w * in_quat2->q1 + in_quat1->q1 * in_quat2->w +\\n                  in_quat1->q2 * in_quat2->q3 - in_quat1->q3 * in_quat2->q2;\\n    out_quat.q2 = in_quat1->w * in_quat2->q2 - in_quat1->q1 * in_quat2->q3 +\\n                  in_quat1->q2 * in_quat2->w + in_quat1->q3 * in_quat2->q1;\\n    out_quat.q3 = in_quat1->w * in_quat2->q3 + in_quat1->q1 * in_quat2->q2 -\\n                  in_quat1->q2 * in_quat2->q1 + in_quat1->q3 * in_quat2->w;\\n\\n    return out_quat;\\n}\\n\\n/** @} */\\n\\nstatic void test()\\n{\\n    quaternion quat = {0.7071f, 0.7071f, 0.f, 0.f};\\n    euler eul = euler_from_quat(&quat);\\n    printf(\\\"Euler: %.4g, %.4g, %.4g\\\\n\\\", eul.pitch, eul.roll, eul.yaw);\\n\\n    quaternion test_quat = quat_from_euler(&eul);\\n    printf(\\\"Quaternion: %.4g %+.4g %+.4g %+.4g\\\\n\\\", test_quat.w,\\n           test_quat.dual.x, test_quat.dual.y, test_quat.dual.z);\\n\\n    assert(fabsf(test_quat.w - quat.w) < .01);\\n    assert(fabsf(test_quat.q1 - quat.q1) < .01);\\n    assert(fabsf(test_quat.q2 - quat.q2) < .01);\\n    assert(fabsf(test_quat.q3 - quat.q3) < .01);\\n}\\n\\nint main()\\n{\\n    test();\\n    return 0;\\n}\\n\"",
    "vectors 3d": "\"/**\\n * @file\\n * @brief Functions related to 3D vector operations.\\n * @author Krishna Vedala\\n */\\n\\n#include <stdio.h>\\n#ifdef __arm__  // if compiling for ARM-Cortex processors\\n#define LIBQUAT_ARM\\n#include <arm_math.h>\\n#else\\n#include <math.h>\\n#endif\\n#include <assert.h>\\n\\n#include \\\"geometry_datatypes.h\\\"\\n\\n/**\\n * @addtogroup vec_3d 3D Vector operations\\n * @{\\n */\\n\\n/**\\n * Subtract one vector from another. @f[\\n * \\\\vec{c}=\\\\vec{a}-\\\\vec{b}=\\\\left(a_x-b_x\\\\right)\\\\hat{i}+\\n * \\\\left(a_y-b_y\\\\right)\\\\hat{j}+\\\\left(a_z-b_z\\\\right)\\\\hat{k}@f]\\n * @param[in] a vector to subtract from\\n * @param[in] b vector to subtract\\n * @returns resultant vector\\n */\\nvec_3d vector_sub(const vec_3d *a, const vec_3d *b)\\n{\\n    vec_3d out;\\n#ifdef LIBQUAT_ARM\\n    arm_sub_f32((float *)a, (float *)b, (float *)&out);\\n#else\\n    out.x = a->x - b->x;\\n    out.y = a->y - b->y;\\n    out.z = a->z - b->z;\\n#endif\\n\\n    return out;\\n}\\n\\n/**\\n * Add one vector to another. @f[\\n * \\\\vec{c}=\\\\vec{a}+\\\\vec{b}=\\\\left(a_x+b_x\\\\right)\\\\hat{i}+\\n * \\\\left(a_y+b_y\\\\right)\\\\hat{j}+\\\\left(a_z+b_z\\\\right)\\\\hat{k}@f]\\n * @param[in] a vector to add to\\n * @param[in] b vector to add\\n * @returns resultant vector\\n */\\nvec_3d vector_add(const vec_3d *a, const vec_3d *b)\\n{\\n    vec_3d out;\\n#ifdef LIBQUAT_ARM\\n    arm_add_f32((float *)a, (float *)b, (float *)&out);\\n#else\\n    out.x = a->x + b->x;\\n    out.y = a->y + b->y;\\n    out.z = a->z + b->z;\\n#endif\\n\\n    return out;\\n}\\n\\n/**\\n * Obtain the dot product of two 3D vectors.\\n * @f[\\n * \\\\vec{a}\\\\cdot\\\\vec{b}=a_xb_x + a_yb_y + a_zb_z\\n * @f]\\n * @param[in] a first vector\\n * @param[in] b second vector\\n * @returns resulting dot product\\n */\\nfloat dot_prod(const vec_3d *a, const vec_3d *b)\\n{\\n    float dot;\\n#ifdef LIBQUAT_ARM\\n    arm_dot_prod_f32((float *)a, (float *)b, &dot);\\n#else\\n    dot = a->x * b->x;\\n    dot += a->y * b->y;\\n    dot += a->z * b->z;\\n#endif\\n\\n    return dot;\\n}\\n\\n/**\\n * Compute the vector product of two 3d vectors.\\n * @f[\\\\begin{align*}\\n * \\\\vec{a}\\\\times\\\\vec{b} &= \\\\begin{vmatrix}\\n *  \\\\hat{i} & \\\\hat{j} & \\\\hat{k}\\\\\\\\\\n *  a_x & a_y & a_z\\\\\\\\\\n *  b_x & b_y & b_z\\n *  \\\\end{vmatrix}\\\\\\\\\\n *  &= \\\\left(a_yb_z-b_ya_z\\\\right)\\\\hat{i} - \\\\left(a_xb_z-b_xa_z\\\\right)\\\\hat{j}\\n * + \\\\left(a_xb_y-b_xa_y\\\\right)\\\\hat{k} \\\\end{align*}\\n * @f]\\n * @param[in] a first vector @f$\\\\vec{a}@f$\\n * @param[in] b second vector @f$\\\\vec{b}@f$\\n * @returns resultant vector @f$\\\\vec{o}=\\\\vec{a}\\\\times\\\\vec{b}@f$\\n */\\nvec_3d vector_prod(const vec_3d *a, const vec_3d *b)\\n{\\n    vec_3d out;  // better this way to avoid copying results to input\\n                 // vectors themselves\\n    out.x = a->y * b->z - a->z * b->y;\\n    out.y = -a->x * b->z + a->z * b->x;\\n    out.z = a->x * b->y - a->y * b->x;\\n\\n    return out;\\n}\\n\\n/**\\n * Print formatted vector on stdout.\\n * @param[in] a vector to print\\n * @param[in] name  name of the vector\\n * @returns string representation of vector\\n */\\nconst char *print_vector(const vec_3d *a, const char *name)\\n{\\n    static char vec_str[100];  // static to ensure the string life extends the\\n                               // life of function\\n\\n    snprintf(vec_str, 99, \\\"vec(%s) = (%.3g)i + (%.3g)j + (%.3g)k\\\\n\\\", name, a->x,\\n             a->y, a->z);\\n    return vec_str;\\n}\\n\\n/**\\n * Compute the norm a vector.\\n * @f[\\\\lVert\\\\vec{a}\\\\rVert = \\\\sqrt{\\\\vec{a}\\\\cdot\\\\vec{a}} @f]\\n * @param[in] a input vector\\n * @returns norm of the given vector\\n */\\nfloat vector_norm(const vec_3d *a)\\n{\\n    float n = dot_prod(a, a);\\n#ifdef LIBQUAT_ARM\\n    arm_sqrt_f32(*n, n);\\n#else\\n    n = sqrtf(n);\\n#endif\\n\\n    return n;\\n}\\n\\n/**\\n * Obtain unit vector in the same direction as given vector.\\n * @f[\\\\hat{a}=\\\\frac{\\\\vec{a}}{\\\\lVert\\\\vec{a}\\\\rVert}@f]\\n * @param[in] a input vector\\n * @returns n unit vector in the direction of @f$\\\\vec{a}@f$\\n */\\nvec_3d unit_vec(const vec_3d *a)\\n{\\n    vec_3d n = {0};\\n\\n    float norm = vector_norm(a);\\n    if (fabsf(norm) < EPSILON)\\n    {  // detect possible divide by 0\\n        return n;\\n    }\\n\\n    if (norm != 1.F)  // perform division only if needed\\n    {\\n        n.x = a->x / norm;\\n        n.y = a->y / norm;\\n        n.z = a->z / norm;\\n    }\\n    return n;\\n}\\n\\n/**\\n * The cross product of vectors can be represented as a matrix\\n * multiplication operation. This function obtains the `3x3` matrix\\n * of the cross-product operator from the first vector.\\n * @f[\\\\begin{align*}\\n * \\\\left(\\\\vec{a}\\\\times\\\\right)\\\\vec{b} &= \\\\tilde{A}_a\\\\vec{b}\\\\\\\\\\n * \\\\tilde{A}_a &=\\n * \\\\begin{bmatrix}0&-a_z&a_y\\\\\\\\a_z&0&-a_x\\\\\\\\-a_y&a_x&0\\\\end{bmatrix}\\n * \\\\end{align*}@f]\\n * @param[in] a input vector\\n * @returns the `3x3` matrix for the cross product operator\\n * @f$\\\\left(\\\\vec{a}\\\\times\\\\right)@f$\\n */\\nmat_3x3 get_cross_matrix(const vec_3d *a)\\n{\\n    mat_3x3 A = {0., -a->z, a->y, a->z, 0., -a->x, -a->y, a->x, 0.};\\n    return A;\\n}\\n\\n/**\\n * Obtain the angle between two given vectors.\\n * @f[\\\\alpha=acos\\\\left(\\\\frac{\\\\vec{a} \\\\cdot \\\\vec{b}}{\\\\lVert\\\\vec{a}\\\\rVert \\\\cdot \\\\lVert\\\\vec{b}\\\\rVert}\\\\right)@f]\\n * @param[in] a first input vector\\n * @param[in] b second input vector\\n * @returns angle between @f$\\\\vec{a}@f$ and @f$\\\\vec{b}@f$ in radians\\n */\\n\\ndouble get_angle(const vec_3d *a, const vec_3d *b)\\n{\\n    double alpha, cos_alpha;\\n    float norm_a = vector_norm(a); ///< The norm of vector a\\n    float norm_b = vector_norm(b); ///< The norm of vector b\\n    if (fabsf(norm_a) < EPSILON || fabsf(norm_b) < EPSILON) /// detect possible division by 0 - the angle is not defined in this case\\n    {  \\n        return NAN; \\n    }\\n\\n    cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\\n    alpha = acos(cos_alpha); // delivers the radian\\n    return alpha; // in range from -1 to 1\\n}\\n\\n/** @} */\\n\\n/**\\n * @brief Testing function\\n * @returns `void`\\n */\\nstatic void test()\\n{\\n    vec_3d a = {1., 2., 3.};\\n    vec_3d b = {1., 1., 1.};\\n    float d;\\n\\n    // printf(\\\"%s\\\", print_vector(&a, \\\"a\\\"));\\n    // printf(\\\"%s\\\", print_vector(&b, \\\"b\\\"));\\n\\n    d = vector_norm(&a);\\n    // printf(\\\"|a| = %.4g\\\\n\\\", d);\\n    assert(fabsf(d - 3.742f) < 0.01);\\n    d = vector_norm(&b);\\n    // printf(\\\"|b| = %.4g\\\\n\\\", d);\\n    assert(fabsf(d - 1.732f) < 0.01);\\n\\n    d = dot_prod(&a, &b);\\n    // printf(\\\"Dot product: %f\\\\n\\\", d);\\n    assert(fabsf(d - 6.f) < 0.01);\\n\\n    vec_3d c = vector_prod(&a, &b);\\n    // printf(\\\"Vector product \\\");\\n    // printf(\\\"%s\\\", print_vector(&c, \\\"c\\\"));\\n    assert(fabsf(c.x - (-1.f)) < 0.01);\\n    assert(fabsf(c.y - (2.f)) < 0.01);\\n    assert(fabsf(c.z - (-1.f)) < 0.01);\\n\\n    double alpha = get_angle(&a, &b);\\n    // printf(\\\"The angle is %f\\\\n\\\", alpha);\\n    assert(fabsf(alpha - 0.387597) < 0.01);\\n}\\n\\n/**\\n * @brief Main function\\n *\\n * @return 0 on exit\\n */\\nint main(void)\\n{\\n    test();\\n\\n    return 0;\\n}\\n\"",
    "spirograph": "\"/**\\n * @file\\n * @author [Krishna Vedala](https://github.com/kvedala)\\n * @brief Implementation of\\n * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)\\n *\\n * @details\\n * Implementation of the program is based on the geometry shown in the figure\\n * below:\\n *\\n * <a\\n * href=\\\"https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg\\\"><img\\n * src=\\\"https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg\\\"\\n * alt=\\\"Spirograph geometry from Wikipedia\\\" style=\\\"width: 250px\\\"/></a>\\n */\\n#define _USE_MATH_DEFINES /**< required for MSVC compiler */\\n#include <math.h>\\n#include <stdbool.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n/** Generate spirograph curve into arrays `x` and `y` such that the i^th point\\n * in 2D is represented by `(x[i],y[i])`. The generating function is given by:\\n * \\\\f{eqnarray*}{\\n * x &=& R\\\\left[ (1-k) \\\\cos (t) + l\\\\cdot k\\\\cdot\\\\cos \\\\left(\\\\frac{1-k}{k}t\\\\right)\\n * \\\\right]\\\\\\\\\\n * y &=& R\\\\left[ (1-k) \\\\sin (t) - l\\\\cdot k\\\\cdot\\\\sin \\\\left(\\\\frac{1-k}{k}t\\\\right)\\n * \\\\right] \\\\f}\\n * where\\n * * \\\\f$R\\\\f$ is the scaling parameter that we will consider \\\\f$=1\\\\f$\\n * * \\\\f$l=\\\\frac{\\\\rho}{r}\\\\f$ is the relative distance of marker from the centre\\n * of inner circle and \\\\f$0\\\\le l\\\\le1\\\\f$\\n * * \\\\f$\\\\rho\\\\f$ is physical distance of marker from centre of inner circle\\n * * \\\\f$r\\\\f$ is the radius of inner circle\\n * * \\\\f$k=\\\\frac{r}{R}\\\\f$ is the ratio of radius of inner circle to outer circle\\n * and \\\\f$0<k<1\\\\f$\\n * * \\\\f$R\\\\f$ is the radius of outer circle\\n * * \\\\f$t\\\\f$ is the angle of rotation of the point i.e., represents the time\\n * parameter\\n *\\n * Since we are considering ratios, the actual values of \\\\f$r\\\\f$ and\\n * \\\\f$R\\\\f$ are immaterial.\\n *\\n * @param [out] x output array containing absicca of points (must be\\n * pre-allocated)\\n * @param [out] y output array containing ordinates of points (must be\\n * pre-allocated)\\n * @param l the relative distance of marker from the centre of\\n * inner circle and \\\\f$0\\\\le l\\\\le1\\\\f$\\n * @param k the ratio of radius of inner circle to outer circle and\\n * \\\\f$0<k<1\\\\f$\\n * @param N number of sample points along the trajectory (higher = better\\n * resolution but consumes more time and memory)\\n * @param num_rot the number of rotations to perform (can be fractional value)\\n */\\nvoid spirograph(double *x, double *y, double l, double k, size_t N, double rot)\\n{\\n    double dt = rot * 2.f * M_PI / N;\\n    double t = 0.f, R = 1.f;\\n    const double k1 = 1.f - k;\\n\\n    for (size_t dk = 0; dk < N; dk++, t += dt)\\n    {\\n        x[dk] = R * (k1 * cos(t) + l * k * cos(k1 * t / k));\\n        y[dk] = R * (k1 * sin(t) - l * k * sin(k1 * t / k));\\n    }\\n}\\n\\n/**\\n * @brief Test function to save resulting points to a CSV file.\\n *\\n */\\nvoid test(void)\\n{\\n    size_t N = 500;\\n    double l = 0.3, k = 0.75, rot = 10.;\\n    char fname[50];\\n    snprintf(fname, 50, \\\"spirograph_%.2f_%.2f_%.2f.csv\\\", l, k, rot);\\n    FILE *fp = fopen(fname, \\\"wt\\\");\\n    if (!fp)\\n    {\\n        perror(fname);\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    double *x = (double *)malloc(N * sizeof(double));\\n    double *y = (double *)malloc(N * sizeof(double));\\n\\n    spirograph(x, y, l, k, N, rot);\\n\\n    for (size_t i = 0; i < N; i++)\\n    {\\n        fprintf(fp, \\\"%.5g, %.5g\\\", x[i], y[i]);\\n        if (i < N - 1)\\n        {\\n            fputc('\\\\n', fp);\\n        }\\n    }\\n\\n    fclose(fp);\\n\\n    free(x);\\n    free(y);\\n}\\n\\n#ifdef USE_GLUT  // this is set by CMAKE automatically, if available\\n#ifdef __APPLE__\\n#include <GLUT/glut.h>  // include path on Macs is different\\n#else\\n#include <GL/glut.h>\\n#endif\\n\\nstatic bool paused = 0; /**< flag to set pause/unpause animation */\\nstatic const int animation_speed = 25; /**< animation delate in ms */\\n\\nstatic const double step = 0.01;   /**< animation step size */\\nstatic double l_ratio = 0.1;       /**< the l-ratio defined in docs */\\nstatic double k_ratio = 0.1;       /**< the k-ratio defined in docs */\\nstatic const double num_rot = 20.; /**< number of rotations to simulate */\\n\\n/** A wrapper that is not available in all GLUT implementations.\\n */\\nstatic inline void glutBitmapString(void *font, char *string)\\n{\\n    for (char *ch = string; *ch != '\\\\0'; ch++) glutBitmapCharacter(font, *ch);\\n}\\n\\n/**\\n * @brief Function to graph (x,y) points on the OpenGL graphics window.\\n *\\n * @param x array containing absicca of points (must be pre-allocated)\\n * @param y array containing ordinates of points (must be pre-allocated)\\n * @param N number of points in the the arrays\\n */\\nvoid display_graph(const double *x, const double *y, size_t N, double l,\\n                   double k)\\n{\\n    glClearColor(1.0f, 1.0f, 1.0f,\\n                 0.0f);            // Set background color to white and opaque\\n    glClear(GL_COLOR_BUFFER_BIT);  // Clear the color buffer (background)\\n\\n    if (x && y)\\n    {\\n        glBegin(GL_LINES);         // draw line segments\\n        glColor3f(0.f, 0.f, 1.f);  // blue\\n        glPointSize(2.f);          // point size in pixels\\n\\n        for (size_t i = 1; i < N; i++)\\n        {\\n            glVertex2f(x[i - 1], y[i - 1]);  // line from\\n            glVertex2f(x[i], y[i]);          // line to\\n        }\\n        glEnd();\\n    }\\n    glColor3f(0.f, 0.f, 0.f);\\n    char buffer[20];\\n    snprintf(buffer, 20, \\\"l = %.3f\\\", l);\\n    glRasterPos2f(-.85, .85);\\n    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);\\n    snprintf(buffer, 20, \\\"k = %.3f\\\", k);\\n    glRasterPos2f(-.85, .75);\\n    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);\\n\\n    glutSwapBuffers();\\n}\\n\\n/**\\n * @brief Test function with animation\\n *\\n */\\nvoid test2(void)\\n{\\n    const size_t N = 1000;  // number of samples\\n\\n    static bool direction1 = true;  // increment if true, otherwise decrement\\n    static bool direction2 = true;  // increment if true, otherwise decrement\\n\\n    double *x = (double *)malloc(N * sizeof(double));\\n    double *y = (double *)malloc(N * sizeof(double));\\n\\n    spirograph(x, y, l_ratio, k_ratio, N, num_rot);\\n    display_graph(x, y, N, l_ratio, k_ratio);\\n\\n    free(x);  // free dynamic memories\\n    free(y);\\n\\n    if (paused)\\n        // if paused, do not update l_ratio and k_ratio\\n        return;\\n\\n    if (direction1)  // increment k_ratio\\n    {\\n        if (k_ratio >= (1.f - step))  // maximum limit\\n            direction1 = false;       // reverse direction of k_ratio\\n        else\\n            k_ratio += step;\\n    }\\n    else  // decrement k_ratio\\n    {\\n        if (k_ratio <= step)  // minimum limit\\n        {\\n            direction1 = true;  // reverse direction of k_ratio\\n\\n            if (direction2)  // increment l_ratio\\n            {\\n                if (l_ratio >= (1.f - step))  // max limit of l_ratio\\n                    direction2 = false;       // reverse direction of l_ratio\\n                else\\n                    l_ratio += step;\\n            }\\n            else  // decrement l_ratio\\n            {\\n                if (l_ratio <= step)    // minimum limit of l_ratio\\n                    direction2 = true;  // reverse direction of l_ratio\\n                else\\n                    l_ratio -= step;\\n            }\\n        }\\n        else  // no min limit of k_ratio\\n            k_ratio -= step;\\n    }\\n}\\n\\n/**\\n * @brief GLUT timer callback function to add animation delay.\\n */\\nvoid timer_cb(int id)\\n{\\n    glutPostRedisplay();\\n    glutTimerFunc(animation_speed, timer_cb, 0);\\n}\\n\\n/**\\n * @brief Keypress event call back function.\\n *\\n * @param key ID of the key pressed\\n * @param x mouse pointer position at event\\n * @param y mouse pointer position at event\\n */\\nvoid keyboard_cb(unsigned char key, int x, int y)\\n{\\n    switch (key)\\n    {\\n    case ' ':              // spacebar toggles pause\\n        paused = !paused;  // toggle\\n        break;\\n    case '+':  // up arrow key\\n        k_ratio += step;\\n        display_graph(NULL, NULL, 1, l_ratio, k_ratio);\\n        break;\\n    case '_':  // down arrow key\\n        k_ratio -= step;\\n        display_graph(NULL, NULL, 1, l_ratio, k_ratio);\\n        break;\\n    case '=':  // left arrow key\\n        l_ratio += step;\\n        display_graph(NULL, NULL, 1, l_ratio, k_ratio);\\n        break;\\n    case '-':  // right arrow key\\n        l_ratio -= step;\\n        display_graph(NULL, NULL, 1, l_ratio, k_ratio);\\n        break;\\n    case 0x1B:  // escape key exits\\n        exit(EXIT_SUCCESS);\\n    }\\n}\\n#endif\\n\\n/** Main function */\\nint main(int argc, char **argv)\\n{\\n    test();\\n\\n#ifdef USE_GLUT\\n    glutInit(&argc, argv);\\n    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);\\n    glutCreateWindow(\\\"Spirograph\\\");\\n    glutInitWindowSize(400, 400);\\n    // glutIdleFunc(glutPostRedisplay);\\n    glutTimerFunc(animation_speed, timer_cb, 0);\\n    glutKeyboardFunc(keyboard_cb);\\n    glutDisplayFunc(test2);\\n    glutMainLoop();\\n#endif\\n\\n    return 0;\\n}\\n\"",
    "djikstra": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAX 20\\n#define INF 999\\n\\nint mat[MAX][MAX];\\nint V;\\n\\nint dist[MAX];\\n\\nint q[MAX];\\nint qp = 0;\\n\\nvoid enqueue(int v) { q[qp++] = v; }\\n\\nint cf(void *a, void *b)\\n{\\n    int *x = (int *)a;\\n    int *y = (int *)b;\\n    return *y - *x;\\n}\\n\\nint dequeue()\\n{\\n    qsort(q, qp, sizeof(int), cf);\\n    return q[--qp];\\n}\\n\\nint queue_has_something() { return (qp > 0); }\\n\\nint visited[MAX];\\nint vp = 0;\\n\\nvoid dijkstra(int s)\\n{\\n    dist[s] = 0;\\n    int i;\\n    for (i = 0; i < V; ++i)\\n    {\\n        if (i != s)\\n        {\\n            dist[i] = INF;\\n        }\\n        enqueue(i);\\n    }\\n    while (queue_has_something())\\n    {\\n        int u = dequeue();\\n        visited[vp++] = u;\\n        for (i = 0; i < V; ++i)\\n        {\\n            if (mat[u][i])\\n            {\\n                if (dist[i] > dist[u] + mat[u][i])\\n                {\\n                    dist[i] = dist[u] + mat[u][i];\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nint main(int argc, char const *argv[])\\n{\\n    printf(\\\"Enter the number of vertices: \\\");\\n    scanf(\\\" %d\\\", &V);\\n    printf(\\\"Enter the adj matrix: \\\");\\n    int i, j;\\n    for (i = 0; i < V; ++i)\\n    {\\n        for (j = 0; j < V; ++j)\\n        {\\n            scanf(\\\" %d\\\", &mat[i][j]);\\n        }\\n    }\\n\\n    dijkstra(0);\\n\\n    printf(\\\"\\\\nNode\\\\tDist\\\\n\\\");\\n    for (i = 0; i < V; ++i)\\n    {\\n        printf(\\\"%d\\\\t%d\\\\n\\\", i, dist[i]);\\n    }\\n\\n    return 0;\\n}\\n\"",
    "prim": "\"/**\\n * @file\\n * @author [Timothy Maloney](https://github.com/sl1mb0)\\n * @brief [Prim's algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)\\n * implementation in C to find the MST of a weighted, connected graph.\\n * @details Prim's algorithm uses a greedy approach to generate the MST of a weighted connected graph.\\n * The algorithm begins at an arbitrary vertex v, and selects a next vertex u, \\n * where v and u are connected by a weighted edge whose weight is the minimum of all edges connected to v. \\n * @references Page 319 \\\"Introduction to the Design and Analysis of Algorithms\\\" - Anany Levitin\\n *\\n * To test - run './prim -test'\\n * prim() will find the MST of the following adj. matrix:\\n *\\t  \\n *\\t  0  1  2  3\\n *        1  0  4  6\\n *        2  4  0  5\\n *        3  6  5  0\\n * \\n * The minimum spanning tree for the above weighted connected graph is given by the following adj matrix:\\n *\\t   \\n *\\t  0  1  2  3\\n *\\t  1  0  0  0\\n *\\t  2  0  0  0\\n *\\t  3  0  0  0\\n *\\n *\\n * The following [link](https://visualgo.net/en/mst) provides a visual representation of graphs that can be used to test/verify the algorithm for different adj\\n * matrices and their weighted, connected graphs.\\n */\\n\\n#include <stdio.h>        /// for IO operations\\n#include <string.h>      /// for string comparison\\n#include <assert.h>     /// for assert()\\n#include <inttypes.h>  /// for uint16_t\\n\\n#define MAX 20\\n#define INF 999\\n\\n/**\\n * @brief Finds index of minimum element in edge list for an arbitrary vertex\\n * @param arr graph row\\n * @param N number of elements in arr\\n * @returns index of minimum element in arr\\n */\\nuint16_t minimum(uint16_t arr[], uint16_t N)\\n{\\n    uint16_t index = 0;\\n    uint16_t min = INF;\\n\\n    for (uint16_t i = 0; i < N; i++)\\n    {\\n        if (arr[i] < min)\\n        {\\n            min = arr[i];\\n            index = i;\\n        }\\n    }\\n    return index;\\n}\\n\\n/**\\n * @brief Used to find MST of user-generated adj matrix G\\n * @returns void\\n */\\nvoid prim(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)\\n{\\n    uint16_t u, v;\\n    uint16_t E_t[MAX], path[MAX];\\n    uint16_t V_t[MAX], no_of_edges;\\n\\n    E_t[0] = 0;  // edges for current vertex\\n    V_t[0] = 1;  // list of visited vertices\\n\\n    for (uint16_t i = 1; i < V; i++)\\n    {\\n        E_t[i] = G[i][0];\\n        path[i] = 0;\\n        V_t[i] = 0;\\n    }\\n\\n    no_of_edges = V - 1;\\n\\n    while (no_of_edges > 0)\\n    {\\n        u = minimum(E_t, V);\\n        while (V_t[u] == 1)\\n        {\\n            E_t[u] = INF;\\n            u = minimum(E_t, V);\\n        }\\n\\n        v = path[u];\\n        MST[v][u] = E_t[u];\\n        MST[u][v] = E_t[u];\\n        no_of_edges--;\\n        V_t[u] = 1;\\n\\n        for (uint16_t i = 1; i < V; i++)\\n        {\\n            if (V_t[i] == 0 && G[u][i] < E_t[i])\\n            {\\n                E_t[i] = G[u][i];\\n                path[i] = v;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)\\n{\\n \\n  uint16_t test[4][4] = {{0,1,2,3},{1,0,4,6},{2,4,0,5},{3,6,5,0}};\\n  uint16_t solution[4][4] = {{0,1,2,3},{1,0,0,0},{2,0,0,0},{3,0,0,0}};\\n\\n  V = 4;\\n\\n  for(uint16_t i = 0; i < V; ++i)\\n  {\\n    for(uint16_t j = 0; j < V; ++j)\\n    {\\n      G[i][j] = test[i][j];\\n    }\\n  }\\n\\n  prim(&(*G),&(*MST),V);\\n\\n  for(uint16_t i = 0; i < V; ++i)\\n  {\\n    for(uint16_t j = 0; j < V; ++j)\\n    {\\n      assert(MST[i][j] == solution[i][j]);\\n    }\\n  }\\n}\\n\\n/**\\n * @brief Function user_graph();\\n * gets user input adj. matrix and finds MST of that graph\\n * @returns void\\n */\\nvoid user_graph(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)\\n{\\n      printf(\\\"Enter the number of vertices: \\\");\\n      scanf(\\\" %hd\\\", &V);\\n\\n      assert(V <= MAX);\\n\\n      printf(\\\"Enter the adj matrix\\\\n\\\");\\n      uint16_t i, j;\\n      for (i = 0; i < V; ++i)\\n      {\\n          for (j = 0; j < V; ++j)\\n          {\\n              printf(\\\"G[%d][%d]: \\\", i, j);\\n              scanf(\\\" %hd\\\", &G[i][j]);\\n              if (G[i][j] == 0)\\n                  G[i][j] = INF;\\n          }\\n      }\\n\\n      prim(&(*G),&(*MST),V);\\n\\n      printf(\\\"minimum spanning tree:\\\\n\\\");\\n      for (i = 0; i < V; ++i)\\n      {\\n          printf(\\\"\\\\n\\\");\\n          for (j = 0; j < V; ++j)\\n          {\\n              printf(\\\"%d\\\\t\\\", MST[i][j]);\\n          }\\n      }\\n}\\n\\n\\n/**\\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, char const *argv[])\\n{   \\n\\n    uint16_t G[MAX][MAX];    ///< weighted, connected graph G\\n    uint16_t MST[MAX][MAX];  ///< adj matrix to hold minimum spanning tree of G\\n    uint16_t V;              ///< number of vertices in V in G\\n\\n\\n    if(argc == 2 && strcmp(argv[1],\\\"-test\\\") == 0)\\n    {\\n      test(&(*G),&(*MST),V);\\n    }\\n    else\\n    {\\n      user_graph(&(*G),&(*MST),V);\\n    }\\n\\n    return 0;\\n}\\n\"",
    "hash adler32": "\"/**\\n * @addtogroup hash Hash algorithms\\n * @{\\n * @file hash_adler32.c\\n * @author [Christian Bender](https://github.com/christianbender)\\n * @brief 32-bit [Adler hash](https://en.wikipedia.org/wiki/Adler-32) algorithm\\n */\\n#include <assert.h>\\n#include <inttypes.h>\\n#include <stdio.h>\\n\\n/**\\n * @brief 32-bit Adler algorithm implementation\\n *\\n * @param s NULL terminated ASCII string to hash\\n * @return 32-bit hash result\\n */\\nuint32_t adler32(const char* s)\\n{\\n    uint32_t a = 1;\\n    uint32_t b = 0;\\n    const uint32_t MODADLER = 65521;\\n\\n    size_t i = 0;\\n    while (s[i] != '\\\\0')\\n    {\\n        a = (a + s[i]) % MODADLER;\\n        b = (b + a) % MODADLER;\\n        i++;\\n    }\\n    return (b << 16) | a;\\n}\\n\\n/**\\n * @brief Test function for ::adler32\\n * \\\\returns None\\n */\\nvoid test_adler32()\\n{\\n    assert(adler32(\\\"Hello World\\\") == 403375133);\\n    assert(adler32(\\\"Hello World!\\\") == 474547262);\\n    assert(adler32(\\\"Hello world\\\") == 413860925);\\n    assert(adler32(\\\"Hello world!\\\") == 487130206);\\n    printf(\\\"Tests passed\\\\n\\\");\\n}\\n\\n/** @} */\\n\\n/** Main function */\\nint main()\\n{\\n    test_adler32();\\n    return 0;\\n}\\n\"",
    "hash crc32": "\"/**\\n * @addtogroup hash Hash algorithms\\n * @{\\n * @file hash_crc32.c\\n * @author [Christian Bender](https://github.com/christianbender)\\n * @brief 32-bit [CRC\\n * hash](https://en.wikipedia.org/wiki/Cyclic_redundancy_check#CRC-32_algorithm)\\n * algorithm\\n */\\n#include <assert.h>\\n#include <inttypes.h>\\n#include <stdio.h>\\n\\n/**\\n * @brief 32-bit CRC algorithm implementation\\n *\\n * @param s NULL terminated ASCII string to hash\\n * @return 32-bit hash result\\n */\\nuint32_t crc32(const char* s)\\n{\\n    uint32_t crc = 0xffffffff;\\n    size_t i = 0;\\n    while (s[i] != '\\\\0')\\n    {\\n        uint8_t byte = s[i];\\n        crc = crc ^ byte;\\n        for (uint8_t j = 8; j > 0; --j)\\n        {\\n            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));\\n        }\\n\\n        i++;\\n    }\\n    return crc ^ 0xffffffff;\\n}\\n\\n/**\\n * @brief Test function for ::crc32\\n * \\\\returns None\\n */\\nvoid test_crc32()\\n{\\n    assert(crc32(\\\"Hello World\\\") == 1243066710);\\n    assert(crc32(\\\"Hello World!\\\") == 472456355);\\n    assert(crc32(\\\"Hello world\\\") == 2346098258);\\n    assert(crc32(\\\"Hello world!\\\") == 461707669);\\n    printf(\\\"Tests passed\\\\n\\\");\\n}\\n\\n/** @} */\\n\\n/** Main function */\\nint main()\\n{\\n    test_crc32();\\n    return 0;\\n}\\n\"",
    "hash djb2": "\"/**\\n * @addtogroup hash Hash algorithms\\n * @{\\n * @file hash_djb2.c\\n * @author [Christian Bender](https://github.com/christianbender)\\n * @brief [DJB2 hash algorithm](http://www.cse.yorku.ca/~oz/hash.html)\\n */\\n#include <assert.h>\\n#include <inttypes.h>\\n#include <stdio.h>\\n\\n/**\\n * @brief DJB2 algorithm implementation\\n *\\n * @param s NULL terminated string to hash\\n * @return 64-bit hash result\\n */\\nuint64_t djb2(const char* s)\\n{\\n    uint64_t hash = 5381; /* init value */\\n    size_t i = 0;\\n    while (s[i] != '\\\\0')\\n    {\\n        hash = ((hash << 5) + hash) + s[i];\\n        i++;\\n    }\\n    return hash;\\n}\\n\\n/**\\n * Test function for ::djb2\\n * \\\\returns none\\n */\\nvoid test_djb2(void)\\n{\\n    assert(djb2(\\\"Hello World\\\") == 13827776004929097857);\\n    assert(djb2(\\\"Hello World!\\\") == 13594750393630990530);\\n    assert(djb2(\\\"Hello world\\\") == 13827776004967047329);\\n    assert(djb2(\\\"Hello world!\\\") == 13594750394883323106);\\n    printf(\\\"Tests passed\\\\n\\\");\\n}\\n\\n/** @} */\\n\\n/** Main function */\\nint main()\\n{\\n    test_djb2();\\n    return 0;\\n}\\n\"",
    "hash sdbm": "\"/**\\n * @addtogroup hash Hash algorithms\\n * @{\\n * @file hash_sdbm.c\\n * @author [Christian Bender](https://github.com/christianbender)\\n * @brief [SDBM hash algorithm](http://www.cse.yorku.ca/~oz/hash.html)\\n */\\n#include <assert.h>\\n#include <inttypes.h>\\n#include <stdio.h>\\n\\n/**\\n * @brief SDBM algorithm implementation\\n *\\n * @param s NULL terminated string to hash\\n * @return 64-bit hash result\\n */\\nuint64_t sdbm(const char* s)\\n{\\n    uint64_t hash = 0;\\n    size_t i = 0;\\n    while (s[i] != '\\\\0')\\n    {\\n        hash = s[i] + (hash << 6) + (hash << 16) - hash;\\n        i++;\\n    }\\n    return hash;\\n}\\n\\n/**\\n * @brief Test function for ::sdbm\\n * \\\\returns None\\n */\\nvoid test_sdbm()\\n{\\n    assert(sdbm(\\\"Hello World\\\") == 12881824461405877380U);\\n    assert(sdbm(\\\"Hello World!\\\") == 7903571203300273309);\\n    assert(sdbm(\\\"Hello world\\\") == 15154913742888948900U);\\n    assert(sdbm(\\\"Hello world!\\\") == 15254999417003201661U);\\n    printf(\\\"Tests passed\\\\n\\\");\\n}\\n\\n/** @} */\\n\\n/** Main function */\\nint main()\\n{\\n    test_sdbm();\\n    return 0;\\n}\\n\"",
    "hash xor8": "\"/**\\n * @addtogroup hash Hash algorithms\\n * @{\\n * @file hash_xor8.c\\n * @author [Christian Bender](https://github.com/christianbender)\\n * @brief 8-bit [XOR hash](https://en.wikipedia.org/wiki/XOR_cipher) algorithm\\n * for ASCII characters\\n */\\n#include <assert.h>\\n#include <inttypes.h>\\n#include <stdio.h>\\n\\n/**\\n * @brief 8-bit XOR algorithm implementation\\n *\\n * @param s NULL terminated ASCII string to hash\\n * @return 8-bit hash result\\n */\\nuint8_t xor8(const char* s)\\n{\\n    uint8_t hash = 0;\\n    size_t i = 0;\\n    while (s[i] != '\\\\0')\\n    {\\n        hash = (hash + s[i]) & 0xff;\\n        i++;\\n    }\\n    return (((hash ^ 0xff) + 1) & 0xff);\\n}\\n\\n/**\\n * @brief Test function for ::xor8\\n * \\\\returns None\\n */\\nvoid test_xor8()\\n{\\n    assert(xor8(\\\"Hello World\\\") == 228);\\n    assert(xor8(\\\"Hello World!\\\") == 195);\\n    assert(xor8(\\\"Hello world\\\") == 196);\\n    assert(xor8(\\\"Hello world!\\\") == 163);\\n    printf(\\\"Tests passed\\\\n\\\");\\n}\\n\\n/** @} */\\n\\n/** Main function */\\nint main()\\n{\\n    test_xor8();\\n    return 0;\\n}\\n\"",
    "adaline learning": "\"/**\\n * \\\\file\\n * \\\\brief [Adaptive Linear Neuron\\n * (ADALINE)](https://en.wikipedia.org/wiki/ADALINE) implementation\\n * \\\\details\\n * <img\\n * src=\\\"https://upload.wikimedia.org/wikipedia/commons/b/be/Adaline_flow_chart.gif\\\"\\n * width=\\\"200px\\\">\\n * [source](https://commons.wikimedia.org/wiki/File:Adaline_flow_chart.gif)\\n * ADALINE is one of the first and simplest single layer artificial neural\\n * network. The algorithm essentially implements a linear function\\n * \\\\f[ f\\\\left(x_0,x_1,x_2,\\\\ldots\\\\right) =\\n * \\\\sum_j x_jw_j+\\\\theta\\n * \\\\f]\\n * where \\\\f$x_j\\\\f$ are the input features of a sample, \\\\f$w_j\\\\f$ are the\\n * coefficients of the linear function and \\\\f$\\\\theta\\\\f$ is a constant. If we\\n * know the \\\\f$w_j\\\\f$, then for any given set of features, \\\\f$y\\\\f$ can be\\n * computed. Computing the \\\\f$w_j\\\\f$ is a supervised learning algorithm wherein\\n * a set of features and their corresponding outputs are given and weights are\\n * computed using stochastic gradient descent method.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n\\n#include <assert.h>\\n#include <limits.h>\\n#include <math.h>\\n#include <stdbool.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n/**\\n * @addtogroup machine_learning Machine learning algorithms\\n * @{\\n * @addtogroup adaline Adaline learning algorithm\\n * @{\\n */\\n\\n/** Maximum number of iterations to learn */\\n#define MAX_ADALINE_ITER 500  // INT_MAX\\n\\n/** structure to hold adaline model parameters */\\nstruct adaline\\n{\\n    double eta;      /**< learning rate of the algorithm */\\n    double *weights; /**< weights of the neural network */\\n    int num_weights; /**< number of weights of the neural network */\\n};\\n\\n/** convergence accuracy \\\\f$=1\\\\times10^{-5}\\\\f$ */\\n#define ADALINE_ACCURACY 1e-5\\n\\n/**\\n * Default constructor\\n * \\\\param[in] num_features number of features present\\n * \\\\param[in] eta learning rate (optional, default=0.1)\\n * \\\\returns new adaline model\\n */\\nstruct adaline new_adaline(const int num_features, const double eta)\\n{\\n    if (eta <= 0.f || eta >= 1.f)\\n    {\\n        fprintf(stderr, \\\"learning rate should be > 0 and < 1\\\\n\\\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    // additional weight is for the constant bias term\\n    int num_weights = num_features + 1;\\n    struct adaline ada;\\n    ada.eta = eta;\\n    ada.num_weights = num_weights;\\n    ada.weights = (double *)malloc(num_weights * sizeof(double));\\n    if (!ada.weights)\\n    {\\n        perror(\\\"Unable to allocate error for weights!\\\");\\n        return ada;\\n    }\\n\\n    // initialize with random weights in the range [-50, 49]\\n    for (int i = 0; i < num_weights; i++) ada.weights[i] = 1.f;\\n    // ada.weights[i] = (double)(rand() % 100) - 50);\\n\\n    return ada;\\n}\\n\\n/** delete dynamically allocated memory\\n * \\\\param[in] ada model from which the memory is to be freed.\\n */\\nvoid delete_adaline(struct adaline *ada)\\n{\\n    if (ada == NULL)\\n        return;\\n\\n    free(ada->weights);\\n};\\n\\n/** [Heaviside activation\\n * function](https://en.wikipedia.org/wiki/Heaviside_step_function) <img\\n * src=\\\"https://upload.wikimedia.org/wikipedia/commons/d/d9/Dirac_distribution_CDF.svg\\\"\\n * width=\\\"200px\\\"/>\\n * @param x activation function input\\n * @returns \\\\f$f(x)= \\\\begin{cases}1 & \\\\forall\\\\; x > 0\\\\\\\\ -1 & \\\\forall\\\\; x \\\\le0\\n * \\\\end{cases}\\\\f$\\n */\\nint adaline_activation(double x) { return x > 0 ? 1 : -1; }\\n\\n/**\\n * Operator to print the weights of the model\\n * @param ada model for which the values to print\\n * @returns pointer to a NULL terminated string of formatted weights\\n */\\nchar *adaline_get_weights_str(const struct adaline *ada)\\n{\\n    static char out[100];  // static so the value is persistent\\n\\n    sprintf(out, \\\"<\\\");\\n    for (int i = 0; i < ada->num_weights; i++)\\n    {\\n        sprintf(out, \\\"%s%.4g\\\", out, ada->weights[i]);\\n        if (i < ada->num_weights - 1)\\n            sprintf(out, \\\"%s, \\\", out);\\n    }\\n    sprintf(out, \\\"%s>\\\", out);\\n    return out;\\n}\\n\\n/**\\n * predict the output of the model for given set of features\\n *\\n * \\\\param[in] ada adaline model to predict\\n * \\\\param[in] x input vector\\n * \\\\param[out] out optional argument to return neuron output before applying\\n * activation function (`NULL` to ignore)\\n * \\\\returns model prediction output\\n */\\nint adaline_predict(struct adaline *ada, const double *x, double *out)\\n{\\n    double y = ada->weights[ada->num_weights - 1];  // assign bias value\\n\\n    for (int i = 0; i < ada->num_weights - 1; i++) y += x[i] * ada->weights[i];\\n\\n    if (out)  // if out variable is not NULL\\n        *out = y;\\n\\n    // quantizer: apply ADALINE threshold function\\n    return adaline_activation(y);\\n}\\n\\n/**\\n * Update the weights of the model using supervised learning for one feature\\n * vector\\n *\\n * \\\\param[in] ada adaline model to fit\\n * \\\\param[in] x feature vector\\n * \\\\param[in] y known output  value\\n * \\\\returns correction factor\\n */\\ndouble adaline_fit_sample(struct adaline *ada, const double *x, const int y)\\n{\\n    /* output of the model with current weights */\\n    int p = adaline_predict(ada, x, NULL);\\n    int prediction_error = y - p;  // error in estimation\\n    double correction_factor = ada->eta * prediction_error;\\n\\n    /* update each weight, the last weight is the bias term */\\n    for (int i = 0; i < ada->num_weights - 1; i++)\\n    {\\n        ada->weights[i] += correction_factor * x[i];\\n    }\\n    ada->weights[ada->num_weights - 1] += correction_factor;  // update bias\\n\\n    return correction_factor;\\n}\\n\\n/**\\n * Update the weights of the model using supervised learning for an array of\\n * vectors.\\n *\\n * \\\\param[in] ada adaline model to train\\n * \\\\param[in] X array of feature vector\\n * \\\\param[in] y known output value for each feature vector\\n * \\\\param[in] N number of training samples\\n */\\nvoid adaline_fit(struct adaline *ada, double **X, const int *y, const int N)\\n{\\n    double avg_pred_error = 1.f;\\n\\n    int iter;\\n    for (iter = 0;\\n         (iter < MAX_ADALINE_ITER) && (avg_pred_error > ADALINE_ACCURACY);\\n         iter++)\\n    {\\n        avg_pred_error = 0.f;\\n\\n        // perform fit for each sample\\n        for (int i = 0; i < N; i++)\\n        {\\n            double err = adaline_fit_sample(ada, X[i], y[i]);\\n            avg_pred_error += fabs(err);\\n        }\\n        avg_pred_error /= N;\\n\\n        // Print updates every 200th iteration\\n        // if (iter % 100 == 0)\\n        printf(\\\"\\\\tIter %3d: Training weights: %s\\\\tAvg error: %.4f\\\\n\\\", iter,\\n               adaline_get_weights_str(ada), avg_pred_error);\\n    }\\n\\n    if (iter < MAX_ADALINE_ITER)\\n        printf(\\\"Converged after %d iterations.\\\\n\\\", iter);\\n    else\\n        printf(\\\"Did not converged after %d iterations.\\\\n\\\", iter);\\n}\\n\\n/** @}\\n *  @}\\n */\\n\\n/**\\n * test function to predict points in a 2D coordinate system above the line\\n * \\\\f$x=y\\\\f$ as +1 and others as -1.\\n * Note that each point is defined by 2 values or 2 features.\\n * \\\\param[in] eta learning rate (optional, default=0.01)\\n */\\nvoid test1(double eta)\\n{\\n    struct adaline ada = new_adaline(2, eta);  // 2 features\\n\\n    const int N = 10;  // number of sample points\\n    const double saved_X[10][2] = {{0, 1},  {1, -2},   {2, 3},   {3, -1},\\n                                   {4, 1},  {6, -5},   {-7, -3}, {-8, 5},\\n                                   {-9, 2}, {-10, -15}};\\n\\n    double **X = (double **)malloc(N * sizeof(double *));\\n    const int Y[10] = {1,  -1, 1, -1, -1,\\n                       -1, 1,  1, 1,  -1};  // corresponding y-values\\n    for (int i = 0; i < N; i++)\\n    {\\n        X[i] = (double *)saved_X[i];\\n    }\\n\\n    printf(\\\"------- Test 1 -------\\\\n\\\");\\n    printf(\\\"Model before fit: %s\\\\n\\\", adaline_get_weights_str(&ada));\\n\\n    adaline_fit(&ada, X, Y, N);\\n    printf(\\\"Model after fit: %s\\\\n\\\", adaline_get_weights_str(&ada));\\n\\n    double test_x[] = {5, -3};\\n    int pred = adaline_predict(&ada, test_x, NULL);\\n    printf(\\\"Predict for x=(5,-3): % d\\\\n\\\", pred);\\n    assert(pred == -1);\\n    printf(\\\" ...passed\\\\n\\\");\\n\\n    double test_x2[] = {5, 8};\\n    pred = adaline_predict(&ada, test_x2, NULL);\\n    printf(\\\"Predict for x=(5, 8): % d\\\\n\\\", pred);\\n    assert(pred == 1);\\n    printf(\\\" ...passed\\\\n\\\");\\n\\n    // for (int i = 0; i < N; i++)\\n    //     free(X[i]);\\n    free(X);\\n    delete_adaline(&ada);\\n}\\n\\n/**\\n * test function to predict points in a 2D coordinate system above the line\\n * \\\\f$x+3y=-1\\\\f$ as +1 and others as -1.\\n * Note that each point is defined by 2 values or 2 features.\\n * The function will create random sample points for training and test purposes.\\n * \\\\param[in] eta learning rate (optional, default=0.01)\\n */\\nvoid test2(double eta)\\n{\\n    struct adaline ada = new_adaline(2, eta);  // 2 features\\n\\n    const int N = 50;  // number of sample points\\n\\n    double **X = (double **)malloc(N * sizeof(double *));\\n    int *Y = (int *)malloc(N * sizeof(int));  // corresponding y-values\\n    for (int i = 0; i < N; i++) X[i] = (double *)malloc(2 * sizeof(double));\\n\\n    // generate sample points in the interval\\n    // [-range2/100 , (range2-1)/100]\\n    int range = 500;          // sample points full-range\\n    int range2 = range >> 1;  // sample points half-range\\n    for (int i = 0; i < N; i++)\\n    {\\n        double x0 = ((rand() % range) - range2) / 100.f;\\n        double x1 = ((rand() % range) - range2) / 100.f;\\n        X[i][0] = x0;\\n        X[i][1] = x1;\\n        Y[i] = (x0 + 3. * x1) > -1 ? 1 : -1;\\n    }\\n\\n    printf(\\\"------- Test 2 -------\\\\n\\\");\\n    printf(\\\"Model before fit: %s\\\\n\\\", adaline_get_weights_str(&ada));\\n\\n    adaline_fit(&ada, X, Y, N);\\n    printf(\\\"Model after fit: %s\\\\n\\\", adaline_get_weights_str(&ada));\\n\\n    int N_test_cases = 5;\\n    double test_x[2];\\n    for (int i = 0; i < N_test_cases; i++)\\n    {\\n        double x0 = ((rand() % range) - range2) / 100.f;\\n        double x1 = ((rand() % range) - range2) / 100.f;\\n\\n        test_x[0] = x0;\\n        test_x[1] = x1;\\n        int pred = adaline_predict(&ada, test_x, NULL);\\n        printf(\\\"Predict for x=(% 3.2f,% 3.2f): % d\\\\n\\\", x0, x1, pred);\\n\\n        int expected_val = (x0 + 3. * x1) > -1 ? 1 : -1;\\n        assert(pred == expected_val);\\n        printf(\\\" ...passed\\\\n\\\");\\n    }\\n\\n    for (int i = 0; i < N; i++) free(X[i]);\\n    free(X);\\n    free(Y);\\n    delete_adaline(&ada);\\n}\\n\\n/**\\n * test function to predict points in a 3D coordinate system lying within the\\n * sphere of radius 1 and centre at origin as +1 and others as -1. Note that\\n * each point is defined by 3 values but we use 6 features. The function will\\n * create random sample points for training and test purposes.\\n * The sphere centred at origin and radius 1 is defined as:\\n * \\\\f$x^2+y^2+z^2=r^2=1\\\\f$ and if the \\\\f$r^2<1\\\\f$, point lies within the sphere\\n * else, outside.\\n *\\n * \\\\param[in] eta learning rate (optional, default=0.01)\\n */\\nvoid test3(double eta)\\n{\\n    struct adaline ada = new_adaline(6, eta);  // 2 features\\n\\n    const int N = 50;  // number of sample points\\n\\n    double **X = (double **)malloc(N * sizeof(double *));\\n    int *Y = (int *)malloc(N * sizeof(int));  // corresponding y-values\\n    for (int i = 0; i < N; i++) X[i] = (double *)malloc(6 * sizeof(double));\\n\\n    // generate sample points in the interval\\n    // [-range2/100 , (range2-1)/100]\\n    int range = 200;          // sample points full-range\\n    int range2 = range >> 1;  // sample points half-range\\n    for (int i = 0; i < N; i++)\\n    {\\n        double x0 = ((rand() % range) - range2) / 100.f;\\n        double x1 = ((rand() % range) - range2) / 100.f;\\n        double x2 = ((rand() % range) - range2) / 100.f;\\n        X[i][0] = x0;\\n        X[i][1] = x1;\\n        X[i][2] = x2;\\n        X[i][3] = x0 * x0;\\n        X[i][4] = x1 * x1;\\n        X[i][5] = x2 * x2;\\n        Y[i] = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;\\n    }\\n\\n    printf(\\\"------- Test 3 -------\\\\n\\\");\\n    printf(\\\"Model before fit: %s\\\\n\\\", adaline_get_weights_str(&ada));\\n\\n    adaline_fit(&ada, X, Y, N);\\n    printf(\\\"Model after fit: %s\\\\n\\\", adaline_get_weights_str(&ada));\\n\\n    int N_test_cases = 5;\\n    double test_x[6];\\n    for (int i = 0; i < N_test_cases; i++)\\n    {\\n        double x0 = ((rand() % range) - range2) / 100.f;\\n        double x1 = ((rand() % range) - range2) / 100.f;\\n        double x2 = ((rand() % range) - range2) / 100.f;\\n        test_x[0] = x0;\\n        test_x[1] = x1;\\n        test_x[2] = x2;\\n        test_x[3] = x0 * x0;\\n        test_x[4] = x1 * x1;\\n        test_x[5] = x2 * x2;\\n        int pred = adaline_predict(&ada, test_x, NULL);\\n        printf(\\\"Predict for x=(% 3.2f,% 3.2f): % d\\\\n\\\", x0, x1, pred);\\n\\n        int expected_val = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;\\n        assert(pred == expected_val);\\n        printf(\\\" ...passed\\\\n\\\");\\n    }\\n\\n    for (int i = 0; i < N; i++) free(X[i]);\\n    free(X);\\n    free(Y);\\n    delete_adaline(&ada);\\n}\\n\\n/** Main function */\\nint main(int argc, char **argv)\\n{\\n    srand(time(NULL));  // initialize random number generator\\n\\n    double eta = 0.1;  // default value of eta\\n    if (argc == 2)     // read eta value from commandline argument if present\\n        eta = strtof(argv[1], NULL);\\n\\n    test1(eta);\\n\\n    printf(\\\"Press ENTER to continue...\\\\n\\\");\\n    getchar();\\n\\n    test2(eta);\\n\\n    printf(\\\"Press ENTER to continue...\\\\n\\\");\\n    getchar();\\n\\n    test3(eta);\\n\\n    return 0;\\n}\\n\"",
    "kohonen som topology": "\"/**\\n * \\\\file\\n * \\\\brief [Kohonen self organizing\\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (topological map)\\n *\\n * This example implements a powerful unsupervised learning algorithm called as\\n * a self organizing map. The algorithm creates a connected network of weights\\n * that closely follows the given data points. This thus creates a topological\\n * map of the given data i.e., it maintains the relationship between various\\n * data points in a much higher dimensional space by creating an equivalent in a\\n * 2-dimensional space.\\n * <img alt=\\\"Trained topological maps for the test cases in the program\\\"\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/2D_Kohonen_SOM.svg\\\"\\n * />\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n * \\\\warning MSVC 2019 compiler generates code that does not execute as expected.\\n * However, MinGW, Clang for GCC and Clang for MSVC compilers on windows perform\\n * as expected. Any insights and suggestions should be directed to the author.\\n * \\\\see kohonen_som_trace.c\\n */\\n#define _USE_MATH_DEFINES /**< required for MS Visual C */\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#ifdef _OPENMP  // check if OpenMP based parallellization is available\\n#include <omp.h>\\n#endif\\n\\n/**\\n * @addtogroup machine_learning Machine learning algorithms\\n * @{\\n * @addtogroup kohonen_2d Kohonen SOM topology algorithm\\n * @{\\n */\\n\\n#ifndef max\\n/** shorthand for maximum value */\\n#define max(a, b) (((a) > (b)) ? (a) : (b))\\n#endif\\n#ifndef min\\n/** shorthand for minimum value */\\n#define min(a, b) (((a) < (b)) ? (a) : (b))\\n#endif\\n\\n/** to store info regarding 3D arrays */\\nstruct kohonen_array_3d\\n{\\n    int dim1;     /**< lengths of first dimension */\\n    int dim2;     /**< lengths of second dimension */\\n    int dim3;     /**< lengths of thirddimension */\\n    double *data; /**< pointer to data */\\n};\\n\\n/** Function that returns the pointer to (x, y, z) ^th location in the\\n * linear 3D array given by:\\n * \\\\f[\\n * X_{i,j,k} = i\\\\times M\\\\times N + j\\\\times N + k\\n * \\\\f]\\n * where \\\\f$L\\\\f$, \\\\f$M\\\\f$ and \\\\f$N\\\\f$ are the 3D matrix dimensions.\\n * \\\\param[in] arr pointer to ::kohonen_array_3d structure\\n * \\\\param[in] x     first index\\n * \\\\param[in] y     second index\\n * \\\\param[in] z     third index\\n * \\\\returns pointer to (x,y,z)^th location of data\\n */\\ndouble *kohonen_data_3d(const struct kohonen_array_3d *arr, int x, int y, int z)\\n{\\n    int offset = (x * arr->dim2 * arr->dim3) + (y * arr->dim3) + z;\\n    return arr->data + offset;\\n}\\n\\n/**\\n * Helper function to generate a random number in a given interval.\\n * \\\\n Steps:\\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\\n * 3. scale and offset the random number to given range of \\\\f$[a,b)\\\\f$\\n * \\\\f[\\n * y = (b - a) \\\\times \\\\frac{\\\\text{(random number between 0 and RAND_MAX)} \\\\;\\n * \\\\text{mod}\\\\; 100}{100} + a \\\\f]\\n *\\n * \\\\param[in] a lower limit\\n * \\\\param[in] b upper limit\\n * \\\\returns random number in the range \\\\f$[a,b)\\\\f$\\n */\\ndouble _random(double a, double b)\\n{\\n    return ((b - a) * (rand() % 100) / 100.f) + a;\\n}\\n\\n/**\\n * Save a given n-dimensional data martix to file.\\n *\\n * \\\\param[in] fname filename to save in (gets overwritten without confirmation)\\n * \\\\param[in] X matrix to save\\n * \\\\param[in] num_points rows in the matrix = number of points\\n * \\\\param[in] num_features columns in the matrix = dimensions of points\\n * \\\\returns 0 if all ok\\n * \\\\returns -1 if file creation failed\\n */\\nint save_2d_data(const char *fname, double **X, int num_points,\\n                 int num_features)\\n{\\n    FILE *fp = fopen(fname, \\\"wt\\\");\\n    if (!fp)  // error with fopen\\n    {\\n        char msg[120];\\n        sprintf(msg, \\\"File error (%s): \\\", fname);\\n        perror(msg);\\n        return -1;\\n    }\\n\\n    for (int i = 0; i < num_points; i++)  // for each point in the array\\n    {\\n        for (int j = 0; j < num_features; j++)  // for each feature in the array\\n        {\\n            fprintf(fp, \\\"%.4g\\\", X[i][j]);  // print the feature value\\n            if (j < num_features - 1)      // if not the last feature\\n                fputc(',', fp);            // suffix comma\\n        }\\n        if (i < num_points - 1)  // if not the last row\\n            fputc('\\\\n', fp);     // start a new line\\n    }\\n    fclose(fp);\\n    return 0;\\n}\\n\\n/**\\n * Create the distance matrix or\\n * [U-matrix](https://en.wikipedia.org/wiki/U-matrix) from the trained weights\\n * and save to disk.\\n *\\n * \\\\param [in] fname filename to save in (gets overwriten without confirmation)\\n * \\\\param [in] W model matrix to save\\n * \\\\returns 0 if all ok\\n * \\\\returns -1 if file creation failed\\n */\\nint save_u_matrix(const char *fname, struct kohonen_array_3d *W)\\n{\\n    FILE *fp = fopen(fname, \\\"wt\\\");\\n    if (!fp)  // error with fopen\\n    {\\n        char msg[120];\\n        sprintf(msg, \\\"File error (%s): \\\", fname);\\n        perror(msg);\\n        return -1;\\n    }\\n\\n    int R = max(W->dim1 >> 3, 2); /* neighborhood range */\\n\\n    for (int i = 0; i < W->dim1; i++)  // for each x\\n    {\\n        for (int j = 0; j < W->dim2; j++)  // for each y\\n        {\\n            double distance = 0.f;\\n            int k;\\n\\n            int from_x = max(0, i - R);\\n            int to_x = min(W->dim1, i + R + 1);\\n            int from_y = max(0, j - R);\\n            int to_y = min(W->dim2, j + R + 1);\\n            int l;\\n#ifdef _OPENMP\\n#pragma omp parallel for reduction(+ : distance)\\n#endif\\n            for (l = from_x; l < to_x; l++)  // scan neighborhoor in x\\n            {\\n                for (int m = from_y; m < to_y; m++)  // scan neighborhood in y\\n                {\\n                    double d = 0.f;\\n                    for (k = 0; k < W->dim3; k++)  // for each feature\\n                    {\\n                        double *w1 = kohonen_data_3d(W, i, j, k);\\n                        double *w2 = kohonen_data_3d(W, l, m, k);\\n                        d += (w1[0] - w2[0]) * (w1[0] - w2[0]);\\n                        // distance += w1[0] * w1[0];\\n                    }\\n                    distance += sqrt(d);\\n                    // distance += d;\\n                }\\n            }\\n\\n            distance /= R * R;              // mean distance from neighbors\\n            fprintf(fp, \\\"%.4g\\\", distance);  // print the mean separation\\n            if (j < W->dim2 - 1)            // if not the last column\\n                fputc(',', fp);             // suffix comma\\n        }\\n        if (i < W->dim1 - 1)  // if not the last row\\n            fputc('\\\\n', fp);  // start a new line\\n    }\\n    fclose(fp);\\n    return 0;\\n}\\n\\n/**\\n * Get minimum value and index of the value in a matrix\\n * \\\\param[in] X matrix to search\\n * \\\\param[in] N number of points in the vector\\n * \\\\param[out] val minimum value found\\n * \\\\param[out] x_idx x-index where minimum value was found\\n * \\\\param[out] y_idx y-index where minimum value was found\\n */\\nvoid get_min_2d(double **X, int N, double *val, int *x_idx, int *y_idx)\\n{\\n    val[0] = INFINITY;  // initial min value\\n\\n    for (int i = 0; i < N; i++)  // traverse each x-index\\n    {\\n        for (int j = 0; j < N; j++)  // traverse each y-index\\n        {\\n            if (X[i][j] < val[0])  // if a lower value is found\\n            {                      // save the value and its index\\n                x_idx[0] = i;\\n                y_idx[0] = j;\\n                val[0] = X[i][j];\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Update weights of the SOM using Kohonen algorithm\\n *\\n * \\\\param[in] X data point\\n * \\\\param[in,out] W weights matrix\\n * \\\\param[in,out] D temporary vector to store distances\\n * \\\\param[in] num_out number of output points\\n * \\\\param[in] num_features number of features per input sample\\n * \\\\param[in] alpha learning rate \\\\f$0<\\\\alpha\\\\le1\\\\f$\\n * \\\\param[in] R neighborhood range\\n * \\\\returns minimum distance of sample and trained weights\\n */\\ndouble kohonen_update_weights(const double *X, struct kohonen_array_3d *W,\\n                              double **D, int num_out, int num_features,\\n                              double alpha, int R)\\n{\\n    int x, y, k;\\n    double d_min = 0.f;\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    // step 1: for each 2D output point\\n    for (x = 0; x < num_out; x++)\\n    {\\n        for (y = 0; y < num_out; y++)\\n        {\\n            D[x][y] = 0.f;\\n            // compute Euclidian distance of each output\\n            // point from the current sample\\n            for (k = 0; k < num_features; k++)\\n            {\\n                double *w = kohonen_data_3d(W, x, y, k);\\n                D[x][y] += (w[0] - X[k]) * (w[0] - X[k]);\\n            }\\n            D[x][y] = sqrt(D[x][y]);\\n        }\\n    }\\n\\n    // step 2:  get closest node i.e., node with smallest Euclidian distance to\\n    // the current pattern\\n    int d_min_x, d_min_y;\\n    get_min_2d(D, num_out, &d_min, &d_min_x, &d_min_y);\\n\\n    // step 3a: get the neighborhood range\\n    int from_x = max(0, d_min_x - R);\\n    int to_x = min(num_out, d_min_x + R + 1);\\n    int from_y = max(0, d_min_y - R);\\n    int to_y = min(num_out, d_min_y + R + 1);\\n\\n    // step 3b: update the weights of nodes in the\\n    // neighborhood\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (x = from_x; x < to_x; x++)\\n    {\\n        for (y = from_y; y < to_y; y++)\\n        {\\n            /* you can enable the following normalization if needed.\\n               personally, I found it detrimental to convergence */\\n            // const double s2pi = sqrt(2.f * M_PI);\\n            // double normalize = 1.f / (alpha * s2pi);\\n\\n            /* apply scaling inversely proportional to distance from the\\n               current node */\\n            double d2 =\\n                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);\\n            double scale_factor = exp(-d2 / (2.f * alpha * alpha));\\n\\n            for (k = 0; k < num_features; k++)\\n            {\\n                double *w = kohonen_data_3d(W, x, y, k);\\n                // update weights of nodes in the neighborhood\\n                w[0] += alpha * scale_factor * (X[k] - w[0]);\\n            }\\n        }\\n    }\\n    return d_min;\\n}\\n\\n/**\\n * Apply incremental algorithm with updating neighborhood and learning rates\\n * on all samples in the given datset.\\n *\\n * \\\\param[in] X data set\\n * \\\\param[in,out] W weights matrix\\n * \\\\param[in] num_samples number of output points\\n * \\\\param[in] num_features number of features per input sample\\n * \\\\param[in] num_out number of output points\\n * \\\\param[in] alpha_min terminal value of alpha\\n */\\nvoid kohonen_som(double **X, struct kohonen_array_3d *W, int num_samples,\\n                 int num_features, int num_out, double alpha_min)\\n{\\n    int R = num_out >> 2, iter = 0;\\n    double **D = (double **)malloc(num_out * sizeof(double *));\\n    for (int i = 0; i < num_out; i++)\\n        D[i] = (double *)malloc(num_out * sizeof(double));\\n\\n    double dmin = 1.f;  // average minimum distance of all samples\\n\\n    // Loop alpha from 1 to slpha_min\\n    for (double alpha = 1.f; alpha > alpha_min && dmin > 1e-3;\\n         alpha -= 0.001, iter++)\\n    {\\n        dmin = 0.f;\\n        // Loop for each sample pattern in the data set\\n        for (int sample = 0; sample < num_samples; sample++)\\n        {\\n            // update weights for the current input pattern sample\\n            dmin += kohonen_update_weights(X[sample], W, D, num_out,\\n                                           num_features, alpha, R);\\n        }\\n\\n        // every 20th iteration, reduce the neighborhood range\\n        if (iter % 100 == 0 && R > 1)\\n            R--;\\n\\n        dmin /= num_samples;\\n        printf(\\\"iter: %5d\\\\t alpha: %.4g\\\\t R: %d\\\\td_min: %.4g\\\\r\\\", iter, alpha, R,\\n               dmin);\\n    }\\n    putchar('\\\\n');\\n\\n    for (int i = 0; i < num_out; i++) free(D[i]);\\n    free(D);\\n}\\n\\n/**\\n * @}\\n * @}\\n */\\n\\n/** Creates a random set of points distributed in four clusters in\\n * 3D space with centroids at the points\\n * * \\\\f$(0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(0,5,-0.5, -0.5)\\\\f$\\n * * \\\\f$(-0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(-0,5,-0.5, -0.5)\\\\f$\\n *\\n * \\\\param[out] data matrix to store data in\\n * \\\\param[in] N number of points required\\n */\\nvoid test_2d_classes(double *const *data, int N)\\n{\\n    const double R = 0.3;  // radius of cluster\\n    int i;\\n    const int num_classes = 4;\\n    const double centres[][2] = {\\n        // centres of each class cluster\\n        {.5, .5},   // centre of class 1\\n        {.5, -.5},  // centre of class 2\\n        {-.5, .5},  // centre of class 3\\n        {-.5, -.5}  // centre of class 4\\n    };\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++)\\n    {\\n        int class =\\n            rand() % num_classes;  // select a random class for the point\\n\\n        // create random coordinates (x,y,z) around the centre of the class\\n        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);\\n        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);\\n\\n        /* The follosing can also be used\\n        for (int j = 0; j < 2; j++)\\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\\n        */\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed in four clusters in\\n * 2D space and trains an SOM that finds the topological pattern.\\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\\n * files are created to validate the execution:\\n * * `test1.csv`: random test samples points with a circular pattern\\n * * `w11.csv`: initial random U-matrix\\n * * `w12.csv`: trained SOM U-matrix\\n */\\nvoid test1()\\n{\\n    int j, N = 300;\\n    int features = 2;\\n    int num_out = 30;  // image size - N x N\\n\\n    // 2D space, hence size = number of rows * 2\\n    double **X = (double **)malloc(N * sizeof(double *));\\n\\n    // cluster nodex in 'x' * cluster nodes in 'y' * 2\\n    struct kohonen_array_3d W;\\n    W.dim1 = num_out;\\n    W.dim2 = num_out;\\n    W.dim3 = features;\\n    W.data = (double *)malloc(num_out * num_out * features *\\n                              sizeof(double));  // assign rows\\n\\n    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)\\n    {\\n        if (i < N)  // only add new arrays if i < N\\n            X[i] = (double *)malloc(features * sizeof(double));\\n        if (i < num_out)  // only add new arrays if i < num_out\\n        {\\n            for (int k = 0; k < num_out; k++)\\n            {\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n                // preallocate with random initial weights\\n                for (j = 0; j < features; j++)\\n                {\\n                    double *w = kohonen_data_3d(&W, i, k, j);\\n                    w[0] = _random(-5, 5);\\n                }\\n            }\\n        }\\n    }\\n\\n    test_2d_classes(X, N);  // create test data around circumference of a circle\\n    save_2d_data(\\\"test1.csv\\\", X, N, features);  // save test data points\\n    save_u_matrix(\\\"w11.csv\\\", &W);               // save initial random weights\\n    kohonen_som(X, &W, N, features, num_out, 1e-4);  // train the SOM\\n    save_u_matrix(\\\"w12.csv\\\", &W);  // save the resultant weights\\n\\n    for (int i = 0; i < N; i++) free(X[i]);\\n    free(X);\\n    free(W.data);\\n}\\n\\n/** Creates a random set of points distributed in four clusters in\\n * 3D space with centroids at the points\\n * * \\\\f$(0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(0,5,-0.5, -0.5)\\\\f$\\n * * \\\\f$(-0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(-0,5,-0.5, -0.5)\\\\f$\\n *\\n * \\\\param[out] data matrix to store data in\\n * \\\\param[in] N number of points required\\n */\\nvoid test_3d_classes1(double *const *data, int N)\\n{\\n    const double R = 0.2;  // radius of cluster\\n    int i;\\n    const int num_classes = 4;\\n    const double centres[][3] = {\\n        // centres of each class cluster\\n        {.5, .5, .5},    // centre of class 1\\n        {.5, -.5, -.5},  // centre of class 2\\n        {-.5, .5, .5},   // centre of class 3\\n        {-.5, -.5 - .5}  // centre of class 4\\n    };\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++)\\n    {\\n        int class =\\n            rand() % num_classes;  // select a random class for the point\\n\\n        // create random coordinates (x,y,z) around the centre of the class\\n        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);\\n        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);\\n        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);\\n\\n        /* The follosing can also be used\\n        for (int j = 0; j < 3; j++)\\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\\n        */\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed in 4 clusters in\\n * 3D space and trains an SOM that finds the topological pattern. The following\\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\\n * to validate the execution:\\n * * `test2.csv`: random test samples points\\n * * `w21.csv`: initial random U-matrix\\n * * `w22.csv`: trained SOM U-matrix\\n */\\nvoid test2()\\n{\\n    int j, N = 500;\\n    int features = 3;\\n    int num_out = 30;  // image size - N x N\\n\\n    // 3D space, hence size = number of rows * 3\\n    double **X = (double **)malloc(N * sizeof(double *));\\n\\n    // cluster nodex in 'x' * cluster nodes in 'y' * 2\\n    struct kohonen_array_3d W;\\n    W.dim1 = num_out;\\n    W.dim2 = num_out;\\n    W.dim3 = features;\\n    W.data = (double *)malloc(num_out * num_out * features *\\n                              sizeof(double));  // assign rows\\n\\n    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)\\n    {\\n        if (i < N)  // only add new arrays if i < N\\n            X[i] = (double *)malloc(features * sizeof(double));\\n        if (i < num_out)  // only add new arrays if i < num_out\\n        {\\n            for (int k = 0; k < num_out; k++)\\n            {\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n                for (j = 0; j < features; j++)\\n                {  // preallocate with random initial weights\\n                    double *w = kohonen_data_3d(&W, i, k, j);\\n                    w[0] = _random(-5, 5);\\n                }\\n            }\\n        }\\n    }\\n\\n    test_3d_classes1(X, N);                     // create test data\\n    save_2d_data(\\\"test2.csv\\\", X, N, features);  // save test data points\\n    save_u_matrix(\\\"w21.csv\\\", &W);               // save initial random weights\\n    kohonen_som(X, &W, N, features, num_out, 1e-4);  // train the SOM\\n    save_u_matrix(\\\"w22.csv\\\", &W);  // save the resultant weights\\n\\n    for (int i = 0; i < N; i++) free(X[i]);\\n    free(X);\\n    free(W.data);\\n}\\n\\n/** Creates a random set of points distributed in four clusters in\\n * 3D space with centroids at the points\\n * * \\\\f$(0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(0,5,-0.5, -0.5)\\\\f$\\n * * \\\\f$(-0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(-0,5,-0.5, -0.5)\\\\f$\\n *\\n * \\\\param[out] data matrix to store data in\\n * \\\\param[in] N number of points required\\n */\\nvoid test_3d_classes2(double *const *data, int N)\\n{\\n    const double R = 0.2;  // radius of cluster\\n    int i;\\n    const int num_classes = 8;\\n    const double centres[][3] = {\\n        // centres of each class cluster\\n        {.5, .5, .5},    // centre of class 1\\n        {.5, .5, -.5},   // centre of class 2\\n        {.5, -.5, .5},   // centre of class 3\\n        {.5, -.5, -.5},  // centre of class 4\\n        {-.5, .5, .5},   // centre of class 5\\n        {-.5, .5, -.5},  // centre of class 6\\n        {-.5, -.5, .5},  // centre of class 7\\n        {-.5, -.5, -.5}  // centre of class 8\\n    };\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++)\\n    {\\n        int class =\\n            rand() % num_classes;  // select a random class for the point\\n\\n        // create random coordinates (x,y,z) around the centre of the class\\n        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);\\n        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);\\n        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);\\n\\n        /* The follosing can also be used\\n        for (int j = 0; j < 3; j++)\\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\\n        */\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed in eight clusters in\\n * 3D space and trains an SOM that finds the topological pattern. The following\\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\\n * to validate the execution:\\n * * `test3.csv`: random test samples points\\n * * `w31.csv`: initial random U-matrix\\n * * `w32.csv`: trained SOM U-matrix\\n */\\nvoid test3()\\n{\\n    int j, N = 500;\\n    int features = 3;\\n    int num_out = 30;\\n    double **X = (double **)malloc(N * sizeof(double *));\\n\\n    // cluster nodex in 'x' * cluster nodes in 'y' * 2\\n    struct kohonen_array_3d W;\\n    W.dim1 = num_out;\\n    W.dim2 = num_out;\\n    W.dim3 = features;\\n    W.data = (double *)malloc(num_out * num_out * features *\\n                              sizeof(double));  // assign rows\\n\\n    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)\\n    {\\n        if (i < N)  // only add new arrays if i < N\\n            X[i] = (double *)malloc(features * sizeof(double));\\n        if (i < num_out)  // only add new arrays if i < num_out\\n        {\\n            for (int k = 0; k < num_out; k++)\\n            {\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n                // preallocate with random initial weights\\n                for (j = 0; j < features; j++)\\n                {\\n                    double *w = kohonen_data_3d(&W, i, k, j);\\n                    w[0] = _random(-5, 5);\\n                }\\n            }\\n        }\\n    }\\n\\n    test_3d_classes2(X, N);  // create test data around the lamniscate\\n    save_2d_data(\\\"test3.csv\\\", X, N, features);  // save test data points\\n    save_u_matrix(\\\"w31.csv\\\", &W);               // save initial random weights\\n    kohonen_som(X, &W, N, features, num_out, 0.01);  // train the SOM\\n    save_u_matrix(\\\"w32.csv\\\", &W);  // save the resultant weights\\n\\n    for (int i = 0; i < N; i++) free(X[i]);\\n    free(X);\\n    free(W.data);\\n}\\n\\n/**\\n * Convert clock cycle difference to time in seconds\\n *\\n * \\\\param[in] start_t start clock\\n * \\\\param[in] end_t end clock\\n * \\\\returns time difference in seconds\\n */\\ndouble get_clock_diff(clock_t start_t, clock_t end_t)\\n{\\n    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;\\n}\\n\\n/** Main function */\\nint main(int argc, char **argv)\\n{\\n#ifdef _OPENMP\\n    printf(\\\"Using OpenMP based parallelization\\\\n\\\");\\n#else\\n    printf(\\\"NOT using OpenMP based parallelization\\\\n\\\");\\n#endif\\n    clock_t start_clk, end_clk;\\n\\n    start_clk = clock();\\n    test1();\\n    end_clk = clock();\\n    printf(\\\"Test 1 completed in %.4g sec\\\\n\\\",\\n           get_clock_diff(start_clk, end_clk));\\n\\n    start_clk = clock();\\n    test2();\\n    end_clk = clock();\\n    printf(\\\"Test 2 completed in %.4g sec\\\\n\\\",\\n           get_clock_diff(start_clk, end_clk));\\n\\n    start_clk = clock();\\n    test3();\\n    end_clk = clock();\\n    printf(\\\"Test 3 completed in %.4g sec\\\\n\\\",\\n           get_clock_diff(start_clk, end_clk));\\n\\n    printf(\\\"(Note: Calculated times include: writing files to disk.)\\\\n\\\\n\\\");\\n    return 0;\\n}\\n\"",
    "kohonen som trace": "\"/**\\n * \\\\file\\n * \\\\brief [Kohonen self organizing\\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (data tracing)\\n *\\n * \\\\details\\n * This example implements a powerful self organizing map algorithm.\\n * The algorithm creates a connected network of weights that closely\\n * follows the given data points. This this creates a chain of nodes that\\n * resembles the given input shape.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n * \\\\see kohonen_som_topology.c\\n */\\n#define _USE_MATH_DEFINES /**< required for MS Visual C */\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#ifdef _OPENMP  // check if OpenMP based parallelization is available\\n#include <omp.h>\\n#endif\\n\\n/**\\n * @addtogroup machine_learning Machine learning algorithms\\n * @{\\n * @addtogroup kohonen_1d Kohonen SOM trace/chain algorithm\\n * @{\\n */\\n\\n#ifndef max\\n/** shorthand for maximum value */\\n#define max(a, b) (((a) > (b)) ? (a) : (b))\\n#endif\\n#ifndef min\\n/** shorthand for minimum value */\\n#define min(a, b) (((a) < (b)) ? (a) : (b))\\n#endif\\n\\n/**\\n * \\\\brief Helper function to generate a random number in a given interval.\\n * \\\\details\\n * \\\\n Steps:\\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\\n * 3. scale and offset the random number to given range of \\\\f$[a,b)\\\\f$\\n * \\\\f[\\n * y = (b - a) \\\\times \\\\frac{\\\\text{(random number between 0 and RAND_MAX)} \\\\;\\n * \\\\text{mod}\\\\; 100}{100} + a \\\\f]\\n *\\n * \\\\param a lower limit\\n * \\\\param b upper limit\\n * \\\\returns random number in the range \\\\f$[a,b)\\\\f$\\n */\\ndouble _random(double a, double b)\\n{\\n    int r = rand() % 100;\\n    return ((b - a) * r / 100.f) + a;\\n}\\n\\n/**\\n * Save a given n-dimensional data martix to file.\\n *\\n * \\\\param [in] fname filename to save in (gets overwriten without confirmation)\\n * \\\\param [in] X matrix to save\\n * \\\\param [in] num_points rows in the matrix = number of points\\n * \\\\param [in] num_features columns in the matrix = dimensions of points\\n * \\\\returns 0 if all ok\\n * \\\\returns -1 if file creation failed\\n */\\nint save_nd_data(const char *fname, double **X, int num_points,\\n                 int num_features)\\n{\\n    FILE *fp = fopen(fname, \\\"wt\\\");\\n    if (!fp)  // error with fopen\\n    {\\n        char msg[120];\\n        sprintf(msg, \\\"File error (%s): \\\", fname);\\n        perror(msg);\\n        return -1;\\n    }\\n\\n    for (int i = 0; i < num_points; i++)  // for each point in the array\\n    {\\n        for (int j = 0; j < num_features; j++)  // for each feature in the array\\n        {\\n            fprintf(fp, \\\"%.4g\\\", X[i][j]);  // print the feature value\\n            if (j < num_features - 1)      // if not the last feature\\n                fprintf(fp, \\\",\\\");          // suffix comma\\n        }\\n        if (i < num_points - 1)  // if not the last row\\n            fprintf(fp, \\\"\\\\n\\\");   // start a new line\\n    }\\n    fclose(fp);\\n    return 0;\\n}\\n\\n/**\\n * Get minimum value and index of the value in a vector\\n * \\\\param[in] X vector to search\\n * \\\\param[in] N number of points in the vector\\n * \\\\param[out] val minimum value found\\n * \\\\param[out] idx index where minimum value was found\\n */\\nvoid kohonen_get_min_1d(double const *X, int N, double *val, int *idx)\\n{\\n    val[0] = INFINITY;  // initial min value\\n\\n    for (int i = 0; i < N; i++)  // check each value\\n    {\\n        if (X[i] < val[0])  // if a lower value is found\\n        {                   // save the value and its index\\n            idx[0] = i;\\n            val[0] = X[i];\\n        }\\n    }\\n}\\n\\n/**\\n * Update weights of the SOM using Kohonen algorithm\\n *\\n * \\\\param[in] x data point\\n * \\\\param[in,out] W weights matrix\\n * \\\\param[in,out] D temporary vector to store distances\\n * \\\\param[in] num_out number of output points\\n * \\\\param[in] num_features number of features per input sample\\n * \\\\param[in] alpha learning rate \\\\f$0<\\\\alpha\\\\le1\\\\f$\\n * \\\\param[in] R neighborhood range\\n */\\nvoid kohonen_update_weights(double const *x, double *const *W, double *D,\\n                            int num_out, int num_features, double alpha, int R)\\n{\\n    int j, k;\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    // step 1: for each output point\\n    for (j = 0; j < num_out; j++)\\n    {\\n        D[j] = 0.f;\\n        // compute Euclidian distance of each output\\n        // point from the current sample\\n        for (k = 0; k < num_features; k++)\\n            D[j] += (W[j][k] - x[k]) * (W[j][k] - x[k]);\\n    }\\n\\n    // step 2:  get closest node i.e., node with smallest Euclidian distance to\\n    // the current pattern\\n    int d_min_idx;\\n    double d_min;\\n    kohonen_get_min_1d(D, num_out, &d_min, &d_min_idx);\\n\\n    // step 3a: get the neighborhood range\\n    int from_node = max(0, d_min_idx - R);\\n    int to_node = min(num_out, d_min_idx + R + 1);\\n\\n    // step 3b: update the weights of nodes in the\\n    // neighborhood\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (j = from_node; j < to_node; j++)\\n        for (k = 0; k < num_features; k++)\\n            // update weights of nodes in the neighborhood\\n            W[j][k] += alpha * (x[k] - W[j][k]);\\n}\\n\\n/**\\n * Apply incremental algorithm with updating neighborhood and learning rates\\n * on all samples in the given datset.\\n *\\n * \\\\param[in] X data set\\n * \\\\param[in,out] W weights matrix\\n * \\\\param[in] num_samples number of output points\\n * \\\\param[in] num_features number of features per input sample\\n * \\\\param[in] num_out number of output points\\n * \\\\param[in] alpha_min terminal value of alpha\\n */\\nvoid kohonen_som_tracer(double **X, double *const *W, int num_samples,\\n                        int num_features, int num_out, double alpha_min)\\n{\\n    int R = num_out >> 2, iter = 0;\\n    double alpha = 1.f;\\n    double *D = (double *)malloc(num_out * sizeof(double));\\n\\n    // Loop alpha from 1 to alpha_min\\n    for (; alpha > alpha_min; alpha -= 0.01, iter++)\\n    {\\n        // Loop for each sample pattern in the data set\\n        for (int sample = 0; sample < num_samples; sample++)\\n        {\\n            const double *x = X[sample];\\n            // update weights for the current input pattern sample\\n            kohonen_update_weights(x, W, D, num_out, num_features, alpha, R);\\n        }\\n\\n        // every 10th iteration, reduce the neighborhood range\\n        if (iter % 10 == 0 && R > 1)\\n            R--;\\n    }\\n\\n    free(D);\\n}\\n\\n/**\\n * @}\\n * @}\\n */\\n\\n/** Creates a random set of points distributed *near* the circumference\\n * of a circle and trains an SOM that finds that circular pattern. The\\n * generating function is\\n * \\\\f{eqnarray*}{\\n * r &\\\\in& [1-\\\\delta r, 1+\\\\delta r)\\\\\\\\\\n * \\\\theta &\\\\in& [0, 2\\\\pi)\\\\\\\\\\n * x &=& r\\\\cos\\\\theta\\\\\\\\\\n * y &=& r\\\\sin\\\\theta\\n * \\\\f}\\n *\\n * \\\\param[out] data matrix to store data in\\n * \\\\param[in] N number of points required\\n */\\nvoid test_circle(double *const *data, int N)\\n{\\n    const double R = 0.75, dr = 0.3;\\n    double a_t = 0., b_t = 2.f * M_PI;  // theta random between 0 and 2*pi\\n    double a_r = R - dr, b_r = R + dr;  // radius random between R-dr and R+dr\\n    int i;\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++)\\n    {\\n        double r = _random(a_r, b_r);      // random radius\\n        double theta = _random(a_t, b_t);  // random theta\\n        data[i][0] = r * cos(theta);       // convert from polar to cartesian\\n        data[i][1] = r * sin(theta);\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed *near* the\\n * circumference of a circle and trains an SOM that finds that circular pattern.\\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\\n * files are created to validate the execution:\\n * * `test1.csv`: random test samples points with a circular pattern\\n * * `w11.csv`: initial random map\\n * * `w12.csv`: trained SOM map\\n *\\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\\n * the following snippet\\n * ```gnuplot\\n * set datafile separator ','\\n * plot \\\"test1.csv\\\" title \\\"original\\\", \\\\\\n *      \\\"w11.csv\\\" title \\\"w1\\\", \\\\\\n *      \\\"w12.csv\\\" title \\\"w2\\\"\\n * ```\\n * ![Sample execution\\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test1.svg)\\n */\\nvoid test1()\\n{\\n    int j, N = 500;\\n    int features = 2;\\n    int num_out = 50;\\n\\n    // 2D space, hence size = number of rows * 2\\n    double **X = (double **)malloc(N * sizeof(double *));\\n\\n    // number of clusters nodes * 2\\n    double **W = (double **)malloc(num_out * sizeof(double *));\\n\\n    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)\\n    {\\n        if (i < N)  // only add new arrays if i < N\\n            X[i] = (double *)malloc(features * sizeof(double));\\n        if (i < num_out)  // only add new arrays if i < num_out\\n        {\\n            W[i] = (double *)malloc(features * sizeof(double));\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n            // preallocate with random initial weights\\n            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);\\n        }\\n    }\\n\\n    test_circle(X, N);  // create test data around circumference of a circle\\n    save_nd_data(\\\"test1.csv\\\", X, N, features);  // save test data points\\n    save_nd_data(\\\"w11.csv\\\", W, num_out,\\n                 features);  // save initial random weights\\n    kohonen_som_tracer(X, W, N, features, num_out, 0.1);  // train the SOM\\n    save_nd_data(\\\"w12.csv\\\", W, num_out,\\n                 features);  // save the resultant weights\\n\\n    for (int i = 0; i < max(num_out, N); i++)\\n    {\\n        if (i < N)\\n            free(X[i]);\\n        if (i < num_out)\\n            free(W[i]);\\n    }\\n}\\n\\n/** Creates a random set of points distributed *near* the locus\\n * of the [Lamniscate of\\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono).\\n * \\\\f{eqnarray*}{\\n * \\\\delta r &=& 0.2\\\\\\\\\\n * \\\\delta x &\\\\in& [-\\\\delta r, \\\\delta r)\\\\\\\\\\n * \\\\delta y &\\\\in& [-\\\\delta r, \\\\delta r)\\\\\\\\\\n * \\\\theta &\\\\in& [0, \\\\pi)\\\\\\\\\\n * x &=& \\\\delta x + \\\\cos\\\\theta\\\\\\\\\\n * y &=& \\\\delta y + \\\\frac{\\\\sin(2\\\\theta)}{2}\\n * \\\\f}\\n * \\\\param[out] data matrix to store data in\\n * \\\\param[in] N number of points required\\n */\\nvoid test_lamniscate(double *const *data, int N)\\n{\\n    const double dr = 0.2;\\n    int i;\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++)\\n    {\\n        double dx = _random(-dr, dr);     // random change in x\\n        double dy = _random(-dr, dr);     // random change in y\\n        double theta = _random(0, M_PI);  // random theta\\n        data[i][0] = dx + cos(theta);     // convert from polar to cartesian\\n        data[i][1] = dy + sin(2. * theta) / 2.f;\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed *near* the locus\\n * of the [Lamniscate of\\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono) and trains an SOM\\n * that finds that circular pattern. The following\\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\\n * to validate the execution:\\n * * `test2.csv`: random test samples points with a lamniscate pattern\\n * * `w21.csv`: initial random map\\n * * `w22.csv`: trained SOM map\\n *\\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\\n * the following snippet\\n * ```gnuplot\\n * set datafile separator ','\\n * plot \\\"test2.csv\\\" title \\\"original\\\", \\\\\\n *      \\\"w21.csv\\\" title \\\"w1\\\", \\\\\\n *      \\\"w22.csv\\\" title \\\"w2\\\"\\n * ```\\n * ![Sample execution\\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test2.svg)\\n */\\nvoid test2()\\n{\\n    int j, N = 500;\\n    int features = 2;\\n    int num_out = 20;\\n    double **X = (double **)malloc(N * sizeof(double *));\\n    double **W = (double **)malloc(num_out * sizeof(double *));\\n    for (int i = 0; i < max(num_out, N); i++)\\n    {\\n        if (i < N)  // only add new arrays if i < N\\n            X[i] = (double *)malloc(features * sizeof(double));\\n        if (i < num_out)  // only add new arrays if i < num_out\\n        {\\n            W[i] = (double *)malloc(features * sizeof(double));\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n            // preallocate with random initial weights\\n            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);\\n        }\\n    }\\n\\n    test_lamniscate(X, N);  // create test data around the lamniscate\\n    save_nd_data(\\\"test2.csv\\\", X, N, features);  // save test data points\\n    save_nd_data(\\\"w21.csv\\\", W, num_out,\\n                 features);  // save initial random weights\\n    kohonen_som_tracer(X, W, N, features, num_out, 0.01);  // train the SOM\\n    save_nd_data(\\\"w22.csv\\\", W, num_out,\\n                 features);  // save the resultant weights\\n\\n    for (int i = 0; i < max(num_out, N); i++)\\n    {\\n        if (i < N)\\n            free(X[i]);\\n        if (i < num_out)\\n            free(W[i]);\\n    }\\n    free(X);\\n    free(W);\\n}\\n\\n/** Creates a random set of points distributed in four clusters in\\n * 3D space with centroids at the points\\n * * \\\\f$(0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(0,5,-0.5, -0.5)\\\\f$\\n * * \\\\f$(-0,5, 0.5, 0.5)\\\\f$\\n * * \\\\f$(-0,5,-0.5, -0.5)\\\\f$\\n *\\n * \\\\param[out] data matrix to store data in\\n * \\\\param[in] N number of points required\\n */\\nvoid test_3d_classes(double *const *data, int N)\\n{\\n    const double R = 0.1;  // radius of cluster\\n    int i;\\n    const int num_classes = 4;\\n    const double centres[][3] = {\\n        // centres of each class cluster\\n        {.5, .5, .5},    // centre of class 1\\n        {.5, -.5, -.5},  // centre of class 2\\n        {-.5, .5, .5},   // centre of class 3\\n        {-.5, -.5 - .5}  // centre of class 4\\n    };\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++)\\n    {\\n        int class =\\n            rand() % num_classes;  // select a random class for the point\\n\\n        // create random coordinates (x,y,z) around the centre of the class\\n        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);\\n        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);\\n        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);\\n\\n        /* The follosing can also be used\\n        for (int j = 0; j < 3; j++)\\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\\n        */\\n    }\\n}\\n\\n/** Test that creates a random set of points distributed in six clusters in\\n * 3D space. The following\\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\\n * to validate the execution:\\n * * `test3.csv`: random test samples points with a circular pattern\\n * * `w31.csv`: initial random map\\n * * `w32.csv`: trained SOM map\\n *\\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\\n * the following snippet\\n * ```gnuplot\\n * set datafile separator ','\\n * plot \\\"test3.csv\\\" title \\\"original\\\", \\\\\\n *      \\\"w31.csv\\\" title \\\"w1\\\", \\\\\\n *      \\\"w32.csv\\\" title \\\"w2\\\"\\n * ```\\n * ![Sample execution\\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test3.svg)\\n */\\nvoid test3()\\n{\\n    int j, N = 200;\\n    int features = 3;\\n    int num_out = 20;\\n    double **X = (double **)malloc(N * sizeof(double *));\\n    double **W = (double **)malloc(num_out * sizeof(double *));\\n    for (int i = 0; i < max(num_out, N); i++)\\n    {\\n        if (i < N)  // only add new arrays if i < N\\n            X[i] = (double *)malloc(features * sizeof(double));\\n        if (i < num_out)  // only add new arrays if i < num_out\\n        {\\n            W[i] = (double *)malloc(features * sizeof(double));\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n            // preallocate with random initial weights\\n            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);\\n        }\\n    }\\n\\n    test_3d_classes(X, N);  // create test data around the lamniscate\\n    save_nd_data(\\\"test3.csv\\\", X, N, features);  // save test data points\\n    save_nd_data(\\\"w31.csv\\\", W, num_out,\\n                 features);  // save initial random weights\\n    kohonen_som_tracer(X, W, N, features, num_out, 0.01);  // train the SOM\\n    save_nd_data(\\\"w32.csv\\\", W, num_out,\\n                 features);  // save the resultant weights\\n\\n    for (int i = 0; i < max(num_out, N); i++)\\n    {\\n        if (i < N)\\n            free(X[i]);\\n        if (i < num_out)\\n            free(W[i]);\\n    }\\n    free(X);\\n    free(W);\\n}\\n\\n/**\\n * Convert clock cycle difference to time in seconds\\n *\\n * \\\\param[in] start_t start clock\\n * \\\\param[in] end_t end clock\\n * \\\\returns time difference in seconds\\n */\\ndouble get_clock_diff(clock_t start_t, clock_t end_t)\\n{\\n    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;\\n}\\n\\n/** Main function */\\nint main(int argc, char **argv)\\n{\\n#ifdef _OPENMP\\n    printf(\\\"Using OpenMP based parallelization\\\\n\\\");\\n#else\\n    printf(\\\"NOT using OpenMP based parallelization\\\\n\\\");\\n#endif\\n    clock_t start_clk = clock();\\n    test1();\\n    clock_t end_clk = clock();\\n    printf(\\\"Test 1 completed in %.4g sec\\\\n\\\",\\n           get_clock_diff(start_clk, end_clk));\\n    start_clk = clock();\\n    test2();\\n    end_clk = clock();\\n    printf(\\\"Test 2 completed in %.4g sec\\\\n\\\",\\n           get_clock_diff(start_clk, end_clk));\\n    start_clk = clock();\\n    test3();\\n    end_clk = clock();\\n    printf(\\\"Test 3 completed in %.4g sec\\\\n\\\",\\n           get_clock_diff(start_clk, end_clk));\\n    printf(\\n        \\\"(Note: Calculated times include: creating test sets, training \\\"\\n        \\\"model and writing files to disk.)\\\\n\\\\n\\\");\\n    return 0;\\n}\\n\"",
    "k means clustering": "\"/**\\n * @file k_means_clustering.c\\n * @brief K Means Clustering Algorithm implemented\\n * @details\\n * This file has K Means algorithm implemmented\\n * It prints test output in eps format\\n *\\n * Note:\\n * Though the code for clustering works for all the\\n * 2D data points and can be extended for any size vector\\n * by making the required changes, but note that\\n * the output method i.e. printEPS is only good for\\n * polar data points i.e. in a circle and both test\\n * use the same.\\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\\n */\\n\\n#define _USE_MATH_DEFINES /* required for MS Visual C */\\n#include <float.h>        /* DBL_MAX, DBL_MIN */\\n#include <math.h>         /* PI, sin, cos */\\n#include <stdio.h>        /* printf */\\n#include <stdlib.h>       /* rand */\\n#include <string.h>       /* memset */\\n#include <time.h>         /* time */\\n\\n/*!\\n * @addtogroup machine_learning Machine Learning Algorithms\\n * @{\\n * @addtogroup k_means K-Means Clustering Algorithm\\n * @{\\n */\\n\\n/*! @struct observation\\n *  a class to store points in 2d plane\\n *  the name observation is used to denote\\n *  a random point in plane\\n */\\ntypedef struct observation\\n{\\n    double x;  /**< abscissa of 2D data point */\\n    double y;  /**< ordinate of 2D data point */\\n    int group; /**< the group no in which this observation would go */\\n} observation;\\n\\n/*! @struct cluster\\n *  this class stores the coordinates\\n *  of centroid of all the points\\n *  in that cluster it also\\n *  stores the count of observations\\n *  belonging to this cluster\\n */\\ntypedef struct cluster\\n{\\n    double x;     /**< abscissa centroid of this cluster */\\n    double y;     /**< ordinate of centroid of this cluster */\\n    size_t count; /**< count of observations present in this cluster */\\n} cluster;\\n\\n/*!\\n * Returns the index of centroid nearest to\\n * given observation\\n *\\n * @param o  observation\\n * @param clusters  array of cluster having centroids coordinates\\n * @param k  size of clusters array\\n *\\n * @returns the index of nearest centroid for given observation\\n */\\nint calculateNearst(observation* o, cluster clusters[], int k)\\n{\\n    double minD = DBL_MAX;\\n    double dist = 0;\\n    int index = -1;\\n    int i = 0;\\n    for (; i < k; i++)\\n    {\\n        /* Calculate Squared Distance*/\\n        dist = (clusters[i].x - o->x) * (clusters[i].x - o->x) +\\n               (clusters[i].y - o->y) * (clusters[i].y - o->y);\\n        if (dist < minD)\\n        {\\n            minD = dist;\\n            index = i;\\n        }\\n    }\\n    return index;\\n}\\n\\n/*!\\n * Calculate centoid and assign it to the cluster variable\\n *\\n * @param observations  an array of observations whose centroid is calculated\\n * @param size  size of the observations array\\n * @param centroid  a reference to cluster object to store information of\\n * centroid\\n */\\nvoid calculateCentroid(observation observations[], size_t size,\\n                       cluster* centroid)\\n{\\n    size_t i = 0;\\n    centroid->x = 0;\\n    centroid->y = 0;\\n    centroid->count = size;\\n    for (; i < size; i++)\\n    {\\n        centroid->x += observations[i].x;\\n        centroid->y += observations[i].y;\\n        observations[i].group = 0;\\n    }\\n    centroid->x /= centroid->count;\\n    centroid->y /= centroid->count;\\n}\\n\\n/*!\\n *    --K Means Algorithm--\\n * 1. Assign each observation to one of k groups\\n *    creating a random initial clustering\\n * 2. Find the centroid of observations for each\\n *    cluster to form new centroids\\n * 3. Find the centroid which is nearest for each\\n *    observation among the calculated centroids\\n * 4. Assign the observation to its nearest centroid\\n *    to create a new clustering.\\n * 5. Repeat step 2,3,4 until there is no change\\n *    the current clustering and is same as last\\n *    clustering.\\n *\\n * @param observations  an array of observations to cluster\\n * @param size  size of observations array\\n * @param k  no of clusters to be made\\n *\\n * @returns pointer to cluster object\\n */\\ncluster* kMeans(observation observations[], size_t size, int k)\\n{\\n    cluster* clusters = NULL;\\n    if (k <= 1)\\n    {\\n        /*\\n        If we have to cluster them only in one group\\n        then calculate centroid of observations and\\n        that will be a ingle cluster\\n        */\\n        clusters = (cluster*)malloc(sizeof(cluster));\\n        memset(clusters, 0, sizeof(cluster));\\n        calculateCentroid(observations, size, clusters);\\n    }\\n    else if (k < size)\\n    {\\n        clusters = malloc(sizeof(cluster) * k);\\n        memset(clusters, 0, k * sizeof(cluster));\\n        /* STEP 1 */\\n        for (size_t j = 0; j < size; j++)\\n        {\\n            observations[j].group = rand() % k;\\n        }\\n        size_t changed = 0;\\n        size_t minAcceptedError =\\n            size /\\n            10000;  // Do until 99.99 percent points are in correct cluster\\n        int t = 0;\\n        do\\n        {\\n            /* Initialize clusters */\\n            for (int i = 0; i < k; i++)\\n            {\\n                clusters[i].x = 0;\\n                clusters[i].y = 0;\\n                clusters[i].count = 0;\\n            }\\n            /* STEP 2*/\\n            for (size_t j = 0; j < size; j++)\\n            {\\n                t = observations[j].group;\\n                clusters[t].x += observations[j].x;\\n                clusters[t].y += observations[j].y;\\n                clusters[t].count++;\\n            }\\n            for (int i = 0; i < k; i++)\\n            {\\n                clusters[i].x /= clusters[i].count;\\n                clusters[i].y /= clusters[i].count;\\n            }\\n            /* STEP 3 and 4 */\\n            changed = 0;  // this variable stores change in clustering\\n            for (size_t j = 0; j < size; j++)\\n            {\\n                t = calculateNearst(observations + j, clusters, k);\\n                if (t != observations[j].group)\\n                {\\n                    changed++;\\n                    observations[j].group = t;\\n                }\\n            }\\n        } while (changed > minAcceptedError);  // Keep on grouping until we have\\n                                               // got almost best clustering\\n    }\\n    else\\n    {\\n        /* If no of clusters is more than observations\\n           each observation can be its own cluster\\n        */\\n        clusters = (cluster*)malloc(sizeof(cluster) * k);\\n        memset(clusters, 0, k * sizeof(cluster));\\n        for (int j = 0; j < size; j++)\\n        {\\n            clusters[j].x = observations[j].x;\\n            clusters[j].y = observations[j].y;\\n            clusters[j].count = 1;\\n            observations[j].group = j;\\n        }\\n    }\\n    return clusters;\\n}\\n\\n/**\\n * @}\\n * @}\\n */\\n\\n/*!\\n * A function to print observations and clusters\\n * The code is taken from\\n * http://rosettacode.org/wiki/K-means%2B%2B_clustering.\\n * Even the K Means code is also inspired from it\\n *\\n * @note To print in a file use pipeline operator\\n * ```sh\\n * ./k_means_clustering > image.eps\\n * ```\\n *\\n * @param observations  observations array\\n * @param len  size of observation array\\n * @param cent  clusters centroid's array\\n * @param k  size of cent array\\n */\\nvoid printEPS(observation pts[], size_t len, cluster cent[], int k)\\n{\\n    int W = 400, H = 400;\\n    double min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;\\n    double scale = 0, cx = 0, cy = 0;\\n    double* colors = (double*)malloc(sizeof(double) * (k * 3));\\n    int i;\\n    size_t j;\\n    double kd = k * 1.0;\\n    for (i = 0; i < k; i++)\\n    {\\n        *(colors + 3 * i) = (3 * (i + 1) % k) / kd;\\n        *(colors + 3 * i + 1) = (7 * i % k) / kd;\\n        *(colors + 3 * i + 2) = (9 * i % k) / kd;\\n    }\\n\\n    for (j = 0; j < len; j++)\\n    {\\n        if (max_x < pts[j].x)\\n        {\\n            max_x = pts[j].x;\\n        }\\n        if (min_x > pts[j].x)\\n        {\\n            min_x = pts[j].x;\\n        }\\n        if (max_y < pts[j].y)\\n        {\\n            max_y = pts[j].y;\\n        }\\n        if (min_y > pts[j].y)\\n        {\\n            min_y = pts[j].y;\\n        }\\n    }\\n    scale = W / (max_x - min_x);\\n    if (scale > (H / (max_y - min_y)))\\n    {\\n        scale = H / (max_y - min_y);\\n    };\\n    cx = (max_x + min_x) / 2;\\n    cy = (max_y + min_y) / 2;\\n\\n    printf(\\\"%%!PS-Adobe-3.0 EPSF-3.0\\\\n%%%%BoundingBox: -5 -5 %d %d\\\\n\\\", W + 10,\\n           H + 10);\\n    printf(\\n        \\\"/l {rlineto} def /m {rmoveto} def\\\\n\\\"\\n        \\\"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\\\n\\\"\\n        \\\"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\\"\\n        \\\"\\tgsave 1 setgray fill grestore gsave 3 setlinewidth\\\"\\n        \\\" 1 setgray stroke grestore 0 setgray stroke }def\\\\n\\\");\\n    for (int i = 0; i < k; i++)\\n    {\\n        printf(\\\"%g %g %g setrgbcolor\\\\n\\\", *(colors + 3 * i),\\n               *(colors + 3 * i + 1), *(colors + 3 * i + 2));\\n        for (j = 0; j < len; j++)\\n        {\\n            if (pts[j].group != i)\\n            {\\n                continue;\\n            }\\n            printf(\\\"%.3f %.3f c\\\\n\\\", (pts[j].x - cx) * scale + W / 2,\\n                   (pts[j].y - cy) * scale + H / 2);\\n        }\\n        printf(\\\"\\\\n0 setgray %g %g s\\\\n\\\", (cent[i].x - cx) * scale + W / 2,\\n               (cent[i].y - cy) * scale + H / 2);\\n    }\\n    printf(\\\"\\\\n%%%%EOF\\\");\\n\\n    // free accquired memory\\n    free(colors);\\n}\\n\\n/*!\\n * A function to test the kMeans function\\n * Generates 100000 points in a circle of\\n * radius 20.0 with center at (0,0)\\n * and cluster them into 5 clusters\\n *\\n * <img alt=\\\"Output for 100000 points divided in 5 clusters\\\" src=\\n * \\\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest1.png\\\"\\n * width=\\\"400px\\\" heiggt=\\\"400px\\\">\\n * @returns None\\n */\\nstatic void test()\\n{\\n    size_t size = 100000L;\\n    observation* observations =\\n        (observation*)malloc(sizeof(observation) * size);\\n    double maxRadius = 20.00;\\n    double radius = 0;\\n    double ang = 0;\\n    size_t i = 0;\\n    for (; i < size; i++)\\n    {\\n        radius = maxRadius * ((double)rand() / RAND_MAX);\\n        ang = 2 * M_PI * ((double)rand() / RAND_MAX);\\n        observations[i].x = radius * cos(ang);\\n        observations[i].y = radius * sin(ang);\\n    }\\n    int k = 5;  // No of clusters\\n    cluster* clusters = kMeans(observations, size, k);\\n    printEPS(observations, size, clusters, k);\\n    // Free the accquired memory\\n    free(observations);\\n    free(clusters);\\n}\\n\\n/*!\\n * A function to test the kMeans function\\n * Generates 1000000 points in a circle of\\n * radius 20.0 with center at (0,0)\\n * and cluster them into 11 clusters\\n *\\n * <img alt=\\\"Output for 1000000 points divided in 11 clusters\\\" src=\\n * \\\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest2.png\\\"\\n * width=\\\"400px\\\" heiggt=\\\"400px\\\">\\n * @returns None\\n */\\nvoid test2()\\n{\\n    size_t size = 1000000L;\\n    observation* observations =\\n        (observation*)malloc(sizeof(observation) * size);\\n    double maxRadius = 20.00;\\n    double radius = 0;\\n    double ang = 0;\\n    size_t i = 0;\\n    for (; i < size; i++)\\n    {\\n        radius = maxRadius * ((double)rand() / RAND_MAX);\\n        ang = 2 * M_PI * ((double)rand() / RAND_MAX);\\n        observations[i].x = radius * cos(ang);\\n        observations[i].y = radius * sin(ang);\\n    }\\n    int k = 11;  // No of clusters\\n    cluster* clusters = kMeans(observations, size, k);\\n    printEPS(observations, size, clusters, k);\\n    // Free the accquired memory\\n    free(observations);\\n    free(clusters);\\n}\\n\\n/*!\\n * This function calls the test\\n * function\\n */\\nint main()\\n{\\n    srand(time(NULL));\\n    test();\\n    /* test2(); */\\n    return 0;\\n}\\n\"",
    "armstrong number": "\"// A number is called as Armstrong number if sum of cubes of digits of number is\\n// equal to the number itself.\\n// For Example 153 is an Armstrong number because 153 = 1³+5³+3³.\\n#include <stdio.h>\\n\\n// Function to calculate x raised to the power y\\nint power(int x, unsigned int y)\\n{\\n    if (y == 0)\\n        return 1;\\n    if (y % 2 == 0)\\n        return power(x, y / 2) * power(x, y / 2);\\n    return x * power(x, y / 2) * power(x, y / 2);\\n}\\n\\n// Function to calculate order of the number\\nint order(int x)\\n{\\n    int n = 0;\\n    while (x)\\n    {\\n        n++;\\n        x = x / 10;\\n    }\\n    return n;\\n}\\n\\n// Function to check whether the given number is\\n// Armstrong number or not\\nint isArmstrong(int x)\\n{\\n    // Calling order function\\n    int n = order(x);\\n    int temp = x, sum = 0;\\n    while (temp)\\n    {\\n        int r = temp % 10;\\n        sum += power(r, n);\\n        temp = temp / 10;\\n    }\\n\\n    // If satisfies Armstrong condition\\n    if (sum == x)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\n//\\nint main()\\n{\\n    int x = 153;\\n    if (isArmstrong(x) == 1)\\n        printf(\\\"True\\\\n\\\");\\n    else\\n        printf(\\\"False\\\\n\\\");\\n\\n    x = 1253;\\n    if (isArmstrong(x) == 1)\\n        printf(\\\"True\\\\n\\\");\\n    else\\n        printf(\\\"False\\\\n\\\");\\n\\n    return 0;\\n}\\n\"",
    "cantor set": "\"/**\\n * @file\\n * @brief Program to generate [Cantor ternary\\n * set](https://en.wikipedia.org/wiki/Cantor_set)\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n/** structure to define Cantor set */\\ntypedef struct _cantor_set\\n{\\n    double start;             /**< start of interval */\\n    double end;               /**< end of interval */\\n    struct _cantor_set *next; /**< pointer to next set */\\n} CantorSet;\\n\\n/** Iterative constructor of all sets in the current level. This function\\n * dynamically allocates memory when creating new sets. These are freed by the\\n * function ::free_memory.\\n * @param head pointer to interval set instance to update\\n */\\nvoid propagate(CantorSet *head)\\n{\\n    // if input is NULL, ignore the process\\n    if (head == NULL)\\n        return;\\n\\n    CantorSet *temp = head;  // local pointer to track propagation\\n\\n    // create new node for the new set\\n    CantorSet *newNode = (CantorSet *)malloc(sizeof(CantorSet));\\n\\n    // get 1/3rd of interval\\n    double diff = (((temp->end) - (temp->start)) / 3);\\n\\n    // update interval ranges\\n    newNode->end = temp->end;\\n    temp->end = ((temp->start) + diff);\\n    newNode->start = (newNode->end) - diff;\\n\\n    // update pointer to next set in this level\\n    newNode->next = temp->next;\\n\\n    // point to next set\\n    temp->next = newNode;\\n\\n    // create next set\\n    propagate(temp->next->next);\\n}\\n\\n/** Print sets in the current range to `stdout`\\n * @param head pointer to first set in the current level\\n */\\nvoid print(CantorSet *head)\\n{\\n    CantorSet *temp = head;\\n    while (temp != NULL)  // print while a valid set is found\\n    {\\n        printf(\\\"\\\\t\\\");\\n        printf(\\\"[%lf] -- \\\", temp->start);\\n        printf(\\\"[%lf]\\\", temp->end);\\n        temp = temp->next;\\n    }\\n\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n/** Clear memory allocated by ::propagate function.\\n * @param head pointer to first allocated instance.\\n */\\nvoid free_memory(CantorSet *head)\\n{\\n    if (!head)\\n        return;\\n\\n    if (head->next)\\n        free_memory(head->next);\\n\\n    free(head);\\n}\\n\\n/** Main function */\\nint main(int argc, char const *argv[])\\n{\\n    int start_num, end_num, levels;\\n\\n    if (argc < 2)\\n    {\\n        printf(\\\"Enter 3 arguments: start_num \\\\t end_num \\\\t levels\\\\n\\\");\\n        scanf(\\\"%d %d %d\\\", &start_num, &end_num, &levels);\\n    }\\n    else\\n    {\\n        start_num = atoi(argv[1]);\\n        end_num = atoi(argv[2]);\\n        levels = atoi(argv[3]);\\n    }\\n\\n    if (start_num < 0 || end_num < 0 || levels < 0)\\n    {\\n        fprintf(stderr, \\\"All numbers must be positive\\\\n\\\");\\n        return -1;\\n    }\\n\\n    CantorSet head = {.start = start_num, .end = end_num, .next = NULL};\\n\\n    // loop to propagate each level from top to bottom\\n    for (int i = 0; i < levels; i++)\\n    {\\n        printf(\\\"Level %d\\\\t\\\", i);\\n        print(&head);\\n        propagate(&head);\\n        printf(\\\"\\\\n\\\");\\n    }\\n    printf(\\\"Level %d\\\\t\\\", levels);\\n    print(&head);\\n\\n    // delete all memory allocated\\n    free_memory(head.next);\\n\\n    return 0;\\n}\\n\"",
    "cartesian to polar": "\"/**\\n * @file\\n * @brief Function to convert a Cartesian co-ordinate to polar form.\\n */\\n#define _USE_MATH_DEFINES /**< required for MS Visual C */\\n#include <assert.h>\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n/**\\n * @brief Function to convert cartesian coordinates to polar.\\n *\\\\f{eqnarray*}{\\n r &=& \\\\sqrt{x^2+y^2}\\\\\\\\\\n \\\\theta &=& \\\\atan\\\\frac{y}{x}\\n \\\\f}\\n * @param [in] x absicca value\\n * @param [in] y ordinate value\\n * @param [out] r pointer to store polar radius\\n * @param [out] theta pointer to store polar angle (in radian)\\n */\\nvoid to_polar(double x, double y, double *r, double *theta)\\n{\\n    double thetaFinal = 0.f;\\n\\n    *r = sqrt(x * x + y * y);\\n\\n    if (x != 0)\\n    {\\n        if (y != 0)\\n        {\\n            *theta = atan(y / x);\\n            if ((x > 0 && y > 0) || (x == -y))\\n            {  // Q1\\n                thetaFinal = *theta;\\n            }\\n            else if (x < 0 && y > 0)\\n            {  // Q2\\n                thetaFinal = *theta + M_PI;\\n            }\\n            else if (x < 0 && y < 0)\\n            {  // Q3\\n                thetaFinal = *theta - M_PI;\\n            }\\n            else if (x > 0 && y < 0)\\n            {  // Q4\\n                thetaFinal = 2 * M_PI - *theta;\\n            }\\n            else\\n            {\\n                fprintf(stderr, \\\"Should not reach here!\\\\n\\\");\\n            }\\n        }\\n    }\\n    else\\n    {  // exceptions when no actual angle is present\\n        if (y > 0)\\n        {\\n            thetaFinal = M_PI / 2;\\n        }\\n        else\\n        {\\n            thetaFinal = -(M_PI / 2);\\n        }\\n    }\\n    if (y == 0)\\n    {\\n        if (x > 0)\\n        {\\n            thetaFinal = 0;\\n        }\\n        else\\n        {\\n            thetaFinal = -M_PI;\\n        }\\n    }\\n\\n    *theta = thetaFinal;\\n}\\n\\n/**\\n * @brief Generate a random number in the given limits\\n *\\n * @param lim1 lower limit\\n * @param lim2 upper limit\\n * @return random number in the given range\\n */\\ndouble get_rand(double lim1, double lim2)\\n{\\n    double r = (double)rand() / RAND_MAX;  // value in [0,1)\\n    return (lim2 - lim1) * r + lim1;       // scale to range\\n}\\n\\n/**\\n * @brief Test implementation\\n *\\n */\\nvoid test()\\n{\\n    srand(10);\\n    int NUM_TESTS = 5;\\n\\n    for (int i = 0; i < NUM_TESTS; i++)\\n    {\\n        double r, theta;\\n        printf(\\\"Test %d.... \\\", i);\\n        double x = get_rand(-5, 5);\\n        double y = get_rand(-5, 5);\\n        printf(\\\"(%.2g, %.2g).... \\\", x, y);\\n        to_polar(x, y, &r, &theta);\\n        assert(fabs(r - hypot(x, y)) < 0.01);\\n        assert(fabs(theta - atan2(y, x)) < 0.01);\\n        printf(\\\"passed\\\\n\\\");\\n    }\\n}\\n\\n/** Main function */\\nint main()\\n{\\n    test();\\n\\n    return 0;\\n}\\n\"",
    "catalan": "\"/*\\ncode for computing nth catalan number\\n*/\\n#include <stdio.h>\\nlong int factorial(int x)  // long int for more than 10 factorial\\n{\\n    int i;\\n    long int fac;  // fac stores x factorial\\n    fac = x;\\n    for (i = 1; i < x; i++)  // loop to calculate x factorial\\n    {\\n        fac = fac * (x - i);\\n    }\\n    return fac;  // returning x factorial\\n}\\nint main()\\n{\\n    long int f1, f2, f3;  // long int for more than 10 factorial\\n    int n;\\n    float C;  // C is catalan number for n;\\n    scanf(\\\"%d\\\", &n);\\n    f1 = factorial(2 * n);\\n    f2 = factorial(n + 1);\\n    f3 = factorial(n);\\n    C = f1 / (f2 * f3);  // formula for catalan number for n\\n    printf(\\\"%0.2f\\\", C);\\n    return 0;\\n}\\n\"",
    "collatz": "\"/**\\n * \\\\file\\n *\\n * \\\\brief Implementation of [Collatz'\\n * conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)\\n *\\n * Collatz conjecture: a series for a number \\\\f$n\\\\f$ in which if \\\\f$n\\\\f$ even\\n * then the next number is \\\\f$\\\\frac{n}{2}\\\\f$ ,but if n is odd then the next\\n * number is \\\\f$3n+1\\\\f$. This series continues till \\\\f$n\\\\f$ reaches 1\\n */\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n/** Main function */\\nint main(int argc, char *argv[])\\n{\\n    unsigned long long n, curr_no, num_steps = 0;\\n    if (argc == 2)\\n        n = strtoull(argv[1], NULL, 10);\\n    else\\n    {\\n        printf(\\\"Enter starting number: \\\");\\n        scanf(\\\"%lu\\\", &n);  // input number\\n    }\\n\\n    curr_no = n;          // curr_no stores input number n\\n    while (curr_no != 1)  // loop till series reaches 1\\n    {\\n        num_steps++;\\n        printf(\\\"%llu->\\\", curr_no);\\n        if (curr_no % 2 == 0)  // condition   for even number\\n            curr_no = curr_no / 2;\\n        else\\n            curr_no = (curr_no * 3) + 1;  // condition for odd number\\n    }\\n    printf(\\\"1\\\\nNumber of steps: %llu\\\\n\\\", num_steps);\\n    return 0;\\n}\\n\"",
    "demonetization": "\"// Recursion problem\\n// Given the denominations of currencies available in a system, find the number\\n// of ways an ATM machine can generate notes for an entered amount N.\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint ways(int n, int *a, int k)\\n{\\n    if (n < 0 || k < 0)\\n        return 0;\\n    if (n == 0)\\n        return 1;\\n    if (k == 0)\\n        return 0;\\n    return ways(n, a, k - 1) + ways(n - a[k - 1], a, k);\\n}\\n\\nint main()\\n{\\n    int m;\\n    int t;\\n    int n;\\n\\n    printf(\\\"Number of coins? \\\");\\n    scanf(\\\"%d\\\", &m);\\n    int *coin = (int *)malloc(m * sizeof(int)), i;\\n    for (i = 0; i < m; i++)\\n    {\\n        printf(\\\"coin? \\\");\\n        scanf(\\\"%d\\\", &coin[i]);\\n    }\\n\\n    printf(\\\"---- your requests --- \\\\n\\\");\\n    while (1)\\n    {\\n        printf(\\\"amount? exit(0) \\\");\\n        scanf(\\\"%d\\\", &n);\\n        if (!n)\\n        {\\n            break;\\n        }\\n        printf(\\\"%d\\\\n\\\", ways(n, coin, m));\\n    }\\n\\n    free(coin);\\n    return 0;\\n}\\n\"",
    "factorial": "\"#include <stdio.h>\\nint main()\\n{\\n    int a[200], n, counter, temp, i;\\n    a[0] = 1;\\n    counter = 0;\\n    printf(\\\"Enter a whole number to Find its Factorial: \\\");\\n    scanf(\\\"%d\\\", &n);\\n    if (n < 0)\\n        printf(\\\"Cannot Calculate factorials for negative numbers.\\\");\\n    else\\n    {\\n        for (; n >= 2; n--)\\n        {\\n            temp = 0;\\n            for (i = 0; i <= counter; i++)\\n            {\\n                temp = (a[i] * n) + temp;\\n                a[i] = temp % 10;\\n                temp = temp / 10;\\n            }\\n            while (temp > 0)\\n            {\\n                a[++counter] = temp % 10;\\n                temp = temp / 10;\\n            }\\n        }\\n        for (i = counter; i >= 0; i--) printf(\\\"%d\\\", a[i]);\\n    }\\n    return 0;\\n}\\n\"",
    "factorial large number": "\"/**\\n * @file\\n * \\\\brief Compute factorial of arbitrarily large numbers by\\n * storing individual digits in a byte.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n/**\\n * dynamically large number\\n */\\ntypedef struct _large_num\\n{\\n    char *digits;            /**< array to store individual digits */\\n    unsigned int num_digits; /**< number of digits in the number */\\n} large_num;\\n\\n/**\\n * create a new large number\\n * \\\\returns pointer to a large number\\n */\\nlarge_num *new_number(void)\\n{\\n    large_num *new_num = (large_num *)malloc(sizeof(large_num));\\n    new_num->num_digits = 1;\\n    new_num->digits = (char *)malloc(1 * sizeof(char));\\n    new_num->digits[0] = 1;\\n    return new_num;\\n}\\n\\n/**\\n * delete all memory allocated for large number\\n * \\\\param[in] num pointer to large_num to delete\\n */\\nvoid delete_number(large_num *num)\\n{\\n    free(num->digits);\\n    free(num);\\n}\\n\\n/**\\n * add a digit to the large number\\n * \\\\param[in,out] num\\n * \\\\param[in] value value of the digit to insert\\n */\\nvoid add_digit(large_num *num, unsigned int value)\\n{\\n    if (value > 9)\\n    {\\n        fprintf(stderr, \\\"digit > 9!!\\\\n\\\");\\n        delete_number(num);\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    num->num_digits++;\\n    num->digits = (char *)realloc(num->digits, num->num_digits * sizeof(char));\\n    num->digits[num->num_digits - 1] = value;\\n}\\n\\n/**\\n * multiply large number with another integer and\\n * store the result in the same large number\\n */\\nvoid multiply(large_num *num, unsigned long n)\\n{\\n    int i;\\n    unsigned long carry = 0, temp;\\n    for (i = 0; i < num->num_digits; i++)\\n    {\\n        temp = num->digits[i] * n;\\n        temp += carry;\\n        if (temp < 10)\\n            carry = 0;\\n        else\\n        {\\n            carry = temp / 10;\\n            temp = temp % 10;\\n        }\\n        num->digits[i] = temp;\\n    }\\n\\n    while (carry != 0)\\n    {\\n        add_digit(num, carry % 10);\\n        carry /= 10;\\n    }\\n}\\n\\n/**\\n * main function\\n */\\nint main(int argc, char *argv[])\\n{\\n    int number, i;\\n\\n    // Asks for the number/position of term in Fibonnacci sequence\\n    if (argc == 2)\\n        number = atoi(argv[1]);\\n    else\\n    {\\n        printf(\\\"Enter the value of n(n starts from 0 ): \\\");\\n        scanf(\\\"%d\\\", &number);\\n    }\\n\\n    large_num *result = new_number();\\n\\n    clock_t start_time = clock();\\n    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */\\n        multiply(result, i);\\n    double time_taken = (clock() - start_time) * (double)1e3 / CLOCKS_PER_SEC;\\n    // time_taken = (clock() - start_time) / (double) CLOCKS_PER_SEC;\\n\\n    printf(\\\"%d! = \\\", number);\\n    for (i = result->num_digits; i > 0; i--)\\n        putchar(result->digits[i - 1] + '0');\\n    printf(\\\"\\\\nTime taken: %.4g ms\\\\n\\\", time_taken);\\n\\n    delete_number(result);\\n    return 0;\\n}\\n\"",
    "factorial trailing zeroes": "\"/*\\nprogramme for computing number of zeroes at the end of factorial of a given\\nnumber n\\n*/\\n#include <math.h>  //including math.h header file to use pow function\\n#include <stdio.h>\\nint main()\\n{\\n    int i, n, test = 0, count = 0;\\n    // taking input number n\\n    scanf(\\\"%d\\\", &n);\\n\\n    // looping from 1 till loop break\\n    for (i = 1;; i++)\\n    {\\n        test =\\n            n /\\n            pow(5,\\n                i);  // division of n by ith power of 5(storing in integer form)\\n        if (test !=\\n            0)  // condition for zeroes at end corresponding individual ith case\\n        {\\n            count = count + test;\\n        }\\n        else\\n            break;  // break the loop for if test=0\\n    }\\n    printf(\\\"%d\\\\n\\\", count);\\n    return 0;\\n}\\n\"",
    "fibonacci": "\"#include <stdio.h>\\n\\n// Fibonnacci function\\nint fib(int number)\\n{\\n    if (number == 1 || number == 2)\\n        return 1;\\n    else\\n        return fib(number - 1) + fib(number - 2);\\n}\\n\\nint main()\\n{\\n    int number;\\n\\n    // Asks for the number that is in n position in Fibonnacci sequence\\n    printf(\\\"Number: \\\");\\n    scanf(\\\"%d\\\", &number);\\n\\n    printf(\\\"%d \\\\n\\\", fib(number));\\n\\n    return 0;\\n}\"",
    "fibonacci dp": "\"// Fibonacci Series using Dynamic Programming\\n\\n/* Author: Moinak Banerjee(moinak878)\\n   Date : 1 October ,2019\\n*/\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint fib(int n)\\n{\\n    // Out of Range checking\\n    if (n < 0)\\n    {\\n        printf(\\\"\\\\nNo Such term !\\\\n\\\");\\n        exit(0);\\n    }\\n    // declaring array to store fibonacci numbers -- memoization\\n    int *f = (int *)malloc(\\n        (n + 2) * sizeof(int));  //  one extra to handle edge case, n = 0\\n    int i;\\n\\n    /* let 0th and 1st number of the series be 0 and 1*/\\n    f[0] = 0;\\n    f[1] = 1;\\n\\n    for (i = 2; i <= n; i++)\\n    {\\n        // Adding the previous 2 terms to make the 3rd term\\n        f[i] = f[i - 1] + f[i - 2];\\n    }\\n\\n    int out = f[n];\\n    free(f);\\n    return out;\\n}\\n\\nint main(int argc, char *argv[])\\n{\\n    int number;\\n\\n    // Asks for the number/position of term in Fibonnacci sequence\\n    if (argc == 2)\\n        number = atoi(argv[1]);\\n    else\\n    {\\n        printf(\\\"Enter the value of n(n starts from 0 ): \\\");\\n        scanf(\\\"%d\\\", &number);\\n    }\\n\\n    printf(\\\"The nth term is : %d \\\\n\\\", fib(number));\\n\\n    return 0;\\n}\"",
    "fibonacci fast": "\"/**\\n    @file\\n    @author [Krishna Vedala](https://github.com/kvedala)\\n    @date 2 October, 2019\\n    @brief Compute \\\\f$m^{mth}\\\\f$ Fibonacci number using the formulae:\\n    \\\\f{eqnarray*}{\\n        F_{2n-1} &=& F_n^2 + F_{n-1}^2 \\\\\\\\\\n        F_{2n}   &=& F_n\\\\left(2F_{n-1} + F_n\\\\right)\\n   \\\\f}\\n*/\\n\\n#include <locale.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n/**\\n * Get the \\\\f$n^{th}\\\\f$ and \\\\f$n+1^{th}\\\\f$ Fibonacci number using recursive\\n * half-interval decimation.\\n * \\\\param [in] n index of Fibonacci number to get\\n * \\\\param [out] C left half interval value - end result here. Cannot be NULL\\n * \\\\param [out] D right half interval can be discarded at end and can be NULL\\n */\\nvoid fib(unsigned long n, unsigned long *C, unsigned long *D)\\n{\\n    // Out of Range checking\\n    // commented out since `n` is unsigned integer\\n    // if (n < 0)\\n    // {\\n    //     printf(\\\"\\\\nNo Such term !\\\\n\\\");\\n    //     exit(0);\\n    // }\\n\\n    unsigned long a, b, c, d;\\n\\n    if (n == 0)\\n    {\\n        C[0] = 0;\\n        if (D) /* if D is not NULL */\\n            D[0] = 1;\\n        return;\\n    }\\n\\n    fib(n >> 1, &c, &d); /* Compute F(n/2) */\\n\\n    a = c * ((d << 1) - c);\\n    b = c * c + d * d;\\n    if (n % 2 == 0) /* If n is even */\\n    {\\n        C[0] = a;\\n        if (D)\\n            D[0] = b;\\n        return;\\n    }\\n\\n    /**< If n is odd */\\n    C[0] = b;\\n    if (D) /* if D is not NULL */\\n        D[0] = a + b;\\n    return;\\n}\\n\\n/**\\n * main function\\n */\\nint main(int argc, char *argv[])\\n{\\n    unsigned long number, result;\\n\\n    setlocale(LC_NUMERIC, \\\"\\\");  // format the printf output\\n\\n    // Asks for the number/position of term in Fibonnacci sequence\\n    if (argc == 2)\\n        number = atoi(argv[1]);\\n    else\\n    {\\n        printf(\\\"Enter the value of n(n starts from 0 ): \\\");\\n        scanf(\\\"%lu\\\", &number);\\n    }\\n\\n    fib(number, &result, NULL);\\n\\n    printf(\\\"The nth term is : %'lu \\\\n\\\", result);\\n\\n    return 0;\\n}\\n\"",
    "gcd": "\"#include <stdio.h>\\n\\n// Euclid's algorithm\\nint GCD(int x, int y)\\n{\\n    if (y == 0)\\n        return x;\\n    return GCD(y, x % y);\\n}\\n\\nint main()\\n{\\n    int a, b;\\n    printf(\\\"Input two numbers:\\\\n\\\");\\n    scanf(\\\"%d %d\\\", &a, &b);\\n    printf(\\\"Greatest common divisor: %d\\\\n\\\", GCD(a, b));\\n}\\n\"",
    "is armstrong": "\"#include <stdio.h>\\n\\nint main()\\n{\\n    int n, sum = 0, i, num;\\n    printf(\\\"Enter number: \\\");\\n    scanf(\\\"%d\\\", &n);\\n    num = n;\\n    while (n != 0)\\n    {\\n        i = n % 10;\\n        sum = sum + (i * i * i);\\n        n = n / 10;\\n    }\\n    if (sum == num)\\n    {\\n        printf(\\\"%d is an armstrong number!\\\\n\\\", num);\\n    }\\n    else\\n    {\\n        printf(\\\"%d is not an armstrong number!\\\\n\\\", num);\\n    }\\n    return 0;\\n}\\n\"",
    "large factorials": "\"#include <stdio.h>\\n\\nint main()\\n{\\n    int a[16500], T;\\n    long long int i, j;\\n\\n    printf(\\\"Enter number of test cases : \\\");\\n    scanf(\\\"%d\\\", &T);\\n\\n    while (T--)\\n    {\\n        for (i = 0; i < 16500; i++)\\n        {\\n            a[i] = 0;\\n        }\\n\\n        a[1] = 1;\\n        int N, carry = 0, count = 0;\\n        printf(\\\"Enter a number : \\\");\\n        scanf(\\\"%d\\\", &N);\\n\\n        for (i = 1; i <= N; i++)\\n        {\\n            carry = 0;\\n            for (j = 0; j < 16500; j++)\\n            {\\n                a[j] = a[j] * i + carry;\\n                carry = a[j] / 10;\\n                a[j] = a[j] % 10;\\n            }\\n        }\\n\\n        for (i = 0; i < 16500; i++)\\n        {\\n            if (a[i] != 0)\\n            {\\n                count = i;\\n            }\\n        }\\n\\n        for (i = count; i > 0; i--)\\n        {\\n            printf(\\\"%d\\\", a[i]);\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n\\n    return 0;\\n}\\n\"",
    "lcm": "\"// C program to find LCM of two numbers\\n/*\\n    suppose we have two numbers a and b.\\n    Property: Since product of LCM and GCD of two numbers are equal to product\\n   of that number itself. i.e, LCM(a,b)*GCD(a,b)=a*b. So,here we first find the\\n   GCD of two numbers and using above property we find LCM of that two numbers.\\n*/\\n#include <stdio.h>\\n\\n// Recursive function to return gcd of a and b\\nint gcd(int a, int b)\\n{\\n    if (a == 0)\\n        return b;\\n    return gcd(b % a, a);\\n}\\n\\n// Function to return LCM of two numbers\\nint lcm(int a, int b) { return (a * b) / gcd(a, b); }\\n\\n// Driver program\\nint main()\\n{\\n    int a, b;\\n    printf(\\\"Enter two numbers to find their LCM \\\\n\\\");\\n    scanf(\\\"%d%d\\\", &a, &b);\\n    printf(\\\"LCM of %d and %d is %d \\\", a, b, lcm(a, b));\\n    return 0;\\n}\\n/*\\nTest Case1:\\na=15,b=20\\nLCM(a,b)=60\\nTest Case2:\\na=12,b=18\\nLCM(a,b)=36\\n*/\\n\"",
    "lerp": "\"#include <math.h>\\n#include <stdio.h>\\n\\nfloat lerp(float k0, float k1, float t) { return k0 + t * (k1 - k0); }\\n\\nfloat lerp_precise(int k0, int k1, float t) { return (1 - t) * k0 + t * k1; }\\n\\nint main()\\n{\\n    float start = 0;\\n    float finish = 5;\\n    float steps = 0;\\n\\n    printf(\\\"Input a number, this is the bigger bound of the lerp:\\\\n\\\");\\n    scanf(\\\"%f\\\", &finish);\\n\\n    printf(\\n        \\\"Input a number, this is in how many steps you want to divide the \\\"\\n        \\\"lerp:\\\\n\\\");\\n    scanf(\\\"%f\\\", &steps);\\n\\n    for (int i = 0; i < steps + 1; i++)\\n    {\\n        printf(\\\"%f\\\\n\\\", lerp(start, finish, i / steps));\\n    }\\n\\n    return 0;\\n}\\n\"",
    "lexicographic permutations": "\"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nvoid swap(char *left, char *right)\\n{\\n    char temp = *left;\\n    *left = *right;\\n    *right = temp;\\n}\\n\\nint compare(const void *a, const void *b) { return (*(char *)a - *(char *)b); }\\n\\nvoid PrintSortedPermutations(char *str)\\n{\\n    int strSize = strlen(str);\\n    qsort(str, strSize, sizeof(char), compare);\\n\\n    int largerPermFound = 1;\\n    do\\n    {\\n        // 1. Print permutation\\n        printf(\\\"%s\\\\n\\\", str);\\n        // 2. Find rightmost char that is smaller than char to its right\\n        int i;\\n        for (i = strSize - 2; i >= 0 && str[i] >= str[i + 1]; --i)\\n        {\\n        }\\n\\n        // if we couldn't find one, we're finished, else we can swap\\n        if (i >= 0)\\n        {\\n            // 3. find character at index j such that str[j] = min(str[k]) &&\\n            // str[k] > str[i] for all k > i\\n            int j = i + 1, k;\\n            for (k = j; k < strSize && str[k]; k++)\\n            {\\n                if (str[k] > str[i] && str[k] < str[j])\\n                    j = k;\\n            }\\n            // 3. Swap chars at i and j\\n            swap(&str[i], &str[j]);\\n            // 4. Sort string to the right of i\\n            qsort(str + i + 1, strSize - i - 1, sizeof(char), compare);\\n        }\\n        else\\n            largerPermFound = 0;\\n    } while (largerPermFound);\\n}\\n\\nint main()\\n{\\n    int n;  // size of string\\n    scanf(\\\"%d\\\\n\\\", &n);\\n    if (n <= 0 || n >= 1000)\\n    {\\n        perror(\\\"Input number out of range: >0 and <1000\\\\n\\\");\\n        return -1;\\n    }\\n    char *str = (char *)malloc(n * sizeof(char));\\n    scanf(\\\"%s\\\", str);\\n    PrintSortedPermutations(str);\\n    free(str);\\n    return 0;\\n}\\n\"",
    "longest subsequence": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid longestSub(int *ARRAY, int ARRAY_LENGTH, int **RESULT, int *RESULT_LENGTH)\\n{  // RESULT and RESULT_LENGTH will be modified by their pointers\\n\\n    if (ARRAY_LENGTH <= 1)\\n    {\\n        *RESULT = ARRAY;\\n        *RESULT_LENGTH = ARRAY_LENGTH;\\n    }\\n    else\\n    {\\n        int PIVOT = ARRAY[0];\\n        int *LONGEST_SUB = NULL;\\n        int i, j, LONGEST_SUB_LENGTH = 0;\\n        int TEMPORARY_ARRAY_LENGTH = 0, *TEMPORARY_ARRAY = NULL;\\n\\n        for (i = 1; i < ARRAY_LENGTH; i++)\\n        {\\n            if (ARRAY[i] < PIVOT)\\n            {\\n                TEMPORARY_ARRAY_LENGTH = 0;\\n                TEMPORARY_ARRAY = NULL;\\n\\n                for (j = i + 1; j < ARRAY_LENGTH; j++)\\n                {\\n                    if (ARRAY[j] >= ARRAY[i])\\n                    {\\n                        TEMPORARY_ARRAY_LENGTH++;\\n                        TEMPORARY_ARRAY = (int *)realloc(\\n                            TEMPORARY_ARRAY,\\n                            TEMPORARY_ARRAY_LENGTH * sizeof(int));\\n                        TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[j];\\n                    }\\n                }\\n\\n                longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH,\\n                           &TEMPORARY_ARRAY, &TEMPORARY_ARRAY_LENGTH);\\n                if (LONGEST_SUB_LENGTH < TEMPORARY_ARRAY_LENGTH + 1)\\n                {\\n                    LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;\\n                    LONGEST_SUB = (int *)realloc(\\n                        LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));\\n                    LONGEST_SUB[0] = ARRAY[i];\\n\\n                    for (i = 1; i < LONGEST_SUB_LENGTH; i++)\\n                        LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];\\n                }\\n            }\\n        }\\n\\n        TEMPORARY_ARRAY = NULL;\\n        TEMPORARY_ARRAY_LENGTH = 0;\\n        for (i = 1; i < ARRAY_LENGTH; i++)\\n        {\\n            if (ARRAY[i] >= PIVOT)\\n            {\\n                TEMPORARY_ARRAY_LENGTH++;\\n                TEMPORARY_ARRAY = (int *)realloc(\\n                    TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH * sizeof(int));\\n                TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[i];\\n            }\\n        }\\n\\n        longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH, &TEMPORARY_ARRAY,\\n                   &TEMPORARY_ARRAY_LENGTH);\\n        if (TEMPORARY_ARRAY_LENGTH + 1 > LONGEST_SUB_LENGTH)\\n        {\\n            LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;\\n            LONGEST_SUB =\\n                (int *)realloc(LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));\\n            LONGEST_SUB[0] = PIVOT;\\n            for (i = 1; i < LONGEST_SUB_LENGTH; i++)\\n                LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];\\n        }\\n        *RESULT = LONGEST_SUB;\\n        *RESULT_LENGTH = LONGEST_SUB_LENGTH;\\n    }\\n}\\n\\nint main()\\n{\\n    int EXAMPLE_LENGTH = 8;\\n    int EXAMPLE[] = {18, 2, 15, 4, 30, 0, 11, 12};\\n\\n    int *RESULT = NULL;\\n    int RESULT_LENGTH, i;\\n\\n    longestSub(EXAMPLE, EXAMPLE_LENGTH, &RESULT, &RESULT_LENGTH);\\n\\n    printf(\\\"Longest Sub Sequence length: %d and it's:\\\\n\\\", RESULT_LENGTH);\\n    for (i = 0; i < RESULT_LENGTH; i++) printf(\\\"%d \\\", RESULT[i]);\\n    printf(\\\"\\\\n\\\");\\n\\n    return 0;\\n}\"",
    "mirror": "\"#include <stdio.h>\\n#include <string.h>  // we include the library string.h to the use of string\\n\\nvoid saisie(\\n    char *cpointeur);  // Prototypes of the three functions used in the program\\nint compte(char *s);\\nchar *miroir(char *s);\\n\\nint main(int argc, char *argv[])\\n{\\n    char chaine[20];\\n    saisie(chaine);\\n    printf(\\\"miroir est %s\\\", miroir(chaine));\\n}\\n// this function is used to put a string\\nvoid saisie(char *cpointeur)\\n{\\n    printf(\\\"saisir une chaine\\\\n\\\");\\n    scanf(\\\"%s\\\", cpointeur);\\n}\\n/* the function miroir (in french ) it means \\\"mirror\\\" , the major idea is to\\npermute the first caractere with the last using an auxilary variable (aux) the\\nthe 2nd character with the penultimate one and so on . we made a call to the\\nfunction (compte) which counts the length of the string . As you can see clearly\\n, I substruct 1 from the equation k = compte(s)-1 ; to get rid of the EOF\\ncaractere which is '\\\\0' because it is not a caractere from the string typed */\\nchar *miroir(char *s)\\n{\\n    int i;\\n    char aux;\\n    int k;\\n    k = compte(s) - 1;\\n    i = 0;\\n    while (i <= k)\\n    {\\n        aux = s[i];\\n        s[i] = s[k];\\n        s[k] = aux;\\n        k--;\\n        i++;\\n    }\\n\\n    return s;\\n}\\n\\n// compte plays the role of strlen so we can change it by an strlen function if\\n// you want that\\nint compte(char *s)\\n{\\n    char *p;\\n    int k;\\n    p = s;\\n    k = 0;\\n    while (*p != '\\\\0')\\n    {\\n        p++;\\n        k++;\\n    }\\n    return k;\\n}\\n\"",
    "palindrome": "\"/**\\n * @file\\n * @brief Program to identify if a number is [palindrome\\n * number](https://en.wikipedia.org/wiki/Palindrome) or not.\\n * @see project_euler/problem_4/sol1.c\\n */\\n#include <assert.h>\\n#include <stdbool.h>\\n#include <stdio.h>\\n\\nbool isPalindrome(int number);\\n\\n/** Driver Code */\\nint main()\\n{\\n    assert(isPalindrome(0));\\n    assert(isPalindrome(1));\\n    assert(isPalindrome(12321));\\n    assert(!isPalindrome(1234));\\n    return 0;\\n}\\n\\n/**\\n * Check given number whether is palindrome number or not\\n * @param number number to check\\n * @return `true` if given number is palindrome number\\n * @return `false` if number is not a palindrome number\\n */\\nbool isPalindrome(int number)\\n{\\n    int reversedNumber = 0;\\n    int originalNumber = number;\\n    while (number != 0)\\n    {\\n        int remainder = number % 10;\\n        reversedNumber = reversedNumber * 10 + remainder;\\n        number /= 10;\\n    }\\n    return originalNumber == reversedNumber;\\n}\\n\"",
    "pid": "\"/**\\r\\n * PID Controller\\r\\n *\\r\\n * The PID controller is a linear control algorithm that has three terms:\\r\\n *  - Proportional: A simple scaling of the error value by a gain kP\\r\\n *  - Integral: Integration of the error value over time, then multipled by gain\\r\\n * kI\\r\\n *  - Derivative: Rate of change of the error value over time, multiplied by\\r\\n * gain kD\\r\\n *\\r\\n * Terms of the controller can be removed by setting their gain to 0, creating a\\r\\n * PI (kD = 0) or PD (kI = 0) controller. Depending on the control problem at\\r\\n * hand, some terms may not increase the performance of the system, or may have\\r\\n * a negative effect.\\r\\n *\\r\\n * For a more mathematical expanation of the PID Controller, see\\r\\n * https://en.wikipedia.org/wiki/PID_controller\\r\\n *\\r\\n * Limitations of this implementation:\\r\\n *  - Since this implementation is just for demonstration, the pid_step function\\r\\n * takes the dt as a parameter, and it can be provided by the user in main().\\r\\n * This allows deterministic experimentation with the algorithm, rather than\\r\\n * using time(NULL) which would make the function non-deterministic.\\r\\n *\\r\\n * Inputs: e(t) - Current error at time t. For example, how far a servo is off\\r\\n * the desired angle Output: u(t) - Controller output at time t.\\r\\n */\\r\\n#include <stdio.h>\\r\\n\\r\\nstruct pid\\r\\n{\\r\\n    // Controller gains\\r\\n    float kP;\\r\\n    float kI;\\r\\n    float kD;\\r\\n\\r\\n    // State variables\\r\\n    float lastError;\\r\\n    float integral;\\r\\n};\\r\\n\\r\\nfloat pid_step(struct pid *controller, float dt, float error)\\r\\n{\\r\\n    // Calculate p term\\r\\n    float p = error * controller->kP;\\r\\n\\r\\n    // Calculate i term\\r\\n    controller->integral += error * dt * controller->kI;\\r\\n\\r\\n    // Calculate d term, taking care to not divide by zero\\r\\n    float d =\\r\\n        dt == 0 ? 0 : ((error - controller->lastError) / dt) * controller->kD;\\r\\n    controller->lastError = error;\\r\\n\\r\\n    return p + controller->integral + d;\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n    printf(\\\"PID Controller Example\\\\n\\\");\\r\\n\\r\\n    struct pid controller = {.lastError = 0, .integral = 0};\\r\\n\\r\\n    // Take the controller gains from the user\\r\\n    printf(\\r\\n        \\\"Please enter controller gains in format kP, kI, KD. For example, \\\"\\r\\n        \\\"\\\\\\\"1.2 2.1 3.2\\\\\\\"\\\\n> \\\");\\r\\n    scanf(\\\"%f %f %f\\\", &controller.kP, &controller.kI, &controller.kD);\\r\\n    printf(\\\"Using kP: %f, kI: %f, kD: %f\\\\n\\\", controller.kP, controller.kI,\\r\\n           controller.kD);\\r\\n\\r\\n    // How often the pid_step algorithm expects to be called. In a real life\\r\\n    // scenario this would be provided by calling time(NULL) - last_time, or by\\r\\n    // calling the function reliably at X Hz (using a timer or RTOS etc) For\\r\\n    // demonstration of this algorithm though, it is defined below as 1 second,\\r\\n    // allowing easy testing of integral and derivative terms.\\r\\n    float time_step = 1;\\r\\n\\r\\n    float error_value;\\r\\n    while (1)\\r\\n    {\\r\\n        printf(\\\"Enter error value\\\\n>\\\");\\r\\n        scanf(\\\"%f\\\", &error_value);\\r\\n\\r\\n        float output = pid_step(&controller, time_step, error_value);\\r\\n        printf(\\\"Output: %f\\\\n\\\", output);\\r\\n    }\\r\\n}\\r\\n\"",
    "poly add": "\"/**\\n * @file\\n * @brief Implementation of [Addition of two polynomials]\\n * (https://en.wikipedia.org/wiki/Polynomial#Addition)\\n * @author [Ankita Roy Chowdhury](https://github.com/Ankita19ms0010)\\n * @details\\n * This code takes two polynomials as input\\n * and prints their sum using linked list.\\n * The polynomials must be in increasing or decreasing order of degree.\\n * Degree must be positive.\\n */\\n#include <stdio.h>  // for io operations\\n#include <stdlib.h>\\n\\n/**\\n * @brief identifier for single-variable polynomial coefficients as a linked\\n * list\\n */\\nstruct term\\n{\\n    int coef;          /**< coefficient value */\\n    int pow;           /**< power of the polynomial term */\\n    struct term *next; /**< pointer to the successive term */\\n};\\n\\n/**\\n * @brief Frees memory space\\n * @param poly first term of polynomial\\n * @returns void\\n */\\nvoid free_poly(struct term *poly)\\n{\\n    if (!poly)\\n    {\\n        return;  // NULL pointer does not need delete\\n    }\\n    else\\n    {\\n        while (!poly->next)\\n        {\\n            free(poly->next);  // Deletes next term\\n        }\\n        free(poly);  // delete the current term\\n    }\\n}\\n\\n/**\\n * The function will create a polynomial\\n * @param poly stores the address of the polynomial being created\\n * @param coef contains the coefficient of the node\\n * @param pow contains the degree\\n * @returns none\\n */\\nvoid create_polynomial(struct term **poly, int coef, int pow)\\n{\\n    // Creating the polynomial using temporary linked lists\\n    struct term *temp1, *temp2;\\n    temp1 = *poly;  // Contains the null pointer\\n\\n    // Initiating first term\\n    if (temp1 == NULL)\\n    {\\n        temp2 = (struct term *)malloc(\\n            sizeof(struct term));  // Dynamic node creation\\n        temp2->coef = coef;\\n        temp2->pow = pow;\\n        // Updating the null pointer with the address of the first node of the\\n        // polynomial just created\\n        *poly = temp2;\\n        temp2->next = NULL;  // Increasing the pointer temp2\\n    }\\n    // Creating the rest of the nodes\\n    else\\n    {\\n        temp2->next = (struct term *)malloc(\\n            sizeof(struct term));  // Dynamic node creation\\n        temp2 = temp2->next;       // Increasing the pointer temp2\\n        temp2->coef = coef;\\n        temp2->pow = pow;\\n        temp2->next = NULL;\\n    }\\n}\\n\\n/**\\n * The function will add 2 polynomials\\n * @param poly1 first polynomial of the addition\\n * @param poly2 second polynomial of the addition\\n * @param pol  the resultant polynomial\\n */\\n\\nvoid poly_add(struct term **pol, struct term *poly1, struct term *poly2)\\n{\\n    // Creating a temporary linked list to store the resultant polynomial\\n    struct term *temp = (struct term *)malloc(sizeof(struct term));\\n    temp->next = NULL;\\n    *pol =\\n        temp;  //*pol always points to the 1st node of the resultant polynomial\\n\\n    // Comparing the powers of the nodes of both the polynomials\\n    // until one gets exhausted\\n    while (poly1 && poly2)\\n    {\\n        /* If the power of the first polynomial is greater than the power of the\\n       second one place the power and coefficient of that node of the first\\n       polynomial in temp and increase the pointer poly1\\n       */\\n        if (poly1->pow > poly2->pow)\\n        {\\n            temp->coef = poly1->coef;\\n            temp->pow = poly1->pow;\\n            poly1 = poly1->next;\\n        }\\n        /* If the power of the second polynomial is greater than the power of\\n          the first one place the power and coefficient of that node of the\\n          second polynomial in temp and increase the pointer poly2\\n        */\\n        else if (poly1->pow < poly2->pow)\\n        {\\n            temp->coef = poly2->coef;\\n            temp->pow = poly2->pow;\\n            poly2 = poly2->next;\\n        }\\n        /* If both of them have same power then sum the coefficients\\n          place both the summed coefficient and the power in temp\\n          increase both the pointers poly1 and poly2\\n        */\\n        else\\n        {\\n            temp->coef = poly1->coef + poly2->coef;\\n            temp->pow = poly1->pow;\\n            poly1 = poly1->next;\\n            poly2 = poly2->next;\\n        }\\n        /* If none of the polynomials are exhausted\\n         dynamically create a node in temp\\n         */\\n        if (poly1 && poly2)\\n        {\\n            temp->next = (struct term *)malloc(\\n                sizeof(struct term));  // Dynamic node creation\\n            temp = temp->next;         // Increase the pointer temp\\n            temp->next = NULL;\\n        }\\n    }\\n    /* If one of the polynomials is exhausted\\n    place the rest of the other polynomial as it is in temp\\n    by creating nodes dynamically\\n    */\\n    while (poly1 || poly2)\\n    {\\n        temp->next = (struct term *)malloc(\\n            sizeof(struct term));  // Dynamic node creation\\n        temp = temp->next;         // Increasing the pointer\\n        temp->next = NULL;\\n\\n        /* If poly1 is not exhausted\\n        place rest of that polynomial in temp\\n        */\\n        if (poly1)\\n        {\\n            temp->coef = poly1->coef;\\n            temp->pow = poly1->pow;\\n            poly1 = poly1->next;\\n        }\\n        /* If poly2 is not exhausted\\n       place rest of that polynomial in temp\\n       */\\n        else if (poly2)\\n        {\\n            temp->coef = poly2->coef;\\n            temp->pow = poly2->pow;\\n            poly2 = poly2->next;\\n        }\\n    }\\n}\\n\\n/**\\n * The function will display the polynomial\\n * @param poly first term of the polynomial to be displayed\\n * @returns none\\n */\\nvoid display_polynomial(struct term *poly)\\n{\\n    while (poly != NULL)\\n    {\\n        printf(\\\"%d x^%d\\\", poly->coef, poly->pow);\\n        poly = poly->next;\\n        if (poly != NULL)\\n        {\\n            printf(\\\" + \\\");\\n        }\\n    }\\n}\\n\\n/**\\n * @brief Test function 1\\n *\\n * @details\\n * Polynomial 1 is 5 x^2 + 3 x^1 + 2 x^0\\n * Polynomial 2 is 7 x^3 + 9 x^1 + 10 x^0\\n * Resultant polynomial is 7 x^3 + 5 x^2 + 12 x^1 + 12 x^0\\n * @returns void\\n */\\nstatic void test1(struct term *poly1, struct term *poly2, struct term *poly3)\\n{\\n    printf(\\\"\\\\n----Test 1----\\\\n\\\");\\n    printf(\\\"\\\\nFirst Polynomial:\\\\n\\\");  // Defining the 1st polynomial\\n    create_polynomial(&poly1, 5, 2);\\n    create_polynomial(&poly1, 3, 1);\\n    create_polynomial(&poly1, 2, 0);\\n    display_polynomial(poly1);\\n\\n    printf(\\\"\\\\nSecond Polynomial:\\\\n\\\");  // Defining the 2nd polynomial\\n    create_polynomial(&poly2, 7, 3);\\n    create_polynomial(&poly2, 9, 1);\\n    create_polynomial(&poly2, 10, 0);\\n    display_polynomial(poly2);\\n\\n    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials\\n    printf(\\\"\\\\nResultant polynomial:\\\\n\\\");\\n    display_polynomial(poly3);\\n    printf(\\\"\\\\n\\\");\\n\\n    // Frees memory space\\n    free_poly(poly1);\\n    free_poly(poly2);\\n    free_poly(poly3);\\n}\\n\\n/**\\n * @brief Test function 2\\n *\\n * @details\\n * Polynomial 1 is 3 x^5 + 1 x^4 + 2 x^3 + -2 x^1 + 5 x^0\\n * Polynomial 2 is 2 x^5 + 3 x^3 + 7 x^1 + 2 x^0\\n * Resultant polynomial is 5 x^5 + 1 x^4 + 5 x^3 + 5 x^1 + 7 x^0\\n * @returns void\\n */\\nstatic void test2(struct term *poly1, struct term *poly2, struct term *poly3)\\n{\\n    printf(\\\"\\\\n----Test 2----\\\\n\\\");\\n    printf(\\\"\\\\nFirst Polynomial:\\\\n\\\");  // Defining the 1st polynomial\\n    create_polynomial(&poly1, 3, 5);\\n    create_polynomial(&poly1, 1, 4);\\n    create_polynomial(&poly1, 2, 3);\\n    create_polynomial(&poly1, -2, 1);\\n    create_polynomial(&poly1, 5, 0);\\n\\n    display_polynomial(poly1);\\n\\n    printf(\\\"\\\\nSecond Polynomial:\\\\n\\\");  // Defining the 2nd polynomial\\n    create_polynomial(&poly2, 2, 5);\\n    create_polynomial(&poly2, 3, 3);\\n    create_polynomial(&poly2, 7, 1);\\n    create_polynomial(&poly2, 2, 0);\\n\\n    display_polynomial(poly2);\\n\\n    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials\\n    printf(\\\"\\\\nResultant polynomial:\\\\n\\\");\\n    display_polynomial(poly3);\\n    printf(\\\"\\\\n\\\");\\n\\n    // Frees memory space\\n    free_poly(poly1);\\n    free_poly(poly2);\\n    free_poly(poly3);\\n}\\n\\n/**\\n * @brief Test function 3\\n *\\n * @details\\n * Polynomial 1 is -12 x^0 + 8 x^1 + 4 x^3\\n * Polynomial 2 is 5 x^0 + -13 x^1 + 3 x^3\\n * Resultant polynomial is -7 x^0 + -5 x^1 + 7 x^3\\n * @returns void\\n */\\nstatic void test3(struct term *poly1, struct term *poly2, struct term *poly3)\\n{\\n    printf(\\\"\\\\n----Test 3----\\\\n\\\");\\n    printf(\\\"\\\\nFirst Polynomial:\\\\n\\\");  // Defining the 1st polynomial\\n    create_polynomial(&poly1, -12, 0);\\n    create_polynomial(&poly1, 8, 1);\\n    create_polynomial(&poly1, 4, 3);\\n\\n    display_polynomial(poly1);\\n\\n    printf(\\\"\\\\nSecond Polynomial:\\\\n\\\");  // Defining the 2nd polynomial\\n    create_polynomial(&poly2, 5, 0);\\n    create_polynomial(&poly2, -13, 1);\\n    create_polynomial(&poly2, 3, 3);\\n\\n    display_polynomial(poly2);\\n\\n    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials\\n    printf(\\\"\\\\nResultant polynomial:\\\\n\\\");\\n    display_polynomial(poly3);\\n    printf(\\\"\\\\n\\\");\\n\\n    // Frees memory space\\n    free_poly(poly1);\\n    free_poly(poly2);\\n    free_poly(poly3);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main(void)\\n{\\n    struct term *poly1 = NULL, *poly2 = NULL, *poly3 = NULL;\\n    test1(poly1, poly2, poly3);\\n    test2(poly1, poly2, poly3);\\n    test3(poly1, poly2, poly3);\\n\\n    return 0;\\n}\\n\"",
    "postfix evaluation": "\"/**\\n * @file\\n * @brief [Postfix evaluation algorithm](https://www.includehelp.com/c/evaluation-of-postfix-expressions-using-stack-with-c-program.aspx) implementation\\n * @details\\n * The input postfix expression is of type string upto 49 characters (including space delimiters).\\n * Supported operations- '+', '-', '/', '*', '%'\\n * @author [Kumar Yash](https://github.com/kumaryash18)\\n */\\n \\n#include <stdio.h>\\t/// for IO operations\\n#include <string.h>\\t/// for strlen()\\n#include <ctype.h>\\t/// for isdigit()\\n#include <stdlib.h>\\t/// for exit()\\n#include <stdint.h>\\t/// for int8_t\\n#include <assert.h>\\t/// for assert\\n\\n/**\\n * @brief array implementation of stack using structure\\n */\\nstruct Stack {\\n\\tint8_t stack[20];\\t\\t///< array stack\\n\\tint top;\\t\\t///< stores index of the top element\\n};\\nstruct Stack st;\\t\\t///< global declaration of stack st\\n\\n/**\\n * @brief Function to push on the stack\\n * @param opd number to be pushed in the stack\\n * @returns void\\n */\\nvoid push(int8_t opd) {\\n\\tif(st.top == 19)\\t{\\t\\t// overflow condition\\n\\t\\tprintf(\\\"Stack overflow...\\\");\\n\\t\\texit(1);\\n\\t}\\n\\tst.top++;\\n\\tst.stack[st.top] = opd;\\n}\\n\\n/**\\n * @brief Function to pop from the stack\\n * @returns popped number\\n */\\nint8_t pop() {\\n\\tint8_t item;\\t\\t\\t\\t///< to store the popped value to be returned\\n\\tif(st.top == -1) {\\t\\t// underflow condition\\n\\t\\tprintf(\\\"Stack underflow...\\\");\\n\\t\\texit(1);\\n\\t}\\n\\titem = st.stack[st.top];\\n\\tst.top--;\\n\\treturn item;\\n}\\n\\n/**\\n * @brief Function to evaluate postfix expression\\n * @param post the input postfix expression\\n * @returns evaluated answer\\n */\\nint8_t evaluate(char post[]) {\\n\\tint8_t it1;\\n\\tint8_t it2;\\n\\tint8_t temp;\\n\\tint8_t number;\\n    int i;\\n    for(i = 0; i < strlen(post); i++) {\\n\\t\\tif(post[i] == ' ') {\\n\\t\\t\\tcontinue;\\t\\t\\t// ignore delimiter\\n\\t\\t}\\n\\t\\telse if(isdigit(post[i])) {\\n\\t\\t\\tnumber = 0;\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tnumber = number * 10 + (post[i]-'0');\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} while(i < strlen(post) && isdigit(post[i]));\\n\\t\\t\\tpush(number);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tit2 = pop();\\n\\t\\t\\tit1 = pop();\\n\\t\\t\\tswitch(post[i]) {\\n\\t\\t\\t\\tcase '+':\\n\\t\\t\\t\\ttemp = it1 + it2; break;\\n\\t\\t\\t\\tcase '-':\\n\\t\\t\\t\\ttemp = it1 - it2; break;\\n\\t\\t\\t\\tcase '*':\\n\\t\\t\\t\\ttemp = it1 * it2; break;\\n\\t\\t\\t\\tcase '/':\\n\\t\\t\\t\\ttemp = it1 / it2; break;\\n\\t\\t\\t\\tcase '%':\\n\\t\\t\\t\\ttemp = it1 % it2; break;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\tprintf(\\\"Invalid operator\\\"); exit(1);\\n\\t\\t\\t}\\n\\t\\t\\tpush(temp);\\n\\t\\t}\\n\\t}\\n\\treturn pop();\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    /* check sample test case\\n\\t   input: \\\"2 10 + 9 6 - /\\\"\\n\\t   expected output: 4\\n\\t */\\n\\tchar temp1[50] = \\\"2 10 + 9 6 - /\\\";\\n\\tassert(evaluate(temp1) == 4); \\t\\t\\t/// this ensures that the algorithm works as expected\\n\\t/* input: \\\"4 2 + 3 5 1 - * +\\\"\\n\\t   expected output: 18\\n\\t */\\n\\tchar temp2[50] = \\\"4 2 + 3 5 1 - * +\\\";\\n\\tassert(evaluate(temp2) == 18); \\t\\t\\t/// this ensures that the algorithm works as expected\\n\\tprintf(\\\"All tests have successfully passed!\\\\n\\\");\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() {\\n\\tst.top = -1;\\t\\t\\t/// initialize\\n\\ttest();\\t\\t\\t\\t/// run self-test implementations\\n\\treturn 0;\\n}\\n\"",
    "prime": "\"/**\\n * @file\\n * @brief Program to identify if a number is [prime\\n * number](https://en.wikipedia.org/wiki/Prime_number) or not\\n */\\n#include <assert.h>\\n#include <math.h>\\n#include <stdbool.h>\\n#include <stdio.h>\\n\\n/**\\n * Check if a given number is prime number or not\\n * @param x number to check\\n * @return `true` if given number is prime number, otherwise `false`\\n */\\nbool isPrime(int x)\\n{\\n    if (x == 2)\\n    {\\n        return true;\\n    }\\n    if (x < 2 || x % 2 == 0)\\n    {\\n        return false;\\n    }\\n\\n    double squareRoot = sqrt(x);\\n\\n    for (int i = 3; i <= squareRoot; i += 2)\\n    {\\n        if (x % i == 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * Test function\\n * @return void\\n */\\nvoid test()\\n{\\n    /* all the prime numbers less than 100 */\\n    int primers[] = {2,  3,  5,  7,  11, 13, 17, 19, 23, 29, 31, 37, 41,\\n                     43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\\n    for (size_t i = 0, size = sizeof(primers) / sizeof(primers[0]); i < size;\\n         ++i)\\n    {\\n        assert(isPrime(primers[i]));\\n    }\\n\\n    /* Example Non-prime numbers */\\n    int NonPrimers[] = {-1, 0, 1, 4, 6, 8, 9, 10};\\n    for (size_t i = 0, size = sizeof(NonPrimers) / sizeof(NonPrimers[0]);\\n         i < size; ++i)\\n    {\\n        assert(!isPrime(NonPrimers[i]));\\n    }\\n}\\n\\n/**\\n * Driver Code\\n * @return None\\n */\\nint main()\\n{\\n    test();\\n    return 0;\\n}\\n\"",
    "prime factoriziation": "\"/*\\n    AUTHOR: Christian Bender\\n    DATE: 12.02.2019\\n    DESCRIPTION: This program calculates the prime factoriziation of a positive\\n   integer > 1\\n*/\\n\\n#include <assert.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n/* initial length of the dynamic array */\\n#define LEN 10\\n\\n/* increasing range */\\n#define STEP 5\\n\\n/*\\n    this type is for the representation of the prim factoriziation\\n    - its series/range of prime factors\\n    - its length : numbers of prime factors\\n*/\\ntypedef struct data\\n{\\n    int *range;\\n    int length;\\n} range;\\ntypedef range *Range;\\n\\n/* int_fac : calculates the prime factoriziation of positive integers */\\nRange int_fact(int);\\n\\n/* print_arr : prints the integer (heap) array*/\\nvoid print_arr(Range);\\n\\n/* increase : increases the dynamic integer array */\\nint *increase(int *, int);\\n\\n/* destroy: destroys the range-structure */\\nvoid destroy(Range);\\n\\n/*\\n    main : simle frame program with a simple UI\\n*/\\nint main()\\n{\\n    int n = 0; /* for user input */\\n\\n    printf(\\\"\\\\t\\\\tPrim factoriziation\\\\n\\\\n\\\");\\n    printf(\\\"positive integer (> 1) ? \\\");\\n    scanf(\\\"%d\\\", &n);\\n    Range r = int_fact(n);\\n    printf(\\\"\\\\nThe factoriziation are: \\\");\\n    print_arr(r);\\n    destroy(r);\\n    return 0;\\n}\\n\\nRange int_fact(int n)\\n{\\n    assert(n > 1); /* precondition : n must be greater then 1*/\\n\\n    int len = LEN;\\n    int count = 0;\\n    int i = 0;\\n    int *range = (int *)malloc(sizeof(int) * len);\\n    assert(range);\\n    Range pstr = (Range)malloc(sizeof(range));\\n    assert(pstr);\\n\\n    while (n % 2 == 0)\\n    {\\n        n /= 2;\\n        if (i < len)\\n        {\\n            range[i] = 2;\\n            i++;\\n        }\\n        else\\n        {\\n            range = increase(range, len);\\n            len += STEP;\\n            range[i] = 2;\\n            i++;\\n        }\\n        count++;\\n    }\\n\\n    int j = 3;\\n    while (j * j <= n)\\n    {\\n        while (n % j == 0)\\n        {\\n            n /= j;\\n            if (i < len)\\n            {\\n                range[i] = j;\\n                i++;\\n            }\\n            else\\n            {\\n                range = increase(range, len);\\n                len += STEP;\\n                range[i] = j;\\n                i++;\\n            }\\n            count++;\\n        }\\n\\n        j += 2;\\n    }\\n\\n    if (n > 1)\\n    {\\n        if (i < len)\\n        {\\n            range[i] = n;\\n            i++;\\n        }\\n        else\\n        {\\n            range = increase(range, len);\\n            len += STEP;\\n            range[i] = n;\\n            i++;\\n        }\\n        count++;\\n    }\\n\\n    pstr->range = range;\\n    pstr->length = count;\\n    return pstr;\\n}\\n\\nvoid print_arr(Range pStr)\\n{\\n    assert(pStr); /* checks whether pStr is a null-pointer */\\n    int i = 0;\\n    printf(\\\"\\\\n\\\");\\n    for (i; i < pStr->length; i++)\\n    {\\n        if (i == 0)\\n            printf(\\\"%d\\\", pStr->range[0]);\\n        else\\n            printf(\\\"-%d\\\", pStr->range[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint *increase(int *arr, int len)\\n{\\n    assert(arr); /* checks whether arr is a null-pointer */\\n    int *tmp = (int *)realloc(arr, sizeof(int) * (len + STEP));\\n    assert(tmp);\\n    return tmp;\\n    //    assert(arr);\\n}\\n\\nvoid destroy(Range r)\\n{\\n    free(r->range);\\n    free(r);\\n}\\n\"",
    "prime seive": "\"/**\\n * @file\\n * @brief [Prime Seive](https://leetcode.com/problems/count-primes/)\\n * algorithm implementation.\\n * @author [Divyansh Kushwaha](https://github.com/webdesignbydivyansh)\\n */\\n#include <assert.h>\\t/// for assert\\n#include <stdio.h>\\t/// for standard input output\\n#include <stdlib.h>\\t/// for general purpose standard library\\n\\nconst unsigned long long MAX_SIZE = 1000000;  /// variable upto which prime numbers are to be found out\\n/**\\n * @addtogroup misc\\n * @{\\n */\\n/**\\n * @brief Prime Sieve works in O(nlogn) time\\n * @param p array to be updated\\n * @returns void\\n */\\nvoid prime(int *p)\\n{\\n\\tfor(long long int i=3;i<=MAX_SIZE;i+=2) { p[i]=1; }\\n\\tfor(long long int i=3;i<=MAX_SIZE;i+=2)\\n\\t{\\n\\t\\tif(p[i]==1) {\\n\\t\\t    for(long long int j=i*i;j<=MAX_SIZE;j+=i) {\\n\\t\\t\\tp[j]=0;\\n\\t\\t    }\\n\\t\\t}\\n\\t}\\n\\tp[2]=1;\\n\\tp[0]=p[1]=0;    \\n}\\n/**\\n * @brief Count func counts the number of \\n * prime numbers.\\n * @param arr contains the prime numbers\\n * @param size denotes upto which prime numbers are to be found out\\n * @returns count of prime numbers\\n */\\nint count(int *arr, const int size){\\n  int k=0;\\n  for(int i=0;i<=size;i++){\\n    if(arr[i]==1){\\n      k++;\\n    }\\n  }\\n  return k;\\n}\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test()\\n{\\n    // Test Case 1\\n    const int size = 10; /* array size */\\n    printf(\\\"Test Case 1...\\\");\\n    int arr[1000005]={0};   /* array to store prime numbers */\\n    prime(arr);\\n    assert(count(arr,size)==4);\\n    printf(\\\"Passed\\\\n\\\");\\n}\\n\\n/** \\n * @brief Main function\\n * @param argc commandline argument count (ignored)\\n * @param argv commandline array of arguments (ignored)\\n * @returns 0 on exit\\n */\\nint main(int argc, const char *argv[])\\n{\\n    test();\\t// execute the tests\\n    return 0;\\n}\\n\"",
    "quartile": "\"#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main()\\n{\\n    int a[10], n, i, j, temp;\\n    float q1, q3, iqr;\\n\\n    printf(\\\"Enter no. for Random Numbers :\\\");\\n    scanf(\\\"%d\\\", &n);\\n    for (i = 0; i < n; i++)\\n    {\\n        a[i] = rand() % 100;\\n    }\\n    printf(\\\"Random Numbers Generated are :\\\\n\\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"\\\\n%d\\\", a[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n    printf(\\\"\\\\nSorted Data:\\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        for (j = 0; j < n; j++)\\n        {\\n            if (a[i] < a[j])\\n            {\\n                temp = a[i];\\n                a[i] = a[j];\\n                a[j] = temp;\\n            }\\n        }\\n    }\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"\\\\n%d\\\", a[i]);\\n    }\\n    q1 = a[n / 4];\\n    printf(\\\"\\\\nFirst Quartile : %f\\\", q1);\\n    q3 = a[(3 * n) / 4];\\n    printf(\\\"\\\\nThird Quartile : %f\\\", q3);\\n    iqr = q3 - q1;\\n    printf(\\\"\\\\nInterQuartile Range is : %f\\\", iqr);\\n\\n    return 0;\\n}\"",
    "rselect": "\"#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\nvoid swap(int *a, int *b)\\n{\\n    int t;\\n    t = *a;\\n    *a = *b;\\n    *b = t;\\n}\\nint part(int a[], int l, int r, int n, int pivot, int pindex)\\n{\\n    int p1 = l, p2 = r;\\n    while (p2 > p1)\\n    {\\n        if (a[p1] > pivot && a[p2] < pivot)\\n        {\\n            swap(&a[p1], &a[p2]);\\n        }\\n        else\\n        {\\n            if (a[p1] <= pivot)\\n            {\\n                p1++;\\n            }\\n            if (a[p2] >= pivot)\\n            {\\n                p2--;\\n            }\\n        }\\n    }\\n    swap(&a[pindex], &a[p2]);\\n    return p2;\\n}\\nint rselect(int a[], int l, int r, int n, int o)\\n{\\n    int pivot, pindex, pactual;\\n    if (r > l)\\n    {\\n        pindex = rand() % (r - l + 1);\\n        pivot = a[pindex];\\n        pactual = part(a, l, r, n, pivot, pindex);\\n\\n        if (pactual == o)\\n        {\\n            return a[pactual];\\n        }\\n\\n        if (o < pactual)\\n        {\\n            rselect(a, l, pactual - 1, n, o);\\n        }\\n\\n        if (o > pactual)\\n        {\\n            rselect(a, pactual + 1, r, n, o - pactual);\\n        }\\n    }\\n    if (r == l)\\n    {\\n        return a[l];\\n    }\\n    return -1;\\n}\\nint main()\\n{\\n    srand(time(NULL));\\n    int n, o, i, *a;\\n    scanf(\\\"%d %d\\\", &n, &o);\\n    a = (int *)malloc(n * sizeof(int));\\n    for (i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d\\\", a + i);\\n    }\\n    printf(\\\"\\\\n\\\\n%d\\\", rselect(a, 0, n - 1, n, o));\\n    return 0;\\n}\\n\"",
    "strong number": "\"/**\\n * @file\\n * @brief Strong number is a number whose sum of all digits’ factorial is equal\\n * to the number n For example: 145 = 1!(1) + 4!(24) + 5!(120)\\n */\\n#include <assert.h>\\n#include <stdbool.h>\\n#include <stdio.h>\\n\\n/**\\n * Check if given number is strong number or not\\n * @param number\\n * @return `true` if given number is strong number, otherwise `false`\\n */\\nbool isStrong(int number)\\n{\\n    if (number < 0)\\n    {\\n        return false;\\n    }\\n    int sum = 0;\\n    int originalNumber = number;\\n    while (originalNumber != 0)\\n    {\\n        int remainder = originalNumber % 10;\\n        int factorial = remainder == 0 ? 0 : 1; /* 0! == 1 */\\n\\n        /* calculate factorial of n */\\n        for (int i = 1; i <= remainder; factorial *= i, i++)\\n        {\\n            ;\\n        }\\n        sum += factorial;\\n        originalNumber /= 10;\\n    }\\n    return number == sum;\\n}\\n\\n/**\\n * Test function\\n * @return void\\n */\\nvoid test()\\n{\\n    assert(isStrong(145));  /* 145 = 1! + 4! + 5! */\\n    assert(!isStrong(543)); /* 543 != 5!+ 4! + 3! */\\n}\\n\\n/**\\n * Driver Code\\n * @return None\\n */\\nint main()\\n{\\n    test();\\n    return 0;\\n}\\n\"",
    "sudoku solver": "\"/**\\n * @file\\n * @brief Sudoku Solver using recursive implementation of brute-force algorithm\\n *\\n * @details\\n * Given an incomplete N*N Sudoku and asked to solve it using the\\n * following recursive algorithm:\\n * 1. Scan the Sudoku from left to right row-wise to search for an empty cell.\\n * 2. If there are no empty cells, print the Sudoku. Go to step 5.\\n * 3. In the empty cell, try putting numbers 1 to N\\n * while ensuring that no two numbers in a single row, column, or box are same.\\n * Go back to step 1.\\n * 4. Declare that the Sudoku is Invalid.\\n * 5. Exit.\\n *\\n * @authors [Anuj Shah](https://github.com/anujms1999)\\n * @authors [Krishna Vedala](https://github.com/kvedala)\\n */\\n#include <assert.h>\\n#include <inttypes.h>\\n#include <math.h>\\n#include <stdbool.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n/** @addtogroup sudoku Sudoku solver\\n * @{\\n */\\n/** Structure to hold the matrix and dimensions\\n */\\nstruct sudoku\\n{\\n    uint8_t *a; /**< matrix as a flattened 1D row-major array */\\n    uint8_t N;  /**< number of elements */\\n    uint8_t N2; /**< block of elements */\\n};\\n\\n/**\\n * Check if `x`^th row is valid\\n * @param a ::sudoku to check\\n * @param x row to check\\n * @param y ignored column\\n * @param v value to check if it repeats\\n * @returns `true` if valid\\n * @returns `false` if in-valid\\n */\\nbool OKrow(const struct sudoku *a, int x, int y, int v)\\n{\\n    int offset = x * a->N;\\n    for (int j = 0; j < a->N; j++)\\n        if (a->a[offset + j] == v)\\n            // if the value is found in the row\\n            return false;\\n    return true;\\n}\\n\\n/**\\n * Check if `y`^th column is valid\\n * @param a ::sudoku to check\\n * @param x ignored row\\n * @param y column to check\\n * @param v value to check if it repeats\\n * @returns `true` if valid\\n * @returns `false` if in-valid\\n */\\nbool OKcol(const struct sudoku *a, int x, int y, int v)\\n{\\n    for (int i = 0; i < a->N; i++)\\n        if (a->a[i * a->N + y] == v)\\n            // if the value is found in the column\\n            return false;\\n    return true;\\n}\\n\\n/**\\n * Check if a 3x3 box is valid\\n * @param a matrix to check\\n * @param x row index of the element to check\\n * @param y column index of the element to check\\n * @param v value to check if it repeats\\n * @returns `true` if valid\\n * @returns `false` if in-valid\\n */\\nbool OKbox(const struct sudoku *a, int x, int y, int v)\\n{\\n    /* get start indices of the box that the current (x,y) lies in\\n       remember that in C/C++, division operation always rounds towards\\n       -infinity for signed integers and towards 0 for unsigned integers\\n    */\\n    int bi = x - x % a->N2, bj = y - y % a->N2;\\n    // printf(\\\"Checking box: (%d,%d)\\\\n\\\", bi, bj);\\n\\n    for (int i = bi; i < (bi + a->N2); i++)\\n        for (int j = bj; j < (bj + a->N2); j++)\\n            if (a->a[i * a->N + j] == v)\\n                // if the value is found in the box\\n                return false;\\n    return true;\\n}\\n\\n/**\\n * Check if element `v` is valid to place at (x,y) location.\\n * @param a ::sudoku to check\\n * @param x row to place value\\n * @param y column to place value\\n * @param v value to check if it is valid\\n * @returns `true` if valid\\n * @returns `false` if in-valid\\n */\\nbool OK(const struct sudoku *a, int x, int y, int v)\\n{\\n    bool result = OKrow(a, x, y, v);\\n    if (result)\\n        result = OKcol(a, x, y, v);\\n    if (result)\\n        result = OKbox(a, x, y, v);\\n\\n    return result;\\n}\\n\\n/**\\n * Print the matrix to stdout\\n * @param [in] a array to print\\n */\\nvoid print(const struct sudoku *a)\\n{\\n    int i, j;\\n    for (i = 0; i < a->N; i++)\\n        for (j = 0; j < a->N; j++)\\n            printf(\\\"%\\\" SCNu8 \\\"%c\\\", a->a[i * a->N + j],\\n                   (j == a->N - 1 ? '\\\\n' : ' '));\\n}\\n\\n/**\\n * @brief Find and get the location for next empty cell.\\n *\\n * @param [in] a pointer to sudoku instance\\n * @param [out] x pointer to row index of next unknown\\n * @param [out] y pointer to column index of next unknown\\n * @returns `true` if an empty location was found\\n * @returns `false` if no more empty locations found\\n */\\nbool get_next_unknown(const struct sudoku *a, int *x, int *y)\\n{\\n    for (int i = 0; i < a->N; i++)\\n    {\\n        for (int j = 0; j < a->N; j++)\\n        {\\n            if (a->a[i * a->N + j] == 0)\\n            {\\n                *x = i;\\n                *y = j;\\n                return true;\\n            }\\n        }\\n    }\\n\\n    /* no unknown locations found */\\n    return false;\\n}\\n\\n/**\\n * @brief Function to solve a partially filled sudoku matrix. For each unknown\\n * value (0), the function fills a possible value and calls the function again\\n * to check forvalid solution.\\n *\\n * @param [in,out] a sudoku matrix to solve\\n * @return `true` if solution found\\n * @return `false` if no solution found\\n */\\nbool solve(struct sudoku *a)\\n{\\n    static uint32_t counter = 0;\\n    int i, j;\\n    static char prefix[100] = \\\"\\\";  // enough memory\\n\\n    if (!get_next_unknown(a, &i, &j))\\n    {\\n        /* no more empty location found\\n           implies all good in the matrix\\n         */\\n        return true;\\n    }\\n\\n    /* try all possible values for the unknown */\\n    for (uint8_t v = 1; v <= a->N; v++)\\n    { /* try all possible values 1 thru N */\\n        printf(\\\"%sTry (%d,%d) = %\\\" SCNu8 \\\"... \\\", prefix, i, j, v);\\n        counter++;\\n        if (OK(a, i, j, v))\\n        {\\n            /* if assignment checks satisfy, set the value and\\n             continue with remaining elements */\\n            printf(\\\"passed (counter=%\\\" SCNu32 \\\")\\\\n\\\", counter);\\n            a->a[i * a->N + j] = v;\\n            strcat(prefix, \\\"  \\\");\\n            if (solve(a))\\n            {\\n                /* solution found */\\n                return true;\\n            }\\n\\n            printf(\\\"%sBacktrack (%d,%d) <- %\\\" SCNu8 \\\" (counter=%\\\" SCNu32 \\\")\\\\n\\\",\\n                   prefix, i, j, a->a[i * a->N + j], counter);\\n\\n            prefix[strlen(prefix) - 2] = '\\\\0';  // truncate the prefix\\n            a->a[i * a->N + j] = 0;\\n        }\\n        else\\n        {\\n            printf(\\\"\\\\r\\\");\\n        }\\n    }\\n\\n    return false;\\n}\\n\\n/** @} */\\n\\nvoid test()\\n{\\n    printf(\\\"Test begin...\\\\n\\\");\\n\\n    uint8_t test_array[] = {3, 0, 6, 5, 0, 8, 4, 0, 0, 5, 2, 0, 0, 0, 0, 0, 0,\\n                            0, 0, 8, 7, 0, 0, 0, 0, 3, 1, 0, 0, 3, 0, 1, 0, 0,\\n                            8, 0, 9, 0, 0, 8, 6, 3, 0, 0, 5, 0, 5, 0, 0, 9, 0,\\n                            6, 0, 0, 1, 3, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0,\\n                            0, 0, 7, 4, 0, 0, 5, 2, 0, 6, 3, 0, 0};\\n    struct sudoku a = {.N = 9, .N2 = 3, .a = test_array};\\n    assert(solve(&a));  // ensure that solution is obtained\\n\\n    uint8_t expected[] = {3, 1, 6, 5, 7, 8, 4, 9, 2, 5, 2, 9, 1, 3, 4, 7, 6,\\n                          8, 4, 8, 7, 6, 2, 9, 5, 3, 1, 2, 6, 3, 4, 1, 5, 9,\\n                          8, 7, 9, 7, 4, 8, 6, 3, 1, 2, 5, 8, 5, 1, 7, 9, 2,\\n                          6, 4, 3, 1, 3, 8, 9, 4, 7, 2, 5, 6, 6, 9, 2, 3, 5,\\n                          1, 8, 7, 4, 7, 4, 5, 2, 8, 6, 3, 1, 9};\\n    for (int i = 0; i < a.N; i++)\\n        for (int j = 0; j < a.N; j++)\\n            assert(a.a[i * a.N + j] == expected[i * a.N + j]);\\n\\n    printf(\\\"Test passed\\\\n\\\");\\n}\\n\\n/** \\\\brief Main function */\\nint main()\\n{\\n    test();\\n\\n    struct sudoku a;  // store the matrix as a 1D array\\n    scanf(\\\"%\\\" SCNu8, &(a.N));\\n    a.a = (uint8_t *)malloc(a.N * a.N * sizeof(uint8_t));\\n    a.N2 = (uint8_t)sqrt(a.N);\\n\\n    for (int i = 0; i < a.N; i++)\\n        for (int j = 0; j < a.N; j++) scanf(\\\"%\\\" SCNu8, &(a.a[i * a.N + j]));\\n\\n    printf(\\\"Entered a %udx%ud matrix with block size: %\\\" SCNu8 \\\"\\\\n\\\", a.N, a.N,\\n           a.N2);\\n    // print(&a);\\n    printf(\\\"\\\\n\\\\n\\\");\\n    if (solve(&a))\\n        printf(\\\"Valid solution found!\\\\n\\\");\\n    else\\n        printf(\\\"Invalid\\\\n\\\");\\n    print(&a);\\n\\n    free(a.a);\\n    return 0;\\n}\\n\"",
    "tower of hanoi": "\"\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n// Function for Tower of Hanoi algorithm\\nvoid hanoi(int noOfDisks, char where, char to, char extra)\\n{\\n    if (noOfDisks != 0)\\n    {\\n        hanoi(noOfDisks - 1, where, extra, to);\\n        printf(\\\"Move disk : %d from %c to %c\\\\n\\\", noOfDisks, where, to);\\n        hanoi(noOfDisks - 1, extra, to, where);\\n    }\\n}\\nint main(void)\\n{\\n    int noOfDisks;\\n\\n    // Asks the number of disks in the tower\\n    printf(\\\"Number of disks: \\\\n\\\");\\n    scanf(\\\"%d\\\", &noOfDisks);\\n\\n    hanoi(noOfDisks, 'A', 'B', 'C');\\n\\n    return 0;\\n}\\n\"",
    "union find": "\"/**\\n * @file union_find.c\\n * @brief [Union\\n * find](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) algorithm.\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n#define MAX_SIZE 1000 /**< maximum number of elements in the set */\\n\\n/**\\n * @brief Find index of or value in an array\\n *\\n * @param [in,out] p array to search and update\\n * @param x value to search\\n * @return value at the index `x`\\n */\\nint find(int *p, int x)\\n{\\n    if (x >= MAX_SIZE)\\n    {\\n        fprintf(stderr, \\\"Out-of bounds value\\\\n\\\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    if (p[x] == x)\\n    {\\n        return x;\\n    }\\n    else\\n    {\\n        p[x] = find(p, p[x]);\\n        return p[x];\\n    }\\n}\\n\\n/**\\n * @brief Function to join\\n * @param [in,out] p array to join in\\n * @param x value or index to join to\\n * @param y value or index to join from\\n */\\nvoid join(int *p, int x, int y) { p[find(p, x)] = find(p, y); }\\n\\n/** Main function */\\nint main()\\n{\\n    int union_set[MAX_SIZE];\\n\\n    // Have all array indexes that you need to use reference themselves\\n    for (int i = 0; i < 10; i++)\\n    {\\n        union_set[i] = i;\\n    }\\n    // p = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\\n\\n    join(union_set, 3, 5);\\n    printf(\\\"The array is now: \\\");\\n    for (int i = 0; i < 10; i++)\\n    {\\n        printf(\\\"%d \\\", union_set[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n    // Now 3 and 5 are groupped together, that is find(3) = find(5)\\n    // p = {0, 1, 2, 5, 4, 5, 6, 7, 8, 9}\\n\\n    join(union_set, 3, 8);\\n    printf(\\\"The array is now: \\\");\\n    for (int i = 0; i < 10; i++)\\n    {\\n        printf(\\\"%d \\\", union_set[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n\\n    // Now 3, 5 and are groupped together, find(3) = find(5) = find(8)\\n    // p = {0, 1, 2, 5, 4, 8, 6, 7, 8, 9}\\n    join(union_set, 0, 5);\\n    if (find(union_set, 0) == find(union_set, 3))\\n    {\\n        printf(\\\"0 and 3 are groupped together\\\\n\\\");\\n    }\\n    printf(\\\"The array is now: \\\");\\n    for (int i = 0; i < 10; i++)\\n    {\\n        printf(\\\"%d \\\", union_set[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n\\n    return 0;\\n}\\n\"",
    "durand kerner roots": "\"/**\\n * @file\\n * \\\\brief Compute all possible approximate roots of any given polynomial using\\n * [Durand Kerner\\n * algorithm](https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method)\\n *\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n *\\n * Test the algorithm online:\\n * https://gist.github.com/kvedala/27f1b0b6502af935f6917673ec43bcd7\\n *\\n * Try the highly unstable Wilkinson's polynomial:\\n * ```\\n * ./numerical_methods/durand_kerner_roots.c 1 -210 20615 -1256850 53327946\\n * -1672280820 40171771630 -756111184500 11310276995381 -135585182899530\\n * 1307535010540395 -10142299865511450 63030812099294896 -311333643161390640\\n * 1206647803780373360 -3599979517947607200 8037811822645051776\\n * -12870931245150988800 13803759753640704000 -8752948036761600000\\n * 2432902008176640000\\n * ```\\n * Sample implementation results to compute approximate roots of the equation\\n * \\\\f$x^4-1=0\\\\f$:\\\\n\\n * <img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/durand_kerner_error.svg\\\"\\n * width=\\\"400\\\" alt=\\\"Error evolution during root approximations computed every\\n * iteration.\\\"/> <img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/durand_kerner_roots.svg\\\"\\n * width=\\\"400\\\" alt=\\\"Roots evolution - shows the initial approximation of the\\n * roots and their convergence to a final approximation along with the iterative\\n * approximations\\\" />\\n */\\n\\n#include <complex.h>\\n#include <limits.h>\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <time.h>\\n\\n#define ACCURACY 1e-10 /**< maximum accuracy limit */\\n\\n/**\\n * Evaluate the value of a polynomial with given coefficients\\n * \\\\param[in] coeffs coefficients of the polynomial\\n * \\\\param[in] degree degree of polynomial\\n * \\\\param[in] x point at which to evaluate the polynomial\\n * \\\\returns \\\\f$f(x)\\\\f$\\n */\\nlong double complex poly_function(long double *coeffs, unsigned int degree,\\n                                  long double complex x)\\n{\\n    long double complex out = 0.;\\n    unsigned int n;\\n\\n    for (n = 0; n < degree; n++) out += coeffs[n] * cpow(x, degree - n - 1);\\n\\n    return out;\\n}\\n\\n/**\\n * create a textual form of complex number\\n * \\\\param[in] x point at which to evaluate the polynomial\\n * \\\\returns pointer to converted string\\n */\\nconst char *complex_str(long double complex x)\\n{\\n    static char msg[50];\\n    double r = creal(x);\\n    double c = cimag(x);\\n\\n    sprintf(msg, \\\"% 7.04g%+7.04gj\\\", r, c);\\n\\n    return msg;\\n}\\n\\n/**\\n * check for termination condition\\n * \\\\param[in] delta point at which to evaluate the polynomial\\n * \\\\returns 0 if termination not reached\\n * \\\\returns 1 if termination reached\\n */\\nchar check_termination(long double delta)\\n{\\n    static long double past_delta = INFINITY;\\n    if (fabsl(past_delta - delta) <= ACCURACY || delta < ACCURACY)\\n        return 1;\\n    past_delta = delta;\\n    return 0;\\n}\\n\\n/***\\n * the comandline inputs are taken as coeffiecients of a polynomial\\n */\\nint main(int argc, char **argv)\\n{\\n    long double *coeffs = NULL;\\n    long double complex *s0 = NULL;\\n    unsigned int degree = 0;\\n    unsigned int n, i;\\n\\n    if (argc < 2)\\n    {\\n        printf(\\n            \\\"Please pass the coefficients of the polynomial as commandline \\\"\\n            \\\"arguments.\\\\n\\\");\\n        return 0;\\n    }\\n\\n    degree = argc - 1; /* detected polynomial degree */\\n    coeffs = (long double *)malloc(\\n        degree * sizeof(long double)); /* store all input coefficients */\\n    s0 = (long double complex *)malloc(\\n        (degree - 1) *\\n        sizeof(long double complex)); /* number of roots = degree-1 */\\n\\n    /* initialize random seed: */\\n    srand(time(NULL));\\n\\n    if (!coeffs || !s0)\\n    {\\n        perror(\\\"Unable to allocate memory!\\\");\\n        if (coeffs)\\n            free(coeffs);\\n        if (s0)\\n            free(s0);\\n        return EXIT_FAILURE;\\n    }\\n\\n#if defined(DEBUG) || !defined(NDEBUG)\\n    /**\\n     * store intermediate values to a CSV file\\n     */\\n    FILE *log_file = fopen(\\\"durand_kerner.log.csv\\\", \\\"wt\\\");\\n    if (!log_file)\\n    {\\n        perror(\\\"Unable to create a storage log file!\\\");\\n        free(coeffs);\\n        free(s0);\\n        return EXIT_FAILURE;\\n    }\\n    fprintf(log_file, \\\"iter#,\\\");\\n#endif\\n\\n    printf(\\\"Computing the roots for:\\\\n\\\\t\\\");\\n    for (n = 0; n < degree; n++)\\n    {\\n        coeffs[n] = strtod(argv[n + 1], NULL);\\n        if (n < degree - 1 && coeffs[n] != 0)\\n            printf(\\\"(%Lg) x^%d + \\\", coeffs[n], degree - n - 1);\\n        else if (coeffs[n] != 0)\\n            printf(\\\"(%Lg) x^%d = 0\\\\n\\\", coeffs[n], degree - n - 1);\\n\\n        double tmp;\\n        if (n > 0)\\n            coeffs[n] /= tmp; /* numerical errors less when the first\\n                                 coefficient is \\\"1\\\" */\\n        else\\n        {\\n            tmp = coeffs[0];\\n            coeffs[0] = 1;\\n        }\\n\\n        /* initialize root approximations with random values */\\n        if (n < degree - 1)\\n        {\\n            s0[n] = (long double)rand() + (long double)rand() * I;\\n#if defined(DEBUG) || !defined(NDEBUG)\\n            fprintf(log_file, \\\"root_%d,\\\", n);\\n#endif\\n        }\\n    }\\n\\n#if defined(DEBUG) || !defined(NDEBUG)\\n    fprintf(log_file, \\\"avg. correction\\\");\\n    fprintf(log_file, \\\"\\\\n0,\\\");\\n    for (n = 0; n < degree - 1; n++)\\n        fprintf(log_file, \\\"%s,\\\", complex_str(s0[n]));\\n#endif\\n\\n    double tol_condition = 1;\\n    unsigned long iter = 0;\\n\\n    clock_t end_time, start_time = clock();\\n    while (!check_termination(tol_condition) && iter < INT_MAX)\\n    {\\n        long double complex delta = 0;\\n        tol_condition = 0;\\n        iter++;\\n\\n#if defined(DEBUG) || !defined(NDEBUG)\\n        fprintf(log_file, \\\"\\\\n%ld,\\\", iter);\\n#endif\\n\\n        for (n = 0; n < degree - 1; n++)\\n        {\\n            long double complex numerator =\\n                poly_function(coeffs, degree, s0[n]);\\n            long double complex denominator = 1.0;\\n            for (i = 0; i < degree - 1; i++)\\n                if (i != n)\\n                    denominator *= s0[n] - s0[i];\\n\\n            delta = numerator / denominator;\\n\\n            if (isnan(cabsl(delta)) || isinf(cabsl(delta)))\\n            {\\n                printf(\\\"\\\\n\\\\nOverflow/underrun error - got value = %Lg\\\",\\n                       cabsl(delta));\\n                goto end;\\n            }\\n\\n            s0[n] -= delta;\\n\\n            tol_condition = fmaxl(tol_condition, fabsl(cabsl(delta)));\\n\\n#if defined(DEBUG) || !defined(NDEBUG)\\n            fprintf(log_file, \\\"%s,\\\", complex_str(s0[n]));\\n#endif\\n        }\\n        // tol_condition /= (degree - 1);\\n\\n#if defined(DEBUG) || !defined(NDEBUG)\\n        if (iter % 500 == 0)\\n        {\\n            printf(\\\"Iter: %lu\\\\t\\\", iter);\\n            for (n = 0; n < degree - 1; n++) printf(\\\"\\\\t%s\\\", complex_str(s0[n]));\\n            printf(\\\"\\\\t\\\\tabsolute average change: %.4g\\\\n\\\", tol_condition);\\n        }\\n\\n        fprintf(log_file, \\\"%.4g\\\", tol_condition);\\n#endif\\n    }\\nend:\\n\\n    end_time = clock();\\n\\n#if defined(DEBUG) || !defined(NDEBUG)\\n    fclose(log_file);\\n#endif\\n\\n    printf(\\\"\\\\nIterations: %lu\\\\n\\\", iter);\\n    for (n = 0; n < degree - 1; n++) printf(\\\"\\\\t%s\\\\n\\\", complex_str(s0[n]));\\n    printf(\\\"absolute average change: %.4g\\\\n\\\", tol_condition);\\n    printf(\\\"Time taken: %.4g sec\\\\n\\\",\\n           (end_time - start_time) / (double)CLOCKS_PER_SEC);\\n\\n    free(coeffs);\\n    free(s0);\\n\\n    return 0;\\n}\\n\"",
    "gauss elimination": "\"#include <math.h>\\n#include <stdio.h>\\n\\n#define ARRAY_SIZE 20\\n\\nvoid display(float a[ARRAY_SIZE][ARRAY_SIZE], int n)\\n{\\n    int i, j;\\n    for (i = 0; i < n; i++)\\n    {\\n        for (j = 0; j <= n; j++)\\n        {\\n            printf(\\\"%.2f \\\\t\\\", a[i][j]);\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nfloat interchange(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)\\n{\\n    float tmp[ARRAY_SIZE][ARRAY_SIZE];\\n    float max = fabs(m[i][i]);\\n    int j, k = i;\\n\\n    for (j = i; j < n; j++)\\n    {\\n        if (max < fabs(m[j][i]))\\n        {\\n            max = fabs(m[j][i]);\\n            k = j;\\n        }\\n    }\\n    for (j = 0; j <= n; j++)\\n    {\\n        tmp[i][j] = m[i][j];\\n        m[i][j] = m[k][j];\\n        m[k][j] = tmp[i][j];\\n    }\\n    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];\\n}\\nfloat eliminate(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)\\n{\\n    float tmp;\\n    int k = 1, l, j;\\n    for (j = i; j < n - 1; j++)\\n    {\\n        tmp = -((m[i + k][i]) / (m[i][i]));\\n        for (l = 0; l <= n; l++)\\n        {\\n            m[i + k][l] = (m[i + k][l]) + (m[i][l] * tmp);\\n        }\\n        k++;\\n    }\\n    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];\\n}\\nint main(void)\\n{\\n    int i, j, n, k = 0, l;\\n    float m[ARRAY_SIZE][ARRAY_SIZE], mul, tmp[ARRAY_SIZE][ARRAY_SIZE], val,\\n        ans[ARRAY_SIZE];\\n\\n    printf(\\\"Total No.of Equations : \\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    printf(\\\"\\\\n\\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"Enter Co-efficient Of Equations %d & Total --->>>\\\\n\\\", i + 1);\\n        for (j = 0; j <= n; j++)\\n        {\\n            printf(\\\"r%d%d : \\\", i, j);\\n            scanf(\\\"%f\\\", &m[i][j]);\\n        }\\n        printf(\\\"\\\\n\\\");\\n    }\\n    printf(\\\":::::::::::: Current Matrix ::::::::::::\\\\n\\\\n\\\");\\n    display(m, n);\\n\\n    for (i = 0; i < n - 1; i++)\\n    {\\n        printf(\\\"\\\\n------->>>>>>>>>>>>>>>>>>>>>>>>-------- %d\\\\n\\\", i + 1);\\n        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = interchange(m, i, n);\\n        display(m, n);\\n        printf(\\\"\\\\n_______________________________________\\\\n\\\");\\n        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = eliminate(m, i, n);\\n        display(m, n);\\n    }\\n    printf(\\\"\\\\n\\\\n Values are : \\\\n\\\");\\n    for (i = n - 1; i >= 0; i--)\\n    {\\n        l = n - 1;\\n        mul = 0;\\n        for (j = 0; j < k; j++)\\n        {\\n            mul = mul + m[i][l] * ans[l];\\n            l--;\\n        }\\n        k++;\\n        ans[i] = (m[i][n] - mul) / m[i][i];\\n        printf(\\\"X%d = %.2f\\\\n\\\", i + 1, ans[i]);\\n    }\\n\\n    return 0;\\n}\\n\"",
    "gauss seidel method": "\"#include <math.h>\\n#include <stdio.h>\\n\\nint main()\\n{\\n    float a, b, c, a1, a2, a3, b1, b2, b3, c1, c2, c3, d1, d2, d3, x1, x2, x3;\\n\\n    printf(\\\"Enter values of eq1:\\\");\\n    scanf(\\\"%f%f%f%f\\\", &a1, &a2, &a3, &d1);\\n    printf(\\\"Enter values of eq2:\\\");\\n    scanf(\\\"%f%f%f%f\\\", &b1, &b2, &b3, &d2);\\n    printf(\\\"Enter values of eq3:\\\");\\n    scanf(\\\"%f%f%f%f\\\", &c1, &c2, &c3, &d3);\\n    x1 = x2 = x3 = 0.0;\\n    do\\n    {\\n        a = x1;\\n        b = x2;\\n        c = x3;\\n        x1 = (1 / a1) * (d1 - (a2 * x2) - (a3 * x3));\\n        x2 = (1 / b2) * (d2 - (b1 * x1) - (b3 * x3));\\n        x3 = (1 / c3) * (d3 - (c1 * x1) - (c2 * x2));\\n    } while (fabs(x1 - a) > 0.0001 && fabs(x2 - b) > 0.0001 &&\\n             fabs(x3 - c) > 0.0001);\\n    printf(\\\"x1=%f\\\\nx2=%f\\\\nx3=%f\\\", x1, x2, x3);\\n\\n    return 0;\\n}\"",
    "lagrange theorem": "\"#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main()\\n{\\n    float x[20], y[20], a, sum, p;\\n    int n, i, j;\\n\\n    printf(\\\"Enter the no of entry to insert->\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"enter the value of x%d->\\\", i);\\n        scanf(\\\"%f\\\", &x[i]);\\n        printf(\\\"enter the value of y%d->\\\", i);\\n        scanf(\\\"%f\\\", &y[i]);\\n    }\\n    printf(\\\"\\\\n X \\\\t\\\\t Y \\\\n\\\");\\n    printf(\\\"----------------------------\\\\n\\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"%f\\\\t\\\", x[i]);\\n        printf(\\\"%f\\\\n\\\", y[i]);\\n    }\\n    printf(\\\"\\\\nenter the value of x for interpolation:\\\");\\n    scanf(\\\"%f\\\", &a);\\n    sum = 0;\\n    for (i = 0; i < n; i++)\\n    {\\n        p = 1.0;\\n        for (j = 0; j < n; j++)\\n        {\\n            if (i != j)\\n            {\\n                p = p * (a - x[j]) / (x[i] - x[j]);\\n            }\\n            sum = sum + y[i] * p;\\n        }\\n        printf(\\\"ans is->%f\\\", sum);\\n\\n        return 0;\\n    }\\n}\"",
    "lu decompose": "\"/**\\n * \\\\file\\n * \\\\brief [LU decomposition](https://en.wikipedia.org/wiki/LU_decompositon) of a\\n * square matrix\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#ifdef _OPENMP\\n#include <omp.h>\\n#endif\\n\\n/** Perform LU decomposition on matrix\\n * \\\\param[in] A matrix to decompose\\n * \\\\param[out] L output L matrix\\n * \\\\param[out] U output U matrix\\n * \\\\param[in] mat_size input square matrix size\\n */\\nint lu_decomposition(double **A, double **L, double **U, int mat_size)\\n{\\n    int row, col, j;\\n\\n    // regularize each row\\n    for (row = 0; row < mat_size; row++)\\n    {\\n        // Upper triangular matrix\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n        for (col = row; col < mat_size; col++)\\n        {\\n            // Summation of L[i,j] * U[j,k]\\n            double lu_sum = 0.;\\n            for (j = 0; j < row; j++) lu_sum += L[row][j] * U[j][col];\\n\\n            // Evaluate U[i,k]\\n            U[row][col] = A[row][col] - lu_sum;\\n        }\\n\\n        // Lower triangular matrix\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n        for (col = row; col < mat_size; col++)\\n        {\\n            if (row == col)\\n            {\\n                L[row][col] = 1.;\\n                continue;\\n            }\\n\\n            // Summation of L[i,j] * U[j,k]\\n            double lu_sum = 0.;\\n            for (j = 0; j < row; j++) lu_sum += L[col][j] * U[j][row];\\n\\n            // Evaluate U[i,k]\\n            L[col][row] = (A[col][row] - lu_sum) / U[row][row];\\n        }\\n    }\\n\\n    return 0;\\n}\\n\\n/** Function to display square matrix */\\nvoid display(double **A, int N)\\n{\\n    for (int i = 0; i < N; i++)\\n    {\\n        for (int j = 0; j < N; j++)\\n        {\\n            printf(\\\"% 3.3g \\\\t\\\", A[i][j]);\\n        }\\n        putchar('\\\\n');\\n    }\\n}\\n\\n/** Main function */\\nint main(int argc, char **argv)\\n{\\n    int mat_size = 3;  // default matrix size\\n    const int range = 10;\\n    const int range2 = range >> 1;\\n\\n    if (argc == 2)\\n        mat_size = atoi(argv[1]);\\n\\n    srand(time(NULL));  // random number initializer\\n\\n    /* Create a square matrix with random values */\\n    double **A = (double **)malloc(mat_size * sizeof(double *));\\n    double **L = (double **)malloc(mat_size * sizeof(double *));  // output\\n    double **U = (double **)malloc(mat_size * sizeof(double *));  // output\\n    for (int i = 0; i < mat_size; i++)\\n    {\\n        // calloc so that all valeus are '0' by default\\n        A[i] = (double *)calloc(mat_size, sizeof(double));\\n        L[i] = (double *)calloc(mat_size, sizeof(double));\\n        U[i] = (double *)calloc(mat_size, sizeof(double));\\n        for (int j = 0; j < mat_size; j++)\\n            /* create random values in the limits [-range2, range-1] */\\n            A[i][j] = (double)(rand() % range - range2);\\n    }\\n\\n    lu_decomposition(A, L, U, mat_size);\\n\\n    printf(\\\"A = \\\\n\\\");\\n    display(A, mat_size);\\n    printf(\\\"\\\\nL = \\\\n\\\");\\n    display(L, mat_size);\\n    printf(\\\"\\\\nU = \\\\n\\\");\\n    display(U, mat_size);\\n\\n    /* Free dynamically allocated memory */\\n    for (int i = 0; i < mat_size; i++)\\n    {\\n        free(A[i]);\\n        free(L[i]);\\n        free(U[i]);\\n    }\\n    free(A);\\n    free(L);\\n    free(U);\\n\\n    return 0;\\n}\"",
    "mean": "\"#include <limits.h>\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAX_LEN INT_MAX\\n\\nint main(int argc, char **argv)\\n{\\n    int *a, n = 10, i, j, temp, sum = 0;\\n    float mean;\\n\\n    if (argc == 2)\\n    {\\n        n = atoi(argv[1]);\\n        if (n >= MAX_LEN)\\n        {\\n            fprintf(stderr, \\\"Maximum %d!\\\\n\\\", MAX_LEN);\\n            return 1;\\n        }\\n    }\\n    \\n    a = (int *)malloc(n * sizeof(int));\\n\\n    printf(\\\"Random Numbers Generated are: \\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        a[i] = rand() % 100;\\n        printf(\\\"%2d, \\\", a[i]);\\n    }\\n    putchar('\\\\n');\\n\\n    for (i = 0; i < n; i++) sum = sum + a[i];\\n\\n    mean = sum / (float)n;\\n    printf(\\\"\\\\nMean: \\\");\\n    printf(\\\"%f\\\\n\\\", mean);\\n\\n    free(a);\\n    return 0;\\n}\\n\"",
    "median": "\"#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main()\\n{\\n    int a[10], n, i, j, temp;\\n    float mean, median;\\n\\n    printf(\\\"Enter no. for Random Numbers :\\\");\\n    scanf(\\\"%d\\\", &n);\\n    for (i = 0; i < n; i++)\\n    {\\n        a[i] = rand() % 100;\\n    }\\n    printf(\\\"Random Numbers Generated are :\\\\n\\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"\\\\n%d\\\", a[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n    printf(\\\"\\\\nSorted Data:\\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        for (j = 0; j < n; j++)\\n        {\\n            if (a[i] < a[j])\\n            {\\n                temp = a[i];\\n                a[i] = a[j];\\n                a[j] = temp;\\n            }\\n        }\\n    }\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"\\\\n%d\\\", a[i]);\\n    }\\n\\n    if (n % 2 == 0)\\n    {\\n        median = (a[n / 2] + a[(n / 2) - 1]) / 2;\\n    }\\n    else\\n    {\\n        median = a[n / 2];\\n    }\\n    printf(\\\"\\\\nMedian is : %f\\\", median);\\n\\n    return 0;\\n}\\n\"",
    "newton raphson root": "\"/**\\n * @file\\n * \\\\brief Find approximate solution for \\\\f$f(x) = 0\\\\f$ using\\n * Newton-Raphson interpolation algorithm.\\n *\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n\\n#include <complex.h> /* requires minimum of C99 */\\n#include <limits.h>\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n#define ACCURACY 1e-10 /**< solution accuracy */\\n\\n/**\\n * Return value of the function to find the root for.\\n * \\\\f$f(x)\\\\f$\\n */\\ndouble complex func(double complex x)\\n{\\n    return x * x - 3.; /* x^2 = 3 - solution is sqrt(3) */\\n    // return x * x - 2.; /* x^2 = 2 - solution is sqrt(2) */\\n}\\n\\n/**\\n * Return first order derivative of the function.\\n * \\\\f$f'(x)\\\\f$\\n */\\ndouble complex d_func(double complex x) { return 2. * x; }\\n\\n/**\\n * main function\\n */\\nint main(int argc, char **argv)\\n{\\n    double delta = 1;\\n    double complex cdelta = 1;\\n\\n    /* initialize random seed: */\\n    srand(time(NULL));\\n\\n    /* random initial approximation */\\n    double complex root = (rand() % 100 - 50) + (rand() % 100 - 50) * I;\\n\\n    unsigned long counter = 0;\\n    /* iterate till a convergence is reached */\\n    while (delta > ACCURACY && counter < ULONG_MAX)\\n    {\\n        cdelta = func(root) / d_func(root);\\n        root += -cdelta;\\n        counter++;\\n        delta = fabs(cabs(cdelta));\\n\\n#if defined(DEBUG) || !defined(NDEBUG)\\n        if (counter % 50 == 0)\\n        {\\n            double r = creal(root);\\n            double c = cimag(root);\\n\\n            printf(\\\"Iter %5lu: Root: %4.4g%c%4.4gi\\\\t\\\\tdelta: %.4g\\\\n\\\", counter,\\n                   r, c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);\\n        }\\n#endif\\n    }\\n\\n    double r = creal(root);\\n    double c = fabs(cimag(root)) < ACCURACY ? 0 : cimag(root);\\n\\n    printf(\\\"Iter %5lu: Root: %4.4g%c%4.4gi\\\\t\\\\tdelta: %.4g\\\\n\\\", counter, r,\\n           c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);\\n\\n    return 0;\\n}\\n\"",
    "ode forward euler": "\"/**\\n * \\\\file\\n * \\\\authors [Krishna Vedala](https://github.com/kvedala)\\n * \\\\brief Solve a multivariable first order [ordinary differential equation\\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\\n * [forward Euler\\n * method](https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations#Euler_method)\\n *\\n * \\\\details\\n * The ODE being solved is:\\n * \\\\f{eqnarray*}{\\n * \\\\dot{u} &=& v\\\\\\\\\\n * \\\\dot{v} &=& -\\\\omega^2 u\\\\\\\\\\n * \\\\omega &=& 1\\\\\\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\\\qquad\\\\ldots\\\\text{(initial values)}\\n * \\\\f}\\n * The exact solution for the above problem is:\\n * \\\\f{eqnarray*}{\\n * u(x) &=& \\\\cos(x)\\\\\\\\\\n * v(x) &=& -\\\\sin(x)\\\\\\\\\\n * \\\\f}\\n * The computation results are stored to a text file `forward_euler.csv` and the\\n * exact soltuion results in `exact.csv` for comparison.\\n * <img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_forward_euler.svg\\\"\\n * alt=\\\"Implementation solution\\\"/>\\n *\\n * To implement [Van der Pol\\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\\n * ::problem function to:\\n * ```cpp\\n * const double mu = 2.0;\\n * dy[0] = y[1];\\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\\n * ```\\n * \\\\see ode_midpoint_euler.c, ode_semi_implicit_euler.c\\n */\\n\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n#define order 2 /**< number of dependent variables in ::problem */\\n\\n/**\\n * @brief Problem statement for a system with first-order differential\\n * equations. Updates the system differential variables.\\n * \\\\note This function can be updated to and ode of any order.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable(s)\\n * @param[in,out]\\ty\\t\\tdependent variable(s)\\n * @param[in,out]\\tdy\\t    first-derivative of dependent variable(s)\\n */\\nvoid problem(const double *x, double *y, double *dy)\\n{\\n    const double omega = 1.F;       // some const for the problem\\n    dy[0] = y[1];                   // x dot\\n    dy[1] = -omega * omega * y[0];  // y dot\\n}\\n\\n/**\\n * @brief Exact solution of the problem. Used for solution comparison.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable\\n * @param[in,out]\\ty\\t\\tdependent variable\\n */\\nvoid exact_solution(const double *x, double *y)\\n{\\n    y[0] = cos(x[0]);\\n    y[1] = -sin(x[0]);\\n}\\n\\n/**\\n * @brief Compute next step approximation using the forward-Euler\\n * method. @f[y_{n+1}=y_n + dx\\\\cdot f\\\\left(x_n,y_n\\\\right)@f]\\n * @param[in] \\t\\tdx\\tstep size\\n * @param[in,out] \\tx\\ttake \\\\f$x_n\\\\f$ and compute \\\\f$x_{n+1}\\\\f$\\n * @param[in,out] \\ty\\ttake \\\\f$y_n\\\\f$ and compute \\\\f$y_{n+1}\\\\f$\\n * @param[in,out]\\tdy\\tcompute \\\\f$f\\\\left(x_n,y_n\\\\right)\\\\f$\\n */\\nvoid forward_euler_step(const double dx, const double *x, double *y, double *dy)\\n{\\n    int o;\\n    problem(x, y, dy);\\n    for (o = 0; o < order; o++) y[o] += dx * dy[o];\\n}\\n\\n/**\\n * @brief Compute approximation using the forward-Euler\\n * method in the given limits.\\n * @param[in] \\t\\tdx  \\tstep size\\n * @param[in]   \\tx0  \\tinitial value of independent variable\\n * @param[in] \\t    x_max\\tfinal value of independent variable\\n * @param[in,out] \\ty\\t    take \\\\f$y_n\\\\f$ and compute \\\\f$y_{n+1}\\\\f$\\n * @param[in] save_to_file\\tflag to save results to a CSV file (1) or not (0)\\n * @returns time taken for computation in seconds\\n */\\ndouble forward_euler(double dx, double x0, double x_max, double *y,\\n                     char save_to_file)\\n{\\n    double dy[order];\\n\\n    FILE *fp = NULL;\\n    if (save_to_file)\\n    {\\n        fp = fopen(\\\"forward_euler.csv\\\", \\\"w+\\\");\\n        if (fp == NULL)\\n        {\\n            perror(\\\"Error! \\\");\\n            return -1;\\n        }\\n    }\\n\\n    /* start integration */\\n    clock_t t1 = clock();\\n    double x = x0;\\n    do  // iterate for each step of independent variable\\n    {\\n        if (save_to_file && fp)\\n            fprintf(fp, \\\"%.4g,%.4g,%.4g\\\\n\\\", x, y[0], y[1]);  // write to file\\n        forward_euler_step(dx, &x, y, dy);  // perform integration\\n        x += dx;                            // update step\\n    } while (x <= x_max);  // till upper limit of independent variable\\n    /* end of integration */\\n    clock_t t2 = clock();\\n\\n    if (save_to_file && fp)\\n        fclose(fp);\\n\\n    return (double)(t2 - t1) / CLOCKS_PER_SEC;\\n}\\n\\n/**\\n    Main Function\\n*/\\nint main(int argc, char *argv[])\\n{\\n    double X0 = 0.f;          /* initial value of x0 */\\n    double X_MAX = 10.F;      /* upper limit of integration */\\n    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */\\n    double step_size;\\n\\n    if (argc == 1)\\n    {\\n        printf(\\\"\\\\nEnter the step size: \\\");\\n        scanf(\\\"%lg\\\", &step_size);\\n    }\\n    else\\n        // use commandline argument as independent variable step size\\n        step_size = atof(argv[1]);\\n\\n    // get approximate solution\\n    double total_time = forward_euler(step_size, X0, X_MAX, Y0, 1);\\n    printf(\\\"\\\\tTime = %.6g ms\\\\n\\\", total_time);\\n\\n    /* compute exact solution for comparion */\\n    FILE *fp = fopen(\\\"exact.csv\\\", \\\"w+\\\");\\n    if (fp == NULL)\\n    {\\n        perror(\\\"Error! \\\");\\n        return -1;\\n    }\\n    double x = X0;\\n    double *y = &(Y0[0]);\\n    printf(\\\"Finding exact solution\\\\n\\\");\\n    clock_t t1 = clock();\\n\\n    do\\n    {\\n        fprintf(fp, \\\"%.4g,%.4g,%.4g\\\\n\\\", x, y[0], y[1]);  // write to file\\n        exact_solution(&x, y);\\n        x += step_size;\\n    } while (x <= X_MAX);\\n\\n    clock_t t2 = clock();\\n    total_time = (t2 - t1) / CLOCKS_PER_SEC;\\n    printf(\\\"\\\\tTime = %.6g ms\\\\n\\\", total_time);\\n    fclose(fp);\\n\\n    return 0;\\n}\\n\"",
    "ode midpoint euler": "\"/**\\n * \\\\file\\n * \\\\authors [Krishna Vedala](https://github.com/kvedala)\\n * \\\\brief Solve a multivariable first order [ordinary differential equation\\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\\n * [midpoint Euler\\n * method](https://en.wikipedia.org/wiki/Midpoint_method)\\n *\\n * \\\\details\\n * The ODE being solved is:\\n * \\\\f{eqnarray*}{\\n * \\\\dot{u} &=& v\\\\\\\\\\n * \\\\dot{v} &=& -\\\\omega^2 u\\\\\\\\\\n * \\\\omega &=& 1\\\\\\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\\\qquad\\\\ldots\\\\text{(initial values)}\\n * \\\\f}\\n * The exact solution for the above problem is:\\n * \\\\f{eqnarray*}{\\n * u(x) &=& \\\\cos(x)\\\\\\\\\\n * v(x) &=& -\\\\sin(x)\\\\\\\\\\n * \\\\f}\\n * The computation results are stored to a text file `midpoint_euler.csv` and\\n * the exact soltuion results in `exact.csv` for comparison. <img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_midpoint_euler.svg\\\"\\n * alt=\\\"Implementation solution\\\"/>\\n *\\n * To implement [Van der Pol\\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\\n * ::problem function to:\\n * ```cpp\\n * const double mu = 2.0;\\n * dy[0] = y[1];\\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\\n * ```\\n * \\\\see ode_forward_euler.c, ode_semi_implicit_euler.c\\n */\\n\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n#define order 2 /**< number of dependent variables in ::problem */\\n\\n/**\\n * @brief Problem statement for a system with first-order differential\\n * equations. Updates the system differential variables.\\n * \\\\note This function can be updated to and ode of any order.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable(s)\\n * @param[in,out]\\ty\\t\\tdependent variable(s)\\n * @param[in,out]\\tdy\\t    first-derivative of dependent variable(s)\\n */\\nvoid problem(const double *x, double *y, double *dy)\\n{\\n    const double omega = 1.F;       // some const for the problem\\n    dy[0] = y[1];                   // x dot\\n    dy[1] = -omega * omega * y[0];  // y dot\\n}\\n\\n/**\\n * @brief Exact solution of the problem. Used for solution comparison.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable\\n * @param[in,out]\\ty\\t\\tdependent variable\\n */\\nvoid exact_solution(const double *x, double *y)\\n{\\n    y[0] = cos(x[0]);\\n    y[1] = -sin(x[0]);\\n}\\n\\n/**\\n * @brief Compute next step approximation using the midpoint-Euler\\n * method.\\n * @f[y_{n+1} = y_n + dx\\\\, f\\\\left(x_n+\\\\frac{1}{2}dx,\\n * y_n + \\\\frac{1}{2}dx\\\\,f\\\\left(x_n,y_n\\\\right)\\\\right)@f]\\n * @param[in] \\t\\tdx\\tstep size\\n * @param[in,out] \\tx\\ttake @f$x_n@f$ and compute @f$x_{n+1}@f$\\n * @param[in,out] \\ty\\ttake @f$y_n@f$ and compute @f$y_{n+1}@f$\\n * @param[in,out]\\tdy\\tcompute @f$y_n+\\\\frac{1}{2}dx\\\\,f\\\\left(x_n,y_n\\\\right)@f$\\n */\\nvoid midpoint_euler_step(double dx, double *x, double *y, double *dy)\\n{\\n    problem(x, y, dy);\\n    double tmp_x = (*x) + 0.5 * dx;\\n    double tmp_y[order];\\n    int o;\\n    for (o = 0; o < order; o++) tmp_y[o] = y[o] + 0.5 * dx * dy[o];\\n\\n    problem(&tmp_x, tmp_y, dy);\\n\\n    for (o = 0; o < order; o++) y[o] += dx * dy[o];\\n}\\n\\n/**\\n * @brief Compute approximation using the midpoint-Euler\\n * method in the given limits.\\n * @param[in] \\t\\tdx  \\tstep size\\n * @param[in]   \\tx0  \\tinitial value of independent variable\\n * @param[in] \\t    x_max\\tfinal value of independent variable\\n * @param[in,out] \\ty\\t    take \\\\f$y_n\\\\f$ and compute \\\\f$y_{n+1}\\\\f$\\n * @param[in] save_to_file\\tflag to save results to a CSV file (1) or not (0)\\n * @returns time taken for computation in seconds\\n */\\ndouble midpoint_euler(double dx, double x0, double x_max, double *y,\\n                      char save_to_file)\\n{\\n    double dy[order];\\n\\n    FILE *fp = NULL;\\n    if (save_to_file)\\n    {\\n        fp = fopen(\\\"midpoint_euler.csv\\\", \\\"w+\\\");\\n        if (fp == NULL)\\n        {\\n            perror(\\\"Error! \\\");\\n            return -1;\\n        }\\n    }\\n\\n    /* start integration */\\n    clock_t t1 = clock();\\n    double x = x0;\\n    do  // iterate for each step of independent variable\\n    {\\n        if (save_to_file && fp)\\n            fprintf(fp, \\\"%.4g,%.4g,%.4g\\\\n\\\", x, y[0], y[1]);  // write to file\\n        midpoint_euler_step(dx, &x, y, dy);  // perform integration\\n        x += dx;                             // update step\\n    } while (x <= x_max);  // till upper limit of independent variable\\n    /* end of integration */\\n    clock_t t2 = clock();\\n\\n    if (save_to_file && fp)\\n        fclose(fp);\\n\\n    return (double)(t2 - t1) / CLOCKS_PER_SEC;\\n}\\n\\n/**\\n    Main Function\\n*/\\nint main(int argc, char *argv[])\\n{\\n    double X0 = 0.f;          /* initial value of x0 */\\n    double X_MAX = 10.F;      /* upper limit of integration */\\n    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */\\n    double step_size;\\n\\n    if (argc == 1)\\n    {\\n        printf(\\\"\\\\nEnter the step size: \\\");\\n        scanf(\\\"%lg\\\", &step_size);\\n    }\\n    else\\n        // use commandline argument as independent variable step size\\n        step_size = atof(argv[1]);\\n\\n    // get approximate solution\\n    double total_time = midpoint_euler(step_size, X0, X_MAX, Y0, 1);\\n    printf(\\\"\\\\tTime = %.6g ms\\\\n\\\", total_time);\\n\\n    /* compute exact solution for comparion */\\n    FILE *fp = fopen(\\\"exact.csv\\\", \\\"w+\\\");\\n    if (fp == NULL)\\n    {\\n        perror(\\\"Error! \\\");\\n        return -1;\\n    }\\n    double x = X0;\\n    double *y = &(Y0[0]);\\n    printf(\\\"Finding exact solution\\\\n\\\");\\n    clock_t t1 = clock();\\n\\n    do\\n    {\\n        fprintf(fp, \\\"%.4g,%.4g,%.4g\\\\n\\\", x, y[0], y[1]);  // write to file\\n        exact_solution(&x, y);\\n        x += step_size;\\n    } while (x <= X_MAX);\\n\\n    clock_t t2 = clock();\\n    total_time = (t2 - t1) / CLOCKS_PER_SEC;\\n    printf(\\\"\\\\tTime = %.6g ms\\\\n\\\", total_time);\\n    fclose(fp);\\n\\n    return 0;\\n}\\n\"",
    "ode semi implicit euler": "\"/**\\n * \\\\file\\n * \\\\authors [Krishna Vedala](https://github.com/kvedala)\\n * \\\\brief Solve a multivariable first order [ordinary differential equation\\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\\n * [semi implicit Euler\\n * method](https://en.wikipedia.org/wiki/Semi-implicit_Euler_method)\\n *\\n * \\\\details\\n * The ODE being solved is:\\n * \\\\f{eqnarray*}{\\n * \\\\dot{u} &=& v\\\\\\\\\\n * \\\\dot{v} &=& -\\\\omega^2 u\\\\\\\\\\n * \\\\omega &=& 1\\\\\\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\\\qquad\\\\ldots\\\\text{(initial values)}\\n * \\\\f}\\n * The exact solution for the above problem is:\\n * \\\\f{eqnarray*}{\\n * u(x) &=& \\\\cos(x)\\\\\\\\\\n * v(x) &=& -\\\\sin(x)\\\\\\\\\\n * \\\\f}\\n * The computation results are stored to a text file `semi_implicit_euler.csv`\\n * and the exact soltuion results in `exact.csv` for comparison. <img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_semi_implicit_euler.svg\\\"\\n * alt=\\\"Implementation solution\\\"/>\\n *\\n * To implement [Van der Pol\\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\\n * ::problem function to:\\n * ```cpp\\n * const double mu = 2.0;\\n * dy[0] = y[1];\\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\\n * ```\\n * <a href=\\\"https://en.wikipedia.org/wiki/Van_der_Pol_oscillator\\\"><img\\n * src=\\\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/van_der_pol_implicit_euler.svg\\\"\\n * alt=\\\"Van der Pol Oscillator solution\\\"/></a>\\n *\\n * \\\\see ode_forward_euler.c, ode_midpoint_euler.c\\n */\\n\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n#define order 2 /**< number of dependent variables in ::problem */\\n\\n/**\\n * @brief Problem statement for a system with first-order differential\\n * equations. Updates the system differential variables.\\n * \\\\note This function can be updated to and ode of any order.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable(s)\\n * @param[in,out]\\ty\\t\\tdependent variable(s)\\n * @param[in,out]\\tdy\\t    first-derivative of dependent variable(s)\\n */\\nvoid problem(const double *x, double *y, double *dy)\\n{\\n    const double omega = 1.F;       // some const for the problem\\n    dy[0] = y[1];                   // x dot\\n    dy[1] = -omega * omega * y[0];  // y dot\\n}\\n\\n/**\\n * @brief Exact solution of the problem. Used for solution comparison.\\n *\\n * @param[in] \\t\\tx \\t\\tindependent variable\\n * @param[in,out]\\ty\\t\\tdependent variable\\n */\\nvoid exact_solution(const double *x, double *y)\\n{\\n    y[0] = cos(x[0]);\\n    y[1] = -sin(x[0]);\\n}\\n\\n/**\\n * @brief Compute next step approximation using the semi-implicit-Euler\\n * method.\\n * @param[in] \\t\\tdx\\tstep size\\n * @param[in,out] \\tx\\ttake @f$x_n@f$ and compute @f$x_{n+1}@f$\\n * @param[in,out] \\ty\\ttake @f$y_n@f$ and compute @f$y_{n+1}@f$\\n * @param[in,out]\\tdy\\tcompute @f$y_n+\\\\frac{1}{2}dx\\\\,f\\\\left(x_n,y_n\\\\right)@f$\\n */\\nvoid semi_implicit_euler_step(double dx, double *x, double *y, double *dy)\\n{\\n    int o;\\n\\n    problem(x, y, dy);   // update dy once\\n    y[0] += dx * dy[0];  // update y0\\n\\n    problem(x, y, dy);  // update dy once more\\n\\n    for (o = 1; o < order; o++)\\n        y[o] += dx * dy[o];  // update remaining using new dy\\n    *x += dx;\\n}\\n\\n/**\\n * @brief Compute approximation using the semi-implicit-Euler\\n * method in the given limits.\\n * @param[in] \\t\\tdx  \\tstep size\\n * @param[in]   \\tx0  \\tinitial value of independent variable\\n * @param[in] \\t    x_max\\tfinal value of independent variable\\n * @param[in,out] \\ty\\t    take \\\\f$y_n\\\\f$ and compute \\\\f$y_{n+1}\\\\f$\\n * @param[in] save_to_file\\tflag to save results to a CSV file (1) or not (0)\\n * @returns time taken for computation in seconds\\n */\\ndouble semi_implicit_euler(double dx, double x0, double x_max, double *y,\\n                           char save_to_file)\\n{\\n    double dy[order];\\n\\n    FILE *fp = NULL;\\n    if (save_to_file)\\n    {\\n        fp = fopen(\\\"semi_implicit_euler.csv\\\", \\\"w+\\\");\\n        if (fp == NULL)\\n        {\\n            perror(\\\"Error! \\\");\\n            return -1;\\n        }\\n    }\\n\\n    /* start integration */\\n    clock_t t1 = clock();\\n    double x = x0;\\n    do  // iterate for each step of independent variable\\n    {\\n        if (save_to_file && fp)\\n            fprintf(fp, \\\"%.4g,%.4g,%.4g\\\\n\\\", x, y[0], y[1]);  // write to file\\n        semi_implicit_euler_step(dx, &x, y, dy);  // perform integration\\n        x += dx;                                  // update step\\n    } while (x <= x_max);  // till upper limit of independent variable\\n    /* end of integration */\\n    clock_t t2 = clock();\\n\\n    if (save_to_file && fp)\\n        fclose(fp);\\n\\n    return (double)(t2 - t1) / CLOCKS_PER_SEC;\\n}\\n\\n/**\\n    Main Function\\n*/\\nint main(int argc, char *argv[])\\n{\\n    double X0 = 0.f;          /* initial value of x0 */\\n    double X_MAX = 10.F;      /* upper limit of integration */\\n    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */\\n    double step_size;\\n\\n    if (argc == 1)\\n    {\\n        printf(\\\"\\\\nEnter the step size: \\\");\\n        scanf(\\\"%lg\\\", &step_size);\\n    }\\n    else\\n        // use commandline argument as independent variable step size\\n        step_size = atof(argv[1]);\\n\\n    // get approximate solution\\n    double total_time = semi_implicit_euler(step_size, X0, X_MAX, Y0, 1);\\n    printf(\\\"\\\\tTime = %.6g ms\\\\n\\\", total_time);\\n\\n    /* compute exact solution for comparion */\\n    FILE *fp = fopen(\\\"exact.csv\\\", \\\"w+\\\");\\n    if (fp == NULL)\\n    {\\n        perror(\\\"Error! \\\");\\n        return -1;\\n    }\\n    double x = X0;\\n    double *y = &(Y0[0]);\\n    printf(\\\"Finding exact solution\\\\n\\\");\\n    clock_t t1 = clock();\\n\\n    do\\n    {\\n        fprintf(fp, \\\"%.4g,%.4g,%.4g\\\\n\\\", x, y[0], y[1]);  // write to file\\n        exact_solution(&x, y);\\n        x += step_size;\\n    } while (x <= X_MAX);\\n\\n    clock_t t2 = clock();\\n    total_time = (t2 - t1) / CLOCKS_PER_SEC;\\n    printf(\\\"\\\\tTime = %.6g ms\\\\n\\\", total_time);\\n    fclose(fp);\\n\\n    return 0;\\n}\\n\"",
    "qr decompose": "\"/**\\n * @file\\n * \\\\brief Library functions to compute [QR\\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given\\n * matrix.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n\\n#ifndef QR_DECOMPOSE_H\\n#define QR_DECOMPOSE_H\\n\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#ifdef _OPENMP\\n#include <omp.h>\\n#endif\\n\\n/**\\n * function to display matrix on stdout\\n */\\nvoid print_matrix(double **A, /**< matrix to print */\\n                  int M,      /**< number of rows of matrix */\\n                  int N)      /**< number of columns of matrix */\\n{\\n    for (int row = 0; row < M; row++)\\n    {\\n        for (int col = 0; col < N; col++) printf(\\\"% 9.3g\\\\t\\\", A[row][col]);\\n        putchar('\\\\n');\\n    }\\n    putchar('\\\\n');\\n}\\n\\n/**\\n * Compute dot product of two vectors of equal lengths\\n *\\n * If \\\\f$\\\\vec{a}=\\\\left[a_0,a_1,a_2,...,a_L\\\\right]\\\\f$ and\\n * \\\\f$\\\\vec{b}=\\\\left[b_0,b_1,b_1,...,b_L\\\\right]\\\\f$ then\\n * \\\\f$\\\\vec{a}\\\\cdot\\\\vec{b}=\\\\displaystyle\\\\sum_{i=0}^L a_i\\\\times b_i\\\\f$\\n *\\n * \\\\returns \\\\f$\\\\vec{a}\\\\cdot\\\\vec{b}\\\\f$\\n */\\ndouble vector_dot(double *a, double *b, int L)\\n{\\n    double mag = 0.f;\\n    int i;\\n#ifdef _OPENMP\\n// parallelize on threads\\n#pragma omp parallel for reduction(+ : mag)\\n#endif\\n    for (i = 0; i < L; i++) mag += a[i] * b[i];\\n\\n    return mag;\\n}\\n\\n/**\\n * Compute magnitude of vector.\\n *\\n * If \\\\f$\\\\vec{a}=\\\\left[a_0,a_1,a_2,...,a_L\\\\right]\\\\f$ then\\n * \\\\f$\\\\left|\\\\vec{a}\\\\right|=\\\\sqrt{\\\\displaystyle\\\\sum_{i=0}^L a_i^2}\\\\f$\\n *\\n * \\\\returns \\\\f$\\\\left|\\\\vec{a}\\\\right|\\\\f$\\n */\\ndouble vector_mag(double *vector, int L)\\n{\\n    double dot = vector_dot(vector, vector, L);\\n    return sqrt(dot);\\n}\\n\\n/**\\n * Compute projection of vector \\\\f$\\\\vec{a}\\\\f$ on \\\\f$\\\\vec{b}\\\\f$ defined as\\n * \\\\f[\\\\text{proj}_\\\\vec{b}\\\\vec{a}=\\\\frac{\\\\vec{a}\\\\cdot\\\\vec{b}}{\\\\left|\\\\vec{b}\\\\right|^2}\\\\vec{b}\\\\f]\\n *\\n * \\\\returns NULL if error, otherwise pointer to output\\n */\\ndouble *vector_proj(double *a, double *b, double *out, int L)\\n{\\n    const double num = vector_dot(a, b, L);\\n    const double deno = vector_dot(b, b, L);\\n    if (deno == 0) /*! check for division by zero */\\n        return NULL;\\n\\n    const double scalar = num / deno;\\n    int i;\\n#ifdef _OPENMP\\n// parallelize on threads\\n#pragma omp for\\n#endif\\n    for (i = 0; i < L; i++) out[i] = scalar * b[i];\\n\\n    return out;\\n}\\n\\n/**\\n * Compute vector subtraction\\n *\\n * \\\\f$\\\\vec{c}=\\\\vec{a}-\\\\vec{b}\\\\f$\\n *\\n * \\\\returns pointer to output vector\\n */\\ndouble *vector_sub(double *a,   /**< minuend */\\n                   double *b,   /**< subtrahend */\\n                   double *out, /**< resultant vector */\\n                   int L        /**< length of vectors */\\n)\\n{\\n    int i;\\n#ifdef _OPENMP\\n// parallelize on threads\\n#pragma omp for\\n#endif\\n    for (i = 0; i < L; i++) out[i] = a[i] - b[i];\\n\\n    return out;\\n}\\n\\n/**\\n * Decompose matrix \\\\f$A\\\\f$ using [Gram-Schmidt\\n *process](https://en.wikipedia.org/wiki/QR_decomposition).\\n *\\n * \\\\f{eqnarray*}{\\n * \\\\text{given that}\\\\quad A &=&\\n *\\\\left[\\\\mathbf{a}_1,\\\\mathbf{a}_2,\\\\ldots,\\\\mathbf{a}_{N-1},\\\\right]\\\\\\\\\\n * \\\\text{where}\\\\quad\\\\mathbf{a}_i &=&\\n *\\\\left[a_{0i},a_{1i},a_{2i},\\\\ldots,a_{(M-1)i}\\\\right]^T\\\\quad\\\\ldots\\\\mbox{(column\\n *vectors)}\\\\\\\\\\n * \\\\text{then}\\\\quad\\\\mathbf{u}_i &=& \\\\mathbf{a}_i\\n *-\\\\sum_{j=0}^{i-1}\\\\text{proj}_{\\\\mathbf{u}_j}\\\\mathbf{a}_i\\\\\\\\\\n * \\\\mathbf{e}_i &=&\\\\frac{\\\\mathbf{u}_i}{\\\\left|\\\\mathbf{u}_i\\\\right|}\\\\\\\\\\n * Q &=& \\\\begin{bmatrix}\\\\mathbf{e}_0 & \\\\mathbf{e}_1 & \\\\mathbf{e}_2 & \\\\dots &\\n *\\\\mathbf{e}_{N-1}\\\\end{bmatrix}\\\\\\\\\\n * R &=& \\\\begin{bmatrix}\\\\langle\\\\mathbf{e}_0\\\\,,\\\\mathbf{a}_0\\\\rangle &\\n *\\\\langle\\\\mathbf{e}_1\\\\,,\\\\mathbf{a}_1\\\\rangle &\\n *\\\\langle\\\\mathbf{e}_2\\\\,,\\\\mathbf{a}_2\\\\rangle & \\\\dots \\\\\\\\\\n *                  0 & \\\\langle\\\\mathbf{e}_1\\\\,,\\\\mathbf{a}_1\\\\rangle &\\n *\\\\langle\\\\mathbf{e}_2\\\\,,\\\\mathbf{a}_2\\\\rangle & \\\\dots\\\\\\\\\\n *                  0 & 0 & \\\\langle\\\\mathbf{e}_2\\\\,,\\\\mathbf{a}_2\\\\rangle & \\\\dots\\\\\\\\\\n *                  \\\\vdots & \\\\vdots & \\\\vdots & \\\\ddots\\n *      \\\\end{bmatrix}\\\\\\\\\\n * \\\\f}\\n */\\nvoid qr_decompose(double **A, /**< input matrix to decompose */\\n                  double **Q, /**< output decomposed matrix */\\n                  double **R, /**< output decomposed matrix */\\n                  int M,      /**< number of rows of matrix A */\\n                  int N       /**< number of columns of matrix A */\\n)\\n{\\n    double *col_vector = (double *)malloc(M * sizeof(double));\\n    double *col_vector2 = (double *)malloc(M * sizeof(double));\\n    double *tmp_vector = (double *)malloc(M * sizeof(double));\\n    for (int i = 0; i < N;\\n         i++) /* for each column => R is a square matrix of NxN */\\n    {\\n        int j;\\n#ifdef _OPENMP\\n// parallelize on threads\\n#pragma omp for\\n#endif\\n        for (j = 0; j < i; j++) /* second dimension of column */\\n            R[i][j] = 0.;       /* make R upper triangular */\\n\\n            /* get corresponding Q vector */\\n#ifdef _OPENMP\\n// parallelize on threads\\n#pragma omp for\\n#endif\\n        for (j = 0; j < M; j++)\\n        {\\n            tmp_vector[j] = A[j][i]; /* accumulator for uk */\\n            col_vector[j] = A[j][i];\\n        }\\n        for (j = 0; j < i; j++)\\n        {\\n            for (int k = 0; k < M; k++) col_vector2[k] = Q[k][j];\\n            vector_proj(col_vector, col_vector2, col_vector2, M);\\n            vector_sub(tmp_vector, col_vector2, tmp_vector, M);\\n        }\\n        double mag = vector_mag(tmp_vector, M);\\n\\n#ifdef _OPENMP\\n// parallelize on threads\\n#pragma omp for\\n#endif\\n        for (j = 0; j < M; j++) Q[j][i] = tmp_vector[j] / mag;\\n\\n        /* compute upper triangular values of R */\\n        for (int kk = 0; kk < M; kk++) col_vector[kk] = Q[kk][i];\\n        for (int k = i; k < N; k++)\\n        {\\n            for (int kk = 0; kk < M; kk++) col_vector2[kk] = A[kk][k];\\n            R[i][k] = vector_dot(col_vector, col_vector2, M);\\n        }\\n    }\\n\\n    free(col_vector);\\n    free(col_vector2);\\n    free(tmp_vector);\\n}\\n\\n#endif  // QR_DECOMPOSE_H\\n\"",
    "qr decomposition": "\"/**\\n * @file\\n * \\\\brief Program to compute the [QR\\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given\\n * matrix.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include \\\"qr_decompose.h\\\"\\n\\n/**\\n * main function\\n */\\nint main(void)\\n{\\n    double **A;\\n    unsigned int ROWS, COLUMNS;\\n\\n    printf(\\\"Enter the number of rows and columns: \\\");\\n    scanf(\\\"%u %u\\\", &ROWS, &COLUMNS);\\n    if (ROWS < COLUMNS)\\n    {\\n        fprintf(stderr,\\n                \\\"Number of rows must be greater than or equal to \\\"\\n                \\\"number of columns.\\\\n\\\");\\n        return -1;\\n    }\\n\\n    printf(\\\"Enter matrix elements row-wise:\\\\n\\\");\\n\\n    A = (double **)malloc(ROWS * sizeof(double *));\\n    for (int i = 0; i < ROWS; i++)\\n        A[i] = (double *)malloc(COLUMNS * sizeof(double));\\n\\n    for (int i = 0; i < ROWS; i++)\\n        for (int j = 0; j < COLUMNS; j++) scanf(\\\"%lf\\\", &A[i][j]);\\n\\n    print_matrix(A, ROWS, COLUMNS);\\n\\n    double **R = (double **)malloc(sizeof(double *) * ROWS);\\n    double **Q = (double **)malloc(sizeof(double *) * ROWS);\\n    if (!Q || !R)\\n    {\\n        perror(\\\"Unable to allocate memory for Q & R!\\\");\\n        return -1;\\n    }\\n    for (int i = 0; i < ROWS; i++)\\n    {\\n        R[i] = (double *)malloc(sizeof(double) * COLUMNS);\\n        Q[i] = (double *)malloc(sizeof(double) * ROWS);\\n        if (!Q[i] || !R[i])\\n        {\\n            perror(\\\"Unable to allocate memory for Q & R.\\\");\\n            return -1;\\n        }\\n    }\\n\\n    clock_t t1 = clock();\\n    qr_decompose(A, Q, R, ROWS, COLUMNS);\\n    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;\\n\\n    print_matrix(R, ROWS, COLUMNS);\\n    print_matrix(Q, ROWS, COLUMNS);\\n    printf(\\\"Time taken to compute: %.4g sec\\\\n\\\", dtime);\\n\\n    for (int i = 0; i < ROWS; i++)\\n    {\\n        free(A[i]);\\n        free(R[i]);\\n        free(Q[i]);\\n    }\\n    free(A);\\n    free(R);\\n    free(Q);\\n    return 0;\\n}\\n\"",
    "qr eigen values": "\"/**\\n * @file\\n * \\\\brief Compute real eigen values and eigen vectors of a symmetric matrix\\n * using [QR decomposition](https://en.wikipedia.org/wiki/QR_decomposition)\\n * method.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#include <assert.h>\\n#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n#include \\\"qr_decompose.h\\\"\\n#ifdef _OPENMP\\n#include <omp.h>\\n#endif\\n\\n#define LIMS 9        /**< limit of range of matrix values */\\n#define EPSILON 1e-10 /**< accuracy tolerance limit */\\n\\n/**\\n * create a square matrix of given size with random elements\\n * \\\\param[out] A matrix to create (must be pre-allocated in memory)\\n * \\\\param[in] N matrix size\\n */\\nvoid create_matrix(double **A, int N)\\n{\\n    int i, j, tmp, lim2 = LIMS >> 1;\\n\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < N; i++)\\n    {\\n        A[i][i] = (rand() % LIMS) - lim2;\\n        for (j = i + 1; j < N; j++)\\n        {\\n            tmp = (rand() % LIMS) - lim2;\\n            A[i][j] = tmp;\\n            A[j][i] = tmp;\\n        }\\n    }\\n}\\n\\n/**\\n * Perform multiplication of two matrices.\\n * * R2 must be equal to C1\\n * * Resultant matrix size should be R1xC2\\n * \\\\param[in] A first matrix to multiply\\n * \\\\param[in] B second matrix to multiply\\n * \\\\param[out] OUT output matrix (must be pre-allocated)\\n * \\\\param[in] R1 number of rows of first matrix\\n * \\\\param[in] C1 number of columns of first matrix\\n * \\\\param[in] R2 number of rows of second matrix\\n * \\\\param[in] C2 number of columns of second matrix\\n * \\\\returns pointer to resultant matrix\\n */\\ndouble **mat_mul(double **A, double **B, double **OUT, int R1, int C1, int R2,\\n                 int C2)\\n{\\n    if (C1 != R2)\\n    {\\n        perror(\\\"Matrix dimensions mismatch!\\\");\\n        return OUT;\\n    }\\n\\n    int i;\\n#ifdef _OPENMP\\n#pragma omp for\\n#endif\\n    for (i = 0; i < R1; i++)\\n    {\\n        for (int j = 0; j < C2; j++)\\n        {\\n            OUT[i][j] = 0.f;\\n            for (int k = 0; k < C1; k++) OUT[i][j] += A[i][k] * B[k][j];\\n        }\\n    }\\n    return OUT;\\n}\\n\\n/** Compute eigen values using iterative shifted QR decomposition algorithm as\\n * follows:\\n * 1. Use last diagonal element of A as eigen value approximation \\\\f$c\\\\f$\\n * 2. Shift diagonals of matrix \\\\f$A' = A - cI\\\\f$\\n * 3. Decompose matrix \\\\f$A'=QR\\\\f$\\n * 4. Compute next approximation \\\\f$A'_1 = RQ \\\\f$\\n * 5. Shift diagonals back \\\\f$A_1 = A'_1 + cI\\\\f$\\n * 6. Termination condition check: last element below diagonal is almost 0\\n *   1. If not 0, go back to step 1 with the new approximation \\\\f$A_1\\\\f$\\n *   2. If 0, continue to step 7\\n * 7. Save last known \\\\f$c\\\\f$ as the eigen value.\\n * 8. Are all eigen values found?\\n *   1. If not, remove last row and column of \\\\f$A_1\\\\f$ and go back to step 1.\\n *   2. If yes, stop.\\n *\\n * \\\\note The matrix \\\\f$A\\\\f$ gets modified\\n *\\n * \\\\param[in,out] A matrix to compute eigen values for\\n * \\\\param[out] eigen_vals resultant vector containing computed eigen values\\n * \\\\param[in] mat_size matrix size\\n * \\\\param[in] debug_print 1 to print intermediate Q & R matrices, 0 for not to\\n * \\\\returns time for computation in seconds\\n */\\ndouble eigen_values(double **A, double *eigen_vals, int mat_size,\\n                    char debug_print)\\n{\\n    if (!eigen_vals)\\n    {\\n        perror(\\\"Output eigen value vector cannot be NULL!\\\");\\n        return -1;\\n    }\\n    double **R = (double **)malloc(sizeof(double *) * mat_size);\\n    double **Q = (double **)malloc(sizeof(double *) * mat_size);\\n    if (!Q || !R)\\n    {\\n        perror(\\\"Unable to allocate memory for Q & R!\\\");\\n        if (Q)\\n        {\\n            free(Q);\\n        }\\n        if (R)\\n        {\\n            free(R);\\n        }\\n        return -1;\\n    }\\n\\n    /* allocate dynamic memory for matrices */\\n    for (int i = 0; i < mat_size; i++)\\n    {\\n        R[i] = (double *)malloc(sizeof(double) * mat_size);\\n        Q[i] = (double *)malloc(sizeof(double) * mat_size);\\n        if (!Q[i] || !R[i])\\n        {\\n            perror(\\\"Unable to allocate memory for Q & R.\\\");\\n            for (; i >= 0; i--)\\n            {\\n                free(R[i]);\\n                free(Q[i]);\\n            }\\n            free(Q);\\n            free(R);\\n            return -1;\\n        }\\n    }\\n\\n    if (debug_print)\\n    {\\n        print_matrix(A, mat_size, mat_size);\\n    }\\n\\n    int rows = mat_size, columns = mat_size;\\n    int counter = 0, num_eigs = rows - 1;\\n    double last_eig = 0;\\n\\n    clock_t t1 = clock();\\n    while (num_eigs > 0) /* continue till all eigen values are found */\\n    {\\n        /* iterate with QR decomposition */\\n        while (fabs(A[num_eigs][num_eigs - 1]) > EPSILON)\\n        {\\n            last_eig = A[num_eigs][num_eigs];\\n            for (int i = 0; i < rows; i++) A[i][i] -= last_eig; /* A - cI */\\n            qr_decompose(A, Q, R, rows, columns);\\n\\n            if (debug_print)\\n            {\\n                print_matrix(A, rows, columns);\\n                print_matrix(Q, rows, columns);\\n                print_matrix(R, columns, columns);\\n                printf(\\\"-------------------- %d ---------------------\\\\n\\\",\\n                       ++counter);\\n            }\\n\\n            mat_mul(R, Q, A, columns, columns, rows, columns);\\n            for (int i = 0; i < rows; i++) A[i][i] += last_eig; /* A + cI */\\n        }\\n\\n        /* store the converged eigen value */\\n        eigen_vals[num_eigs] = last_eig;\\n\\n        if (debug_print)\\n        {\\n            printf(\\\"========================\\\\n\\\");\\n            printf(\\\"Eigen value: % g,\\\\n\\\", last_eig);\\n            printf(\\\"========================\\\\n\\\");\\n        }\\n\\n        num_eigs--;\\n        rows--;\\n        columns--;\\n    }\\n    eigen_vals[0] = A[0][0];\\n    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;\\n\\n    if (debug_print)\\n    {\\n        print_matrix(R, mat_size, mat_size);\\n        print_matrix(Q, mat_size, mat_size);\\n    }\\n\\n    /* cleanup dynamic memory */\\n    for (int i = 0; i < mat_size; i++)\\n    {\\n        free(R[i]);\\n        free(Q[i]);\\n    }\\n    free(R);\\n    free(Q);\\n\\n    return dtime;\\n}\\n\\n/**\\n * test function to compute eigen values of a 2x2 matrix\\n * \\\\f[\\\\begin{bmatrix}\\n * 5 & 7\\\\\\\\\\n * 7 & 11\\n * \\\\end{bmatrix}\\\\f]\\n * which are approximately, {15.56158, 0.384227}\\n */\\nvoid test1()\\n{\\n    int mat_size = 2;\\n    double X[][2] = {{5, 7}, {7, 11}};\\n    double y[] = {15.56158, 0.384227};  // corresponding y-values\\n    double eig_vals[2] = {0, 0};\\n\\n    // The following steps are to convert a \\\"double[][]\\\" to \\\"double **\\\"\\n    double **A = (double **)malloc(mat_size * sizeof(double *));\\n    for (int i = 0; i < mat_size; i++) A[i] = X[i];\\n\\n    printf(\\\"------- Test 1 -------\\\\n\\\");\\n\\n    double dtime = eigen_values(A, eig_vals, mat_size, 0);\\n\\n    for (int i = 0; i < mat_size; i++)\\n    {\\n        printf(\\\"%d/5 Checking for %.3g --> \\\", i + 1, y[i]);\\n        char result = 0;\\n        for (int j = 0; j < mat_size && !result; j++)\\n        {\\n            if (fabs(y[i] - eig_vals[j]) < 0.1)\\n            {\\n                result = 1;\\n                printf(\\\"(%.3g) \\\", eig_vals[j]);\\n            }\\n        }\\n\\n        // ensure that i^th expected eigen value was computed\\n        assert(result != 0);\\n        printf(\\\"found\\\\n\\\");\\n    }\\n    printf(\\\"Test 1 Passed in %.3g sec\\\\n\\\\n\\\", dtime);\\n    free(A);\\n}\\n\\n/**\\n * test function to compute eigen values of a 2x2 matrix\\n * \\\\f[\\\\begin{bmatrix}\\n * -4& 4& 2& 0& -3\\\\\\\\\\n * 4& -4& 4& -3& -1\\\\\\\\\\n * 2& 4& 4& 3& -3\\\\\\\\\\n * 0& -3& 3& -1&-1\\\\\\\\\\n * -3& -1& -3& -3& 0\\n * \\\\end{bmatrix}\\\\f]\\n * which are approximately, {9.27648, -9.26948, 2.0181, -1.03516, -5.98994}\\n */\\nvoid test2()\\n{\\n    int mat_size = 5;\\n    double X[][5] = {{-4, 4, 2, 0, -3},\\n                     {4, -4, 4, -3, -1},\\n                     {2, 4, 4, 3, -3},\\n                     {0, -3, 3, -1, -3},\\n                     {-3, -1, -3, -3, 0}};\\n    double y[] = {9.27648, -9.26948, 2.0181, -1.03516,\\n                  -5.98994};  // corresponding y-values\\n    double eig_vals[5];\\n\\n    // The following steps are to convert a \\\"double[][]\\\" to \\\"double **\\\"\\n    double **A = (double **)malloc(mat_size * sizeof(double *));\\n    for (int i = 0; i < mat_size; i++) A[i] = X[i];\\n\\n    printf(\\\"------- Test 2 -------\\\\n\\\");\\n\\n    double dtime = eigen_values(A, eig_vals, mat_size, 0);\\n\\n    for (int i = 0; i < mat_size; i++)\\n    {\\n        printf(\\\"%d/5 Checking for %.3g --> \\\", i + 1, y[i]);\\n        char result = 0;\\n        for (int j = 0; j < mat_size && !result; j++)\\n        {\\n            if (fabs(y[i] - eig_vals[j]) < 0.1)\\n            {\\n                result = 1;\\n                printf(\\\"(%.3g) \\\", eig_vals[j]);\\n            }\\n        }\\n\\n        // ensure that i^th expected eigen value was computed\\n        assert(result != 0);\\n        printf(\\\"found\\\\n\\\");\\n    }\\n    printf(\\\"Test 2 Passed in %.3g sec\\\\n\\\\n\\\", dtime);\\n    free(A);\\n}\\n\\n/**\\n * main function\\n */\\nint main(int argc, char **argv)\\n{\\n    srand(time(NULL));\\n\\n    int mat_size = 5;\\n    if (argc == 2)\\n    {\\n        mat_size = atoi(argv[1]);\\n    }\\n    else\\n    {  // if invalid input argument is given run tests\\n        test1();\\n        test2();\\n        printf(\\\"Usage: ./qr_eigen_values [mat_size]\\\\n\\\");\\n        return 0;\\n    }\\n\\n    if (mat_size < 2)\\n    {\\n        fprintf(stderr, \\\"Matrix size should be > 2\\\\n\\\");\\n        return -1;\\n    }\\n\\n    int i;\\n\\n    double **A = (double **)malloc(sizeof(double *) * mat_size);\\n    /* number of eigen values = matrix size */\\n    double *eigen_vals = (double *)malloc(sizeof(double) * mat_size);\\n    if (!eigen_vals)\\n    {\\n        perror(\\\"Unable to allocate memory for eigen values!\\\");\\n        free(A);\\n        return -1;\\n    }\\n    for (i = 0; i < mat_size; i++)\\n    {\\n        A[i] = (double *)malloc(sizeof(double) * mat_size);\\n        eigen_vals[i] = 0.f;\\n    }\\n\\n    /* create a random matrix */\\n    create_matrix(A, mat_size);\\n\\n    print_matrix(A, mat_size, mat_size);\\n\\n    double dtime = eigen_values(A, eigen_vals, mat_size, 0);\\n    printf(\\\"Eigen vals: \\\");\\n    for (i = 0; i < mat_size; i++) printf(\\\"% 9.4g\\\\t\\\", eigen_vals[i]);\\n    printf(\\\"\\\\nTime taken to compute: % .4g sec\\\\n\\\", dtime);\\n\\n    for (int i = 0; i < mat_size; i++) free(A[i]);\\n    free(A);\\n    free(eigen_vals);\\n    return 0;\\n}\\n\"",
    "realtime stats": "\"/**\\n * \\\\file\\n * \\\\brief Compute statistics for data entered in rreal-time\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n *\\n * This algorithm is really beneficial to compute statistics on data read in\\n * realtime. For example, devices reading biometrics data. The algorithm is\\n * simple enough to be easily implemented in an embedded system.\\n */\\n#include <assert.h>\\n#include <math.h>\\n#include <stdio.h>\\n\\n/**\\n * continuous mean and variance computance using\\n * first value as an approximation for the mean.\\n * If the first number is much far form the mean, the algorithm becomes very\\n * inaccurate to compute variance and standard deviation.\\n * \\\\param[in] x new value added to data set\\n * \\\\param[out] mean if not NULL, mean returns mean of data set\\n * \\\\param[out] variance if not NULL, mean returns variance of data set\\n * \\\\param[out] std if not NULL, mean returns standard deviation of data set\\n */\\nvoid stats_computer1(float x, float *mean, float *variance, float *std)\\n{\\n    /* following variables declared static becuase they need to be remembered\\n     * when updating for next sample, when received.\\n     */\\n    static unsigned int n = 0;\\n    static float Ex = 0.f, Ex2 = 0.f;\\n    static float K = 0.f;\\n\\n    if (n == 0)\\n        K = x;\\n    n++;\\n    float tmp = x - K;\\n    Ex += tmp;\\n    Ex2 += tmp * tmp;\\n\\n    /* return sample mean computed till last sample */\\n    if (mean != NULL)\\n        *mean = K + Ex / n;\\n\\n    /* return data variance computed till last sample */\\n    if (variance != NULL)\\n        *variance = (Ex2 - (Ex * Ex) / n) / (n - 1);\\n\\n    /* return sample standard deviation computed till last sample */\\n    if (std != NULL)\\n        *std = sqrtf(*variance);\\n}\\n\\n/**\\n * continuous mean and variance computance using\\n * Welford's algorithm  (very accurate)\\n * \\\\param[in] x new value added to data set\\n * \\\\param[out] mean if not NULL, mean returns mean of data set\\n * \\\\param[out] variance if not NULL, mean returns variance of data set\\n * \\\\param[out] std if not NULL, mean returns standard deviation of data set\\n */\\nvoid stats_computer2(float x, float *mean, float *variance, float *std)\\n{\\n    /* following variables declared static becuase they need to be remembered\\n     * when updating for next sample, when received.\\n     */\\n    static unsigned int n = 0;\\n    static float mu = 0, M = 0;\\n\\n    n++;\\n    float delta = x - mu;\\n    mu += delta / n;\\n    float delta2 = x - mu;\\n    M += delta * delta2;\\n\\n    /* return sample mean computed till last sample */\\n    if (mean != NULL)\\n        *mean = mu;\\n\\n    /* return data variance computed till last sample */\\n    if (variance != NULL)\\n        *variance = M / n;\\n\\n    /* return sample standard deviation computed till last sample */\\n    if (std != NULL)\\n        *std = sqrtf(*variance);\\n}\\n\\n/** Test the algorithm implementation\\n * \\\\param[in] test_data array of data to test the algorithms\\n * \\\\param[in] number_of_samples number of samples of data\\n */\\nvoid test_function(const float *test_data, const int number_of_samples)\\n{\\n    float ref_mean = 0.f, ref_variance = 0.f;\\n    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;\\n    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;\\n\\n    for (int i = 0; i < number_of_samples; i++)\\n    {\\n        stats_computer1(test_data[i], &s1_mean, &s1_variance, &s1_std);\\n        stats_computer2(test_data[i], &s2_mean, &s2_variance, &s2_std);\\n        ref_mean += test_data[i];\\n    }\\n    ref_mean /= number_of_samples;\\n\\n    for (int i = 0; i < number_of_samples; i++)\\n    {\\n        float temp = test_data[i] - ref_mean;\\n        ref_variance += temp * temp;\\n    }\\n    ref_variance /= number_of_samples;\\n\\n    printf(\\\"<<<<<<<< Test Function >>>>>>>>\\\\n\\\");\\n    printf(\\\"Expected: Mean: %.4f\\\\t Variance: %.4f\\\\n\\\", ref_mean, ref_variance);\\n    printf(\\\"\\\\tMethod 1:\\\\tMean: %.4f\\\\t Variance: %.4f\\\\t Std: %.4f\\\\n\\\", s1_mean,\\n           s1_variance, s1_std);\\n    printf(\\\"\\\\tMethod 2:\\\\tMean: %.4f\\\\t Variance: %.4f\\\\t Std: %.4f\\\\n\\\", s2_mean,\\n           s2_variance, s2_std);\\n\\n    assert(fabs(s1_mean - ref_mean) < 0.01);\\n    assert(fabs(s2_mean - ref_mean) < 0.01);\\n    assert(fabs(s2_variance - ref_variance) < 0.01);\\n\\n    printf(\\\"(Tests passed)\\\\n\\\\n\\\");\\n}\\n\\n/** Main function */\\nint main(int argc, char **argv)\\n{\\n    const float test_data1[] = {3, 4, 5, -1.4, -3.6, 1.9, 1.};\\n    test_function(test_data1, sizeof(test_data1) / sizeof(test_data1[0]));\\n\\n    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;\\n    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;\\n\\n    printf(\\\"Enter data. Any non-numeric data will terminate the data input.\\\\n\\\");\\n\\n    while (1)\\n    {\\n        float val;\\n        printf(\\\"Enter number: \\\");\\n\\n        // check for failure to read input. Happens for\\n        // non-numeric data\\n        if (!scanf(\\\"%f\\\", &val))\\n            break;\\n\\n        stats_computer1(val, &s1_mean, &s1_variance, &s1_std);\\n        stats_computer2(val, &s2_mean, &s2_variance, &s2_std);\\n\\n        printf(\\\"\\\\tMethod 1:\\\\tMean: %.4f\\\\t Variance: %.4f\\\\t Std: %.4f\\\\n\\\",\\n               s1_mean, s1_variance, s1_std);\\n        printf(\\\"\\\\tMethod 2:\\\\tMean: %.4f\\\\t Variance: %.4f\\\\t Std: %.4f\\\\n\\\",\\n               s2_mean, s2_variance, s2_std);\\n    }\\n\\n    return 0;\\n}\\n\"",
    "simpsons 1 3rd rule": "\"#include <math.h>\\n#include <stdio.h>\\n\\nfloat f(float x)\\n{\\n    return 1.0 +\\n           x * x * x;  // This is the expresion of the function to integrate?\\n}\\n\\nint main()\\n{\\n    int i, n;\\n    float a, b, h, x, s2, s3, sum, integral;\\n\\n    printf(\\\"enter the lower limit of the integration:\\\");\\n    scanf(\\\"%f\\\", &a);\\n    printf(\\\"enter the upper limit of the integration:\\\");\\n    scanf(\\\"%f\\\", &b);\\n    printf(\\\"enter the number of intervals:\\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    h = (b - a) / n;\\n    sum = f(a) + f(b);\\n    s2 = s3 = 0.0;\\n\\n    for (i = 1; i < n; i += 3)\\n    {\\n        x = a + i * h;\\n        s3 = s3 + f(x) + f(x + h);\\n    }\\n\\n    for (i = 3; i < n; i += 3)\\n    {\\n        x = a + i * h;\\n        s2 = s2 + f(x);\\n    }\\n\\n    integral = (h / 3.0) * (sum + 2 * s2 + 4 * s3);\\n    printf(\\\"\\\\nValue of the integral = %9.4f\\\\n\\\", integral);\\n\\n    return 0;\\n}\"",
    "variance": "\"#include <math.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main()\\n{\\n    int *ARRAY = NULL, ARRAY_LENGTH, i, TEMPORARY_ELEMENT, isSorted = 0;\\n    float MEAN = 0, VARIANCE = 0, STAND;\\n\\n    printf(\\\"Enter no. for Random Numbers :\\\");\\n    scanf(\\\"%d\\\", &ARRAY_LENGTH);\\n    ARRAY = (int *)realloc(\\n        ARRAY,\\n        ARRAY_LENGTH * (sizeof(int)));  // We allocate the dedicated memory\\n    for (i = 0; i < ARRAY_LENGTH; i++)  // We generate the random numbers\\n        ARRAY[i] = rand() % 100;\\n\\n    printf(\\\"Random Numbers Generated are :\\\\n\\\");  // We display them\\n    for (i = 0; i < ARRAY_LENGTH; i++) printf(\\\"%d \\\", ARRAY[i]);\\n\\n    printf(\\\"\\\\nSorted Data: \\\");  // Then we sort it using Bubble Sort..\\n\\n    while (!isSorted)\\n    {                  // While our array's not sorted\\n        isSorted = 1;  // we suppose that it's sorted\\n        for (i = 0; i < ARRAY_LENGTH - 1; i++)\\n        {  // then for each element of the array\\n            if (ARRAY[i] > ARRAY[i + 1])\\n            {                  // if the two elements aren't sorted\\n                isSorted = 0;  // it means that the array is not sorted\\n                TEMPORARY_ELEMENT = ARRAY[i];  // and we switch these elements\\n                                               // using TEMPORARY_ELEMENT\\n                ARRAY[i] = ARRAY[i + 1];\\n                ARRAY[i + 1] = TEMPORARY_ELEMENT;\\n            }\\n        }\\n    }\\n    for (i = 0; i < ARRAY_LENGTH; i++)\\n    {\\n        printf(\\\"%d \\\", ARRAY[i]);\\n        MEAN = MEAN + ARRAY[i];\\n    }\\n    MEAN = MEAN / (float)ARRAY_LENGTH;\\n\\n    for (i = 0; i < ARRAY_LENGTH; i++)\\n        VARIANCE = VARIANCE + (pow((ARRAY[i] - MEAN), 2));\\n\\n    VARIANCE = VARIANCE / (float)ARRAY_LENGTH;\\n    STAND = sqrt(VARIANCE);\\n\\n    printf(\\\"\\\\n\\\\n- Mean is: %f\\\\n\\\", MEAN);\\n    printf(\\\"- Variance is: %f\\\\n\\\", VARIANCE);\\n    printf(\\\"- Standard Deviation is: %f\\\\n\\\", STAND);\\n}\\n\"",
    "binary search": "\"/**\\n * @file\\n * @brief Program to perform [binary\\n * search](https://en.wikipedia.org/wiki/Binary_search_algorithm) of a target\\n * value in a given *sorted* array.\\n * @authors [James McDermott](https://github.com/theycallmemac) - recursive\\n * algorithm\\n * @authors [Krishna Vedala](https://github.com/kvedala) - iterative algorithm\\n */\\n#include <assert.h>\\n#include <stdio.h>\\n\\n/** Recursive implementation\\n * \\\\param[in] arr array to search\\n * \\\\param l left index of search range\\n * \\\\param r right index of search range\\n * \\\\param x target value to search for\\n * \\\\returns location of x assuming array arr[l..r] is present\\n * \\\\returns -1 otherwise\\n */\\nint binarysearch1(const int *arr, int l, int r, int x)\\n{\\n    if (r >= l)\\n    {\\n        int mid = l + (r - l) / 2;\\n\\n        // If element is present at middle\\n        if (arr[mid] == x)\\n            return mid;\\n\\n        // If element is smaller than middle\\n        if (arr[mid] > x)\\n            return binarysearch1(arr, l, mid - 1, x);\\n\\n        // Else element is in right subarray\\n        return binarysearch1(arr, mid + 1, r, x);\\n    }\\n\\n    // When element is not present in array\\n    return -1;\\n}\\n\\n/** Iterative implementation\\n * \\\\param[in] arr array to search\\n * \\\\param l left index of search range\\n * \\\\param r right index of search range\\n * \\\\param x target value to search for\\n * \\\\returns location of x assuming array arr[l..r] is present\\n * \\\\returns -1 otherwise\\n */\\nint binarysearch2(const int *arr, int l, int r, int x)\\n{\\n    int mid = l + (r - l) / 2;\\n\\n    while (arr[mid] != x)\\n    {\\n        if (r <= l || r < 0)\\n            return -1;\\n\\n        if (arr[mid] > x)\\n            // If element is smaller than middle\\n            r = mid - 1;\\n        else\\n            // Else element is in right subarray\\n            l = mid + 1;\\n\\n        mid = l + (r - l) / 2;\\n    }\\n\\n    // When element is not present in array\\n    return mid;\\n}\\n\\n/** Test implementations */\\nvoid test()\\n{\\n    // give function an array to work with\\n    int arr[] = {2, 3, 4, 10, 40};\\n    // get size of array\\n    int n = sizeof(arr) / sizeof(arr[0]);\\n\\n    printf(\\\"Test 1.... \\\");\\n    // set value to look for\\n    int x = 10;\\n    // set result to what is returned from binarysearch\\n    int result = binarysearch1(arr, 0, n - 1, x);\\n    assert(result == 3);\\n    printf(\\\"passed recursive... \\\");\\n    result = binarysearch2(arr, 0, n - 1, x);\\n    assert(result == 3);\\n    printf(\\\"passed iterative...\\\\n\\\");\\n\\n    printf(\\\"Test 2.... \\\");\\n    x = 5;\\n    // set result to what is returned from binarysearch\\n    result = binarysearch1(arr, 0, n - 1, x);\\n    assert(result == -1);\\n    printf(\\\"passed recursive... \\\");\\n    result = binarysearch2(arr, 0, n - 1, x);\\n    assert(result == -1);\\n    printf(\\\"passed iterative...\\\\n\\\");\\n}\\n\\n/** Main function */\\nint main(void)\\n{\\n    test();\\n    return 0;\\n}\\n\"",
    "exponential search": "\"/**\\n *  \\\\file\\n *  \\\\brief [Exponential Search](https://github.com/TheAlgorithms/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Exponential%20Search.md)\\n *  \\\\author [Alessio Farinelli](https://github.com/faridevnz)\\n */\\n#include <assert.h>  /// for assert\\n#include <inttypes.h>  /// for int64_t, uint16_t\\n\\n#define ELEMENT -10\\n\\nint64_t binary_search(const int64_t* arr, const uint16_t l_index, const uint16_t r_index, const int64_t n); ///< used to perform the binary search over the given array\\nint64_t exponential_search(const int64_t* arr, const uint16_t length, const int64_t n); ///< used to perform the exponential search over the given array\\nstatic void test(); ///< used to run the self-test implementations\\n\\n/**\\n * Function: exponential_search\\n * \\\\brief algorithm that search the index of the given item\\n * \\\\details recursive function that take an array and quickly find the range \\n * where to apply the binary search algorithm to find the given element\\n * ----------------------------\\n * \\\\param arr array where search the element\\n * \\\\param length the total length of the given array (arr)\\n * \\\\param n element to find in the array (arr)\\n * \\n * \\\\returns the index of the element (n) in the array (arr)\\n * \\\\returns -1 if the element wasn't found\\n */\\nint64_t exponential_search(const int64_t* arr, const uint16_t length, const int64_t n) \\n{\\n    if ( length == 0 ) { return -1; }\\n    // find the upperbound\\n    uint32_t upper_bound = 1;\\n    while ( upper_bound <= length && arr[upper_bound] < n ) { upper_bound = upper_bound * 2; }\\n    // calculate the range ( between lower_boud and upper_bound )\\n    uint16_t lower_bound = upper_bound/2;\\n    if ( upper_bound > length ) { upper_bound = length; }\\n    // apply the binary search in the range\\n    return binary_search(arr, lower_bound, upper_bound, n);\\n}\\n\\n/**\\n * Function: binary_search\\n * \\\\brief algorithm that search the index of the given item\\n * \\\\details recursive function that search the given element in\\n * the array using the [Binary Search](https://github.com/TheAlgorithms/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Binary%20Search.md)\\n * ----------------------------\\n * \\\\param arr array where search the element\\n * \\\\param l_index start index of the array (arr) to apply the algorithm\\n * \\\\param r_index end index of the array (arr) to apply the algorithm\\n * \\\\param n element to find in the array (arr)\\n *\\n * \\\\returns the index of the element (n) in the array (arr)\\n * \\\\returns -1 if the n element wasn't found\\n */\\nint64_t binary_search(const int64_t* arr, const uint16_t l_index, const uint16_t r_index, const int64_t n) \\n{\\n    // calculate the middle index of the array\\n    uint16_t middle_index = l_index + ( r_index - l_index ) / 2;\\n    // base cases\\n    if ( l_index > r_index ) { return -1; }\\n    if ( arr[middle_index] == n ) { return middle_index; }\\n    // recursion\\n    if ( arr[middle_index] > n ) { return binary_search(arr, l_index, middle_index-1, n); } // left\\n    return binary_search(arr, middle_index+1, r_index, n); // right\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main() \\n{\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test()\\n{\\n    // empty array\\n    int64_t arr_empty[] = {};\\n    assert(exponential_search(arr_empty, 0, 10) == -1);\\n    // elent not found\\n    int64_t arr_found[] = {1, 2, 3};\\n    assert(exponential_search(arr_found, 3, 10) == -1);\\n    // element found in an array of length 1\\n    int64_t arr_one[] = {1};\\n    assert(exponential_search(arr_found, 1, 1) == 0);\\n    // find the first element in an array of length 2\\n    int64_t arr_first_2[] = {1, 2};\\n    assert(exponential_search(arr_first_2, 2, 1) == 0);\\n    // find the last element in an array of length 2\\n    int64_t arr_last_2[] = {1, 2};\\n    assert(exponential_search(arr_last_2, 2, 2) == 1);\\n    // find the first element in an array of length n\\n    int64_t arr_first_n[] = {-1, 2, 4, 6, 8};\\n    assert(exponential_search(arr_first_n, 5, -1) == 0);\\n    // find the last element in an array of length n\\n    int64_t arr_last_n[] = {-1, 2, 4, 6, 8};\\n    assert(exponential_search(arr_last_n, 5, 8) == 4);\\n    // find an element in an array of length n\\n    int64_t arr_middle[] = {-1, 2, 4, 6, 8};\\n    assert(exponential_search(arr_middle, 5, 6) == 3);\\n}\\n\"",
    "fibonacci search": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint fibMonaccianSearch(int arr[], int x, int n)\\n{\\n    /* Initialize fibonacci numbers */\\n    int fibMMm2 = 0;               // (m-2)'th Fibonacci No.\\n    int fibMMm1 = 1;               // (m-1)'th Fibonacci No.\\n    int fibM = fibMMm2 + fibMMm1;  // m'th Fibonacci\\n\\n    /* fibM is going to store the smallest Fibonacci\\n       Number greater than or equal to n */\\n    while (fibM < n)\\n    {\\n        fibMMm2 = fibMMm1;\\n        fibMMm1 = fibM;\\n        fibM = fibMMm2 + fibMMm1;\\n    }\\n\\n    // Marks the eliminated range from front\\n    int offset = -1;\\n\\n    /* while there are elements to be inspected. Note that\\n       we compare arr[fibMm2] with x. When fibM becomes 1,\\n       fibMm2 becomes 0 */\\n    while (fibM > 1)\\n    {\\n        // Check if fibMm2 is a valid location\\n\\n        // sets i to the min. of (offset+fibMMm2) and (n-1)\\n        int i = ((offset + fibMMm2) < (n - 1)) ? (offset + fibMMm2) : (n - 1);\\n\\n        /* If x is greater than the value at index fibMm2,\\n           cut the subarray array from offset to i */\\n        if (arr[i] < x)\\n        {\\n            fibM = fibMMm1;\\n            fibMMm1 = fibMMm2;\\n            fibMMm2 = fibM - fibMMm1;\\n            offset = i;\\n        }\\n\\n        /* If x is greater than the value at index fibMm2,\\n           cut the subarray after i+1  */\\n        else if (arr[i] > x)\\n        {\\n            fibM = fibMMm2;\\n            fibMMm1 = fibMMm1 - fibMMm2;\\n            fibMMm2 = fibM - fibMMm1;\\n        }\\n\\n        /* element found. return index */\\n        else\\n            return i;\\n    }\\n\\n    /* comparing the last element with x */\\n    if (fibMMm1 && arr[offset + 1] == x)\\n        return offset + 1;\\n\\n    /*element not found. return -1 */\\n    return -1;\\n}\\n\\nint main(void)\\n{\\n    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};\\n    int n = sizeof(arr) / sizeof(arr[0]);\\n    int x = 85;\\n    printf(\\\"Found at index: %d\\\", fibMonaccianSearch(arr, x, n));\\n    return 0;\\n}\\n\"",
    "floyd cycle detection algorithm": "\"/**\\n * @file\\n * @brief Implementation of [Floyd's Cycle\\n * Detection](https://en.wikipedia.org/wiki/Cycle_detection) algorithm\\n * @details\\n * Given an array of integers containing `n + 1` integers, where each\\n * integer is in the range [1, n] inclusive. If there is only one duplicate\\n * number in the input array, this algorithm returns the duplicate number in\\n * O(1) space and the time complexity is less than O(n^2) without modifying the\\n * original array, otherwise, it returns -1.\\n * @author [Swastika Gupta](https://github.com/Swastyy)\\n */\\n \\n#include <assert.h>   /// for assert\\n#include <inttypes.h> /// for uint32_t\\n#include <stdio.h>    /// for IO operations\\n\\n/**\\n * @brief The main function implements the search algorithm\\n * @tparam T type of array\\n * @param in_arr the input array\\n * @param n size of the array\\n * @returns the duplicate number\\n */\\nuint32_t duplicateNumber(const uint32_t *in_arr, size_t n)\\n{\\n    if (n <= 1) {  // to find duplicate in an array its size should be atleast 2\\n        return -1;\\n    }\\n    uint32_t tortoise = in_arr[0];  ///< variable tortoise is used for the longer\\n                                    ///< jumps in the array\\n    uint32_t hare = in_arr[0];  ///< variable hare is used for shorter jumps in the array\\n    do {                                   // loop to enter the cycle\\n        tortoise = in_arr[tortoise];       // tortoise is moving by one step\\n        hare = in_arr[in_arr[hare]];       // hare is moving by two steps\\n    } while (tortoise != hare);\\n    tortoise = in_arr[0];\\n    while (tortoise != hare) {             // loop to find the entry point of cycle\\n        tortoise = in_arr[tortoise];\\n        hare = in_arr[hare];\\n    }\\n    return tortoise;\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test()\\n{\\n    uint32_t arr[] = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}; // input array\\n    size_t n = sizeof(arr) / sizeof(int);\\n\\n    printf(\\\"1st test... \\\");\\n    uint32_t index = duplicateNumber(arr, n); // calling the duplicateNumber function to check which number occurs twice in the array\\n    assert(index == 1); // the number which occurs twice is 1 or not\\n    printf(\\\"passed\\\\n\\\");\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "interpolation search": "\"#include <stdio.h>\\n\\n/* By comparison, binary search always chooses the middle of the remaining\\n * search space, discarding one half or the other, depending on the comparison\\n * between the key found at the estimated position and the key sought. The\\n * remaining search space is reduced to the part before or after the estimated\\n * position. The linear search uses equality only as it compares elements\\n * one-by-one from the start, ignoring any sorting. On average the interpolation\\n * search makes about log(log(n)) comparisons (if the elements are uniformly\\n * distributed), where n is the number of elements to be searched. In the worst\\n * case (for instance where the numerical values of the keys increase\\n * exponentially) it can make up to O(n) comparisons. In\\n * interpolation-sequential search, interpolation is used to find an item near\\n * the one being searched for, then linear search is used to find the exact\\n * item. */\\n\\nint interpolationSearch(int arr[], int n, int key)\\n{\\n    int low = 0, high = n - 1;\\n    while (low <= high && key >= arr[low] && key <= arr[high])\\n    {\\n        /* Calculate the nearest posible position of key */\\n        int pos =\\n            low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low]);\\n        if (key > arr[pos])\\n            low = pos + 1;\\n        else if (key < arr[pos])\\n            high = pos - 1;\\n        else /* Found */\\n            return pos;\\n    }\\n    /* Not found */\\n    return -1;\\n}\\n\\nint main()\\n{\\n    int x;\\n    int arr[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};\\n    int n = sizeof(arr) / sizeof(arr[0]);\\n\\n    printf(\\\"Array: \\\");\\n    for (int i = 0; i < n; i++) printf(\\\"%d \\\", arr[i]);\\n    printf(\\\"\\\\nEnter the number to be searched: \\\");\\n    scanf(\\\"%d\\\", &x); /* Element to be searched */\\n\\n    int index = interpolationSearch(arr, n, x);\\n\\n    /* If element was found */\\n    if (index != -1)\\n        printf(\\\"Element found at position: %d\\\\n\\\", index);\\n    else\\n        printf(\\\"Element not found.\\\\n\\\");\\n    return 0;\\n}\\n\"",
    "jump search": "\"/**\\n * @file jump_search.c\\n * @brief Implementation of [jump\\n * search](https://en.wikipedia.org/wiki/Jump_search) algorithm.\\n */\\n#include <assert.h>\\n#include <math.h>\\n#include <stdio.h>\\n\\n/**\\n * @brief Macro to return the minimum of two values\\n */\\n#define min(X, Y) ((X) < (Y) ? (X) : (Y))\\n\\n/**\\n * @brief Implement Jump-search algorithm\\n *\\n * @param [in] arr Array to search within\\n * @param x value to search for\\n * @param n length of array\\n * @return index where the value was found\\n * @return -1 if value not found\\n */\\nint jump_search(const int *arr, int x, size_t n)\\n{\\n    int step = floor(sqrt(n));\\n    int prev = 0;\\n\\n    while (arr[min(step, n) - 1] < x)\\n    {\\n        prev = step;\\n        step += floor(sqrt(n));\\n        if (prev >= n)\\n        {\\n            return -1;\\n        }\\n    }\\n\\n    while (arr[prev] < x)\\n    {\\n        prev = prev + 1;\\n        if (prev == min(step, n))\\n        {\\n            return -1;\\n        }\\n    }\\n    if (arr[prev] == x)\\n    {\\n        return prev;\\n    }\\n    return -1;\\n}\\n\\n/**\\n * @brief Test implementation of the function\\n *\\n */\\nvoid test()\\n{\\n    int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610};\\n    size_t n = sizeof(arr) / sizeof(int);\\n\\n    int x = 55;\\n    printf(\\\"Test 1.... \\\");\\n    int index = jump_search(arr, x, n);\\n    assert(index == 10);\\n    printf(\\\"passed\\\\nTest 2.... \\\");\\n    x = 56;\\n    index = jump_search(arr, x, n);\\n    assert(index == -1);\\n    printf(\\\"passed\\\\nTest 3.... \\\");\\n    x = 13;\\n    index = jump_search(arr, x, n);\\n    assert(index == 7);\\n    printf(\\\"passed\\\\n\\\");\\n}\\n\\n/**\\n * @brief Main function\\n */\\nint main()\\n{\\n    test();\\n    return 0;\\n}\\n\"",
    "linear search": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint linearsearch(int *arr, int size, int val)\\n{\\n    int i;\\n    for (i = 0; i < size; i++)\\n    {\\n        if (arr[i] == val)\\n            return 1;\\n    }\\n    return 0;\\n}\\n\\nint main()\\n{\\n    int n, i, v;\\n    printf(\\\"Enter the size of the array:\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);  // Taking input for the size of Array\\n\\n    int *a = (int *)malloc(n * sizeof(int));\\n    printf(\\\"Enter the contents for an array of size %d:\\\\n\\\", n);\\n    for (i = 0; i < n; i++)\\n        scanf(\\\"%d\\\", &a[i]);  // accepts the values of array elements until the\\n                             // loop terminates//\\n\\n    printf(\\\"Enter the value to be searched:\\\\n\\\");\\n    scanf(\\\"%d\\\", &v);  // Taking input the value to be searched\\n    if (linearsearch(a, n, v))\\n        printf(\\\"Value %d is in the array.\\\\n\\\", v);\\n    else\\n        printf(\\\"Value %d is not in the array.\\\\n\\\", v);\\n\\n    free(a);\\n    return 0;\\n}\\n\"",
    "modified binary search": "\"/**\\n * @file\\n * @brief [Modified binary search algorithm](https://arxiv.org/abs/1406.1677)\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n/** This function does Binary search for `x` in `i`-th row from `j_low` to\\n * `j_high`.\\n * @param mat 2D matrix to search within\\n * @param i row to search in\\n * @param j_low start column index\\n * @param j_high end column index\\n * @param x value to search for\\n * @return column where `x` was found\\n * @return -1 if value not found\\n */\\nint binarySearch(const int **mat, int i, int j_low, int j_high, int x)\\n{\\n    while (j_low <= j_high)\\n    {\\n        int j_mid = (j_low + j_high) / 2;\\n\\n        // Element found\\n        if (mat[i][j_mid] == x)\\n        {\\n            printf(\\\"Found at (%d,%d)\\\\n\\\", i, j_mid);\\n            return j_mid;\\n        }\\n        else if (mat[i][j_mid] > x)\\n            j_high = j_mid - 1;\\n        else\\n            j_low = j_mid + 1;\\n    }\\n\\n    // element not found\\n    printf(\\\"element not found\\\\n\\\");\\n    return -1;\\n}\\n\\n/** Function to perform binary search on the mid values of row to get the\\n * desired pair of rows where the element can be found\\n * @param [in] mat matrix to search for the value in\\n * @param n number of rows in the matrix\\n * @param m number of columns in the matrix\\n * @param x value to search for\\n */\\nvoid modifiedBinarySearch(const int **mat, int n, int m, int x)\\n{  // If Single row matrix\\n    if (n == 1)\\n    {\\n        binarySearch(mat, 0, 0, m - 1, x);\\n        return;\\n    }\\n\\n    // Do binary search in middle column.\\n    // Condition to terminate the loop when the 2 desired rows are found.\\n    int i_low = 0, i_high = n - 1, j_mid = m / 2;\\n    while ((i_low + 1) < i_high)\\n    {\\n        int i_mid = (i_low + i_high) / 2;\\n        // element found\\n        if (mat[i_mid][j_mid] == x)\\n        {\\n            printf(\\\"Found at (%d,%d)\\\\n\\\", i_mid, j_mid);\\n            return;\\n        }\\n        else if (mat[i_mid][j_mid] > x)\\n            i_high = i_mid;\\n        else\\n            i_low = i_mid;\\n    }\\n    // If element is present on the mid of the two rows\\n    if (mat[i_low][j_mid] == x)\\n        printf(\\\"Found at (%d,%d)\\\\n\\\", i_low, j_mid);\\n    else if (mat[i_low + 1][j_mid] == x)\\n        printf(\\\"Found at (%d,%d)\\\\n\\\", i_low + 1, j_mid);\\n\\n    // Search element on 1st half of 1st row\\n    else if (x <= mat[i_low][j_mid - 1])\\n        binarySearch(mat, i_low, 0, j_mid - 1, x);\\n\\n    // Search element on 2nd half of 1st row\\n    else if (x >= mat[i_low][j_mid + 1] && x <= mat[i_low][m - 1])\\n        binarySearch(mat, i_low, j_mid + 1, m - 1, x);\\n\\n    // Search element on 1st half of 2nd row\\n    else if (x <= mat[i_low + 1][j_mid - 1])\\n        binarySearch(mat, i_low + 1, 0, j_mid - 1, x);\\n\\n    // search element on 2nd half of 2nd row\\n    else\\n        binarySearch(mat, i_low + 1, j_mid + 1, m - 1, x);\\n}\\n\\n/** Main function */\\nint main()\\n{\\n    int x;     // element to be searched\\n    int m, n;  // m = columns, n = rows\\n\\n    scanf(\\\"%d %d %d\\\\n\\\", &n, &m, &x);\\n\\n    int **mat = (int **)malloc(n * sizeof(int *));\\n    for (int i = 0; i < m; i++) mat[i] = (int *)malloc(m * sizeof(int));\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            scanf(\\\"%d\\\", &mat[i][j]);\\n        }\\n    }\\n\\n    modifiedBinarySearch(mat, n, m, x);\\n\\n    for (int i = 0; i < n; i++) free(mat[i]);\\n    free(mat);\\n    return 0;\\n}\\n\"",
    "other binary search": "\"#include <stdio.h>\\n#include <stdlib.h>\\n#define len 5\\n\\nint binarySearch(int array[], int leng, int searchX)\\n{\\n    int pos = -1, right, left, i = 0;\\n\\n    left = 0;\\n    right = leng - 1;\\n\\n    while (left <= right)\\n    {\\n        pos = left + (right - left) / 2;\\n        if (array[pos] == searchX)\\n        {\\n            return pos;\\n        }\\n        else if (array[pos] > searchX)\\n        {\\n            right = pos - 1;\\n        }\\n        else\\n        {\\n            left = pos + 1;\\n        }\\n    }\\n    return -1; /* not found */\\n}\\n\\nint main(int argc, char *argv[])\\n{\\n    int array[len] = {5, 8, 10, 14, 16};\\n\\n    int position;\\n    position = binarySearch(array, len, 5);\\n\\n    if (position < 0)\\n        printf(\\\"The number %d doesnt exist in array\\\\n\\\", 5);\\n    else\\n    {\\n        printf(\\\"The number %d exist in array at position : %d \\\\n\\\", 5, position);\\n    }\\n\\n    return 0;\\n}\\n\"",
    "sentinel linear search": "\"/**\\n * @file\\n * @brief [Linear Search with Sentinel](https://en.wikipedia.org/wiki/Linear_search#With_a_sentinel) algorithm implementation\\n * @details\\n * This algorithm saves the last element of the array, \\n * then replaces it with the value to be found and sets it as the sentinel. \\n * When searching, compares each element with the sentinel. \\n * If the same, returns the index. If the index is the index of the sentinel, it means it was not found. \\n * Of course, if the value to be found is the last element, we return the index of the last element.\\n * @author [Regan Yue](https://github.com/ReganYue)\\n * Time Complexity: O(N)\\n */\\n\\n#include <stdio.h>   /// for IO operations\\n#include <assert.h>  /// for assert\\n\\n/**\\n * @brief Utility function to search for an element in the array and return the index of the element\\n * @details \\n * The so-called \\\"sentinel\\\" is to use a special value as the boundary key of the array. \\n * One less judgment statement can be used. \\n * The purpose is to avoid checking whether the entire array is searched at each step in the search \\n * process, so as to improve the efficiency of the program.\\n * We can use the last value of the array as the \\\"sentinel\\\", the data storage index i \\n * starts from 0 and ends at len-1, then the position where the index of arr is n-1 indicates \\n * that there is no data temporarily, which is the \\\"sentinel\\\" key.\\n * If the last element of the array is equal to the key, directly return the index of the last element. \\n * Before setting the last element of the array as the key, we hand over the last element of the array to temp for temporary storage. \\n * Then go to the array to find the key. If the key is found, stop the search, and then compare the found element index with len-1. \\n * If it is equal, it means it was not found. If it is not equal, it is found.\\n * @param arr this is an array containing elements\\n * @param len this is the number of elements in the array\\n * @param key the value we want to search\\n * @return i if found, otherwise -1 is returned.\\n */\\nint sentinel_linear_search( int arr[], int len, int key ){\\n\\tif(key == arr[len-1]){\\n\\t\\treturn len-1;\\n\\t}\\n\\t\\n\\tint temp = arr[len-1]; \\n\\tarr[len-1] = key;\\n\\t\\n\\tint i = 0;\\n\\twhile (arr[len-1] != arr[i]) {\\n\\t\\ti++;\\n\\t}\\n\\t\\n\\tarr[len-1] = temp;\\n\\t\\n\\treturn i != len-1 ? i : -1;\\n\\t \\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test(){\\n\\tint n,i;\\n\\tn = 5;\\n\\t/* init array */\\n\\tint arr[] = { 1, 2, 2, 6, 99, 100, 999 };\\n\\n\\tassert(sentinel_linear_search( arr, n, 1 )==0);\\n\\tassert(sentinel_linear_search( arr, n, 2 )==1);\\n\\tassert(sentinel_linear_search( arr, n, 6 )==3);\\n\\tassert(sentinel_linear_search( arr, n, 101 )==-1);\\n\\tprintf(\\\"All test cases have successfully passed!\\\\n\\\");\\n} \\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main(){\\n\\ttest();  // run self-test implementations\\n\\treturn 0;\\n}\\n\"",
    "ternary search": "\"\\n#include <stdio.h>\\n\\n// Function to perform Ternary Search\\nint ternarySearch(int l, int r, int key, int ar[])\\n{\\n    if (r >= l)\\n    {\\n        // Find the mid1 and mid2\\n        int mid1 = l + (r - l) / 3;\\n        int mid2 = r - (r - l) / 3;\\n\\n        // Check if key is present at any mid\\n        if (ar[mid1] == key)\\n        {\\n            return mid1;\\n        }\\n        if (ar[mid2] == key)\\n        {\\n            return mid2;\\n        }\\n\\n        // Since key is not present at mid,\\n        // check in which region it is present\\n        // then repeat the Search operation\\n        // in that region\\n\\n        if (key < ar[mid1])\\n        {\\n            // The key lies in between l and mid1\\n            return ternarySearch(l, mid1 - 1, key, ar);\\n        }\\n        else if (key > ar[mid2])\\n        {\\n            // The key lies in between mid2 and r\\n            return ternarySearch(mid2 + 1, r, key, ar);\\n        }\\n        else\\n        {\\n            // The key lies in between mid1 and mid2\\n            return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\\n        }\\n    }\\n\\n    // Key not found\\n    return -1;\\n}\\n\\n// Driver code\\nint main()\\n{\\n    int l, r, p, key;\\n\\n    // Get the array\\n    // Sort the array if not sorted\\n    int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\\n\\n    // Starting index\\n    l = 0;\\n\\n    // length of array\\n    r = 9;\\n\\n    // Checking for 5\\n\\n    // Key to be searched in the array\\n    key = 5;\\n\\n    // Search the key using ternarySearch\\n    p = ternarySearch(l, r, key, ar);\\n\\n    // Print the result\\n    printf(\\\"Index of %d is %d\\\\n\\\", key, p);\\n\\n    // Checking for 50\\n\\n    // Key to be searched in the array\\n    key = 50;\\n\\n    // Search the key using ternarySearch\\n    p = ternarySearch(l, r, key, ar);\\n\\n    // Print the result\\n    printf(\\\"Index of %d is %d\\\", key, p);\\n}\"",
    "bead sort": "\"/**\\n * @file\\n * @brief Sorting of array list using [bead\\n * sort](https://en.wikipedia.org/wiki/Bead_sort)\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n/**\\n * @addtogroup sorting Sorting algorithms\\n * @{\\n */\\n/** Create easy access of elements from a 2D matrix stored in memory as a 1D\\n * array\\n */\\n#define BEAD(i, j) beads[i * max + j]\\n\\n/**\\n * Displays the array, passed to this method\\n * @param [in] arr array to display\\n * @param [in] n number of elements in the array\\n */\\nvoid display(const int *arr, int n)\\n{\\n    for (int i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n/** This is where the sorting of the array takes place\\n * @param [in,out] a array to be sorted\\n * @param [in] len Array Size\\n */\\nvoid bead_sort(int *a, size_t len)\\n{\\n    int i, j, max, sum;\\n    unsigned char *beads;\\n\\n    for (i = 1, max = a[0]; i < len; i++)\\n        if (a[i] > max)\\n            max = a[i];\\n\\n    beads = calloc(1, max * len);\\n\\n    /* mark the beads */\\n    for (i = 0; i < len; i++)\\n        for (j = 0; j < a[i]; j++) BEAD(i, j) = 1;\\n\\n    for (j = 0; j < max; j++)\\n    {\\n        /* count how many beads are on each post */\\n        for (sum = i = 0; i < len; i++)\\n        {\\n            sum += BEAD(i, j);\\n            BEAD(i, j) = 0;\\n        }\\n        /* mark bottom sum beads */\\n        for (i = len - sum; i < len; i++) BEAD(i, j) = 1;\\n    }\\n\\n    for (i = 0; i < len; i++)\\n    {\\n        for (j = 0; j < max && BEAD(i, j); j++)\\n            ;\\n        a[i] = j;\\n    }\\n    free(beads);\\n}\\n/** @} */\\n\\n/** Main function */\\nint main(int argc, const char *argv[])\\n{\\n    int n;\\n    printf(\\\"Enter size of array:\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);  // E.g. 8 1 2 3\\n\\n    printf(\\\"Enter the elements of the array\\\\n\\\");\\n    int i;\\n    int *arr = (int *)malloc(n * sizeof(int));\\n    for (i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d\\\", &arr[i]);\\n    }\\n\\n    printf(\\\"Original array: \\\");\\n    display(arr, n);\\n\\n    bead_sort(arr, n);\\n\\n    printf(\\\"Sorted array: \\\");\\n    display(arr, n);\\n\\n    free(arr);\\n    return 0;\\n}\\n\"",
    "binary insertion sort": "\"/* Sorting of array list using binary insertion sort\\n * Using binary search to find the proper location for\\n * inserting the selected item at each iteration. */\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n/*Displays the array, passed to this method*/\\nvoid display(int *arr, int n)\\n{\\n    int i;\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint binarySearch(int *arr, int key, int low, int high)\\n{\\n    if (low >= high)\\n        return (key > arr[low]) ? (low + 1) : low;\\n    int mid = low + (high - 1) / 2;\\n    if (arr[mid] == key)\\n        return mid + 1;\\n    else if (arr[mid] > key)\\n        return binarySearch(arr, key, low, mid - 1);\\n    else\\n        return binarySearch(arr, key, mid + 1, high);\\n}\\n/*This is where the sorting of the array takes place\\n arr[] --- Array to be sorted\\n size --- Array Size\\n */\\nvoid insertionSort(int *arr, int size)\\n{\\n    int i, j, key, index;\\n    for (i = 0; i < size; i++)\\n    {\\n        j = i - 1;\\n        key = arr[i];\\n        /* Use binrary search to find exact key's index */\\n        index = binarySearch(arr, key, 0, j);\\n        /* Move all elements greater than key from [index...j]\\n         * to one position */\\n        while (j >= index)\\n        {\\n            arr[j + 1] = arr[j];\\n            j = j - 1;\\n        }\\n        /* Insert key value in right place */\\n        arr[j + 1] = key;\\n    }\\n}\\n\\nint main(int argc, const char *argv[])\\n{\\n    int n;\\n    printf(\\\"Enter size of array:\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);  // E.g. 8\\n\\n    printf(\\\"Enter the elements of the array\\\\n\\\");\\n    int i;\\n    int *arr = (int *)malloc(n * sizeof(int));\\n    for (i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d\\\", &arr[i]);\\n    }\\n\\n    printf(\\\"Original array: \\\");\\n    display(arr, n);\\n\\n    insertionSort(arr, n);\\n\\n    printf(\\\"Sorted array: \\\");\\n    display(arr, n);\\n\\n    free(arr);\\n    return 0;\\n}\\n\"",
    "bogo sort": "\"#include <stdbool.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nbool check_sorted(int *a, int n)\\n{\\n    while (--n >= 1)\\n    {\\n        if (a[n] < a[n - 1])\\n            return false;\\n    }\\n    return true;\\n}\\n\\nvoid shuffle(int *a, int n)\\n{\\n    int i, t, r;\\n    for (i = 0; i < n; i++)\\n    {\\n        t = a[i];\\n        r = rand() % n;\\n        a[i] = a[r];\\n        a[r] = t;\\n    }\\n}\\n\\nvoid sort(int *a, int n)\\n{\\n    while (!check_sorted(a, n)) shuffle(a, n);\\n}\\n\\nint main()\\n{\\n    int numbers[6];\\n    int i;\\n    printf(\\\"Enter 6 numbers unsorted \\\\n\\\\n\\\");\\n    for (i = 0; i < 6; i++)\\n    {\\n        scanf(\\\"%d\\\", &numbers[i]);\\n    }\\n    sort(numbers, 6);\\n    for (i = 0; i < 6; i++) printf(\\\"%d \\\", numbers[i]);\\n    printf(\\\"\\\\n\\\");\\n}\\n\"",
    "bubble sort": "\"/**\\n * @file\\n * @brief [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm\\n * implementation\\n */\\n#include <assert.h>\\n#include <stdbool.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n/**\\n * Display elements of array\\n * @param arr array to be display\\n * @param n length of array\\n */\\nvoid display(const int *arr, int n)\\n{\\n    for (int i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n/**\\n * Swap two values by using pointer\\n * @param first first pointer of first number\\n * @param second second pointer of second number\\n */\\nvoid swap(int *first, int *second)\\n{\\n    int temp = *first;\\n    *first = *second;\\n    *second = temp;\\n}\\n\\n/**\\n * Bubble sort algorithm implementation\\n * @param arr array to be sorted\\n * @param size size of array\\n */\\nvoid bubbleSort(int *arr, int size)\\n{\\n    for (int i = 0; i < size - 1; i++)\\n    {                         /* for each array index */\\n        bool swapped = false; /* flag to check if any changes had to be made */\\n        /* perform iterations until no more changes were made or outer loop\\n            executed for all array indices */\\n        for (int j = 0; j < size - 1 - i; j++)\\n        { /* for each element in the array */\\n            if (arr[j] > arr[j + 1])\\n            { /* if the order of successive elements needs update */\\n                swap(&arr[j], &arr[j + 1]);\\n                swapped = true; /* set flag */\\n            }\\n        }\\n        if (!swapped)\\n        {\\n            /* since no more updates we made, the array is already sorted\\n                this is an optimization for early termination */\\n            break;\\n        }\\n    }\\n}\\n\\n/**\\n * Test function\\n */\\nvoid test()\\n{\\n    const int size = 10;\\n    int *arr = (int *)calloc(size, sizeof(int));\\n\\n    /* generate size random numbers from 0 to 100 */\\n    for (int i = 0; i < size; i++)\\n    {\\n        arr[i] = rand() % 100;\\n    }\\n    bubbleSort(arr, size);\\n    for (int i = 0; i < size - 1; ++i)\\n    {\\n        assert(arr[i] <= arr[i + 1]);\\n    }\\n    free(arr);\\n}\\n\\n/** Driver Code */\\nint main(int argc, const char *argv[])\\n{\\n    /* Intializes random number generator */\\n    srand(time(NULL));\\n    test();\\n    return 0;\\n}\\n\"",
    "bubble sort 2": "\"/**\\n * @file\\n * @brief implementation of [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm\\n * @details\\n * worst-case: O(n^2)\\n * best-case: O(n)\\n * average-complexity: O(n^2)\\n\\n * @author Unknown author\\n * @author [Gabriel Fioravante](https://github.com/northernSage)\\n */\\n\\n#include <stdlib.h>   /// for rand() calls\\n#include <assert.h>   /// for assert(<expr>)\\n#include <stdbool.h>  /// for boolean values: true, false  \\n\\n#define MAX 20\\n\\n/**\\n * @brief Bubble sort implementation\\n * @param array_sort the array to be sorted\\n * @returns void\\n */\\nvoid bubble_sort(int* array_sort)\\n{\\n\\tbool is_sorted = false;\\n\\n    /* keep iterating over entire array\\n     * and swaping elements out of order\\n     * until it is sorted */\\n    while (!is_sorted)\\n    {\\n\\t\\tis_sorted = true;\\n\\n        /* iterate over all elements */\\n        for (int i = 0; i < MAX - 1; i++)\\n        {\\n            /* check if adjacent elements are out of order */\\n            if (array_sort[i] > array_sort[i + 1])\\n            {\\n                /* swap elements */\\n                int change_place = array_sort[i];\\n                array_sort[i] = array_sort[i + 1];\\n                array_sort[i + 1] = change_place;\\n                /* elements out of order were found\\n                 * so we reset the flag to keep ordering\\n                 * until no swap operations are executed */\\n                is_sorted = false;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @brief Test implementations\\n * @returns void\\n */\\nstatic void test() {\\n    /* simple int array for testing */\\n\\tint array_sort[MAX] = {0};\\n\\n    /* populate our test array with \\n     * random integer numbers */\\n    for (int i = 0; i < MAX; i++)\\n    {\\n        array_sort[i] = rand() % 101;\\n    }\\n\\n    /* sort array */\\n    bubble_sort(array_sort);\\n\\n    /* check if array ir correctly ordered */\\t\\n    for (int i = 0; i < MAX - 1; i++)\\n    {\\n        assert(array_sort[i] <= array_sort[i+1]);\\n    }\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "bubble sort recursion": "\"/**\\n * @file\\n * @brief [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm\\n * implementation using recursion.\\n */\\n#include <assert.h>\\n#include <stdbool.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n/**\\n * Swapped two numbers using pointer\\n * @param first first pointer of first number\\n * @param second second pointer of second number\\n */\\nvoid swap(int *first, int *second)\\n{\\n    int temp = *first;\\n    *first = *second;\\n    *second = temp;\\n}\\n\\n/**\\n * Bubble sort algorithm implements using recursion\\n * @param arr array to be sorted\\n * @param size size of array\\n */\\nvoid bubbleSort(int *arr, int size)\\n{\\n    if (size == 1)\\n    {\\n        return;\\n    }\\n    bool swapped = false;\\n    for (int i = 0; i < size - 1; ++i)\\n    {\\n        if (arr[i] > arr[i + 1])\\n        {\\n            swap(arr + i, arr + i + 1);\\n            swapped = true;\\n        }\\n    }\\n    if (swapped)\\n    {\\n        bubbleSort(arr, size - 1);\\n    }\\n}\\n\\n/**\\n * Test function\\n */\\nvoid test()\\n{\\n    const int size = 10;\\n    int *arr = (int *)calloc(size, sizeof(int));\\n\\n    /* generate size random numbers from 0 to 100 */\\n    for (int i = 0; i < size; i++)\\n    {\\n        arr[i] = rand() % 100;\\n    }\\n    bubbleSort(arr, size);\\n    for (int i = 0; i < size - 1; ++i)\\n    {\\n        assert(arr[i] <= arr[i + 1]);\\n    }\\n    free(arr);\\n}\\n\\n/** Driver Code */\\nint main()\\n{\\n    /* Intializes random number generator */\\n    srand(time(NULL));\\n    test();\\n    return 0;\\n}\\n\"",
    "bucket sort": "\"/*\\n * Algorithm : Bucket Sort\\n * Time-Complexity : O(n)\\n */\\n#include <assert.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define NARRAY 8    /* array size */\\n#define NBUCKET 5   /* bucket size */\\n#define INTERVAL 10 /* bucket range */\\n\\nstruct Node\\n{\\n    int data;\\n    struct Node *next;\\n};\\n\\nvoid BucketSort(int arr[]);\\nstruct Node *InsertionSort(struct Node *list);\\nvoid print(int arr[]);\\nvoid printBuckets(struct Node *list);\\nint getBucketIndex(int value);\\n\\nvoid BucketSort(int arr[])\\n{\\n    int i, j;\\n    struct Node **buckets;\\n\\n    /* allocate memory for array of pointers to the buckets */\\n    buckets = (struct Node **)malloc(sizeof(struct Node *) * NBUCKET);\\n\\n    /* initialize pointers to the buckets */\\n    for (i = 0; i < NBUCKET; ++i)\\n    {\\n        buckets[i] = NULL;\\n    }\\n\\n    /* put items into the buckets */\\n    /* creates a link list in each bucket slot */\\n    for (i = 0; i < NARRAY; ++i)\\n    {\\n        struct Node *current;\\n        int pos = getBucketIndex(arr[i]);\\n        current = (struct Node *)malloc(sizeof(struct Node));\\n        current->data = arr[i];\\n        current->next = buckets[pos];\\n        buckets[pos] = current;\\n    }\\n\\n    /* check what's in each bucket */\\n    for (i = 0; i < NBUCKET; i++)\\n    {\\n        printf(\\\"Bucket[\\\\\\\"%d\\\\\\\"] : \\\", i);\\n        printBuckets(buckets[i]);\\n        printf(\\\"\\\\n\\\");\\n    }\\n\\n    /* sorting bucket using Insertion Sort */\\n    for (i = 0; i < NBUCKET; ++i)\\n    {\\n        buckets[i] = InsertionSort(buckets[i]);\\n    }\\n\\n    /* check what's in each bucket */\\n    printf(\\\"--------------\\\\n\\\");\\n    printf(\\\"Buckets after sorted\\\\n\\\");\\n    for (i = 0; i < NBUCKET; i++)\\n    {\\n        printf(\\\"Bucket[\\\\\\\"%d\\\\\\\"] : \\\", i);\\n        printBuckets(buckets[i]);\\n        printf(\\\"\\\\n\\\");\\n    }\\n\\n    /* put items back to original array */\\n    for (j = 0, i = 0; i < NBUCKET; ++i)\\n    {\\n        struct Node *node;\\n        node = buckets[i];\\n        while (node)\\n        {\\n            // precondition for avoiding out of bounds by the array\\n            assert(j < NARRAY);\\n            arr[j++] = node->data;\\n            node = node->next;\\n        }\\n    }\\n\\n    /* free memory */\\n    for (i = 0; i < NBUCKET; ++i)\\n    {\\n        struct Node *node;\\n        node = buckets[i];\\n        while (node)\\n        {\\n            struct Node *tmp;\\n            tmp = node;\\n            node = node->next;\\n            free(tmp);\\n        }\\n    }\\n    free(buckets);\\n    return;\\n}\\n\\n/* Insertion Sort */\\nstruct Node *InsertionSort(struct Node *list)\\n{\\n    struct Node *k, *nodeList;\\n    /* need at least two items to sort */\\n    if (list == NULL || list->next == NULL)\\n    {\\n        return list;\\n    }\\n\\n    nodeList = list;\\n    k = list->next;\\n    nodeList->next = NULL; /* 1st node is new list */\\n    while (k != NULL)\\n    {\\n        struct Node *ptr;\\n        /* check if insert before first */\\n        if (nodeList->data > k->data)\\n        {\\n            struct Node *tmp;\\n            tmp = k;\\n            k = k->next;  // important for the while\\n            tmp->next = nodeList;\\n            nodeList = tmp;\\n            continue;\\n        }\\n\\n        // from begin up to end\\n        // finds [i] > [i+1]\\n        for (ptr = nodeList; ptr->next != NULL; ptr = ptr->next)\\n        {\\n            if (ptr->next->data > k->data)\\n                break;\\n        }\\n\\n        // if found (above)\\n        if (ptr->next != NULL)\\n        {\\n            struct Node *tmp;\\n            tmp = k;\\n            k = k->next;  // important for the while\\n            tmp->next = ptr->next;\\n            ptr->next = tmp;\\n            continue;\\n        }\\n        else\\n        {\\n            ptr->next = k;\\n            k = k->next;  // important for the while\\n            ptr->next->next = NULL;\\n            continue;\\n        }\\n    }\\n    return nodeList;\\n}\\n\\nint getBucketIndex(int value) { return value / INTERVAL; }\\n\\nvoid print(int ar[])\\n{\\n    int i;\\n    for (i = 0; i < NARRAY; ++i)\\n    {\\n        printf(\\\"%d \\\", ar[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nvoid printBuckets(struct Node *list)\\n{\\n    struct Node *cur = list;\\n    while (cur)\\n    {\\n        printf(\\\"%d \\\", cur->data);\\n        cur = cur->next;\\n    }\\n}\\n\\nint main(void)\\n{\\n    int array[NARRAY] = {29, 25, -1, 49, 9, 37, 21, 43};\\n\\n    printf(\\\"Initial array\\\\n\\\");\\n    print(array);\\n    printf(\\\"------------\\\\n\\\");\\n\\n    BucketSort(array);\\n    printf(\\\"------------\\\\n\\\");\\n    printf(\\\"Sorted array\\\\n\\\");\\n    print(array);\\n    return 0;\\n}\\n\"",
    "cocktail sort": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define TRUE 1\\n#define FALSE 0\\n\\nvoid cocktailSort(int arr[], int size)\\n{\\n    int i, changed = TRUE, temp, start = 0, end = size - 1;\\n\\n    while (changed)\\n    {\\n        changed = FALSE;\\n        for (i = start; i < end; i++)\\n        {\\n            if (arr[i] > arr[i + 1])\\n            {\\n                temp = arr[i];\\n                arr[i] = arr[i + 1];\\n                arr[i + 1] = temp;\\n                changed = TRUE;\\n            }\\n        }\\n        end--;\\n\\n        if (changed == FALSE)\\n        {\\n            break;\\n        }\\n        changed = FALSE;\\n\\n        for (i = end - 1; i >= start; i--)\\n        {\\n            if (arr[i + 1] < arr[i])\\n            {\\n                temp = arr[i + 1];\\n                arr[i + 1] = arr[i];\\n                arr[i] = temp;\\n                changed = TRUE;\\n            }\\n        }\\n        start++;\\n    }\\n}\\n\\nint main()\\n{\\n    int i, n;\\n\\n    printf(\\\"Enter the size of the array: \\\");\\n    scanf(\\\"%d\\\", &n);\\n    int *arr = (int *)malloc(sizeof(int) * n);\\n\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"Number #%d: \\\", i + 1);\\n        scanf(\\\"%d\\\", &arr[i]);\\n    }\\n\\n    printf(\\\"You entered:  \\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n    cocktailSort(arr, n);\\n    printf(\\\"\\\\nSorted array: \\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n\\n    free(arr);\\n    return 0;\\n}\"",
    "comb sort": "\"#include <stdio.h>\\n#include <stdlib.h>\\n#define SHRINK 1.3  // suggested shrink factor value\\n\\nvoid sort(int *numbers, int size)\\n{\\n    int gap = size;\\n    while (gap > 1)  // gap = 1 means that the array is sorted\\n    {\\n        gap = gap / SHRINK;\\n        int i = 0;\\n        while ((i + gap) < size)\\n        {  // similiar to the Shell Sort\\n            if (numbers[i] > numbers[i + gap])\\n            {\\n                int tmp = numbers[i];\\n                numbers[i] = numbers[i + gap];\\n                numbers[i + gap] = tmp;\\n            }\\n            i++;\\n        }\\n    }\\n}\\n\\nvoid display(int *array, int n)\\n{\\n    int i;\\n    for (i = 0; i < n; ++i) printf(\\\"%d \\\", array[i]);\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint main()\\n{\\n    int size = 6;\\n    int *numbers = malloc(size * sizeof(int));\\n    printf(\\\"Insert %d unsorted numbers: \\\\n\\\", size);\\n    int i;\\n    for (i = 0; i < size; ++i) scanf(\\\"%d\\\", &numbers[i]);\\n    printf(\\\"Initial array: \\\");\\n    display(numbers, size);\\n    sort(numbers, size);\\n    printf(\\\"Sorted array: \\\");\\n    display(numbers, size);\\n    free(numbers);\\n    return 0;\\n}\\n\"",
    "counting sort": "\"/*\\n  > Counting sort is a sorting technique based on keys between a specific range.\\n  > integer sorting algorithm\\n  > Worst-case performance O(n+k)\\n  > Stabilized by prefix sum array\\n*/\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint main()\\n{\\n    int i, n, l = 0;\\n\\n    printf(\\\"Enter size of array = \\\");\\n    scanf(\\\"%d\\\", &n);\\n\\n    int *a = (int *)malloc(n * sizeof(int));\\n    printf(\\\"Enter %d elements in array :\\\\n\\\", n);\\n    for (i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d\\\", &a[i]);\\n        if (a[i] > l)\\n            l = a[i];\\n    }\\n\\n    int *b = (int *)malloc((l + 1) * sizeof(int));\\n    memset(b, 0, (l + 1) * sizeof(b[0]));\\n\\n    for (i = 0; i < n; i++) b[a[i]]++;  // hashing number to array index\\n\\n    for (i = 0; i < (l + 1); i++)  // unstable , stabilized by prefix sum array\\n    {\\n        if (b[i] > 0)\\n        {\\n            while (b[i] != 0)  // for case when number exists more than once\\n            {\\n                printf(\\\"%d \\\", i);\\n                b[i]--;\\n            }\\n        }\\n    }\\n\\n    free(a);\\n    free(b);\\n    return 0;\\n}\\n\"",
    "cycle sort": "\"// Sorting of array list using cycle sort\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n// Displays the array, passed to this method\\nvoid display(int *arr, int n)\\n{\\n    int i;\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n// Swap function to swap two values\\nvoid swap(int *first, int *second)\\n{\\n    int temp = *first;\\n    *first = *second;\\n    *second = temp;\\n}\\n\\n// Function sort the array using Cycle sort\\nvoid cycleSort(int *arr, int n)\\n{\\n    // count number of memory writes\\n    int writes = 0;\\n\\n    // traverse array elements and put it to on\\n    // the right place\\n    for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++)\\n    {\\n        // initialize item as starting point\\n        int item = arr[cycle_start];\\n\\n        // Find position where we put the item. We basically\\n        // count all smaller elements on right side of item.\\n        int pos = cycle_start;\\n        for (int i = cycle_start + 1; i < n; i++)\\n            if (arr[i] < item)\\n                pos++;\\n\\n        // If item is already in correct position\\n        if (pos == cycle_start)\\n            continue;\\n\\n        // ignore all duplicate elements\\n        while (item == arr[pos]) pos += 1;\\n\\n        // put the item to it's right position\\n        if (pos != cycle_start)\\n        {\\n            swap(&item, &arr[pos]);\\n            writes++;\\n        }\\n\\n        // Rotate rest of the cycle\\n        while (pos != cycle_start)\\n        {\\n            pos = cycle_start;\\n\\n            // Find position where we put the element\\n            for (int i = cycle_start + 1; i < n; i++)\\n                if (arr[i] < item)\\n                    pos += 1;\\n\\n            // ignore all duplicate elements\\n            while (item == arr[pos]) pos += 1;\\n\\n            // put the item to it's right position\\n            if (item != arr[pos])\\n            {\\n                swap(&item, &arr[pos]);\\n                writes++;\\n            }\\n        }\\n    }\\n}\\n\\n// Driver program to test above function\\nint main()\\n{\\n    int n;  // Size of array elements\\n\\n    printf(\\\"Enter size of array:\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);  // E.g. 8\\n\\n    printf(\\\"Enter the elements of the array\\\\n\\\");\\n    int i;\\n    int *arr = (int *)malloc(n * sizeof(int));\\n    for (i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d\\\", &arr[i]);\\n    }\\n\\n    printf(\\\"Original array: \\\");\\n    display(arr, n);\\n\\n    cycleSort(arr, n);\\n    printf(\\\"Sorted array: \\\");\\n    display(arr, n);\\n\\n    free(arr);\\n    return 0;\\n}\\n\"",
    "gnome sort": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid sort(int *numbers, int size)\\n{\\n    int pos = 0;\\n    while (pos < size)\\n    {\\n        if (numbers[pos] >= numbers[pos - 1])\\n            pos++;\\n        else\\n        {\\n            int tmp = numbers[pos - 1];\\n            numbers[pos - 1] = numbers[pos];\\n            numbers[pos] = tmp;\\n            pos--;\\n\\n            if (pos == 0)\\n                pos = 1;\\n        }\\n    }\\n}\\n\\nvoid display(int *array, int n)\\n{\\n    int i;\\n    for (i = 0; i < n; ++i) printf(\\\"%d \\\", array[i]);\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint main()\\n{\\n    int size = 6;\\n    int i;\\n    int *numbers = malloc(size * sizeof(int));\\n    printf(\\\"Insert %d unsorted numbers: \\\\n\\\", size);\\n    for (i = 0; i < size; ++i) scanf(\\\"%d\\\", &numbers[i]);\\n    printf(\\\"Initial array: \\\");\\n    display(numbers, size);\\n    sort(numbers, size);\\n    printf(\\\"Sorted array: \\\");\\n    display(numbers, size);\\n    free(numbers);\\n    return 0;\\n}\\n\"",
    "heap sort": "\"#include <stdio.h>\\n\\nvoid max_heapify(int *a, int i, int n);\\nvoid heapsort(int *a, int n);\\nvoid build_maxheap(int *a, int n);\\n\\nvoid max_heapify(int *a, int i, int n)\\n{\\n    int j, temp;\\n    temp = a[i];\\n    j = 2 * i;\\n    while (j <= n)\\n    {\\n        if (j < n && a[j + 1] > a[j])\\n            j = j + 1;\\n        if (temp > a[j])\\n        {\\n            break;\\n        }\\n        else if (temp <= a[j])\\n        {\\n            a[j / 2] = a[j];\\n            j = 2 * j;\\n        }\\n    }\\n    a[j / 2] = temp;\\n    return;\\n}\\n\\nvoid heapsort(int *a, int n)\\n{\\n    int i, temp;\\n    for (i = n; i >= 2; i--)\\n    {\\n        temp = a[i];\\n        a[i] = a[1];\\n        a[1] = temp;\\n        max_heapify(a, 1, i - 1);\\n    }\\n}\\n\\nvoid build_maxheap(int *a, int n)\\n{\\n    int i;\\n    for (i = n / 2; i >= 1; i--)\\n    {\\n        max_heapify(a, i, n);\\n    }\\n}\\n\\nint main()\\n{\\n    int n, i;\\n    printf(\\\"Enter number of elements of array\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);\\n    int a[20];\\n    for (i = 1; i <= n; i++)\\n    {\\n        printf(\\\"Enter Element %d\\\\n\\\", i);\\n        scanf(\\\"%d\\\", a + i);\\n    }\\n\\n    build_maxheap(a, n);\\n    heapsort(a, n);\\n    printf(\\\"Sorted Output\\\\n\\\");\\n    for (i = 1; i <= n; i++)\\n    {\\n        printf(\\\"%d\\\\n\\\", a[i]);\\n    }\\n\\n    getchar();\\n}\\n\"",
    "heap sort 2": "\"/**\\n * @file\\n * @author [Dhruv Pasricha](https://github.com/DhruvPasricha)\\n * @brief [Heap Sort](https://en.wikipedia.org/wiki/Heapsort) implementation\\n * @details\\n * Heap-sort is a comparison-based sorting algorithm.\\n * Heap-sort can be thought of as an improved selection sort:\\n * like selection sort, heap sort divides its input into a sorted\\n * and an unsorted region, and it iteratively shrinks the unsorted\\n * region by extracting the largest element from it and inserting\\n * it into the sorted region.\\n *\\n * Unlike selection sort,\\n * heap sort does not waste time with a linear-time scan of the\\n * unsorted region; rather, heap sort maintains the unsorted region\\n * in a heap data structure to more quickly find the largest element\\n * in each step.\\n * Time Complexity : O(Nlog(N))\\n */\\n\\n#include <assert.h>   /// for assert\\n#include <stdio.h>    /// for IO operations\\n#include <stdlib.h>   /// for dynamic memory allocation\\n#include <time.h>     /// for random numbers generation\\n#include <inttypes.h> /// for uint8_t, int8_t\\n\\n/**\\n * @brief Swapped two numbers using pointer\\n * @param first pointer of first number\\n * @param second pointer of second number\\n */\\nvoid swap(int8_t *first, int8_t *second)\\n{\\n    int8_t temp = *first;\\n    *first = *second;\\n    *second = temp;\\n}\\n\\n/**\\n * @brief heapifyDown Adjusts new root to the correct position in the heap\\n * This heapify procedure can be thought of as building a heap from\\n * the top down by successively shifting downward to establish the\\n * heap property.\\n * @param arr array to be sorted\\n * @param size size of array\\n * @return void\\n*/\\nvoid heapifyDown(int8_t *arr, const uint8_t size)\\n{\\n    uint8_t i = 0;\\n\\n    while (2 * i + 1 < size)\\n    {\\n        uint8_t maxChild = 2 * i + 1;\\n\\n        if (2 * i + 2 < size && arr[2 * i + 2] > arr[maxChild])\\n        {\\n            maxChild = 2 * i + 2;\\n        }\\n\\n        if (arr[maxChild] > arr[i])\\n        {\\n            swap(&arr[i], &arr[maxChild]);\\n            i = maxChild;\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n}\\n\\n/**\\n * @brief heapifyUp Adjusts arr[i] to the correct position in the heap\\n * This heapify procedure can be thought of as building a heap from\\n * the bottom up by successively shifting upward to establish the\\n * heap property.\\n * @param arr array to be sorted\\n * @param i index of the pushed element\\n * @return void\\n*/\\nvoid heapifyUp(int8_t *arr, uint8_t i)\\n{\\n    while (i > 0 && arr[i / 2] < arr[i])\\n    {\\n        swap(&arr[i / 2], &arr[i]);\\n        i /= 2;\\n    }\\n}\\n\\n/**\\n * @brief Heap Sort algorithm\\n * @param arr array to be sorted\\n * @param size size of the array\\n * @returns void\\n */\\nvoid heapSort(int8_t *arr, const uint8_t size)\\n{\\n    if (size <= 1)\\n    {\\n        return;\\n    }\\n\\n    for (uint8_t i = 0; i < size; i++)\\n    {\\n        // Pushing `arr[i]` to the heap\\n\\n        /*heapifyUp Adjusts arr[i] to the correct position in the heap*/\\n        heapifyUp(arr, i);\\n    }\\n\\n    for (uint8_t i = size - 1; i >= 1; i--)\\n    {\\n        // Moving current root to the end\\n        swap(&arr[0], &arr[i]);\\n\\n        // `heapifyDown` adjusts new root to the correct position in the heap\\n        heapifyDown(arr, i);\\n\\n    }\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test()\\n{\\n    const uint8_t size = 10;\\n    int8_t *arr = (int8_t *)calloc(size, sizeof(int8_t));\\n\\n    /* generate size random numbers from 0 to 100 */\\n    for (uint8_t i = 0; i < size; i++)\\n    {\\n        arr[i] = rand() % 100;\\n    }\\n    heapSort(arr, size);\\n    for (uint8_t i = 0; i < size - 1; ++i)\\n    {\\n        assert(arr[i] <= arr[i + 1]);\\n    }\\n    free(arr);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    // Intializes random number generator\\n    srand(time(NULL));\\n\\n    test(); // run self-test implementations\\n    return 0;\\n}\\n\"",
    "insertion sort": "\"/**\\n * @file\\n * @brief [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort)\\n * algorithm implementation.\\n */\\n#include <assert.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n/**\\n * Insertion sort algorithm implements\\n * @param arr array to be sorted\\n * @param size size of array\\n */\\nvoid insertionSort(int *arr, int size)\\n{\\n    for (int i = 1; i < size; i++)\\n    {\\n        int j = i - 1;\\n        int key = arr[i];\\n        /* Move all elements greater than key to one position */\\n        while (j >= 0 && key < arr[j])\\n        {\\n            arr[j + 1] = arr[j];\\n            j = j - 1;\\n        }\\n        /* Find a correct position for key */\\n        arr[j + 1] = key;\\n    }\\n}\\n\\n/** Test function\\n  * @returns None\\n  */\\nstatic void test()\\n{\\n    const int size = rand() % 500; /* random array size */\\n    int *arr = (int *)calloc(size, sizeof(int));\\n\\n    /* generate size random numbers from -50 to 49 */  \\n    for (int i = 0; i < size; i++)\\n    {\\n        arr[i] = (rand() % 100) - 50; /* signed random numbers */\\n    }\\n    insertionSort(arr, size);\\n    for (int i = 0; i < size - 1; ++i)\\n    {\\n        assert(arr[i] <= arr[i + 1]);\\n    }\\n    free(arr);\\n}\\nint main(int argc, const char *argv[])\\n{\\n    /* Intializes random number generator */\\n    srand(time(NULL));\\n    test();\\n    return 0;\\n}\\n\"",
    "insertion sort recursive": "\"/**\\n * @file\\n * @brief [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort)\\n * algorithm implementation.\\n */\\n#include <assert.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n/**\\n * @addtogroup sorting Sorting algorithms\\n * @{\\n */\\n/**\\n * Insertion sort algorithm implements using Recursion \\n * @param arr array to be sorted\\n * @param size size of array\\n */\\nvoid RecursionInsertionSort(int *arr, int size)\\n{\\n    if(size <= 0)\\n    {\\n        return;\\n    }\\n    \\n    // marking recursive call to reach starting element\\n    RecursionInsertionSort(arr,size-1);\\n    \\n    int key = arr[size-1];\\n    int j = size-2;\\n    // swapping logic for insertion sort\\n    while(j >= 0 && arr[j] > key)\\n    {\\n        arr[j+1] = arr[j];\\n        j--;\\n    }\\n    arr[j+1] = key;\\n}\\n/** @} */\\n/** Test function\\n  * @returns None\\n  */\\nstatic void test()\\n{\\n    const int size = rand() % 500; /* random array size */\\n    int *arr = (int *)calloc(size, sizeof(int));\\n\\n    /* generate size random numbers from -50 to 49 */  \\n    for (int i = 0; i < size; i++)\\n    {\\n        arr[i] = (rand() % 100) - 50;/* signed random numbers */\\n    }\\n    RecursionInsertionSort(arr, size);\\n    for (int i = 0; i < size  ; ++i)\\n    {\\n        assert(arr[i] <= arr[i + 1]);\\n    }\\n    free(arr);\\n}\\n\\n/** Main function\\n *  @returns integer 0\\n */\\nint main(int argc, const char *argv[])\\n{\\n    /* Intializes random number generator */\\n    srand(time(NULL));\\n    test();\\n    return 0;\\n}\\n\"",
    "merge sort": "\"/**\\n * @file\\n * @brief Implementation of [merge\\n * sort](https://en.wikipedia.org/wiki/Merge_sort) algorithm\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n/**\\n * @addtogroup sorting Sorting algorithms\\n * @{\\n */\\n/** Swap two integer variables\\n * @param [in,out] a pointer to first variable\\n * @param [in,out] b pointer to second variable\\n */\\nvoid swap(int *a, int *b)\\n{\\n    int t;\\n    t = *a;\\n    *a = *b;\\n    *b = t;\\n}\\n\\n/**\\n * @brief Perform merge of segments.\\n *\\n * @param a array to sort\\n * @param l left index for merge\\n * @param r right index for merge\\n * @param n total number of elements in the array\\n */\\nvoid merge(int *a, int l, int r, int n)\\n{\\n    int *b = (int *)malloc(n * sizeof(int)); /* dynamic memory must be freed */\\n    int c = l;\\n    int p1, p2;\\n    p1 = l;\\n    p2 = ((l + r) / 2) + 1;\\n    while ((p1 < ((l + r) / 2) + 1) && (p2 < r + 1))\\n    {\\n        if (a[p1] <= a[p2])\\n        {\\n            b[c++] = a[p1];\\n            p1++;\\n        }\\n        else\\n        {\\n            b[c++] = a[p2];\\n            p2++;\\n        }\\n    }\\n\\n    if (p2 == r + 1)\\n    {\\n        while ((p1 < ((l + r) / 2) + 1))\\n        {\\n            b[c++] = a[p1];\\n            p1++;\\n        }\\n    }\\n    else\\n    {\\n        while ((p2 < r + 1))\\n        {\\n            b[c++] = a[p2];\\n            p2++;\\n        }\\n    }\\n\\n    for (c = l; c < r + 1; c++) a[c] = b[c];\\n\\n    free(b);\\n}\\n\\n/** Merge sort algorithm implementation\\n * @param a array to sort\\n * @param n number of elements in the array\\n * @param l index to sort from\\n * @param r index to sort till\\n */\\nvoid merge_sort(int *a, int n, int l, int r)\\n{\\n    if (r - l == 1)\\n    {\\n        if (a[l] > a[r])\\n            swap(&a[l], &a[r]);\\n    }\\n    else if (l != r)\\n    {\\n        merge_sort(a, n, l, (l + r) / 2);\\n        merge_sort(a, n, ((l + r) / 2) + 1, r);\\n        merge(a, l, r, n);\\n    }\\n\\n    /* no change if l == r */\\n}\\n/** @} */\\n\\n/** Main function */\\nint main(void)\\n{\\n    int *a, n, i;\\n    scanf(\\\"%d\\\", &n);\\n    a = (int *)malloc(n * sizeof(int));\\n    for (i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    merge_sort(a, n, 0, n - 1);\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\" %d\\\", a[i]);\\n    }\\n\\n    free(a);\\n\\n    return 0;\\n}\\n\"",
    "merge sort nr": "\"/* Program to demonstrate non recursive merge sort */\\r\\n\\r\\n/* Merge sort is an effective sorting algorithm which falls under divide and\\r\\nconquer paradigm and produces a stable sort. Merge sort repeatedly breaks down a\\r\\nlist into several sublists until each sublist consists of a single element and\\r\\nmerging those sublists in a manner that results into a sorted list.\\r\\n\\r\\nBottom-Up Merge Sort Implementation:\\r\\nThe Bottom-Up merge sort approach uses iterative methodology. It starts with the\\r\\n“single-element” array, and combines two adjacent elements and also sorting the\\r\\ntwo at the same time. The combined-sorted arrays are again combined and sorted\\r\\nwith each other until one single unit of sorted array is achieved. */\\r\\n\\r\\n#include <stdio.h>\\r\\n\\r\\nvoid mergesort(int x[], int n);\\r\\nvoid show(int x[], int n);\\r\\n\\r\\nvoid mergesort(int x[], int n)\\r\\n{\\r\\n    int temp[50], i, j, k, lb1, lb2, ub1, ub2, size;\\r\\n\\r\\n    size = 1;\\r\\n    while (size < n)\\r\\n    {\\r\\n        lb1 = 0;\\r\\n        k = 0;\\r\\n\\r\\n        while (lb1 + size < n)\\r\\n        {\\r\\n            lb2 = lb1 + size;\\r\\n            ub1 = lb2 - 1;\\r\\n            if (ub1 + size < n)\\r\\n                ub2 = ub1 + size;\\r\\n            else\\r\\n                ub2 = n - 1;\\r\\n\\r\\n            i = lb1;\\r\\n            j = lb2;\\r\\n\\r\\n            while (i <= ub1 && j <= ub2)\\r\\n                if (x[i] < x[j])\\r\\n                    temp[k++] = x[i++];\\r\\n                else\\r\\n                    temp[k++] = x[j++];\\r\\n\\r\\n            while (i <= ub1) temp[k++] = x[i++];\\r\\n\\r\\n            while (j <= ub2) temp[k++] = x[j++];\\r\\n\\r\\n            lb1 = ub2 + 1;\\r\\n        }\\r\\n\\r\\n        for (i = 0; i <= ub2; i++) x[i] = temp[i];\\r\\n\\r\\n        size = size * 2;\\r\\n\\r\\n        show(x, n);\\r\\n    }\\r\\n}\\r\\n\\r\\n// function to show each pass\\r\\nvoid show(int x[], int n)\\r\\n{\\r\\n    int i;\\r\\n    for (i = 0; i < n; i++) printf(\\\"%d \\\", x[i]);\\r\\n    printf(\\\"\\\\n\\\\n\\\");\\r\\n}\\r\\n\\r\\nint main()  // main function\\r\\n{\\r\\n    int i, n, x[20];\\r\\n\\r\\n    printf(\\\"Enter the number of elements: \\\");\\r\\n    scanf(\\\"%d\\\", &n);\\r\\n    printf(\\\"Enter the elements:\\\\n\\\");\\r\\n    for (i = 0; i < n; i++) scanf(\\\"%d\\\", &x[i]);\\r\\n\\r\\n    mergesort(x, n);\\r\\n\\r\\n    printf(\\\"Sorted array is as shown:\\\\n\\\");\\r\\n    for (i = 0; i < n; i++) printf(\\\"%d \\\", x[i]);\\r\\n    return 0;\\r\\n}\\r\\n\\r\\n/* Output of the Program*/\\r\\n/*\\r\\nEnter the number of elements: 5\\r\\nEnter the elements:\\r\\n15\\r\\n14\\r\\n13\\r\\n12\\r\\n11\\r\\n14 15 12 13 11\\r\\n\\r\\n12 13 14 15 11\\r\\n\\r\\n11 12 13 14 15\\r\\n\\r\\nSorted array is as shown:\\r\\n11 12 13 14 15\\r\\n*/\\r\\n\"",
    "multikey quick sort": "\"/* demo.c -- Implementations of multikey quicksort and ternary search trees\\n   Usage\\n    demo                  Run basic timings on /usr/dict/words\\n    demo <file>           Run basic timings on <file>\\n    demo <file> trysearch Interactive pm and nn search on <file>\\n    demo <file> nncost    Run near neigbhor expers on <file>\\n    demo <file> pmcost    Interactive partial match expers on <file>\\n */\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <time.h>\\n\\n// MULTIKEY QUICKSORT\\n\\n#ifndef min\\n#define min(a, b) ((a) <= (b) ? (a) : (b))\\n#endif\\n\\n#define swap(a, b)      \\\\\\n    {                   \\\\\\n        char *t = x[a]; \\\\\\n        x[a] = x[b];    \\\\\\n        x[b] = t;       \\\\\\n    }\\n#define i2c(i) x[i][depth]\\n\\nvoid vecswap(int i, int j, int n, char *x[])\\n{\\n    while (n-- > 0)\\n    {\\n        swap(i, j);\\n        i++;\\n        j++;\\n    }\\n}\\n\\nvoid ssort1(char *x[], int n, int depth)\\n{\\n    int a, b, c, d, r, v;\\n    if (n <= 1)\\n        return;\\n    a = rand() % n;\\n    swap(0, a);\\n    v = i2c(0);\\n    a = b = 1;\\n    c = d = n - 1;\\n    for (;;)\\n    {\\n        while (b <= c && (r = i2c(b) - v) <= 0)\\n        {\\n            if (r == 0)\\n            {\\n                swap(a, b);\\n                a++;\\n            }\\n            b++;\\n        }\\n        while (b <= c && (r = i2c(c) - v) >= 0)\\n        {\\n            if (r == 0)\\n            {\\n                swap(c, d);\\n                d--;\\n            }\\n            c--;\\n        }\\n        if (b > c)\\n            break;\\n        swap(b, c);\\n        b++;\\n        c--;\\n    }\\n    r = min(a, b - a);\\n    vecswap(0, b - r, r, x);\\n    r = min(d - c, n - d - 1);\\n    vecswap(b, n - r, r, x);\\n    r = b - a;\\n    ssort1(x, r, depth);\\n    if (i2c(r) != 0)\\n        ssort1(x + r, a + n - d - 1, depth + 1);\\n    r = d - c;\\n    ssort1(x + n - r, r, depth);\\n}\\n\\nvoid ssort1main(char *x[], int n) { ssort1(x, n, 0); }\\n\\n// ssort2 -- Faster Version of Multikey Quicksort\\n\\nvoid vecswap2(char **a, char **b, int n)\\n{\\n    while (n-- > 0)\\n    {\\n        char *t = *a;\\n        *a++ = *b;\\n        *b++ = t;\\n    }\\n}\\n\\n#define swap2(a, b)  \\\\\\n    {                \\\\\\n        t = *(a);    \\\\\\n        *(a) = *(b); \\\\\\n        *(b) = t;    \\\\\\n    }\\n#define ptr2char(i) (*(*(i) + depth))\\n\\nchar **med3func(char **a, char **b, char **c, int depth)\\n{\\n    int va, vb, vc;\\n    if ((va = ptr2char(a)) == (vb = ptr2char(b)))\\n        return a;\\n    if ((vc = ptr2char(c)) == va || vc == vb)\\n        return c;\\n    return va < vb ? (vb < vc ? b : (va < vc ? c : a))\\n                   : (vb > vc ? b : (va < vc ? a : c));\\n}\\n#define med3(a, b, c) med3func(a, b, c, depth)\\n\\nvoid inssort(char **a, int n, int d)\\n{\\n    char **pi, **pj, *s, *t;\\n    for (pi = a + 1; --n > 0; pi++)\\n        for (pj = pi; pj > a; pj--)\\n        {\\n            // Inline strcmp: break if *(pj-1) <= *pj\\n            for (s = *(pj - 1) + d, t = *pj + d; *s == *t && *s != 0; s++, t++)\\n                ;\\n            if (*s <= *t)\\n                break;\\n            swap2(pj, pj - 1);\\n        }\\n}\\n\\nvoid ssort2(char **a, int n, int depth)\\n{\\n    int d, r, partval;\\n    char **pa, **pb, **pc, **pd, **pl, **pm, **pn, *t;\\n    if (n < 10)\\n    {\\n        inssort(a, n, depth);\\n        return;\\n    }\\n    pl = a;\\n    pm = a + (n / 2);\\n    pn = a + (n - 1);\\n    if (n > 30)\\n    {  // On big arrays, pseudomedian of 9\\n        d = (n / 8);\\n        pl = med3(pl, pl + d, pl + 2 * d);\\n        pm = med3(pm - d, pm, pm + d);\\n        pn = med3(pn - 2 * d, pn - d, pn);\\n    }\\n    pm = med3(pl, pm, pn);\\n    swap2(a, pm);\\n    partval = ptr2char(a);\\n    pa = pb = a + 1;\\n    pc = pd = a + n - 1;\\n    for (;;)\\n    {\\n        while (pb <= pc && (r = ptr2char(pb) - partval) <= 0)\\n        {\\n            if (r == 0)\\n            {\\n                swap2(pa, pb);\\n                pa++;\\n            }\\n            pb++;\\n        }\\n        while (pb <= pc && (r = ptr2char(pc) - partval) >= 0)\\n        {\\n            if (r == 0)\\n            {\\n                swap2(pc, pd);\\n                pd--;\\n            }\\n            pc--;\\n        }\\n        if (pb > pc)\\n            break;\\n        swap2(pb, pc);\\n        pb++;\\n        pc--;\\n    }\\n    pn = a + n;\\n    r = min(pa - a, pb - pa);\\n    vecswap2(a, pb - r, r);\\n    r = min(pd - pc, pn - pd - 1);\\n    vecswap2(pb, pn - r, r);\\n    if ((r = pb - pa) > 1)\\n        ssort2(a, r, depth);\\n    if (ptr2char(a + r) != 0)\\n        ssort2(a + r, pa - a + pn - pd - 1, depth + 1);\\n    if ((r = pd - pc) > 1)\\n        ssort2(a + n - r, r, depth);\\n}\\n\\nvoid ssort2main(char **a, int n) { ssort2(a, n, 0); }\\n\\n// TERNARY SEARCH TREE ALGS\\n\\ntypedef struct tnode *Tptr;\\ntypedef struct tnode\\n{\\n    char splitchar;\\n    Tptr lokid, eqkid, hikid;\\n} Tnode;\\nTptr root;\\n\\n// Insert 1 -- Simple Insertion Algorithm\\n\\nTptr insert1(Tptr p, char *s)\\n{\\n    if (p == 0)\\n    {\\n        p = (Tptr)malloc(sizeof(Tnode));\\n        p->splitchar = *s;\\n        p->lokid = p->eqkid = p->hikid = 0;\\n    }\\n    if (*s < p->splitchar)\\n        p->lokid = insert1(p->lokid, s);\\n    else if (*s == p->splitchar)\\n    {\\n        if (*s != 0)\\n            p->eqkid = insert1(p->eqkid, ++s);\\n    }\\n    else\\n        p->hikid = insert1(p->hikid, s);\\n    return p;\\n}\\n\\nvoid cleanup1(Tptr p)\\n{\\n    if (p)\\n    {\\n        cleanup1(p->lokid);\\n        cleanup1(p->eqkid);\\n        cleanup1(p->hikid);\\n        free(p);\\n    }\\n}\\n\\n// Insert 2 -- Faster version of Insert\\n\\n#define BUFSIZE 1000\\nTptr buffer;\\nint bufn, freen;\\nvoid *freearr[10000];\\nint storestring = 0;\\n\\nvoid insert2(char *s)\\n{\\n    int d;\\n    char *instr = s;\\n\\n    Tptr pp, *p;\\n    p = &root;\\n    pp = *p;\\n    while (pp == *p)\\n    {\\n        if ((d = *s - pp->splitchar) == 0)\\n        {\\n            if (*s++ == 0)\\n                return;\\n            p = &(pp->eqkid);\\n        }\\n        else if (d < 0)\\n            p = &(pp->lokid);\\n        else\\n            p = &(pp->hikid);\\n    }\\n    for (;;)\\n    {\\n        // *p = (Tptr) malloc(sizeof(Tnode));\\n        if (bufn-- == 0)\\n        {\\n            buffer = (Tptr)malloc(BUFSIZE * sizeof(Tnode));\\n            freearr[freen++] = (void *)buffer;\\n            bufn = BUFSIZE - 1;\\n        }\\n        *p = buffer++;\\n        pp = *p;\\n        pp->splitchar = *s;\\n        pp->lokid = pp->eqkid = pp->hikid = 0;\\n        if (*s++ == 0)\\n        {\\n            if (storestring)\\n                pp->eqkid = (Tptr)instr;\\n            return;\\n        }\\n        p = &(pp->eqkid);\\n    }\\n}\\nvoid cleanup2()\\n{\\n    int i;\\n    for (i = 0; i < freen; i++) free(freearr[i]);\\n}\\n\\n// Search Algorithms\\n\\nint search1(char *s)\\n{\\n    Tptr p;\\n    p = root;\\n    while (p)\\n    {\\n        if (*s < p->splitchar)\\n            p = p->lokid;\\n        else if (*s == p->splitchar)\\n        {\\n            if (*s++ == 0)\\n                return 1;\\n            p = p->eqkid;\\n        }\\n        else\\n            p = p->hikid;\\n    }\\n    return 0;\\n}\\n\\nint search2(char *s)\\n{\\n    int d, sc;\\n    Tptr p;\\n    sc = *s;\\n    p = root;\\n    while (p)\\n    {\\n        if ((d = sc - p->splitchar) == 0)\\n        {\\n            if (sc == 0)\\n                return 1;\\n            sc = *++s;\\n            p = p->eqkid;\\n        }\\n        else if (d < 0)\\n            p = p->lokid;\\n        else\\n            p = p->hikid;\\n    }\\n    return 0;\\n}\\n\\n// Advanced searching: Partial match, near words\\n\\nint nodecnt;\\nchar *srcharr[100000];\\nint srchtop;\\n\\nvoid pmsearch(Tptr p, char *s)\\n{\\n    if (!p)\\n        return;\\n    nodecnt++;\\n    if (*s == '.' || *s < p->splitchar)\\n        pmsearch(p->lokid, s);\\n    if (*s == '.' || *s == p->splitchar)\\n        if (p->splitchar && *s)\\n            pmsearch(p->eqkid, s + 1);\\n    if (*s == 0 && p->splitchar == 0)\\n        srcharr[srchtop++] = (char *)p->eqkid;\\n    if (*s == '.' || *s > p->splitchar)\\n        pmsearch(p->hikid, s);\\n}\\n\\nvoid nearsearch(Tptr p, char *s, int d)\\n{\\n    if (!p || d < 0)\\n        return;\\n    nodecnt++;\\n    if (d > 0 || *s < p->splitchar)\\n        nearsearch(p->lokid, s, d);\\n    if (p->splitchar == 0)\\n    {\\n        if ((int)strlen(s) <= d)\\n            srcharr[srchtop++] = (char *)p->eqkid;\\n    }\\n    else\\n        nearsearch(p->eqkid, *s ? s + 1 : s, (*s == p->splitchar) ? d : d - 1);\\n    if (d > 0 || *s > p->splitchar)\\n        nearsearch(p->hikid, s, d);\\n}\\n\\n#define NUMBER_OF_STRING 3\\n\\nint main(int argc, char *argv[])\\n{\\n    char *arr[NUMBER_OF_STRING] = {\\\"apple\\\", \\\"cat\\\", \\\"boy\\\"};\\n\\n    ssort1main(arr, NUMBER_OF_STRING);\\n\\n    for (int i = 0; i < NUMBER_OF_STRING; i++)\\n    {\\n        printf(\\\"%s \\\", arr[i]);\\n    }\\n}\\n\"",
    "odd even sort": "\"/**\\n * @file\\n * @author [Edwin Ajong](https://github.com/eddybruv)\\n * @brief [Odd Even Sort](https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort) implementation\\n * @details\\n * This algorithm is divided into two phases- Odd and Even Phase.\\n * The algorithm runs until the array elements are sorted and in each iteration two phases occurs- Odd and Even Phases.\\n * In the odd phase, we perform a bubble sort on odd indexed elements and in the even phase,\\n * we perform a bubble sort on even indexed elements.\\n * Time Complexity: O(N ^ 2)\\n */\\n\\n#include <assert.h>     /// for assert\\n#include <stdbool.h>    /// for bool\\n#include <stdio.h>      /// for IO operations\\n#include <stdlib.h>     /// for dynammic memory allocation\\n#include <time.h>       /// for random number generation\\n#include <inttypes.h>   /// for int32_t types\\n\\n/**\\n * @brief Swap numbers by reference(using pointers)\\n * @param first pointer to first number\\n * @param second pointer to second number\\n * @returns void\\n */\\nvoid swap(int32_t *first, int32_t *second)\\n{\\n    int32_t temp = *first;\\n    *first = *second;\\n    *second = temp;\\n}\\n\\n/**\\n * @brief oddEvenSort sorts the array using the algorithm described above.\\n * @details \\n * A boolean varaible(isSorted) is declared and initialised to \\\"false\\\".\\n * In the while loop, the variable(isSorted) is then set to \\\"true\\\".\\n * During even phase the for loop loops through the array, touching just the even indexes.\\n * i.e arr[0], arr[2], arr[4] and so on.\\n * While during the odd phase, the for loop loops through the array, touching just the odd indexes.\\n * i.e arr[1], arr[3], arr[5] and so on.\\n * During these phases, if the if statement check if the interger at the current position in the array\\n * is greater than the interger at the next array index (i.e arr[index + 2], to make sure the index is odd\\n * during the odd phase and even during the even phase).\\n * If the condition is true, the function \\\"swap\\\" is called and address of the intergers in question are passed as\\n * parameters. After the swap is completed, \\\"isSorted\\\" is set to \\\"false\\\".\\n * The while loop will keep running till the array is propertly sorted.\\n * @param arr array to be sorted\\n * @param size the size of the array\\n * @returns void\\n */\\nvoid oddEvenSort(int *arr, int size)\\n{\\n    bool isSorted = false;\\n    while(!isSorted)\\n    {\\n        isSorted = true;\\n        int32_t i;\\n\\n        // Even phase\\n        for(i = 0; i <= size - 2; i += 2)\\n        {\\n            if(arr[i] > arr[i + 1])\\n            {\\n                swap(&arr[i], &arr[i + 1]);\\n                isSorted = false;\\n            }\\n        }\\n\\n        // Odd phase\\n        for(i = 1; i <= size - 2; i += 2)\\n        {\\n            if(arr[i] > arr[i + 1])\\n            {\\n                swap(&arr[i], &arr[i + 1]);\\n                isSorted = false;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @details Two tests (unsorted) arrays were created and their corresponding solution(sorted) arrays were also created.\\n * The test arrays and their respective sizes are then passed in to the oddEvenSort function.\\n * To test if the algorithm works, a for loop is assigned to loop through the both arrays(test and solution) and check if the array elements \\n * of the test array correspond to the elements of the solution array.\\n * @returns void\\n */\\nstatic void test()\\n{\\n    int32_t arr1[] = {-9, 2, 3, 1};\\n    int32_t arr1Soln[] = {-9, 1, 2, 3};\\n    int32_t arr2[] = {9, 7, 5, 3, 8, 2, 1, 4, 0, 6};\\n    int32_t arr2Soln[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\\n\\n    oddEvenSort(arr1, 4);\\n    oddEvenSort(arr2, 10);\\n\\n     for (int32_t i = 0; i < 4; i++)\\n     {\\n         assert(arr1[i] == arr1Soln[i]);    \\n     }\\n\\n    for (int32_t i = 0; i < 10; i++)\\n    {\\n        assert(arr2[i] == arr2Soln[i]);    \\n    }\\n    printf(\\\"All tests have passed!\\\\n\\\");\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "pancake sort": "\"// Sorting of array list using pancake sort\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n/* Reverses the array */\\nvoid flip(int arr[], int i)\\n{\\n    int temp, start = 0;\\n\\n    while (start < i)\\n    {\\n        temp = arr[start];\\n        arr[start] = arr[i];\\n        arr[i] = temp;\\n        start++;\\n        i--;\\n    }\\n}\\n\\n// Returns index of the maximum element in arr[0..n-1]\\nint findMax(int arr[], int n)\\n{\\n    int maxElementIdx, i;\\n\\n    for (maxElementIdx = 0, i = 0; i < n; ++i)\\n        if (arr[i] > arr[maxElementIdx])\\n            maxElementIdx = i;\\n\\n    return maxElementIdx;\\n}\\n\\n// Sorts the array using flip operations\\nvoid pancakeSort(int *arr, int n)\\n{\\n    // Start from the complete array and one by one reduce current size by one\\n    for (int curr_size = n; curr_size > 1; --curr_size)\\n    {\\n        // Find index of the maximum element in arr[0..curr_size-1]\\n        int maxElementIdx = findMax(arr, curr_size);\\n\\n        // Move the maximum element to end of current array if it's not already\\n        // at the end\\n        if (maxElementIdx != curr_size - 1)\\n        {\\n            // To move at the end, first move maximum number to beginning\\n            flip(arr, maxElementIdx);\\n\\n            // Now move the maximum number to end by reversing current array\\n            flip(arr, curr_size - 1);\\n        }\\n    }\\n}\\n\\n// Displays the array, passed to this method\\nvoid display(int arr[], int n)\\n{\\n    for (int i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n#define N 50\\n\\n// Driver program to test above function\\nint main()\\n{\\n    int arr[N];\\n    for (int i = 0; i < N; i++)\\n        arr[i] = rand() % (N << 1); /* random numbers from 0 to 2N */\\n\\n    printf(\\\"Original array: \\\");\\n    display(arr, N);\\n\\n    pancakeSort(arr, N);\\n    printf(\\\"Sorted array: \\\");\\n    display(arr, N);\\n\\n    return 0;\\n}\"",
    "partition sort": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid swap(int *a, int *b)\\n{\\n    int tmp = *a;\\n    *a = *b;\\n    *b = tmp;\\n}\\n\\nint partition(int arr[], int low, int high)\\n{\\n    int pivot = arr[low];\\n    int i = low - 1, j = high + 1;\\n\\n    while (1)\\n    {\\n        /* Find leftmost element >= pivot */\\n        do\\n        {\\n            i++;\\n        } while (arr[i] < pivot);\\n\\n        /* Find rightmost element <= pivot */\\n        do\\n        {\\n            j--;\\n        } while (arr[j] > pivot);\\n\\n        /* if two pointers met */\\n        if (i >= j)\\n            return j;\\n\\n        swap(&arr[i], &arr[j]);\\n    }\\n}\\n\\nvoid partitionSort(int arr[], int low, int high)\\n{\\n    if (low < high)\\n    {\\n        int value = partition(arr, low, high);\\n        partitionSort(arr, low, value);\\n        partitionSort(arr, value + 1, high);\\n    }\\n}\\n\\nvoid printArray(int arr[], int n)\\n{\\n    int i;\\n    for (i = 0; i < n; i++) printf(\\\"%d \\\", arr[i]);\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nint main()\\n{\\n    int arr[20];\\n    int i, range = 100;\\n    for (i = 0; i < 20; i++)\\n    {\\n        arr[i] = rand() % range + 1;\\n    }\\n    int size = sizeof arr / sizeof arr[0];\\n    printf(\\\"Array: \\\\n\\\");\\n    printArray(arr, size);\\n    partitionSort(arr, 0, size - 1);\\n    printf(\\\"Sorted Array: \\\\n\\\");\\n    printArray(arr, size);\\n\\n    return 0;\\n}\\n\"",
    "pigeonhole sort": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid pigeonholeSort(int arr[], int size)\\n{\\n    int i, j, min = arr[0], max = arr[0], range;\\n\\n    // Getting range of the array using max and min\\n    for (i = 1; i < size; i++)\\n    {\\n        if (arr[i] < min)\\n            min = arr[i];\\n        if (arr[i] > max)\\n            max = arr[i];\\n    }\\n    range = max - min + 1;\\n\\n    // Make 'holes' and put array's numbers in holes\\n    int *holes = (int *)malloc(sizeof(int) * range);\\n    for (i = 0; i < range; i++)\\n    {\\n        holes[i] = 0;\\n    }\\n    for (i = 0; i < size; i++)\\n    {\\n        holes[arr[i] - min]++;\\n    }\\n\\n    // Copy the numbers back to the original array\\n    j = 0;\\n    for (i = 0; i < range; i++)\\n    {\\n        while (holes[i] > 0)\\n        {\\n            arr[j] = i + min;\\n            holes[i]--;\\n            j++;\\n        }\\n    }\\n\\n    free(holes);\\n}\\n\\nint main()\\n{\\n    int i, n;\\n\\n    printf(\\\"Enter the size of the array: \\\");\\n    scanf(\\\"%d\\\", &n);\\n    int *arr = (int *)malloc(sizeof(int) * n);\\n\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"Number #%d: \\\", i + 1);\\n        scanf(\\\"%d\\\", &arr[i]);\\n    }\\n\\n    printf(\\\"You entered:  \\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n    pigeonholeSort(arr, n);\\n    printf(\\\"\\\\nSorted array: \\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n\\n    free(arr);\\n    return 0;\\n}\"",
    "quick sort": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\n/*Displays the array, passed to this method*/\\nvoid display(int arr[], int n)\\n{\\n    int i;\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n/*Swap function to swap two values*/\\nvoid swap(int *first, int *second)\\n{\\n    int temp = *first;\\n    *first = *second;\\n    *second = temp;\\n}\\n\\n/*Partition method which selects a pivot\\n  and places each element which is less than the pivot value to its left\\n  and the elements greater than the pivot value to its right\\n  arr[] --- array to be partitioned\\n  lower --- lower index\\n  upper --- upper index\\n*/\\nint partition(int arr[], int lower, int upper)\\n{\\n    int i = (lower - 1);\\n\\n    int pivot = arr[upper];  // Selects last element as the pivot value\\n\\n    int j;\\n    for (j = lower; j < upper; j++)\\n    {\\n        if (arr[j] <= pivot)\\n        {  // if current element is smaller than the pivot\\n\\n            i++;  // increment the index of smaller element\\n            swap(&arr[i], &arr[j]);\\n        }\\n    }\\n\\n    swap(&arr[i + 1], &arr[upper]);  // places the last element i.e, the pivot\\n                                     // to its correct position\\n\\n    return (i + 1);\\n}\\n\\n/*This is where the sorting of the array takes place\\n    arr[] --- Array to be sorted\\n    lower --- Starting index\\n    upper --- Ending index\\n*/\\nvoid quickSort(int arr[], int lower, int upper)\\n{\\n    if (upper > lower)\\n    {\\n        // partitioning index is returned by the partition method , partition\\n        // element is at its correct poition\\n\\n        int partitionIndex = partition(arr, lower, upper);\\n\\n        // Sorting elements before and after the partition index\\n        quickSort(arr, lower, partitionIndex - 1);\\n        quickSort(arr, partitionIndex + 1, upper);\\n    }\\n}\\n\\nint main()\\n{\\n    int n;\\n    printf(\\\"Enter size of array:\\\\n\\\");\\n    scanf(\\\"%d\\\", &n);  // E.g. 8\\n\\n    printf(\\\"Enter the elements of the array\\\\n\\\");\\n    int i;\\n    int *arr = (int *)malloc(sizeof(int) * n);\\n    for (i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d\\\", &arr[i]);\\n    }\\n\\n    printf(\\\"Original array: \\\");\\n    display(arr, n);  // Original array : 10 11 9 8 4 7 3 8\\n\\n    quickSort(arr, 0, n - 1);\\n\\n    printf(\\\"Sorted array: \\\");\\n    display(arr, n);  // Sorted array : 3 4 7 8 8 9 10 11\\n    getchar();\\n    return 0;\\n}\\n\"",
    "radix sort": "\"#include <stdio.h>\\n\\nint largest(int a[], int n)\\n{\\n    int large = a[0], i;\\n    for (i = 1; i < n; i++)\\n    {\\n        if (large < a[i])\\n            large = a[i];\\n    }\\n    return large;\\n}\\n\\nvoid RadixSort(int a[], int n)\\n{\\n    int bucket[10][10], bucket_count[10];\\n    int i, j, k, remainder, NOP = 0, divisor = 1, large, pass;\\n\\n    large = largest(a, n);\\n    printf(\\\"The large element %d\\\\n\\\", large);\\n    while (large > 0)\\n    {\\n        NOP++;\\n        large /= 10;\\n    }\\n\\n    for (pass = 0; pass < NOP; pass++)\\n    {\\n        for (i = 0; i < 10; i++)\\n        {\\n            bucket_count[i] = 0;\\n        }\\n        for (i = 0; i < n; i++)\\n        {\\n            remainder = (a[i] / divisor) % 10;\\n            bucket[remainder][bucket_count[remainder]] = a[i];\\n            bucket_count[remainder] += 1;\\n        }\\n\\n        i = 0;\\n        for (k = 0; k < 10; k++)\\n        {\\n            for (j = 0; j < bucket_count[k]; j++)\\n            {\\n                a[i] = bucket[k][j];\\n                i++;\\n            }\\n        }\\n        divisor *= 10;\\n\\n        for (i = 0; i < n; i++) printf(\\\"%d  \\\", a[i]);\\n        printf(\\\"\\\\n\\\");\\n    }\\n}\\n\\nint main()\\n{\\n    int i, n, a[10];\\n    printf(\\\"Enter the number of elements :: \\\");\\n    scanf(\\\"%d\\\", &n);\\n    printf(\\\"Enter the elements :: \\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n    RadixSort(a, n);\\n    printf(\\\"The sorted elements are ::  \\\");\\n    for (i = 0; i < n; i++) printf(\\\"%d  \\\", a[i]);\\n    printf(\\\"\\\\n\\\");\\n    return 0;\\n}\\n\"",
    "radix sort 2": "\"// sorting of array list using Radix sort\\r\\n#include <stdio.h>\\r\\n#include <stdlib.h>\\r\\n\\r\\n#define range 10  // Range for integers is 10 as digits range from 0-9\\r\\n\\r\\n// Utility function to get the maximum value in ar[]\\r\\nint MAX(int *ar, int size)\\r\\n{\\r\\n    int i, max = ar[0];\\r\\n    for (i = 0; i < size; i++)\\r\\n    {\\r\\n        if (ar[i] > max)\\r\\n            max = ar[i];\\r\\n    }\\r\\n    return max;\\r\\n}\\r\\n\\r\\n// Counting sort according to the digit represented by place\\r\\nvoid countSort(int *arr, int n, int place)\\r\\n{\\r\\n    int i, freq[range] = {0};\\r\\n    int *output = (int *)malloc(n * sizeof(int));\\r\\n\\r\\n    // Store count of occurences in freq[]\\r\\n    for (i = 0; i < n; i++) freq[(arr[i] / place) % range]++;\\r\\n\\r\\n    // Change freq[i] so that it contains the actual position of the digit in\\r\\n    // output[]\\r\\n    for (i = 1; i < range; i++) freq[i] += freq[i - 1];\\r\\n\\r\\n    // Build the output array\\r\\n    for (i = n - 1; i >= 0; i--)\\r\\n    {\\r\\n        output[freq[(arr[i] / place) % range] - 1] = arr[i];\\r\\n        freq[(arr[i] / place) % range]--;\\r\\n    }\\r\\n\\r\\n    // Copy the output array to arr[], so it contains numbers according to the\\r\\n    // current digit\\r\\n    for (i = 0; i < n; i++) arr[i] = output[i];\\r\\n    free(output);\\r\\n}\\r\\n\\r\\n/*This is where the sorting of the array takes place\\r\\n arr[] --- Array to be sorted\\r\\n n --- Array Size\\r\\n max --- Maximum element in Array\\r\\n */\\r\\nvoid radixsort2(int *arr, int n,\\r\\n                int max)  // max is the maximum element in the array\\r\\n{\\r\\n    int mul = 1;\\r\\n    while (max)\\r\\n    {\\r\\n        countSort(arr, n, mul);\\r\\n        mul *= 10;\\r\\n        max /= 10;\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid display(int *arr, int N)\\r\\n{\\r\\n    for (int i = 0; i < N; i++) printf(\\\"%d, \\\", arr[i]);\\r\\n    putchar('\\\\n');\\r\\n}\\r\\n\\r\\nint main(int argc, const char *argv[])\\r\\n{\\r\\n    int n;\\r\\n    printf(\\\"Enter size of array:\\\\n\\\");\\r\\n    scanf(\\\"%d\\\", &n);  // E.g. 8\\r\\n\\r\\n    printf(\\\"Enter the elements of the array\\\\n\\\");\\r\\n    int i;\\r\\n    int *arr = (int *)malloc(n * sizeof(int));\\r\\n    for (i = 0; i < n; i++)\\r\\n    {\\r\\n        scanf(\\\"%d\\\", &arr[i]);\\r\\n    }\\r\\n\\r\\n    printf(\\\"Original array: \\\");\\r\\n    display(arr, n);  // Original array : 10 11 9 8 4 7 3 8\\r\\n\\r\\n    int max;\\r\\n    max = MAX(arr, n);\\r\\n\\r\\n    radixsort2(arr, n, max);\\r\\n\\r\\n    printf(\\\"Sorted array: \\\");\\r\\n    display(arr, n);  // Sorted array : 3 4 7 8 8 9 10 11\\r\\n\\r\\n    free(arr);\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "random quick sort": "\"/*\\nRandomised quick sort implementation in C language.\\nIn normal quick sort, pivot chosen to partition is either the first or the last\\nelement of the array. This can take time O(n*n) to sort in the worst case. Now\\nin randomised quick sort, pivot is randomly chosen and then recursively sort the\\nleft and right sub-arrays. The expected running time of the algorithm is\\nO(nlog(n)).\\n*/\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint getBig(int *a, int i, int right, int pivot)\\n{\\n    for (int k = i; k <= right; k++)\\n    {\\n        if (a[k] > pivot)\\n            return k;\\n    }\\n    return right + 1;\\n}\\n\\nint getSmall(int *a, int j, int left, int pivot)\\n{\\n    for (int k = j; k >= left; k--)\\n    {\\n        if (a[k] < pivot)\\n            return k;\\n    }\\n    return -1;\\n}\\n\\nvoid swap(int *a, int *b)\\n{\\n    int t = *a;\\n    *a = *b;\\n    *b = t;\\n}\\n\\nvoid random_quick(int *a, int left, int right)\\n{\\n    if (left >= right)\\n        return;\\n    int index = left + (rand() % (right - left)), i = left, j = right;\\n    int pivot_index = index;\\n    int pivot = a[index];\\n    // storing index of element greater than pivot\\n    i = getBig(a, i, right, pivot);\\n    // storing index of element smaller than pivot\\n    j = getSmall(a, j, left, pivot);\\n    while (i <= j)\\n    {\\n        swap(&a[i], &a[j]);\\n        i = getBig(a, i, right, pivot);\\n        j = getSmall(a, j, left, pivot);\\n    }\\n    // after separating the smaller and greater elements, there are 3 cases\\n    // possible\\n    if (pivot_index > j && pivot_index > i)\\n    {\\n        // case 1. When the pivot element index is greater than both i and j\\n        swap(&a[i], &a[pivot_index]);\\n        random_quick(a, left, i - 1);\\n        random_quick(a, i + 1, right);\\n    }\\n    else if (pivot_index < j && pivot_index < i)\\n    {\\n        // case 2. When the pivot element index is smaller than both i and j\\n        swap(&a[j], &a[pivot_index]);\\n        random_quick(a, left, j - 1);\\n        random_quick(a, j + 1, right);\\n    }\\n    else\\n    {\\n        // the pivot element is at its origin position.\\n        random_quick(a, left, pivot_index - 1);\\n        random_quick(a, pivot_index + 1, right);\\n    }\\n}\\n\\nint main()\\n{\\n    srand(time(0));\\n    int num;\\n    scanf(\\\"%d\\\", &num);\\n    int *arr = (int *)malloc(num * sizeof(int));\\n    for (int i = 0; i < num; i++)\\n    {\\n        scanf(\\\"%d\\\", &arr[i]);\\n    }\\n    random_quick(arr, 0, num - 1);\\n    for (int i = 0; i < num; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n\\n    free(arr);\\n    printf(\\\"\\\\n\\\");\\n}\\n\"",
    "selection sort": "\"/**\\n * @file\\n * @brief [Selection sort](https://en.wikipedia.org/wiki/Selection_sort)\\n * algorithm implementation.\\n */\\n#include <assert.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n/**\\n * Swapped two numbers using pointer\\n * @param first first pointer of first number\\n * @param second second pointer of second number\\n */\\nvoid swap(int *first, int *second)\\n{\\n    int temp = *first;\\n    *first = *second;\\n    *second = temp;\\n}\\n\\n/**\\n * Selection sort algorithm implements\\n * @param arr array to be sorted\\n * @param size size of array\\n */\\nvoid selectionSort(int *arr, int size)\\n{\\n    for (int i = 0; i < size - 1; i++)\\n    {\\n        int min_index = i;\\n        for (int j = i + 1; j < size; j++)\\n        {\\n            if (arr[min_index] > arr[j])\\n            {\\n                min_index = j;\\n            }\\n        }\\n        if (min_index != i)\\n        {\\n            swap(arr + i, arr + min_index);\\n        }\\n    }\\n}\\n\\n/** Test function\\n  * @returns None\\n  */\\nstatic void test()\\n{\\n    const int size = rand() % 500; /* random array size */\\n    int *arr = (int *)calloc(size, sizeof(int));\\n\\n    /* generate size random numbers from -50 to 49 */\\n    for (int i = 0; i < size; i++)\\n    {\\n        arr[i] = (rand() % 100) - 50; /* signed random numbers */\\n    }\\n    selectionSort(arr, size);\\n    for (int i = 0; i < size - 1; ++i)\\n    {\\n        assert(arr[i] <= arr[i + 1]);\\n    }\\n    free(arr);\\n}\\n\\n/** Driver Code */\\nint main(int argc, const char *argv[])\\n{\\n    /* Intializes random number generator */\\n    srand(time(NULL));\\n    test();\\n    return 0;\\n}\\n\"",
    "selection sort recursive": "\"/**\\n * @file\\n * @author [Dhruv Pasricha](https://github.com/DhruvPasricha)\\n * @brief [Selection Sort](https://en.wikipedia.org/wiki/Selection_sort)\\n * implementation using recursion.\\n */\\n\\n#include <assert.h>     /// for assert\\n#include <stdio.h>      /// for IO operations\\n#include <stdlib.h>     /// for dynamic memory allocation\\n#include <time.h>       /// for random numbers generation\\n#include <inttypes.h>   /// for uint8_t, int8_t\\n\\n/**\\n * @brief Swapped two numbers using pointer\\n * @param first pointer of first number\\n * @param second pointer of second number\\n */\\nvoid swap(int8_t *first, int8_t *second)\\n{\\n    int8_t temp = *first;\\n    *first = *second;\\n    *second = temp;\\n}\\n\\n/**\\n * @brief Returns the index having minimum value using recursion\\n * @param arr array to be sorted\\n * @param size size of array\\n * @return min_index index of an element having a minimum value\\n*/\\nuint8_t findIndex(const int8_t *arr, const uint8_t size)\\n{\\n    if (size == 1)\\n    {\\n        return 0;\\n    }\\n\\n    // marking recursive call to reach starting element\\n    uint8_t min_index = findIndex(arr, size - 1);\\n\\n    if (arr[size - 1] < arr[min_index])\\n    {\\n        min_index = size - 1;\\n    }\\n\\n    return min_index;\\n}\\n\\n/**\\n * @brief Selection Sort algorithm implemented using recursion\\n * @param arr array to be sorted\\n * @param size size of the array\\n * @returns void\\n */\\nvoid selectionSort(int8_t *arr, const uint8_t size)\\n{\\n    if (size <= 1)\\n    {\\n        return;\\n    }\\n\\n    /* findIndex(arr, size) returned the index having min value*/\\n    uint8_t min_index = findIndex(arr, size);\\n    /* arr[min_index] is the minimum value in the array*/\\n\\n    if (min_index != 0)\\n    {\\n        swap(&arr[0], &arr[min_index]);\\n    }\\n\\n    /*sorted the remaining array recursively*/\\n    selectionSort(arr + 1, size - 1);\\n}\\n\\n/**\\n * @brief Self-test implementations\\n * @returns void\\n */\\nstatic void test()\\n{\\n    const uint8_t size = 10;\\n    int8_t *arr = (int8_t *)calloc(size, sizeof(int8_t));\\n\\n    /* generate size random numbers from 0 to 100 */\\n    for (uint8_t i = 0; i < size; i++)\\n    {\\n        arr[i] = rand() % 100;\\n    }\\n    selectionSort(arr, size);\\n    for (uint8_t i = 0; i < size - 1; ++i)\\n    {\\n        assert(arr[i] <= arr[i + 1]);\\n    }\\n    free(arr);\\n}\\n\\n/**\\n * @brief Main function\\n * @returns 0 on exit\\n */\\nint main()\\n{\\n    /* Intializes random number generator */\\n    srand(time(NULL));\\n\\n    test();  // run self-test implementations\\n    return 0;\\n}\\n\"",
    "shaker sort": "\"#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid swap(int *a, int *b)\\n{\\n    int temp;\\n    temp = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\nvoid shakersort(int *a, int n)\\n{\\n    int p, i;\\n    for (p = 1; p <= n / 2; p++)\\n    {\\n        for (i = p - 1; i < n - p; i++)\\n            if (a[i] > a[i + 1])\\n            {\\n                swap(&a[i], &a[i + 1]);\\n            }\\n        for (i = n - p - 1; i >= p; i--)\\n            if (a[i] < a[i - 1])\\n            {\\n                swap(&a[i], &a[i - 1]);\\n            }\\n    }\\n}\\nint main()\\n{\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int *arr = (int *)malloc(n * sizeof(int));\\n    int i;\\n    for (i = 0; i < n; i++) scanf(\\\"%d \\\", &arr[i]);\\n    shakersort(arr, n);\\n    for (i = 0; i < n; i++) printf(\\\"%d \\\", arr[i]);\\n    free(arr);\\n    return 0;\\n}\\n\"",
    "shell sort": "\"#include <stdio.h>\\r\\n#include <stdlib.h>\\r\\n#include <time.h>\\r\\n\\r\\n#define ELEMENT_NR 20000\\r\\n#define ARRAY_LEN(x) (sizeof(x) / sizeof((x)[0]))\\r\\nconst char *notation =\\r\\n    \\\"Shell Sort Big O Notation:\\\\\\r\\n\\t\\t\\t\\t\\t\\t\\\\n--> Best Case: O(n log(n)) \\\\\\r\\n\\t\\t\\t\\t\\t\\t\\\\n--> Average Case: depends on gap sequence \\\\\\r\\n\\t\\t\\t\\t\\t\\t\\\\n--> Worst Case: O(n)\\\";\\r\\n\\r\\nvoid show_data(int arr[], int len)\\r\\n{\\r\\n    int i;\\r\\n\\r\\n    for (i = 0; i < len; i++) printf(\\\"%3d \\\", arr[i]);\\r\\n    printf(\\\"\\\\n\\\");\\r\\n}\\r\\n\\r\\nvoid swap(int *a, int *b)\\r\\n{\\r\\n    int tmp;\\r\\n\\r\\n    tmp = *a;\\r\\n    *a = *b;\\r\\n    *b = tmp;\\r\\n}\\r\\n\\r\\nvoid shellSort(int array[], int len)\\r\\n{\\r\\n    int i, j, gap;\\r\\n\\r\\n    for (gap = len / 2; gap > 0; gap = gap / 2)\\r\\n        for (i = gap; i < len; i++)\\r\\n            for (j = i - gap; j >= 0 && array[j] > array[j + gap]; j = j - gap)\\r\\n                swap(&array[j], &array[j + gap]);\\r\\n}\\r\\n\\r\\nint main(int argc, char *argv[])\\r\\n{\\r\\n    int i;\\r\\n    int array[ELEMENT_NR];\\r\\n    int range = 500;\\r\\n    int size;\\r\\n    clock_t start, end;\\r\\n    double time_spent;\\r\\n\\r\\n    srand(time(NULL));\\r\\n    for (i = 0; i < ELEMENT_NR; i++) array[i] = rand() % range + 1;\\r\\n\\r\\n    size = ARRAY_LEN(array);\\r\\n\\r\\n    show_data(array, size);\\r\\n    start = clock();\\r\\n    shellSort(array, size);\\r\\n    end = clock();\\r\\n    time_spent = (double)(end - start) / CLOCKS_PER_SEC;\\r\\n\\r\\n    printf(\\\"Data Sorted\\\\n\\\");\\r\\n    show_data(array, size);\\r\\n\\r\\n    printf(\\\"%s\\\\n\\\", notation);\\r\\n    printf(\\\"Time spent sorting: %.4g ms\\\\n\\\", time_spent * 1e3);\\r\\n\\r\\n    return 0;\\r\\n}\\r\\n\"",
    "shell sort2": "\"/**\\n * \\\\file\\n * \\\\brief [Shell sort algorithm](https://en.wikipedia.org/wiki/Shell_sort)\\n * implementation.\\n * \\\\author [Krishna Vedala](https://github.com/kvedala)\\n */\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n/**\\n * @addtogroup sorting Sorting algorithms\\n * @{\\n */\\n/** Helper function to print array values */\\nvoid show_data(int *arr, long len)\\n{\\n    for (long i = 0; i < len; i++) printf(\\\"%3d \\\", arr[i]);\\n    printf(\\\"\\\\n\\\");\\n}\\n\\n/** Function to swap values of two integers\\n * @param [in,out] a reference to first variable\\n * @param [in,out] b reference to second variable\\n */\\ninline void swap(int *a, int *b)\\n{\\n    int tmp;\\n\\n    tmp = *a;\\n    *a = *b;\\n    *b = tmp;\\n}\\n\\n/**\\n * Shell sort algorithm.\\\\n\\n * Optimized algorithm - takes half the time as other\\n * @param [in,out] array array to sort\\n * @param [in] LEN length of the array\\n */\\nvoid shell_sort(int *array, long LEN)\\n{\\n    const int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};\\n    const int gap_len = 8;\\n    long i, j, g;\\n\\n    for (g = 0; g < gap_len; g++)\\n    {  // for each gap\\n        int gap = gaps[g];\\n        for (i = gap; i < LEN; i++)\\n        {  // from gap position to the end\\n            int tmp = array[i];\\n\\n            for (j = i; j >= gap && (array[j - gap] - tmp) > 0; j -= gap)\\n                array[j] = array[j - gap];\\n            array[j] = tmp;\\n        }\\n    }\\n#ifdef DEBUG\\n    for (i = 0; i < LEN; i++) printf(\\\"%s\\\\t\\\", data[i]);\\n#endif\\n}\\n/** @} */\\n\\n/** Main function */\\nint main(int argc, char *argv[])\\n{\\n    int i;\\n    long size = 500;\\n    if (argc == 2)\\n        size = atol(argv[1]);\\n    else if (argc > 2)\\n        fprintf(stderr, \\\"Usage: ./shell_sort [number of values]\\\\n\\\");\\n\\n    int *array = (int *)malloc(size * sizeof(int));\\n    int range = 500;  // range of array values\\n    double time_spent;\\n\\n    srand(time(NULL));  // initialize random number generator\\n    for (i = 0; i < size; i++)\\n        // fill array with random integers\\n        array[i] = rand() % range + 1;\\n\\n    show_data(array, size);   // show array before sorting\\n    clock_t t1 = clock();     // start timer\\n    shell_sort(array, size);  // sort the array\\n    clock_t t2 = clock();     // end timer\\n\\n    printf(\\\"Data Sorted\\\\n\\\");\\n    show_data(array, size);  // display array after sorting\\n\\n    printf(\\\"Time spent sorting: %.4g s\\\\n\\\", (t2 - t1) / CLOCKS_PER_SEC);\\n\\n    free(array);\\n    return 0;\\n}\\n\"",
    "stooge sort": "\"#include <stdio.h>\\nvoid stoogesort(int[], int, int);\\n\\nint main()\\n{\\n    int arr[100], i, n;\\n\\n    printf(\\\"How many elements do you want to sort: \\\");\\n    scanf(\\\"%d\\\", &n);\\n    for (i = 0; i < n; i++) scanf(\\\" %d\\\", &arr[i]);\\n    stoogesort(arr, 0, n - 1);\\n    printf(\\\"Sorted array : \\\\n\\\");\\n    for (i = 0; i < n; i++)\\n    {\\n        printf(\\\"%d \\\", arr[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n    return 0;\\n}\\n\\nvoid stoogesort(int arr[], int i, int j)\\n{\\n    int temp, k;\\n    if (arr[i] > arr[j])\\n    {\\n        temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    if ((i + 1) >= j)\\n        return;\\n    k = (int)((j - i + 1) / 3);\\n    stoogesort(arr, i, j - k);\\n    stoogesort(arr, i + k, j);\\n    stoogesort(arr, i, j - k);\\n}\\n\""
  }
}
