{
  "swift": {
    "fibonacci": "\"// The Fibonacci numbers, commonly denoted F(n) form a sequence,\\n// called the Fibonacci sequence, such that # each number is the sum\\n// of the two preceding ones, starting from 0 and 1. That is,\\n//\\n// F(0) = 0, F(1) = 1\\n// F(n) = F(n - 1) + F(n - 2), for n > 1\\n//\\n// Given n, calculate F(n).\\n//\\n// @leticiafaleia\\nfunc fibonacci(_ number: Int) -> Int {\\n    guard number > 1 else { return number }\\n    return fibonacci(number - 1) + fibonacci(number - 2)\\n}\\n\\nfibonacci(5)\\n\"",
    "binary search": "\"import Foundation\\n\\npublic func binarySearch<T: Comparable>(_ a: [T], key: T) -> Int? {\\n    var lowerBound = 0\\n    var upperBound = a.count\\n    while lowerBound < upperBound {\\n        let midIndex = lowerBound + (upperBound - lowerBound) / 2\\n        if a[midIndex] == key {\\n            return midIndex\\n        } else if a[midIndex] < key {\\n            lowerBound = midIndex + 1\\n        } else {\\n            upperBound = midIndex\\n        }\\n    }\\n    return nil\\n}\\n// The code below can be used for testing\\n\\n// var numbers = [7, 10, 13, 17, 19, 24, 29, 31, 32, 37, 41, 43, 47, 51, 53, 119, 163, 611, 627]\\n// if let searchIndex = binarySearch(numbers, key: 10) {\\n//     print(\\\"Element found on index: \\\\(searchIndex)\\\")\\n// }\\n// else {\\n// print(\\\"Element not found\\\")\\n// }\\n\\n\"",
    "linear search": "\"import Foundation\\n\\nfunc linearSearch<T: Equatable>(_ array: [T], _ object: T) -> Int? {\\n  for (index, obj) in array.enumerated() where obj == object {\\n    return index\\n  }\\n  return nil\\n}\\n\\n// The code below can be used for testing\\n\\n// var numbers = [10, 119, 13, 24, 53, 17, 31, 7, 19, 627, 47, 163, 37, 611, 29, 43, 51, 41, 32]\\n// if let searchIndex = linearSearch(numbers,31) {\\n//     print(\\\"Element found on index: \\\\(searchIndex)\\\")\\n// }\\n// else {\\n// print(\\\"Element not found\\\")\\n// }\\n\"",
    "bubble sort": "\"import Foundation\\n\\nextension Array where Element: Comparable {\\n\\n    func bubbleSort(by areInIncreasingOrder: ((Element, Element) -> Bool) = (<)) -> [Element] {\\n        var data = self\\n        \\n        for i in 0..<(data.count-1) { \\n            for j in 0..<(data.count-i-1) where areInIncreasingOrder(data[j+1], data[j]) { \\n                data.swapAt(j, j + 1)\\n            }\\n        }\\n        \\n        return data\\n    }\\n}\\n\\nfunc swap<T: Comparable>(left: inout T, right: inout T) {\\n    print(\\\"Swapping \\\\(left) and \\\\(right)\\\")\\n    let temp = right\\n    right = left\\n    left = temp\\n}\\n\\n// The code below can be used for testing\\n\\n// let numberList : Array<Int> = [8, 2, 10, 9, 7, 5]\\n// let results: Array<Int> = numberList.bubbleSort()\\n// print(results)\\n\"",
    "insertion sort": "\"import Foundation\\n\\nfunc insertionSort<T>(_ array: [T], by comparison: (T, T) -> Bool) -> [T] {\\n    guard array.count > 1 else { return array }\\n    \\n    var sortedArray = array\\n    \\n    for index in 1..<sortedArray.count {\\n        var currentIndex = index\\n        let temp = sortedArray[currentIndex]\\n        \\n        while currentIndex > 0, comparison(temp, sortedArray[currentIndex - 1]) {\\n            sortedArray[currentIndex] = sortedArray[currentIndex - 1]\\n            currentIndex -= 1\\n        }\\n        sortedArray[currentIndex] = temp\\n    }\\n    \\n    return sortedArray\\n}\\n\\n// The code below can be used for testing\\n\\n/*\\nlet numbers = [10, 1, 3, 8, 4, 2]\\n\\nprint(insertionSort(numbers, by: >))\\nprint(insertionSort(numbers, by: <))\\n\\nlet names = [\\\"Jack\\\", \\\"Paul\\\", \\\"Olivia\\\", \\\"Emma\\\", \\\"Michael\\\"]\\n\\nprint(insertionSort(names, by: >))\\nprint(insertionSort(names, by: <))\\n*/\\n\"",
    "merge sort": "\"\\nimport Foundation\\n\\nextension Array where Element: Comparable {\\n\\t\\n\\tmutating func mergeSort(by comparison: (Element, Element) -> Bool) {\\n\\t\\tguard self.count > 1 else {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\t_mergeSort(from: 0, to: count - 1, by: comparison)\\n\\t}\\n\\t\\n\\tmutating private func _mergeSort(\\n\\t\\tfrom left: Int,\\n\\t\\tto right: Int,\\n\\t\\tby comparison: (Element, Element) -> Bool\\n\\t) {\\n\\t\\tif left < right {\\n\\t\\t\\tlet mid = left + (right - left) / 2\\n\\t\\t\\t_mergeSort(from: 0, to: mid, by: comparison)\\n\\t\\t\\t_mergeSort(from: mid + 1, to: right, by: comparison)\\n\\t\\t\\t_merge(from: left, mid: mid, to: right, by: comparison)\\n\\t\\t}\\n\\t}\\n\\t\\n\\tmutating private func _merge(\\n\\t\\tfrom left: Int,\\n\\t\\tmid: Int,\\n\\t\\tto right: Int,\\n\\t\\tby comparison: (Element, Element) -> Bool\\n\\t) {\\n\\t\\tvar copy = [Element](repeating: self[left], count: right - left + 1)\\n\\t\\tvar (leftStartIndex, rightStartIndex, currentIndex) = (left, mid + 1, 0)\\n\\t\\tfor _ in left ... right {\\n\\t\\t\\tif leftStartIndex > mid {\\n\\t\\t\\t\\tcopy[currentIndex] = self[rightStartIndex]\\n\\t\\t\\t\\trightStartIndex += 1\\n\\t\\t\\t} else if rightStartIndex > right {\\n\\t\\t\\t\\tcopy[currentIndex] = self[leftStartIndex]\\n\\t\\t\\t\\tleftStartIndex += 1\\n\\t\\t\\t} else if comparison(self[leftStartIndex], self[rightStartIndex]) {\\n\\t\\t\\t\\tcopy[currentIndex] = self[leftStartIndex]\\n\\t\\t\\t\\tleftStartIndex += 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcopy[currentIndex] = self[rightStartIndex]\\n\\t\\t\\t\\trightStartIndex += 1\\n\\t\\t\\t}\\n\\t\\t\\tcurrentIndex += 1\\n\\t\\t}\\n\\t\\tleftStartIndex = left\\n\\t\\tfor i in copy.indices {\\n\\t\\t\\tself[leftStartIndex] = copy[i]\\n\\t\\t\\tleftStartIndex += 1\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunc mergeSorted(by comparison: (Element, Element) -> Bool) -> Array {\\n\\t\\tvar copy = self\\n\\t\\tcopy.mergeSort(by: comparison)\\n\\t\\treturn copy\\n\\t}\\n\\t\\n}\\n\\n// The code below can be used for testing\\n// var numberList = [15, 2, 23, 11, 3, 9]\\n// debugPrint(numberList.mergeSorted(by: >))\\n// numberList.mergeSort(by: <)\\n// debugPrint(numberList)\\n\"",
    "quick sort": "\"import Foundation\\n\\nextension Array where Element: Comparable {\\n    /// Sorts the array using the QuickSort algorithm in place.\\n    ///\\n    /// The QuickSort algorithm sorts the array by first choosing a pivot. This pivot is used to rearrange\\n    /// all elements, moving the smaller ones to the left of it. This operation is then recursevely applied\\n    /// to the subarrays formed around the pivot.\\n    mutating func quickSort() {\\n        guard count > 1 else {\\n            return\\n        }\\n        \\n        _quickSort(from: 0, to: count - 1)\\n    }\\n    \\n    mutating private func _quickSort(from left: Int, to right: Int) {\\n        guard left < right, right - left > 0 else {\\n            return\\n        }\\n        \\n        let pivotIndex = partition(from: left, to: right)\\n        _quickSort(from: left, to: pivotIndex - 1)\\n        _quickSort(from: pivotIndex + 1, to: right)\\n    }\\n    \\n    /// This method is where the pivot is chosen, so the smaller elements get moved to the left,\\n    /// and the bigger ones to the right.\\n    mutating private func partition(from left: Int, to right: Int) -> Int {\\n        /// Chooses the pivot, which in this case is always the first element, which is not very efficient.\\n        let pivotIndex = left\\n        swapAt(pivotIndex, right)\\n        \\n        let pivot = self[right]\\n        var i = left\\n        \\n        for j in i ..< right {\\n            // If the element is smaller than the pivot, move it to the left.\\n            if self[j] <= pivot {\\n                swapAt(i, j)\\n                i += 1\\n            }\\n        }\\n        \\n        // Move the pivot to its right sorted position.\\n        swapAt(i, right)\\n        \\n        return i\\n    }\\n    \\n    /// Returns a sorted version of this array using the QuickSort algorithm.\\n    func quickSorted() -> Array {\\n        var copy = self\\n        \\n        copy.quickSort()\\n        \\n        return copy\\n    }\\n}\\n\\n// Use the following code to test it:\\n// var numbers = [1002, 42, 55, 124, 205]\\n// debugPrint(numbers.quickSorted())\\n//\\n// numbers.quickSort()\\n// debugPrint(numbers)\\n//\\n// The console should print:\\n// [42, 55, 124, 205, 1002]\\n// [42, 55, 124, 205, 1002]\\n\"",
    "selection sort": "\"import Foundation\\n\\nextension Array where Element: Comparable {\\nfunc selectionSort() -> Array<Element> {     \\n        \\n        guard self.count > 1 else {\\n            return self\\n        }        \\n        \\n        var output: Array<Element> = self\\n                \\n        for primaryindex in 0..<output.count {\\n                        \\n            var minimum = primaryindex\\n            var secondaryindex = primaryindex + 1\\n                        \\n            while secondaryindex < output.count {\\n         \\n                if output[minimum] > output[secondaryindex] {\\n                    minimum = secondaryindex\\n                }                \\n                secondaryindex += 1\\n            }\\n            \\n            if primaryindex != minimum {\\n            output.swapAt(primaryindex, minimum)\\n            }            \\n        }\\n                \\n        return output        \\n    }\\n}\\n\\n// The code below can be used for testing\\n\\n// let numberList : Array<Int> = [15, 2, 23, 11, 3, 9]\\n// let results: Array<Int> = numberList.selectionSort()\\n// print(results)\\n\"",
    "tree": "\"import Foundation\\n\\npublic class TreeNode<T> {\\n    public var value: T\\n\\n    public weak var parent: TreeNode?\\n    public var children = [TreeNode<T>]()\\n\\n    public init(value: T) {\\n        self.value = value\\n    }\\n\\n    public func addChild(_ node: TreeNode<T>) {\\n        children.append(node)\\n        node.parent = self\\n    }\\n}\\n\\n/* Checks the node's value property, if there is no match, check the child nodes.\\nRepeat the same process recursively */\\nextension TreeNode where T: Equatable {\\n    func search(_ value: T) -> TreeNode? {\\n        if value == self.value {\\n            return self\\n        }\\n        for child in children {\\n            if let found = child.search(value) {\\n                return found\\n            }\\n        }\\n        return nil\\n    }\\n}\\n\\n// The code below can be used for testing\\nlet tree = TreeNode<String>(value: \\\"animals\\\")\\n\\nlet reptilesNode = TreeNode<String>(value: \\\"reptiles\\\")\\nlet mammalsNode = TreeNode<String>(value: \\\"mammals\\\")\\n\\nlet lizardsNode = TreeNode<String>(value: \\\"lizards\\\")\\nlet snakesNode = TreeNode<String>(value: \\\"snakes\\\")\\n\\nlet dogsNode = TreeNode<String>(value: \\\"dogs\\\")\\nlet humansNode = TreeNode<String>(value: \\\"humans\\\")\\n\\ntree.addChild(reptilesNode)\\ntree.addChild(mammalsNode)\\n\\nreptilesNode.addChild(lizardsNode)\\nreptilesNode.addChild(snakesNode)\\n\\nmammalsNode.addChild(dogsNode)\\nmammalsNode.addChild(humansNode)\\n\\nprint(tree.search(\\\"humans\\\")?.value)\\nprint(tree.search(\\\"lizards\\\")?.value)\\nprint(tree.search(\\\"dragons\\\")?.value)\\n\"",
    "heap": "\"struct Heap<Element> {\\n    let compare: (Element, Element) -> Bool\\n    private var items : [Element]\\n\\n    init(_ items : [Element], compare: @escaping (Element, Element) -> Bool) {\\n        self.compare = compare\\n        self.items = items\\n        for index in (0 ..< count / 2).reversed() {\\n            heapify(index)\\n        }\\n    }\\n\\n    /// The minimum item on this heap or nil if the heap is empty\\n    var min: Element? {\\n        return items.first\\n    }\\n\\n    /// The number of items on this heap\\n    var count: Int {\\n        return items.count\\n    }\\n\\n    /// true if this heap is empty\\n    var isEmpty: Bool {\\n        return items.isEmpty\\n    }\\n\\n    /// Removes and returns the minimum item from the heap.\\n    /// - returns: The minimum item from the heap or nil if the heap is empty.\\n    mutating func extractMin() -> Element? {\\n        guard let result = items.first else { return nil }\\n\\n        items.removeFirst()\\n        heapify(0)\\n        return result\\n\\n    }\\n\\n    /// Inserts a new item into this heap\\n    /// - parameter item: The new item to insert\\n    mutating func insert(item : Element) {\\n        items.append(item)\\n        var i = items.count - 1\\n        while i > 0 && compare(items[i], items[parent(i)]) {\\n            items.swapAt(i, parent(i))\\n            i = parent(i)\\n        }\\n    }\\n\\n    /// Restores the heap property starting at a given index\\n    /// - parameter index: The index to start at\\n    private mutating func heapify(_ index : Int) {\\n        var minimumIndex = index\\n        if left(index) < count && compare(items[left(index)], items[minimumIndex]) {\\n            minimumIndex = left(index)\\n        }\\n\\n        if right(index) < count && compare(items[right(index)], items[minimumIndex]) {\\n            minimumIndex = right(index)\\n        }\\n\\n        if minimumIndex != index {\\n            items.swapAt(minimumIndex, index)\\n            heapify(minimumIndex)\\n        }\\n    }\\n\\n    /// Returns the index of the left child of an item\\n    private func left(_ index : Int) -> Int {\\n        return 2 * index + 1\\n    }\\n\\n    /// Returns the index of the right child of an item\\n    private func right(_ index: Int) -> Int {\\n        return 2 * index + 2\\n    }\\n\\n    /// Returns the index of the parent of an item\\n    private func parent(_ index: Int) -> Int {\\n        return (index - 1) / 2\\n    }\\n}\\n\\n\\nextension Heap: ExpressibleByArrayLiteral where Element: Comparable {\\n    init(arrayLiteral elements: Element...) {\\n        self.init(elements, compare: <)\\n    }\\n\\n    init(_ elements: [Element]) {\\n        self.init(elements, compare: <)\\n    }\\n}\\n\"",
    "linked list": "\"import Foundation\\n\\npublic class Node<Value> {\\n    public var value: Value?\\n    public var next: Node?\\n    \\n    public init(value: Value? = nil, next: Node<Value>? = nil) {\\n        self.value = value\\n        self.next = next\\n    }\\n}\\n\\nextension Node: CustomStringConvertible {\\n    public var description: String {\\n        guard let next = next else {\\n            return \\\"\\\\(String(describing: value))\\\"\\n        }\\n        return \\\"\\\\(String(describing: value)) -> \\\" + String(describing: next) + \\\" \\\"\\n    }\\n}\\n\\npublic struct LinkedList<Value> {\\n    \\n    public var head: Node<Value>?\\n    public var tail: Node<Value>?\\n    \\n    public init() {}\\n    \\n    public var isEmpty: Bool {\\n        return head == nil\\n    }\\n    public mutating func push(_ value: Value) {\\n        head = Node(value: value, next: head)\\n        \\n        if tail == nil {\\n            tail = head\\n        }\\n    }\\n    \\n    public mutating func append(_ value: Value) {\\n        guard !isEmpty else {\\n            push(value)\\n            return\\n        }\\n        \\n        tail!.next = Node(value: value)\\n        \\n        tail = tail!.next\\n    }\\n\\n    public func node(at index: Int) -> Node<Value>? {\\n        var currentNode = head\\n        var currentIndex = 0\\n        \\n        while currentNode != nil && currentIndex < index {\\n            currentNode = currentNode!.next\\n            currentIndex += 1\\n        }\\n        \\n        return currentNode\\n    }\\n\\n    @discardableResult\\n    public mutating func insert(_ value: Value,\\n                                after node: Node<Value>) -> Node<Value> {\\n        guard tail !== node else {\\n          append(value)\\n          return tail!\\n        }\\n        node.next = Node(value: value, next: node.next)\\n        \\n        return node.next!\\n    }\\n    \\n    @discardableResult\\n    public mutating func pop() -> Value? {\\n        defer {\\n            head = head?.next\\n            if isEmpty {\\n                tail = nil\\n            }\\n        }\\n        return head?.value\\n    }\\n    \\n    @discardableResult\\n    public mutating func removeLast() -> Value? {\\n      guard let head = head else {\\n    return nil\\n    }\\n      guard head.next != nil else {\\n        return pop()\\n      }\\n      var prev = head\\n      var current = head\\n      while let next = current.next {\\n        prev = current\\n        current = next\\n      }\\n      prev.next = nil\\n      tail = prev\\n      return current.value\\n    }\\n    \\n    @discardableResult\\n    public mutating func remove(after node: Node<Value>) -> Value? {\\n      defer {\\n        if node.next === tail {\\n          tail = node \\n        }\\n        node.next = node.next?.next\\n      }\\n      return node.next?.value\\n    }\\n}\\n\\nextension LinkedList: CustomStringConvertible {\\n    public var description: String {\\n        guard let head = head else {\\n          return \\\"Empty list\\\"\\n        }\\n        return String(describing: head)\\n      }\\n}\\n\\n// Below you can find a testing Scenario for Playground.\\n\\n/*\\n import UIKit\\n\\n // Test Linked List\\n\\n let node1 = Node(value: 1)\\n let node2 = Node(value: 2)\\n let node3 = Node(value: 3)\\n\\n node1.next = node2\\n node2.next = node3\\n\\n print(node1)\\n\\n var list = LinkedList<Int>()\\n list.push(3)\\n list.push(2)\\n list.push(1)\\n\\n print(list)\\n\\n var listAppend = LinkedList<Int>()\\n\\n listAppend.append(1)\\n listAppend.append(2)\\n listAppend.append(3)\\n\\n print(listAppend)\\n */\\n\"",
    "queue": "\"// Create simple queue\\n// Tejas Nanaware\\n\\nstruct Queue<T> {\\n  private var elements: [T] = []\\n\\n  mutating func push(_ value: T) {\\n    elements.append(value)\\n  }\\n\\n  mutating func pop() -> T? {\\n    guard !elements.isEmpty else { \\n      return nil\\n    }\\n    return elements.removeFirst()\\n  }\\n}\\n\\nvar queue = Queue<String>()\\n\\nqueue.push(\\\"One\\\")\\nqueue.push(\\\"Two\\\")\\nqueue.push(\\\"Three\\\")\\n\\nprint(queue.pop())\\nprint(queue)\\nprint(queue.pop())\\nprint(queue)\\nprint(queue.pop())\\nprint(queue)\\n\"",
    "stack": "\"import Foundation\\n\\npublic struct Stack<T> {\\n    private var elements = [T]()\\n    \\n    public mutating func push(_ element: T) {\\n        elements.append(element)\\n    }\\n    \\n    public mutating func pop() -> T? {\\n        return elements.popLast()\\n    }\\n    \\n    public var isEmpty: Bool {\\n        return elements.isEmpty\\n    }\\n    \\n    public var count: Int {\\n        return elements.count\\n    }\\n    \\n    public var peek: T? {\\n        return elements.last\\n    }\\n}\\n\\n// The code below can be used for testing\\n\\nvar stack = Stack<Int>()\\n\\nstack.push(10)\\nstack.push(20)\\nstack.push(30)\\n\\nprint(stack.count)\\nprint(stack.peek)\\nprint(stack.isEmpty)\\n\\nprint(stack.pop())\\nprint(stack.pop())\\nprint(stack.pop())\\nprint(stack.isEmpty)\\nprint(stack.count)\\n\"",
    "union find": "\"class UnionFindNode {\\n    var rank = 0\\n\\n    private var parent: UnionFindNode? = nil\\n\\n    func findRoot() -> UnionFindNode {\\n        var x = self\\n        while let parent = x.parent {\\n            x.parent = parent.parent ?? parent\\n            x = parent\\n        }\\n        return x\\n    }\\n\\n    @discardableResult\\n    static func union(_ x: UnionFindNode, _ y: UnionFindNode) -> UnionFindNode {\\n        var x = x.findRoot()\\n        var y = y.findRoot()\\n\\n        guard x !== y else { return x }\\n\\n        if x.rank < y.rank {\\n            swap(&x, &y)\\n        }\\n\\n        y.parent = x\\n        if x.rank == y.rank {\\n            x.rank = y.rank + 1\\n        }\\n        \\n        return x\\n    }\\n\\n    static func inSameSet(_ x: UnionFindNode, _ y: UnionFindNode) -> Bool {\\n        return x.findRoot() === y.findRoot()\\n    }\\n}\\n\\n\\nfunc testUnionFind() {\\n    let a = UnionFindNode()\\n    let b = UnionFindNode()\\n    let c = UnionFindNode()\\n\\n    print(\\\"a, b\\\", UnionFindNode.inSameSet(a, b))\\n    print(\\\"b, c\\\", UnionFindNode.inSameSet(b, c))\\n    print(\\\"a, c\\\", UnionFindNode.inSameSet(a, c))\\n\\n    print(\\\"Joining a, b\\\")\\n\\n    UnionFindNode.union(a, b)\\n    print(\\\"a, b\\\", UnionFindNode.inSameSet(a, b))\\n    print(\\\"b, c\\\", UnionFindNode.inSameSet(b, c))\\n    print(\\\"a, c\\\", UnionFindNode.inSameSet(a, c))\\n\\n    print(\\\"Joining b, c\\\")\\n\\n    UnionFindNode.union(b, c)\\n    print(\\\"a, b\\\", UnionFindNode.inSameSet(a, b))\\n    print(\\\"b, c\\\", UnionFindNode.inSameSet(b, c))\\n    print(\\\"a, c\\\", UnionFindNode.inSameSet(a, c))\\n\\n\\n    print(\\\"New node d\\\")\\n    let d = UnionFindNode()\\n\\n    print(\\\"a, d\\\", UnionFindNode.inSameSet(a, d))\\n\\n    print(\\\"Joining d, c\\\")\\n    UnionFindNode.union(d, c)\\n    print(\\\"a, d\\\", UnionFindNode.inSameSet(a, d))\\n\\n}\\n\""
  }
}
