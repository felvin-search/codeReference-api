{
  "dart": {
    "validate subsequence": "\"import 'package:test/test.dart';\\n\\nbool checkIsSubSequence(List<int> array, List<int> sequence) {\\n  if (array.isEmpty) {\\n    return false;\\n  }\\n\\n  if (sequence.isEmpty) {\\n    return true;\\n  }\\n  int arrayIndex = 0;\\n  int sequenceIndex = 0;\\n\\n  while (sequenceIndex < sequence.length && arrayIndex < array.length) {\\n    if (sequence[sequenceIndex] == array[arrayIndex]) {\\n      sequenceIndex += 1;\\n    }\\n    arrayIndex += 1;\\n  }\\n  return sequenceIndex == sequence.length;\\n}\\n\\nvoid main() {\\n  List<int> array;\\n  List<int> sequence;\\n\\n  test('test 1', () {\\n    array = [5, 1, 22, 25, 6, -1, 8, 10];\\n    sequence = [1, 6, -1, 10];\\n    expect(checkIsSubSequence(array, sequence), isTrue);\\n  });\\n\\n  test('test 2', () {\\n    array = [5, 1, 22, 25, 6, -1, 8, 10];\\n    sequence = [5, -1, 8, 10];\\n    expect(checkIsSubSequence(array, sequence), isTrue);\\n  });\\n\\n  test('test 3', () {\\n    array = [1, 1, 1, 1, 1];\\n    sequence = [0, 0, 0, 0];\\n    expect(checkIsSubSequence(array, sequence), isFalse);\\n  });\\n\\n  test('test 4', () {\\n    array = [1, 6, -1, 10];\\n    sequence = [1, 6, -1, 10];\\n    expect(checkIsSubSequence(array, sequence), isTrue);\\n  });\\n\\n  test('test 5', () {\\n    array = [1, 1, 6, 1];\\n    sequence = [0];\\n    expect(checkIsSubSequence(array, sequence), isFalse);\\n  });\\n\\n  test('test 6', () {\\n    array = [];\\n    sequence = [0];\\n    expect(checkIsSubSequence(array, sequence), isFalse);\\n  });\\n\\n  test('test 7', () {\\n    array = [1, 1, 6, 1];\\n    sequence = [];\\n    expect(checkIsSubSequence(array, sequence), isTrue);\\n  });\\n}\\n\"",
    "open knight tour": "\"import 'dart:io';\\n\\nimport 'package:test/test.dart';\\n\\nList<List<int>> getValidPos(List<int> position, int n) {\\n  final i = position[0];\\n  final j = position[1];\\n  final positions = [\\n    [i + 1, j + 2],\\n    [i - 1, j + 2],\\n    [i + 1, j - 2],\\n    [i - 1, j - 2],\\n    [i + 2, j + 1],\\n    [i + 2, j - 1],\\n    [i - 2, j + 1],\\n    [i - 2, j - 1],\\n  ];\\n\\n  final List<List<int>> permissiblePositions = [];\\n  for (final currPosition in positions) {\\n    final iTest = currPosition[0];\\n    final jTest = currPosition[1];\\n    if (0 <= iTest && iTest < n && 0 <= jTest && jTest < n) {\\n      permissiblePositions.add(currPosition);\\n    }\\n  }\\n  return permissiblePositions;\\n}\\n\\nbool isComplete(List<List<int>> board) {\\n  for (final row in board) {\\n    for (final elem in row) {\\n      if (elem == 0) {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n}\\n\\nbool openKnightTourHelper(List<List<int>> board, List<int> pos, int curr) {\\n  if (isComplete(board)) {\\n    return true;\\n  }\\n\\n  for (final position in getValidPos(pos, board.length)) {\\n    final i = position[0];\\n    final j = position[1];\\n\\n    if (board[i][j] == 0) {\\n      board[i][j] = curr + 1;\\n      if (openKnightTourHelper(board, position, curr + 1)) {\\n        return true;\\n      }\\n      board[i][j] = 0;\\n    }\\n  }\\n  return false;\\n}\\n\\nList<List<int>> openKnightTour(int n) {\\n  // board creation\\n  final List<List<int>> board = [];\\n  for (var i = 0; i < n; i++) {\\n    final List<int> row = [];\\n    for (var j = 0; j < n; j++) {\\n      row.add(0);\\n    }\\n    board.add(row);\\n  }\\n  // open knight tour with backtracking\\n  for (var i = 0; i < n; i++) {\\n    for (var j = 0; j < n; j++) {\\n      board[i][j] = 1;\\n      if (openKnightTourHelper(board, [i, j], 1)) {\\n        return board;\\n      }\\n      board[i][j] = 0;\\n    }\\n  }\\n  return board;\\n}\\n\\nvoid printBoard(List<List<int>> board) {\\n  for (final row in board) {\\n    for (final elem in row) {\\n      stdout.write(elem);\\n    }\\n    stdout.write(\\\"\\\\n\\\");\\n  }\\n  stdout.write(\\\"\\\\n\\\");\\n}\\n\\nvoid main() {\\n  test(('getValidPos: testCase #1'), () {\\n    expect(\\n        getValidPos([1, 3], 4),\\n        equals([\\n          [2, 1],\\n          [0, 1],\\n          [3, 2]\\n        ]));\\n  });\\n\\n  test(('getValidPos: testCase #3'), () {\\n    expect(\\n        getValidPos([1, 2], 5),\\n        equals([\\n          [2, 4],\\n          [0, 4],\\n          [2, 0],\\n          [0, 0],\\n          [3, 3],\\n          [3, 1]\\n        ]));\\n  });\\n\\n  test(('isComplete: testCase #1'), () {\\n    expect(\\n        isComplete([\\n          [1]\\n        ]),\\n        equals(true));\\n  });\\n\\n  test(('isComplete: testCase #2'), () {\\n    expect(\\n        isComplete([\\n          [1, 2],\\n          [3, 0]\\n        ]),\\n        equals(false));\\n  });\\n\\n  test(('openKnightTour: testCase #1'), () {\\n    expect(\\n        openKnightTour(1),\\n        equals([\\n          [1]\\n        ]));\\n  });\\n\\n  test(('openKnightTour: testCase #2'), () {\\n    expect(\\n        openKnightTour(2),\\n        equals([\\n          [0, 0],\\n          [0, 0]\\n        ]));\\n  });\\n\\n  test(('openKnightTour: testCase #3'), () {\\n    expect(\\n        openKnightTour(5),\\n        equals([\\n          [1, 14, 19, 8, 25],\\n          [6, 9, 2, 13, 18],\\n          [15, 20, 7, 24, 3],\\n          [10, 5, 22, 17, 12],\\n          [21, 16, 11, 4, 23]\\n        ]));\\n  });\\n}\\n\"",
    "binary to decimal": "\"import \\\"dart:math\\\" show pow;\\n\\nvoid main() {\\n  print(binary_to_decimal(\\\"-111\\\")); // -7\\n  print(binary_to_decimal(\\\" 101011 \\\")); // 43\\n  try {\\n    print(binary_to_decimal(\\\"1a1\\\")); //error\\n  } catch (ex) {\\n    print(ex);\\n  }\\n}\\n\\nint binary_to_decimal(String bin_string) {\\n  bin_string = bin_string.trim();\\n  if (bin_string == null || bin_string == \\\"\\\") {\\n    throw Exception(\\\"An empty value was passed to the function\\\");\\n  }\\n  bool is_negative = bin_string[0] == \\\"-\\\";\\n  if (is_negative) bin_string = bin_string.substring(1);\\n  int decimal_val = 0;\\n  for (int i = 0; i < bin_string.length; i++) {\\n    if (\\\"01\\\".contains(bin_string[i]) == false) {\\n      throw Exception(\\\"Non-binary value was passed to the function\\\");\\n    } else {\\n      decimal_val +=\\n          pow(2, bin_string.length - i - 1) * int.parse((bin_string[i]));\\n    }\\n  }\\n  return is_negative ? -1 * decimal_val : decimal_val;\\n}\\n\"",
    "binary to hexadecimal": "\"import 'package:test/test.dart';\\n\\n//Binary number to hexadecimal number conversion\\nMap<String, String> hex_table = {\\n  \\\"0000\\\": '0',\\n  \\\"0001\\\": '1',\\n  \\\"0010\\\": '2',\\n  \\\"0011\\\": '3',\\n  \\\"0100\\\": '4',\\n  \\\"0101\\\": '5',\\n  \\\"0110\\\": '6',\\n  \\\"0111\\\": '7',\\n  \\\"1000\\\": '8',\\n  \\\"1001\\\": '9',\\n  \\\"1010\\\": 'A',\\n  \\\"1011\\\": 'B',\\n  \\\"1100\\\": 'C',\\n  \\\"1101\\\": 'D',\\n  \\\"1110\\\": 'E',\\n  \\\"1111\\\": 'F',\\n};\\n\\n// function to take a binary string and to return hex value\\nString binary_to_hexadecimal(String bin_string) {\\n  // checking for unexpected values\\n  bin_string = bin_string.trim();\\n  if (bin_string == null || bin_string == \\\"\\\") {\\n    throw new FormatException(\\\"An empty value was passed to the function\\\");\\n  }\\n  try {\\n    int.parse(bin_string);\\n  } catch (e) {\\n    throw new FormatException(\\\"An invalid value was passed to the function\\\");\\n  }\\n\\n  // negative number check\\n  bool is_negative = bin_string[0] == \\\"-\\\";\\n  if (is_negative) bin_string = bin_string.substring(1);\\n\\n  // add min 0's in the end to make right substring length divisible by 4\\n  var len_bin = bin_string.length;\\n  for (int i = 1; i <= (4 - len_bin % 4) % 4; i++)\\n    bin_string = '0' + bin_string;\\n\\n  // coverting the binary values to hex by diving into substring\\n  String hex_val = \\\"\\\";\\n  int i = 0;\\n  while (i != bin_string.length) {\\n    String bin_curr = bin_string.substring(i, i + 4);\\n    hex_val += hex_table[bin_curr];\\n    i += 4;\\n  }\\n\\n  // returning the value\\n  if (is_negative) {\\n    return \\\"-\\\" + hex_val;\\n  }\\n  return hex_val;\\n}\\n\\n// driver function\\nvoid main() {\\n  test(\\\"binary_to_hexadecimal -1111\\\", () {\\n    expect(binary_to_hexadecimal(\\\"-1111\\\"), equals(\\\"-F\\\"));\\n  });\\n\\n  test(\\\"binary_to_hexadecimal 101011\\\", () {\\n    expect(binary_to_hexadecimal(\\\"101011\\\"), equals(\\\"2B\\\"));\\n  });\\n\\n  test(\\\"binary_to_hexadecimal rasies error when number is invalid\\\", () {\\n    expect(() => binary_to_hexadecimal(\\\"-1011a01\\\"), throwsFormatException);\\n  });\\n\\n  test(\\\"binary_to_hexadecimal of empty string raises error\\\", () {\\n    expect(() => binary_to_hexadecimal(\\\"\\\"), throwsFormatException);\\n  });\\n}\\n\"",
    "binary to octal": "\"import 'package:test/test.dart';\\n\\n//Binary number to octal number conversion\\nvoid main() {\\n  test(\\\"binary_to_octal -1111\\\", () {\\n    expect(binary_to_octal(\\\"-1111\\\"), equals(\\\"-17\\\"));\\n  });\\n\\n  test(\\\"binary_to_octal 101011\\\", () {\\n    expect(binary_to_octal(\\\"101011\\\"), equals(\\\"53\\\"));\\n  });\\n\\n  test(\\\"binary_to_octal rasies error when number is invalid\\\", () {\\n    expect(() => binary_to_octal(\\\"-1011a01\\\"), throwsFormatException);\\n  });\\n\\n  test(\\\"binary_to_octal of empty string raises error\\\", () {\\n    expect(() => binary_to_octal(\\\"\\\"), throwsFormatException);\\n  });\\n}\\n\\nString binary_to_octal(String bin_string) {\\n  bin_string = bin_string.trim();\\n  if (bin_string == null || bin_string == \\\"\\\") {\\n    throw new FormatException(\\\"An empty value was passed to the function\\\");\\n  }\\n  bool is_negative = bin_string[0] == \\\"-\\\";\\n  if (is_negative) bin_string = bin_string.substring(1);\\n\\n  String octal_val = \\\"\\\";\\n  int binary;\\n  try {\\n    binary = int.parse(bin_string);\\n  } catch (e) {\\n    throw new FormatException(\\\"An invalid value was passed to the function\\\");\\n  }\\n  int curr_bit;\\n  int j = 1;\\n  while (binary > 0) {\\n    int code_3 = 0;\\n    for (int i = 0; i < 3; i++) {\\n      curr_bit = binary % 10;\\n      binary = binary ~/ 10;\\n      code_3 += curr_bit * j;\\n      j *= 2;\\n    }\\n    octal_val = code_3.toString() + octal_val;\\n    j = 1;\\n  }\\n  if (is_negative) {\\n    return \\\"-\\\" + octal_val;\\n  }\\n  return octal_val;\\n}\\n\"",
    "decimal to any": "\"//Convert a Decimal Number to Any Other Representation\\n//https://en.wikipedia.org/wiki/Positional_notation#Base_conversion\\n\\nvoid main() {\\n  print(decimal_to_any(0, 2)); //Expected '0'\\n  print(decimal_to_any(5, 4)); //Expected '11'\\n  print(decimal_to_any(20, 3)); //Expected '202'\\n  print(decimal_to_any(-58, 16)); //Expected '-3A'\\n  print(decimal_to_any(243, 17)); //Expected 'E5'\\n  print(decimal_to_any(34923, 36)); //Expected 'QY3'\\n  print(decimal_to_any(10, 11)); //Expected 'A'\\n  print(decimal_to_any(-16, 16)); //Expected '-10'\\n  print(decimal_to_any(36, 36)); //Expected '10'\\n\\n  try {\\n    print(decimal_to_any(10, 37)); //Expected Error\\n  } on FormatException {\\n    print(\\\"Base value is not supported\\\");\\n  }\\n}\\n\\nString decimal_to_any(int value, int base) {\\n  var ALPHABET_VALUES = {\\n    10: 'A',\\n    11: 'B',\\n    12: 'C',\\n    13: 'D',\\n    14: 'E',\\n    15: 'F',\\n    16: 'G',\\n    17: 'H',\\n    18: 'I',\\n    19: 'J',\\n    20: 'K',\\n    21: 'L',\\n    22: 'M',\\n    23: 'N',\\n    24: 'O',\\n    25: 'P',\\n    26: 'Q',\\n    27: 'R',\\n    28: 'S',\\n    29: 'T',\\n    30: 'U',\\n    31: 'V',\\n    32: 'W',\\n    33: 'X',\\n    34: 'Y',\\n    35: 'Z'\\n  };\\n\\n  if (value == 0) return \\\"0\\\";\\n\\n  if (base < 2 || base > 36) throw FormatException(\\\"Base not supported!\\\");\\n\\n  bool negative = false;\\n  if (value < 0) {\\n    negative = true;\\n    value *= -1;\\n  }\\n\\n  String output = \\\"\\\";\\n  while (value > 0) {\\n    int remainder = value % base;\\n    value = value ~/ base;\\n    output =\\n        (remainder < 10 ? remainder.toString() : ALPHABET_VALUES[remainder]) +\\n            output;\\n  }\\n\\n  return negative ? '-' + output : output;\\n}\\n\"",
    "decimal to binary": "\"//Author:Shawn\\n//Email:stepfencurryxiao@gmail.com\\n\\nimport \\\"dart:math\\\" show pow;\\n\\n/*\\n * This method converts a decimal number \\n * to a binary number using a bitwise\\n * algorithm\\n */\\nvoid bitwiseConversion(var n) {\\n  int b = 0, c = 0, d;\\n  print(\\\"Bitwise conversion.\\\\n\\\");\\n  while (n != 0) {\\n    d = (n & 1);\\n    b += d * (pow(10, c++).toInt());\\n    n >>= 1;\\n  }\\n  print(\\\"\\\\tBinary number: $b\\\");\\n}\\n\\n//Main method\\nvoid main() {\\n  bitwiseConversion(8);\\n}\\n\"",
    "decimal to hexadecimal": "\"Map<String, String> hex_table = {\\n  \\\"10\\\": \\\"A\\\",\\n  \\\"11\\\": \\\"B\\\",\\n  \\\"12\\\": \\\"C\\\",\\n  \\\"13\\\": \\\"D\\\",\\n  \\\"14\\\": \\\"E\\\",\\n  \\\"15\\\": \\\"F\\\",\\n};\\nvoid main() {\\n  print(decimal_to_hexadecimal(-123));\\n  print(decimal_to_hexadecimal(0));\\n  print(decimal_to_hexadecimal(404));\\n}\\n\\nString decimal_to_hexadecimal(int decimal_val) {\\n  if (decimal_val == 0) {\\n    return \\\"0\\\";\\n  }\\n  bool negative = false;\\n  if (decimal_val < 0) {\\n    negative = true;\\n    decimal_val *= -1;\\n  }\\n  String hex_string = \\\"\\\";\\n  while (decimal_val > 0) {\\n    String hex_val = \\\"\\\";\\n    int remainder = decimal_val % 16;\\n    decimal_val = decimal_val ~/ 16;\\n    if (hex_table.containsKey(remainder.toString())) {\\n      hex_val = hex_table[remainder.toString()];\\n    } else {\\n      hex_val = remainder.toString();\\n    }\\n    hex_string = hex_val + hex_string;\\n  }\\n  return negative ? \\\"-\\\" + hex_string : hex_string;\\n}\\n\"",
    "decimal to octal": "\"void main() {\\n  print(decimal_to_octal(-123));\\n  print(decimal_to_octal(0));\\n  print(decimal_to_octal(404));\\n}\\n\\nString decimal_to_octal(int decimal_val) {\\n  if (decimal_val == 0) {\\n    return \\\"0\\\";\\n  }\\n  bool negative = false;\\n  if (decimal_val < 0) {\\n    negative = true;\\n    decimal_val *= -1;\\n  }\\n  String oct_string = \\\"\\\";\\n  while (decimal_val > 0) {\\n    int remainder = decimal_val % 8;\\n    decimal_val = decimal_val ~/ 8;\\n    oct_string = remainder.toString() + oct_string;\\n  }\\n  return negative ? \\\"-\\\" + oct_string : oct_string;\\n}\\n\"",
    "hexadecimal to binary": "\"import 'package:test/test.dart';\\n\\n// hexadecimal number to binary number conversion\\nMap<String, String> bin_table = {\\n  \\\"0\\\": \\\"0\\\",\\n  \\\"1\\\": \\\"1\\\",\\n  \\\"2\\\": \\\"10\\\",\\n  \\\"3\\\": \\\"11\\\",\\n  \\\"4\\\": \\\"100\\\",\\n  \\\"5\\\": \\\"101\\\",\\n  \\\"6\\\": \\\"110\\\",\\n  \\\"7\\\": \\\"111\\\",\\n  \\\"8\\\": \\\"1000\\\",\\n  \\\"9\\\": \\\"1001\\\",\\n  \\\"A\\\": \\\"1010\\\",\\n  \\\"B\\\": \\\"1011\\\",\\n  \\\"C\\\": \\\"1100\\\",\\n  \\\"D\\\": \\\"1101\\\",\\n  \\\"E\\\": \\\"1110\\\",\\n  \\\"F\\\": \\\"1111\\\",\\n};\\n\\n// function to take hex value as string and return binary value as string\\nString hexadecimal_to_binary(String hex_value) {\\n  // checking for unexpected values\\n  hex_value = hex_value.trim();\\n  if (hex_value == null || hex_value == \\\"\\\") {\\n    throw new FormatException(\\\"An empty value was passed to the function\\\");\\n  }\\n\\n  // negative number check\\n  bool is_negative = hex_value[0] == \\\"-\\\";\\n  if (is_negative) hex_value = hex_value.substring(1);\\n\\n  // coverting the  hex to binary values by diving into substring\\n  String bin_val = \\\"\\\";\\n  int i = 0;\\n  while (i != hex_value.length) {\\n    String hex_cur = hex_value.substring(i, i + 1);\\n    if (!bin_table.containsKey(hex_cur)) {\\n      throw new FormatException(\\\"An invalid value was passed to the function\\\");\\n    }\\n    bin_val += bin_table[hex_cur];\\n    i++;\\n  }\\n\\n  // returning the value\\n  if (is_negative) {\\n    return \\\"-\\\" + bin_val;\\n  }\\n  return bin_val;\\n}\\n\\nvoid main() {\\n  test(\\\"hexadecimal_to_binary -F\\\", () {\\n    expect(hexadecimal_to_binary(\\\"-F\\\"), equals(\\\"-1111\\\"));\\n  });\\n\\n  test(\\\"hexadecimal_to_binaryl 2B\\\", () {\\n    expect(hexadecimal_to_binary(\\\"2B\\\"), equals(\\\"101011\\\"));\\n  });\\n\\n  test(\\\"hexadecimal_to_binary rasies error when number is invalid\\\", () {\\n    expect(() => hexadecimal_to_binary(\\\"AIO\\\"), throwsFormatException);\\n  });\\n\\n  test(\\\"hexadecimal_to_binary of empty string raises error\\\", () {\\n    expect(() => hexadecimal_to_binary(\\\"\\\"), throwsFormatException);\\n  });\\n}\\n\"",
    "hexadecimal to decimal": "\"import \\\"dart:math\\\" show pow;\\n\\nMap<String, int> hex_table = {\\n  \\\"A\\\": 10,\\n  \\\"B\\\": 11,\\n  \\\"C\\\": 12,\\n  \\\"D\\\": 13,\\n  \\\"E\\\": 14,\\n  \\\"F\\\": 15,\\n};\\nvoid main() {\\n  print(hexadecimal_to_decimal(\\\"1abc\\\")); // 6844\\n\\n  print(hexadecimal_to_decimal(\\\" -123 \\\")); // -291\\n  try {\\n    print(hexadecimal_to_decimal(\\\"1x\\\")); //error\\n  } catch (ex) {\\n    print(ex);\\n  }\\n}\\n\\nint hexadecimal_to_decimal(String hex_string) {\\n  hex_string = hex_string.trim().toUpperCase();\\n  if (hex_string == null || hex_string == \\\"\\\") {\\n    throw Exception(\\\"An empty value was passed to the function\\\");\\n  }\\n  bool is_negative = hex_string[0] == \\\"-\\\";\\n  if (is_negative) hex_string = hex_string.substring(1);\\n  int decimal_val = 0;\\n  for (int i = 0; i < hex_string.length; i++) {\\n    if (int.parse(hex_string[i], onError: (e) => null) == null &&\\n        hex_table.containsKey(hex_string[i]) == false) {\\n      throw Exception(\\\"Non-hex value was passed to the function\\\");\\n    } else {\\n      decimal_val += pow(16, hex_string.length - i - 1) *\\n          int.parse((hex_string[i]), onError: (e) => hex_table[hex_string[i]]);\\n    }\\n  }\\n  return is_negative ? -1 * decimal_val : decimal_val;\\n}\\n\"",
    "hexadecimal to octal": "\"import \\\"dart:math\\\" show pow;\\nimport 'package:test/test.dart';\\n\\n// Hexadecimal number to octal number conversion program\\nString hexadecimal_to_octal(String hex_val) {\\n  int dec = 0;\\n\\n  // checking for null string passed to function\\n  if (hex_val == null || hex_val == \\\"\\\") {\\n    throw new FormatException(\\\"An empty value was passed to the function\\\");\\n  }\\n\\n  // negative number check\\n  bool is_negative = hex_val[0] == \\\"-\\\";\\n  if (is_negative) hex_val = hex_val.substring(1);\\n  int c = hex_val.length - 1;\\n\\n  // finding the decimal equivalent of the hexa decimal number\\n  for (int i = 0; i < hex_val.length; i++) {\\n    var ch = hex_val.substring(i, i + 1);\\n    switch (ch) {\\n      case '0':\\n      case '1':\\n      case '2':\\n      case '3':\\n      case '4':\\n      case '5':\\n      case '6':\\n      case '7':\\n      case '8':\\n      case '9':\\n        dec = dec + int.parse(ch) * pow(16, c);\\n        c--;\\n        break;\\n      case 'a':\\n      case 'A':\\n        dec = dec + 10 * pow(16, c);\\n        c--;\\n        break;\\n      case 'b':\\n      case 'B':\\n        dec = dec + 11 * pow(16, c);\\n        c--;\\n        break;\\n      case 'c':\\n      case 'C':\\n        dec = dec + 12 * pow(16, c);\\n        c--;\\n        break;\\n      case 'd':\\n      case 'D':\\n        dec = dec + 13 * pow(16, c);\\n        c--;\\n        break;\\n      case 'e':\\n      case 'E':\\n        dec = dec + 14 * pow(16, c);\\n        c--;\\n        break;\\n      case 'f':\\n      case 'F':\\n        dec = dec + 15 * pow(16, c);\\n        c--;\\n        break;\\n      default:\\n        throw new FormatException(\\n            \\\"An invalid value was passed to the function\\\");\\n        break;\\n    }\\n  }\\n\\n  // String oct to store the octal equivalent of a hexadecimal number.\\n  String oct_val = \\\"\\\";\\n\\n  // Converting decimal to octal number.\\n  while (dec > 0) {\\n    oct_val = (dec % 8).toString() + oct_val;\\n    dec = dec ~/ 8;\\n  }\\n\\n  // Returning the value\\n  if (is_negative) {\\n    return \\\"-\\\" + oct_val;\\n  }\\n  return oct_val;\\n}\\n\\nvoid main() {\\n  // Test cases with various input\\n  test(\\\"hexadecimal_to_octal 43DF\\\", () {\\n    expect(hexadecimal_to_octal(\\\"43DF\\\"), equals(\\\"41737\\\"));\\n  });\\n\\n  test(\\\"hexadecimal_to_octal -2CB\\\", () {\\n    expect(hexadecimal_to_octal(\\\"-2CB\\\"), equals(\\\"-1313\\\"));\\n  });\\n\\n  test(\\\"hexadecimal_to_octal rasies error when number is invalid\\\", () {\\n    expect(() => hexadecimal_to_octal(\\\"AIO\\\"), throwsFormatException);\\n  });\\n\\n  test(\\\"hexadecimal_to_octal of empty string raises error\\\", () {\\n    expect(() => hexadecimal_to_octal(\\\"\\\"), throwsFormatException);\\n  });\\n}\\n\"",
    "integer to roman": "\"///Author: Shawn\\n///Email: stepfencurryxiao@gmail.com\\n\\n/*\\n * \\n * Concerting Integers into Roman Numerals\\n * \\n */\\n\\nList<int> ArabianRomanNumbers = [\\n  1000,\\n  900,\\n  500,\\n  400,\\n  100,\\n  90,\\n  50,\\n  40,\\n  10,\\n  9,\\n  5,\\n  4,\\n  1\\n];\\n\\nList<String> RomanNumbers = [\\n  \\\"M\\\",\\n  \\\"CM\\\",\\n  \\\"D\\\",\\n  \\\"CD\\\",\\n  \\\"C\\\",\\n  \\\"XC\\\",\\n  \\\"L\\\",\\n  \\\"XL\\\",\\n  \\\"X\\\",\\n  \\\"IX\\\",\\n  \\\"V\\\",\\n  \\\"IV\\\",\\n  \\\"I\\\"\\n];\\n\\nList<String> integer_to_roman(int num) {\\n  if (num < 0) {\\n    return null;\\n  }\\n\\n  List<String> result = [];\\n  for (int i = 0; i < ArabianRomanNumbers.length; i++) {\\n    int times = num ~/ ArabianRomanNumbers[i];\\n    for (int j = 0; j < times; j++) {\\n      print(RomanNumbers[i]);\\n    }\\n    num -= times * ArabianRomanNumbers[i];\\n  }\\n\\n  return result;\\n}\\n\\nint main() {\\n  /* IV */\\n  integer_to_roman(4);\\n  /* II */\\n  integer_to_roman(2);\\n  /* M */\\n  integer_to_roman(1000);\\n  return 0;\\n}\\n\"",
    "octal to binary": "\"import \\\"dart:math\\\" show pow;\\nimport 'package:test/test.dart';\\n\\n// octal number to binary number conversion\\nString ocatal_to_binary(String oct_val) {\\n  // checking for unexpected values\\n  oct_val = oct_val.trim();\\n  if (oct_val == null || oct_val == \\\"\\\") {\\n    throw new FormatException(\\\"An empty value was passed to the function\\\");\\n  }\\n\\n  // negative number check\\n  bool is_negative = oct_val[0] == \\\"-\\\";\\n  if (is_negative) oct_val = oct_val.substring(1);\\n\\n  int oct;\\n  try {\\n    oct = int.parse(oct_val);\\n  } catch (e) {\\n    throw new FormatException(\\\"An invalid value was passed to the function\\\");\\n  }\\n\\n  // checking number not valid for octal is passed(0-7)\\n  for (int i = 0; i < oct_val.length; i++) {\\n    if (!(int.parse(oct_val.substring(i, i + 1)) < 8)) {\\n      throw new FormatException(\\\"An invalid value was passed to the function\\\");\\n    }\\n    ;\\n  }\\n\\n  // converting octal to decimal\\n  int dec_val = 0, i = 0, bin_val = 0;\\n  while (oct != 0) {\\n    dec_val = dec_val + ((oct % 10) * pow(8, i));\\n    i++;\\n    oct = oct ~/ 10;\\n  }\\n\\n  // converting to decimal to binary\\n  i = 1;\\n  while (dec_val != 0) {\\n    bin_val = bin_val + (dec_val % 2) * i;\\n    dec_val = dec_val ~/ 2;\\n    i = i * 10;\\n  }\\n\\n  // returning the value\\n  if (is_negative) {\\n    return \\\"-\\\" + bin_val.toString();\\n  }\\n  return bin_val.toString();\\n}\\n\\nvoid main() {\\n  test(\\\"ocatal_to_binary 75\\\", () {\\n    expect(ocatal_to_binary(\\\"75\\\"), equals(\\\"111101\\\"));\\n  });\\n\\n  test(\\\"ocatal_to_binary -62\\\", () {\\n    expect(ocatal_to_binary(\\\"-62\\\"), equals(\\\"-110010\\\"));\\n  });\\n\\n  test(\\\"ocatal_to_binary rasies error when number is invalid\\\", () {\\n    expect(() => ocatal_to_binary(\\\"84\\\"), throwsFormatException);\\n  });\\n\\n  test(\\\"ocatal_to_binary rasies error when number is invalid\\\", () {\\n    expect(() => ocatal_to_binary(\\\"as23\\\"), throwsFormatException);\\n  });\\n\\n  test(\\\"ocatal_to_binary of empty string raises error\\\", () {\\n    expect(() => ocatal_to_binary(\\\"\\\"), throwsFormatException);\\n  });\\n}\\n\"",
    "octal to decimal": "\"import \\\"dart:math\\\" show pow;\\nimport 'package:test/test.dart';\\n\\n// octal number to decimal number conversion\\n//\\n// function to take oct string value and  return decmal string value\\nString ocatal_to_decimal(String oct_val) {\\n  // checking for unexpected values\\n  oct_val = oct_val.trim();\\n  if (oct_val == null || oct_val == \\\"\\\") {\\n    throw new FormatException(\\\"An empty value was passed to the function\\\");\\n  }\\n\\n  // negative number check\\n  bool is_negative = oct_val[0] == \\\"-\\\";\\n  if (is_negative) oct_val = oct_val.substring(1);\\n\\n  int oct;\\n  try {\\n    oct = int.parse(oct_val);\\n  } catch (e) {\\n    throw new FormatException(\\\"An invalid value was passed to the function\\\");\\n  }\\n\\n  // checking number not valid for octal is passed(0-7)\\n  for (int i = 0; i < oct_val.length; i++) {\\n    if (!(int.parse(oct_val.substring(i, i + 1)) < 8)) {\\n      throw new FormatException(\\\"An invalid value was passed to the function\\\");\\n    }\\n    ;\\n  }\\n\\n  // converting octal to decimal\\n  int dec_val = 0, i = 0;\\n  while (oct != 0) {\\n    dec_val = dec_val + ((oct % 10) * pow(8, i));\\n    i++;\\n    oct = oct ~/ 10;\\n  }\\n\\n  // returning the value\\n  if (is_negative) {\\n    return \\\"-\\\" + dec_val.toString();\\n  }\\n  return dec_val.toString();\\n}\\n\\n// driver function\\nvoid main() {\\n  // test cases for different input\\n  test(\\\"ocatal_to_decimal 75\\\", () {\\n    expect(ocatal_to_decimal(\\\"75\\\"), equals(\\\"61\\\"));\\n  });\\n\\n  test(\\\"ocatal_to_decimal -62\\\", () {\\n    expect(ocatal_to_decimal(\\\"-62\\\"), equals(\\\"-50\\\"));\\n  });\\n\\n  test(\\\"ocatal_to_decimal rasies error when number is invalid\\\", () {\\n    expect(() => ocatal_to_decimal(\\\"84\\\"), throwsFormatException);\\n  });\\n\\n  test(\\\"ocatal_to_decimal rasies error when number is invalid\\\", () {\\n    expect(() => ocatal_to_decimal(\\\"as23\\\"), throwsFormatException);\\n  });\\n\\n  test(\\\"ocatal_to_decimal of empty string raises error\\\", () {\\n    expect(() => ocatal_to_decimal(\\\"\\\"), throwsFormatException);\\n  });\\n}\\n\"",
    "octal to hexadecimal": "\"import \\\"dart:math\\\" show pow;\\nimport 'package:test/test.dart';\\n\\n// octal number to hex number\\nMap<String, String> hex_table = {\\n  \\\"10\\\": \\\"A\\\",\\n  \\\"11\\\": \\\"B\\\",\\n  \\\"12\\\": \\\"C\\\",\\n  \\\"13\\\": \\\"D\\\",\\n  \\\"14\\\": \\\"E\\\",\\n  \\\"15\\\": \\\"F\\\",\\n};\\n//\\n// function take octal string value and return hexadecimal string value\\nString ocatal_to_hex(String oct_val) {\\n  // checking for unexpected values\\n  oct_val = oct_val.trim();\\n  if (oct_val == null || oct_val == \\\"\\\") {\\n    throw new FormatException(\\\"An empty value was passed to the function\\\");\\n  }\\n\\n  // negative number check\\n  bool is_negative = oct_val[0] == \\\"-\\\";\\n  if (is_negative) oct_val = oct_val.substring(1);\\n\\n  int oct;\\n  try {\\n    oct = int.parse(oct_val);\\n  } catch (e) {\\n    throw new FormatException(\\\"An invalid value was passed to the function\\\");\\n  }\\n\\n  // checking number not valid for octal is passed(0-7)\\n  for (int i = 0; i < oct_val.length; i++) {\\n    if (!(int.parse(oct_val.substring(i, i + 1)) < 8)) {\\n      throw new FormatException(\\\"An invalid value was passed to the function\\\");\\n    }\\n    ;\\n  }\\n\\n  // converting octal to decimal\\n  int dec_val = 0, i = 0;\\n  while (oct != 0) {\\n    dec_val = dec_val + ((oct % 10) * pow(8, i));\\n    i++;\\n    oct = oct ~/ 10;\\n  }\\n\\n  // converting to decimal to hex\\n  if (dec_val == 0) {\\n    return \\\"0\\\";\\n  }\\n  String hex_string = \\\"\\\";\\n  while (dec_val > 0) {\\n    String hex_val = \\\"\\\";\\n    int remainder = dec_val % 16;\\n    dec_val = dec_val ~/ 16;\\n    if (hex_table.containsKey(remainder.toString())) {\\n      hex_val = hex_table[remainder.toString()];\\n    } else {\\n      hex_val = remainder.toString();\\n    }\\n    hex_string = hex_val + hex_string;\\n  }\\n\\n  // returning the value\\n  if (is_negative) {\\n    return \\\"-\\\" + hex_string;\\n  }\\n  return hex_string;\\n}\\n\\n// driver function\\nvoid main() {\\n  // test input\\n  test(\\\"ocatal_to_hex 75\\\", () {\\n    expect(ocatal_to_hex(\\\"75\\\"), equals(\\\"3D\\\"));\\n  });\\n\\n  test(\\\"ocatal_to_hex -62\\\", () {\\n    expect(ocatal_to_hex(\\\"-62\\\"), equals(\\\"-32\\\"));\\n  });\\n\\n  test(\\\"ocatal_to_hex rasies error when number is invalid\\\", () {\\n    expect(() => ocatal_to_hex(\\\"84\\\"), throwsFormatException);\\n  });\\n\\n  test(\\\"ocatal_to_hex rasies error when number is invalid\\\", () {\\n    expect(() => ocatal_to_hex(\\\"as23\\\"), throwsFormatException);\\n  });\\n\\n  test(\\\"ocatal_to_hex of empty string raises error\\\", () {\\n    expect(() => ocatal_to_hex(\\\"\\\"), throwsFormatException);\\n  });\\n}\\n\"",
    "roman to integer": "\"import 'package:test/test.dart';\\n\\nint romanToInteger(var s) {\\n  int ans = 0;\\n  for (int i = 0; i < s.length; i++) {\\n    int num1 = value(s[i]);\\n    if (i + 1 < s.length) {\\n      int num2 = value(s[i + 1]);\\n      if (num1 < num2) {\\n        ans = ans + num2 - num1;\\n        i++;\\n      } else {\\n        ans = ans + num1;\\n      }\\n    } else {\\n      ans = ans + num1;\\n    }\\n  }\\n  return ans;\\n}\\n\\nint value(var r) {\\n  if (r == 'I')\\n    return 1;\\n  else if (r == 'V')\\n    return 5;\\n  else if (r == 'X')\\n    return 10;\\n  else if (r == 'L')\\n    return 50;\\n  else if (r == 'C')\\n    return 100;\\n  else if (r == 'D')\\n    return 500;\\n  else if (r == 'M') return 1000;\\n  return 0;\\n}\\n\\nvoid main() {\\n  test(\\\"romanToInteger XII returns 12\\\", () {\\n    expect(romanToInteger('XII'), equals(12));\\n  });\\n\\n  test(\\\"romanToInteger LII returns 52\\\", () {\\n    expect(romanToInteger('LII'), equals(52));\\n  });\\n\\n  test(\\\"romanToInteger DLVII returns 557\\\", () {\\n    expect(romanToInteger('LII'), equals(52));\\n  });\\n\\n  test(\\\"romanToInteger VI returns 6\\\", () {\\n    expect(romanToInteger('VI'), equals(6));\\n  });\\n\\n  test(\\\"romanToInteger CLXV returns 165\\\", () {\\n    expect(romanToInteger('CLXV'), equals(165));\\n  });\\n\\n  test(\\\"romanToInteger MDCI returns 1601\\\", () {\\n    expect(romanToInteger('MDCI'), equals(1601));\\n  });\\n\\n  test(\\\"romanToInteger LVII returns 57\\\", () {\\n    expect(romanToInteger('LVII'), equals(57));\\n  });\\n}\\n\"",
    "01knapsack recursive": "\"import 'dart:math';\\nimport 'package:test/test.dart';\\n\\nint knapSackProblem(int capacity, List<int> values, List<int> weights,\\n    [int numberOfItems]) {\\n  numberOfItems ??= values.length;\\n  if (numberOfItems == 0 || capacity == 0) {\\n    return 0;\\n  }\\n  int currentValue = values[numberOfItems - 1];\\n  int currentWeight = weights[numberOfItems - 1];\\n\\n  if (weights[numberOfItems - 1] <= capacity) {\\n    return max(\\n        currentValue +\\n            knapSackProblem(\\n                capacity - currentWeight, values, weights, numberOfItems - 1),\\n        knapSackProblem(capacity, values, weights, numberOfItems - 1));\\n  } else {\\n    return knapSackProblem(capacity, values, weights, numberOfItems - 1);\\n  }\\n}\\n\\nvoid main() {\\n  int ans = knapSackProblem(10, [1, 4, 5, 6], [2, 3, 6, 7]);\\n  print(ans);\\n\\n  test('TC: 1', () {\\n    expect(knapSackProblem(10, [1, 4, 5, 6], [2, 3, 6, 7]), 10);\\n  });\\n\\n  ans = knapSackProblem(100, [2, 70, 30, 69, 100], [1, 70, 30, 69, 100]);\\n  print(ans);\\n\\n  test('TC: 2', () {\\n    expect(\\n        knapSackProblem(100, [2, 70, 30, 69, 100], [1, 70, 30, 69, 100]), 101);\\n  });\\n}\\n\"",
    "coin change": "\"import 'dart:math';\\nimport 'package:test/test.dart';\\n\\n/// we build an array which calculates the min coins for all amounts upto n\\n///\\n///  bottom up approach where we calculate the number of coins used for each\\n///  amount from 1 to n for each coin.\\n///  time complexity O(targetAmount * coinDenoms)\\n///  space complexity O(targetAmount)\\nint minNumberOfCoins(int targetAmount, List<int> coinDenoms) {\\n  List<int> amounts =\\n      new List<int>.generate(targetAmount + 1, (int index) => 1000000000000);\\n\\n  amounts[0] = 0;\\n\\n  for (int currentCoin in coinDenoms) {\\n    for (int amount = currentCoin; amount <= targetAmount; amount++) {\\n      amounts[amount] = min(amounts[amount], amounts[amount - currentCoin] + 1);\\n    }\\n  }\\n  if (amounts[targetAmount] != 1000000000000) {\\n    return amounts[targetAmount];\\n  }\\n  return -1;\\n}\\n\\nvoid main() {\\n  test(('testCase #1'), () {\\n    expect(minNumberOfCoins(7, [1, 5, 10]), equals(3));\\n  });\\n\\n  test(('testCase #2'), () {\\n    expect(minNumberOfCoins(7, [3, 5]), equals(-1));\\n  });\\n\\n  test(('testCase #3'), () {\\n    expect(minNumberOfCoins(9, [3, 4, 5]), equals(2));\\n  });\\n}\\n\"",
    "kadanes algorithm": "\"import 'package:test/test.dart';\\nimport 'dart:math';\\n\\nint kadanesAlgorithm(List<int> array) {\\n  int maxEndingHere = array[0];\\n  int maxSoFar = array[0];\\n\\n  for (int num in array.sublist(1, array.length)) {\\n    maxEndingHere = max(maxEndingHere + num, num);\\n    maxSoFar = max(maxSoFar, maxEndingHere);\\n  }\\n  return maxSoFar;\\n}\\n\\nvoid main() {\\n  List<int> array;\\n  int maxContiniousSubarraySum;\\n\\n  test(('.Check the response for each test case'), () {\\n    array = [3, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 4];\\n\\n    maxContiniousSubarraySum = kadanesAlgorithm(array);\\n    expect(maxContiniousSubarraySum, equals(19));\\n  });\\n\\n  test(('.Check the response for each test case'), () {\\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\\n    maxContiniousSubarraySum = kadanesAlgorithm(array);\\n    expect(maxContiniousSubarraySum, equals(55));\\n  });\\n\\n  test(('.Check the response for each test case'), () {\\n    array = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10];\\n    maxContiniousSubarraySum = kadanesAlgorithm(array);\\n    expect(maxContiniousSubarraySum, equals(-1));\\n  });\\n\\n  test(('.Check the response for each test case'), () {\\n    array = [1, 2, 3, 4, 5, 6, -22, 7, 8, 9, 10];\\n    maxContiniousSubarraySum = kadanesAlgorithm(array);\\n    expect(maxContiniousSubarraySum, equals(34));\\n  });\\n}\\n\"",
    "min number of jumps": "\"import 'dart:math';\\nimport 'package:test/test.dart';\\n\\nint minimumNumberOfJumps(List<int> array) {\\n  List<int> jumps = List.generate((array.length), (index) => 1000000000000);\\n  jumps[0] = 0;\\n  int length = array.length;\\n  for (int i = 1; i < length; i++) {\\n    for (int j = 0; j < i; j++) {\\n      if (array[j] + j >= i) {\\n        jumps[i] = min(jumps[j] + 1, jumps[i]);\\n      }\\n    }\\n  }\\n  return jumps[length - 1];\\n}\\n\\nvoid main() {\\n  List<int> array;\\n  test('test 1', () {\\n    array = [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3];\\n    expect(minimumNumberOfJumps(array), 4);\\n  });\\n  test('test 2', () {\\n    array = [1];\\n    expect(minimumNumberOfJumps(array), 0);\\n  });\\n  test('test 3', () {\\n    array = [1, 1];\\n    expect(minimumNumberOfJumps(array), 1);\\n  });\\n  test('test 4', () {\\n    array = [1, 1, 1];\\n    expect(minimumNumberOfJumps(array), 2);\\n  });\\n  test('test 5', () {\\n    array = [2, 1, 2, 3, 1, 1, 1];\\n    expect(minimumNumberOfJumps(array), 3);\\n  });\\n  test('test 6', () {\\n    array = [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1];\\n    expect(minimumNumberOfJumps(array), 7);\\n  });\\n}\\n\"",
    "breadth first search": "\"import 'dart:collection';\\nimport 'package:test/test.dart';\\n\\n/// Implementation of Breadth First Search\\n/// https://en.wikipedia.org/wiki/Breadth-first_search\\n\\nclass Graph {\\n  /// Adjacency List representation using dynamic list and HashMap\\n  HashMap graph = new HashMap<int, List<dynamic>>();\\n  List<int> nodes;\\n\\n  void makeGraph() {\\n    /// initialise all nodes with empty lists.\\n    /// each node will have a list as value which stores\\n    /// the nodes to which it is connected to\\n    for (int i = 0; i < this.nodes.length; i++) {\\n      this.graph[nodes[i]] = List();\\n    }\\n  }\\n\\n  Graph(this.nodes) {\\n    this.makeGraph();\\n  }\\n\\n  int get numberOfNodesInGraph {\\n    return this.nodes.length;\\n  }\\n\\n  HashMap get graphDataStructure {\\n    return this.graph;\\n  }\\n\\n  void addNodes(int newNode) {\\n    this.nodes.add(newNode);\\n    this.graph[newNode] = List();\\n  }\\n\\n  void addEdges(int start, int end) {\\n    this.graph[start].add(end);\\n  }\\n}\\n\\nList<int> breadthFirstSearch(Graph graph, int numberOfNodes, int startNode) {\\n  Queue queue = new Queue<int>();\\n  List<int> answer = List();\\n  queue.add(startNode);\\n  while (queue.isNotEmpty) {\\n    int node = queue.removeFirst();\\n    answer.add(node);\\n    for (int child in graph.graph[node]) {\\n      queue.add(child);\\n    }\\n  }\\n  return answer;\\n}\\n\\nvoid main() {\\n  test(('Test case 1:'), () {\\n    List<int> nodes = [0, 1, 2];\\n    int numberOfEdges = 2;\\n\\n    List<List<int>> edges = [\\n      [0, 1],\\n      [0, 2]\\n    ];\\n    Graph graph = Graph(nodes);\\n\\n    for (int i = 0; i < numberOfEdges; i++) {\\n      int start = edges[i][0];\\n      int end = edges[i][1];\\n      graph.addEdges(start, end);\\n    }\\n    int startNode = 0;\\n    List<int> answer =\\n        breadthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\\n    expect(answer, equals([0, 1, 2]));\\n  });\\n\\n  test(('Test case 2:'), () {\\n    List<int> nodes = [0, 1, 2, 3, 4];\\n    int numberOfEdges = 4;\\n\\n    List<List<int>> edges = [\\n      [0, 1],\\n      [0, 2],\\n      [0, 3],\\n      [2, 4]\\n    ];\\n    Graph graph = Graph(nodes);\\n\\n    for (int i = 0; i < numberOfEdges; i++) {\\n      int start = edges[i][0];\\n      int end = edges[i][1];\\n      graph.addEdges(start, end);\\n    }\\n    int startNode = 0;\\n    List<int> answer =\\n        breadthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\\n    expect(answer, equals([0, 1, 2, 3, 4]));\\n  });\\n}\\n\"",
    "depth first search": "\"import 'dart:collection';\\nimport 'package:test/test.dart';\\n\\n/// Implementation of Depth First Search\\n/// https://en.wikipedia.org/wiki/Depth-first_search\\n\\nclass Graph {\\n  /// Adjacency List representation using dynamic list and HashMap\\n  HashMap graph = new HashMap<int, List<dynamic>>();\\n  List<int> nodes;\\n\\n  void makeGraph() {\\n    /// initialise all nodes with empty lists.\\n    /// each node will have a list as value which stores\\n    /// the nodes to which it is connected to\\n    for (int i = 0; i < this.nodes.length; i++) {\\n      this.graph[nodes[i]] = List();\\n    }\\n  }\\n\\n  Graph(this.nodes) {\\n    this.makeGraph();\\n  }\\n\\n  int get numberOfNodesInGraph {\\n    return this.nodes.length;\\n  }\\n\\n  HashMap get graphDataStructure {\\n    return this.graph;\\n  }\\n\\n  void addNodes(int newNode) {\\n    this.nodes.add(newNode);\\n    this.graph[newNode] = List();\\n  }\\n\\n  void addEdges(int start, int end) {\\n    this.graph[start].add(end);\\n  }\\n}\\n\\nvoid depthFirstSearchHelper(graph, visitedNodes, node, answer) {\\n  if (visitedNodes[node]) {\\n    return null;\\n  }\\n  visitedNodes[node] = true;\\n  answer.add(node);\\n  if (graph.containsKey(node)) {\\n    for (int child in graph[node]) {\\n      if (!visitedNodes[child]) {\\n        depthFirstSearchHelper(graph, visitedNodes, child, answer);\\n      }\\n    }\\n  }\\n}\\n\\nList<int> depthFirstSearch(Graph graph, int numberOfNodes, int startNode) {\\n  List<bool> visitedNodes =\\n      new List<bool>.generate(numberOfNodes, (index) => false);\\n\\n  List<int> answer = List();\\n  depthFirstSearchHelper(graph.graph, visitedNodes, startNode, answer);\\n  return answer;\\n}\\n\\nvoid main() {\\n  test(('Test case 1:'), () {\\n    List<int> nodes = [0, 1, 2, 3];\\n    int numberOfEdges = 3;\\n\\n    List<List<int>> edges = [\\n      [0, 1],\\n      [1, 2],\\n      [0, 3]\\n    ];\\n    Graph graph = Graph(nodes);\\n\\n    for (int i = 0; i < numberOfEdges; i++) {\\n      int start = edges[i][0];\\n      int end = edges[i][1];\\n      graph.addEdges(start, end);\\n    }\\n    int startNode = 0;\\n    List<int> answer =\\n        depthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\\n    expect(answer, equals([0, 1, 2, 3]));\\n  });\\n\\n  test(('Test case 2:'), () {\\n    List<int> nodes = [0, 1, 2, 3, 4];\\n    int numberOfEdges = 4;\\n\\n    List<List<int>> edges = [\\n      [0, 1],\\n      [0, 2],\\n      [0, 3],\\n      [2, 4]\\n    ];\\n    Graph graph = Graph(nodes);\\n\\n    for (int i = 0; i < numberOfEdges; i++) {\\n      int start = edges[i][0];\\n      int end = edges[i][1];\\n      graph.addEdges(start, end);\\n    }\\n    int startNode = 0;\\n    List<int> answer =\\n        depthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\\n    expect(answer, equals([0, 1, 2, 4, 3]));\\n  });\\n}\\n\"",
    "nearest neighbour algorithm": "\"import 'dart:math';\\n\\n/// Graph represented as adjacency matrix\\n/// [nodes] - node names preserved in order\\n/// [adjacencyMatrix] edge weights, distances between nodes\\nclass Graph {\\n  List<String> nodes;\\n  List<List<double>> adjacencyMatrix;\\n\\n  Graph(this.nodes, this.adjacencyMatrix);\\n}\\n\\n/// Find path visiting all nodes in given [graph] using greedy approach\\nList<String> nearestNeighbourSearch(Graph graph) {\\n  List<String> path = [];\\n  Set<int> unvisitedNodes = Set.from(Iterable.generate(graph.nodes.length));\\n\\n  int currentNode = 0;\\n  while (unvisitedNodes.isNotEmpty) {\\n    unvisitedNodes.remove(currentNode);\\n    int nearestNeighbour;\\n    double nearestNeighbourDistance;\\n\\n    for (int neighbour in unvisitedNodes) {\\n      double neighbourDistance = graph.adjacencyMatrix[currentNode][neighbour];\\n      if (nearestNeighbour == null ||\\n          neighbourDistance < nearestNeighbourDistance) {\\n        nearestNeighbour = neighbour;\\n        nearestNeighbourDistance = neighbourDistance;\\n      }\\n    }\\n\\n    path.add(graph.nodes[currentNode]);\\n    currentNode = nearestNeighbour;\\n  }\\n\\n  return path;\\n}\\n\\nclass Point {\\n  double x;\\n  double y;\\n\\n  @override\\n  String toString() => \\\"P($x, $y)\\\";\\n\\n  Point(this.x, this.y);\\n}\\n\\n/// Euclidean distance between [p1] and [p2]\\ndouble distance(Point p1, Point p2) {\\n  return sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));\\n}\\n\\n/// Form graph using given [points].\\n/// Edge weights will correspond to distances\\nGraph fromPoints(List<Point> points) {\\n  List<String> nodes = [];\\n  List<List<double>> adjacencyMatrix = [];\\n\\n  for (Point p1 in points) {\\n    List<double> neigbourDistances = [];\\n    for (Point p2 in points) {\\n      neigbourDistances.add(distance(p1, p2));\\n    }\\n    nodes.add(p1.toString());\\n    adjacencyMatrix.add(neigbourDistances);\\n  }\\n\\n  return Graph(nodes, adjacencyMatrix);\\n}\\n\\nvoid main() {\\n  Graph graph = Graph([\\n    \\\"A\\\",\\n    \\\"B\\\",\\n    \\\"C\\\",\\n    \\\"D\\\",\\n    \\\"E\\\"\\n  ], [\\n    [0, 12, 4, 54, 100],\\n    [3, 0, 5, 1, 1],\\n    [300, 20, 0, 433, 123],\\n    [32, 31, 54, 0, 3],\\n    [2, 65, 12, 32, 0]\\n  ]);\\n\\n  print(nearestNeighbourSearch(graph));\\n\\n  List<Point> points = [\\n    new Point(0, 0),\\n    new Point(0, 10),\\n    new Point(-10, 10),\\n    new Point(3.33, 8.11),\\n    new Point(12, 11),\\n    new Point(-1, 1),\\n    new Point(-2, 2)\\n  ];\\n\\n  print(nearestNeighbourSearch(fromPoints(points)));\\n}\\n\"",
    "abs": "\"abs_value(number) {\\n  return number < 0 ? -number : number;\\n}\\n\\nvoid main() {\\n  print(abs_value(-34));\\n}\\n\"",
    "abs max": "\"/* Driver */\\nvoid main() {\\n  assert(absMax([0, 5, 1, 11]) == 11);\\n  assert(absMax([3, -10, -2]) == -10);\\n}\\n\\n/**\\n * get the value in [list], it's absolute value is max\\n * Examples:\\n * absMax([0, 5, 1, 11]) = 11, absMax([3 , -10, -2]) = -10\\n */\\nint absMax(List<int> list) {\\n  int max = list[0];\\n  for (int i = 1, length = list.length; i < length; ++i) {\\n    if (list[i].abs() > max.abs()) {\\n      max = list[i];\\n    }\\n  }\\n  return max;\\n}\\n\"",
    "abs min": "\"/* Driver */\\nvoid main() {\\n  assert(absMin([0, 5, 1, 11]) == 0);\\n  assert(absMin([3, -10, -2]) == -2);\\n}\\n\\n/**\\n * get the value in [list], it's absolute value is min\\n * Examples:\\n *      absMin([0, 5, 1, 11]) = 0, absMin([3 , -10, -2]) = -2\\n */\\nint absMin(List<int> list) {\\n  int min = list[0];\\n  for (int i = 1, length = list.length; i < length; ++i) {\\n    if (list[i].abs() < min.abs()) {\\n      min = list[i];\\n    }\\n  }\\n  return min;\\n}\\n\"",
    "amicable numbers": "\"/* \\n * https://en.wikipedia.org/wiki/Amicable_numbers\\n *\\n *Amicable numbers are two different numbers related in such a way that the sum of the proper divisors of each is equal to the other number.\\n * \\n * */\\n\\n//this function returns true if numbers are amicable and false otherwise\\nbool amicable_number(int first_number, int second_number) {\\n  if (first_number <= 1 || second_number <= 1) return false;\\n  List<int> first_number_proper_divisors = [];\\n  List<int> second_number_proper_divisors = [];\\n  for (int i = 1; i < first_number; i++) {\\n    if (first_number % i == 0) first_number_proper_divisors.add(i);\\n  }\\n  for (int i = 1; i < second_number; i++) {\\n    if (second_number % i == 0) second_number_proper_divisors.add(i);\\n  }\\n  return first_number ==\\n          second_number_proper_divisors.reduce((a, b) => a + b) &&\\n      second_number == first_number_proper_divisors.reduce((a, b) => a + b);\\n}\\n\\nvoid main() {\\n  print(amicable_number(12, 14)); // false\\n  print(amicable_number(220, 284)); // true\\n  print(amicable_number(60, 84)); // true\\n  print(amicable_number(1184, 1210)); //true\\n  print(amicable_number(-14, 10)); //false\\n}\\n\"",
    "armstrong number": "\"import 'dart:math';\\n\\nbool Armstrong_no(var x) {\\n  var n = x;\\n  var s = n.toString();\\n  var d = s.length;\\n  var sum = 0;\\n  while (n != 0) {\\n    var r = n % 10;\\n    sum = sum + pow(r, d);\\n    n = n ~/ 10;\\n  }\\n  return sum == x;\\n}\\n\\nvoid main() {\\n  for (var x in [0, 10, 370, 371]) {\\n    if (Armstrong_no(x)) {\\n      print(\\\"${x} is armstrong number\\\");\\n    } else {\\n      print(\\\"${x} is not Armstrong number\\\");\\n    }\\n  }\\n}\\n\"",
    "average": "\"//Find mean of a list of numbers.\\n\\naverage(List numbers) {\\n  var sum = 0;\\n  for (var x in numbers) {\\n    sum += x;\\n  }\\n  var avg = sum / numbers.length;\\n  print(avg);\\n  return avg;\\n}\\n\\nvoid main() {\\n  average([2, 8, 6, 90, 60]);\\n}\\n\"",
    "eulers totient": "\"/* Source:\\n *   https://en.wikipedia.org/wiki/Euler%27s_totient_function\\n * \\n * Description:\\n *   eulers_totient(n) = n * product(1 - 1/p for all prime p dividing n)\\n * \\n * Time Complexity:\\n *   O(sqrt(n))\\n */\\n\\nint eulers_totient(int n) {\\n  // Input: n: int\\n  // Output: phi(n): count of numbers b/w 1 and n that are coprime to n\\n  int res = n;\\n  for (int i = 2; i * i <= n; i++) {\\n    if (n % i == 0) {\\n      while (n % i == 0) {\\n        n = n ~/ i;\\n      }\\n      // i is a prime dividing n, multiply res bu 1 - 1/i\\n      // res = res * (1 - 1/i) = res - (res/i)\\n      res = res - (res ~/ i);\\n    }\\n  }\\n  if (n > 1) {\\n    res = res - (res ~/ n);\\n  }\\n  return res;\\n}\\n\\nmain() {\\n  // eulers_totient(9) = 6 as 1, 2, 4, 5, 6, 7, 8 are coprime to 9\\n  // > 6\\n  print(eulers_totient(9));\\n  // eulers_totient(10) = 4 as 1, 3, 7, 9 are coprime to 10\\n  // > 4\\n  print(eulers_totient(10));\\n}\\n\"",
    "factorial": "\"void main() {\\n  var n = 5;\\n  var fac = factorial(n);\\n  print(\\\"$n! = $fac\\\"); /* output: 5! = 120 */\\n}\\n\\n/* calculate factorial of n*/\\nint factorial(var n) {\\n  var fac = 1;\\n  for (int i = 2; i <= n; ++i) {\\n    fac *= i;\\n  }\\n  return fac;\\n}\\n\"",
    "factorial approximation": "\"import 'dart:math';\\n\\n/// Approximation for gamma(x + 1) discovered by Srinivasa Ramanujanea\\ndouble factorial(double x) {\\n  return sqrt(pi) *\\n      pow(x / e, x) *\\n      pow(8 * pow(x, 3) + 4 * pow(x, 2) + x + 1 / 30, 1 / 6);\\n}\\n\\nmain() {\\n  for (int i = 0; i < 10; i++) {\\n    print(\\\"$i! ~= ${factorial(i.toDouble())}\\\");\\n  }\\n}\\n\"",
    "factorial recursion": "\"void main() {\\n  var n = 5;\\n  var fac = factorial(n);\\n  print(\\\"$n! = $fac\\\"); /* output: 5! = 120 */\\n}\\n\\n/* calculate factorial of n*/\\nint factorial(var n) => n == 0 || n == 1 ? 1 : n * factorial(n - 1);\\n\"",
    "factors": "\"void main() {\\n  print(\\\"factors: ${factorsOf(12)}\\\"); //factors: [1, 2, 3, 4, 6, 12]\\n\\n  try {\\n    print(factorsOf(-1)\\n        .toString()); //Unhandled exception: Exception: A non-positive value was passed to the function\\n  } catch (ex) {\\n    print(ex);\\n  }\\n}\\n\\nList<int> factorsOf(int num) {\\n  if (num <= 0)\\n    throw Exception(\\\"A non-positive value was passed to the function\\\");\\n  List<int> factors = [1];\\n  for (int i = 2; i <= num; i++) {\\n    if (num % i == 0) factors.add(i);\\n  }\\n  return factors;\\n}\\n\"",
    "fermats little theorem": "\"@Skip('currently failing (see issue #86)')\\n\\nimport 'package:test/test.dart';\\n\\n/*\\n Fermat's little Theorem\\n Translated from TheAlgorithms/Python\\n*/\\nbinary_exponentiation(a, n, mod) {\\n  if (n == 0) {\\n    return 1;\\n  } else if (n % 2 == 1) {\\n    return (binary_exponentiation(a, n - 1, mod) * a) % mod;\\n  }\\n  int b = binary_exponentiation(a, n / 2, mod);\\n\\n  return (b * b) % mod;\\n}\\n\\nvoid main() {\\n  // a prime number\\n  int p = 701;\\n\\n  double a = 1000000000;\\n  int b = 10;\\n\\n  // using binary exponentiation function, O(log(p)):\\n  print((a / b) % p == (a * binary_exponentiation(b, p - 2, p)) % p);\\n\\n  // using Python operators:\\n  print((a / b) % p == (a * b ^ (p - 2)) % p);\\n}\\n\"",
    "fibonacci dynamic programming": "\"import 'package:test/test.dart';\\n\\n//Title:  Nth Fibonacci Number using Dynamic Programming\\n//Author: Richik Chanda\\n//Email:  richikchanda1999@gmail.com\\nList<int> dp;\\nint mod = (1e9 + 7).toInt();\\n\\n//Get the nth Fibonacci number modulo 10^9 + 7 since it can be a very large number\\nint getFib(int n) {\\n  if (dp[n] == -1) dp[n] = (getFib(n - 1) % mod) + (getFib(n - 2) % mod);\\n  return dp[n] % mod;\\n}\\n\\n//Driver\\nvoid main() {\\n  dp = List.generate((1e6 + 1).toInt(), (e) => -1);\\n  dp[0] = 0;\\n  dp[1] = 1;\\n\\n  test(\\\"getFib 0 equals 0\\\", () {\\n    expect(getFib(0), equals(0));\\n  });\\n\\n  test(\\\"getFib 1 equals 1\\\", () {\\n    expect(getFib(1), equals(1));\\n  });\\n\\n  test(\\\"getFib 5 equals 5\\\", () {\\n    expect(getFib(5), equals(5));\\n  });\\n\\n  test(\\\"getFib(n) equals getFib(n - 1) + getFib(n - 2)\\\", () {\\n    expect(getFib(7), equals(getFib(6) + getFib(5)));\\n    expect(getFib(14), equals(getFib(13) + getFib(12)));\\n  });\\n}\\n\"",
    "fibonacci recursion": "\"/* Driver */\\nvoid main() {\\n  assert(fibonacci(1) == 1);\\n  assert(fibonacci(2) == 1);\\n  assert(fibonacci(3) == 2);\\n  assert(fibonacci(4) == 3);\\n  assert(fibonacci(5) == 5);\\n  assert(fibonacci(8) == 21);\\n}\\n\\n/**\\n * get Nth item of fibonacci\\n * fibonacci: 1 1 2 3 5 8 13 21 ...\\n */\\nint fibonacci(int n) =>\\n    n == 1 || n == 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2);\\n\"",
    "find max": "\"//find the max number\\nfind_max(List numbers) {\\n  var max = numbers[0];\\n  for (var x in numbers) {\\n    if (x > max) {\\n      max = x;\\n    }\\n  }\\n  print(max);\\n}\\n\\nvoid main() {\\n  find_max([2, 9, 18, 8, 76, -3]);\\n}\\n\"",
    "find max recursion": "\"void main() {\\n  List numbers = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10];\\n  int max = find_max_recursion(numbers, 0, numbers.length - 1);\\n  print(\\\"max = $max\\\");\\n}\\n\\n/**\\n * find min using divide-and-conquer algorithm\\n */\\nint find_max_recursion(List numbers, int low, int high) {\\n  if (low == high) {\\n    return numbers[low]; // or numbers[high]\\n  }\\n  int mid = (low + high) >> 1;\\n  int leftMax =\\n      find_max_recursion(numbers, low, mid); /* max in range [low mid] */\\n  int rightMax = find_max_recursion(\\n      numbers, mid + 1, high); /* max in range [mid + 1, high] */\\n  return leftMax >= rightMax ? leftMax : rightMax;\\n}\\n\"",
    "find min": "\"//find the min number\\nfind_min(List numbers) {\\n  var min = numbers[0];\\n  for (var x in numbers) {\\n    if (min > x) {\\n      min = x;\\n    }\\n  }\\n  print(min);\\n}\\n\\nvoid main() {\\n  find_min([2, 9, 18, 8, 76, -3]);\\n}\\n\"",
    "find min recursion": "\"void main() {\\n  List numbers = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10];\\n  int min = find_min_recursion(numbers, 0, numbers.length - 1);\\n  print(\\\"min = $min\\\");\\n}\\n\\n/**\\n * find max using divide-and-conquer algorithm\\n */\\nint find_min_recursion(List numbers, int low, int high) {\\n  if (low == high) {\\n    return numbers[low]; // or numbers[high]\\n  }\\n  int mid = (low + high) >> 1;\\n  int leftMin =\\n      find_min_recursion(numbers, low, mid); /* min in range [low mid] */\\n  int rightMin = find_min_recursion(\\n      numbers, mid + 1, high); /* min in range [mid + 1, high] */\\n  return leftMin <= rightMin ? leftMin : rightMin;\\n}\\n\"",
    "hamming distance": "\"// The Hamming distance between two strings of equal length is\\n// the number of positions at which the corresponding symbols are different.\\n// https://en.wikipedia.org/wiki/Hamming_distance\\n\\nint hamming_distance(String stringA, String stringB) {\\n  //Calculates Hamming Distance\\n  int distance;\\n\\n  //strings must be of equal length\\n  if (stringA.length != stringB.length) {\\n    print('String lengths must be same!');\\n    return null;\\n  } else {\\n    distance = 0;\\n    for (var i = 0; i < stringA.length; i++) {\\n      if (stringA[i] != stringB[i]) {\\n        distance += 1;\\n      }\\n    }\\n  }\\n  return distance;\\n}\\n\\nvoid main() {\\n  String stringA;\\n  String stringB;\\n  int dist;\\n\\n  stringA = 'karolin';\\n  stringB = 'kathrin';\\n  dist = hamming_distance(stringA, stringB);\\n  print('Hamming Distance between $stringA and $stringB is $dist');\\n\\n  stringA = '1011101';\\n  stringB = '1001001';\\n  dist = hamming_distance(stringA, stringB);\\n  print('Hamming Distance between $stringA and $stringB is $dist');\\n}\\n\"",
    "kynea numbers": "\"import 'package:test/test.dart';\\n\\n// Function to calculate nth kynea number\\nint nthKyneaNumber(int n) {\\n  // Calculate nth kynea number\\n  // using formula ((2^n + 1)^2 ) -2\\n\\n  // Firstly calculate 2^n + 1\\n  n = (1 << n) + 1;\\n\\n  // Now calculate (2^n + 1)^2\\n  n = n * n;\\n\\n  // Now calculate ((2^n + 1)^2 ) - 2\\n  n = n - 2;\\n\\n  // return nth Kynea number\\n  return n;\\n}\\n\\n// Driver Program\\n\\nvoid main() {\\n  test(\\\"1th Kynea number equals to 7\\\", () {\\n    expect(nthKyneaNumber(1), equals(7));\\n  });\\n\\n  test(\\\"4th Kynea number equals to 287\\\", () {\\n    expect(nthKyneaNumber(4), equals(287));\\n  });\\n\\n  test(\\\"6th Kynea number equals to 4223\\\", () {\\n    expect(nthKyneaNumber(6), equals(4223));\\n  });\\n\\n  test(\\\"10th Kynea number equals to 1050623\\\", () {\\n    expect(nthKyneaNumber(10), equals(1050623));\\n  });\\n}\\n\"",
    "lineardiophantineeqn": "\"// Program Linear Diophantine equation\\n\\n//Find the GCD of two numbers\\nint gcd(int a, int b) {\\n  return (a % b == 0) ? b.abs() : gcd(b, a % b);\\n}\\n\\n// This function checks if integral solutions are possible\\nbool Isposs(int a, int b, int c) {\\n  return (c % gcd(a, b) == 0);\\n}\\n\\n//Driver function for Linear Diophantine Equations\\nint main() {\\n  int a = 3, b = 6, c = 9;\\n  if (Isposs(a, b, c) == true) {\\n    print(\\\"Possible\\\");\\n  } else {\\n    print(\\\"Not Possible\\\");\\n  }\\n  int x = 3, y = 6, z = 8;\\n  if (Isposs(x, y, z) == true) {\\n    print(\\\"Possible\\\");\\n  } else {\\n    print(\\\"Not Possible\\\");\\n  }\\n\\n  return 0;\\n}\\n\"",
    "lu decomposition": "\"/// Based on https://en.wikipedia.org/wiki/LU_decomposition\\n\\nimport 'dart:math';\\n\\nvoid swap<T>(List<T> collection, int index1, int index2) {\\n  T temp = collection[index1];\\n  collection[index1] = collection[index2];\\n  collection[index2] = temp;\\n}\\n\\nclass MatrixDimensionError extends Error {}\\n\\nclass NonInvertibleMatrixError extends Error {}\\n\\nclass LUPDecomposition {\\n  Matrix lu;\\n  List<int> pivot;\\n\\n  LUPDecomposition(this.lu, this.pivot);\\n}\\n\\nclass Matrix {\\n  List<List<double>> _values;\\n\\n  @override\\n  String toString() => this._values.toString();\\n\\n  int get nRows => this._values.length;\\n  int get nColumns => this.nRows == 0 ? 0 : this._values[0].length;\\n\\n  bool get isSquare => this.nRows == this.nColumns;\\n\\n  List<List<double>> get rows => this._values;\\n\\n  List<double> operator [](int n) => this._values[n];\\n\\n  Matrix operator +(Matrix other) {\\n    if (this.nRows != other.nRows || this.nColumns != other.nColumns) {\\n      throw new MatrixDimensionError();\\n    }\\n\\n    List<List<double>> values = [];\\n    for (int i = 0; i < this.nRows; i++) {\\n      List<double> newRow = [];\\n      for (int j = 0; j < this.nColumns; j++) {\\n        newRow.add(this[i][j] + other[i][j]);\\n      }\\n      values.add(newRow);\\n    }\\n\\n    return new Matrix(values);\\n  }\\n\\n  Matrix operator -(Matrix other) {\\n    if (this.nRows != other.nRows || this.nColumns != other.nColumns) {\\n      throw new MatrixDimensionError();\\n    }\\n\\n    List<List<double>> values = [];\\n    for (int i = 0; i < this.nRows; i++) {\\n      List<double> newRow = [];\\n      for (int j = 0; j < this.nColumns; j++) {\\n        newRow.add(this[i][j] - other[i][j]);\\n      }\\n\\n      values.add(newRow);\\n    }\\n\\n    return new Matrix(values);\\n  }\\n\\n  Matrix times(double n) {\\n    Matrix output = Matrix.from(this);\\n\\n    for (int i = 0; i < output.nRows; i++) {\\n      for (int j = 0; j < output.nColumns; j++) {\\n        output[i][j] *= n;\\n      }\\n    }\\n\\n    return output;\\n  }\\n\\n  Matrix operator *(Matrix other) {\\n    if (this.nColumns != other.nRows) {\\n      throw new MatrixDimensionError();\\n    }\\n\\n    List<List<double>> values = [];\\n    for (int i = 0; i < this.nRows; i++) {\\n      List<double> newRow = [];\\n      for (int j = 0; j < other.nColumns; j++) {\\n        double sum = 0;\\n        for (int k = 0; k < this.nColumns; k++) {\\n          sum += this[i][k] * other[k][j];\\n        }\\n        newRow.add(sum);\\n      }\\n      values.add(newRow);\\n    }\\n\\n    return new Matrix(values);\\n  }\\n\\n  LUPDecomposition decompose() {\\n    if (!this.isSquare) {\\n      throw new MatrixDimensionError();\\n    }\\n\\n    int matrixSize = this.nRows;\\n    List<int> pivot = List.generate(matrixSize + 1, (x) => x);\\n    Matrix output = Matrix.from(this);\\n\\n    for (int i = 0; i < matrixSize; i++) {\\n      double maxValue = 0;\\n      int maxIndex = i;\\n\\n      for (int j = i; j < matrixSize; j++) {\\n        if (output[j][i].abs() > maxValue) {\\n          maxValue = output[j][i].abs();\\n          maxIndex = j;\\n        }\\n      }\\n\\n      if (maxIndex != i) {\\n        swap(pivot, i, maxIndex);\\n        swap(output.rows, i, maxIndex);\\n\\n        pivot[matrixSize]++;\\n      }\\n\\n      for (int j = i + 1; j < matrixSize; j++) {\\n        output[j][i] /= output[i][i];\\n\\n        for (int k = i + 1; k < matrixSize; k++) {\\n          output[j][k] -= output[j][i] * output[i][k];\\n        }\\n      }\\n    }\\n\\n    return LUPDecomposition(output, pivot);\\n  }\\n\\n  Matrix transposition() {\\n    Matrix output = Matrix.zeros(nColumns, nRows);\\n\\n    for (int i = 0; i < output.nRows; i++) {\\n      for (int j = 0; j < output.nColumns; j++) {\\n        output[i][j] = this[j][i];\\n      }\\n    }\\n\\n    return output;\\n  }\\n\\n  Matrix inversion() {\\n    if (!this.isSquare) {\\n      throw new MatrixDimensionError();\\n    }\\n\\n    LUPDecomposition decomposition = this.decompose();\\n    Matrix output = Matrix.from(decomposition.lu);\\n\\n    int matrixSize = decomposition.lu.nRows;\\n\\n    for (int i = 0; i < matrixSize; i++) {\\n      for (int j = 0; j < matrixSize; j++) {\\n        output[j][i] = decomposition.pivot[j] == i ? 1 : 0;\\n\\n        for (int k = 0; k < j; k++) {\\n          output[j][i] -= decomposition.lu[j][k] * output[k][i];\\n        }\\n      }\\n\\n      for (int j = matrixSize - 1; j >= 0; j--) {\\n        for (int k = j + 1; k < matrixSize; k++) {\\n          output[j][i] -= decomposition.lu[j][k] * output[k][i];\\n        }\\n        output[j][i] /= decomposition.lu[j][j];\\n      }\\n    }\\n\\n    return output;\\n  }\\n\\n  double determinant() {\\n    if (this.nRows == 0 || this.nColumns == 0) {\\n      throw MatrixDimensionError();\\n    }\\n\\n    LUPDecomposition decomposition = decompose();\\n    int matrixSize = decomposition.lu.nColumns;\\n    double product = decomposition.lu[0][0];\\n\\n    for (int i = 1; i < matrixSize; i++) {\\n      product *= decomposition.lu[i][i];\\n    }\\n\\n    if (decomposition.pivot[matrixSize] - matrixSize % 2 == 0) {\\n      return product;\\n    } else {\\n      return -product;\\n    }\\n  }\\n\\n  Matrix.eye(int size) {\\n    this._values = [];\\n\\n    for (int i = 0; i < size; i++) {\\n      List<double> row = List.generate(size, (x) => 0);\\n      row[i] = 0;\\n      this._values.add(row);\\n    }\\n  }\\n\\n  Matrix.from(Matrix matrix) {\\n    this._values = matrix.rows.map((row) => List<double>.from(row)).toList();\\n  }\\n\\n  Matrix.zeros(int nRows, int nColumns) {\\n    this._values = [];\\n\\n    for (int i = 0; i < nRows; i++) {\\n      List<double> row = [];\\n      for (int j = 0; j < nColumns; j++) {\\n        row.add(0);\\n      }\\n      this._values.add(row);\\n    }\\n  }\\n\\n  Matrix(List<List<double>> values) {\\n    if (values.length != 0) {\\n      int rowLength = values[0].length;\\n      if (values.any((row) => row.length != rowLength)) {\\n        throw new MatrixDimensionError();\\n      }\\n    }\\n\\n    this._values = values;\\n  }\\n}\\n\\nList<double> solve(Matrix x, List<double> y) {\\n  if (x.nColumns != y.length) {\\n    throw new MatrixDimensionError();\\n  }\\n  LUPDecomposition decomposition = x.decompose();\\n\\n  int matrixHeight = x.nColumns;\\n  List<double> output = List.generate(matrixHeight, (x) => 0);\\n\\n  for (int i = 0; i < matrixHeight; i++) {\\n    output[i] = y[decomposition.pivot[i]];\\n\\n    for (int j = 0; j < i; j++) {\\n      output[i] -= decomposition.lu[i][j] * output[j];\\n    }\\n  }\\n\\n  for (int i = matrixHeight - 1; i >= 0; i--) {\\n    for (int j = i + 1; j < matrixHeight; j++) {\\n      output[i] -= decomposition.lu[i][j] * output[j];\\n    }\\n\\n    output[i] /= decomposition.lu[i][i];\\n  }\\n\\n  return output;\\n}\\n\\nList<double> ordinaryLeastSquare(Matrix x, Matrix y) {\\n  return ((x.transposition() * x).inversion() * x.transposition() * y)\\n      .transposition()\\n      .rows[0];\\n}\\n\\ndouble f(double x, double y) {\\n  return (2 * x) + (6 * y) + 4;\\n}\\n\\nvoid main() {\\n  Matrix a = new Matrix([\\n    [3, 2, -1],\\n    [2, -2, 4],\\n    [-1, 0.5, -1]\\n  ]);\\n  List<double> b = [1, -2, 0];\\n\\n  List<double> solution = solve(a, b);\\n  print(\\\"x=${solution[0]}, y=${solution[1]}, z=${solution[2]}\\\");\\n\\n  Matrix input = Matrix.zeros(10, 3);\\n  Matrix output = Matrix.zeros(10, 1);\\n\\n  Random rng = new Random();\\n  for (int i = 0; i < 10; i++) {\\n    double x = rng.nextInt(100).toDouble() + rng.nextDouble();\\n    double y = rng.nextInt(100).toDouble() + rng.nextDouble();\\n\\n    input[i][0] = x;\\n    input[i][1] = y;\\n    input[i][2] = 1;\\n\\n    output[i][0] = f(x, y);\\n  }\\n  List<double> coeffs = ordinaryLeastSquare(input, output);\\n  print(\\\"f(x, y) = x * ${coeffs[0]} + y * ${coeffs[1]} + ${coeffs[2]}\\\");\\n}\\n\"",
    "newton method": "\"import 'dart:math';\\n\\n/// Approximate derivative of [f] at [x]\\ndouble derivative(double Function(double) f, double x, [double h = 1e-10]) {\\n  return (f(x + h) - f(x - h)) / (2 * h);\\n}\\n\\n/// Find root of given [f] (x where [f(x)] == 0)\\ndouble findRoot(double Function(double) f,\\n    [double initialValue = 0, int iterations = 10, double h = 1e-10]) {\\n  double currentValue = initialValue;\\n  for (int i = 0; i < iterations; i++) {\\n    currentValue -= f(currentValue) / derivative(f, currentValue);\\n  }\\n\\n  return currentValue;\\n}\\n\\ndouble f(x) {\\n  return 2 * x + 4;\\n}\\n\\ndouble g(x) {\\n  return 2 * pow(x, 2) + 7 * x + 1;\\n}\\n\\nmain() {\\n  double fRoot = findRoot(f);\\n  double gRoot = findRoot(g);\\n  double sinRoot = findRoot(sin, 10);\\n\\n  print(\\\"f(x) = 2x + 4, f($fRoot) = ${f(fRoot)}\\\");\\n  print(\\\"g(x) = 2x^2 + 7x + 1, g($gRoot) = ${g(gRoot)}\\\");\\n  print(\\\"sin(${sinRoot / pi} * pi) = ${sin(sinRoot)}\\\");\\n}\\n\"",
    "palindrome number": "\"/* Driver */\\nvoid main() {\\n  assert(isPalindrome(12321) == true);\\n  assert(isPalindrome(0) == true);\\n  assert(isPalindrome(1) == true);\\n  assert(isPalindrome(123322) == false);\\n}\\n\\n/**\\n * Return true if [n] is palindrome number, otherwise false\\n * Throws [ArgumentError] if [n] is negative\\n */\\nbool isPalindrome(int n) {\\n  if (n < 0) {\\n    throw new ArgumentError(\\\"$n is negative\\\");\\n  }\\n  var copy = n;\\n  var reverseNumber = 0;\\n  while (n != 0) {\\n    reverseNumber = reverseNumber * 10 + n % 10;\\n    n = n ~/ 10;\\n  }\\n\\n  return copy == reverseNumber;\\n}\\n\"",
    "palindrome string": "\"/* Driver */\\nvoid main() {\\n  assert(isPalindrome(\\\"abcba\\\"));\\n  assert(isPalindrome(\\\"a\\\"));\\n  assert(isPalindrome(\\\"\\\"));\\n  assert(isPalindrome(\\\"abbcba\\\") == false);\\n}\\n\\n/**\\n * Return true if [string] is palindrome string, otherwise false\\n */\\nbool isPalindrome(String string) {\\n  if (string.length <= 1) {\\n    return true;\\n  }\\n\\n  for (int i = 0, limit = string.length ~/ 2; i <= limit; ++i) {\\n    if (string[i] != string[string.length - 1 - i]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\"",
    "palindrome string recursion": "\"/* Driver */\\nvoid main() {\\n  assert(isPalindrome(\\\"abcba\\\", 0, 4));\\n  assert(isPalindrome(\\\"a\\\", 0, 0));\\n  assert(isPalindrome(\\\"abbcba\\\", 0, 5) == false);\\n}\\n\\n/**\\n * Return true if [string] is palindrome string, otherwise false\\n */\\nbool isPalindrome(String string, int low, int high) {\\n  if (low == high) {\\n    return true;\\n  } else if (string[low] != string[high]) {\\n    return false;\\n  } else {\\n    return isPalindrome(string, low + 1, high - 1);\\n  }\\n}\\n\"",
    "perfect number": "\"/* \\n * From: https://www.britannica.com/science/perfect-number\\n *\\n * A positive integer that is equal to the sum of its proper divisors. \\n * The smallest perfect number is 6, which is the sum of 1, 2, and 3. \\n * Other perfect numbers are 28, 496, and 8,128.\\n * \\n * */\\n\\n//this function returns true if number is perfect and false otherwise\\nbool perfect_number(int number) {\\n  if (number <= 1) return false;\\n  List<int> divisors = [];\\n  for (int i = 1; i < number; i++) {\\n    if (number % i == 0) divisors.add(i);\\n  }\\n  return divisors.reduce((a, b) => a + b) == number;\\n}\\n\\nvoid main() {\\n  print(perfect_number(-1)); // false\\n  print(perfect_number(6)); // true\\n  print(perfect_number(12)); // false\\n  print(perfect_number(16)); // false\\n  print(perfect_number(26)); // false\\n  print(perfect_number(27)); // false\\n  print(perfect_number(28)); // true\\n}\\n\"",
    "pow": "\"void main() {\\n  print(pow(10, 2)); // 100\\n  print(pow(2, 0)); // 1\\n  print(pow(2, 10)); // 1024\\n}\\n\\ndouble pow(int a, int b) {\\n  double result = 1;\\n  for (int i = 1; i <= b; i++) {\\n    result *= a;\\n  }\\n  return result;\\n}\\n\"",
    "power of two": "\"import 'package:test/test.dart';\\n\\nbool power_of_two(int n) {\\n  if (n == 0) return false;\\n\\n  return (n & (n - 1)) == 0;\\n}\\n\\nvoid main() {\\n  test(\\\"Test power_of_two 0 returns false\\\", () {\\n    expect(power_of_two(0), isFalse);\\n  });\\n\\n  test(\\\"Test power_of_two 1 returns true\\\", () {\\n    expect(power_of_two(1), isTrue);\\n  });\\n\\n  test(\\\"Test power_of_two 10 returns false\\\", () {\\n    expect(power_of_two(10), isFalse);\\n  });\\n\\n  test(\\\"Test power_of_two 10 returns false\\\", () {\\n    expect(power_of_two(10), isFalse);\\n  });\\n\\n  test(\\\"Test power_of_two 23 returns false\\\", () {\\n    expect(power_of_two(23), isFalse);\\n  });\\n\\n  test(\\\"Test power_of_two 32 returns true\\\", () {\\n    expect(power_of_two(32), isTrue);\\n  });\\n\\n  test(\\\"Test power_of_two 2234 returns false\\\", () {\\n    expect(power_of_two(2234), isFalse);\\n  });\\n\\n  test(\\\"Test power_of_two 2048 returns true\\\", () {\\n    expect(power_of_two(2048), isTrue);\\n  });\\n}\\n\"",
    "prime check": "\"import 'dart:math';\\n\\nvoid main() {\\n  List<int> numbers = [1, 2, 3, 4, 5, 9, 13];\\n  for (int number in numbers) {\\n    if (isPrime(number)) {\\n      print(\\\"$number is prime.\\\");\\n    } else {\\n      print(\\\"$number is not prime.\\\");\\n    }\\n  }\\n}\\n\\n/**\\n *check out whether number is prime number or not.\\n */\\nbool isPrime(int number) {\\n  if (number == 2) {\\n    return true;\\n  }\\n  if (number <= 1 || number % 2 == 0) {\\n    return false;\\n  }\\n\\n  for (int i = 3, limit = sqrt(number).toInt(); i <= limit; i += 2) {\\n    if (number % i == 0) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\"",
    "relu function": "\"// Program to Implement RELU function\\n// RELU function is commonly used in Machine learning as an activation function\\n\\nint relu_func(var x) {\\n  // here x passed is value passed in the function relu\\n  if (x > 0)\\n    return x;\\n  else\\n    return 0;\\n}\\n\\n//Driver function for RELU function\\nint main() {\\n  var a = 5;\\n  print(relu_func(a));\\n  var b = -1;\\n  print(relu_func(b));\\n  return 0;\\n}\\n\"",
    "shreedharacharya": "\"import 'dart:math';\\n\\n//this function return a list of roots of a quadratic equation\\n// [x1, x2] where x1 and x2 are roots of\\n// aX^2 + bX + c = 0\\nList shreedharacharya(double a, double b, double c) {\\n  double d = b * b - 4 * a * c;\\n  List A = [];\\n  if (d < 0) {\\n    print('Imaginary roots');\\n  } else if (d == 0) {\\n    A.add(-b / (2 * a));\\n  } else {\\n    A.add((-b + sqrt(d)) / (2 * a));\\n    A.add((-b - sqrt(d)) / (2 * a));\\n  }\\n  return A;\\n}\\n\\nvoid main() {\\n  double a = 1.00, b = -4.00, c = 4.00;\\n  List p = shreedharacharya(a, b, c);\\n  print(p);\\n}\\n\"",
    "sieve of eratosthenes": "\"/*\\n  * Source:\\n  *   https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\\n  * \\n  * Description:\\n  *   Calculates prime numbers till a number n\\n  * \\n  * Time Complexity:\\n  *   O(n log(log(n)))\\n  */\\n\\nList<bool> sieve_of_eratosthenes(int n) {\\n  // Input: n: int\\n  // Output: is_prime: List<bool> denoting whether ith element is prime or not\\n  List<bool> is_prime = new List.filled(n + 1, true);\\n  is_prime[0] = false;\\n  is_prime[1] = false;\\n  for (int i = 2; i * i <= n; i++) {\\n    if (is_prime[i]) {\\n      for (int j = i * i; j <= n; j += i) {\\n        // mark all multiples of i as false\\n        is_prime[j] = false;\\n      }\\n    }\\n  }\\n  return is_prime;\\n}\\n\\nmain() {\\n  // Prints all the primes under 50\\n  List<bool> primes = sieve_of_eratosthenes(50);\\n  for (int i = 2; i <= 50; i++) {\\n    if (primes[i]) {\\n      print(i);\\n    }\\n  }\\n}\\n\"",
    "sigmoid": "\"import 'dart:math';\\n\\ndouble sigmoid(\\n    double x, double a) //x is the function variable and a is the gain\\n{\\n  double p = exp(-a * x);\\n  return 1 / (1 + p);\\n}\\n\\nvoid main() {\\n  double gain = 1.00, x = 0.5;\\n  double p = sigmoid(x, gain);\\n  print(p);\\n}\\n\"",
    "simpson rule": "\"/// Approximate definite integral of f in [a, b] interval\\ndouble simpson(double Function(double) f, double a, double b, int n) {\\n  if (n <= 0) {\\n    throw ArgumentError(\\\"n have to be greater than 0\\\");\\n  }\\n\\n  double step = (b - a) / n;\\n  double sum = f(a) + f(b);\\n\\n  for (int i = 1; i < n; i++) {\\n    if (i % 2 == 0) {\\n      sum += 2 * f(a + i * step);\\n    } else {\\n      sum += 4 * f(a + i * step);\\n    }\\n  }\\n\\n  return (step / 3) * sum;\\n}\\n\\ndouble f(double x) {\\n  return x * x + 2 * x + 7;\\n}\\n\\nvoid main() {\\n  print(simpson(f, 0, 10, 10));\\n}\\n\"",
    "sphenic number": "\"import 'package:test/test.dart';\\n\\nvar arr = new List<bool>.filled(1001, true, growable: false);\\nvoid simple_seive() {\\n  for (int p = 2; p * p < 1001; p++) {\\n    if (arr[p]) {\\n      for (int i = p * 2; i < 1001; i = i + p) arr[i] = false;\\n    }\\n  }\\n}\\n\\nbool sphenic_number(int N) {\\n  var arr1 = new List<int>.filled(9, 0, growable: false);\\n\\n  var count = 0;\\n  var j = 0;\\n\\n  for (int i = 1; i <= N; i++) {\\n    if (N % i == 0 && count < 9) {\\n      count++;\\n      arr1[j] = i;\\n      j++;\\n    }\\n  }\\n\\n  return (count == 8 && arr[arr1[0]] && arr[arr1[1]] && arr[arr1[2]]);\\n}\\n\\nvoid main() {\\n  simple_seive();\\n  test(\\\"Test Sphenic_no returns false for non-sphenic numbers\\\", () {\\n    expect(sphenic_number(0), isFalse);\\n    expect(sphenic_number(371), isFalse);\\n    expect(sphenic_number(509), isFalse);\\n    expect(sphenic_number(501), isFalse);\\n  });\\n  test(\\\"Test sphenic_no returns true for sphenic numbers\\\", () {\\n    expect(sphenic_number(370), isTrue);\\n  });\\n}\\n\"",
    "symmetric derivative": "\"import 'dart:math';\\n\\n/// Approximate derivative of [f] at [x]\\ndouble derivative(double Function(double) f, double x, [double h = 1e-10]) {\\n  return (f(x + h) - f(x - h)) / (2 * h);\\n}\\n\\nvoid main() {\\n  print(\\\"derivative(sin, pi) = ${derivative(sin, pi)}, cos(pi) = ${cos(pi)}\\\");\\n  print(\\n      \\\"derivative(sin, 2 * pi) = ${derivative(sin, 2 * pi)}, cos(2 * pi) = ${cos(2 * pi)}\\\");\\n  print(\\\"derivative(exp, 3) = ${derivative(exp, 3)}, exp(3) = ${exp(3)}\\\");\\n}\\n\"",
    "ugly numbers": "\"import 'package:test/test.dart';\\n\\nint maxDivide(int a, int b) {\\n  var n;\\n  while (a % b == 0) {\\n    n = a / b;\\n    a = n.toInt();\\n  }\\n  return a;\\n}\\n\\n/* Function to check if a number is ugly or not */\\nbool isUgly(int no) {\\n  no = maxDivide(no, 2);\\n  no = maxDivide(no, 3);\\n  no = maxDivide(no, 5);\\n\\n  return no == 1;\\n}\\n\\n/* Function to get the nth ugly number*/\\nint getNthUglyNo(int n) {\\n  int i = 1;\\n  int count = 1; /* ugly number count */\\n\\n/*Check for all integers untill ugly count \\n\\tbecomes n*/\\n  while (n > count) {\\n    i++;\\n    if (isUgly(i)) count++;\\n  }\\n  return i;\\n}\\n\\n/* Driver program to test above functions */\\nvoid main() {\\n  test(\\\"getNthUglyNo(150) returns 5832\\\", () {\\n    expect(getNthUglyNo(150), equals(5832));\\n  });\\n\\n  test(\\\"isUgly returns true for 6\\\", () {\\n    expect(isUgly(6), isTrue);\\n  });\\n\\n  test(\\\"isUgly returns true for 5832\\\", () {\\n    expect(isUgly(5832), isTrue);\\n  });\\n\\n  test(\\\"isUgly returns false for 5833\\\", () {\\n    expect(isUgly(5833), isFalse);\\n  });\\n}\\n\"",
    "ackermann": "\"/// Here be dragons\\nint ackermann(int m, int n) {\\n  if (m == 0)\\n    return n + 1;\\n  else if (m > 0 && n == 0)\\n    return ackermann(m - 1, 1);\\n  else\\n    return ackermann(m - 1, ackermann(m, n - 1));\\n}\\n\\nvoid main() {\\n  print(\\\"A(2, 2) = ${ackermann(2, 2)}\\\");\\n  print(\\\"A(3, 3) = ${ackermann(3, 3)}\\\");\\n  print(\\\"A(3, 4) = ${ackermann(3, 4)}\\\");\\n  print(\\\"A(3, 5) = ${ackermann(3, 5)}\\\");\\n  //print(\\\"A(4, 4)=${ackermann(4, 4)}\\\"); /// too much recursionError raised right there\\n}\\n\"",
    "binpow": "\"// Effective computation of large exponents modulo a number\\n// Function binpow to calculate (x^n mod m)\\nint binPow(int a, int b, int m) {\\n  int result = 1;\\n  a %= m;\\n  if (a == 0) return 0;\\n  while (b > 0) {\\n    if (b % 2 == 1) {\\n      result = (result * a) % m;\\n    }\\n    b >>= 1;\\n    a = (a * a) % m;\\n  }\\n  return result;\\n}\\n\\nvoid main() {\\n  print('binary power of (2,5,13) = ' + binPow(2, 5, 13).toString());\\n  print('binary power of (5, 3,13) = ' + binPow(5, 3, 13).toString());\\n}\\n\"",
    "collatz": "\"//collatz conjecture:\\n//A series for a number n in which if n\\n//even then the next number is n/2,\\n//but if n is odd then the next number is 3n + 1.\\n//This series continues till it reaches 1\\n\\n//Author:Shawn\\n//Email:stepfencurryxiao@gmail.com\\n//Reference the C repo\\n\\nvoid main() {\\n  //The number\\n  double n = 20;\\n  //curr_no stores number n\\n  double curr_no = n;\\n  //Loop till series reaches 1\\n  while (curr_no != 1) {\\n    //condition for even number\\n    if (curr_no % 2 == 0) {\\n      curr_no = curr_no / 2;\\n      print(curr_no.toString() + \\\"->\\\");\\n    }\\n    //condition for odd number\\n    else {\\n      curr_no = (curr_no * 3) + 1;\\n      print(curr_no.toString() + \\\"->\\\");\\n    }\\n  }\\n  print(\\\"1\\\");\\n}\\n\"",
    "fisher yates shuffle": "\"import 'dart:math';\\n\\nRandom rng = new Random();\\n\\n/// Swap given [index1] and [index2] in given [collection]\\nvoid swap<T>(List<T> collection, int index1, int index2) {\\n  T temp = collection[index1];\\n  collection[index1] = collection[index2];\\n  collection[index2] = temp;\\n}\\n\\n/// Randomly shuffle given [collection] (inplace)\\nvoid shuffle<T>(List<T> collection) {\\n  for (int i = collection.length - 1; i > 1; i--) {\\n    swap(collection, i, rng.nextInt(i - 1));\\n  }\\n}\\n\\nmain() {\\n  List<double> someList = [1, 2, 3, 4, 5];\\n  print(someList);\\n  shuffle(someList);\\n  print(someList);\\n  shuffle(someList);\\n  print(someList);\\n  shuffle(someList);\\n  print(someList);\\n}\\n\"",
    "fizzbuzz": "\"//Title:FizzBuzz\\n// Author:ShivamVerma\\n// Email:shivamthegreat.sv@gmail.com\\n\\n// Write a program that prints the numbers from 1 to 100. But for multiples of three print \\\"Fizz\\\" instead of the number and for the multiples of five print \\\"Buzz\\\". For numbers which are multiples of both three and five print \\\"FizzBuzz\\\".\\n\\nvoid main() {\\n  fizzBuzz();\\n}\\n\\nvoid fizzBuzz() {\\n  for (int i = 1; i <= 100; i++) {\\n    if (i % 3 == 0 && i % 5 == 0) {\\n      print(\\\"FizzBuzz\\\");\\n    } else if (i % 3 == 0) {\\n      print(\\\"Fizz\\\");\\n    } else if (i % 5 == 0) {\\n      print(\\\"Buzz\\\");\\n    } else {\\n      print(i);\\n    }\\n  }\\n}\\n\"",
    "gcd": "\"//This is the Euclidean algorithm.\\r\\neuclidean_gcd(var a, var b) {\\r\\n  while (b != 0) {\\r\\n    var t = b;\\r\\n    b = a % b;\\r\\n    a = t;\\r\\n  }\\r\\n  return a;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n  print('GCD(1, 4) = ' + euclidean_gcd(1, 4).toString());\\r\\n  print('GCD(5, 3) = ' + euclidean_gcd(5, 3).toString());\\r\\n  print('GCD(3, 6) = ' + euclidean_gcd(3, 6).toString());\\r\\n  print('GCD(8, 4) = ' + euclidean_gcd(8, 4).toString());\\r\\n}\\r\\n\"",
    "haversine formula": "\"/// Based on https://www.movable-type.co.uk/scripts/latlong.html\\nimport \\\"dart:math\\\";\\n\\nconst double earthRadius = 6371;\\n\\n/// Earth radius in kilometers\\n\\nclass Coordinates {\\n  double latitude;\\n  double longitude;\\n\\n  Coordinates(this.latitude, this.longitude);\\n}\\n\\ndouble haversine(fi) => pow(sin(fi / 2), 2);\\n\\n/// Convert [angle] to radians\\ndouble radians(double angle) => (angle * pi) / 180;\\n\\n/// Calculate distance from [p1] to [p2] in kilometers\\n/// We assume that earth is perfect sphere (which is not true)\\n/// In practice you might expect ~1% errors\\ndouble distance(Coordinates p1, Coordinates p2) {\\n  double latitudeChange = radians(p2.latitude - p1.latitude);\\n  double latitude1 = radians(p1.latitude);\\n  double latitude2 = radians(p2.latitude);\\n  double longitudeChange = radians(p2.longitude - p1.longitude);\\n\\n  double a = haversine(latitudeChange) +\\n      cos(latitude1) * cos(latitude2) * haversine(longitudeChange);\\n  double c = 2 * atan2(sqrt(a), sqrt(1 - a));\\n\\n  return earthRadius * c;\\n}\\n\\nvoid main() {\\n  Coordinates newYork = new Coordinates(40.730610, -73.935242);\\n  Coordinates moskov = new Coordinates(55.751244, 37.618423);\\n  Coordinates toronto = new Coordinates(43.651070, -79.347015);\\n  Coordinates seoul = new Coordinates(37.532600, 127.024612);\\n\\n  print(\\\"distance(newYork, moskov) = ${distance(newYork, moskov)}km\\\");\\n  print(\\\"distance(newYork, toronto) = ${distance(newYork, toronto)}km\\\");\\n  print(\\\"distance(seoul, moskov) = ${distance(seoul, moskov)}km\\\");\\n  print(\\\"distance(moskov, seoul) = ${distance(moskov, seoul)}km\\\");\\n}\\n\"",
    "heaps algorithm": "\"/// Swap given [index1] and [index2] in given [collection]\\nvoid swap<T>(List<T> collection, int index1, int index2) {\\n  T temp = collection[index1];\\n  collection[index1] = collection[index2];\\n  collection[index2] = temp;\\n}\\n\\n/// Returns all permutations of given [collection]\\nList<List<T>> permutations<T>(List<T> collection) {\\n  List<int> stack = List.generate(collection.length, (x) => 0);\\n\\n  List<T> currentPermutation = List.from(collection);\\n  List<List<T>> output = [collection];\\n\\n  int i = 0;\\n  while (i < collection.length) {\\n    if (stack[i] < i) {\\n      if (i % 2 == 0) {\\n        swap(currentPermutation, 0, i);\\n      } else {\\n        swap(currentPermutation, stack[i], i);\\n      }\\n      output.add(List.from(currentPermutation));\\n      stack[i]++;\\n      i = 0;\\n    } else {\\n      stack[i] = 0;\\n      i++;\\n    }\\n  }\\n  return output;\\n}\\n\\nmain() {\\n  print(permutations([]));\\n  print(permutations([1, 2]));\\n  print(permutations([1, 2, 3]));\\n\\n  print(\\\"3! = ${permutations([1, 2, 3]).length}\\\");\\n  print(\\\"4! = ${permutations([1, 2, 3, 4]).length}\\\");\\n  print(\\\"5! = ${permutations([1, 2, 3, 4, 5]).length}\\\");\\n  print(\\\"6! = ${permutations([1, 2, 3, 4, 5, 6]).length}\\\");\\n}\\n\"",
    "kadanealgo": "\"// Program to find the Maximum contiguous sum (Kadane's Algorithm)\\n// Function to Calculate Maximum of Two Number\\nint max(int a, int b) {\\n  if (a > b)\\n    return a;\\n  else\\n    return b;\\n}\\n\\n// Function to find the Maximum contiguous Sum in the array\\nint maxSubArraySum(List a, int size) {\\n  int max_so_far = a[0];\\n  int curr_max = a[0];\\n\\n  for (int i = 1; i < size; i++) {\\n    curr_max = max(a[i], curr_max + a[i]);\\n    max_so_far = max(max_so_far, curr_max);\\n  }\\n  return max_so_far;\\n}\\n\\n// main function for validation of the above\\nint main() {\\n  List a = [-2, -3, 4, -1, -2, 1, 5, -3];\\n  int n = a.length;\\n  int max_sum = maxSubArraySum(a, n);\\n  print(\\\"Maximum contiguous sum is \\\" + max_sum.toString());\\n  return 0;\\n}\\n\"",
    "lcm": "\"//Title:Find LCM of two numbers.\\n//Author:Shawn\\n//Email:stepfencurryxiao@gmail.com\\n\\n/*suppose we have two numbers a and b.\\n * Property: Since product of LCM and GCD of two numbers are\\n * equal to product of that number itself.\\n * i.e, LCM(a,b)*GCD(a,b)=a*b\\n * So,here we first find GCD of two numbers and using above\\n * property we find LCM of that two numbers.\\n */\\n\\n//Recursive function to return gcd of a and b\\nint gcd(int a, int b) {\\n  if (a == 0) {\\n    return b;\\n  }\\n  return gcd(b % a, a);\\n}\\n\\n//Function to return LCM of two numbers\\ndouble lcm(int a, int b) {\\n  return (a * b) / gcd(a, b);\\n}\\n\\n//Driver program\\nvoid main() {\\n  var a, b;\\n  //Test case1:\\n  a = 15;\\n  b = 20;\\n  //print the result\\n  print(\\\"LCM of \\\" +\\n      a.toString() +\\n      \\\" and \\\" +\\n      b.toString() +\\n      \\\" is \\\" +\\n      lcm(a, b).toString());\\n  //Test case2:\\n  a = 12;\\n  b = 18;\\n  //print the result\\n  print(\\\"LCM of \\\" +\\n      a.toString() +\\n      \\\" and \\\" +\\n      b.toString() +\\n      \\\" is \\\" +\\n      lcm(a, b).toString());\\n}\\n\"",
    "magic number": "\"import 'package:test/test.dart';\\n\\nbool Magic_no(var x) {\\n  var result = x % 9;\\n  return result == 1;\\n}\\n\\nvoid main() {\\n  test(\\\"Test Magic_no returns false for non-magic numbers\\\", () {\\n    expect(Magic_no(0), isFalse);\\n    expect(Magic_no(371), isFalse);\\n    expect(Magic_no(509), isFalse);\\n    expect(Magic_no(501), isFalse);\\n  });\\n\\n  test(\\\"Test Magic_no returns true for magic numbers\\\", () {\\n    expect(Magic_no(10), isTrue);\\n    expect(Magic_no(370), isTrue);\\n  });\\n}\\n\"",
    "moore voting algorithm": "\"import 'package:test/test.dart';\\n\\nint majorityElement(List<int> arr, int n) {\\n  arr.sort();\\n\\n  var count = 1, max_ele = -1, temp = arr[0], ele = 0, f = 0;\\n\\n  for (int i = 1; i < n; i++) {\\n    if (temp == arr[i]) {\\n      count++;\\n    } else {\\n      count = 1;\\n      temp = arr[i];\\n    }\\n    if (max_ele < count) {\\n      max_ele = count;\\n      ele = arr[i];\\n\\n      if (max_ele > (n / 2)) {\\n        f = 1;\\n        break;\\n      }\\n    }\\n  }\\n  return (f == 1 ? ele : -1);\\n}\\n\\n// Driver code\\nvoid main() {\\n  test(\\\"majorityElement\\\", () {\\n    List<int> a1 = [1, 2, 2, 2, 2, 5, 1];\\n    expect(majorityElement(a1, a1.length), equals(2));\\n\\n    List<int> a2 = [30, 30, 40, 30, 40, 30, 40];\\n    expect(majorityElement(a2, a2.length), equals(30));\\n  });\\n\\n  test(\\\"majorityElement returns -1 when there is no dominant element\\\", () {\\n    List<int> a1 = [3, 3, 22, 21, 21, 5, 21];\\n    expect(majorityElement(a1, a1.length), equals(-1));\\n\\n    List<int> a2 = [100, 4000, 220, 220, 220, 100, 4000];\\n    expect(majorityElement(a2, a2.length), equals(-1));\\n  });\\n}\\n\"",
    "n bonacci": "\"import 'package:test/test.dart';\\n\\nList N_bonacci(int n, int m) {\\n  List v = new List(m);\\n  var i;\\n  for (i = 0; i < m; i++) {\\n    v[i] = 0;\\n  }\\n  v[n - 1] = 1;\\n  v[n] = 1;\\n  for (i = n + 1; i < m; i++) {\\n    v[i] = 2 * v[i - 1] - v[i - 1 - n];\\n  }\\n\\n  return v;\\n}\\n\\nvoid main() {\\n  test(\\\"For n=2 N_bonacci is same as fibbonaci\\\", () {\\n    expect(N_bonacci(2, 6), equals([0, 1, 1, 2, 3, 5]));\\n  });\\n\\n  test(\\\"For n=3 N_bonacci is same as tribbonaci\\\", () {\\n    expect(N_bonacci(3, 7), equals([0, 0, 1, 1, 2, 4, 7]));\\n  });\\n\\n  test(\\\"n=4 N_bonacci\\\", () {\\n    expect(N_bonacci(4, 10), equals([0, 0, 0, 1, 1, 2, 4, 8, 15, 29]));\\n  });\\n\\n  test(\\\"n=6 N_bonacci\\\", () {\\n    expect(N_bonacci(6, 10), equals([0, 0, 0, 0, 0, 1, 1, 2, 4, 8]));\\n  });\\n\\n  test(\\\"n=8 N_bonacci\\\", () {\\n    expect(N_bonacci(8, 10), equals([0, 0, 0, 0, 0, 0, 0, 1, 1, 2]));\\n  });\\n}\\n\"",
    "swap all odd and even bits": "\"import 'package:test/test.dart';\\n\\n//we are given an integer,the tast is to get its binary representation,swap all odd and even bits and print the new number\\nint swapbits(int n) {\\n  return (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n}\\n\\nvoid main() {\\n  test(\\\"swapbits returns 1 for 2\\\", () {\\n    expect(swapbits(2), equals(1));\\n  });\\n\\n  test(\\\"swapbits returns 23 for 43\\\", () {\\n    expect(swapbits(43), equals(23));\\n  });\\n\\n  test(\\\"swapbits returns 43 for 23\\\", () {\\n    expect(swapbits(23), equals(43));\\n  });\\n}\\n\"",
    "tower of hanoi": "\"moveDisk(String fp, String tp) {\\r\\n  print('moving disk from ' + fp + ' to ' + tp);\\r\\n}\\r\\n\\r\\nmoveTower(int height, var fromPole, var toPole, var withPole) {\\r\\n  if (height >= 1) {\\r\\n    moveTower(height - 1, fromPole, withPole, fromPole);\\r\\n    moveDisk(fromPole, toPole);\\r\\n    moveTower(height - 1, withPole, toPole, fromPole);\\r\\n  }\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n  int height = 3;\\r\\n  moveTower(height, 'A', 'B', 'C');\\r\\n  /*\\r\\n  moving disk from A to A\\r\\n  moving disk from A to C\\r\\n  moving disk from A to C\\r\\n  moving disk from A to B\\r\\n  moving disk from C to A\\r\\n  moving disk from C to B\\r\\n  moving disk from A to B\\r\\n  */\\r\\n}\\r\\n\"",
    "binary search": "\"int binary_search(List a, int l, int r, int x) {\\n  if (r >= l) {\\n    int middle = (l + (r - l) / 2).toInt();\\n\\n    //If the element is present at middle\\n    if (a[middle] == x) {\\n      return middle;\\n    }\\n\\n    //If the element is smaller than middle\\n    if (a[middle] > x) {\\n      return binary_search(a, l, middle - 1, x);\\n    }\\n\\n    return binary_search(a, middle + 1, r, x);\\n  }\\n  return -1;\\n}\\n\\nvoid main() {\\n  List list = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89];\\n  int x = 55;\\n  int n = list.length;\\n  int index = binary_search(list, 0, n - 1, x);\\n  print('list:');\\n  print(list);\\n  if (index != -1) {\\n    print('$x found at positions: $index');\\n  } else {\\n    print('$x Not found');\\n  }\\n}\\n\"",
    "binary search recursion": "\"/* Driver */\\nvoid main() {\\n  List<int> list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\\n\\n  int low = 0;\\n  int high = list.length - 1;\\n\\n  assert(binarySearch(list, low, high, 5) == 5);\\n  assert(binarySearch(list, low, high, 9) == 9);\\n  assert(binarySearch(list, low, high, 66) == -1);\\n}\\n\\n/**\\n * Return the index of [key] value in [list]\\n */\\nint binarySearch(List<int> list, int low, int high, int key) {\\n  if (low > high) {\\n    return -1; /* not found */\\n  }\\n  int mid = (low + high) >> 1;\\n  if (key == list[mid]) {\\n    return mid; /* found */\\n  } else if (key > list[mid]) {\\n    return binarySearch(\\n        list, mid + 1, high, key); /* search in range[mid + 1, high] */\\n  } else {\\n    return binarySearch(\\n        list, low, mid - 1, key); /* search in range[low, mid - 1] */\\n  }\\n}\\n\"",
    "fibonacci search": "\"//Title:Fibonacci Search\\n//Author:Shawn\\n//Email:stepfencurryxiao@gmail.com\\n\\nint fibMaonaccianSearch(List arr, int x, int n) {\\n  //Initialize fibonacci numbers\\n  //(m - 2)'th Fibonacci No\\n  int fibMMm2 = 0;\\n  //(m - 2)'th Fibonacci No\\n  int fibMMm1 = 1;\\n  //m'th Fibonacci\\n  int fibM = fibMMm2 + fibMMm1;\\n\\n  //fibM is going to store the smallest Fibonacci\\n  //Number greater than or equal to n\\n  while (fibM < n) {\\n    fibMMm2 = fibMMm1;\\n    fibMMm1 = fibM;\\n    fibM = fibMMm2 + fibMMm1;\\n  }\\n\\n  // Marks the eliminated range from front\\n  int offset = -1;\\n\\n  /*While three are elements to be inspected.\\n   * Note that we compare arr[fibMMm2] with x.\\n   * When fibM becomes 1,\\n   * fibMm2 becomes 0 */\\n  while (fibM > 1) {\\n    //Check if fibMMm2 is a valid location\\n\\n    //sets i to the min. of (offset + fibMMm2) and (n - 1)\\n    int i = ((offset + fibMMm2) < (n - 1)) ? (offset + fibMMm2) : (n - 1);\\n\\n    /* If x is greater than the value at index fibMmm2\\n     * cut the subarray array from offset to i\\n     */\\n\\n    if (arr[i] < x) {\\n      fibM = fibMMm1;\\n      fibMMm1 = fibMMm2;\\n      fibMMm2 = fibM - fibMMm1;\\n      offset = i;\\n    }\\n\\n    /* If x is greater than the value at index fibMmm2\\n     * cut the subarray array after i + 1.\\n     */\\n    else if (arr[i] > x) {\\n      fibM = fibMMm2;\\n      fibMMm1 = fibMMm1 - fibMMm2;\\n      fibMMm2 = fibM - fibMMm1;\\n    }\\n\\n    //elwment found.Return index\\n    else {\\n      return i;\\n    }\\n  }\\n\\n  //Comparing the last element with x\\n  if (arr[offset + 1] == x) {\\n    return offset + 1;\\n  }\\n\\n  //element not found :(\\n  return -1;\\n}\\n\\nvoid main() {\\n  //Get the array\\n  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\\n\\n  var result;\\n\\n  //Print the array\\n  print(arr);\\n\\n  //The size of the array\\n  var n = arr.length;\\n\\n  //Key to be searched in the array\\n  var key = 7;\\n\\n  //Search the key using ternarySearch\\n  result = fibMaonaccianSearch(arr, key, n);\\n\\n  //Print the result\\n  print(\\\"Index of \\\" + key.toString() + \\\" is \\\" + result.toString());\\n}\\n\"",
    "interpolation search": "\"/* By comparison, binary search always chooses the middle of the remaining\\n * search space, discarding one half or the other, depending on the comparison\\n * between the key found at the estimated position and the key sought. The remaining\\n * search space is reduced to the part before or after the estimated position.\\n * The linear search uses equality only as it compares elements one-by-one from the start, ignoring any sorting.\\n * On average the interpolation search makes about log(log(n)) comparisons (if the elements\\n * are uniformly distributed), where n is the number of elements to be searched. In the worst case\\n * (for instance where the numerical values of the keys increase exponentially) it can make up to O(n) comparisons.\\n * In interpolation-sequential search, interpolation is used to find an item near the one being searched for,\\n * then linear search is used to find the exact item. */\\n\\n//Author:Shawn\\n//Email:stepfencurryxiao@gmail.com\\n\\nint interpolationSearch(List arr, int n, int key) {\\n  int low = 0, high = n - 1;\\n  while (low <= high && key >= arr[low] && key <= arr[high]) {\\n    /* Calculate the nearest possible position of key */\\n    int pos = low +\\n        (((key - arr[low]) * (high - low)) / (arr[high] - arr[low])).round();\\n    if (key > arr[pos])\\n      low = pos + 1;\\n    else if (key < arr[pos])\\n      high = pos - 1;\\n    else /* Found */\\n      return pos;\\n  }\\n  /* Not found */\\n  return -1;\\n}\\n\\nint main() {\\n  //Get the arr\\n  List arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\\n  //The size of the arr\\n  var n = arr.length;\\n  //The Key\\n  var key = 5;\\n  print(\\\"I want to found $key at $arr\\\");\\n  //Get the index\\n  var index = interpolationSearch(arr, n, key);\\n  //print the result\\n  print(\\\"Element found at position: $index\\\");\\n  return 0;\\n}\\n\"",
    "jump search": "\"import 'dart:math' show sqrt;\\r\\n\\r\\nmin(X, Y) {\\r\\n  if (X < Y) {\\r\\n    return X;\\r\\n  } else {\\r\\n    return Y;\\r\\n  }\\r\\n}\\r\\n\\r\\nint jump_search(List a, int x) {\\r\\n  int n = a.length;\\r\\n  int step = sqrt(n).floor().toInt();\\r\\n  int prev = 0;\\r\\n  while (a[min(step, n) - 1] < x) {\\r\\n    prev = step;\\r\\n    step += sqrt(n).floor().toInt();\\r\\n    if (prev >= n) {\\r\\n      return -1;\\r\\n    }\\r\\n  }\\r\\n  while (a[prev] < x) {\\r\\n    prev = prev + 1;\\r\\n    if (prev == min(step, n)) {\\r\\n      return -1;\\r\\n    }\\r\\n  }\\r\\n  if (a[prev] == x) {\\r\\n    return prev;\\r\\n  }\\r\\n  return -1;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n  var list = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89];\\r\\n  var x = 55;\\r\\n  var index = jump_search(list, x);\\r\\n  print('list:');\\r\\n  print(list);\\r\\n  print('Number ' + x.toString() + ' is at index ' + index.toString());\\r\\n}\\r\\n\"",
    "linear search": "\"int linear_search(List<int> a, number) {\\r\\n  for (int i = 0; i < a.length; i++) {\\r\\n    if (a[i] == number) {\\r\\n      return i;\\r\\n    }\\r\\n  }\\r\\n  return -1;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n  List<int> list = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89];\\r\\n  int x = 15;\\r\\n  int index = linear_search(list, x);\\r\\n  print('list:');\\r\\n  print(list);\\r\\n  if (index != -1) {\\r\\n    print('$x found at positions: $index');\\r\\n  } else {\\r\\n    print('$x Not found');\\r\\n  }\\r\\n}\\r\\n\"",
    "peak element": "\"import 'package:test/test.dart';\\n\\nint findPeakUtil(List<int> arr, int low, int high, int n) {\\n  var x = (low + high) / 2;\\n  int mid = x.toInt();\\n  if ((mid == 0 || arr[mid - 1] <= arr[mid]) &&\\n      (mid == n - 1 || arr[mid + 1] <= arr[mid]))\\n    return mid;\\n  else if (mid > 0 && arr[mid - 1] > arr[mid])\\n    return findPeakUtil(arr, low, (mid - 1), n);\\n  else\\n    return findPeakUtil(arr, (mid + 1), high, n);\\n}\\n\\nint findPeak(List<int> arr, int n) {\\n  return findPeakUtil(arr, 0, n - 1, n);\\n}\\n\\nvoid main() {\\n  test(\\\"findPeak returns 2 for [1, 3, 20, 6, 1, 2]\\\", () {\\n    List<int> lst = [1, 3, 20, 6, 1, 2];\\n    expect(findPeak(lst, lst.length), equals(2));\\n  });\\n\\n  test(\\\"findPeak returns 3 for [1, 3, 20, 32, 1, 2]\\\", () {\\n    List<int> lst = [1, 3, 20, 32, 1, 2];\\n    expect(findPeak(lst, lst.length), equals(3));\\n  });\\n\\n  test(\\\"findPeak returns 2 for [321, 4353, 22320, 232, 23, 223]\\\", () {\\n    List<int> lst = [321, 4353, 22320, 232, 23, 223];\\n    expect(findPeak(lst, lst.length), equals(2));\\n  });\\n\\n  test(\\\"findPeak returns 2 for [121, 54, 2100, 36, 155, 90]\\\", () {\\n    List<int> lst = [121, 54, 2100, 36, 155, 90];\\n    expect(findPeak(lst, lst.length), equals(2));\\n  });\\n\\n  test(\\\"findPeak returns 2 for [5, 10, 20, 15]\\\", () {\\n    List<int> lst = [5, 10, 20, 15];\\n    expect(findPeak(lst, lst.length), equals(2));\\n  });\\n\\n  test(\\\"findPeak returns 1 for [10, 20, 15, 2, 23, 90, 67]\\\", () {\\n    List<int> lst = [10, 20, 15, 2, 23, 90, 67];\\n    expect(findPeak(lst, lst.length), equals(1));\\n  });\\n}\\n\"",
    "ternary search": "\"//Title:Ternary Search\\n//Author:Shawn\\n//Email:stepfencurryxiao@gmail.com\\n\\nint ternarySearch(var l, var r, var key, var arr) {\\n  if (r >= 1) {\\n    //Find the mid1 and mid2\\n    var mid1 = (l + (r - l) / 3).toInt();\\n    var mid2 = (r - (r - 1) / 3).toInt();\\n\\n    //Check if key is present at any mid\\n    if (arr[mid1] == key) return mid1;\\n\\n    if (arr[mid2] == key) return mid2;\\n\\n    /*Since Key is not present at mid\\n     * check in which region it is present\\n     * then repeat the Search operation\\n     * in that region\\n     */\\n\\n    if (key < arr[mid1]) {\\n      //The Key lies in between 1 and mid1\\n      return ternarySearch(l, mid1 - 1, key, arr);\\n    } else if (key > arr[mid2]) {\\n      //The key lies in between mid2 and r\\n      return ternarySearch(mid2 + 1, r, key, arr);\\n    } else {\\n      //The key lies in between mid1 and mid2\\n      return ternarySearch(mid1 + 1, mid2 - 1, key, arr);\\n    }\\n  }\\n\\n  //Key not found\\n  return -1;\\n}\\n\\n//Driver code\\nvoid main() {\\n  var l, r, p, key;\\n\\n  //Get the array\\n  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\\n\\n  //Print the array\\n  print(arr);\\n\\n  //Starting index\\n  l = 0;\\n\\n  // length of array\\n  r = arr.length;\\n\\n  //Checking for 5\\n  //Key to be searched in the array\\n  key = 5;\\n\\n  //Search the key using ternarySearch\\n  p = ternarySearch(l, r, key, arr);\\n\\n  //Print the result\\n  print(\\\"Index of \\\" + key.toString() + \\\" is \\\" + p.toString());\\n}\\n\"",
    "bubble sort": "\"import 'dart:math' show Random;\\r\\n\\r\\n//main function,the program start\\r\\nvoid main() {\\r\\n  final seed = 100, rnd = Random(), length = 100;\\r\\n  var list =\\r\\n      List<int>.generate(length, (i) => rnd.nextInt(seed), growable: false);\\r\\n  print('before sorting:');\\r\\n  print(list);\\r\\n  print('---------------------------------------------');\\r\\n  print('After sorting:');\\r\\n  bubbleSort(list);\\r\\n  print(list);\\r\\n}\\r\\n\\r\\nvoid bubbleSort(List<int> a) {\\r\\n  for (var i = 0, length = a.length; i < length - 1; ++i) {\\r\\n    bool swapped = false;\\r\\n    for (var j = 0; j < length - 1 - i; ++j) {\\r\\n      if (a[j] > a[j + 1]) {\\r\\n        /* swap */\\r\\n        var temp = a[j];\\r\\n        a[j] = a[j + 1];\\r\\n        a[j + 1] = temp;\\r\\n        swapped = true;\\r\\n      }\\r\\n    }\\r\\n    if (!swapped) {\\r\\n      break; /* array has been sorted */\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"",
    "cocktail sort": "\"void cocktailSort(List lst) //function to sort a list\\n{\\n  bool swap_done = true;\\n  do {\\n    swap_done = false;\\n    for (int i = 0; i < lst.length - 2; i++) {\\n      swap_done = swapItemCocktail(lst, i, swap_done);\\n    }\\n\\n    if (swap_done) {\\n      swap_done = false;\\n      for (int i = lst.length - 2; i >= 0; i--) {\\n        swap_done = swapItemCocktail(lst, i, swap_done);\\n      }\\n    }\\n  } while (swap_done);\\n}\\n\\nbool swapItemCocktail(List lst, int i, bool swap_done) {\\n  if (lst[i] > lst[i + 1]) {\\n    swap(lst, i);\\n    swap_done = true;\\n  }\\n  return swap_done;\\n}\\n\\nvoid swap(List lst, int i) {\\n  int tmp = lst[i];\\n  lst[i] = lst[i + 1];\\n  lst[i + 1] = tmp;\\n}\\n\\nvoid main() //driver function\\n{\\n  var lst = [5, 3, 6, 7, 3, 378, 3, 1, -1];\\n  print(lst);\\n  cocktailSort(lst);\\n  print(lst);\\n}\\n\"",
    "comb sort": "\"// function for combsort\\nvoid combSort(List list) {\\n  int gpVal = list.length;\\n  double shrink = 1.3;\\n  bool sortedBool = false;\\n\\n  while (!sortedBool) {\\n    gpVal = (gpVal / shrink).floor();\\n    if (gpVal > 1) {\\n      sortedBool = false;\\n    } else {\\n      gpVal = 1;\\n      sortedBool = true;\\n    }\\n\\n    int i = 0;\\n    while (i + gpVal < list.length) {\\n      if (list[i] > list[i + gpVal]) {\\n        swap(list, i, gpVal);\\n        sortedBool = false;\\n      }\\n      i++;\\n    }\\n  }\\n}\\n\\n// function to swap the values\\nvoid swap(List list, int i, int gpVal) {\\n  int temp = list[i];\\n  list[i] = list[i + gpVal];\\n  list[i + gpVal] = temp;\\n}\\n\\nvoid main() {\\n  //Get the dummy array\\n  List arr = [1, 451, 562, 2, 99, 78, 5];\\n  // for printing the array before sorting\\n  print(\\\"Before sorting the array: $arr\\\\n\\\");\\n  // applying combSort function\\n  combSort(arr);\\n  // printing the sortedBool value\\n  print(\\\"After sorting the array: $arr\\\");\\n}\\n\"",
    "gnome sort": "\"// Sorting of array using gnome sort\\n//Author:Shawn\\n//Email:stepfencurryxiao@gmail.com\\n\\n//Function sort the array using gnome sort\\nvoid gnomeSort(List arr, var n) {\\n  if (arr == null || n == 0) return;\\n  int first = 1;\\n  int second = 2;\\n\\n  while (first < n) {\\n    if (arr[first - 1] <= arr[first]) {\\n      first = second;\\n      second++;\\n    } else {\\n      int temp = arr[first - 1];\\n      arr[first - 1] = arr[first];\\n      arr[first] = temp;\\n      first -= 1;\\n      if (first == 0) {\\n        first = 1;\\n        second = 2;\\n      }\\n    }\\n  }\\n}\\n\\nvoid main() {\\n  //Get the array\\n  List arr = [10, 34, 6, 323, 7];\\n\\n  //Get size of the array\\n  int n = arr.length;\\n\\n  //print the array\\n  print(arr);\\n\\n  //Sorting of array using gnome sort\\n  gnomeSort(arr, n);\\n\\n  //print the result\\n  print(\\\"Sorted:\\\\n\\\" + arr.toString());\\n}\\n\"",
    "heap sort": "\"void sort(List arr) {\\n  //The length of the list\\n  int n = arr.length;\\n\\n  //Build heap (rearrange array)\\n  for (int i = (n / 2 - 1).round(); i >= 0; i--) {\\n    heapify(arr, n, i);\\n  }\\n\\n  // One by one extract an element from heap\\n  for (int i = n - 1; i >= 0; i--) {\\n    //Move current root to end\\n    var temp = arr[0];\\n    arr[0] = arr[i];\\n    arr[i] = temp;\\n\\n    //call max heapify on the reduce heap\\n    heapify(arr, i, 0);\\n  }\\n}\\n\\nvoid heapify(List arr, var n, var i) {\\n  //Init largest as root\\n  var largest = i;\\n  //left = 2*i + 1\\n  var l = 2 * i + 1;\\n  //right = 2*i + 2\\n  var r = 2 * i + 2;\\n\\n  // If left child is lager than root\\n  if (l < n && arr[l] > arr[largest]) largest = l;\\n\\n  // If right child is larger than largest so far\\n  if (r < n && arr[r] > arr[largest]) largest = r;\\n\\n  // If largest is not root\\n  if (largest != i) {\\n    var swap = arr[i];\\n    arr[i] = arr[largest];\\n    arr[largest] = swap;\\n\\n    //Recursively heapify the affected sub-tree\\n    heapify(arr, n, largest);\\n  }\\n}\\n\\nvoid main() {\\n  List list = [19, 48, 5, 7, 99, 10];\\n  sort(list);\\n  print(list);\\n}\\n\"",
    "insert sort": "\"import 'dart:math' show Random;\\r\\n\\r\\nvoid main() {\\r\\n  final seed = 100, rnd = Random(), length = 100;\\r\\n  var list =\\r\\n      List<int>.generate(length, (i) => rnd.nextInt(seed), growable: false);\\r\\n  print('before sorting:');\\r\\n  print(list);\\r\\n  print('----------------------------------------------');\\r\\n  print('After sorting:');\\r\\n  insertSort(list);\\r\\n  print(list);\\r\\n}\\r\\n\\r\\nvoid insertSort(List<int> a) {\\r\\n  for (var i = 1; i < a.length; i++) {\\r\\n    int j, t = a[i];\\r\\n    for (j = i - 1; j >= 0 && t < a[j]; j--) {\\r\\n      a[j + 1] = a[j];\\r\\n    }\\r\\n    if (j < i - 1) a[j + 1] = t;\\r\\n  }\\r\\n}\\r\\n\"",
    "merge sort": "\"import 'dart:math' show Random;\\n\\nvoid merge(List list, int lIndex, int mIndex, int rIndex) {\\n  int lSize = mIndex - lIndex + 1;\\n  int rSize = rIndex - mIndex;\\n\\n  List lList = new List(lSize);\\n  List rList = new List(rSize);\\n\\n  for (int i = 0; i < lSize; i++) lList[i] = list[lIndex + i];\\n  for (int j = 0; j < rSize; j++) rList[j] = list[mIndex + j + 1];\\n\\n  int i = 0, j = 0;\\n  int k = lIndex;\\n\\n  while (i < lSize && j < rSize) {\\n    if (lList[i] <= rList[j]) {\\n      list[k] = lList[i];\\n      i++;\\n    } else {\\n      list[k] = rList[j];\\n      j++;\\n    }\\n    k++;\\n  }\\n\\n  while (i < lSize) {\\n    list[k] = lList[i];\\n    i++;\\n    k++;\\n  }\\n\\n  while (j < rSize) {\\n    list[k] = rList[j];\\n    j++;\\n    k++;\\n  }\\n}\\n\\nvoid mergeSort(List list, int lIndex, int rIndex) {\\n  if (lIndex < rIndex) {\\n    int mIndex = (rIndex + lIndex) ~/ 2; // finds the middle index\\n\\n    mergeSort(list, lIndex, mIndex); // sorts the first half of the list\\n    mergeSort(list, mIndex + 1, rIndex); // sorts the second half of the list\\n\\n    merge(list, lIndex, mIndex, rIndex);\\n  }\\n}\\n\\nvoid main() {\\n  final seed = 100, rnd = Random(), length = 100;\\n  var list =\\n      List<int>.generate(length, (i) => rnd.nextInt(seed), growable: false);\\n  print('before sorting:');\\n  print(list);\\n  print('--------------------------------------');\\n  print('After sorting:');\\n  mergeSort(list, 0, list.length - 1);\\n  print(list);\\n}\\n\"",
    "pigeonhole sort": "\"import 'package:test/test.dart';\\n\\nvoid pigeonholeSort(List arr) {\\n  //The length of the list\\n  int n = arr.length;\\n\\n  //checking the size\\n  if (n <= 0) {\\n    return;\\n  }\\n\\n  //Find minimum and maximum values in arr\\n  int min = arr[0];\\n  int max = arr[0];\\n\\n  for (int i = 1; i < n; i++) {\\n    if (arr[i] < min) min = arr[i];\\n    if (arr[i] > max) max = arr[i];\\n  }\\n\\n  int range = max - min;\\n  range++;\\n\\n  List phole = new List(range);\\n  for (int i = 0; i < range; i++) {\\n    phole[i] = 0;\\n  }\\n\\n  //Populate the pigeonholes.\\n  for (int i = 0; i < n; i++) {\\n    phole[arr[i] - min];\\n    phole[arr[i] - min] = phole[arr[i] - min] + 1;\\n  }\\n\\n  //Put the elements back into the array in order\\n  int index = 0;\\n\\n  for (int j = 0; j < range; j++) while (phole[j]-- > 0) arr[index++] = j + min;\\n}\\n\\nvoid main() {\\n  test(\\\"Sort empty list returns empty list\\\", () {\\n    List list = [];\\n    pigeonholeSort(list);\\n    expect(list, isEmpty);\\n  });\\n\\n  test(\\\"Already sorted list remain sorted\\\", () {\\n    List list = [1, 2, 3, 4, 5];\\n    pigeonholeSort(list);\\n    expect(list, equals([1, 2, 3, 4, 5]));\\n  });\\n\\n  test(\\\"Sort\\\", () {\\n    List list = [87, 48, 5, 7, 135, 85];\\n    pigeonholeSort(list);\\n    expect(list, equals([5, 7, 48, 85, 87, 135]));\\n  });\\n\\n  test(\\\"Sorted list size doesnt change\\\", () {\\n    List list = [1, 1, 4, 1, -12, -12, 77];\\n    pigeonholeSort(list);\\n    expect(list.length, equals(7));\\n    expect(list, [-12, -12, 1, 1, 1, 4, 77]);\\n  });\\n}\\n\"",
    "quick sort": "\"import 'dart:math' show Random;\\r\\n\\r\\n// quickSort\\r\\n// O(n*log n)\\r\\nvoid main() {\\r\\n  var list = List<int>();\\r\\n  Random random = new Random();\\r\\n  for (var i = 0; i < 100; i++) {\\r\\n    list.add(random.nextInt(100));\\r\\n  }\\r\\n  print('before sorting:');\\r\\n  print(list);\\r\\n  print('---------------------------------------------');\\r\\n  print('After sorting:');\\r\\n  print(quickSort(list));\\r\\n}\\r\\n\\r\\nList<int> quickSort(List<int> a) {\\r\\n  if (a.length < 2) {\\r\\n    return a;\\r\\n  } else {\\r\\n    var pivot = a[0];\\r\\n    var less = <int>[];\\r\\n    var greater = <int>[];\\r\\n    a.removeAt(0);\\r\\n    for (var i in a) {\\r\\n      if (i <= pivot) {\\r\\n        less.add(i);\\r\\n      } else {\\r\\n        greater.add(i);\\r\\n      }\\r\\n    }\\r\\n    return quickSort(less) + [pivot] + quickSort(greater);\\r\\n  }\\r\\n}\\r\\n\"",
    "radix sort": "\"//radix sort\\n/*\\n radix sort is a non-comparative sorting algorithm. It avoids comparison by creating and distributing elements into buckets according to their radix.\\n  For elements with more than one significant digit, this bucketing process is repeated for each digit, \\n while preserving the ordering of the prior step, until all digits have been considered. For this reason, \\n radix sort has also been called bucket sort and digital sort.\\n */\\nimport 'dart:math' as Math;\\nimport 'dart:math' show Random;\\nimport 'package:test/test.dart';\\n\\nmain() {\\n  test(\\\"Sorting of empty list returns empty list\\\", () {\\n    expect(radixSort([]), equals([]));\\n  });\\n  test(\\\"Sorting one element list return same list\\\", () {\\n    expect(radixSort([1]), equals([1]));\\n  });\\n  test(\\\"Sorting two times doesnt change input\\\", () {\\n    List<int> lst = [5, 7, 1, 10, 54, -1];\\n    expect(radixSort(lst), equals(radixSort(radixSort(lst))));\\n  });\\n  test(\\\"Sorting already sorted list returns same list\\\", () {\\n    List<int> lst = [1, 2, 3, 4, 10];\\n    expect(radixSort(lst), equals(lst));\\n  });\\n  test(\\\"radix sort\\\", () {\\n    expect(radixSort([34, -2, 122, 24435, 23, 434, 232, 1323]),\\n        equals([-2, 23, 34, 122, 232, 434, 1323, 24435]));\\n  });\\n\\n  final seed = 10, rnd = Random(), length = 10;\\n  var list =\\n      List<int>.generate(length, (i) => rnd.nextInt(seed), growable: false);\\n  print('before sorting:');\\n  print(list);\\n  print('----------------------------------------------');\\n  print('After sorting:');\\n  print(radixSort(list));\\n}\\n\\ngetDigitNum(int n, int i) {\\n  var cal = (n.round().abs() / Math.pow(10, i)) % 10;\\n\\n  return cal.round();\\n}\\n\\ndigitCount(int number) {\\n  if (number == 0) {\\n    return 1;\\n  }\\n  return (number.abs().toString().length);\\n}\\n\\nmostDigits(List number) {\\n  var maxDigits = 0;\\n  for (var i = 0; i < number.length; i++) {\\n    maxDigits = Math.max(maxDigits, digitCount(number[i]));\\n  }\\n  return maxDigits;\\n}\\n\\nradixSort(List nums) {\\n  var maxDightCount = mostDigits(nums);\\n  for (var k = 0; k < maxDightCount; k++) {\\n    var digitBuckets = List.generate(10, (_) => []);\\n    for (var i = 0; i < nums.length; i++) {\\n      var digit = getDigitNum(nums[i], k);\\n      digitBuckets[digit].add(nums[i]);\\n    }\\n\\n    nums = digitBuckets.expand((lst) => lst).toList();\\n  }\\n  return nums;\\n}\\n\"",
    "select sort": "\"import 'dart:math' show Random;\\r\\n\\r\\n//main function,the program start\\r\\nvoid main() {\\r\\n  final seed = 100, rnd = Random(), length = 100;\\r\\n  var list =\\r\\n      List<int>.generate(length, (i) => rnd.nextInt(seed), growable: false);\\r\\n  print('before sorting:');\\r\\n  print(list);\\r\\n  print('--------------------------------------');\\r\\n  print('After sorting:');\\r\\n  selectSort(list);\\r\\n  print(list);\\r\\n}\\r\\n\\r\\nvoid selectSort(List<int> a) {\\r\\n  for (var i = 0; i < a.length - 1; i++) {\\r\\n    var mi = i;\\r\\n    for (var j = i + 1; j < a.length; j++) {\\r\\n      if (a[j] < a[mi]) mi = j;\\r\\n    }\\r\\n    if (i != mi) {\\r\\n      var t = a[i];\\r\\n      a[i] = a[mi];\\r\\n      a[mi] = t;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"",
    "shell sort": "\"import 'dart:math' show Random;\\r\\n\\r\\nvoid main() {\\r\\n  final seed = 100, rnd = Random(), length = 100;\\r\\n  var list =\\r\\n      List<int>.generate(length, (i) => rnd.nextInt(seed), growable: false);\\r\\n  print('before sorting:');\\r\\n  print(list);\\r\\n  print('----------------------------------------------');\\r\\n  print('After sorting:');\\r\\n  shellSort(list);\\r\\n  print(list);\\r\\n}\\r\\n\\r\\nvoid shellSort<E extends Comparable>(List<E> a) {\\r\\n  for (var i = _initInterval(a); i > 0; i = (i - 1) ~/ 3) {\\r\\n    for (var g = 0; g < i; g++) {\\r\\n      for (var j = i + g; j < a.length; j += i) {\\r\\n        var k = j - i, t = a[j];\\r\\n        while (k >= 0 && t.compareTo(a[k]) < 0) {\\r\\n          a[k + i] = a[k];\\r\\n          k -= i;\\r\\n        }\\r\\n        if (k < j - i) a[k + i] = t;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nint _initInterval<E>(List<E> a) {\\r\\n  var interval = 1;\\r\\n  while (interval < a.length ~/ 3) interval = interval * 3 + 1;\\r\\n  return interval;\\r\\n}\\r\\n\"",
    "tim sort": "\"import 'dart:math';\\n\\nconst int RUN = 32;\\nvoid insertionSort(List list, int left, int right) {\\n  for (int i = left + 1; i <= right; i++) {\\n    int temp = list[i];\\n    int j = i - 1;\\n    while (j >= left && list[j] > temp) {\\n      list[j + 1] = list[j];\\n      j--;\\n    }\\n    list[j + 1] = temp;\\n  }\\n}\\n\\nvoid merge(List list, int left, int middle, int right) {\\n  int length1 = middle - left + 1, length2 = right - middle;\\n  List leftList = new List(length1), rightList = new List(length2);\\n\\n  for (int i = 0; i < length1; i++) {\\n    leftList[i] = list[left + i];\\n  }\\n\\n  for (int i = 0; i < length2; i++) {\\n    rightList[i] = list[middle + 1 + i];\\n  }\\n\\n  int i = 0, j = 0, k = 0;\\n  while (i < length1 && j < length2) {\\n    if (leftList[i] <= rightList[j]) {\\n      list[k] = leftList[i];\\n      i++;\\n    } else {\\n      list[k] = rightList[j];\\n      j++;\\n    }\\n    k++;\\n  }\\n\\n  while (i < length1) {\\n    list[k] = leftList[i];\\n    i++;\\n    k++;\\n  }\\n\\n  while (j < length2) {\\n    list[k] = rightList[j];\\n    k++;\\n    j++;\\n  }\\n}\\n\\nvoid timSort(List list, int n) {\\n  for (int i = 0; i < n; i += RUN) {\\n    insertionSort(list, i, min((i + 31), n - 1));\\n  }\\n\\n  for (int size = RUN; size < n; size = 2 * size) {\\n    for (int left = 0; left < n; left += 2 * size) {\\n      int middle = left + size - 1;\\n      int right = min((left + 2 * size - 1), (n - 1));\\n      merge(list, left, middle, right);\\n    }\\n  }\\n}\\n\\nvoid main() {\\n  //Get the array\\n  List arr = [12, 213, 45, 9, 107];\\n  print(\\\"Before sorting: $arr\\\\n\\\");\\n  timSort(arr, arr.length);\\n  print(\\\"After sorting: $arr\\\");\\n}\\n\"",
    "knuth morris prat": "\"import 'package:test/test.dart';\\n\\n/// Preprocess pattern to identify any suffixes that are identical to prefixes\\n/// in the given string.\\n///\\n/// Build a pattern which tells us where to continue iteration from if we\\n///  get a mismatch between the character\\n///\\n/// Step through the text one character at a time and compare it to a character in\\n/// the pattern updating our location within the pattern if necessary\\nbool stringCompare(String string, String subString) {\\n  if (subString.isEmpty) {\\n    return false;\\n  }\\n\\n  List<int> pattern =\\n      new List<int>.generate(subString.length, (int index) => -1);\\n\\n  int i = 1;\\n  int j = 0;\\n\\n  while (i < subString.length) {\\n    if (subString[i] == subString[j]) {\\n      pattern[i] = j;\\n      i++;\\n      j++;\\n    } else if (j > 0) {\\n      j = pattern[j - 1] + 1;\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  return stringCompareHelper(string, subString, pattern);\\n}\\n\\nbool stringCompareHelper(String string, String subString, List<int> pattern) {\\n  int i = 0;\\n  int j = 0;\\n\\n  while (i + subString.length - j <= string.length) {\\n    if (string[i] == subString[j]) {\\n      if (j == subString.length - 1) {\\n        return true;\\n      }\\n      i++;\\n      j++;\\n    } else if (j > 0) {\\n      j = pattern[j - 1] + 1;\\n    } else {\\n      i++;\\n    }\\n  }\\n  return false;\\n}\\n\\nvoid main() {\\n  String string;\\n  String subString;\\n\\n  test(('KMP: '), () {\\n    string = 'aefoaefcdaefcdaed';\\n    subString = 'aefcdaed';\\n    expect(stringCompare(string, subString), isTrue);\\n  });\\n\\n  test(('KMP: '), () {\\n    string = 'testwafwafawfawfawfawfawfawfawfa';\\n    subString = 'fawfawfawfawfa';\\n    expect(stringCompare(string, subString), isTrue);\\n  });\\n\\n  test(('KMP: '), () {\\n    string = 'aabc';\\n    subString = 'abc';\\n    expect(stringCompare(string, subString), isTrue);\\n  });\\n\\n  test(('KMP: '), () {\\n    string = 'adafccfefbbbfeeccbcfd';\\n    subString = 'ecb';\\n    expect(stringCompare(string, subString), isFalse);\\n  });\\n\\n  test(('KMP: '), () {\\n    string = 'akash';\\n    subString = 'christy';\\n    expect(stringCompare(string, subString), isFalse);\\n  });\\n  test(('KMP: '), () {\\n    string = '';\\n    subString = 'asd';\\n    expect(stringCompare(string, subString), isFalse);\\n  });\\n\\n  test(('KMP: '), () {\\n    string = 'asd';\\n    subString = '';\\n    expect(stringCompare(string, subString), isFalse);\\n  });\\n}\\n\"",
    "remove duplicates": "\"import 'package:test/test.dart';\\n\\n// function to remove duplicate in string\\nString removeDups(String s) {\\n  var arr = new List.filled(256, 0);\\n  String l = '';\\n  int i = 0;\\n  for (i = 0; i < s.length; i++) {\\n    if (arr[s.codeUnitAt(i)] == 0) {\\n      l += s[i];\\n      arr[s.codeUnitAt(i)]++;\\n    }\\n  }\\n  return l;\\n}\\n\\nvoid main() {\\n  test(\\\"removeDups from string without duplicates returns same string\\\", () {\\n    expect(removeDups(\\\"1234\\\"), equals(\\\"1234\\\"));\\n  });\\n\\n  test(\\\"removeDups from empty list returns empty list\\\", () {\\n    expect(removeDups(\\\"\\\"), equals(\\\"\\\"));\\n  });\\n\\n  test(\\\"removeDups from 12341234 returns 1234\\\", () {\\n    expect(removeDups(\\\"12341234\\\"), equals(\\\"1234\\\"));\\n  });\\n\\n  test(\\\"removeDups from aaaab returns ab\\\", () {\\n    expect(removeDups(\\\"aaaab\\\"), equals(\\\"ab\\\"));\\n  });\\n}\\n\"",
    "reverse string": "\"/**\\n * Reverse String\\n */\\n\\nvoid main() {\\n  String stringToReverse = \\\"The Algorithms:Dart\\\";\\n  print('Method 1 =>  $stringToReverse\\\\t   ${reverseString(stringToReverse)}');\\n  print('Method 2 =>  $stringToReverse\\\\t   ${reverseString2(stringToReverse)}');\\n}\\n\\n/**\\n * * easiest way to reverses the string\\n */\\nString reverseString(String str) {\\n  return str.split('').reversed.join();\\n}\\n\\n/**\\n * Second way to reverses the string\\n */\\nString reverseString2(String str) {\\n  String reversed = \\\"\\\";\\n  for (int i = str.length - 1; i >= 0; i--) reversed += str[i];\\n  return reversed;\\n}\\n\"",
    "reverse words of string": "\"import 'package:test/test.dart';\\n\\nString reverseStringWords(String s) {\\n  String res = \\\"\\\";\\n  int m = s.length;\\n  int j = m - 1;\\n  for (int i = m - 1; i >= 0; i--) {\\n    if (s[i] == '.') {\\n      for (int j1 = i + 1; j1 <= j; j1++) {\\n        res += s[j1];\\n      }\\n      res += s[i];\\n      j = i - 1;\\n    } else if (i == 0) {\\n      for (int j1 = i; j1 <= j; j1++) {\\n        res += s[j1];\\n      }\\n    }\\n  }\\n  return res;\\n}\\n\\nvoid main() {\\n  test(\\\"reverseStringWords single word returns same word\\\", () {\\n    expect(reverseStringWords(\\\"word\\\"), equals(\\\"word\\\"));\\n  });\\n\\n  test(\\\"reverseStringWords w1.w2 returns w2.w1\\\", () {\\n    expect(reverseStringWords(\\\"w1.w2\\\"), equals(\\\"w2.w1\\\"));\\n  });\\n\\n  test(\\\"reverseStringWords on empty string returns empty string\\\", () {\\n    expect(reverseStringWords(\\\"\\\"), equals(\\\"\\\"));\\n  });\\n\\n  test(\\\"reverseStringWords\\\", () {\\n    expect(reverseStringWords(\\\"abhishek.is.a.good.boy\\\"),\\n        equals(\\\"boy.good.a.is.abhishek\\\"));\\n  });\\n}\\n\"",
    "basic binary tree": "\"//Author:Shawn\\n//Email:stepfencurryxiao@gmail.com\\n\\n/*This is Class Node with constructor that contains\\n * data variable to type data and left,right pointers\\n*/\\nclass Node {\\n  var data;\\n  var left;\\n  var right;\\n\\n  Node(var data) {\\n    this.data = data;\\n    this.left = null;\\n    this.right = null;\\n  }\\n}\\n\\n/*In order traversal of the tree*/\\nvoid display(var tree) {\\n  if (tree == null) {\\n    return;\\n  }\\n\\n  if (tree.left != null) {\\n    display(tree.left);\\n  }\\n\\n  print(tree.data);\\n\\n  if (tree.right != null) {\\n    display(tree.right);\\n  }\\n\\n  return;\\n}\\n\\n/*\\n *This is the recursive function to find the depth of\\n * binary tree.\\n*/\\ndouble depth_of_tree(var tree) {\\n  if (tree == null) {\\n    return 0;\\n  } else {\\n    var depth_l_tree = depth_of_tree(tree.left);\\n    var depth_r_tree = depth_of_tree(tree.right);\\n\\n    if (depth_l_tree > depth_r_tree) {\\n      return (1 + depth_l_tree);\\n    } else {\\n      return (1 + depth_r_tree);\\n    }\\n  }\\n}\\n\\n/*This function returns that is it full binary tree or not*/\\nbool is_full_binary_tree(var tree) {\\n  if (tree == null) {\\n    return true;\\n  }\\n  if (tree.left == null && tree.right == null) {\\n    return true;\\n  }\\n  if (tree.left != null && tree.right != null) {\\n    return (is_full_binary_tree(tree.left) && is_full_binary_tree(tree.right));\\n  } else {\\n    return false;\\n  }\\n}\\n\\n//Main function for testing\\nvoid main() {\\n  var tree = Node(1);\\n  tree.left = Node(2);\\n  tree.right = Node(3);\\n  tree.left.left = Node(4);\\n  tree.left.right = Node(5);\\n  tree.left.right.left = Node(6);\\n  tree.right.left = Node(7);\\n  tree.right.left.left = Node(8);\\n  tree.right.left.left.right = Node(9);\\n\\n  print(is_full_binary_tree(tree));\\n  print(depth_of_tree(tree));\\n  print(\\\"Tree is:\\\\n\\\");\\n  display(tree);\\n}\\n\"",
    "binary tree traversal": "\"import 'package:test/test.dart';\\n\\nclass TreeNode {\\n  int data;\\n  var leftNode = null;\\n  var rightNode = null;\\n\\n  int get value {\\n    return this.data;\\n  }\\n\\n  TreeNode get left {\\n    return this.leftNode;\\n  }\\n\\n  void set left(TreeNode value) {\\n    this.leftNode = value;\\n  }\\n\\n  void set right(TreeNode value) {\\n    this.rightNode = value;\\n  }\\n\\n  TreeNode get right {\\n    return this.rightNode;\\n  }\\n\\n  TreeNode(this.data);\\n}\\n\\nList<int> inOrder(TreeNode root, List<int> result) {\\n  if (root != null) {\\n    inOrder(root.left, result);\\n    result.add(root.value);\\n    inOrder(root.right, result);\\n  }\\n  return result;\\n}\\n\\nList<int> preOrder(TreeNode root, List<int> result) {\\n  if (root != null) {\\n    result.add(root.value);\\n    preOrder(root.left, result);\\n    preOrder(root.right, result);\\n  }\\n  return result;\\n}\\n\\nList<int> postOrder(TreeNode root, List<int> result) {\\n  if (root != null) {\\n    postOrder(root.left, result);\\n    postOrder(root.right, result);\\n    result.add(root.value);\\n  }\\n  return result;\\n}\\n\\nvoid main() {\\n  var root = TreeNode(1);\\n  root.left = TreeNode(2);\\n  root.right = TreeNode(3);\\n  root.left.left = TreeNode(4);\\n  root.left.right = TreeNode(5);\\n  root.left.right.left = TreeNode(6);\\n  root.right.left = TreeNode(7);\\n  root.right.left.left = TreeNode(8);\\n  root.right.left.left.right = TreeNode(9);\\n\\n  List<int> result;\\n  result = List();\\n\\n  test(('inOrder traversal'), () {\\n    result = List();\\n    expect(inOrder(root, result), equals([4, 2, 6, 5, 1, 8, 9, 7, 3]));\\n  });\\n\\n  test(('preOrder traversal'), () {\\n    result = List();\\n    expect(preOrder(root, result), equals([1, 2, 4, 5, 6, 3, 7, 8, 9]));\\n  });\\n\\n  test(('postOrder traversal'), () {\\n    result = List();\\n    expect(postOrder(root, result), equals([4, 6, 5, 2, 9, 8, 7, 3, 1]));\\n  });\\n\\n  test(('postOrder traversal'), () {\\n    result = List();\\n    root = null;\\n    expect(postOrder(root, result), equals([]));\\n  });\\n\\n  test(('inOrder traversal'), () {\\n    result = List();\\n    root = null;\\n    expect(inOrder(root, result), equals([]));\\n  });\\n\\n  test(('preOrder traversal'), () {\\n    result = List();\\n    root = null;\\n    expect(preOrder(root, result), equals([]));\\n  });\\n}\\n\"",
    "hashing": "\"//Author:Shawn\\n//Email:stepfencurryxiao@gmail.com\\n\\nclass Node {\\n  int data;\\n  Node next;\\n\\n  Node(int data) {\\n    this.data = data;\\n    this.next = null;\\n  }\\n}\\n\\nclass LinkedList {\\n  Node head;\\n  int size;\\n\\n  LinkedList() {\\n    head = null;\\n    size = 0;\\n  }\\n\\n  void insert(int data) {\\n    Node newnode = new Node(data);\\n\\n    size++;\\n\\n    if (head == null) {\\n      head = newnode;\\n    } else {\\n      newnode.next = head;\\n      head = newnode;\\n    }\\n  }\\n\\n  void delete(int data) {\\n    if (size == 0) {\\n      print(\\\"underFlow!\\\");\\n      return;\\n    } else {\\n      Node curr = head;\\n      if (curr.data == data) {\\n        head = curr.next;\\n        size--;\\n        return;\\n      } else {\\n        while (curr.next.next != null) {\\n          if (curr.next.data == data) {\\n            curr.next = curr.next.next;\\n            return;\\n          }\\n        }\\n        print(\\\"Key not found\\\");\\n      }\\n    }\\n  }\\n\\n  void display() {\\n    Node temp = head;\\n    while (temp != null) {\\n      print(temp.data.toString());\\n      temp = temp.next;\\n    }\\n    print(\\\"\\\\n\\\");\\n  }\\n}\\n\\nclass HashMap {\\n  int hsize;\\n  List<LinkedList> buckets;\\n\\n  HashMap(int hsize) {\\n    buckets = new List<LinkedList>(hsize);\\n    for (int i = 0; i < hsize; i++) {\\n      buckets[i] = new LinkedList();\\n    }\\n    this.hsize = hsize;\\n  }\\n\\n  int hashing(int key) {\\n    int hash = key % hsize;\\n    if (hash < 0) {\\n      hash += hsize;\\n    }\\n    return hash;\\n  }\\n\\n  void insertHash(int key) {\\n    int hash = hashing(key);\\n    buckets[hash].insert(key);\\n  }\\n\\n  void deleteHash(int key) {\\n    int hash = hashing(key);\\n    buckets[hash].delete(key);\\n  }\\n\\n  void displayHashtable() {\\n    for (int i = 0; i < hsize; i++) {\\n      print(\\\"Bucket $i:\\\");\\n      buckets[i].display();\\n    }\\n  }\\n}\\n\\nvoid main() {\\n  HashMap h = new HashMap(7);\\n\\n  print(\\\"Add key 5\\\");\\n  h.insertHash(5);\\n\\n  print(\\\"Add key 28\\\");\\n  h.insertHash(28);\\n\\n  print(\\\"Add key 1\\\");\\n  h.insertHash(1);\\n\\n  print(\\\"Delete Key 28\\\");\\n  h.deleteHash(28);\\n\\n  print(\\\"Print Table:\\\\n\\\");\\n  h.displayHashtable();\\n\\n  print(\\\"Delete Key 1\\\");\\n  h.deleteHash(1);\\n\\n  print(\\\"Print Table:\\\\n\\\");\\n  h.displayHashtable();\\n}\\n\"",
    "cycle in linked list": "\"import 'dart:math';\\nimport 'package:test/test.dart';\\n\\nclass Node {\\n  int value;\\n  Node next = null;\\n  Node(this.value);\\n\\n  int get nodeValue {\\n    return this.value;\\n  }\\n\\n  Node get nextNode {\\n    return this.next;\\n  }\\n}\\n\\nclass LinkedList {\\n  Node _headNode;\\n  Node _tailNode;\\n\\n  Node get head {\\n    return this._headNode;\\n  }\\n\\n  Node get tail {\\n    return this._tailNode;\\n  }\\n\\n  void insert(Node newNode) {\\n    if (head == null) {\\n      this._headNode = newNode;\\n      this._tailNode = newNode;\\n    } else {\\n      this._tailNode.next = newNode;\\n      this._tailNode = this._tailNode.next;\\n    }\\n  }\\n}\\n\\nNode createNode(int value) {\\n  return Node(value);\\n}\\n\\nNode findCyclicNode(Node headNode) {\\n  /// Check : https://en.wikipedia.org/wiki/Cycle_detection\\n  /// we maintain a fast and slow pointer\\n  /// The fast pointer jumps 2 nodes at a time\\n  /// and the slow pointer jumps one node at a time\\n  /// eventually the fast and slow will coincide on a node\\n  ///\\n  /// Then we place one of the node back to the head.\\n  /// The node where these two nodes coincide again will be the\\n  /// origin of the loop node.\\n  /// and move in tandem. check algorith for proof\\n  Node fastNode = headNode;\\n  Node slowNode = headNode;\\n\\n  while (fastNode != null && fastNode.next != null) {\\n    slowNode = slowNode.next;\\n    fastNode = fastNode.next.next;\\n\\n    if (slowNode == fastNode) {\\n      break;\\n    }\\n  }\\n\\n  if (slowNode == fastNode) {\\n    slowNode = headNode;\\n    while (slowNode != fastNode) {\\n      slowNode = slowNode.next;\\n      fastNode = fastNode.next;\\n    }\\n    return slowNode;\\n  } else {\\n    return null;\\n  }\\n}\\n\\nvoid main() {\\n  LinkedList linkedList = LinkedList();\\n  List<Node> allNodes = List();\\n  for (var i = 0; i <= 10; i++) {\\n    Node newNode = createNode(i);\\n    linkedList.insert(newNode);\\n    allNodes.add(newNode);\\n  }\\n  Node tail = linkedList.tail;\\n  Random random = new Random();\\n\\n  test(('test 1'), () {\\n    int randomIndex = random.nextInt(9);\\n    tail.next = allNodes[randomIndex];\\n    Node cycleNode = findCyclicNode(linkedList.head);\\n    expect(cycleNode, equals(allNodes[randomIndex]));\\n  });\\n  test(('test 2'), () {\\n    int randomIndex = random.nextInt(9);\\n    tail.next = allNodes[randomIndex];\\n    Node cycleNode = findCyclicNode(linkedList.head);\\n    expect(cycleNode, equals(allNodes[randomIndex]));\\n  });\\n\\n  test(('test 3'), () {\\n    int randomIndex = random.nextInt(9);\\n    tail.next = allNodes[randomIndex];\\n    Node cycleNode = findCyclicNode(linkedList.head);\\n    expect(cycleNode, equals(allNodes[randomIndex]));\\n  });\\n\\n  test(('test 4'), () {\\n    int randomIndex = random.nextInt(9);\\n    tail.next = allNodes[randomIndex];\\n    Node cycleNode = findCyclicNode(linkedList.head);\\n    expect(cycleNode, equals(allNodes[randomIndex]));\\n  });\\n\\n  test(('test 5'), () {\\n    int randomIndex = random.nextInt(9);\\n    tail.next = allNodes[randomIndex];\\n    Node cycleNode = findCyclicNode(linkedList.head);\\n    expect(cycleNode, equals(allNodes[randomIndex]));\\n  });\\n\\n  test(('test 6'), () {\\n    int randomIndex = random.nextInt(9);\\n    tail.next = allNodes[randomIndex];\\n    Node cycleNode = findCyclicNode(linkedList.head);\\n    expect(cycleNode, equals(allNodes[randomIndex]));\\n  });\\n\\n  test(('test 7'), () {\\n    int randomIndex = random.nextInt(9);\\n    tail.next = allNodes[randomIndex];\\n    Node cycleNode = findCyclicNode(linkedList.head);\\n    expect(cycleNode, equals(allNodes[randomIndex]));\\n  });\\n}\\n\"",
    "linked list": "\"import 'package:test/test.dart';\\n\\nclass Node<T> {\\n  Node<T> next;\\n  T value;\\n\\n  Node(this.value);\\n  Node.before(this.next, this.value);\\n}\\n\\nclass LinkedListIterator<T> extends Iterator<T> {\\n  Node<T> _current;\\n\\n  @override\\n  bool moveNext() => _current != null;\\n\\n  @override\\n  T get current {\\n    T currentValue = this._current.value;\\n\\n    this._current = this._current.next;\\n\\n    return currentValue;\\n  }\\n\\n  LinkedListIterator(this._current);\\n}\\n\\nclass LinkedList<T> extends Iterable<T> {\\n  int _length = 0;\\n  int get length => this._length;\\n\\n  Node<T> _head;\\n\\n  @override\\n  Iterator<T> get iterator => new LinkedListIterator<T>(this._head);\\n\\n  void remove(T item) {\\n    if (this._head?.value == item) {\\n      this._head = this._head?.next;\\n      this._length--;\\n    }\\n\\n    if (this._head != null) {\\n      Node<T> current = this._head;\\n      while (current?.next != null) {\\n        if (current.next.value == item) {\\n          current.next = current.next.next;\\n          this._length--;\\n        }\\n\\n        current = current.next;\\n      }\\n    }\\n  }\\n\\n  T pop() {\\n    if (this._head != null) {\\n      T value = this._head.value;\\n      this._head = this._head.next;\\n      this._length--;\\n\\n      return value;\\n    }\\n\\n    return null;\\n  }\\n\\n  void push(T item) {\\n    this._head = new Node.before(this._head, item);\\n    this._length++;\\n  }\\n\\n  void add(T item) {\\n    if (this._head == null) {\\n      this._head = new Node(item);\\n    } else {\\n      Node<T> current = this._head;\\n      while (current?.next != null) {\\n        current = current.next;\\n      }\\n\\n      current.next = Node(item);\\n    }\\n    this._length++;\\n  }\\n}\\n\\nmain() {\\n  test(\\\".add is adding elements in order\\\", () {\\n    LinkedList<double> linkedList = new LinkedList();\\n    linkedList.add(1);\\n    linkedList.add(2);\\n    linkedList.add(3);\\n\\n    expect(linkedList, equals([1, 2, 3]));\\n  });\\n\\n  test(\\\".remove is removing all elements with given value\\\", () {\\n    LinkedList<double> linkedList = new LinkedList();\\n    linkedList.add(1);\\n    linkedList.add(2);\\n    linkedList.add(3);\\n    linkedList.add(2);\\n\\n    linkedList.remove(2);\\n\\n    expect(linkedList, equals([1, 3]));\\n  });\\n\\n  test(\\\".remove on empty list do nothing\\\", () {\\n    LinkedList<double> linkedList = new LinkedList();\\n\\n    linkedList.remove(2);\\n\\n    expect(linkedList, isEmpty);\\n  });\\n\\n  test(\\\".push is appending first element\\\", () {\\n    LinkedList<double> linkedList = new LinkedList();\\n\\n    linkedList.push(1);\\n    expect(linkedList, equals([1]));\\n\\n    linkedList.push(2);\\n    expect(linkedList, equals([2, 1]));\\n\\n    linkedList.push(3);\\n    expect(linkedList, equals([3, 2, 1]));\\n  });\\n\\n  test(\\\".pop is returning and removing first element\\\", () {\\n    LinkedList<double> linkedList = new LinkedList();\\n\\n    linkedList.add(1);\\n    linkedList.add(2);\\n    linkedList.add(3);\\n\\n    expect(linkedList.pop(), equals(1));\\n    expect(linkedList, equals([2, 3]));\\n\\n    expect(linkedList.pop(), equals(2));\\n    expect(linkedList, equals([3]));\\n\\n    expect(linkedList.pop(), equals(3));\\n    expect(linkedList, equals([]));\\n  });\\n\\n  test(\\\".pop is returning null when list is empty\\\", () {\\n    LinkedList<double> linkedList = new LinkedList();\\n\\n    expect(linkedList.pop(), isNull);\\n  });\\n}\\n\"",
    "quad tree": "\"// Author: Jerold Albertson\\n// Profile: https://github.com/jerold\\n// Algorithm: https://en.wikipedia.org/wiki/Quadtree\\n\\nimport 'dart:math';\\nimport 'package:test/test.dart';\\n\\n// defaults should almost never be used, tune the quad tree to fit your problem\\nint default_max_depth = 1000;\\nint default_max_items = 100;\\n\\n// names reflect a coordinate system where values increase as one goes left or down\\nconst _upperLeftIndex = 0;\\nconst _upperRightIndex = 1;\\nconst _lowerLeftIndex = 2;\\nconst _lowerRightIndex = 3;\\n\\nclass Node<T> extends Rectangle<num> {\\n  final int maxDepth;\\n  final int maxItems;\\n\\n  final int _depth;\\n  final Point<num> _center;\\n  final List<_ItemAtPoint<T>> _items = <_ItemAtPoint<T>>[];\\n  final List<Node<T>> _children = <Node<T>>[];\\n\\n  factory Node(num left, num top, num width, num height,\\n          {int maxDepth, int maxItems}) =>\\n      Node._(left, top, width, height, maxDepth, maxItems, 0);\\n\\n  Node._(num left, num top, num width, num height, int maxDepth, int maxItems,\\n      int depth)\\n      : maxDepth = maxDepth ?? default_max_depth,\\n        maxItems = maxItems ?? default_max_items,\\n        _depth = depth,\\n        _center = Point<num>(left + width / 2.0, top + height / 2.0),\\n        super(left, top, width, height);\\n\\n  bool insert(T item, Point<num> atPoint) {\\n    if (!containsPoint(atPoint)) return false;\\n\\n    if (_children.isEmpty) {\\n      if (_items.length + 1 <= maxItems || _depth + 1 > maxDepth) {\\n        _items.add(_ItemAtPoint<T>(item, atPoint));\\n        return true;\\n      }\\n      _splitItemsBetweenChildren();\\n    }\\n    return _insertItemIntoChildren(item, atPoint);\\n  }\\n\\n  List<T> query(Rectangle range) {\\n    if (_children.isEmpty) {\\n      return _items\\n          .where((item) => range.containsPoint(item.point))\\n          .map((item) => item.item)\\n          .toList();\\n    }\\n    return _children\\n        .where((child) => child.intersects(range))\\n        .expand((child) => child.query(range))\\n        .toList();\\n  }\\n\\n  String toString() {\\n    return '[$_depth](${_items.map((item) => item.item).toList()}:$_children)';\\n  }\\n\\n  bool _insertItemIntoChildren(T item, Point<num> atPoint) {\\n    if (atPoint.x > _center.x) {\\n      if (atPoint.y > _center.y) {\\n        return _children[_lowerRightIndex].insert(item, atPoint);\\n      }\\n      return _children[_upperRightIndex].insert(item, atPoint);\\n    } else {\\n      if (atPoint.y > _center.y) {\\n        return _children[_lowerLeftIndex].insert(item, atPoint);\\n      } else {\\n        return _children[_upperLeftIndex].insert(item, atPoint);\\n      }\\n    }\\n  }\\n\\n  void _splitItemsBetweenChildren() {\\n    _children.addAll([\\n      _newUpperLeft, // _upperLeftIndex = 0\\n      _newUpperRight, // _upperRightIndex = 1\\n      _newLowerLeft, // _lowerLeftIndex = 2\\n      _newLowerRight // _lowerRightIndex = 3\\n    ]);\\n    for (final item in _items) {\\n      _insertItemIntoChildren(item.item, item.point);\\n    }\\n    _items.clear();\\n  }\\n\\n  Node<T> get _newUpperLeft => Node<T>._(\\n      left, top, width / 2.0, height / 2.0, maxDepth, maxItems, _depth + 1);\\n\\n  Node<T> get _newUpperRight => Node<T>._(_center.x, top, width / 2.0,\\n      height / 2.0, maxDepth, maxItems, _depth + 1);\\n\\n  Node<T> get _newLowerLeft => Node<T>._(left, _center.y, width / 2.0,\\n      height / 2.0, maxDepth, maxItems, _depth + 1);\\n\\n  Node<T> get _newLowerRight => Node<T>._(_center.x, _center.y, width / 2.0,\\n      height / 2.0, maxDepth, maxItems, _depth + 1);\\n}\\n\\nclass _ItemAtPoint<T> {\\n  final T item;\\n  final Point<num> point;\\n\\n  _ItemAtPoint(this.item, this.point);\\n}\\n\\nvoid main() {\\n  group('QuadTree', () {\\n    test('items will not insert at points outside the tree\\\\'s bounds', () {\\n      final tree = Node<String>(-50, -50, 100, 100);\\n      expect(tree.insert(\\\"a\\\", Point(-75, 0)), isFalse);\\n      expect(tree.insert(\\\"b\\\", Point(75, 0)), isFalse);\\n      expect(tree.insert(\\\"c\\\", Point(0, -75)), isFalse);\\n      expect(tree.insert(\\\"d\\\", Point(0, 75)), isFalse);\\n      expect(tree.toString(), equals(\\\"[0]([]:[])\\\"));\\n    });\\n\\n    test('maxItems is honored until maxDepth is hit', () {\\n      final tree = Node<String>(0, 0, 100, 100, maxItems: 2, maxDepth: 2);\\n\\n      expect(tree.insert(\\\"a\\\", Point(0, 0)), isTrue);\\n      expect(tree.toString(), equals(\\\"[0]([a]:[])\\\"));\\n\\n      expect(tree.insert(\\\"b\\\", Point(100, 0)), isTrue);\\n      expect(tree.toString(), equals(\\\"[0]([a, b]:[])\\\"));\\n\\n      expect(tree.insert(\\\"c\\\", Point(0, 100)), isTrue);\\n      expect(\\n          tree.toString(),\\n          equals(\\n              \\\"[0]([]:[[1]([a]:[]), [1]([b]:[]), [1]([c]:[]), [1]([]:[])])\\\"));\\n\\n      expect(tree.insert(\\\"d\\\", Point(100, 100)), isTrue);\\n      expect(\\n          tree.toString(),\\n          equals(\\n              \\\"[0]([]:[[1]([a]:[]), [1]([b]:[]), [1]([c]:[]), [1]([d]:[])])\\\"));\\n\\n      expect(tree.insert(\\\"e\\\", Point(99, 99)), isTrue);\\n      expect(tree.insert(\\\"f\\\", Point(99, 99)), isTrue);\\n      expect(tree.insert(\\\"g\\\", Point(99, 99)), isTrue);\\n      expect(tree.insert(\\\"h\\\", Point(99, 99)), isTrue);\\n      expect(\\n          tree.toString(),\\n          equals(\\n              \\\"[0]([]:[[1]([a]:[]), [1]([b]:[]), [1]([c]:[]), [1]([]:[[2]([]:[]), [2]([]:[]), [2]([]:[]), [2]([d, e, f, g, h]:[])])])\\\"));\\n    });\\n\\n    test(\\n        'better at finding local points within a large space than simple iteration',\\n        () {\\n      final rand = Random.secure();\\n      final items = <int, Point>{};\\n\\n      final width = 1000;\\n      final height = 1000;\\n\\n      var timesBetter = 0;\\n      final numberOfRuns = 100;\\n      // run the same test x number of times\\n      for (int j = 0; j < numberOfRuns; j++) {\\n        // test consists of setting up x items, distributing them randomly\\n        // within a space, and then searching for a small subset of those\\n        // using simple rect comparison on all items, or a quad tree query\\n        final tree = Node(0, 0, width, height);\\n        final numberOfItems = 50000;\\n        for (int i = 0; i < numberOfItems; i++) {\\n          items[i] =\\n              Point(rand.nextDouble() * width, rand.nextDouble() * height);\\n          expect(tree.insert(i, items[i]), isTrue);\\n        }\\n\\n        // set up a box that is 1/10th the size of the total space\\n        final rangeSizePercentage = .1;\\n        final rangeWidth = width * rangeSizePercentage;\\n        final rangeHeight = height * rangeSizePercentage;\\n        final rangeLeft = rand.nextDouble() * (width - rangeWidth);\\n        final rangeTop = rand.nextDouble() * (height - rangeHeight);\\n\\n        final range = Rectangle(rangeLeft, rangeTop, rangeWidth, rangeHeight);\\n\\n        // simple iteration over all items, comparing each to the given range\\n        var startTime = DateTime.now();\\n        final foundA =\\n            items.keys.where((key) => range.containsPoint(items[key])).toList();\\n        var iterationTime = DateTime.now().difference(startTime);\\n\\n        // quad tree query rules out whole quadrants full of points when possible\\n        startTime = DateTime.now();\\n        final foundB = tree.query(range);\\n        var quadTreeTime = DateTime.now().difference(startTime);\\n\\n        if (iterationTime.compareTo(quadTreeTime) > 0) {\\n          timesBetter++;\\n        }\\n\\n        // every time, quad tree query results should equal brute force results\\n        expect(foundA.toSet().containsAll(foundB), isTrue,\\n            reason: \\\"not all items were found\\\");\\n        expect(foundB.toSet().containsAll(foundA), isTrue,\\n            reason: \\\"not all items were found\\\");\\n      }\\n\\n      expect(timesBetter / numberOfRuns > 0.5, isTrue,\\n          reason:\\n              \\\"tree query was only better ${timesBetter / numberOfRuns * 100}% of the time\\\");\\n    });\\n  });\\n}\\n\"",
    "circular queue": "\"import 'package:test/test.dart';\\n\\n// author: kjain1810\\n// reference: https://en.wikipedia.org/wiki/Circular_buffer\\nconst int MAX_SIZE = 10;\\n\\nclass CircularQueue<T> {\\n  int start = -1, end = -1;\\n  List<T> queue = new List<T>(MAX_SIZE);\\n\\n  // insert elements into the queue\\n  void enque(T element) {\\n    if (start == -1) {\\n      start = 0;\\n      end = 0;\\n      queue[0] = element;\\n      return;\\n    }\\n    if (end == MAX_SIZE - 1 && start == 0) {\\n      print(\\\"The queue is full!!!\\\");\\n      return;\\n    }\\n    if (end == start - 1) {\\n      print(\\\"The queue is full!!!\\\");\\n      return;\\n    }\\n    end++;\\n    end %= MAX_SIZE;\\n    queue[end] = element;\\n  }\\n\\n  // remove elements from the queue\\n  T deque() {\\n    if (start == -1) {\\n      print(\\\"The queue is empty!!!\\\");\\n      return null;\\n    }\\n    T here = queue[start];\\n    if (start == end) {\\n      start = -1;\\n      end = -1;\\n      return here;\\n    }\\n    start++;\\n    start %= MAX_SIZE;\\n    return here;\\n  }\\n\\n  // get the size of the queue\\n  int size() {\\n    if (start == -1) return 0;\\n    if (start < end) return end - start + 1;\\n    return (MAX_SIZE - (start - end));\\n  }\\n\\n  // print all the elements of the queue\\n  void printAll() {\\n    if (start == -1) {\\n      print(\\\"The queue is empty!!!\\\");\\n      return;\\n    }\\n    int i = start;\\n    while (i != end) {\\n      i++;\\n      i %= MAX_SIZE;\\n      print(queue[i]);\\n    }\\n  }\\n}\\n\\nvoid main() {\\n  test(\\\"Initial CircularQueue is empty\\\", () {\\n    CircularQueue<int> queue = new CircularQueue<int>();\\n\\n    expect(queue.deque(), isNull);\\n  });\\n\\n  test(\\\"deque return first item put to CircularQueue\\\", () {\\n    CircularQueue<int> queue = new CircularQueue<int>();\\n    queue.enque(1);\\n\\n    expect(queue.deque(), equals(1));\\n  });\\n\\n  test(\\\"CircularQueue act as fifo\\\", () {\\n    CircularQueue<int> queue = new CircularQueue<int>();\\n    queue.enque(1);\\n    queue.enque(2);\\n    queue.enque(3);\\n\\n    expect(queue.deque(), equals(1));\\n    expect(queue.deque(), equals(2));\\n    expect(queue.deque(), equals(3));\\n  });\\n\\n  test(\\\"deque returns null after removing all items\\\", () {\\n    CircularQueue<int> queue = new CircularQueue<int>();\\n    queue.enque(1);\\n    queue.enque(2);\\n    queue.enque(3);\\n\\n    queue.deque();\\n    queue.deque();\\n    queue.deque();\\n\\n    expect(queue.deque(), isNull);\\n  });\\n}\\n\"",
    "list queue": "\"//Author:Shawn\\n//Email:stepfencurryxiao@gmail.com\\n\\nconst int MAX_SIZE = 10;\\n\\nclass ListQueue<T> {\\n  int count = 0;\\n  List<T> queue = new List<T>(MAX_SIZE);\\n\\n  //Checks if the queue has elements (not empty)\\n  bool hasElements() {\\n    if (queue.length == 0) {\\n      return false;\\n    } else {\\n      return true;\\n    }\\n  }\\n\\n  //Add an element to the queue\\n  void enque(T element) {\\n    if (count == MAX_SIZE) {\\n      print(\\\"The queue is full!!!\\\");\\n    } else {\\n      queue[count] = element;\\n      count++;\\n    }\\n  }\\n\\n  //Takes the next element from the queue\\n  T deque() {\\n    T result = null;\\n    if (count == 0) {\\n      print(\\\"The queue is empty!!!\\\");\\n    } else {\\n      result = queue[0];\\n      for (int i = 0; i < queue.length - 1; i++) {\\n        queue[i] = queue[i + 1];\\n      }\\n    }\\n    return result;\\n  }\\n}\\n\\nvoid main() {\\n  ListQueue<int> Queue = new ListQueue<int>();\\n  Queue.enque(12);\\n  Queue.enque(2);\\n  Queue.enque(7);\\n  print(Queue.queue);\\n  print(\\\"Enqueue:\\\");\\n  var returnData = Queue.deque();\\n  print(\\\"$returnData\\\\n\\\");\\n  print(\\\"Enqueue:\\\");\\n  returnData = Queue.deque();\\n  print(\\\"$returnData\\\\n\\\");\\n  print(\\\"Enqueue:\\\");\\n  returnData = Queue.deque();\\n  print(\\\"$returnData\\\\n\\\");\\n  print(\\\"Now the queue is: \\\" + (Queue.queue).toString());\\n}\\n\"",
    "priority queue": "\"class PriorityQueue<T> {\\n  List<QueueItem<T>> _dataStore = <QueueItem<T>>[];\\n\\n  int get size => _dataStore.length;\\n\\n  bool get isEmpty => _dataStore.isEmpty;\\n\\n  enqueue(T item, int priority) {\\n    QueueItem queueItem = new QueueItem<T>(item, priority);\\n    bool added = false;\\n    for (int i = 0; i < _dataStore.length; i++) {\\n      if (priority < _dataStore[i].priority) {\\n        added = true;\\n        _dataStore.insert(i, queueItem);\\n        break;\\n      }\\n    }\\n    if (!added) {\\n      _dataStore.add(queueItem);\\n    }\\n  }\\n\\n  T dequeue() {\\n    if (_dataStore.isNotEmpty) {\\n      return _dataStore.removeAt(0).item;\\n    }\\n    return null;\\n  }\\n\\n  T get front {\\n    if (_dataStore.isNotEmpty) {\\n      return _dataStore.first.item;\\n    }\\n    return null;\\n  }\\n\\n  T get end {\\n    if (_dataStore.isNotEmpty) {\\n      return _dataStore.last.item;\\n    }\\n    return null;\\n  }\\n\\n  clear() {\\n    _dataStore.clear();\\n  }\\n\\n  String toString() {\\n    return _dataStore.toString();\\n  }\\n}\\n\\nclass QueueItem<T> {\\n  T item;\\n  int priority;\\n\\n  QueueItem(this.item, this.priority);\\n\\n  String toString() {\\n    return '$item - $priority';\\n  }\\n}\\n\\nvoid main() {\\n  PriorityQueue<int> queue = new PriorityQueue();\\n  queue.enqueue(1, 2);\\n  queue.enqueue(2, 1);\\n  queue.enqueue(3, 3);\\n  queue.enqueue(4, 2);\\n\\n  print(queue.dequeue());\\n  print(queue.dequeue());\\n  print(queue.dequeue());\\n  print(queue.dequeue());\\n}\\n\"",
    "array stack": "\"//Author: Shawn\\n//Email: stepfencurryxiao@gmail.com\\n\\nclass ArrayStack<T> {\\n  //stack\\n  List<T> stack;\\n  //element of the stack\\n  int count;\\n  //size of stack\\n  int n;\\n\\n  //Init the array stack\\n  ArrayStack(var n) {\\n    this.n = n;\\n    this.stack = new List<T>(n);\\n    this.count = 0;\\n  }\\n\\n  //Push a item to the stack\\n  void push(T item) {\\n    if (count == n) {\\n      print(\\\"The stack is full\\\\n\\\");\\n    }\\n    stack[count] = item;\\n    count++;\\n  }\\n\\n  //Pop a item from the stack\\n  T pop() {\\n    if (count == 0) {\\n      print(\\\"No data in the stack!\\\\n\\\");\\n    }\\n    T pop_data = stack[count - 1];\\n    stack[count - 1] = null;\\n    count--;\\n    return pop_data;\\n  }\\n\\n  void Display() {\\n    print(\\\"ArrayStack: $stack\\\\n\\\");\\n  }\\n}\\n\\nvoid main() {\\n  ArrayStack<String> array_stack = new ArrayStack<String>(6);\\n\\n  array_stack.push('1');\\n  array_stack.push(\\\"2\\\");\\n  array_stack.push('3');\\n  array_stack.push(\\\"4\\\");\\n  array_stack.push('5');\\n  array_stack.push(\\\"6\\\");\\n\\n  array_stack.Display();\\n\\n  var pop_data;\\n  pop_data = array_stack.pop();\\n  print(\\\"Pop $pop_data from stack\\\\n\\\");\\n  pop_data = array_stack.pop();\\n  print(\\\"Pop $pop_data from stack\\\\n\\\");\\n  print(\\\"Now the stock:\\\");\\n  array_stack.Display();\\n}\\n\"",
    "balanced brackets": "\"import 'package:test/test.dart';\\nimport 'package:stack/stack.dart';\\n\\nbool isBalancedBrackets(String string) {\\n  Stack<String> stack = Stack();\\n\\n  List<String> openingBrackets = ['(', '{', '['];\\n  final Map<String, String> matchingBracket = {'}': '{', ')': '(', ']': '['};\\n\\n  for (int i = 0; i < string.length; i++) {\\n    var currentChar = string[i];\\n\\n    if (openingBrackets.contains(currentChar)) {\\n      stack.push(currentChar);\\n    } else {\\n      if (stack.isNotEmpty) {\\n        if (stack.top() == matchingBracket[currentChar]) {\\n          stack.pop();\\n        } else {\\n          return false;\\n        }\\n      } else {\\n        return false;\\n      }\\n    }\\n  }\\n  return stack.isEmpty;\\n}\\n\\nvoid main() {\\n  test(('Balanced Bracket'), () {\\n    expect(isBalancedBrackets('([])(){}(())()()'), isTrue);\\n  });\\n\\n  test(('Balanced Bracket'), () {\\n    expect(isBalancedBrackets('()[]{}{'), isFalse);\\n  });\\n\\n  test(('Balanced Bracket'), () {\\n    expect(isBalancedBrackets('()()[{()})]'), isFalse);\\n  });\\n\\n  test(('Balanced Bracket'), () {\\n    expect(isBalancedBrackets('()([])'), isTrue);\\n  });\\n\\n  test(('Balanced Bracket'), () {\\n    expect(\\n        isBalancedBrackets(\\n            '(((((([[[[[[{{{{{{{{{{{{()}}}}}}}}}}}}]]]]]]))))))((([])({})[])[])[]([]){}(())'),\\n        isTrue);\\n  });\\n}\\n\"",
    "linked list stack": "\"//Author: Shawn\\n//Email: stepfencurryxiao@gmail.com\\n\\nclass Node<T> {\\n  //the data of the Node\\n  T data;\\n  Node next;\\n\\n  Node(T data) {\\n    this.data = data;\\n    this.next = null;\\n  }\\n}\\n\\nclass LinkedListStack<T> {\\n  //Top of stack\\n  Node<T> head;\\n\\n  //Size of stack\\n  int size;\\n\\n  LinkedListStack() {\\n    this.head = null;\\n    this.size = 0;\\n  }\\n\\n  //Add element at top of the stack\\n\\n  void push(T element) {\\n    Node<T> newNode = new Node<T>(element);\\n    newNode.next = this.head;\\n    this.head = newNode;\\n    this.size++;\\n  }\\n\\n  //Pop element from top at the stack\\n\\n  T pop() {\\n    T returnData = null;\\n    if (size == 0) {\\n      print(\\\"The stack is empty!!!\\\");\\n    } else {\\n      Node<T> destroy = this.head;\\n      this.head = this.head.next;\\n      returnData = destroy.data;\\n      this.size--;\\n    }\\n    return returnData;\\n  }\\n\\n  bool isEmpty() {\\n    return this.size == 0;\\n  }\\n\\n  int getSize() {\\n    return this.size;\\n  }\\n}\\n\\nint main() {\\n  LinkedListStack<String> Stack = new LinkedListStack<String>();\\n  var returnData;\\n  print(\\\"Push 2 5 9 7 to the stack\\\\n\\\");\\n  Stack.push(\\\"2\\\");\\n  Stack.push(\\\"5\\\");\\n  Stack.push(\\\"9\\\");\\n  Stack.push(\\\"7\\\");\\n  print(\\\"Successful push!\\\\n\\\");\\n  returnData = Stack.pop();\\n  print(\\\"Pop a data: $returnData\\\\n\\\");\\n  returnData = Stack.pop();\\n  print(\\\"Pop a data: $returnData\\\\n\\\");\\n  returnData = Stack.pop();\\n  print(\\\"Pop a data: $returnData\\\\n\\\");\\n  return 0;\\n}\\n\""
  }
}
