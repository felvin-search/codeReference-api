{
  "rust": {
    "another rot13": "\"pub fn another_rot13(text: &str) -> String {\\n    let input = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\";\\n    let output = \\\"NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm\\\";\\n    text.chars()\\n        .map(|c| match input.find(c) {\\n            Some(i) => output.chars().nth(i).unwrap(),\\n            None => c,\\n        })\\n        .collect()\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    // Note this useful idiom: importing names from outer (for mod tests) scope.\\n    use super::*;\\n\\n    #[test]\\n    fn test_simple() {\\n        assert_eq!(another_rot13(\\\"ABCzyx\\\"), \\\"NOPmlk\\\");\\n    }\\n\\n    #[test]\\n    fn test_every_alphabet_with_space() {\\n        assert_eq!(\\n            another_rot13(\\\"The quick brown fox jumps over the lazy dog\\\"),\\n            \\\"Gur dhvpx oebja sbk whzcf bire gur ynml qbt\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn test_non_alphabet() {\\n        assert_eq!(another_rot13(\\\"🎃 Jack-o'-lantern\\\"), \\\"🎃 Wnpx-b'-ynagrea\\\");\\n    }\\n}\\n\"",
    "caesar": "\"//! Caesar Cipher\\n//! Based on cipher_crypt::caesar\\n//!\\n//! # Algorithm\\n//!\\n//! Rotate each ascii character by shift. The most basic example is ROT 13, which rotates 'a' to\\n//! 'n'. This implementation does not rotate unicode characters.\\n\\n/// Caesar cipher to rotate cipher text by shift and return an owned String.\\npub fn caesar(cipher: &str, shift: u8) -> String {\\n    cipher\\n        .chars()\\n        .map(|c| {\\n            if c.is_ascii_alphabetic() {\\n                let first = if c.is_ascii_lowercase() { b'a' } else { b'A' };\\n                // modulo the distance to keep character range\\n                (first + (c as u8 + shift - first) % 26) as char\\n            } else {\\n                c\\n            }\\n        })\\n        .collect()\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn empty() {\\n        assert_eq!(caesar(\\\"\\\", 13), \\\"\\\");\\n    }\\n\\n    #[test]\\n    fn caesar_rot_13() {\\n        assert_eq!(caesar(\\\"rust\\\", 13), \\\"ehfg\\\");\\n    }\\n\\n    #[test]\\n    fn caesar_unicode() {\\n        assert_eq!(caesar(\\\"attack at dawn 攻\\\", 5), \\\"fyyfhp fy ifbs 攻\\\");\\n    }\\n}\\n\"",
    "mod": "\"mod aho_corasick;\\nmod burrows_wheeler_transform;\\nmod knuth_morris_pratt;\\nmod manacher;\\nmod rabin_karp;\\nmod reverse;\\n\\npub use self::aho_corasick::AhoCorasick;\\npub use self::burrows_wheeler_transform::{\\n    burrows_wheeler_transform, inv_burrows_wheeler_transform,\\n};\\npub use self::knuth_morris_pratt::knuth_morris_pratt;\\npub use self::manacher::manacher;\\npub use self::rabin_karp::rabin_karp;\\npub use self::reverse::reverse;\\n\"",
    "morse code": "\"use std::collections::HashMap;\\nuse std::io;\\n\\nconst UNKNOWN_CHARACTER: &str = \\\"........\\\";\\nconst _UNKNOWN_MORSE_CHARACTER: &str = \\\"_\\\";\\n\\npub fn encode(message: &str) -> String {\\n    let dictionary = _morse_dictionary();\\n    message\\n        .chars()\\n        .into_iter()\\n        .map(|char| char.to_uppercase().to_string())\\n        .map(|letter| dictionary.get(letter.as_str()))\\n        .map(|option| option.unwrap_or(&UNKNOWN_CHARACTER).to_string())\\n        .collect::<Vec<String>>()\\n        .join(\\\" \\\")\\n}\\n\\n// Declaritive macro for creating readable map declarations, for more info see https://doc.rust-lang.org/book/ch19-06-macros.html\\nmacro_rules! map {\\n    ($($key:expr => $value:expr),* $(,)?) => {\\n        std::iter::Iterator::collect(std::array::IntoIter::new([$(($key, $value),)*]))\\n    };\\n}\\n\\nfn _morse_dictionary() -> HashMap<&'static str, &'static str> {\\n    map! {\\n        \\\"A\\\" => \\\".-\\\",      \\\"B\\\" => \\\"-...\\\",    \\\"C\\\" => \\\"-.-.\\\",\\n        \\\"D\\\" => \\\"-..\\\",     \\\"E\\\" => \\\".\\\",       \\\"F\\\" => \\\"..-.\\\",\\n        \\\"G\\\" => \\\"--.\\\",     \\\"H\\\" => \\\"....\\\",    \\\"I\\\" => \\\"..\\\",\\n        \\\"J\\\" => \\\".---\\\",    \\\"K\\\" => \\\"-.-\\\",     \\\"L\\\" => \\\".-..\\\",\\n        \\\"M\\\" => \\\"--\\\",      \\\"N\\\" => \\\"-.\\\",      \\\"O\\\" => \\\"---\\\",\\n        \\\"P\\\" => \\\".--.\\\",    \\\"Q\\\" => \\\"--.-\\\",    \\\"R\\\" => \\\".-.\\\",\\n        \\\"S\\\" => \\\"...\\\",     \\\"T\\\" => \\\"-\\\",       \\\"U\\\" => \\\"..-\\\",\\n        \\\"V\\\" => \\\"...-\\\",    \\\"W\\\" => \\\".--\\\",     \\\"X\\\" => \\\"-..-\\\",\\n        \\\"Y\\\" => \\\"-.--\\\",    \\\"Z\\\" => \\\"--..\\\",\\n\\n        \\\"1\\\" => \\\".----\\\",   \\\"2\\\" => \\\"..---\\\",   \\\"3\\\" => \\\"...--\\\",\\n        \\\"4\\\" => \\\"....-\\\",   \\\"5\\\" => \\\".....\\\",   \\\"6\\\" => \\\"-....\\\",\\n        \\\"7\\\" => \\\"--...\\\",   \\\"8\\\" => \\\"---..\\\",   \\\"9\\\" => \\\"----.\\\",\\n        \\\"0\\\" => \\\"-----\\\",\\n\\n        \\\"&\\\" => \\\".-...\\\",   \\\"@\\\" => \\\".--.-.\\\",  \\\":\\\" => \\\"---...\\\",\\n        \\\",\\\" => \\\"--..--\\\",  \\\".\\\" => \\\".-.-.-\\\",  \\\"'\\\" => \\\".----.\\\",\\n        \\\"\\\\\\\"\\\" => \\\".-..-.\\\", \\\"?\\\" => \\\"..--..\\\",  \\\"/\\\" => \\\"-..-.\\\",\\n        \\\"=\\\" => \\\"-...-\\\",   \\\"+\\\" => \\\".-.-.\\\",   \\\"-\\\" => \\\"-....-\\\",\\n        \\\"(\\\" => \\\"-.--.\\\",   \\\")\\\" => \\\"-.--.-\\\",  \\\" \\\" => \\\"/\\\",\\n        \\\"!\\\" => \\\"-.-.--\\\",\\n    }\\n}\\n\\nfn _morse_to_alphanumeric_dictionary() -> HashMap<&'static str, &'static str> {\\n    map! {\\n        \\\".-\\\"   =>  \\\"A\\\",      \\\"-...\\\" => \\\"B\\\",    \\\"-.-.\\\" => \\\"C\\\",\\n        \\\"-..\\\"  =>  \\\"D\\\",      \\\".\\\"    => \\\"E\\\",       \\\"..-.\\\" => \\\"F\\\",\\n        \\\"--.\\\"  =>  \\\"G\\\",      \\\"....\\\" => \\\"H\\\",    \\\"..\\\" => \\\"I\\\",\\n        \\\".---\\\" =>  \\\"J\\\",     \\\"-.-\\\" => \\\"K\\\",     \\\".-..\\\" => \\\"L\\\",\\n        \\\"--\\\"   =>  \\\"M\\\",       \\\"-.\\\" => \\\"N\\\",      \\\"---\\\" => \\\"O\\\",\\n        \\\".--.\\\" =>  \\\"P\\\",     \\\"--.-\\\" => \\\"Q\\\",    \\\".-.\\\" => \\\"R\\\",\\n        \\\"...\\\"  =>  \\\"S\\\",      \\\"-\\\" => \\\"T\\\",       \\\"..-\\\" => \\\"U\\\",\\n        \\\"...-\\\" =>  \\\"V\\\",     \\\".--\\\" => \\\"W\\\",     \\\"-..-\\\" => \\\"X\\\",\\n        \\\"-.--\\\" =>  \\\"Y\\\",     \\\"--..\\\" => \\\"Z\\\",\\n\\n        \\\".----\\\" => \\\"1\\\",    \\\"..---\\\" => \\\"2\\\",   \\\"...--\\\" => \\\"3\\\",\\n        \\\"....-\\\" => \\\"4\\\",    \\\".....\\\" => \\\"5\\\",   \\\"-....\\\" => \\\"6\\\",\\n        \\\"--...\\\" => \\\"7\\\",    \\\"---..\\\" => \\\"8\\\",   \\\"----.\\\" => \\\"9\\\",\\n        \\\"-----\\\" => \\\"0\\\",\\n\\n        \\\".-...\\\" => \\\"&\\\",    \\\".--.-.\\\" => \\\"@\\\",  \\\"---...\\\" => \\\":\\\",\\n        \\\"--..--\\\" => \\\",\\\",   \\\".-.-.-\\\" => \\\".\\\",  \\\".----.\\\" => \\\"'\\\",\\n        \\\".-..-.\\\" => \\\"\\\\\\\"\\\",  \\\"..--..\\\" => \\\"?\\\",  \\\"-..-.\\\" => \\\"/\\\",\\n        \\\"-...-\\\" => \\\"=\\\",   \\\".-.-.\\\" => \\\"+\\\",   \\\"-....-\\\" => \\\"-\\\",\\n        \\\"-.--.\\\" => \\\"(\\\",   \\\"-.--.-\\\" => \\\")\\\",  \\\"/\\\" => \\\" \\\",\\n        \\\"-.-.--\\\" => \\\"!\\\",  \\\" \\\" => \\\" \\\",       \\\"\\\" => \\\"\\\"\\n    }\\n}\\n\\nfn _check_part(string: &str) -> bool {\\n    for c in string.chars() {\\n        match c {\\n            '.' | '-' | ' ' => (),\\n            _ => return false,\\n        }\\n    }\\n    true\\n}\\n\\nfn _check_all_parts(string: &str) -> bool {\\n    string.split('/').all(_check_part)\\n}\\n\\nfn _decode_token(string: &str) -> String {\\n    _morse_to_alphanumeric_dictionary()\\n        .get(string)\\n        .unwrap_or(&_UNKNOWN_MORSE_CHARACTER)\\n        .to_string()\\n}\\n\\nfn _decode_part(string: &str) -> String {\\n    string\\n        .split(' ')\\n        .map(_decode_token)\\n        .collect::<Vec<String>>()\\n        .join(\\\"\\\")\\n}\\n\\n/// Convert morse code to ascii.\\n///\\n/// Given a morse code, return the corresponding message.\\n/// If the code is invalid, the undecipherable part of the code is replaced by `_`.\\npub fn decode(string: &str) -> Result<String, io::Error> {\\n    if !_check_all_parts(string) {\\n        return Err(io::Error::new(\\n            io::ErrorKind::InvalidData,\\n            \\\"Invalid morse code\\\",\\n        ));\\n    }\\n\\n    let mut partitions: Vec<String> = vec![];\\n\\n    for part in string.split('/') {\\n        partitions.push(_decode_part(part));\\n    }\\n\\n    Ok(partitions.join(\\\" \\\"))\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn encrypt_only_letters() {\\n        let message = \\\"Hello Morse\\\";\\n        let cipher = encode(message);\\n        assert_eq!(\\n            cipher,\\n            \\\".... . .-.. .-.. --- / -- --- .-. ... .\\\".to_string()\\n        )\\n    }\\n\\n    #[test]\\n    fn encrypt_letters_and_special_characters() {\\n        let message = \\\"What's a great day!\\\";\\n        let cipher = encode(message);\\n        assert_eq!(\\n            cipher,\\n            \\\".-- .... .- - .----. ... / .- / --. .-. . .- - / -.. .- -.-- -.-.--\\\".to_string()\\n        )\\n    }\\n\\n    #[test]\\n    fn encrypt_message_with_unsupported_character() {\\n        let message = \\\"Error?? {}\\\";\\n        let cipher = encode(message);\\n        assert_eq!(\\n            cipher,\\n            \\\". .-. .-. --- .-. ..--.. ..--.. / ........ ........\\\".to_string()\\n        )\\n    }\\n\\n    #[test]\\n    fn decrypt_valid_morsecode_with_spaces() {\\n        let expected = \\\"Hello Morse! How's it goin, \\\\\\\"eh\\\\\\\"?\\\"\\n            .to_string()\\n            .to_uppercase();\\n        let encypted = encode(&expected);\\n        let result = decode(&encypted).unwrap();\\n\\n        assert_eq!(expected, result);\\n    }\\n\\n    #[test]\\n    fn decrypt_valid_character_set_invalid_morsecode() {\\n        let expected = format!(\\n            \\\"{}{}{}{} {}\\\",\\n            _UNKNOWN_MORSE_CHARACTER,\\n            _UNKNOWN_MORSE_CHARACTER,\\n            _UNKNOWN_MORSE_CHARACTER,\\n            _UNKNOWN_MORSE_CHARACTER,\\n            _UNKNOWN_MORSE_CHARACTER,\\n        );\\n\\n        let encypted = \\\".-.-.--.-.-. --------. ..---.-.-. .-.-.--.-.-. / .-.-.--.-.-.\\\".to_string();\\n        let result = decode(&encypted).unwrap();\\n\\n        assert_eq!(expected, result);\\n    }\\n\\n    #[test]\\n    fn decrypt_invalid_morsecode_with_spaces() {\\n        let encypted = \\\"1... . .-.. .-.. --- / -- --- .-. ... .\\\";\\n        let result = decode(encypted).map_err(|e| e.kind());\\n        let expected = Err(io::ErrorKind::InvalidData);\\n\\n        assert_eq!(expected, result);\\n    }\\n}\\n\"",
    "polybius": "\"/// Encode an ASCII string into its location in a Polybius square.\\n/// Only alphabetical characters are encoded.\\npub fn encode_ascii(string: &str) -> String {\\n    string\\n        .chars()\\n        .map(|c| match c {\\n            'a' | 'A' => \\\"11\\\",\\n            'b' | 'B' => \\\"12\\\",\\n            'c' | 'C' => \\\"13\\\",\\n            'd' | 'D' => \\\"14\\\",\\n            'e' | 'E' => \\\"15\\\",\\n            'f' | 'F' => \\\"21\\\",\\n            'g' | 'G' => \\\"22\\\",\\n            'h' | 'H' => \\\"23\\\",\\n            'i' | 'I' | 'j' | 'J' => \\\"24\\\",\\n            'k' | 'K' => \\\"25\\\",\\n            'l' | 'L' => \\\"31\\\",\\n            'm' | 'M' => \\\"32\\\",\\n            'n' | 'N' => \\\"33\\\",\\n            'o' | 'O' => \\\"34\\\",\\n            'p' | 'P' => \\\"35\\\",\\n            'q' | 'Q' => \\\"41\\\",\\n            'r' | 'R' => \\\"42\\\",\\n            's' | 'S' => \\\"43\\\",\\n            't' | 'T' => \\\"44\\\",\\n            'u' | 'U' => \\\"45\\\",\\n            'v' | 'V' => \\\"51\\\",\\n            'w' | 'W' => \\\"52\\\",\\n            'x' | 'X' => \\\"53\\\",\\n            'y' | 'Y' => \\\"54\\\",\\n            'z' | 'Z' => \\\"55\\\",\\n            _ => \\\"\\\",\\n        })\\n        .collect()\\n}\\n\\n/// Decode a string of ints into their corresponding\\n/// letters in a Polybius square.\\n///\\n/// Any invalid characters, or whitespace will be ignored.\\npub fn decode_ascii(string: &str) -> String {\\n    string\\n        .chars()\\n        .filter(|c| !c.is_whitespace())\\n        .collect::<String>()\\n        .as_bytes()\\n        .chunks(2)\\n        .map(|s| match std::str::from_utf8(s) {\\n            Ok(v) => v.parse::<i32>().unwrap_or(0),\\n            Err(_) => 0,\\n        })\\n        .map(|i| match i {\\n            11 => 'A',\\n            12 => 'B',\\n            13 => 'C',\\n            14 => 'D',\\n            15 => 'E',\\n            21 => 'F',\\n            22 => 'G',\\n            23 => 'H',\\n            24 => 'I',\\n            25 => 'K',\\n            31 => 'L',\\n            32 => 'M',\\n            33 => 'N',\\n            34 => 'O',\\n            35 => 'P',\\n            41 => 'Q',\\n            42 => 'R',\\n            43 => 'S',\\n            44 => 'T',\\n            45 => 'U',\\n            51 => 'V',\\n            52 => 'W',\\n            53 => 'X',\\n            54 => 'Y',\\n            55 => 'Z',\\n            _ => ' ',\\n        })\\n        .collect::<String>()\\n        .replace(\\\" \\\", \\\"\\\")\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::{decode_ascii, encode_ascii};\\n\\n    #[test]\\n    fn encode_empty() {\\n        assert_eq!(encode_ascii(\\\"\\\"), \\\"\\\");\\n    }\\n\\n    #[test]\\n    fn encode_valid_string() {\\n        assert_eq!(encode_ascii(\\\"This is a test\\\"), \\\"4423244324431144154344\\\");\\n    }\\n\\n    #[test]\\n    fn encode_emoji() {\\n        assert_eq!(encode_ascii(\\\"🙂\\\"), \\\"\\\");\\n    }\\n\\n    #[test]\\n    fn decode_empty() {\\n        assert_eq!(decode_ascii(\\\"\\\"), \\\"\\\");\\n    }\\n\\n    #[test]\\n    fn decode_valid_string() {\\n        assert_eq!(\\n            decode_ascii(\\\"44 23 24 43 24 43 11 44 15 43 44 \\\"),\\n            \\\"THISISATEST\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn decode_emoji() {\\n        assert_eq!(decode_ascii(\\\"🙂\\\"), \\\"\\\");\\n    }\\n\\n    #[test]\\n    fn decode_string_with_whitespace() {\\n        assert_eq!(\\n            decode_ascii(\\\"44\\\\n23\\\\t\\\\r24\\\\r\\\\n43   2443\\\\n 11 \\\\t 44\\\\r \\\\r15 \\\\n43 44\\\"),\\n            \\\"THISISATEST\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn decode_unknown_string() {\\n        assert_eq!(decode_ascii(\\\"94 63 64 83 64 48 77 00 05 47 48 \\\"), \\\"\\\");\\n    }\\n\\n    #[test]\\n    fn decode_odd_length() {\\n        assert_eq!(decode_ascii(\\\"11 22 33 4\\\"), \\\"AGN\\\");\\n    }\\n\\n    #[test]\\n    fn encode_and_decode() {\\n        let string = \\\"Do you ever wonder why we're here?\\\";\\n        let encode = encode_ascii(string);\\n        assert_eq!(\\n            \\\"1434543445155115425234331415425223545215421523154215\\\",\\n            encode,\\n        );\\n        assert_eq!(\\\"DOYOUEVERWONDERWHYWEREHERE\\\", decode_ascii(&encode));\\n    }\\n}\\n\"",
    "rot13": "\"pub fn rot13(text: &str) -> String {\\n    let to_enc = text.to_uppercase();\\n    to_enc\\n        .chars()\\n        .map(|c| match c {\\n            'A'..='M' => ((c as u8) + 13) as char,\\n            'N'..='Z' => ((c as u8) - 13) as char,\\n            _ => c,\\n        })\\n        .collect()\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_single_letter() {\\n        assert_eq!(\\\"N\\\", rot13(\\\"A\\\"));\\n    }\\n\\n    #[test]\\n    fn test_bunch_of_letters() {\\n        assert_eq!(\\\"NOP\\\", rot13(\\\"ABC\\\"));\\n    }\\n\\n    #[test]\\n    fn test_non_ascii() {\\n        assert_eq!(\\\"😀NO\\\", rot13(\\\"😀AB\\\"));\\n    }\\n\\n    #[test]\\n    fn test_twice() {\\n        assert_eq!(\\\"ABCD\\\", rot13(&rot13(\\\"ABCD\\\")));\\n    }\\n}\\n\"",
    "sha256": "\"//! SHA-2 (256 Bit)\\n\\nstruct BufState {\\n    data: Vec<u8>,\\n    len: usize,\\n    total_len: usize,\\n    single: bool,\\n    total: bool,\\n}\\n\\npub fn sha256(data: &[u8]) -> [u8; 32] {\\n    let mut hash: [u8; 32] = [0; 32];\\n\\n    let mut h: [u32; 8] = [\\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,\\n        0x5be0cd19,\\n    ];\\n\\n    let k: [u32; 64] = [\\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4,\\n        0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe,\\n        0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f,\\n        0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\\n        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\\n        0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\\n        0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116,\\n        0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,\\n        0xc67178f2,\\n    ];\\n\\n    let mut chunk: [u8; 64] = [0; 64];\\n\\n    let mut state: BufState = BufState {\\n        data: (*data).to_owned(),\\n        len: data.len(),\\n        total_len: data.len(),\\n        single: false,\\n        total: false,\\n    };\\n\\n    while calc_chunk(&mut chunk, &mut state) {\\n        let mut ah: [u32; 8] = h;\\n        let mut w: [u32; 16] = [0; 16];\\n        for i in 0..4 {\\n            for j in 0..16 {\\n                if i == 0 {\\n                    w[j] = ((chunk[j * 4] as u32) << 24)\\n                        | ((chunk[j * 4 + 1] as u32) << 16)\\n                        | ((chunk[j * 4 + 2] as u32) << 8)\\n                        | (chunk[j * 4 + 3] as u32);\\n                } else {\\n                    let s0 = (w[(j + 1) & 0xf].rotate_right(7) ^ w[(j + 1) & 0xf].rotate_right(18))\\n                        ^ (w[(j + 1) & 0xf] >> 3);\\n                    let s1 = w[(j + 14) & 0xf].rotate_right(17)\\n                        ^ w[(j + 14) & 0xf].rotate_right(19)\\n                        ^ (w[(j + 14) & 0xf] >> 10);\\n                    w[j] = w[j]\\n                        .wrapping_add(s0)\\n                        .wrapping_add(w[(j + 9) & 0xf])\\n                        .wrapping_add(s1);\\n                }\\n\\n                let s1: u32 =\\n                    ah[4].rotate_right(6) ^ ah[4].rotate_right(11) ^ ah[4].rotate_right(25);\\n                let ch: u32 = (ah[4] & ah[5]) ^ (!ah[4] & ah[6]);\\n                let temp1: u32 = ah[7]\\n                    .wrapping_add(s1)\\n                    .wrapping_add(ch)\\n                    .wrapping_add(k[i << 4 | j])\\n                    .wrapping_add(w[j]);\\n                let s0: u32 =\\n                    ah[0].rotate_right(2) ^ ah[0].rotate_right(13) ^ ah[0].rotate_right(22);\\n                let maj: u32 = (ah[0] & ah[1]) ^ (ah[0] & ah[2]) ^ (ah[1] & ah[2]);\\n                let temp2: u32 = s0.wrapping_add(maj);\\n\\n                ah[7] = ah[6];\\n                ah[6] = ah[5];\\n                ah[5] = ah[4];\\n                ah[4] = ah[3].wrapping_add(temp1);\\n                ah[3] = ah[2];\\n                ah[2] = ah[1];\\n                ah[1] = ah[0];\\n                ah[0] = temp1.wrapping_add(temp2);\\n            }\\n        }\\n\\n        for i in 0..8 {\\n            h[i] = h[i].wrapping_add(ah[i]);\\n        }\\n        chunk = [0; 64];\\n    }\\n\\n    for i in 0..8 {\\n        hash[i * 4] = (h[i] >> 24) as u8;\\n        hash[i * 4 + 1] = (h[i] >> 16) as u8;\\n        hash[i * 4 + 2] = (h[i] >> 8) as u8;\\n        hash[i * 4 + 3] = h[i] as u8;\\n    }\\n\\n    hash\\n}\\n\\nfn calc_chunk(chunk: &mut [u8; 64], state: &mut BufState) -> bool {\\n    if state.total {\\n        return false;\\n    }\\n\\n    if state.len >= 64 {\\n        for x in chunk {\\n            *x = state.data[0];\\n            state.data.remove(0);\\n        }\\n        state.len -= 64;\\n        return true;\\n    }\\n\\n    let remaining: usize = state.data.len();\\n    let space: usize = 64 - remaining;\\n    for x in chunk.iter_mut().take(state.data.len()) {\\n        *x = state.data[0];\\n        state.data.remove(0);\\n    }\\n\\n    if !state.single {\\n        chunk[remaining] = 0x80;\\n        state.single = true;\\n    }\\n\\n    if space >= 8 {\\n        let mut len = state.total_len;\\n        chunk[63] = (len << 3) as u8;\\n        len >>= 5;\\n        for i in 1..8 {\\n            chunk[(63 - i)] = len as u8;\\n            len >>= 8;\\n        }\\n        state.total = true;\\n    }\\n\\n    true\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn empty() {\\n        assert_eq!(\\n            sha256(&Vec::new()),\\n            [\\n                0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, 0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f,\\n                0xb9, 0x24, 0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, 0xa4, 0x95, 0x99, 0x1b,\\n                0x78, 0x52, 0xb8, 0x55\\n            ]\\n        );\\n    }\\n\\n    #[test]\\n    fn ascii() {\\n        assert_eq!(\\n            sha256(&b\\\"The quick brown fox jumps over the lazy dog\\\".to_vec()),\\n            [\\n                0xD7, 0xA8, 0xFB, 0xB3, 0x07, 0xD7, 0x80, 0x94, 0x69, 0xCA, 0x9A, 0xBC, 0xB0, 0x08,\\n                0x2E, 0x4F, 0x8D, 0x56, 0x51, 0xE4, 0x6D, 0x3C, 0xDB, 0x76, 0x2D, 0x02, 0xD0, 0xBF,\\n                0x37, 0xC9, 0xE5, 0x92\\n            ]\\n        )\\n    }\\n\\n    #[test]\\n    fn ascii_avalanche() {\\n        assert_eq!(\\n            sha256(&b\\\"The quick brown fox jumps over the lazy dog.\\\".to_vec()),\\n            [\\n                0xEF, 0x53, 0x7F, 0x25, 0xC8, 0x95, 0xBF, 0xA7, 0x82, 0x52, 0x65, 0x29, 0xA9, 0xB6,\\n                0x3D, 0x97, 0xAA, 0x63, 0x15, 0x64, 0xD5, 0xD7, 0x89, 0xC2, 0xB7, 0x65, 0x44, 0x8C,\\n                0x86, 0x35, 0xFB, 0x6C\\n            ]\\n        )\\n    }\\n}\\n\"",
    "vigenere": "\"//! Vigenère Cipher\\n//!\\n//! # Algorithm\\n//!\\n//! Rotate each ascii character by the offset of the corresponding key character.\\n//! When we reach the last key character, we start over from the first one.\\n//! This implementation does not rotate unicode characters.\\n\\n/// Vigenère cipher to rotate plain_text text by key and return an owned String.\\npub fn vigenere(plain_text: &str, key: &str) -> String {\\n    // Remove all unicode and non-ascii characters from key\\n    let key: String = key.chars().filter(|&c| c.is_ascii_alphabetic()).collect();\\n    let key = key.to_ascii_lowercase();\\n\\n    let key_len = key.len();\\n    if key_len == 0 {\\n        return String::from(plain_text);\\n    }\\n\\n    let mut index = 0;\\n\\n    plain_text\\n        .chars()\\n        .map(|c| {\\n            if c.is_ascii_alphabetic() {\\n                let first = if c.is_ascii_lowercase() { b'a' } else { b'A' };\\n                let shift = key.as_bytes()[index % key_len] - b'a';\\n                index += 1;\\n                // modulo the distance to keep character range\\n                (first + (c as u8 + shift - first) % 26) as char\\n            } else {\\n                c\\n            }\\n        })\\n        .collect()\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn empty() {\\n        assert_eq!(vigenere(\\\"\\\", \\\"test\\\"), \\\"\\\");\\n    }\\n\\n    #[test]\\n    fn vigenere_base() {\\n        assert_eq!(\\n            vigenere(\\\"LoremIpsumDolorSitAmet\\\", \\\"base\\\"),\\n            \\\"MojinIhwvmVsmojWjtSqft\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn vigenere_with_spaces() {\\n        assert_eq!(\\n            vigenere(\\n                \\\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\\",\\n                \\\"spaces\\\"\\n            ),\\n            \\\"Ddrgq ahhuo hgddr uml sbev, ggfheexwljr chahxsemfy tlkx.\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn vigenere_unicode_and_numbers() {\\n        assert_eq!(\\n            vigenere(\\\"1 Lorem ⏳ ipsum dolor sit amet Ѡ\\\", \\\"unicode\\\"),\\n            \\\"1 Fbzga ⏳ ltmhu fcosl fqv opin Ѡ\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn vigenere_unicode_key() {\\n        assert_eq!(\\n            vigenere(\\\"Lorem ipsum dolor sit amet\\\", \\\"😉 key!\\\"),\\n            \\\"Vspoq gzwsw hmvsp cmr kqcd\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn vigenere_empty_key() {\\n        assert_eq!(vigenere(\\\"Lorem ipsum\\\", \\\"\\\"), \\\"Lorem ipsum\\\");\\n    }\\n}\\n\"",
    "xor": "\"pub fn xor(text: &str, key: u8) -> String {\\n    text.chars().map(|c| ((c as u8) ^ key) as char).collect()\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_simple() {\\n        let test_string = \\\"test string\\\";\\n        let ciphered_text = xor(test_string, 32);\\n        assert_eq!(test_string, xor(&ciphered_text, 32));\\n    }\\n\\n    #[test]\\n    fn test_every_alphabet_with_space() {\\n        let test_string = \\\"The quick brown fox jumps over the lazy dog\\\";\\n        let ciphered_text = xor(test_string, 64);\\n        assert_eq!(test_string, xor(&ciphered_text, 64));\\n    }\\n}\\n\"",
    "avl tree": "\"use std::{\\n    cmp::{max, Ordering},\\n    iter::FromIterator,\\n    mem,\\n    ops::Not,\\n};\\n\\n/// An internal node of an `AVLTree`.\\nstruct AVLNode<T: Ord> {\\n    value: T,\\n    height: usize,\\n    left: Option<Box<AVLNode<T>>>,\\n    right: Option<Box<AVLNode<T>>>,\\n}\\n\\n/// A set based on an AVL Tree.\\n///\\n/// An AVL Tree is a self-balancing binary search tree. It tracks the height of each node\\n/// and performs internal rotations to maintain a height difference of at most 1 between\\n/// each sibling pair.\\npub struct AVLTree<T: Ord> {\\n    root: Option<Box<AVLNode<T>>>,\\n    length: usize,\\n}\\n\\n/// Refers to the left or right subtree of an `AVLNode`.\\n#[derive(Clone, Copy)]\\nenum Side {\\n    Left,\\n    Right,\\n}\\n\\nimpl<T: Ord> AVLTree<T> {\\n    /// Creates an empty `AVLTree`.\\n    pub fn new() -> AVLTree<T> {\\n        AVLTree {\\n            root: None,\\n            length: 0,\\n        }\\n    }\\n\\n    /// Returns `true` if the tree contains a value.\\n    pub fn contains(&self, value: &T) -> bool {\\n        let mut current = &self.root;\\n        while let Some(node) = current {\\n            current = match value.cmp(&node.value) {\\n                Ordering::Equal => return true,\\n                Ordering::Less => &node.left,\\n                Ordering::Greater => &node.right,\\n            }\\n        }\\n        false\\n    }\\n\\n    /// Adds a value to the tree.\\n    ///\\n    /// Returns `true` if the tree did not yet contain the value.\\n    pub fn insert(&mut self, value: T) -> bool {\\n        let inserted = insert(&mut self.root, value);\\n        if inserted {\\n            self.length += 1;\\n        }\\n        inserted\\n    }\\n\\n    /// Removes a value from the tree.\\n    ///\\n    /// Returns `true` if the tree contained the value.\\n    pub fn remove(&mut self, value: &T) -> bool {\\n        let removed = remove(&mut self.root, value);\\n        if removed {\\n            self.length -= 1;\\n        }\\n        removed\\n    }\\n\\n    /// Returns the number of values in the tree.\\n    pub fn len(&self) -> usize {\\n        self.length\\n    }\\n\\n    /// Returns `true` if the tree contains no values.\\n    pub fn is_empty(&self) -> bool {\\n        self.length == 0\\n    }\\n\\n    /// Returns an iterator that visits the nodes in the tree in order.\\n    fn node_iter(&self) -> NodeIter<T> {\\n        let cap = self.root.as_ref().map_or(0, |n| n.height);\\n        let mut node_iter = NodeIter {\\n            stack: Vec::with_capacity(cap),\\n        };\\n        // Initialize stack with path to leftmost child\\n        let mut child = &self.root;\\n        while let Some(node) = child {\\n            node_iter.stack.push(node.as_ref());\\n            child = &node.left;\\n        }\\n        node_iter\\n    }\\n\\n    /// Returns an iterator that visits the values in the tree in ascending order.\\n    pub fn iter(&self) -> Iter<T> {\\n        Iter {\\n            node_iter: self.node_iter(),\\n        }\\n    }\\n}\\n\\n/// Recursive helper function for `AVLTree` insertion.\\nfn insert<T: Ord>(tree: &mut Option<Box<AVLNode<T>>>, value: T) -> bool {\\n    if let Some(node) = tree {\\n        let inserted = match value.cmp(&node.value) {\\n            Ordering::Equal => false,\\n            Ordering::Less => insert(&mut node.left, value),\\n            Ordering::Greater => insert(&mut node.right, value),\\n        };\\n        if inserted {\\n            node.rebalance();\\n        }\\n        inserted\\n    } else {\\n        *tree = Some(Box::new(AVLNode {\\n            value,\\n            height: 1,\\n            left: None,\\n            right: None,\\n        }));\\n        true\\n    }\\n}\\n\\n/// Recursive helper function for `AVLTree` deletion.\\nfn remove<T: Ord>(tree: &mut Option<Box<AVLNode<T>>>, value: &T) -> bool {\\n    if let Some(node) = tree {\\n        let removed = match value.cmp(&node.value) {\\n            Ordering::Less => remove(&mut node.left, value),\\n            Ordering::Greater => remove(&mut node.right, value),\\n            Ordering::Equal => {\\n                *tree = match (node.left.take(), node.right.take()) {\\n                    (None, None) => None,\\n                    (Some(b), None) | (None, Some(b)) => Some(b),\\n                    (Some(left), Some(right)) => Some(merge(left, right)),\\n                };\\n                return true;\\n            }\\n        };\\n        if removed {\\n            node.rebalance();\\n        }\\n        removed\\n    } else {\\n        false\\n    }\\n}\\n\\n/// Merges two trees and returns the root of the merged tree.\\nfn merge<T: Ord>(left: Box<AVLNode<T>>, right: Box<AVLNode<T>>) -> Box<AVLNode<T>> {\\n    let mut op_right = Some(right);\\n    // Guaranteed not to panic since right has at least one node\\n    let mut root = take_min(&mut op_right).unwrap();\\n    root.left = Some(left);\\n    root.right = op_right;\\n    root.rebalance();\\n    root\\n}\\n\\n/// Removes the smallest node from the tree, if one exists.\\nfn take_min<T: Ord>(tree: &mut Option<Box<AVLNode<T>>>) -> Option<Box<AVLNode<T>>> {\\n    if let Some(mut node) = tree.take() {\\n        // Recurse along the left side\\n        if let Some(small) = take_min(&mut node.left) {\\n            // Took the smallest from below; update this node and put it back in the tree\\n            node.rebalance();\\n            *tree = Some(node);\\n            Some(small)\\n        } else {\\n            // Take this node and replace it with its right child\\n            *tree = node.right.take();\\n            Some(node)\\n        }\\n    } else {\\n        None\\n    }\\n}\\n\\nimpl<T: Ord> AVLNode<T> {\\n    /// Returns a reference to the left or right child.\\n    fn child(&self, side: Side) -> &Option<Box<AVLNode<T>>> {\\n        match side {\\n            Side::Left => &self.left,\\n            Side::Right => &self.right,\\n        }\\n    }\\n\\n    /// Returns a mutable reference to the left or right child.\\n    fn child_mut(&mut self, side: Side) -> &mut Option<Box<AVLNode<T>>> {\\n        match side {\\n            Side::Left => &mut self.left,\\n            Side::Right => &mut self.right,\\n        }\\n    }\\n\\n    /// Returns the height of the left or right subtree.\\n    fn height(&self, side: Side) -> usize {\\n        self.child(side).as_ref().map_or(0, |n| n.height)\\n    }\\n\\n    /// Returns the height difference between the left and right subtrees.\\n    fn balance_factor(&self) -> i8 {\\n        let (left, right) = (self.height(Side::Left), self.height(Side::Right));\\n        if left < right {\\n            (right - left) as i8\\n        } else {\\n            -((left - right) as i8)\\n        }\\n    }\\n\\n    /// Recomputes the `height` field.\\n    fn update_height(&mut self) {\\n        self.height = 1 + max(self.height(Side::Left), self.height(Side::Right));\\n    }\\n\\n    /// Performs a left or right rotation.\\n    fn rotate(&mut self, side: Side) {\\n        let mut subtree = self.child_mut(!side).take().unwrap();\\n        *self.child_mut(!side) = subtree.child_mut(side).take();\\n        self.update_height();\\n        // Swap root and child nodes in memory\\n        mem::swap(self, subtree.as_mut());\\n        // Set old root (subtree) as child of new root (self)\\n        *self.child_mut(side) = Some(subtree);\\n        self.update_height();\\n    }\\n\\n    /// Performs left or right tree rotations to balance this node.\\n    fn rebalance(&mut self) {\\n        self.update_height();\\n        let side = match self.balance_factor() {\\n            -2 => Side::Left,\\n            2 => Side::Right,\\n            _ => return,\\n        };\\n        let subtree = self.child_mut(side).as_mut().unwrap();\\n        // Left-Right and Right-Left require rotation of heavy subtree\\n        if let (Side::Left, 1) | (Side::Right, -1) = (side, subtree.balance_factor()) {\\n            subtree.rotate(side);\\n        }\\n        // Rotate in opposite direction of heavy side\\n        self.rotate(!side);\\n    }\\n}\\n\\nimpl<T: Ord> Default for AVLTree<T> {\\n    fn default() -> Self {\\n        Self::new()\\n    }\\n}\\n\\nimpl Not for Side {\\n    type Output = Side;\\n\\n    fn not(self) -> Self::Output {\\n        match self {\\n            Side::Left => Side::Right,\\n            Side::Right => Side::Left,\\n        }\\n    }\\n}\\n\\nimpl<T: Ord> FromIterator<T> for AVLTree<T> {\\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\\n        let mut tree = AVLTree::new();\\n        for value in iter {\\n            tree.insert(value);\\n        }\\n        tree\\n    }\\n}\\n\\n/// An iterator over the nodes of an `AVLTree`.\\n///\\n/// This struct is created by the `node_iter` method of `AVLTree`.\\nstruct NodeIter<'a, T: Ord> {\\n    stack: Vec<&'a AVLNode<T>>,\\n}\\n\\nimpl<'a, T: Ord> Iterator for NodeIter<'a, T> {\\n    type Item = &'a AVLNode<T>;\\n\\n    fn next(&mut self) -> Option<Self::Item> {\\n        if let Some(node) = self.stack.pop() {\\n            // Push left path of right subtree to stack\\n            let mut child = &node.right;\\n            while let Some(subtree) = child {\\n                self.stack.push(subtree.as_ref());\\n                child = &subtree.left;\\n            }\\n            Some(node)\\n        } else {\\n            None\\n        }\\n    }\\n}\\n\\n/// An iterator over the items of an `AVLTree`.\\n///\\n/// This struct is created by the `iter` method of `AVLTree`.\\npub struct Iter<'a, T: Ord> {\\n    node_iter: NodeIter<'a, T>,\\n}\\n\\nimpl<'a, T: Ord> Iterator for Iter<'a, T> {\\n    type Item = &'a T;\\n\\n    fn next(&mut self) -> Option<&'a T> {\\n        match self.node_iter.next() {\\n            Some(node) => Some(&node.value),\\n            None => None,\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::AVLTree;\\n\\n    /// Returns `true` if all nodes in the tree are balanced.\\n    fn is_balanced<T: Ord>(tree: &AVLTree<T>) -> bool {\\n        tree.node_iter()\\n            .all(|n| (-1..=1).contains(&n.balance_factor()))\\n    }\\n\\n    #[test]\\n    fn len() {\\n        let tree: AVLTree<_> = (1..4).collect();\\n        assert_eq!(tree.len(), 3);\\n    }\\n\\n    #[test]\\n    fn contains() {\\n        let tree: AVLTree<_> = (1..4).collect();\\n        assert!(tree.contains(&1));\\n        assert!(!tree.contains(&4));\\n    }\\n\\n    #[test]\\n    fn insert() {\\n        let mut tree = AVLTree::new();\\n        // First insert succeeds\\n        assert!(tree.insert(1));\\n        // Second insert fails\\n        assert!(!tree.insert(1));\\n    }\\n\\n    #[test]\\n    fn remove() {\\n        let mut tree: AVLTree<_> = (1..8).collect();\\n        // First remove succeeds\\n        assert!(tree.remove(&4));\\n        // Second remove fails\\n        assert!(!tree.remove(&4));\\n    }\\n\\n    #[test]\\n    fn sorted() {\\n        let tree: AVLTree<_> = (1..8).rev().collect();\\n        assert!((1..8).eq(tree.iter().map(|&x| x)));\\n    }\\n\\n    #[test]\\n    fn balanced() {\\n        let mut tree: AVLTree<_> = (1..8).collect();\\n        assert!(is_balanced(&tree));\\n        for x in 1..8 {\\n            tree.remove(&x);\\n            assert!(is_balanced(&tree));\\n        }\\n    }\\n}\\n\"",
    "binary search tree": "\"use std::cmp::Ordering;\\nuse std::ops::Deref;\\n\\n/// This struct implements as Binary Search Tree (BST), which is a\\n/// simple data structure for storing sorted data\\npub struct BinarySearchTree<T>\\nwhere\\n    T: Ord,\\n{\\n    value: Option<T>,\\n    left: Option<Box<BinarySearchTree<T>>>,\\n    right: Option<Box<BinarySearchTree<T>>>,\\n}\\n\\nimpl<T> Default for BinarySearchTree<T>\\nwhere\\n    T: Ord,\\n{\\n    fn default() -> Self {\\n        Self::new()\\n    }\\n}\\n\\nimpl<T> BinarySearchTree<T>\\nwhere\\n    T: Ord,\\n{\\n    /// Create a new, empty BST\\n    pub fn new() -> BinarySearchTree<T> {\\n        BinarySearchTree {\\n            value: None,\\n            left: None,\\n            right: None,\\n        }\\n    }\\n\\n    /// Find a value in this tree. Returns True iff value is in this\\n    /// tree, and false otherwise\\n    pub fn search(&self, value: &T) -> bool {\\n        match &self.value {\\n            Some(key) => {\\n                match key.cmp(value) {\\n                    Ordering::Equal => {\\n                        // key == value\\n                        true\\n                    }\\n                    Ordering::Greater => {\\n                        // key > value\\n                        match &self.left {\\n                            Some(node) => node.search(value),\\n                            None => false,\\n                        }\\n                    }\\n                    Ordering::Less => {\\n                        // key < value\\n                        match &self.right {\\n                            Some(node) => node.search(value),\\n                            None => false,\\n                        }\\n                    }\\n                }\\n            }\\n            None => false,\\n        }\\n    }\\n\\n    /// Returns a new iterator which iterates over this tree in order\\n    pub fn iter(&self) -> impl Iterator<Item = &T> {\\n        BinarySearchTreeIter::new(self)\\n    }\\n\\n    /// Insert a value into the appropriate location in this tree.\\n    pub fn insert(&mut self, value: T) {\\n        if self.value.is_none() {\\n            self.value = Some(value);\\n        } else {\\n            match &self.value {\\n                None => (),\\n                Some(key) => {\\n                    let target_node = if value < *key {\\n                        &mut self.left\\n                    } else {\\n                        &mut self.right\\n                    };\\n                    match target_node {\\n                        Some(ref mut node) => {\\n                            node.insert(value);\\n                        }\\n                        None => {\\n                            let mut node = BinarySearchTree::new();\\n                            node.insert(value);\\n                            *target_node = Some(Box::new(node));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Returns the smallest value in this tree\\n    pub fn minimum(&self) -> Option<&T> {\\n        match &self.left {\\n            Some(node) => node.minimum(),\\n            None => match &self.value {\\n                Some(value) => Some(value),\\n                None => None,\\n            },\\n        }\\n    }\\n\\n    /// Returns the largest value in this tree\\n    pub fn maximum(&self) -> Option<&T> {\\n        match &self.right {\\n            Some(node) => node.maximum(),\\n            None => match &self.value {\\n                Some(value) => Some(value),\\n                None => None,\\n            },\\n        }\\n    }\\n\\n    /// Returns the largest value in this tree smaller than value\\n    pub fn floor(&self, value: &T) -> Option<&T> {\\n        match &self.value {\\n            Some(key) => {\\n                match key.cmp(value) {\\n                    Ordering::Greater => {\\n                        // key > value\\n                        match &self.left {\\n                            Some(node) => node.floor(value),\\n                            None => None,\\n                        }\\n                    }\\n                    Ordering::Less => {\\n                        // key < value\\n                        match &self.right {\\n                            Some(node) => {\\n                                let val = node.floor(value);\\n                                match val {\\n                                    Some(_) => val,\\n                                    None => Some(key),\\n                                }\\n                            }\\n                            None => Some(key),\\n                        }\\n                    }\\n                    Ordering::Equal => Some(key),\\n                }\\n            }\\n            None => None,\\n        }\\n    }\\n\\n    /// Returns the smallest value in this tree larger than value\\n    pub fn ceil(&self, value: &T) -> Option<&T> {\\n        match &self.value {\\n            Some(key) => {\\n                match key.cmp(value) {\\n                    Ordering::Less => {\\n                        // key < value\\n                        match &self.right {\\n                            Some(node) => node.ceil(value),\\n                            None => None,\\n                        }\\n                    }\\n                    Ordering::Greater => {\\n                        // key > value\\n                        match &self.left {\\n                            Some(node) => {\\n                                let val = node.ceil(value);\\n                                match val {\\n                                    Some(_) => val,\\n                                    None => Some(key),\\n                                }\\n                            }\\n                            None => Some(key),\\n                        }\\n                    }\\n                    Ordering::Equal => {\\n                        // key == value\\n                        Some(key)\\n                    }\\n                }\\n            }\\n            None => None,\\n        }\\n    }\\n}\\n\\nstruct BinarySearchTreeIter<'a, T>\\nwhere\\n    T: Ord,\\n{\\n    stack: Vec<&'a BinarySearchTree<T>>,\\n}\\n\\nimpl<'a, T> BinarySearchTreeIter<'a, T>\\nwhere\\n    T: Ord,\\n{\\n    pub fn new(tree: &BinarySearchTree<T>) -> BinarySearchTreeIter<T> {\\n        let mut iter = BinarySearchTreeIter { stack: vec![tree] };\\n        iter.stack_push_left();\\n        iter\\n    }\\n\\n    fn stack_push_left(&mut self) {\\n        while let Some(child) = &self.stack.last().unwrap().left {\\n            self.stack.push(child);\\n        }\\n    }\\n}\\n\\nimpl<'a, T> Iterator for BinarySearchTreeIter<'a, T>\\nwhere\\n    T: Ord,\\n{\\n    type Item = &'a T;\\n\\n    fn next(&mut self) -> Option<&'a T> {\\n        if self.stack.is_empty() {\\n            None\\n        } else {\\n            let node = self.stack.pop().unwrap();\\n            if node.right.is_some() {\\n                self.stack.push(node.right.as_ref().unwrap().deref());\\n                self.stack_push_left();\\n            }\\n            node.value.as_ref()\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::BinarySearchTree;\\n\\n    fn prequel_memes_tree() -> BinarySearchTree<&'static str> {\\n        let mut tree = BinarySearchTree::new();\\n        tree.insert(\\\"hello there\\\");\\n        tree.insert(\\\"general kenobi\\\");\\n        tree.insert(\\\"you are a bold one\\\");\\n        tree.insert(\\\"kill him\\\");\\n        tree.insert(\\\"back away...I will deal with this jedi slime myself\\\");\\n        tree.insert(\\\"your move\\\");\\n        tree.insert(\\\"you fool\\\");\\n        tree\\n    }\\n\\n    #[test]\\n    fn test_search() {\\n        let tree = prequel_memes_tree();\\n        assert!(tree.search(&\\\"hello there\\\"));\\n        assert!(tree.search(&\\\"you are a bold one\\\"));\\n        assert!(tree.search(&\\\"general kenobi\\\"));\\n        assert!(tree.search(&\\\"you fool\\\"));\\n        assert!(tree.search(&\\\"kill him\\\"));\\n        assert!(\\n            !tree.search(&\\\"but i was going to tosche station to pick up some power converters\\\",)\\n        );\\n        assert!(!tree.search(&\\\"only a sith deals in absolutes\\\"));\\n        assert!(!tree.search(&\\\"you underestimate my power\\\"));\\n    }\\n\\n    #[test]\\n    fn test_maximum_and_minimum() {\\n        let tree = prequel_memes_tree();\\n        assert_eq!(*tree.maximum().unwrap(), \\\"your move\\\");\\n        assert_eq!(\\n            *tree.minimum().unwrap(),\\n            \\\"back away...I will deal with this jedi slime myself\\\"\\n        );\\n        let mut tree2: BinarySearchTree<i32> = BinarySearchTree::new();\\n        assert!(tree2.maximum().is_none());\\n        assert!(tree2.minimum().is_none());\\n        tree2.insert(0);\\n        assert_eq!(*tree2.minimum().unwrap(), 0);\\n        assert_eq!(*tree2.maximum().unwrap(), 0);\\n        tree2.insert(-5);\\n        assert_eq!(*tree2.minimum().unwrap(), -5);\\n        assert_eq!(*tree2.maximum().unwrap(), 0);\\n        tree2.insert(5);\\n        assert_eq!(*tree2.minimum().unwrap(), -5);\\n        assert_eq!(*tree2.maximum().unwrap(), 5);\\n    }\\n\\n    #[test]\\n    fn test_floor_and_ceil() {\\n        let tree = prequel_memes_tree();\\n        assert_eq!(*tree.floor(&\\\"hello there\\\").unwrap(), \\\"hello there\\\");\\n        assert_eq!(\\n            *tree\\n                .floor(&\\\"these are not the droids you're looking for\\\")\\n                .unwrap(),\\n            \\\"kill him\\\"\\n        );\\n        assert!(tree.floor(&\\\"another death star\\\").is_none());\\n        assert_eq!(*tree.floor(&\\\"you fool\\\").unwrap(), \\\"you fool\\\");\\n        assert_eq!(\\n            *tree.floor(&\\\"but i was going to tasche station\\\").unwrap(),\\n            \\\"back away...I will deal with this jedi slime myself\\\"\\n        );\\n        assert_eq!(\\n            *tree.floor(&\\\"you underestimate my power\\\").unwrap(),\\n            \\\"you fool\\\"\\n        );\\n        assert_eq!(*tree.floor(&\\\"your new empire\\\").unwrap(), \\\"your move\\\");\\n        assert_eq!(*tree.ceil(&\\\"hello there\\\").unwrap(), \\\"hello there\\\");\\n        assert_eq!(\\n            *tree\\n                .ceil(&\\\"these are not the droids you're looking for\\\")\\n                .unwrap(),\\n            \\\"you are a bold one\\\"\\n        );\\n        assert_eq!(\\n            *tree.ceil(&\\\"another death star\\\").unwrap(),\\n            \\\"back away...I will deal with this jedi slime myself\\\"\\n        );\\n        assert_eq!(*tree.ceil(&\\\"you fool\\\").unwrap(), \\\"you fool\\\");\\n        assert_eq!(\\n            *tree.ceil(&\\\"but i was going to tasche station\\\").unwrap(),\\n            \\\"general kenobi\\\"\\n        );\\n        assert_eq!(\\n            *tree.ceil(&\\\"you underestimate my power\\\").unwrap(),\\n            \\\"your move\\\"\\n        );\\n        assert!(tree.ceil(&\\\"your new empire\\\").is_none());\\n    }\\n\\n    #[test]\\n    fn test_iterator() {\\n        let tree = prequel_memes_tree();\\n        let mut iter = tree.iter();\\n        assert_eq!(\\n            iter.next().unwrap(),\\n            &\\\"back away...I will deal with this jedi slime myself\\\"\\n        );\\n        assert_eq!(iter.next().unwrap(), &\\\"general kenobi\\\");\\n        assert_eq!(iter.next().unwrap(), &\\\"hello there\\\");\\n        assert_eq!(iter.next().unwrap(), &\\\"kill him\\\");\\n        assert_eq!(iter.next().unwrap(), &\\\"you are a bold one\\\");\\n        assert_eq!(iter.next().unwrap(), &\\\"you fool\\\");\\n        assert_eq!(iter.next().unwrap(), &\\\"your move\\\");\\n        assert_eq!(iter.next(), None);\\n        assert_eq!(iter.next(), None);\\n    }\\n}\\n\"",
    "b tree": "\"use std::convert::TryFrom;\\nuse std::fmt::Debug;\\nuse std::mem;\\n\\nstruct Node<T> {\\n    keys: Vec<T>,\\n    children: Vec<Node<T>>,\\n}\\n\\npub struct BTree<T> {\\n    root: Node<T>,\\n    props: BTreeProps,\\n}\\n\\n// Why to need a different Struct for props...\\n// Check - http://smallcultfollowing.com/babysteps/blog/2018/11/01/after-nll-interprocedural-conflicts/#fnref:improvement\\nstruct BTreeProps {\\n    degree: usize,\\n    max_keys: usize,\\n    mid_key_index: usize,\\n}\\n\\nimpl<T> Node<T>\\nwhere\\n    T: Ord,\\n{\\n    fn new(degree: usize, _keys: Option<Vec<T>>, _children: Option<Vec<Node<T>>>) -> Self {\\n        Node {\\n            keys: match _keys {\\n                Some(_keys) => _keys,\\n                None => Vec::with_capacity(degree - 1),\\n            },\\n            children: match _children {\\n                Some(_children) => _children,\\n                None => Vec::with_capacity(degree),\\n            },\\n        }\\n    }\\n\\n    fn is_leaf(&self) -> bool {\\n        self.children.is_empty()\\n    }\\n}\\n\\nimpl BTreeProps {\\n    fn new(degree: usize) -> Self {\\n        BTreeProps {\\n            degree,\\n            max_keys: degree - 1,\\n            mid_key_index: (degree - 1) / 2,\\n        }\\n    }\\n\\n    fn is_maxed_out<T: Ord + Copy>(&self, node: &Node<T>) -> bool {\\n        node.keys.len() == self.max_keys\\n    }\\n\\n    // Split Child expects the Child Node to be full\\n    /// Move the middle_key to parent node and split the child_node's\\n    /// keys/chilren_nodes into half\\n    fn split_child<T: Ord + Copy + Default>(&self, parent: &mut Node<T>, child_index: usize) {\\n        let child = &mut parent.children[child_index];\\n        let middle_key = child.keys[self.mid_key_index];\\n        let right_keys = match child.keys.split_off(self.mid_key_index).split_first() {\\n            Some((_first, _others)) => {\\n                // We don't need _first, as it will move to parent node.\\n                _others.to_vec()\\n            }\\n            None => Vec::with_capacity(self.max_keys),\\n        };\\n        let right_children = if !child.is_leaf() {\\n            Some(child.children.split_off(self.mid_key_index + 1))\\n        } else {\\n            None\\n        };\\n        let new_child_node: Node<T> = Node::new(self.degree, Some(right_keys), right_children);\\n\\n        parent.keys.insert(child_index, middle_key);\\n        parent.children.insert(child_index + 1, new_child_node);\\n    }\\n\\n    fn insert_non_full<T: Ord + Copy + Default>(&mut self, node: &mut Node<T>, key: T) {\\n        let mut index: isize = isize::try_from(node.keys.len()).ok().unwrap() - 1;\\n        while index >= 0 && node.keys[index as usize] >= key {\\n            index -= 1;\\n        }\\n\\n        let mut u_index: usize = usize::try_from(index + 1).ok().unwrap();\\n        if node.is_leaf() {\\n            // Just insert it, as we know this method will be called only when node is not full\\n            node.keys.insert(u_index, key);\\n        } else {\\n            if self.is_maxed_out(&node.children[u_index]) {\\n                self.split_child(node, u_index);\\n                if node.keys[u_index] < key {\\n                    u_index += 1;\\n                }\\n            }\\n\\n            self.insert_non_full(&mut node.children[u_index], key);\\n        }\\n    }\\n\\n    fn traverse_node<T: Ord + Debug>(&self, node: &Node<T>, depth: usize) {\\n        if node.is_leaf() {\\n            print!(\\\" {0:{<1$}{2:?}{0:}<1$} \\\", \\\"\\\", depth, node.keys);\\n        } else {\\n            let _depth = depth + 1;\\n            for (index, key) in node.keys.iter().enumerate() {\\n                self.traverse_node(&node.children[index], _depth);\\n                // Check https://doc.rust-lang.org/std/fmt/index.html\\n                // And https://stackoverflow.com/a/35280799/2849127\\n                print!(\\\"{0:{<1$}{2:?}{0:}<1$}\\\", \\\"\\\", depth, key);\\n            }\\n            self.traverse_node(node.children.last().unwrap(), _depth);\\n        }\\n    }\\n}\\n\\nimpl<T> BTree<T>\\nwhere\\n    T: Ord + Copy + Debug + Default,\\n{\\n    pub fn new(branch_factor: usize) -> Self {\\n        let degree = 2 * branch_factor;\\n        BTree {\\n            root: Node::new(degree, None, None),\\n            props: BTreeProps::new(degree),\\n        }\\n    }\\n\\n    pub fn insert(&mut self, key: T) {\\n        if self.props.is_maxed_out(&self.root) {\\n            // Create an empty root and split the old root...\\n            let mut new_root = Node::new(self.props.degree, None, None);\\n            mem::swap(&mut new_root, &mut self.root);\\n            self.root.children.insert(0, new_root);\\n            self.props.split_child(&mut self.root, 0);\\n        }\\n        self.props.insert_non_full(&mut self.root, key);\\n    }\\n\\n    pub fn traverse(&self) {\\n        self.props.traverse_node(&self.root, 0);\\n        println!();\\n    }\\n\\n    pub fn search(&self, key: T) -> bool {\\n        let mut current_node = &self.root;\\n        let mut index: isize;\\n        loop {\\n            index = isize::try_from(current_node.keys.len()).ok().unwrap() - 1;\\n            while index >= 0 && current_node.keys[index as usize] > key {\\n                index -= 1;\\n            }\\n\\n            let u_index: usize = usize::try_from(index + 1).ok().unwrap();\\n            if index >= 0 && current_node.keys[u_index - 1] == key {\\n                break true;\\n            } else if current_node.is_leaf() {\\n                break false;\\n            } else {\\n                current_node = &current_node.children[u_index];\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::BTree;\\n\\n    #[test]\\n    fn test_search() {\\n        let mut tree = BTree::new(2);\\n        tree.insert(10);\\n        tree.insert(20);\\n        tree.insert(30);\\n        tree.insert(5);\\n        tree.insert(6);\\n        tree.insert(7);\\n        tree.insert(11);\\n        tree.insert(12);\\n        tree.insert(15);\\n        assert!(tree.search(15));\\n        assert_eq!(tree.search(16), false);\\n    }\\n}\\n\"",
    "graph": "\"use std::collections::{HashMap, HashSet};\\nuse std::fmt;\\n\\n#[derive(Debug, Clone)]\\npub struct NodeNotInGraph;\\n\\nimpl fmt::Display for NodeNotInGraph {\\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\\n        write!(f, \\\"accessing a node that is not in the graph\\\")\\n    }\\n}\\n\\npub struct DirectedGraph {\\n    adjacency_table: HashMap<String, Vec<(String, i32)>>,\\n}\\n\\nimpl Graph for DirectedGraph {\\n    fn new() -> DirectedGraph {\\n        DirectedGraph {\\n            adjacency_table: HashMap::new(),\\n        }\\n    }\\n    fn adjacency_table_mutable(&mut self) -> &mut HashMap<String, Vec<(String, i32)>> {\\n        &mut self.adjacency_table\\n    }\\n    fn adjacency_table(&self) -> &HashMap<String, Vec<(String, i32)>> {\\n        &self.adjacency_table\\n    }\\n}\\n\\npub struct UndirectedGraph {\\n    adjacency_table: HashMap<String, Vec<(String, i32)>>,\\n}\\n\\nimpl Graph for UndirectedGraph {\\n    fn new() -> UndirectedGraph {\\n        UndirectedGraph {\\n            adjacency_table: HashMap::new(),\\n        }\\n    }\\n    fn adjacency_table_mutable(&mut self) -> &mut HashMap<String, Vec<(String, i32)>> {\\n        &mut self.adjacency_table\\n    }\\n    fn adjacency_table(&self) -> &HashMap<String, Vec<(String, i32)>> {\\n        &self.adjacency_table\\n    }\\n    fn add_edge(&mut self, edge: (&str, &str, i32)) {\\n        self.add_node(edge.0);\\n        self.add_node(edge.1);\\n\\n        self.adjacency_table\\n            .entry(edge.0.to_string())\\n            .and_modify(|e| {\\n                e.push((edge.1.to_string(), edge.2));\\n            });\\n        self.adjacency_table\\n            .entry(edge.1.to_string())\\n            .and_modify(|e| {\\n                e.push((edge.0.to_string(), edge.2));\\n            });\\n    }\\n}\\n\\npub trait Graph {\\n    fn new() -> Self;\\n    fn adjacency_table_mutable(&mut self) -> &mut HashMap<String, Vec<(String, i32)>>;\\n    fn adjacency_table(&self) -> &HashMap<String, Vec<(String, i32)>>;\\n\\n    fn add_node(&mut self, node: &str) -> bool {\\n        match self.adjacency_table().get(node) {\\n            None => {\\n                self.adjacency_table_mutable()\\n                    .insert((*node).to_string(), Vec::new());\\n                true\\n            }\\n            _ => false,\\n        }\\n    }\\n\\n    fn add_edge(&mut self, edge: (&str, &str, i32)) {\\n        self.add_node(edge.0);\\n        self.add_node(edge.1);\\n\\n        self.adjacency_table_mutable()\\n            .entry(edge.0.to_string())\\n            .and_modify(|e| {\\n                e.push((edge.1.to_string(), edge.2));\\n            });\\n    }\\n\\n    fn neighbours(&self, node: &str) -> Result<&Vec<(String, i32)>, NodeNotInGraph> {\\n        match self.adjacency_table().get(node) {\\n            None => Err(NodeNotInGraph),\\n            Some(i) => Ok(i),\\n        }\\n    }\\n\\n    fn contains(&self, node: &str) -> bool {\\n        self.adjacency_table().get(node).is_some()\\n    }\\n\\n    fn nodes(&self) -> HashSet<&String> {\\n        self.adjacency_table().keys().collect()\\n    }\\n\\n    fn edges(&self) -> Vec<(&String, &String, i32)> {\\n        let mut edges = Vec::new();\\n        for (from_node, from_node_neighbours) in self.adjacency_table() {\\n            for (to_node, weight) in from_node_neighbours {\\n                edges.push((from_node, to_node, *weight));\\n            }\\n        }\\n        edges\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test_undirected_graph {\\n    use super::Graph;\\n    use super::UndirectedGraph;\\n    #[test]\\n    fn test_add_edge() {\\n        let mut graph = UndirectedGraph::new();\\n\\n        graph.add_edge((\\\"a\\\", \\\"b\\\", 5));\\n        graph.add_edge((\\\"b\\\", \\\"c\\\", 10));\\n        graph.add_edge((\\\"c\\\", \\\"a\\\", 7));\\n\\n        let expected_edges = [\\n            (&String::from(\\\"a\\\"), &String::from(\\\"b\\\"), 5),\\n            (&String::from(\\\"b\\\"), &String::from(\\\"a\\\"), 5),\\n            (&String::from(\\\"c\\\"), &String::from(\\\"a\\\"), 7),\\n            (&String::from(\\\"a\\\"), &String::from(\\\"c\\\"), 7),\\n            (&String::from(\\\"b\\\"), &String::from(\\\"c\\\"), 10),\\n            (&String::from(\\\"c\\\"), &String::from(\\\"b\\\"), 10),\\n        ];\\n        for edge in expected_edges.iter() {\\n            assert_eq!(graph.edges().contains(edge), true);\\n        }\\n    }\\n\\n    #[test]\\n    fn test_neighbours() {\\n        let mut graph = UndirectedGraph::new();\\n\\n        graph.add_edge((\\\"a\\\", \\\"b\\\", 5));\\n        graph.add_edge((\\\"b\\\", \\\"c\\\", 10));\\n        graph.add_edge((\\\"c\\\", \\\"a\\\", 7));\\n\\n        assert_eq!(\\n            graph.neighbours(\\\"a\\\").unwrap(),\\n            &vec![(String::from(\\\"b\\\"), 5), (String::from(\\\"c\\\"), 7)]\\n        );\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test_directed_graph {\\n    use super::DirectedGraph;\\n    use super::Graph;\\n\\n    #[test]\\n    fn test_add_node() {\\n        let mut graph = DirectedGraph::new();\\n        graph.add_node(\\\"a\\\");\\n        graph.add_node(\\\"b\\\");\\n        graph.add_node(\\\"c\\\");\\n        assert_eq!(\\n            graph.nodes(),\\n            [&String::from(\\\"a\\\"), &String::from(\\\"b\\\"), &String::from(\\\"c\\\")]\\n                .iter()\\n                .cloned()\\n                .collect()\\n        );\\n    }\\n\\n    #[test]\\n    fn test_add_edge() {\\n        let mut graph = DirectedGraph::new();\\n\\n        graph.add_edge((\\\"a\\\", \\\"b\\\", 5));\\n        graph.add_edge((\\\"c\\\", \\\"a\\\", 7));\\n        graph.add_edge((\\\"b\\\", \\\"c\\\", 10));\\n\\n        let expected_edges = [\\n            (&String::from(\\\"a\\\"), &String::from(\\\"b\\\"), 5),\\n            (&String::from(\\\"c\\\"), &String::from(\\\"a\\\"), 7),\\n            (&String::from(\\\"b\\\"), &String::from(\\\"c\\\"), 10),\\n        ];\\n        for edge in expected_edges.iter() {\\n            assert_eq!(graph.edges().contains(edge), true);\\n        }\\n    }\\n\\n    #[test]\\n    fn test_neighbours() {\\n        let mut graph = DirectedGraph::new();\\n\\n        graph.add_edge((\\\"a\\\", \\\"b\\\", 5));\\n        graph.add_edge((\\\"b\\\", \\\"c\\\", 10));\\n        graph.add_edge((\\\"c\\\", \\\"a\\\", 7));\\n\\n        assert_eq!(\\n            graph.neighbours(\\\"a\\\").unwrap(),\\n            &vec![(String::from(\\\"b\\\"), 5)]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_contains() {\\n        let mut graph = DirectedGraph::new();\\n        graph.add_node(\\\"a\\\");\\n        graph.add_node(\\\"b\\\");\\n        graph.add_node(\\\"c\\\");\\n        assert_eq!(graph.contains(\\\"a\\\"), true);\\n        assert_eq!(graph.contains(\\\"b\\\"), true);\\n        assert_eq!(graph.contains(\\\"c\\\"), true);\\n        assert_eq!(graph.contains(\\\"d\\\"), false);\\n    }\\n}\\n\"",
    "heap": "\"// Heap data structure\\n// Takes a closure as a comparator to allow for min-heap, max-heap, and works with custom key functions\\n\\nuse std::cmp::Ord;\\nuse std::default::Default;\\n\\npub struct Heap<T>\\nwhere\\n    T: Default,\\n{\\n    count: usize,\\n    items: Vec<T>,\\n    comparator: fn(&T, &T) -> bool,\\n}\\n\\nimpl<T> Heap<T>\\nwhere\\n    T: Default,\\n{\\n    pub fn new(comparator: fn(&T, &T) -> bool) -> Self {\\n        Self {\\n            count: 0,\\n            // Add a default in the first spot to offset indexes\\n            // for the parent/child math to work out.\\n            // Vecs have to have all the same type so using Default\\n            // is a way to add an unused item.\\n            items: vec![T::default()],\\n            comparator,\\n        }\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        self.count\\n    }\\n\\n    pub fn is_empty(&self) -> bool {\\n        self.len() == 0\\n    }\\n\\n    pub fn add(&mut self, value: T) {\\n        self.count += 1;\\n        self.items.push(value);\\n\\n        // Heapify Up\\n        let mut idx = self.count;\\n        while self.parent_idx(idx) > 0 {\\n            let pdx = self.parent_idx(idx);\\n            if (self.comparator)(&self.items[idx], &self.items[pdx]) {\\n                self.items.swap(idx, pdx);\\n            }\\n            idx = pdx;\\n        }\\n    }\\n\\n    fn parent_idx(&self, idx: usize) -> usize {\\n        idx / 2\\n    }\\n\\n    fn children_present(&self, idx: usize) -> bool {\\n        self.left_child_idx(idx) <= self.count\\n    }\\n\\n    fn left_child_idx(&self, idx: usize) -> usize {\\n        idx * 2\\n    }\\n\\n    fn right_child_idx(&self, idx: usize) -> usize {\\n        self.left_child_idx(idx) + 1\\n    }\\n\\n    fn smallest_child_idx(&self, idx: usize) -> usize {\\n        if self.right_child_idx(idx) > self.count {\\n            self.left_child_idx(idx)\\n        } else {\\n            let ldx = self.left_child_idx(idx);\\n            let rdx = self.right_child_idx(idx);\\n            if (self.comparator)(&self.items[ldx], &self.items[rdx]) {\\n                ldx\\n            } else {\\n                rdx\\n            }\\n        }\\n    }\\n}\\n\\nimpl<T> Heap<T>\\nwhere\\n    T: Default + Ord,\\n{\\n    /// Create a new MinHeap\\n    pub fn new_min() -> Self {\\n        Self::new(|a, b| a < b)\\n    }\\n\\n    /// Create a new MaxHeap\\n    pub fn new_max() -> Self {\\n        Self::new(|a, b| a > b)\\n    }\\n}\\n\\nimpl<T> Iterator for Heap<T>\\nwhere\\n    T: Default,\\n{\\n    type Item = T;\\n\\n    fn next(&mut self) -> Option<T> {\\n        if self.count == 0 {\\n            return None;\\n        }\\n        // This feels like a function built for heap impl :)\\n        // Removes an item at an index and fills in with the last item\\n        // of the Vec\\n        let next = Some(self.items.swap_remove(1));\\n        self.count -= 1;\\n\\n        if self.count > 0 {\\n            // Heapify Down\\n            let mut idx = 1;\\n            while self.children_present(idx) {\\n                let cdx = self.smallest_child_idx(idx);\\n                if !(self.comparator)(&self.items[idx], &self.items[cdx]) {\\n                    self.items.swap(idx, cdx);\\n                }\\n                idx = cdx;\\n            }\\n        }\\n\\n        next\\n    }\\n}\\n\\npub struct MinHeap;\\n\\nimpl MinHeap {\\n    #[allow(clippy::new_ret_no_self)]\\n    pub fn new<T>() -> Heap<T>\\n    where\\n        T: Default + Ord,\\n    {\\n        Heap::new(|a, b| a < b)\\n    }\\n}\\n\\npub struct MaxHeap;\\n\\nimpl MaxHeap {\\n    #[allow(clippy::new_ret_no_self)]\\n    pub fn new<T>() -> Heap<T>\\n    where\\n        T: Default + Ord,\\n    {\\n        Heap::new(|a, b| a > b)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n    #[test]\\n    fn test_empty_heap() {\\n        let mut heap = MaxHeap::new::<i32>();\\n        assert_eq!(heap.next(), None);\\n    }\\n\\n    #[test]\\n    fn test_min_heap() {\\n        let mut heap = MinHeap::new();\\n        heap.add(4);\\n        heap.add(2);\\n        heap.add(9);\\n        heap.add(11);\\n        assert_eq!(heap.len(), 4);\\n        assert_eq!(heap.next(), Some(2));\\n        assert_eq!(heap.next(), Some(4));\\n        assert_eq!(heap.next(), Some(9));\\n        heap.add(1);\\n        assert_eq!(heap.next(), Some(1));\\n    }\\n\\n    #[test]\\n    fn test_max_heap() {\\n        let mut heap = MaxHeap::new();\\n        heap.add(4);\\n        heap.add(2);\\n        heap.add(9);\\n        heap.add(11);\\n        assert_eq!(heap.len(), 4);\\n        assert_eq!(heap.next(), Some(11));\\n        assert_eq!(heap.next(), Some(9));\\n        assert_eq!(heap.next(), Some(4));\\n        heap.add(1);\\n        assert_eq!(heap.next(), Some(2));\\n    }\\n\\n    struct Point(/* x */ i32, /* y */ i32);\\n    impl Default for Point {\\n        fn default() -> Self {\\n            Self(0, 0)\\n        }\\n    }\\n\\n    #[test]\\n    fn test_key_heap() {\\n        let mut heap: Heap<Point> = Heap::new(|a, b| a.0 < b.0);\\n        heap.add(Point(1, 5));\\n        heap.add(Point(3, 10));\\n        heap.add(Point(-2, 4));\\n        assert_eq!(heap.len(), 3);\\n        assert_eq!(heap.next().unwrap().0, -2);\\n        assert_eq!(heap.next().unwrap().0, 1);\\n        heap.add(Point(50, 34));\\n        assert_eq!(heap.next().unwrap().0, 3);\\n    }\\n}\\n\"",
    "linked list": "\"use std::fmt::{self, Display, Formatter};\\nuse std::ptr::NonNull;\\n\\nstruct Node<T> {\\n    val: T,\\n    next: Option<NonNull<Node<T>>>,\\n    prev: Option<NonNull<Node<T>>>,\\n}\\n\\nimpl<T> Node<T> {\\n    fn new(t: T) -> Node<T> {\\n        Node {\\n            val: t,\\n            prev: None,\\n            next: None,\\n        }\\n    }\\n}\\n\\npub struct LinkedList<T> {\\n    length: u32,\\n    start: Option<NonNull<Node<T>>>,\\n    end: Option<NonNull<Node<T>>>,\\n}\\n\\nimpl<T> Default for LinkedList<T> {\\n    fn default() -> Self {\\n        Self::new()\\n    }\\n}\\n\\nimpl<T> LinkedList<T> {\\n    pub fn new() -> Self {\\n        Self {\\n            length: 0,\\n            start: None,\\n            end: None,\\n        }\\n    }\\n\\n    pub fn add(&mut self, obj: T) {\\n        let mut node = Box::new(Node::new(obj));\\n        // Since we are adding node at the end, next will always be None\\n        node.next = None;\\n        node.prev = self.end;\\n        // Get a pointer to node\\n        let node_ptr = Some(unsafe { NonNull::new_unchecked(Box::into_raw(node)) });\\n        match self.end {\\n            // This is the case of empty list\\n            None => self.start = node_ptr,\\n            Some(end_ptr) => unsafe { (*end_ptr.as_ptr()).next = node_ptr },\\n        }\\n        self.end = node_ptr;\\n        self.length += 1;\\n    }\\n\\n    pub fn get(&mut self, index: i32) -> Option<&T> {\\n        self.get_ith_node(self.start, index)\\n    }\\n\\n    fn get_ith_node(&mut self, node: Option<NonNull<Node<T>>>, index: i32) -> Option<&T> {\\n        match node {\\n            None => None,\\n            Some(next_ptr) => match index {\\n                0 => Some(unsafe { &(*next_ptr.as_ptr()).val }),\\n                _ => self.get_ith_node(unsafe { (*next_ptr.as_ptr()).next }, index - 1),\\n            },\\n        }\\n    }\\n}\\n\\nimpl<T> Display for LinkedList<T>\\nwhere\\n    T: Display,\\n{\\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\\n        match self.start {\\n            Some(node) => write!(f, \\\"{}\\\", unsafe { node.as_ref() }),\\n            None => Ok(()),\\n        }\\n    }\\n}\\n\\nimpl<T> Display for Node<T>\\nwhere\\n    T: Display,\\n{\\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\\n        match self.next {\\n            Some(node) => write!(f, \\\"{}, {}\\\", self.val, unsafe { node.as_ref() }),\\n            None => write!(f, \\\"{}\\\", self.val),\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::LinkedList;\\n\\n    #[test]\\n    fn create_numeric_list() {\\n        let mut list = LinkedList::<i32>::new();\\n        list.add(1);\\n        list.add(2);\\n        list.add(3);\\n        println!(\\\"Linked List is {}\\\", list);\\n        assert_eq!(3, list.length);\\n    }\\n\\n    #[test]\\n    fn create_string_list() {\\n        let mut list_str = LinkedList::<String>::new();\\n        list_str.add(\\\"A\\\".to_string());\\n        list_str.add(\\\"B\\\".to_string());\\n        list_str.add(\\\"C\\\".to_string());\\n        println!(\\\"Linked List is {}\\\", list_str);\\n        assert_eq!(3, list_str.length);\\n    }\\n\\n    #[test]\\n    fn get_by_index_in_numeric_list() {\\n        let mut list = LinkedList::<i32>::new();\\n        list.add(1);\\n        list.add(2);\\n        println!(\\\"Linked List is {}\\\", list);\\n        let retrived_item = list.get(1);\\n        assert!(retrived_item.is_some());\\n        assert_eq!(2 as i32, *retrived_item.unwrap());\\n    }\\n\\n    #[test]\\n    fn get_by_index_in_string_list() {\\n        let mut list_str = LinkedList::<String>::new();\\n        list_str.add(\\\"A\\\".to_string());\\n        list_str.add(\\\"B\\\".to_string());\\n        println!(\\\"Linked List is {}\\\", list_str);\\n        let retrived_item = list_str.get(1);\\n        assert!(retrived_item.is_some());\\n        assert_eq!(\\\"B\\\", *retrived_item.unwrap());\\n    }\\n}\\n\"",
    "queue": "\"#[derive(Debug)]\\npub struct Queue<T> {\\n    elements: Vec<T>,\\n}\\n\\nimpl<T: Clone> Queue<T> {\\n    pub fn new() -> Queue<T> {\\n        Queue {\\n            elements: Vec::new(),\\n        }\\n    }\\n\\n    pub fn enqueue(&mut self, value: T) {\\n        self.elements.push(value)\\n    }\\n\\n    pub fn dequeue(&mut self) -> Result<T, &str> {\\n        if !self.elements.is_empty() {\\n            Ok(self.elements.remove(0usize))\\n        } else {\\n            Err(\\\"Queue is empty\\\")\\n        }\\n    }\\n\\n    pub fn peek(&self) -> Result<&T, &str> {\\n        match self.elements.first() {\\n            Some(value) => Ok(value),\\n            None => Err(\\\"Queue is empty\\\"),\\n        }\\n    }\\n\\n    pub fn size(&self) -> usize {\\n        self.elements.len()\\n    }\\n\\n    pub fn is_empty(&self) -> bool {\\n        self.elements.is_empty()\\n    }\\n}\\n\\nimpl<T> Default for Queue<T> {\\n    fn default() -> Queue<T> {\\n        Queue {\\n            elements: Vec::new(),\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::Queue;\\n\\n    #[test]\\n    fn test_enqueue() {\\n        let mut queue: Queue<u8> = Queue::new();\\n        queue.enqueue(64);\\n        assert_eq!(queue.is_empty(), false);\\n    }\\n\\n    #[test]\\n    fn test_dequeue() {\\n        let mut queue: Queue<u8> = Queue::new();\\n        queue.enqueue(32);\\n        queue.enqueue(64);\\n        let retrieved_dequeue = queue.dequeue();\\n        assert!(retrieved_dequeue.is_ok());\\n        assert_eq!(32, retrieved_dequeue.unwrap());\\n    }\\n\\n    #[test]\\n    fn test_peek() {\\n        let mut queue: Queue<u8> = Queue::new();\\n        queue.enqueue(8);\\n        queue.enqueue(16);\\n        let retrieved_peek = queue.peek();\\n        assert!(retrieved_peek.is_ok());\\n        assert_eq!(8, *retrieved_peek.unwrap());\\n    }\\n\\n    #[test]\\n    fn test_size() {\\n        let mut queue: Queue<u8> = Queue::new();\\n        queue.enqueue(8);\\n        queue.enqueue(16);\\n        assert_eq!(2, queue.size());\\n    }\\n}\\n\"",
    "stack using singly linked list": "\"// the public struct can hide the implementation detail\\npub struct Stack<T> {\\n    head: Link<T>,\\n}\\n\\ntype Link<T> = Option<Box<Node<T>>>;\\n\\nstruct Node<T> {\\n    elem: T,\\n    next: Link<T>,\\n}\\n\\nimpl<T> Stack<T> {\\n    // Self is an alias for Stack\\n    // We implement associated function name new for single-linked-list\\n    pub fn new() -> Self {\\n        // for new function we need to return a new instance\\n        Self {\\n            // we refer to variants of an enum using :: the namespacing operator\\n            head: None,\\n        } // we need to return the variant, so there without the ;\\n    }\\n\\n    // As we know the primary forms that self can take: self, &mut self and &self, push will change the linked list\\n    // so we need &mut\\n    // The push method which the signature's first parameter is self\\n    pub fn push(&mut self, elem: T) {\\n        let new_node = Box::new(Node {\\n            elem,\\n            next: self.head.take(),\\n        });\\n        // don't forget replace the head with new node for stack\\n        self.head = Some(new_node);\\n    }\\n    ///\\n    /// In pop function, we trying to:\\n    /// * check if the list is empty, so we use enum Option<T>, it can either be Some(T) or None\\n    ///   * if it's empty, return None\\n    ///   * if it's not empty\\n    ///     * remove the head of the list\\n    ///     * remove its elem\\n    ///     * replace the list's head with its next\\n    ///     * return Some(elem), as the situation if need\\n    ///\\n    /// so, we need to remove the head, and return the value of the head\\n    pub fn pop(&mut self) -> Result<T, &str> {\\n        match self.head.take() {\\n            None => Err(\\\"Stack is empty\\\"),\\n            Some(node) => {\\n                self.head = node.next;\\n                Ok(node.elem)\\n            }\\n        }\\n    }\\n\\n    pub fn is_empty(&self) -> bool {\\n        // Returns true if the option is a [None] value.\\n        self.head.is_none()\\n    }\\n\\n    pub fn peek(&self) -> Option<&T> {\\n        // Converts from &Option<T> to Option<&T>.\\n        match self.head.as_ref() {\\n            None => None,\\n            Some(node) => Some(&node.elem),\\n        }\\n    }\\n\\n    pub fn peek_mut(&mut self) -> Option<&mut T> {\\n        match self.head.as_mut() {\\n            None => None,\\n            Some(node) => Some(&mut node.elem),\\n        }\\n    }\\n\\n    pub fn into_iter_for_stack(self) -> IntoIter<T> {\\n        IntoIter(self)\\n    }\\n    pub fn iter(&self) -> Iter<'_, T> {\\n        Iter {\\n            next: self.head.as_deref(),\\n        }\\n    }\\n    // '_ is the \\\"explicitly elided lifetime\\\" syntax of Rust\\n    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\\n        IterMut {\\n            next: self.head.as_deref_mut(),\\n        }\\n    }\\n}\\n\\nimpl<T> Default for Stack<T> {\\n    fn default() -> Self {\\n        Self::new()\\n    }\\n}\\n\\n/// The drop method of singly linked list. There's a question that do we need to worry about cleaning up our list?\\n/// As we all know the ownership and borrow mechanism, so we know the type will clean automatically after it goes out the scope,\\n/// this implement by the Rust compiler automatically did which mean add trait `drop` for the automatically.\\n///\\n/// So, the complier will implements Drop for `List->Link->Box<Node> ->Node` automatically and tail recursive to clean the elements\\n/// one by one. And we know the recursive will stop at Box<Node>\\n/// https://rust-unofficial.github.io/too-many-lists/first-drop.html\\n///\\n/// As we know we can't drop the contents of the Box after deallocating, so we need to manually write the iterative drop\\n\\nimpl<T> Drop for Stack<T> {\\n    fn drop(&mut self) {\\n        let mut cur_link = self.head.take();\\n        while let Some(mut boxed_node) = cur_link {\\n            cur_link = boxed_node.next.take();\\n            // boxed_node goes out of scope and gets dropped here;\\n            // but its Node's `next` field has been set to None\\n            // so no unbound recursion occurs.\\n        }\\n    }\\n}\\n\\n/// Rust has nothing like a yield statement, and there's actually 3 different kinds of iterator should to implement\\n\\n// Collections are iterated in Rust using the Iterator trait, we define a struct implement Iterator\\npub struct IntoIter<T>(Stack<T>);\\n\\nimpl<T> Iterator for IntoIter<T> {\\n    // This is declaring that every implementation of iterator has an associated type called Item\\n    type Item = T;\\n    // the reason iterator yield Option<self::Item> is because the interface coalesces the `has_next` and `get_next` concepts\\n    fn next(&mut self) -> Option<Self::Item> {\\n        self.0.pop().ok()\\n    }\\n}\\n\\npub struct Iter<'a, T> {\\n    next: Option<&'a Node<T>>,\\n}\\n\\nimpl<'a, T> Iterator for Iter<'a, T> {\\n    type Item = &'a T;\\n    fn next(&mut self) -> Option<Self::Item> {\\n        self.next.map(|node| {\\n            // as_deref: Converts from Option<T> (or &Option<T>) to Option<&T::Target>.\\n            self.next = node.next.as_deref();\\n            &node.elem\\n        })\\n    }\\n}\\n\\npub struct IterMut<'a, T> {\\n    next: Option<&'a mut Node<T>>,\\n}\\n\\nimpl<'a, T> Iterator for IterMut<'a, T> {\\n    type Item = &'a mut T;\\n    fn next(&mut self) -> Option<Self::Item> {\\n        // we add take() here due to &mut self isn't Copy(& and Option<&> is Copy)\\n        self.next.take().map(|node| {\\n            self.next = node.next.as_deref_mut();\\n            &mut node.elem\\n        })\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test_stack {\\n\\n    use super::*;\\n\\n    #[test]\\n    fn basics() {\\n        let mut list = Stack::new();\\n        assert_eq!(list.pop(), Err(\\\"Stack is empty\\\"));\\n\\n        list.push(1);\\n        list.push(2);\\n        list.push(3);\\n\\n        assert_eq!(list.pop(), Ok(3));\\n        assert_eq!(list.pop(), Ok(2));\\n\\n        list.push(4);\\n        list.push(5);\\n\\n        assert_eq!(list.is_empty(), false);\\n\\n        assert_eq!(list.pop(), Ok(5));\\n        assert_eq!(list.pop(), Ok(4));\\n\\n        assert_eq!(list.pop(), Ok(1));\\n        assert_eq!(list.pop(), Err(\\\"Stack is empty\\\"));\\n\\n        assert_eq!(list.is_empty(), true);\\n    }\\n\\n    #[test]\\n    fn peek() {\\n        let mut list = Stack::new();\\n        assert_eq!(list.peek(), None);\\n        list.push(1);\\n        list.push(2);\\n        list.push(3);\\n\\n        assert_eq!(list.peek(), Some(&3));\\n        assert_eq!(list.peek_mut(), Some(&mut 3));\\n\\n        match list.peek_mut() {\\n            None => None,\\n            Some(value) => Some(*value = 42),\\n        };\\n\\n        assert_eq!(list.peek(), Some(&42));\\n        assert_eq!(list.pop(), Ok(42));\\n    }\\n\\n    #[test]\\n    fn into_iter() {\\n        let mut list = Stack::new();\\n        list.push(1);\\n        list.push(2);\\n        list.push(3);\\n\\n        let mut iter = list.into_iter_for_stack();\\n        assert_eq!(iter.next(), Some(3));\\n        assert_eq!(iter.next(), Some(2));\\n        assert_eq!(iter.next(), Some(1));\\n        assert_eq!(iter.next(), None);\\n    }\\n\\n    #[test]\\n    fn iter() {\\n        let mut list = Stack::new();\\n        list.push(1);\\n        list.push(2);\\n        list.push(3);\\n\\n        let mut iter = list.iter();\\n        assert_eq!(iter.next(), Some(&3));\\n        assert_eq!(iter.next(), Some(&2));\\n        assert_eq!(iter.next(), Some(&1));\\n    }\\n\\n    #[test]\\n    fn iter_mut() {\\n        let mut list = Stack::new();\\n        list.push(1);\\n        list.push(2);\\n        list.push(3);\\n\\n        let mut iter = list.iter_mut();\\n        assert_eq!(iter.next(), Some(&mut 3));\\n        assert_eq!(iter.next(), Some(&mut 2));\\n        assert_eq!(iter.next(), Some(&mut 1));\\n    }\\n}\\n\"",
    "trie": "\"use std::collections::HashMap;\\nuse std::hash::Hash;\\n\\n#[derive(Debug, Default)]\\nstruct Node<Key: Default, Type: Default> {\\n    children: HashMap<Key, Node<Key, Type>>,\\n    value: Option<Type>,\\n}\\n\\n#[derive(Debug, Default)]\\npub struct Trie<Key, Type>\\nwhere\\n    Key: Default + Eq + Hash,\\n    Type: Default,\\n{\\n    root: Node<Key, Type>,\\n}\\n\\nimpl<Key, Type> Trie<Key, Type>\\nwhere\\n    Key: Default + Eq + Hash,\\n    Type: Default,\\n{\\n    pub fn new() -> Self {\\n        Self {\\n            root: Node::default(),\\n        }\\n    }\\n\\n    pub fn insert(&mut self, key: impl IntoIterator<Item = Key>, value: Type)\\n    where\\n        Key: Eq + Hash,\\n    {\\n        let mut node = &mut self.root;\\n        for c in key.into_iter() {\\n            node = node.children.entry(c).or_insert_with(Node::default);\\n        }\\n        node.value = Some(value);\\n    }\\n\\n    pub fn get(&self, key: impl IntoIterator<Item = Key>) -> Option<&Type>\\n    where\\n        Key: Eq + Hash,\\n    {\\n        let mut node = &self.root;\\n        for c in key.into_iter() {\\n            if node.children.contains_key(&c) {\\n                node = node.children.get(&c).unwrap()\\n            } else {\\n                return None;\\n            }\\n        }\\n        node.value.as_ref()\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n\\n    use super::*;\\n\\n    #[test]\\n    fn test_insertion() {\\n        let mut trie = Trie::new();\\n        assert_eq!(trie.get(\\\"\\\".chars()), None);\\n\\n        trie.insert(\\\"foo\\\".chars(), 1);\\n        trie.insert(\\\"foobar\\\".chars(), 2);\\n\\n        let mut trie = Trie::new();\\n        assert_eq!(trie.get(vec![1, 2, 3]), None);\\n\\n        trie.insert(vec![1, 2, 3], 1);\\n        trie.insert(vec![3, 4, 5], 2);\\n    }\\n\\n    #[test]\\n    fn test_get() {\\n        let mut trie = Trie::new();\\n        trie.insert(\\\"foo\\\".chars(), 1);\\n        trie.insert(\\\"foobar\\\".chars(), 2);\\n        trie.insert(\\\"bar\\\".chars(), 3);\\n        trie.insert(\\\"baz\\\".chars(), 4);\\n\\n        assert_eq!(trie.get(\\\"foo\\\".chars()), Some(&1));\\n        assert_eq!(trie.get(\\\"food\\\".chars()), None);\\n\\n        let mut trie = Trie::new();\\n        trie.insert(vec![1, 2, 3, 4], 1);\\n        trie.insert(vec![42], 2);\\n        trie.insert(vec![42, 6, 1000], 3);\\n        trie.insert(vec![1, 2, 4, 16, 32], 4);\\n\\n        assert_eq!(trie.get(vec![42, 6, 1000]), Some(&3));\\n        assert_eq!(trie.get(vec![43, 44, 45]), None);\\n    }\\n}\\n\"",
    "coin change": "\"/// Coin change via Dynamic Programming\\n\\n/// coin_change(coins, amount) returns the fewest number of coins that need to make up that amount.\\n/// If that amount of money cannot be made up by any combination of the coins, return `None`.\\n///\\n/// Arguments:\\n///     * `coins` - coins of different denominations\\n///     * `amount` - a total amount of money be made up.\\n/// Complexity\\n///     - time complexity: O(amount * coins.length),\\n///     - space complexity: O(amount),\\npub fn coin_change(coins: &[usize], amount: usize) -> Option<usize> {\\n    let mut dp = vec![std::usize::MAX; amount + 1];\\n    dp[0] = 0;\\n\\n    // Assume dp[i] is the fewest number of coins making up amount i,\\n    // then for every coin in coins, dp[i] = min(dp[i - coin] + 1).\\n    for i in 0..=amount {\\n        for j in 0..coins.len() {\\n            if i >= coins[j] && dp[i - coins[j]] != std::usize::MAX {\\n                dp[i] = dp[i].min(dp[i - coins[j]] + 1);\\n            }\\n        }\\n    }\\n\\n    match dp[amount] {\\n        std::usize::MAX => None,\\n        _ => Some(dp[amount]),\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        // 11 = 5 * 2 + 1 * 1\\n        let coins = vec![1, 2, 5];\\n        assert_eq!(Some(3), coin_change(&coins, 11));\\n\\n        // 119 = 11 * 10 + 7 * 1 + 2 * 1\\n        let coins = vec![2, 3, 5, 7, 11];\\n        assert_eq!(Some(12), coin_change(&coins, 119));\\n    }\\n\\n    #[test]\\n    fn coins_empty() {\\n        let coins = vec![];\\n        assert_eq!(None, coin_change(&coins, 1));\\n    }\\n\\n    #[test]\\n    fn amount_zero() {\\n        let coins = vec![1, 2, 3];\\n        assert_eq!(Some(0), coin_change(&coins, 0));\\n    }\\n\\n    #[test]\\n    fn fail_change() {\\n        // 3 can't be change by 2.\\n        let coins = vec![2];\\n        assert_eq!(None, coin_change(&coins, 3));\\n        let coins = vec![10, 20, 50, 100];\\n        assert_eq!(None, coin_change(&coins, 5));\\n    }\\n}\\n\"",
    "edit distance": "\"//! Compute the edit distance between two strings\\n\\nuse std::cmp::min;\\n\\n/// edit_distance(str_a, str_b) returns the edit distance between the two\\n/// strings This edit distance is defined as being 1 point per insertion,\\n/// substitution, or deletion which must be made to make the strings equal.\\n///\\n/// This function iterates over the bytes in the string, so it may not behave\\n/// entirely as expected for non-ASCII strings.\\n///\\n/// # Complexity\\n///\\n/// - time complexity: O(nm),\\n/// - space complexity: O(nm),\\n///\\n/// where n and m are lengths of `str_a` and `str_b`\\npub fn edit_distance(str_a: &str, str_b: &str) -> u32 {\\n    // distances[i][j] = distance between a[..i] and b[..j]\\n    let mut distances = vec![vec![0; str_b.len() + 1]; str_a.len() + 1];\\n    // Initialize cases in which one string is empty\\n    for j in 0..=str_b.len() {\\n        distances[0][j] = j as u32;\\n    }\\n    for (i, item) in distances.iter_mut().enumerate() {\\n        item[0] = i as u32;\\n    }\\n    for i in 1..=str_a.len() {\\n        for j in 1..=str_b.len() {\\n            distances[i][j] = min(distances[i - 1][j] + 1, distances[i][j - 1] + 1);\\n            if str_a.as_bytes()[i - 1] == str_b.as_bytes()[j - 1] {\\n                distances[i][j] = min(distances[i][j], distances[i - 1][j - 1]);\\n            } else {\\n                distances[i][j] = min(distances[i][j], distances[i - 1][j - 1] + 1);\\n            }\\n        }\\n    }\\n    distances[str_a.len()][str_b.len()]\\n}\\n\\n/// The space efficient version of the above algorithm.\\n///\\n/// Instead of storing the `m * n` matrix expicitly, only one row (of length `n`) is stored.\\n/// It keeps overwriting itself based on its previous values with the help of two scalars,\\n/// gradually reaching the last row. Then, the score is `matrix[n]`.\\n///\\n/// # Complexity\\n///\\n/// - time complexity: O(nm),\\n/// - space complexity: O(n),\\n///\\n/// where n and m are lengths of `str_a` and `str_b`\\npub fn edit_distance_se(str_a: &str, str_b: &str) -> u32 {\\n    let (str_a, str_b) = (str_a.as_bytes(), str_b.as_bytes());\\n    let (m, n) = (str_a.len(), str_b.len());\\n    let mut distances: Vec<u32> = vec![0; n + 1]; // the dynamic programming matrix (only 1 row stored)\\n    let mut s: u32; // distances[i - 1][j - 1] or distances[i - 1][j]\\n    let mut c: u32; // distances[i][j - 1] or distances[i][j]\\n    let mut char_a: u8; // str_a[i - 1] the i-th character in str_a; only needs to be computed once per row\\n    let mut char_b: u8; // str_b[j - 1] the j-th character in str_b\\n\\n    // 0th row\\n    for (j, v) in distances.iter_mut().enumerate().take(n + 1).skip(1) {\\n        *v = j as u32;\\n    }\\n    // rows 1 to m\\n    for i in 1..=m {\\n        s = (i - 1) as u32;\\n        c = i as u32;\\n        char_a = str_a[i - 1];\\n        for j in 1..=n {\\n            // c is distances[i][j-1] and s is distances[i-1][j-1] at the beginning of each round of iteration\\n            char_b = str_b[j - 1];\\n            c = min(\\n                s + if char_a == char_b { 0 } else { 1 },\\n                min(c + 1, distances[j] + 1),\\n            );\\n            // c is updated to distances[i][j], and will thus become distances[i][j-1] for the next cell\\n            s = distances[j]; // here distances[j] means distances[i-1][j] becuase it has not been overwritten yet\\n                              // s is updated to distances[i-1][j], and will thus become distances[i-1][j-1] for the next cell\\n            distances[j] = c; // now distances[j] is updated to distances[i][j], and will thus become distances[i-1][j] for the next ROW\\n        }\\n    }\\n\\n    distances[n]\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn equal_strings() {\\n        assert_eq!(0, edit_distance(\\\"Hello, world!\\\", \\\"Hello, world!\\\"));\\n        assert_eq!(0, edit_distance_se(\\\"Hello, world!\\\", \\\"Hello, world!\\\"));\\n        assert_eq!(0, edit_distance(\\\"Test_Case_#1\\\", \\\"Test_Case_#1\\\"));\\n        assert_eq!(0, edit_distance_se(\\\"Test_Case_#1\\\", \\\"Test_Case_#1\\\"));\\n    }\\n\\n    #[test]\\n    fn one_edit_difference() {\\n        assert_eq!(1, edit_distance(\\\"Hello, world!\\\", \\\"Hell, world!\\\"));\\n        assert_eq!(1, edit_distance(\\\"Test_Case_#1\\\", \\\"Test_Case_#2\\\"));\\n        assert_eq!(1, edit_distance(\\\"Test_Case_#1\\\", \\\"Test_Case_#10\\\"));\\n        assert_eq!(1, edit_distance_se(\\\"Hello, world!\\\", \\\"Hell, world!\\\"));\\n        assert_eq!(1, edit_distance_se(\\\"Test_Case_#1\\\", \\\"Test_Case_#2\\\"));\\n        assert_eq!(1, edit_distance_se(\\\"Test_Case_#1\\\", \\\"Test_Case_#10\\\"));\\n    }\\n\\n    #[test]\\n    fn several_differences() {\\n        assert_eq!(2, edit_distance(\\\"My Cat\\\", \\\"My Case\\\"));\\n        assert_eq!(7, edit_distance(\\\"Hello, world!\\\", \\\"Goodbye, world!\\\"));\\n        assert_eq!(6, edit_distance(\\\"Test_Case_#3\\\", \\\"Case #3\\\"));\\n        assert_eq!(2, edit_distance_se(\\\"My Cat\\\", \\\"My Case\\\"));\\n        assert_eq!(7, edit_distance_se(\\\"Hello, world!\\\", \\\"Goodbye, world!\\\"));\\n        assert_eq!(6, edit_distance_se(\\\"Test_Case_#3\\\", \\\"Case #3\\\"));\\n    }\\n}\\n\"",
    "egg dropping": "\"/// # Egg Dropping Puzzle\\n\\n/// `egg_drop(eggs, floors)` returns the least number of egg droppings\\n///     required to determine the highest floor from which an egg will not\\n///     break upon dropping\\n///\\n/// Assumptions: n > 0\\npub fn egg_drop(eggs: u32, floors: u32) -> u32 {\\n    assert!(eggs > 0);\\n\\n    // Explicity handle edge cases (optional)\\n    if eggs == 1 || floors == 0 || floors == 1 {\\n        return floors;\\n    }\\n\\n    let eggs_index = eggs as usize;\\n    let floors_index = floors as usize;\\n\\n    // Store solutions to subproblems in 2D Vec,\\n    // where egg_drops[i][j] represents the solution to the egg dropping\\n    // problem with i eggs and j floors\\n    let mut egg_drops: Vec<Vec<u32>> = vec![vec![0; floors_index + 1]; eggs_index + 1];\\n\\n    // Assign solutions for egg_drop(n, 0) = 0, egg_drop(n, 1) = 1\\n    for egg_drop in egg_drops.iter_mut().skip(1) {\\n        egg_drop[0] = 0;\\n        egg_drop[1] = 1;\\n    }\\n\\n    // Assign solutions to egg_drop(1, k) = k\\n    for j in 1..=floors_index {\\n        egg_drops[1][j] = j as u32;\\n    }\\n\\n    // Complete solutions vector using optimal substructure property\\n    for i in 2..=eggs_index {\\n        for j in 2..=floors_index {\\n            egg_drops[i][j] = std::u32::MAX;\\n\\n            for k in 1..=j {\\n                let res = 1 + std::cmp::max(egg_drops[i - 1][k - 1], egg_drops[i][j - k]);\\n\\n                if res < egg_drops[i][j] {\\n                    egg_drops[i][j] = res;\\n                }\\n            }\\n        }\\n    }\\n\\n    egg_drops[eggs_index][floors_index]\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::egg_drop;\\n\\n    #[test]\\n    fn zero_floors() {\\n        assert_eq!(egg_drop(5, 0), 0);\\n    }\\n\\n    #[test]\\n    fn one_egg() {\\n        assert_eq!(egg_drop(1, 8), 8);\\n    }\\n\\n    #[test]\\n    fn eggs2_floors2() {\\n        assert_eq!(egg_drop(2, 2), 2);\\n    }\\n\\n    #[test]\\n    fn eggs3_floors5() {\\n        assert_eq!(egg_drop(3, 5), 3);\\n    }\\n\\n    #[test]\\n    fn eggs2_floors10() {\\n        assert_eq!(egg_drop(2, 10), 4);\\n    }\\n\\n    #[test]\\n    fn eggs2_floors36() {\\n        assert_eq!(egg_drop(2, 36), 8);\\n    }\\n\\n    #[test]\\n    fn large_floors() {\\n        assert_eq!(egg_drop(2, 100), 14);\\n    }\\n}\\n\"",
    "fibonacci": "\"/// Fibonacci via Dynamic Programming\\n\\n/// fibonacci(n) returns the nth fibonacci number\\n/// This function uses the definition of Fibonacci where:\\n/// F(0) = F(1) = 1 and F(n+1) = F(n) + F(n-1) for n>0\\n///\\n/// Warning: This will overflow the 128-bit unsigned integer at n=186\\npub fn fibonacci(n: u32) -> u128 {\\n    // Use a and b to store the previous two values in the sequence\\n    let mut a = 0;\\n    let mut b = 1;\\n    for _i in 0..n {\\n        // As we iterate through, move b's value into a and the new computed\\n        // value into b.\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n    }\\n    b\\n}\\n\\n/// fibonacci(n) returns the nth fibonacci number\\n/// This function uses the definition of Fibonacci where:\\n/// F(0) = F(1) = 1 and F(n+1) = F(n) + F(n-1) for n>0\\n///\\n/// Warning: This will overflow the 128-bit unsigned integer at n=186\\npub fn recursive_fibonacci(n: u32) -> u128 {\\n    // Call the actual tail recursive implementation, with the extra\\n    // arguments set up.\\n    _recursive_fibonacci(n, 0, 1)\\n}\\n\\nfn _recursive_fibonacci(n: u32, previous: u128, current: u128) -> u128 {\\n    if n == 0 {\\n        current\\n    } else {\\n        _recursive_fibonacci(n - 1, current, current + previous)\\n    }\\n}\\n\\n/// classical_fibonacci(n) returns the nth fibonacci number\\n/// This function uses the definition of Fibonacci where:\\n/// F(0) = 0, F(1) = 1 and F(n+1) = F(n) + F(n-1) for n>0\\n///\\n/// Warning: This will overflow the 128-bit unsigned integer at n=186\\npub fn classical_fibonacci(n: u32) -> u128 {\\n    match n {\\n        0 => 0,\\n        1 => 1,\\n        _ => {\\n            let k = n / 2;\\n            let f1 = classical_fibonacci(k);\\n            let f2 = classical_fibonacci(k - 1);\\n\\n            match n % 4 {\\n                0 | 2 => f1 * (f1 + 2 * f2),\\n                1 => (2 * f1 + f2) * (2 * f1 - f2) + 2,\\n                _ => (2 * f1 + f2) * (2 * f1 - f2) - 2,\\n            }\\n        }\\n    }\\n}\\n\\n/// logarithmic_fibonacci(n) returns the nth fibonacci number\\n/// This function uses the definition of Fibonacci where:\\n/// F(0) = 0, F(1) = 1 and F(n+1) = F(n) + F(n-1) for n>0\\n///\\n/// Warning: This will overflow the 128-bit unsigned integer at n=186\\npub fn logarithmic_fibonacci(n: u32) -> u128 {\\n    // if it is the max value before overflow, use n-1 then get the second\\n    // value in the tuple\\n    if n == 186 {\\n        let (_, second) = _logarithmic_fibonacci(185);\\n        second\\n    } else {\\n        let (first, _) = _logarithmic_fibonacci(n);\\n        first\\n    }\\n}\\n\\nfn _logarithmic_fibonacci(n: u32) -> (u128, u128) {\\n    match n {\\n        0 => (0, 1),\\n        _ => {\\n            let (current, next) = _logarithmic_fibonacci(n / 2);\\n            let c = current * (next * 2 - current);\\n            let d = current * current + next * next;\\n\\n            match n % 2 {\\n                0 => (c, d),\\n                _ => (d, c + d),\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::classical_fibonacci;\\n    use super::fibonacci;\\n    use super::logarithmic_fibonacci;\\n    use super::recursive_fibonacci;\\n\\n    #[test]\\n    fn test_fibonacci() {\\n        assert_eq!(fibonacci(0), 1);\\n        assert_eq!(fibonacci(1), 1);\\n        assert_eq!(fibonacci(2), 2);\\n        assert_eq!(fibonacci(3), 3);\\n        assert_eq!(fibonacci(4), 5);\\n        assert_eq!(fibonacci(5), 8);\\n        assert_eq!(fibonacci(10), 89);\\n        assert_eq!(fibonacci(20), 10946);\\n        assert_eq!(fibonacci(100), 573147844013817084101);\\n        assert_eq!(fibonacci(184), 205697230343233228174223751303346572685);\\n    }\\n\\n    #[test]\\n    fn test_recursive_fibonacci() {\\n        assert_eq!(recursive_fibonacci(0), 1);\\n        assert_eq!(recursive_fibonacci(1), 1);\\n        assert_eq!(recursive_fibonacci(2), 2);\\n        assert_eq!(recursive_fibonacci(3), 3);\\n        assert_eq!(recursive_fibonacci(4), 5);\\n        assert_eq!(recursive_fibonacci(5), 8);\\n        assert_eq!(recursive_fibonacci(10), 89);\\n        assert_eq!(recursive_fibonacci(20), 10946);\\n        assert_eq!(recursive_fibonacci(100), 573147844013817084101);\\n        assert_eq!(\\n            recursive_fibonacci(184),\\n            205697230343233228174223751303346572685\\n        );\\n    }\\n\\n    #[test]\\n    fn test_classical_fibonacci() {\\n        assert_eq!(classical_fibonacci(0), 0);\\n        assert_eq!(classical_fibonacci(1), 1);\\n        assert_eq!(classical_fibonacci(2), 1);\\n        assert_eq!(classical_fibonacci(3), 2);\\n        assert_eq!(classical_fibonacci(4), 3);\\n        assert_eq!(classical_fibonacci(5), 5);\\n        assert_eq!(classical_fibonacci(10), 55);\\n        assert_eq!(classical_fibonacci(20), 6765);\\n        assert_eq!(classical_fibonacci(21), 10946);\\n        assert_eq!(classical_fibonacci(100), 354224848179261915075);\\n        assert_eq!(\\n            classical_fibonacci(184),\\n            127127879743834334146972278486287885163\\n        );\\n    }\\n\\n    #[test]\\n    fn test_logarithmic_fibonacci() {\\n        assert_eq!(logarithmic_fibonacci(0), 0);\\n        assert_eq!(logarithmic_fibonacci(1), 1);\\n        assert_eq!(logarithmic_fibonacci(2), 1);\\n        assert_eq!(logarithmic_fibonacci(3), 2);\\n        assert_eq!(logarithmic_fibonacci(4), 3);\\n        assert_eq!(logarithmic_fibonacci(5), 5);\\n        assert_eq!(logarithmic_fibonacci(10), 55);\\n        assert_eq!(logarithmic_fibonacci(20), 6765);\\n        assert_eq!(logarithmic_fibonacci(21), 10946);\\n        assert_eq!(logarithmic_fibonacci(100), 354224848179261915075);\\n        assert_eq!(\\n            logarithmic_fibonacci(184),\\n            127127879743834334146972278486287885163\\n        );\\n    }\\n\\n    #[test]\\n    /// Check that the itterative and recursive fibonacci\\n    /// produce the same value. Both are combinatorial ( F(0) = F(1) = 1 )\\n    fn test_iterative_and_recursive_equivalence() {\\n        assert_eq!(fibonacci(0), recursive_fibonacci(0));\\n        assert_eq!(fibonacci(1), recursive_fibonacci(1));\\n        assert_eq!(fibonacci(2), recursive_fibonacci(2));\\n        assert_eq!(fibonacci(3), recursive_fibonacci(3));\\n        assert_eq!(fibonacci(4), recursive_fibonacci(4));\\n        assert_eq!(fibonacci(5), recursive_fibonacci(5));\\n        assert_eq!(fibonacci(10), recursive_fibonacci(10));\\n        assert_eq!(fibonacci(20), recursive_fibonacci(20));\\n        assert_eq!(fibonacci(100), recursive_fibonacci(100));\\n        assert_eq!(fibonacci(184), recursive_fibonacci(184));\\n    }\\n\\n    #[test]\\n    /// Check that classical and combinatorial fibonacci produce the\\n    /// same value when 'n' differs by 1.\\n    /// classical fibonacci: ( F(0) = 0, F(1) = 1 )\\n    /// combinatorial fibonacci: ( F(0) = F(1) = 1 )\\n    fn test_classical_and_combinatorial_are_off_by_one() {\\n        assert_eq!(classical_fibonacci(1), fibonacci(0));\\n        assert_eq!(classical_fibonacci(2), fibonacci(1));\\n        assert_eq!(classical_fibonacci(3), fibonacci(2));\\n        assert_eq!(classical_fibonacci(4), fibonacci(3));\\n        assert_eq!(classical_fibonacci(5), fibonacci(4));\\n        assert_eq!(classical_fibonacci(6), fibonacci(5));\\n        assert_eq!(classical_fibonacci(11), fibonacci(10));\\n        assert_eq!(classical_fibonacci(20), fibonacci(19));\\n        assert_eq!(classical_fibonacci(21), fibonacci(20));\\n        assert_eq!(classical_fibonacci(101), fibonacci(100));\\n        assert_eq!(classical_fibonacci(185), fibonacci(184));\\n    }\\n}\\n\"",
    "is subsequence": "\"// Given two strings str1 and str2, return true if str1 is a subsequence of str2, or false otherwise.\\n// A subsequence of a string is a new string that is formed from the original string\\n// by deleting some (can be none) of the characters without disturbing the relative\\n// positions of the remaining characters.\\n// (i.e., \\\"ace\\\" is a subsequence of \\\"abcde\\\" while \\\"aec\\\" is not).\\npub fn is_subsequence(str1: String, str2: String) -> bool {\\n    let mut it1 = 0;\\n    let mut it2 = 0;\\n\\n    let byte1 = str1.as_bytes();\\n    let byte2 = str2.as_bytes();\\n\\n    while it1 < str1.len() && it2 < str2.len() {\\n        if byte1[it1] == byte2[it2] {\\n            it1 += 1;\\n        }\\n\\n        it2 += 1;\\n    }\\n\\n    it1 == str1.len()\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test() {\\n        assert_eq!(\\n            is_subsequence(String::from(\\\"abc\\\"), String::from(\\\"ahbgdc\\\")),\\n            true\\n        );\\n        assert_eq!(\\n            is_subsequence(String::from(\\\"axc\\\"), String::from(\\\"ahbgdc\\\")),\\n            false\\n        );\\n    }\\n}\\n\"",
    "knapsack": "\"//! Solves the knapsack problem\\nuse std::cmp::max;\\n\\n/// knapsack_table(w, weights, values) returns the knapsack table (`n`, `m`) with maximum values, where `n` is number of items\\n///\\n/// Arguments:\\n///     * `w` - knapsack capacity\\n///     * `weights` - set of weights for each item\\n///     * `values` - set of values for each item\\nfn knapsack_table(w: &usize, weights: &[usize], values: &[usize]) -> Vec<Vec<usize>> {\\n    // Initialize `n` - number of items\\n    let n: usize = weights.len();\\n    // Initialize `m`\\n    // m[i, w] - the maximum value that can be attained with weight less that or equal to `w` using items up to `i`\\n    let mut m: Vec<Vec<usize>> = vec![vec![0; w + 1]; n + 1];\\n\\n    for i in 0..=n {\\n        for j in 0..=*w {\\n            // m[i, j] compiled according to the following rule:\\n            if i == 0 || j == 0 {\\n                m[i][j] = 0;\\n            } else if weights[i - 1] <= j {\\n                // If `i` is in the knapsack\\n                // Then m[i, j] is equal to the maximum value of the knapsack,\\n                // where the weight `j` is reduced by the weight of the `i-th` item and the set of admissible items plus the value `k`\\n                m[i][j] = max(values[i - 1] + m[i - 1][j - weights[i - 1]], m[i - 1][j]);\\n            } else {\\n                // If the item `i` did not get into the knapsack\\n                // Then m[i, j] is equal to the maximum cost of a knapsack with the same capacity and a set of admissible items\\n                m[i][j] = m[i - 1][j]\\n            }\\n        }\\n    }\\n    m\\n}\\n\\n/// knapsack_items(weights, m, i, j) returns the indices of the items of the optimal knapsack (from 1 to `n`)\\n///\\n/// Arguments:\\n///     * `weights` - set of weights for each item\\n///     * `m` - knapsack table with maximum values\\n///     * `i` - include items 1 through `i` in knapsack (for the initial value, use `n`)\\n///     * `j` - maximum weight of the knapsack\\nfn knapsack_items(weights: &[usize], m: &[Vec<usize>], i: usize, j: usize) -> Vec<usize> {\\n    if i == 0 {\\n        return vec![];\\n    }\\n    if m[i][j] > m[i - 1][j] {\\n        let mut knap: Vec<usize> = knapsack_items(weights, m, i - 1, j - weights[i - 1]);\\n        knap.push(i);\\n        knap\\n    } else {\\n        knapsack_items(weights, m, i - 1, j)\\n    }\\n}\\n\\n/// knapsack(w, weights, values) returns the tuple where first value is `optimal profit`,\\n/// second value is `knapsack optimal weight` and the last value is `indices of items`, that we got (from 1 to `n`)\\n///\\n/// Arguments:\\n///     * `w` - knapsack capacity\\n///     * `weights` - set of weights for each item\\n///     * `values` - set of values for each item\\n///\\n/// Complexity\\n///     - time complexity: O(nw),\\n///     - space complexity: O(nw),\\n///\\n/// where `n` and `w` are `number of items` and `knapsack capacity`\\npub fn knapsack(w: usize, weights: Vec<usize>, values: Vec<usize>) -> (usize, usize, Vec<usize>) {\\n    // Checks if the number of items in the list of weights is the same as the number of items in the list of values\\n    assert_eq!(weights.len(), values.len(), \\\"Number of items in the list of weights doesn't match the number of items in the list of values!\\\");\\n    // Initialize `n` - number of items\\n    let n: usize = weights.len();\\n    // Find the knapsack table\\n    let m: Vec<Vec<usize>> = knapsack_table(&w, &weights, &values);\\n    // Find the indices of the items\\n    let items: Vec<usize> = knapsack_items(&weights, &m, n, w);\\n    // Find the total weight of optimal knapsack\\n    let mut total_weight: usize = 0;\\n    for i in items.iter() {\\n        total_weight += weights[i - 1];\\n    }\\n    // Return result\\n    (m[n][w], total_weight, items)\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    // Took test datasets from https://people.sc.fsu.edu/~jburkardt/datasets/bin_packing/bin_packing.html\\n    use super::*;\\n\\n    #[test]\\n    fn test_p02() {\\n        assert_eq!(\\n            (51, 26, vec![2, 3, 4]),\\n            knapsack(26, vec![12, 7, 11, 8, 9], vec![24, 13, 23, 15, 16])\\n        );\\n    }\\n\\n    #[test]\\n    fn test_p04() {\\n        assert_eq!(\\n            (150, 190, vec![1, 2, 5]),\\n            knapsack(\\n                190,\\n                vec![56, 59, 80, 64, 75, 17],\\n                vec![50, 50, 64, 46, 50, 5]\\n            )\\n        );\\n    }\\n\\n    #[test]\\n    fn test_p01() {\\n        assert_eq!(\\n            (309, 165, vec![1, 2, 3, 4, 6]),\\n            knapsack(\\n                165,\\n                vec![23, 31, 29, 44, 53, 38, 63, 85, 89, 82],\\n                vec![92, 57, 49, 68, 60, 43, 67, 84, 87, 72]\\n            )\\n        );\\n    }\\n\\n    #[test]\\n    fn test_p06() {\\n        assert_eq!(\\n            (1735, 169, vec![2, 4, 7]),\\n            knapsack(\\n                170,\\n                vec![41, 50, 49, 59, 55, 57, 60],\\n                vec![442, 525, 511, 593, 546, 564, 617]\\n            )\\n        );\\n    }\\n\\n    #[test]\\n    fn test_p07() {\\n        assert_eq!(\\n            (1458, 749, vec![1, 3, 5, 7, 8, 9, 14, 15]),\\n            knapsack(\\n                750,\\n                vec![70, 73, 77, 80, 82, 87, 90, 94, 98, 106, 110, 113, 115, 118, 120],\\n                vec![135, 139, 149, 150, 156, 163, 173, 184, 192, 201, 210, 214, 221, 229, 240]\\n            )\\n        );\\n    }\\n}\\n\"",
    "longest common subsequence": "\"/// Longest common subsequence via Dynamic Programming\\n\\n/// longest_common_subsequence(a, b) returns the longest common subsequence\\n/// between the strings a and b.\\npub fn longest_common_subsequence(a: &str, b: &str) -> String {\\n    let a: Vec<_> = a.chars().collect();\\n    let b: Vec<_> = b.chars().collect();\\n    let (na, nb) = (a.len(), b.len());\\n\\n    // solutions[i][j] is the length of the longest common subsequence\\n    // between a[0..i-1] and b[0..j-1]\\n    let mut solutions = vec![vec![0; nb + 1]; na + 1];\\n\\n    for (i, ci) in a.iter().enumerate() {\\n        for (j, cj) in b.iter().enumerate() {\\n            // if ci == cj, there is a new common character;\\n            // otherwise, take the best of the two solutions\\n            // at (i-1,j) and (i,j-1)\\n            solutions[i + 1][j + 1] = if ci == cj {\\n                solutions[i][j] + 1\\n            } else {\\n                solutions[i][j + 1].max(solutions[i + 1][j])\\n            }\\n        }\\n    }\\n\\n    // reconstitute the solution string from the lengths\\n    let mut result: Vec<char> = Vec::new();\\n    let (mut i, mut j) = (na, nb);\\n    while i > 0 && j > 0 {\\n        if a[i - 1] == b[j - 1] {\\n            result.push(a[i - 1]);\\n            i -= 1;\\n            j -= 1;\\n        } else if solutions[i - 1][j] > solutions[i][j - 1] {\\n            i -= 1;\\n        } else {\\n            j -= 1;\\n        }\\n    }\\n\\n    result.reverse();\\n    result.iter().collect()\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::longest_common_subsequence;\\n\\n    #[test]\\n    fn test_longest_common_subsequence() {\\n        // empty case\\n        assert_eq!(&longest_common_subsequence(\\\"\\\", \\\"\\\"), \\\"\\\");\\n        assert_eq!(&longest_common_subsequence(\\\"\\\", \\\"abcd\\\"), \\\"\\\");\\n        assert_eq!(&longest_common_subsequence(\\\"abcd\\\", \\\"\\\"), \\\"\\\");\\n\\n        // simple cases\\n        assert_eq!(&longest_common_subsequence(\\\"abcd\\\", \\\"c\\\"), \\\"c\\\");\\n        assert_eq!(&longest_common_subsequence(\\\"abcd\\\", \\\"d\\\"), \\\"d\\\");\\n        assert_eq!(&longest_common_subsequence(\\\"abcd\\\", \\\"e\\\"), \\\"\\\");\\n        assert_eq!(&longest_common_subsequence(\\\"abcdefghi\\\", \\\"acegi\\\"), \\\"acegi\\\");\\n\\n        // less simple cases\\n        assert_eq!(&longest_common_subsequence(\\\"abcdgh\\\", \\\"aedfhr\\\"), \\\"adh\\\");\\n        assert_eq!(&longest_common_subsequence(\\\"aggtab\\\", \\\"gxtxayb\\\"), \\\"gtab\\\");\\n\\n        // unicode\\n        assert_eq!(\\n            &longest_common_subsequence(\\\"你好，世界\\\", \\\"再见世界\\\"),\\n            \\\"世界\\\"\\n        );\\n    }\\n}\\n\"",
    "longest continuous increasing subsequence": "\"pub fn longest_continuous_increasing_subsequence<T: Ord>(input_array: &[T]) -> &[T] {\\n    let length: usize = input_array.len();\\n\\n    //Handle the base cases\\n    if length <= 1 {\\n        return input_array;\\n    }\\n\\n    //Create the array to store the longest subsequence at each location\\n    let mut tracking_vec = vec![1; length];\\n\\n    //Iterate through the input and store longest subsequences at each location in the vector\\n    for i in (0..length - 1).rev() {\\n        if input_array[i] < input_array[i + 1] {\\n            tracking_vec[i] = tracking_vec[i + 1] + 1;\\n        }\\n    }\\n\\n    //Find the longest subsequence\\n    let mut max_index: usize = 0;\\n    let mut max_value: i32 = 0;\\n    for (index, value) in tracking_vec.iter().enumerate() {\\n        if value > &max_value {\\n            max_value = *value;\\n            max_index = index;\\n        }\\n    }\\n\\n    &input_array[max_index..max_index + max_value as usize]\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::longest_continuous_increasing_subsequence;\\n\\n    #[test]\\n    fn test_longest_increasing_subsequence() {\\n        //Base Cases\\n        let base_case_array: [i32; 0] = [];\\n        assert_eq!(\\n            &longest_continuous_increasing_subsequence(&base_case_array),\\n            &[]\\n        );\\n        assert_eq!(&longest_continuous_increasing_subsequence(&[1]), &[1]);\\n\\n        //Normal i32 Cases\\n        assert_eq!(\\n            &longest_continuous_increasing_subsequence(&[1, 2, 3, 4]),\\n            &[1, 2, 3, 4]\\n        );\\n        assert_eq!(\\n            &longest_continuous_increasing_subsequence(&[1, 2, 2, 3, 4, 2]),\\n            &[2, 3, 4]\\n        );\\n        assert_eq!(\\n            &longest_continuous_increasing_subsequence(&[5, 4, 3, 2, 1]),\\n            &[5]\\n        );\\n        assert_eq!(\\n            &longest_continuous_increasing_subsequence(&[5, 4, 3, 4, 2, 1]),\\n            &[3, 4]\\n        );\\n\\n        //Non-Numeric case\\n        assert_eq!(\\n            &longest_continuous_increasing_subsequence(&['a', 'b', 'c']),\\n            &['a', 'b', 'c']\\n        );\\n        assert_eq!(\\n            &longest_continuous_increasing_subsequence(&['d', 'c', 'd']),\\n            &['c', 'd']\\n        );\\n    }\\n}\\n\"",
    "longest increasing subsequence": "\"/// Finds the longest increasing subsequence and returns it.\\n///\\n/// If multiple subsequences with the longest possible subsequence length can be found, the\\n/// subsequence which appeared first will be returned (see `test_example_1`).\\n///\\n/// Inspired by [this LeetCode problem](https://leetcode.com/problems/longest-increasing-subsequence/).\\npub fn longest_increasing_subsequence<T: Ord + Clone>(input_array: Vec<T>) -> Vec<T> {\\n    let n = input_array.len();\\n    if n <= 1 {\\n        return input_array;\\n    }\\n\\n    // Find longest increasing subsequence\\n    let mut dp = vec![(1, None); n];\\n    let mut pair = 0;\\n\\n    for i in 0..n {\\n        for j in 0..i {\\n            if input_array[j] < input_array[i] && dp[j].0 + 1 > dp[i].0 {\\n                dp[i] = (dp[j].0 + 1, Some(j));\\n\\n                if dp[i].0 > dp[pair].0 {\\n                    pair = i;\\n                }\\n            }\\n        }\\n    }\\n\\n    // Construct subsequence\\n    let mut out: Vec<T> = Vec::with_capacity(dp[pair].0);\\n\\n    out.push(input_array[pair].clone());\\n    while let Some(next) = dp[pair].1 {\\n        pair = next;\\n        out.push(input_array[pair].clone());\\n    }\\n\\n    out.into_iter().rev().collect()\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::longest_increasing_subsequence;\\n\\n    #[test]\\n    /// Need to specify generic type T in order to function\\n    fn test_empty_vec() {\\n        assert_eq!(longest_increasing_subsequence::<i32>(vec![]), vec![]);\\n    }\\n\\n    #[test]\\n    fn test_example_1() {\\n        assert_eq!(\\n            longest_increasing_subsequence(vec![10, 9, 2, 5, 3, 7, 101, 18]),\\n            vec![2, 5, 7, 101]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_example_2() {\\n        assert_eq!(\\n            longest_increasing_subsequence(vec![0, 1, 0, 3, 2, 3]),\\n            vec![0, 1, 2, 3]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_example_3() {\\n        assert_eq!(\\n            longest_increasing_subsequence(vec![7, 7, 7, 7, 7, 7, 7]),\\n            vec![7]\\n        );\\n    }\\n\\n    #[test]\\n    #[ignore]\\n    fn test_tle() {\\n        assert_eq!(\\n            longest_increasing_subsequence(vec![\\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\\n                24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,\\n                45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\\n                66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,\\n                87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105,\\n                106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,\\n                122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,\\n                138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\\n                154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169,\\n                170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185,\\n                186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201,\\n                202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217,\\n                218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233,\\n                234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249,\\n                250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265,\\n                266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281,\\n                282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,\\n                298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313,\\n                314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329,\\n                330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345,\\n                346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361,\\n                362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377,\\n                378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393,\\n                394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409,\\n                410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425,\\n                426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441,\\n                442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457,\\n                458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473,\\n                474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489,\\n                490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505,\\n                506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521,\\n                522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537,\\n                538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553,\\n                554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569,\\n                570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585,\\n                586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601,\\n                602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617,\\n                618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633,\\n                634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649,\\n                650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665,\\n                666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681,\\n                682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697,\\n                698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713,\\n                714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729,\\n                730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745,\\n                746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761,\\n                762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777,\\n                778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793,\\n                794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809,\\n                810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825,\\n                826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841,\\n                842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857,\\n                858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873,\\n                874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889,\\n                890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905,\\n                906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921,\\n                922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937,\\n                938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953,\\n                954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969,\\n                970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985,\\n                986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001,\\n                1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015,\\n                1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029,\\n                1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043,\\n                1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057,\\n                1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071,\\n                1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085,\\n                1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099,\\n                1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113,\\n                1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127,\\n                1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141,\\n                1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155,\\n                1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169,\\n                1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183,\\n                1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197,\\n                1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211,\\n                1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225,\\n                1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239,\\n                1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253,\\n                1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267,\\n                1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281,\\n                1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295,\\n                1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309,\\n                1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323,\\n                1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337,\\n                1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351,\\n                1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365,\\n                1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379,\\n                1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393,\\n                1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407,\\n                1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421,\\n                1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435,\\n                1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449,\\n                1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463,\\n                1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477,\\n                1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491,\\n                1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505,\\n                1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519,\\n                1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533,\\n                1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547,\\n                1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561,\\n                1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575,\\n                1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589,\\n                1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603,\\n                1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617,\\n                1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631,\\n                1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645,\\n                1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659,\\n                1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673,\\n                1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687,\\n                1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701,\\n                1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715,\\n                1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729,\\n                1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743,\\n                1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757,\\n                1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771,\\n                1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785,\\n                1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799,\\n                1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813,\\n                1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827,\\n                1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841,\\n                1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855,\\n                1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869,\\n                1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883,\\n                1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897,\\n                1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911,\\n                1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925,\\n                1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939,\\n                1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953,\\n                1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967,\\n                1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981,\\n                1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,\\n                1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\\n                2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023,\\n                2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037,\\n                2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051,\\n                2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065,\\n                2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079,\\n                2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093,\\n                2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107,\\n                2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121,\\n                2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135,\\n                2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149,\\n                2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163,\\n                2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177,\\n                2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191,\\n                2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205,\\n                2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219,\\n                2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233,\\n                2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247,\\n                2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261,\\n                2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275,\\n                2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289,\\n                2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303,\\n                2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317,\\n                2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331,\\n                2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345,\\n                2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359,\\n                2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373,\\n                2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387,\\n                2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401,\\n                2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415,\\n                2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429,\\n                2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443,\\n                2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457,\\n                2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471,\\n                2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485,\\n                2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499,\\n                2500\\n            ]),\\n            vec![\\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\\n                24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,\\n                45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\\n                66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,\\n                87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105,\\n                106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,\\n                122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,\\n                138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\\n                154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169,\\n                170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185,\\n                186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201,\\n                202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217,\\n                218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233,\\n                234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249,\\n                250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265,\\n                266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281,\\n                282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,\\n                298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313,\\n                314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329,\\n                330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345,\\n                346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361,\\n                362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377,\\n                378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393,\\n                394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409,\\n                410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425,\\n                426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441,\\n                442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457,\\n                458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473,\\n                474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489,\\n                490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505,\\n                506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521,\\n                522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537,\\n                538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553,\\n                554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569,\\n                570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585,\\n                586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601,\\n                602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617,\\n                618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633,\\n                634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649,\\n                650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665,\\n                666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681,\\n                682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697,\\n                698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713,\\n                714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729,\\n                730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745,\\n                746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761,\\n                762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777,\\n                778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793,\\n                794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809,\\n                810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825,\\n                826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841,\\n                842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857,\\n                858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873,\\n                874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889,\\n                890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905,\\n                906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921,\\n                922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937,\\n                938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953,\\n                954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969,\\n                970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985,\\n                986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001,\\n                1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015,\\n                1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029,\\n                1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043,\\n                1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057,\\n                1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071,\\n                1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085,\\n                1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099,\\n                1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113,\\n                1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127,\\n                1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141,\\n                1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155,\\n                1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169,\\n                1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183,\\n                1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197,\\n                1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211,\\n                1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225,\\n                1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239,\\n                1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253,\\n                1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267,\\n                1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281,\\n                1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295,\\n                1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309,\\n                1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323,\\n                1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337,\\n                1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351,\\n                1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365,\\n                1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379,\\n                1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393,\\n                1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407,\\n                1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421,\\n                1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435,\\n                1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449,\\n                1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463,\\n                1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477,\\n                1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491,\\n                1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505,\\n                1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519,\\n                1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533,\\n                1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547,\\n                1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561,\\n                1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575,\\n                1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589,\\n                1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603,\\n                1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617,\\n                1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631,\\n                1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645,\\n                1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659,\\n                1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673,\\n                1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687,\\n                1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701,\\n                1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715,\\n                1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729,\\n                1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743,\\n                1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757,\\n                1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771,\\n                1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785,\\n                1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799,\\n                1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813,\\n                1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827,\\n                1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841,\\n                1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855,\\n                1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869,\\n                1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883,\\n                1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897,\\n                1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911,\\n                1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925,\\n                1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939,\\n                1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953,\\n                1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967,\\n                1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981,\\n                1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,\\n                1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\\n                2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023,\\n                2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037,\\n                2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051,\\n                2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065,\\n                2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079,\\n                2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093,\\n                2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107,\\n                2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121,\\n                2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135,\\n                2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149,\\n                2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163,\\n                2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177,\\n                2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191,\\n                2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205,\\n                2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219,\\n                2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233,\\n                2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247,\\n                2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261,\\n                2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275,\\n                2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289,\\n                2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303,\\n                2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317,\\n                2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331,\\n                2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345,\\n                2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359,\\n                2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373,\\n                2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387,\\n                2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401,\\n                2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415,\\n                2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429,\\n                2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443,\\n                2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457,\\n                2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471,\\n                2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485,\\n                2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499,\\n                2500\\n            ]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_negative_elements() {\\n        assert_eq!(longest_increasing_subsequence(vec![-2, -1]), vec![-2, -1]);\\n    }\\n}\\n\"",
    "maximal square": "\"use std::cmp::max;\\nuse std::cmp::min;\\n\\n/// Maximal Square\\n/// Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\\n/// https://leetcode.com/problems/maximal-square/\\n///\\n/// Arguments:\\n///     * `matrix` - an array of integer array\\n/// Complexity\\n///     - time complexity: O(n^2),\\n///     - space complexity: O(n),\\npub fn maximal_square(matrix: &mut Vec<Vec<i32>>) -> i32 {\\n    if matrix.is_empty() {\\n        return 0;\\n    }\\n\\n    let rows = matrix.len();\\n    let cols = matrix[0].len();\\n    let mut result: i32 = 0;\\n\\n    for row in 0..rows {\\n        for col in 0..cols {\\n            if matrix[row][col] == 1 {\\n                if row == 0 || col == 0 {\\n                    result = max(result, 1);\\n                } else {\\n                    let temp = min(matrix[row - 1][col - 1], matrix[row - 1][col]);\\n\\n                    let count: i32 = min(temp, matrix[row][col - 1]) + 1;\\n                    result = max(result, count);\\n\\n                    matrix[row][col] = count;\\n                }\\n            }\\n        }\\n    }\\n\\n    result * result\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test() {\\n        assert_eq!(maximal_square(&mut vec![]), 0);\\n\\n        let mut matrix = vec![vec![0, 1], vec![1, 0]];\\n        assert_eq!(maximal_square(&mut matrix), 1);\\n\\n        let mut matrix = vec![\\n            vec![1, 0, 1, 0, 0],\\n            vec![1, 0, 1, 1, 1],\\n            vec![1, 1, 1, 1, 1],\\n            vec![1, 0, 0, 1, 0],\\n        ];\\n        assert_eq!(maximal_square(&mut matrix), 4);\\n\\n        let mut matrix = vec![vec![0]];\\n        assert_eq!(maximal_square(&mut matrix), 0);\\n    }\\n}\\n\"",
    "maximum subarray": "\"/// ## maximum subarray via Dynamic Programming\\n\\n/// maximum_subarray(array) find the subarray (containing at least one number) which has the largest sum\\n/// and return its sum.\\n///\\n/// A subarray is a contiguous part of an array.\\n///\\n/// Arguments:\\n///     * `array` - an integer array\\n/// Complexity\\n///     - time complexity: O(array.length),\\n///     - space complexity: O(array.length),\\npub fn maximum_subarray(array: &[i32]) -> i32 {\\n    let mut dp = vec![0; array.len()];\\n    dp[0] = array[0];\\n    let mut result = dp[0];\\n\\n    for i in 1..array.len() {\\n        if dp[i - 1] > 0 {\\n            dp[i] = dp[i - 1] + array[i];\\n        } else {\\n            dp[i] = array[i];\\n        }\\n        result = result.max(dp[i]);\\n    }\\n\\n    result\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn non_negative() {\\n        //the maximum value: 1 + 0 + 5 + 8 = 14\\n        let array = vec![1, 0, 5, 8];\\n        assert_eq!(maximum_subarray(&array), 14);\\n    }\\n\\n    #[test]\\n    fn negative() {\\n        //the maximum value: -1\\n        let array = vec![-3, -1, -8, -2];\\n        assert_eq!(maximum_subarray(&array), -1);\\n    }\\n\\n    #[test]\\n    fn normal() {\\n        //the maximum value: 3 + (-2) + 5 = 6\\n        let array = vec![-4, 3, -2, 5, -8];\\n        assert_eq!(maximum_subarray(&array), 6);\\n    }\\n\\n    #[test]\\n    fn single_element() {\\n        let array = vec![6];\\n        assert_eq!(maximum_subarray(&array), 6);\\n        let array = vec![-6];\\n        assert_eq!(maximum_subarray(&array), -6);\\n    }\\n}\\n\"",
    "rod cutting": "\"//! Solves the rod-cutting problem\\nuse std::cmp::max;\\n\\n/// `rod_cut(p)` returns the maximum possible profit if a rod of length `n` = `p.len()`\\n/// is cut into up to `n` pieces, where the profit gained from each piece of length\\n/// `l` is determined by `p[l - 1]` and the total profit is the sum of the profit\\n/// gained from each piece.\\n///\\n/// # Arguments\\n///    - `p` - profit for rods of length 1 to n inclusive\\n///\\n/// # Complexity\\n///    - time complexity: O(n^2),\\n///    - space complexity: O(n^2),\\n///\\n/// where n is the length of `p`.\\npub fn rod_cut(p: &[usize]) -> usize {\\n    let n = p.len();\\n    // f is the dynamic programming table\\n    let mut f = vec![0; n];\\n\\n    for i in 0..n {\\n        let mut max_price = p[i];\\n        for j in 1..=i {\\n            max_price = max(max_price, p[j - 1] + f[i - j]);\\n        }\\n        f[i] = max_price;\\n    }\\n\\n    // accomodate for input with length zero\\n    if n != 0 {\\n        f[n - 1]\\n    } else {\\n        0\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::rod_cut;\\n\\n    #[test]\\n    fn test_rod_cut() {\\n        assert_eq!(0, rod_cut(&[]));\\n        assert_eq!(15, rod_cut(&[5, 8, 2]));\\n        assert_eq!(10, rod_cut(&[1, 5, 8, 9]));\\n        assert_eq!(25, rod_cut(&[5, 8, 2, 1, 7]));\\n        assert_eq!(87, rod_cut(&[0, 0, 0, 0, 0, 87]));\\n        assert_eq!(49, rod_cut(&[7, 6, 5, 4, 3, 2, 1]));\\n        assert_eq!(22, rod_cut(&[1, 5, 8, 9, 10, 17, 17, 20]));\\n        assert_eq!(60, rod_cut(&[6, 4, 8, 2, 5, 8, 2, 3, 7, 11]));\\n        assert_eq!(30, rod_cut(&[1, 5, 8, 9, 10, 17, 17, 20, 24, 30]));\\n        assert_eq!(12, rod_cut(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]));\\n    }\\n}\\n\"",
    "convex hull": "\"use std::cmp::Ordering::Equal;\\n\\nfn sort_by_min_angle(pts: &[(f64, f64)], min: &(f64, f64)) -> Vec<(f64, f64)> {\\n    let mut points: Vec<(f64, f64, (f64, f64))> = pts\\n        .iter()\\n        .map(|x| {\\n            (\\n                ((x.1 - min.1) as f64).atan2((x.0 - min.0) as f64),\\n                // angle\\n                ((x.1 - min.1) as f64).hypot((x.0 - min.0) as f64),\\n                // distance (we want the closest to be first)\\n                *x,\\n            )\\n        })\\n        .collect();\\n    points.sort_by(|a, b| a.partial_cmp(b).unwrap_or(Equal));\\n    points.into_iter().map(|x| x.2).collect()\\n}\\n\\n// calculates the z coordinate of the vector product of vectors ab and ac\\nfn calc_z_coord_vector_product(a: &(f64, f64), b: &(f64, f64), c: &(f64, f64)) -> f64 {\\n    (b.0 - a.0) * (c.1 - a.1) - (c.0 - a.0) * (b.1 - a.1)\\n}\\n\\n/*\\n    If three points are aligned and are part of the convex hull then the three are kept.\\n    If one doesn't want to keep those points, it is easy to iterate the answer and remove them.\\n\\n    The first point is the one with the lowest y-coordinate and the lowest x-coordinate.\\n    Points are then given counter-clockwise, and the closest one is given first if needed.\\n*/\\npub fn convex_hull_graham(pts: &[(f64, f64)]) -> Vec<(f64, f64)> {\\n    if pts.is_empty() {\\n        return vec![];\\n    }\\n\\n    let mut stack: Vec<(f64, f64)> = vec![];\\n    let min = pts\\n        .iter()\\n        .min_by(|a, b| {\\n            let ord = a.1.partial_cmp(&b.1).unwrap_or(Equal);\\n            match ord {\\n                Equal => a.0.partial_cmp(&b.0).unwrap_or(Equal),\\n                o => o,\\n            }\\n        })\\n        .unwrap();\\n    let points = sort_by_min_angle(pts, min);\\n\\n    if points.len() <= 3 {\\n        return points;\\n    }\\n\\n    for point in points {\\n        while stack.len() > 1\\n            && calc_z_coord_vector_product(&stack[stack.len() - 2], &stack[stack.len() - 1], &point)\\n                < 0.\\n        {\\n            stack.pop();\\n        }\\n        stack.push(point);\\n    }\\n\\n    stack\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn empty() {\\n        assert_eq!(convex_hull_graham(&vec![]), vec![]);\\n    }\\n\\n    #[test]\\n    fn not_enough_points() {\\n        let list = vec![(0f64, 0f64)];\\n        assert_eq!(convex_hull_graham(&list), list);\\n    }\\n\\n    #[test]\\n    fn not_enough_points1() {\\n        let list = vec![(2f64, 2f64), (1f64, 1f64), (0f64, 0f64)];\\n        let ans = vec![(0f64, 0f64), (1f64, 1f64), (2f64, 2f64)];\\n        assert_eq!(convex_hull_graham(&list), ans);\\n    }\\n\\n    #[test]\\n    fn not_enough_points2() {\\n        let list = vec![(2f64, 2f64), (1f64, 2f64), (0f64, 0f64)];\\n        let ans = vec![(0f64, 0f64), (2f64, 2f64), (1f64, 2f64)];\\n        assert_eq!(convex_hull_graham(&list), ans);\\n    }\\n\\n    #[test]\\n    // from https://codegolf.stackexchange.com/questions/11035/find-the-convex-hull-of-a-set-of-2d-points\\n    fn lots_of_points() {\\n        let list = vec![\\n            (4.4, 14.),\\n            (6.7, 15.25),\\n            (6.9, 12.8),\\n            (2.1, 11.1),\\n            (9.5, 14.9),\\n            (13.2, 11.9),\\n            (10.3, 12.3),\\n            (6.8, 9.5),\\n            (3.3, 7.7),\\n            (0.6, 5.1),\\n            (5.3, 2.4),\\n            (8.45, 4.7),\\n            (11.5, 9.6),\\n            (13.8, 7.3),\\n            (12.9, 3.1),\\n            (11., 1.1),\\n        ];\\n        let ans = vec![\\n            (11., 1.1),\\n            (12.9, 3.1),\\n            (13.8, 7.3),\\n            (13.2, 11.9),\\n            (9.5, 14.9),\\n            (6.7, 15.25),\\n            (4.4, 14.),\\n            (2.1, 11.1),\\n            (0.6, 5.1),\\n            (5.3, 2.4),\\n        ];\\n\\n        assert_eq!(convex_hull_graham(&list), ans);\\n    }\\n\\n    #[test]\\n    // from https://codegolf.stackexchange.com/questions/11035/find-the-convex-hull-of-a-set-of-2d-points\\n    fn lots_of_points2() {\\n        let list = vec![\\n            (1., 0.),\\n            (1., 1.),\\n            (1., -1.),\\n            (0.68957, 0.283647),\\n            (0.909487, 0.644276),\\n            (0.0361877, 0.803816),\\n            (0.583004, 0.91555),\\n            (-0.748169, 0.210483),\\n            (-0.553528, -0.967036),\\n            (0.316709, -0.153861),\\n            (-0.79267, 0.585945),\\n            (-0.700164, -0.750994),\\n            (0.452273, -0.604434),\\n            (-0.79134, -0.249902),\\n            (-0.594918, -0.397574),\\n            (-0.547371, -0.434041),\\n            (0.958132, -0.499614),\\n            (0.039941, 0.0990732),\\n            (-0.891471, -0.464943),\\n            (0.513187, -0.457062),\\n            (-0.930053, 0.60341),\\n            (0.656995, 0.854205),\\n        ];\\n        let ans = vec![\\n            (1., -1.),\\n            (1., 0.),\\n            (1., 1.),\\n            (0.583004, 0.91555),\\n            (0.0361877, 0.803816),\\n            (-0.930053, 0.60341),\\n            (-0.891471, -0.464943),\\n            (-0.700164, -0.750994),\\n            (-0.553528, -0.967036),\\n        ];\\n\\n        assert_eq!(convex_hull_graham(&list), ans);\\n    }\\n}\\n\"",
    "hanoi": "\"pub fn hanoi(n: i32, from: i32, to: i32, via: i32, moves: &mut Vec<(i32, i32)>) {\\n    if n > 0 {\\n        hanoi(n - 1, from, via, to, moves);\\n        moves.push((from, to));\\n        hanoi(n - 1, via, to, from, moves);\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn hanoi_simple() {\\n        let correct_solution: Vec<(i32, i32)> =\\n            vec![(1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3)];\\n        let mut our_solution: Vec<(i32, i32)> = Vec::new();\\n        hanoi(3, 1, 3, 2, &mut our_solution);\\n        assert_eq!(correct_solution, our_solution);\\n    }\\n}\\n\"",
    "kmeans": "\"// Macro to implement kmeans for both f64 and f32 without writing everything\\n// twice or importing the `num` crate\\nmacro_rules! impl_kmeans {\\n    ($kind: ty, $modname: ident) => {\\n        // Since we can't overload methods in rust, we have to use namespacing\\n        pub mod $modname {\\n            use std::$modname::INFINITY;\\n\\n            /// computes sum of squared deviation between two identically sized vectors\\n            /// `x`, and `y`.\\n            fn distance(x: &[$kind], y: &[$kind]) -> $kind {\\n                x.iter()\\n                    .zip(y.iter())\\n                    .fold(0.0, |dist, (&xi, &yi)| dist + (xi - yi).powi(2))\\n            }\\n\\n            /// Returns a vector containing the indices z<sub>i</sub> in {0, ..., K-1} of\\n            /// the centroid nearest to each datum.\\n            fn nearest_centroids(xs: &[Vec<$kind>], centroids: &[Vec<$kind>]) -> Vec<usize> {\\n                xs.iter()\\n                    .map(|xi| {\\n                        // Find the argmin by folding using a tuple containing the argmin\\n                        // and the minimum distance.\\n                        let (argmin, _) = centroids.iter().enumerate().fold(\\n                            (0_usize, INFINITY),\\n                            |(min_ix, min_dist), (ix, ci)| {\\n                                let dist = distance(xi, ci);\\n                                if dist < min_dist {\\n                                    (ix, dist)\\n                                } else {\\n                                    (min_ix, min_dist)\\n                                }\\n                            },\\n                        );\\n                        argmin\\n                    })\\n                    .collect()\\n            }\\n\\n            /// Recompute the centroids given the current clustering\\n            fn recompute_centroids(\\n                xs: &[Vec<$kind>],\\n                clustering: &[usize],\\n                k: usize,\\n            ) -> Vec<Vec<$kind>> {\\n                let ndims = xs[0].len();\\n\\n                // NOTE: Kind of inefficient because we sweep all the data from each of the\\n                // k centroids.\\n                (0..k)\\n                    .map(|cluster_ix| {\\n                        let mut centroid: Vec<$kind> = vec![0.0; ndims];\\n                        let mut n_cluster: $kind = 0.0;\\n                        xs.iter().zip(clustering.iter()).for_each(|(xi, &zi)| {\\n                            if zi == cluster_ix {\\n                                n_cluster += 1.0;\\n                                xi.iter().enumerate().for_each(|(j, &x_ij)| {\\n                                    centroid[j] += x_ij;\\n                                });\\n                            }\\n                        });\\n                        centroid.iter().map(|&c_j| c_j / n_cluster).collect()\\n                    })\\n                    .collect()\\n            }\\n\\n            /// Assign the N D-dimensional data, `xs`, to `k` clusters using K-Means clustering\\n            pub fn kmeans(xs: Vec<Vec<$kind>>, k: usize) -> Vec<usize> {\\n                assert!(xs.len() >= k);\\n\\n                // Rather than pulling in a dependency to radomly select the staring\\n                // points for the centroids, we're going to deterministally choose them by\\n                // slecting evenly spaced points in `xs`\\n                let n_per_cluster: usize = xs.len() / k;\\n                let centroids: Vec<Vec<$kind>> =\\n                    (0..k).map(|j| xs[j * n_per_cluster].clone()).collect();\\n\\n                let mut clustering = nearest_centroids(&xs, &centroids);\\n\\n                loop {\\n                    let centroids = recompute_centroids(&xs, &clustering, k);\\n                    let new_clustering = nearest_centroids(&xs, &centroids);\\n\\n                    // loop until the clustering doesn't change after the new centroids are computed\\n                    if new_clustering\\n                        .iter()\\n                        .zip(clustering.iter())\\n                        .all(|(&za, &zb)| za == zb)\\n                    {\\n                        // We need to use `return` to break out of the `loop`\\n                        return clustering;\\n                    } else {\\n                        clustering = new_clustering;\\n                    }\\n                }\\n            }\\n        }\\n    };\\n}\\n\\n// generate code for kmeans for f32 and f64 data\\nimpl_kmeans!(f64, f64);\\nimpl_kmeans!(f32, f32);\\n\\n#[cfg(test)]\\nmod test {\\n    use self::super::f64::kmeans;\\n\\n    #[test]\\n    fn easy_univariate_clustering() {\\n        let xs: Vec<Vec<f64>> = vec![\\n            vec![-1.1],\\n            vec![-1.2],\\n            vec![-1.3],\\n            vec![-1.4],\\n            vec![1.1],\\n            vec![1.2],\\n            vec![1.3],\\n            vec![1.4],\\n        ];\\n        let clustering = kmeans(xs, 2);\\n        assert_eq!(clustering, vec![0, 0, 0, 0, 1, 1, 1, 1]);\\n    }\\n\\n    #[test]\\n    fn easy_univariate_clustering_odd_number_of_data() {\\n        let xs: Vec<Vec<f64>> = vec![\\n            vec![-1.1],\\n            vec![-1.2],\\n            vec![-1.3],\\n            vec![-1.4],\\n            vec![1.1],\\n            vec![1.2],\\n            vec![1.3],\\n            vec![1.4],\\n            vec![1.5],\\n        ];\\n        let clustering = kmeans(xs, 2);\\n        assert_eq!(clustering, vec![0, 0, 0, 0, 1, 1, 1, 1, 1]);\\n    }\\n\\n    #[test]\\n    fn easy_bivariate_clustering() {\\n        let xs: Vec<Vec<f64>> = vec![\\n            vec![-1.1, 0.2],\\n            vec![-1.2, 0.3],\\n            vec![-1.3, 0.1],\\n            vec![-1.4, 0.4],\\n            vec![1.1, -1.1],\\n            vec![1.2, -1.0],\\n            vec![1.3, -1.2],\\n            vec![1.4, -1.3],\\n        ];\\n        let clustering = kmeans(xs, 2);\\n        assert_eq!(clustering, vec![0, 0, 0, 0, 1, 1, 1, 1]);\\n    }\\n\\n    #[test]\\n    fn high_dims() {\\n        let xs: Vec<Vec<f64>> = vec![\\n            vec![-2.7825343, -1.7604825, -5.5550113, -2.9752946, -2.7874138],\\n            vec![-2.9847919, -3.8209332, -2.1531757, -2.2710119, -2.3582877],\\n            vec![-3.0109320, -2.2366132, -2.8048492, -1.2632331, -4.5755581],\\n            vec![-2.8432186, -1.0383805, -2.2022826, -2.7435962, -2.0013399],\\n            vec![-2.6638082, -3.5520086, -1.3684702, -2.1562444, -1.3186447],\\n            vec![1.7409171, 1.9687576, 4.7162628, 4.5743537, 3.7905611],\\n            vec![3.2932369, 2.8508700, 2.5580937, 2.0437325, 4.2192562],\\n            vec![2.5843321, 2.8329818, 2.1329531, 3.2562319, 2.4878733],\\n            vec![2.1859638, 3.2880048, 3.7018615, 2.3641232, 1.6281994],\\n            vec![2.6201773, 0.9006588, 2.6774097, 1.8188620, 1.6076493],\\n        ];\\n\\n        let clustering = kmeans(xs, 2);\\n        assert_eq!(clustering, vec![0, 0, 0, 0, 0, 1, 1, 1, 1, 1]);\\n    }\\n}\\n\"",
    "nqueens": "\"#[allow(unused_imports)]\\nuse std::env::args;\\n\\n#[allow(dead_code)]\\nfn main() {\\n    let mut board_width = 0;\\n\\n    for arg in args() {\\n        board_width = match arg.parse() {\\n            Ok(x) => x,\\n            _ => 0,\\n        };\\n\\n        if board_width != 0 {\\n            break;\\n        }\\n    }\\n\\n    if board_width < 4 {\\n        println!(\\n            \\\"Running algorithm with 8 as a default. Specify an alternative Chess board size for \\\\\\n             N-Queens as a command line argument.\\\\n\\\"\\n        );\\n        board_width = 8;\\n    }\\n\\n    let board = match nqueens(board_width) {\\n        Ok(success) => success,\\n        Err(err) => panic!(\\\"{}\\\", err),\\n    };\\n\\n    println!(\\\"N-Queens {} by {} board result:\\\", board_width, board_width);\\n    print_board(&board);\\n}\\n\\n/*\\nThe n-Queens search is a backtracking algorithm. Each row of the Chess board where a Queen is\\nplaced is dependent on all earlier rows. As only one Queen can fit per row, a one-dimensional\\ninteger array is used to represent the Queen's offset on each row.\\n*/\\npub fn nqueens(board_width: i64) -> Result<Vec<i64>, &'static str> {\\n    let mut board_rows = vec![0; board_width as usize];\\n    let mut conflict;\\n    let mut current_row = 0;\\n\\n    //Process by row up to the current active row\\n    loop {\\n        conflict = false;\\n\\n        //Column review of previous rows\\n        for review_index in 0..current_row {\\n            //Calculate the diagonals of earlier rows where a Queen would be a conflict\\n            let left = board_rows[review_index] - (current_row as i64 - review_index as i64);\\n            let right = board_rows[review_index] + (current_row as i64 - review_index as i64);\\n\\n            if board_rows[current_row] == board_rows[review_index]\\n                || (left >= 0 && left == board_rows[current_row])\\n                || (right < board_width as i64 && right == board_rows[current_row])\\n            {\\n                conflict = true;\\n                break;\\n            }\\n        }\\n\\n        match conflict {\\n            true => {\\n                board_rows[current_row] += 1;\\n\\n                if current_row == 0 && board_rows[current_row] == board_width {\\n                    return Err(\\\"No solution exists for specificed board size.\\\");\\n                }\\n\\n                while board_rows[current_row] == board_width {\\n                    board_rows[current_row] = 0;\\n\\n                    if current_row == 0 {\\n                        return Err(\\\"No solution exists for specificed board size.\\\");\\n                    }\\n\\n                    current_row -= 1;\\n                    board_rows[current_row] += 1;\\n                }\\n            }\\n            _ => {\\n                current_row += 1;\\n\\n                if current_row as i64 == board_width {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    Ok(board_rows)\\n}\\n\\nfn print_board(board: &[i64]) {\\n    for row in 0..board.len() {\\n        print!(\\\"{}\\\\t\\\", board[row as usize]);\\n\\n        for column in 0..board.len() as i64 {\\n            if board[row as usize] == column {\\n                print!(\\\"Q\\\");\\n            } else {\\n                print!(\\\".\\\");\\n            }\\n        }\\n        println!();\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    fn check_board(board: &Vec<i64>) -> bool {\\n        for current_row in 0..board.len() {\\n            //Column review\\n            for review_index in 0..current_row {\\n                //Look for any conflict.\\n                let left = board[review_index] - (current_row as i64 - review_index as i64);\\n                let right = board[review_index] + (current_row as i64 - review_index as i64);\\n\\n                if board[current_row] == board[review_index]\\n                    || (left >= 0 && left == board[current_row])\\n                    || (right < board.len() as i64 && right == board[current_row])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        true\\n    }\\n\\n    #[test]\\n    fn test_board_size_4() {\\n        let board = nqueens(4).expect(\\\"Error propagated.\\\");\\n        assert_eq!(board, vec![1, 3, 0, 2]);\\n        assert!(check_board(&board));\\n    }\\n\\n    #[test]\\n    fn test_board_size_7() {\\n        let board = nqueens(7).expect(\\\"Error propagated.\\\");\\n        assert_eq!(board, vec![0, 2, 4, 6, 1, 3, 5]);\\n        assert!(check_board(&board));\\n    }\\n}\\n\"",
    "two sum": "\"use std::collections::HashMap;\\nuse std::convert::TryInto;\\n\\n// Given an array of integers nums and an integer target,\\n// return indices of the two numbers such that they add up to target.\\n\\npub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n    let mut hash_map: HashMap<i32, i32> = HashMap::new();\\n\\n    for (i, item) in nums.iter().enumerate() {\\n        match hash_map.get(&(target - item)) {\\n            Some(value) => {\\n                return vec![i.try_into().unwrap(), *value];\\n            }\\n            None => {\\n                hash_map.insert(*item, i.try_into().unwrap());\\n            }\\n        }\\n    }\\n\\n    vec![]\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test() {\\n        let nums = vec![2, 7, 11, 15];\\n        assert_eq!(two_sum(nums, 9), vec![1, 0]);\\n\\n        let nums = vec![3, 2, 4];\\n        assert_eq!(two_sum(nums, 6), vec![2, 1]);\\n\\n        let nums = vec![3, 3];\\n        assert_eq!(two_sum(nums, 6), vec![1, 0]);\\n    }\\n}\\n\"",
    "closest points": "\"type Point = (f64, f64);\\nuse std::cmp::Ordering;\\n\\nfn point_cmp((a1, a2): &Point, (b1, b2): &Point) -> Ordering {\\n    let acmp = f64_cmp(a1, b1);\\n    match acmp {\\n        Ordering::Equal => f64_cmp(a2, b2),\\n        _ => acmp,\\n    }\\n}\\n\\nfn f64_cmp(a: &f64, b: &f64) -> Ordering {\\n    a.partial_cmp(b).unwrap()\\n}\\n\\n/// returns the two closest points\\n/// or None if there are zero or one point\\npub fn closest_points(points: &[Point]) -> Option<(Point, Point)> {\\n    let mut points: Vec<Point> = points.to_vec();\\n    points.sort_by(point_cmp);\\n\\n    closest_points_aux(&points, 0, points.len())\\n}\\n\\nfn dist((x1, y1): &Point, (x2, y2): &Point) -> f64 {\\n    let dx = *x1 - *x2;\\n    let dy = *y1 - *y2;\\n\\n    (dx * dx + dy * dy).sqrt()\\n}\\n\\nfn closest_points_aux(\\n    points: &[Point],\\n    mut start: usize,\\n    mut end: usize,\\n) -> Option<(Point, Point)> {\\n    let n = end - start;\\n\\n    if n <= 1 {\\n        return None;\\n    }\\n\\n    if n <= 3 {\\n        // bruteforce\\n        let mut min = dist(&points[0], &points[1]);\\n        let mut pair = (points[0], points[1]);\\n\\n        for i in 0..n {\\n            for j in (i + 1)..n {\\n                let new = dist(&points[i], &points[j]);\\n                if new < min {\\n                    min = new;\\n                    pair = (points[i], points[j]);\\n                }\\n            }\\n        }\\n        return Some(pair);\\n    }\\n\\n    let mid = (start + end) / 2;\\n    let left = closest_points_aux(points, start, mid);\\n    let right = closest_points_aux(points, mid, end);\\n\\n    let (mut min_dist, mut pair) = match (left, right) {\\n        (Some((l1, l2)), Some((r1, r2))) => {\\n            let dl = dist(&l1, &l2);\\n            let dr = dist(&r1, &r2);\\n            if dl < dr {\\n                (dl, (l1, l2))\\n            } else {\\n                (dr, (r1, r2))\\n            }\\n        }\\n        (Some((a, b)), None) => (dist(&a, &b), (a, b)),\\n        (None, Some((a, b))) => (dist(&a, &b), (a, b)),\\n        (None, None) => unreachable!(),\\n    };\\n\\n    let mid_x = points[mid].0;\\n    while points[start].0 < mid_x - min_dist {\\n        start += 1;\\n    }\\n    while points[end - 1].0 > mid_x + min_dist {\\n        end -= 1;\\n    }\\n\\n    let mut mids: Vec<&Point> = points[start..end].iter().collect();\\n    mids.sort_by(|a, b| f64_cmp(&a.1, &b.1));\\n\\n    for (i, e) in mids.iter().enumerate() {\\n        for k in 1..8 {\\n            if i + k >= mids.len() {\\n                break;\\n            }\\n\\n            let new = dist(e, mids[i + k]);\\n            if new < min_dist {\\n                min_dist = new;\\n                pair = (**e, *mids[i + k]);\\n            }\\n        }\\n    }\\n\\n    Some(pair)\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::closest_points;\\n    use super::Point;\\n\\n    fn eq(p1: Option<(Point, Point)>, p2: Option<(Point, Point)>) -> bool {\\n        match (p1, p2) {\\n            (None, None) => true,\\n            (Some((p1, p2)), Some((p3, p4))) => (p1 == p3 && p2 == p4) || (p1 == p4 && p2 == p3),\\n            _ => false,\\n        }\\n    }\\n\\n    macro_rules! assert_display {\\n        ($left: expr, $right: expr) => {\\n            assert!(\\n                eq($left, $right),\\n                \\\"assertion failed: `(left == right)`\\\\nleft: `{:?}`,\\\\nright: `{:?}`\\\",\\n                $left,\\n                $right\\n            )\\n        };\\n    }\\n\\n    #[test]\\n    fn zero_points() {\\n        let vals: [Point; 0] = [];\\n        assert_display!(closest_points(&vals), None::<(Point, Point)>);\\n    }\\n\\n    #[test]\\n    fn one_points() {\\n        let vals = [(0., 0.)];\\n        assert_display!(closest_points(&vals), None::<(Point, Point)>);\\n    }\\n\\n    #[test]\\n    fn two_points() {\\n        let vals = [(0., 0.), (1., 1.)];\\n        assert_display!(closest_points(&vals), Some(((0., 0.), (1., 1.))));\\n    }\\n\\n    #[test]\\n    fn three_points() {\\n        let vals = [(0., 0.), (1., 1.), (3., 3.)];\\n        assert_display!(closest_points(&vals), Some(((0., 0.), (1., 1.))));\\n    }\\n\\n    #[test]\\n    fn list_1() {\\n        let vals = [\\n            (0., 0.),\\n            (2., 1.),\\n            (5., 2.),\\n            (2., 3.),\\n            (4., 0.),\\n            (0., 4.),\\n            (5., 6.),\\n            (4., 4.),\\n            (7., 3.),\\n            (-1., 2.),\\n            (2., 6.),\\n        ];\\n        assert_display!(closest_points(&vals), Some(((2., 1.), (2., 3.))));\\n    }\\n\\n    #[test]\\n    fn list_2() {\\n        let vals = [\\n            (1., 3.),\\n            (4., 6.),\\n            (8., 8.),\\n            (7., 5.),\\n            (5., 3.),\\n            (10., 3.),\\n            (7., 1.),\\n            (8., 3.),\\n            (4., 9.),\\n            (4., 12.),\\n            (4., 15.),\\n            (7., 14.),\\n            (8., 12.),\\n            (6., 10.),\\n            (4., 14.),\\n            (2., 7.),\\n            (3., 8.),\\n            (5., 8.),\\n            (6., 7.),\\n            (8., 10.),\\n            (6., 12.),\\n        ];\\n        assert_display!(closest_points(&vals), Some(((4., 14.), (4., 15.))));\\n    }\\n\\n    #[test]\\n    fn vertical_points() {\\n        let vals = [\\n            (0., 0.),\\n            (0., 50.),\\n            (0., -25.),\\n            (0., 40.),\\n            (0., 42.),\\n            (0., 100.),\\n            (0., 17.),\\n            (0., 29.),\\n            (0., -50.),\\n            (0., 37.),\\n            (0., 34.),\\n            (0., 8.),\\n            (0., 3.),\\n            (0., 46.),\\n        ];\\n        assert_display!(closest_points(&vals), Some(((0., 40.), (0., 42.))));\\n    }\\n}\\n\"",
    "bellman ford": "\"use std::collections::BTreeMap;\\nuse std::ops::Add;\\n\\nuse std::ops::Neg;\\n\\ntype Graph<V, E> = BTreeMap<V, BTreeMap<V, E>>;\\n\\n// performs the Bellman-Ford algorithm on the given graph from the given start\\n// the graph is an undirected graph\\n//\\n// if there is a negative weighted loop it returns None\\n// else it returns a map that for each reachable vertex associates the distance and the predecessor\\n// since the start has no predecessor but is reachable, map[start] will be None\\npub fn bellman_ford<\\n    V: Ord + Copy,\\n    E: Ord + Copy + Add<Output = E> + Neg<Output = E> + std::ops::Sub<Output = E>,\\n>(\\n    graph: &Graph<V, E>,\\n    start: &V,\\n) -> Option<BTreeMap<V, Option<(V, E)>>> {\\n    let mut ans: BTreeMap<V, Option<(V, E)>> = BTreeMap::new();\\n\\n    ans.insert(*start, None);\\n\\n    for _ in 1..(graph.len()) {\\n        for (u, edges) in graph {\\n            let dist_u = match ans.get(u) {\\n                Some(Some((_, d))) => Some(*d),\\n                Some(None) => None,\\n                None => continue,\\n            };\\n\\n            for (v, d) in edges {\\n                match ans.get(v) {\\n                    Some(Some((_, dist)))\\n                        // if this is a longer path, do nothing\\n                        if match dist_u {\\n                            Some(dist_u) => dist_u + *d >= *dist,\\n                            None => d >= dist,\\n                        } => {}\\n                    Some(None) => {\\n                        match dist_u {\\n                            // if dist_u + d < 0 there is a negative loop going by start\\n                            // else it's just a longer path\\n                            Some(dist_u) if dist_u >= -*d => {}\\n                            // negative self edge or negative loop\\n                            _ => {\\n                                if *d > *d + *d {\\n                                    return None;\\n                                }\\n                            }\\n                        };\\n                    }\\n                    // it's a shorter path: either dist_v was infinite or it was longer than dist_u + d\\n                    _ => {\\n                        ans.insert(\\n                            *v,\\n                            Some((\\n                                *u,\\n                                match dist_u {\\n                                    Some(dist) => dist + *d,\\n                                    None => *d,\\n                                },\\n                            )),\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    for (u, edges) in graph {\\n        for (v, d) in edges {\\n            match (ans.get(u), ans.get(v)) {\\n                (Some(None), Some(None)) if *d > *d + *d => return None,\\n                (Some(None), Some(Some((_, dv)))) if d < dv => return None,\\n                (Some(Some((_, du))), Some(None)) if *du < -*d => return None,\\n                (Some(Some((_, du))), Some(Some((_, dv)))) if *du + *d < *dv => return None,\\n                (_, _) => {}\\n            }\\n        }\\n    }\\n\\n    Some(ans)\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::{bellman_ford, Graph};\\n    use std::collections::BTreeMap;\\n\\n    fn add_edge<V: Ord + Copy, E: Ord>(graph: &mut Graph<V, E>, v1: V, v2: V, c: E) {\\n        graph.entry(v1).or_insert_with(BTreeMap::new).insert(v2, c);\\n        graph.entry(v2).or_insert_with(BTreeMap::new);\\n    }\\n\\n    #[test]\\n    fn single_vertex() {\\n        let mut graph: Graph<isize, isize> = BTreeMap::new();\\n        graph.insert(0, BTreeMap::new());\\n\\n        let mut dists = BTreeMap::new();\\n        dists.insert(0, None);\\n\\n        assert_eq!(bellman_ford(&graph, &0), Some(dists));\\n    }\\n\\n    #[test]\\n    fn single_edge() {\\n        let mut graph = BTreeMap::new();\\n        add_edge(&mut graph, 0, 1, 2);\\n\\n        let mut dists_0 = BTreeMap::new();\\n        dists_0.insert(0, None);\\n        dists_0.insert(1, Some((0, 2)));\\n\\n        assert_eq!(bellman_ford(&graph, &0), Some(dists_0));\\n\\n        let mut dists_1 = BTreeMap::new();\\n        dists_1.insert(1, None);\\n\\n        assert_eq!(bellman_ford(&graph, &1), Some(dists_1));\\n    }\\n\\n    #[test]\\n    fn tree_1() {\\n        let mut graph = BTreeMap::new();\\n        let mut dists = BTreeMap::new();\\n        dists.insert(1, None);\\n        for i in 1..100 {\\n            add_edge(&mut graph, i, i * 2, i * 2);\\n            add_edge(&mut graph, i, i * 2 + 1, i * 2 + 1);\\n\\n            match dists[&i] {\\n                Some((_, d)) => {\\n                    dists.insert(i * 2, Some((i, d + i * 2)));\\n                    dists.insert(i * 2 + 1, Some((i, d + i * 2 + 1)));\\n                }\\n                None => {\\n                    dists.insert(i * 2, Some((i, i * 2)));\\n                    dists.insert(i * 2 + 1, Some((i, i * 2 + 1)));\\n                }\\n            }\\n        }\\n\\n        assert_eq!(bellman_ford(&graph, &1), Some(dists));\\n    }\\n\\n    #[test]\\n    fn graph_1() {\\n        let mut graph = BTreeMap::new();\\n        add_edge(&mut graph, 'a', 'c', 12);\\n        add_edge(&mut graph, 'a', 'd', 60);\\n        add_edge(&mut graph, 'b', 'a', 10);\\n        add_edge(&mut graph, 'c', 'b', 20);\\n        add_edge(&mut graph, 'c', 'd', 32);\\n        add_edge(&mut graph, 'e', 'a', 7);\\n\\n        let mut dists_a = BTreeMap::new();\\n        dists_a.insert('a', None);\\n        dists_a.insert('c', Some(('a', 12)));\\n        dists_a.insert('d', Some(('c', 44)));\\n        dists_a.insert('b', Some(('c', 32)));\\n        assert_eq!(bellman_ford(&graph, &'a'), Some(dists_a));\\n\\n        let mut dists_b = BTreeMap::new();\\n        dists_b.insert('b', None);\\n        dists_b.insert('a', Some(('b', 10)));\\n        dists_b.insert('c', Some(('a', 22)));\\n        dists_b.insert('d', Some(('c', 54)));\\n        assert_eq!(bellman_ford(&graph, &'b'), Some(dists_b));\\n\\n        let mut dists_c = BTreeMap::new();\\n        dists_c.insert('c', None);\\n        dists_c.insert('b', Some(('c', 20)));\\n        dists_c.insert('d', Some(('c', 32)));\\n        dists_c.insert('a', Some(('b', 30)));\\n        assert_eq!(bellman_ford(&graph, &'c'), Some(dists_c));\\n\\n        let mut dists_d = BTreeMap::new();\\n        dists_d.insert('d', None);\\n        assert_eq!(bellman_ford(&graph, &'d'), Some(dists_d));\\n\\n        let mut dists_e = BTreeMap::new();\\n        dists_e.insert('e', None);\\n        dists_e.insert('a', Some(('e', 7)));\\n        dists_e.insert('c', Some(('a', 19)));\\n        dists_e.insert('d', Some(('c', 51)));\\n        dists_e.insert('b', Some(('c', 39)));\\n        assert_eq!(bellman_ford(&graph, &'e'), Some(dists_e));\\n    }\\n\\n    #[test]\\n    fn graph_2() {\\n        let mut graph = BTreeMap::new();\\n        add_edge(&mut graph, 0, 1, 6);\\n        add_edge(&mut graph, 0, 3, 7);\\n        add_edge(&mut graph, 1, 2, 5);\\n        add_edge(&mut graph, 1, 3, 8);\\n        add_edge(&mut graph, 1, 4, -4);\\n        add_edge(&mut graph, 2, 1, -2);\\n        add_edge(&mut graph, 3, 2, -3);\\n        add_edge(&mut graph, 3, 4, 9);\\n        add_edge(&mut graph, 4, 0, 3);\\n        add_edge(&mut graph, 4, 2, 7);\\n\\n        let mut dists_0 = BTreeMap::new();\\n        dists_0.insert(0, None);\\n        dists_0.insert(1, Some((2, 2)));\\n        dists_0.insert(2, Some((3, 4)));\\n        dists_0.insert(3, Some((0, 7)));\\n        dists_0.insert(4, Some((1, -2)));\\n        assert_eq!(bellman_ford(&graph, &0), Some(dists_0));\\n\\n        let mut dists_1 = BTreeMap::new();\\n        dists_1.insert(0, Some((4, -1)));\\n        dists_1.insert(1, None);\\n        dists_1.insert(2, Some((4, 3)));\\n        dists_1.insert(3, Some((0, 6)));\\n        dists_1.insert(4, Some((1, -4)));\\n        assert_eq!(bellman_ford(&graph, &1), Some(dists_1));\\n\\n        let mut dists_2 = BTreeMap::new();\\n        dists_2.insert(0, Some((4, -3)));\\n        dists_2.insert(1, Some((2, -2)));\\n        dists_2.insert(2, None);\\n        dists_2.insert(3, Some((0, 4)));\\n        dists_2.insert(4, Some((1, -6)));\\n        assert_eq!(bellman_ford(&graph, &2), Some(dists_2));\\n\\n        let mut dists_3 = BTreeMap::new();\\n        dists_3.insert(0, Some((4, -6)));\\n        dists_3.insert(1, Some((2, -5)));\\n        dists_3.insert(2, Some((3, -3)));\\n        dists_3.insert(3, None);\\n        dists_3.insert(4, Some((1, -9)));\\n        assert_eq!(bellman_ford(&graph, &3), Some(dists_3));\\n\\n        let mut dists_4 = BTreeMap::new();\\n        dists_4.insert(0, Some((4, 3)));\\n        dists_4.insert(1, Some((2, 5)));\\n        dists_4.insert(2, Some((4, 7)));\\n        dists_4.insert(3, Some((0, 10)));\\n        dists_4.insert(4, None);\\n        assert_eq!(bellman_ford(&graph, &4), Some(dists_4));\\n    }\\n\\n    #[test]\\n    fn graph_with_negative_loop() {\\n        let mut graph = BTreeMap::new();\\n        add_edge(&mut graph, 0, 1, 6);\\n        add_edge(&mut graph, 0, 3, 7);\\n        add_edge(&mut graph, 1, 2, 5);\\n        add_edge(&mut graph, 1, 3, 8);\\n        add_edge(&mut graph, 1, 4, -4);\\n        add_edge(&mut graph, 2, 1, -4);\\n        add_edge(&mut graph, 3, 2, -3);\\n        add_edge(&mut graph, 3, 4, 9);\\n        add_edge(&mut graph, 4, 0, 3);\\n        add_edge(&mut graph, 4, 2, 7);\\n\\n        assert_eq!(bellman_ford(&graph, &0), None);\\n        assert_eq!(bellman_ford(&graph, &1), None);\\n        assert_eq!(bellman_ford(&graph, &2), None);\\n        assert_eq!(bellman_ford(&graph, &3), None);\\n        assert_eq!(bellman_ford(&graph, &4), None);\\n    }\\n}\\n\"",
    "breadth first search": "\"use std::collections::HashSet;\\nuse std::collections::VecDeque;\\n\\n/// Perform a breadth-first search on Graph `graph`.\\n///\\n/// # Parameters\\n///\\n/// - `graph`: The graph to search.\\n/// - `root`: The starting node of the graph from which to begin searching.\\n/// - `target`: The target node for the search.\\n///\\n/// # Returns\\n///\\n/// If the target is found, an Optional vector is returned with the history\\n/// of nodes visited as its contents.\\n///\\n/// If the target is not found or there is no path from the root,\\n/// `None` is returned.\\n///\\npub fn breadth_first_search(graph: &Graph, root: Node, target: Node) -> Option<Vec<u32>> {\\n    let mut visited: HashSet<Node> = HashSet::new();\\n    let mut history: Vec<u32> = Vec::new();\\n    let mut queue = VecDeque::new();\\n\\n    visited.insert(root);\\n    queue.push_back(root);\\n    while let Some(currentnode) = queue.pop_front() {\\n        history.push(currentnode.value());\\n\\n        // If we reach the goal, return our travel history.\\n        if currentnode == target {\\n            return Some(history);\\n        }\\n\\n        // Check the neighboring nodes for any that we've not visited yet.\\n        for neighbor in currentnode.neighbors(graph) {\\n            if !visited.contains(&neighbor) {\\n                visited.insert(neighbor);\\n                queue.push_back(neighbor);\\n            }\\n        }\\n    }\\n\\n    // All nodes were visited, yet the target was not found.\\n    None\\n}\\n\\n// Data Structures\\n\\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\\npub struct Node(u32);\\n\\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\\npub struct Edge(u32, u32);\\n\\n#[derive(Clone)]\\npub struct Graph {\\n    #[allow(dead_code)]\\n    nodes: Vec<Node>,\\n    edges: Vec<Edge>,\\n}\\n\\nimpl Graph {\\n    pub fn new(nodes: Vec<Node>, edges: Vec<Edge>) -> Self {\\n        Graph { nodes, edges }\\n    }\\n}\\n\\nimpl From<u32> for Node {\\n    fn from(item: u32) -> Self {\\n        Node(item)\\n    }\\n}\\n\\nimpl Node {\\n    pub fn value(&self) -> u32 {\\n        self.0\\n    }\\n\\n    pub fn neighbors(&self, graph: &Graph) -> Vec<Node> {\\n        graph\\n            .edges\\n            .iter()\\n            .filter(|e| e.0 == self.0)\\n            .map(|e| e.1.into())\\n            .collect()\\n    }\\n}\\n\\nimpl From<(u32, u32)> for Edge {\\n    fn from(item: (u32, u32)) -> Self {\\n        Edge(item.0, item.1)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    /* Example graph #1:\\n     *\\n     *            (1)   <--- Root\\n     *           /   \\\\\\n     *         (2)   (3)\\n     *        / |     | \\\\\\n     *     (4) (5)   (6) (7)\\n     *          |\\n     *         (8)\\n     */\\n    fn graph1() -> Graph {\\n        let nodes = vec![1, 2, 3, 4, 5, 6, 7];\\n        let edges = vec![(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (5, 8)];\\n\\n        Graph::new(\\n            nodes.into_iter().map(|v| v.into()).collect(),\\n            edges.into_iter().map(|e| e.into()).collect(),\\n        )\\n    }\\n\\n    #[test]\\n    fn breadth_first_search_graph1_when_node_not_found_returns_none() {\\n        let graph = graph1();\\n        let root = 1;\\n        let target = 10;\\n\\n        assert_eq!(\\n            breadth_first_search(&graph, root.into(), target.into()),\\n            None\\n        );\\n    }\\n\\n    #[test]\\n    fn breadth_first_search_graph1_when_target_8_should_evaluate_all_nodes_first() {\\n        let graph = graph1();\\n        let root = 1;\\n        let target = 8;\\n\\n        let expected_path = vec![1, 2, 3, 4, 5, 6, 7, 8];\\n\\n        assert_eq!(\\n            breadth_first_search(&graph, root.into(), target.into()),\\n            Some(expected_path)\\n        );\\n    }\\n\\n    /* Example graph #2:\\n     *\\n     *     (1) --- (2)     (3) --- (4)\\n     *            / |     /       /\\n     *          /   |   /       /\\n     *        /     | /       /\\n     *     (5)     (6) --- (7)     (8)\\n     */\\n    fn graph2() -> Graph {\\n        let nodes = vec![1, 2, 3, 4, 5, 6, 7, 8];\\n        let undirected_edges = vec![\\n            (1, 2),\\n            (2, 1),\\n            (2, 5),\\n            (5, 2),\\n            (2, 6),\\n            (6, 2),\\n            (3, 4),\\n            (4, 3),\\n            (3, 6),\\n            (6, 3),\\n            (4, 7),\\n            (7, 4),\\n            (6, 7),\\n            (7, 6),\\n        ];\\n\\n        Graph::new(\\n            nodes.into_iter().map(|v| v.into()).collect(),\\n            undirected_edges.into_iter().map(|e| e.into()).collect(),\\n        )\\n    }\\n\\n    #[test]\\n    fn breadth_first_search_graph2_when_no_path_to_node_returns_none() {\\n        let graph = graph2();\\n        let root = 8;\\n        let target = 4;\\n\\n        assert_eq!(\\n            breadth_first_search(&graph, root.into(), target.into()),\\n            None\\n        );\\n    }\\n\\n    #[test]\\n    fn breadth_first_search_graph2_should_find_path_from_4_to_1() {\\n        let graph = graph2();\\n        let root = 4;\\n        let target = 1;\\n\\n        let expected_path = vec![4, 3, 7, 6, 2, 1];\\n\\n        assert_eq!(\\n            breadth_first_search(&graph, root.into(), target.into()),\\n            Some(expected_path)\\n        );\\n    }\\n}\\n\"",
    "depth first search": "\"use std::collections::HashSet;\\nuse std::collections::VecDeque;\\n\\n// Perform a Depth First Search Algorithm to find a element in a graph\\n//\\n// Return a Optional with a vector with history of vertex visiteds\\n// or a None if the element not exists on the graph\\npub fn depth_first_search(graph: &Graph, root: Vertex, objective: Vertex) -> Option<Vec<u32>> {\\n    let mut visited: HashSet<Vertex> = HashSet::new();\\n    let mut history: Vec<u32> = Vec::new();\\n    let mut queue = VecDeque::new();\\n    queue.push_back(root);\\n\\n    // While there is an element in the queue\\n    // get the first element of the vertex queue\\n    while let Some(current_vertex) = queue.pop_front() {\\n        // Added current vertex in the history of visiteds vertex\\n        history.push(current_vertex.value());\\n\\n        // Verify if this vertex is the objective\\n        if current_vertex == objective {\\n            // Return the Optional with the history of visiteds vertex\\n            return Some(history);\\n        }\\n\\n        // For each over the neighbors of current vertex\\n        for neighbor in current_vertex.neighbors(graph).into_iter().rev() {\\n            // Insert in the HashSet of visiteds if this value not exist yet\\n            if visited.insert(neighbor) {\\n                // Add the neighbor on front of queue\\n                queue.push_front(neighbor);\\n            }\\n        }\\n    }\\n\\n    // If all vertex is visited and the objective is not found\\n    // return a Optional with None value\\n    None\\n}\\n\\n// Data Structures\\n\\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\\npub struct Vertex(u32);\\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\\npub struct Edge(u32, u32);\\n#[derive(Clone)]\\npub struct Graph {\\n    #[allow(dead_code)]\\n    vertices: Vec<Vertex>,\\n    edges: Vec<Edge>,\\n}\\n\\nimpl Graph {\\n    pub fn new(vertices: Vec<Vertex>, edges: Vec<Edge>) -> Self {\\n        Graph { vertices, edges }\\n    }\\n}\\n\\nimpl From<u32> for Vertex {\\n    fn from(item: u32) -> Self {\\n        Vertex(item)\\n    }\\n}\\n\\nimpl Vertex {\\n    pub fn value(&self) -> u32 {\\n        self.0\\n    }\\n\\n    pub fn neighbors(&self, graph: &Graph) -> VecDeque<Vertex> {\\n        graph\\n            .edges\\n            .iter()\\n            .filter(|e| e.0 == self.0)\\n            .map(|e| e.1.into())\\n            .collect()\\n    }\\n}\\n\\nimpl From<(u32, u32)> for Edge {\\n    fn from(item: (u32, u32)) -> Self {\\n        Edge(item.0, item.1)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn find_1_fail() {\\n        let vertices = vec![1, 2, 3, 4, 5, 6, 7];\\n        let edges = vec![(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)];\\n\\n        let root = 1;\\n        let objective = 99;\\n\\n        let graph = Graph::new(\\n            vertices.into_iter().map(|v| v.into()).collect(),\\n            edges.into_iter().map(|e| e.into()).collect(),\\n        );\\n\\n        assert_eq!(\\n            depth_first_search(&graph, root.into(), objective.into()),\\n            None\\n        );\\n    }\\n\\n    #[test]\\n    fn find_1_sucess() {\\n        let vertices = vec![1, 2, 3, 4, 5, 6, 7];\\n        let edges = vec![(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)];\\n\\n        let root = 1;\\n        let objective = 7;\\n\\n        let correct_path = vec![1, 2, 4, 5, 3, 6, 7];\\n\\n        let graph = Graph::new(\\n            vertices.into_iter().map(|v| v.into()).collect(),\\n            edges.into_iter().map(|e| e.into()).collect(),\\n        );\\n\\n        assert_eq!(\\n            depth_first_search(&graph, root.into(), objective.into()),\\n            Some(correct_path)\\n        );\\n    }\\n\\n    #[test]\\n    fn find_2_sucess() {\\n        let vertices = vec![0, 1, 2, 3, 4, 5, 6, 7];\\n        let edges = vec![\\n            (0, 1),\\n            (1, 3),\\n            (3, 2),\\n            (2, 1),\\n            (3, 4),\\n            (4, 5),\\n            (5, 7),\\n            (7, 6),\\n            (6, 4),\\n        ];\\n\\n        let root = 0;\\n        let objective = 6;\\n\\n        let correct_path = vec![0, 1, 3, 2, 4, 5, 7, 6];\\n\\n        let graph = Graph::new(\\n            vertices.into_iter().map(|v| v.into()).collect(),\\n            edges.into_iter().map(|e| e.into()).collect(),\\n        );\\n\\n        assert_eq!(\\n            depth_first_search(&graph, root.into(), objective.into()),\\n            Some(correct_path)\\n        );\\n    }\\n\\n    #[test]\\n    fn find_3_sucess() {\\n        let vertices = vec![0, 1, 2, 3, 4, 5, 6, 7];\\n        let edges = vec![\\n            (0, 1),\\n            (1, 3),\\n            (3, 2),\\n            (2, 1),\\n            (3, 4),\\n            (4, 5),\\n            (5, 7),\\n            (7, 6),\\n            (6, 4),\\n        ];\\n\\n        let root = 0;\\n        let objective = 4;\\n\\n        let correct_path = vec![0, 1, 3, 2, 4];\\n\\n        let graph = Graph::new(\\n            vertices.into_iter().map(|v| v.into()).collect(),\\n            edges.into_iter().map(|e| e.into()).collect(),\\n        );\\n\\n        assert_eq!(\\n            depth_first_search(&graph, root.into(), objective.into()),\\n            Some(correct_path)\\n        );\\n    }\\n}\\n\"",
    "depth first search tic tac toe": "\"/*\\nTic-Tac-Toe Depth First Search Rust Demo\\nCopyright 2021 David V. Makray\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy of\\nthis software and associated documentation files (the \\\"Software\\\"), to deal in\\nthe Software without restriction, including without limitation the rights to\\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\\nof the Software, and to permit persons to whom the Software is furnished to do\\nso, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n*/\\n\\n#[allow(unused_imports)]\\nuse std::io;\\n\\n//Interactive Tic-Tac-Toe play needs the \\\"rand = \\\"0.8.3\\\" crate.\\n//#[cfg(not(test))]\\n//extern crate rand;\\n//#[cfg(not(test))]\\n//use rand::Rng;\\n\\n#[derive(Copy, Clone, PartialEq, Debug)]\\nstruct Position {\\n    x: u8,\\n    y: u8,\\n}\\n\\n#[derive(Copy, Clone, PartialEq, Debug)]\\npub enum Players {\\n    Blank,\\n    PlayerX,\\n    PlayerO,\\n}\\n\\n#[derive(Copy, Clone, PartialEq, Debug)]\\nstruct SinglePlayAction {\\n    position: Position,\\n    side: Players,\\n}\\n\\n#[derive(Clone, PartialEq, Debug)]\\npub struct PlayActions {\\n    positions: Vec<Position>,\\n    side: Players,\\n}\\n\\n#[allow(dead_code)]\\n#[cfg(not(test))]\\nfn main() {\\n    let mut board = vec![vec![Players::Blank; 3]; 3];\\n\\n    while !available_positions(&board).is_empty()\\n        && !win_check(Players::PlayerX, &board)\\n        && !win_check(Players::PlayerO, &board)\\n    {\\n        display_board(&board);\\n        println!(\\\"Type in coordinate for X mark to be played. ie. a1 etc.\\\");\\n        let mut input = String::new();\\n        io::stdin()\\n            .read_line(&mut input)\\n            .expect(\\\"Failed to read line\\\");\\n\\n        let mut move_position: Option<Position> = None;\\n        input.make_ascii_lowercase();\\n        let bytes = input.trim().trim_start().as_bytes();\\n        if bytes.len() as u32 == 2\\n            && (bytes[0] as char).is_alphabetic()\\n            && (bytes[1] as char).is_numeric()\\n        {\\n            let column: u8 = bytes[0] - b'a';\\n            let row: u8 = bytes[1] - b'1';\\n\\n            if column <= 2 && row <= 2 {\\n                move_position = Some(Position { x: column, y: row });\\n            }\\n        }\\n\\n        //Take the validated user input coordinate and use it.\\n        if let Some(move_pos) = move_position {\\n            let open_positions = available_positions(&board);\\n\\n            let mut search = open_positions.iter();\\n            let result = search.find(|&&x| x == move_pos);\\n            if result.is_none() {\\n                println!(\\\"Not a valid empty coordinate.\\\");\\n                continue;\\n            } else {\\n                board[move_pos.y as usize][move_pos.x as usize] = Players::PlayerX;\\n\\n                if win_check(Players::PlayerX, &board) {\\n                    display_board(&board);\\n                    println!(\\\"Player X Wins!\\\");\\n                    return;\\n                }\\n            }\\n\\n            //Find the best game plays from the current board state\\n            let recusion_result = minimax(Players::PlayerO, &board);\\n            match recusion_result {\\n                Some(x) => {\\n                    //Interactive Tic-Tac-Toe play needs the \\\"rand = \\\"0.8.3\\\" crate.\\n                    //#[cfg(not(test))]\\n                    //let random_selection = rand::thread_rng().gen_range(0..x.positions.len());\\n                    let random_selection = 0;\\n\\n                    let response_pos = x.positions[random_selection];\\n                    board[response_pos.y as usize][response_pos.x as usize] = Players::PlayerO;\\n                    if win_check(Players::PlayerO, &board) {\\n                        display_board(&board);\\n                        println!(\\\"Player O Wins!\\\");\\n                        return;\\n                    }\\n                }\\n\\n                None => {\\n                    display_board(&board);\\n                    println!(\\\"Draw game.\\\");\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n#[allow(dead_code)]\\nfn display_board(board: &[Vec<Players>]) {\\n    println!();\\n    for (y, board_row) in board.iter().enumerate() {\\n        print!(\\\"{} \\\", (y + 1));\\n        for board_cell in board_row {\\n            match board_cell {\\n                Players::PlayerX => print!(\\\"X \\\"),\\n                Players::PlayerO => print!(\\\"O \\\"),\\n                Players::Blank => print!(\\\"_ \\\"),\\n            }\\n        }\\n        println!();\\n    }\\n    println!(\\\"  a b c\\\");\\n}\\n\\nfn available_positions(board: &[Vec<Players>]) -> Vec<Position> {\\n    let mut available: Vec<Position> = Vec::new();\\n    for (y, board_row) in board.iter().enumerate() {\\n        for (x, board_cell) in board_row.iter().enumerate() {\\n            if *board_cell == Players::Blank {\\n                available.push(Position {\\n                    x: x as u8,\\n                    y: y as u8,\\n                });\\n            }\\n        }\\n    }\\n    available\\n}\\n\\nfn win_check(player: Players, board: &[Vec<Players>]) -> bool {\\n    if player == Players::Blank {\\n        return false;\\n    }\\n\\n    //Check for a win on the diagonals.\\n    if (board[0][0] == board[1][1]) && (board[1][1] == board[2][2]) && (board[2][2] == player)\\n        || (board[2][0] == board[1][1]) && (board[1][1] == board[0][2]) && (board[0][2] == player)\\n    {\\n        return true;\\n    }\\n\\n    for i in 0..3 {\\n        //Check for a win on the horizontals.\\n        if (board[i][0] == board[i][1]) && (board[i][1] == board[i][2]) && (board[i][2] == player) {\\n            return true;\\n        }\\n\\n        //Check for a win on the verticals.\\n        if (board[0][i] == board[1][i]) && (board[1][i] == board[2][i]) && (board[2][i] == player) {\\n            return true;\\n        }\\n    }\\n\\n    false\\n}\\n\\n//Minimize the actions of the opponent while maximizing the game state of the current player.\\npub fn minimax(side: Players, board: &[Vec<Players>]) -> Option<PlayActions> {\\n    //Check that board is in a valid state.\\n    if win_check(Players::PlayerX, board) || win_check(Players::PlayerO, board) {\\n        return None;\\n    }\\n\\n    let opposite = match side {\\n        Players::PlayerX => Players::PlayerO,\\n        Players::PlayerO => Players::PlayerX,\\n        Players::Blank => panic!(\\\"Minimax can't operate when a player isn't specified.\\\"),\\n    };\\n\\n    let positions = available_positions(board);\\n    if positions.is_empty() {\\n        return None;\\n    }\\n\\n    //Play position\\n    let mut best_move: Option<PlayActions> = None;\\n\\n    for pos in positions {\\n        let mut board_next = board.to_owned();\\n        board_next[pos.y as usize][pos.x as usize] = side;\\n\\n        //Check for a win condition before recursion to determine if this node is terminal.\\n        if win_check(Players::PlayerX, &board_next) {\\n            append_playaction(\\n                side,\\n                &mut best_move,\\n                SinglePlayAction {\\n                    position: pos,\\n                    side: Players::PlayerX,\\n                },\\n            );\\n            continue;\\n        }\\n\\n        if win_check(Players::PlayerO, &board_next) {\\n            append_playaction(\\n                side,\\n                &mut best_move,\\n                SinglePlayAction {\\n                    position: pos,\\n                    side: Players::PlayerO,\\n                },\\n            );\\n            continue;\\n        }\\n\\n        let result = minimax(opposite, &board_next);\\n        let current_score = match result {\\n            Some(x) => x.side,\\n            _ => Players::Blank,\\n        };\\n\\n        append_playaction(\\n            side,\\n            &mut best_move,\\n            SinglePlayAction {\\n                position: pos,\\n                side: current_score,\\n            },\\n        )\\n    }\\n    best_move\\n}\\n\\n//Promote only better or collate equally scored game plays\\nfn append_playaction(\\n    current_side: Players,\\n    opt_play_actions: &mut Option<PlayActions>,\\n    appendee: SinglePlayAction,\\n) {\\n    if opt_play_actions.is_none() {\\n        *opt_play_actions = Some(PlayActions {\\n            positions: vec![appendee.position],\\n            side: appendee.side,\\n        });\\n        return;\\n    }\\n\\n    let mut play_actions = opt_play_actions.as_mut().unwrap();\\n\\n    //New game action is scored from the current side and the current saved best score against the new game action.\\n    match (current_side, play_actions.side, appendee.side) {\\n        (Players::Blank, _, _) => panic!(\\\"Unreachable state.\\\"),\\n\\n        //Winning scores\\n        (Players::PlayerX, Players::PlayerX, Players::PlayerX) => {\\n            play_actions.positions.push(appendee.position);\\n        }\\n        (Players::PlayerX, Players::PlayerX, _) => {}\\n        (Players::PlayerO, Players::PlayerO, Players::PlayerO) => {\\n            play_actions.positions.push(appendee.position);\\n        }\\n        (Players::PlayerO, Players::PlayerO, _) => {}\\n\\n        //Non-winning to Winning scores\\n        (Players::PlayerX, _, Players::PlayerX) => {\\n            play_actions.side = Players::PlayerX;\\n            play_actions.positions.clear();\\n            play_actions.positions.push(appendee.position);\\n        }\\n        (Players::PlayerO, _, Players::PlayerO) => {\\n            play_actions.side = Players::PlayerO;\\n            play_actions.positions.clear();\\n            play_actions.positions.push(appendee.position);\\n        }\\n\\n        //Losing to Neutral scores\\n        (Players::PlayerX, Players::PlayerO, Players::Blank) => {\\n            play_actions.side = Players::Blank;\\n            play_actions.positions.clear();\\n            play_actions.positions.push(appendee.position);\\n        }\\n\\n        (Players::PlayerO, Players::PlayerX, Players::Blank) => {\\n            play_actions.side = Players::Blank;\\n            play_actions.positions.clear();\\n            play_actions.positions.push(appendee.position);\\n        }\\n\\n        //Ignoring lower scored plays\\n        (Players::PlayerX, Players::Blank, Players::PlayerO) => {}\\n        (Players::PlayerO, Players::Blank, Players::PlayerX) => {}\\n\\n        //No change hence append only\\n        (_, _, _) => {\\n            assert!(play_actions.side == appendee.side);\\n            play_actions.positions.push(appendee.position);\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn win_state_check() {\\n        let mut board = vec![vec![Players::Blank; 3]; 3];\\n        board[0][0] = Players::PlayerX;\\n        board[0][1] = Players::PlayerX;\\n        board[0][2] = Players::PlayerX;\\n        let responses = minimax(Players::PlayerO, &board);\\n        assert_eq!(responses, None);\\n    }\\n\\n    #[test]\\n    fn win_state_check2() {\\n        let mut board = vec![vec![Players::Blank; 3]; 3];\\n        board[0][0] = Players::PlayerX;\\n        board[0][1] = Players::PlayerO;\\n        board[1][0] = Players::PlayerX;\\n        board[1][1] = Players::PlayerO;\\n        board[2][1] = Players::PlayerO;\\n        let responses = minimax(Players::PlayerO, &board);\\n        assert_eq!(responses, None);\\n    }\\n\\n    #[test]\\n    fn block_win_move() {\\n        let mut board = vec![vec![Players::Blank; 3]; 3];\\n        board[0][0] = Players::PlayerX;\\n        board[0][1] = Players::PlayerX;\\n        board[1][2] = Players::PlayerO;\\n        board[2][2] = Players::PlayerO;\\n        let responses = minimax(Players::PlayerX, &board);\\n        assert_eq!(\\n            responses,\\n            Some(PlayActions {\\n                positions: vec![Position { x: 2, y: 0 }],\\n                side: Players::PlayerX\\n            })\\n        );\\n    }\\n\\n    #[test]\\n    fn block_move() {\\n        let mut board = vec![vec![Players::Blank; 3]; 3];\\n        board[0][1] = Players::PlayerX;\\n        board[0][2] = Players::PlayerO;\\n        board[2][0] = Players::PlayerO;\\n        let responses = minimax(Players::PlayerX, &board);\\n        assert_eq!(\\n            responses,\\n            Some(PlayActions {\\n                positions: vec![Position { x: 1, y: 1 }],\\n                side: Players::Blank\\n            })\\n        );\\n    }\\n\\n    #[test]\\n    fn expected_loss() {\\n        let mut board = vec![vec![Players::Blank; 3]; 3];\\n        board[0][0] = Players::PlayerX;\\n        board[0][2] = Players::PlayerO;\\n        board[1][0] = Players::PlayerX;\\n        board[2][0] = Players::PlayerO;\\n        board[2][2] = Players::PlayerO;\\n        let responses = minimax(Players::PlayerX, &board);\\n        assert_eq!(\\n            responses,\\n            Some(PlayActions {\\n                positions: vec![\\n                    Position { x: 1, y: 0 },\\n                    Position { x: 1, y: 1 },\\n                    Position { x: 2, y: 1 },\\n                    Position { x: 1, y: 2 }\\n                ],\\n                side: Players::PlayerO\\n            })\\n        );\\n    }\\n}\\n\"",
    "dijkstra": "\"use std::cmp::Reverse;\\nuse std::collections::{BTreeMap, BinaryHeap};\\nuse std::ops::Add;\\n\\ntype Graph<V, E> = BTreeMap<V, BTreeMap<V, E>>;\\n\\n// performs Dijsktra's algorithm on the given graph from the given start\\n// the graph is a positively-weighted undirected graph\\n//\\n// returns a map that for each reachable vertex associates the distance and the predecessor\\n// since the start has no predecessor but is reachable, map[start] will be None\\npub fn dijkstra<V: Ord + Copy, E: Ord + Copy + Add<Output = E>>(\\n    graph: &Graph<V, E>,\\n    start: &V,\\n) -> BTreeMap<V, Option<(V, E)>> {\\n    let mut ans = BTreeMap::new();\\n    let mut prio = BinaryHeap::new();\\n\\n    // start is the special case that doesn't have a predecessor\\n    ans.insert(*start, None);\\n\\n    for (new, weight) in &graph[start] {\\n        ans.insert(*new, Some((*start, *weight)));\\n        prio.push(Reverse((*weight, new, start)));\\n    }\\n\\n    while let Some(Reverse((dist_new, new, prev))) = prio.pop() {\\n        match ans[new] {\\n            // what we popped is what is in ans, we'll compute it\\n            Some((p, d)) if p == *prev && d == dist_new => {}\\n            // otherwise it's not interesting\\n            _ => continue,\\n        }\\n\\n        for (next, weight) in &graph[new] {\\n            match ans.get(next) {\\n                // if ans[next] is a lower dist than the alternative one, we do nothing\\n                Some(Some((_, dist_next))) if dist_new + *weight >= *dist_next => {}\\n                // if ans[next] is None then next is start and so the distance won't be changed, it won't be added again in prio\\n                Some(None) => {}\\n                // the new path is shorter, either new was not in ans or it was farther\\n                _ => {\\n                    ans.insert(*next, Some((*new, *weight + dist_new)));\\n                    prio.push(Reverse((*weight + dist_new, next, new)));\\n                }\\n            }\\n        }\\n    }\\n\\n    ans\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::{dijkstra, Graph};\\n    use std::collections::BTreeMap;\\n\\n    fn add_edge<V: Ord + Copy, E: Ord>(graph: &mut Graph<V, E>, v1: V, v2: V, c: E) {\\n        graph.entry(v1).or_insert_with(BTreeMap::new).insert(v2, c);\\n        graph.entry(v2).or_insert_with(BTreeMap::new);\\n    }\\n\\n    #[test]\\n    fn single_vertex() {\\n        let mut graph: Graph<usize, usize> = BTreeMap::new();\\n        graph.insert(0, BTreeMap::new());\\n\\n        let mut dists = BTreeMap::new();\\n        dists.insert(0, None);\\n\\n        assert_eq!(dijkstra(&graph, &0), dists);\\n    }\\n\\n    #[test]\\n    fn single_edge() {\\n        let mut graph = BTreeMap::new();\\n        add_edge(&mut graph, 0, 1, 2);\\n\\n        let mut dists_0 = BTreeMap::new();\\n        dists_0.insert(0, None);\\n        dists_0.insert(1, Some((0, 2)));\\n\\n        assert_eq!(dijkstra(&graph, &0), dists_0);\\n\\n        let mut dists_1 = BTreeMap::new();\\n        dists_1.insert(1, None);\\n\\n        assert_eq!(dijkstra(&graph, &1), dists_1);\\n    }\\n\\n    #[test]\\n    fn tree_1() {\\n        let mut graph = BTreeMap::new();\\n        let mut dists = BTreeMap::new();\\n        dists.insert(1, None);\\n        for i in 1..100 {\\n            add_edge(&mut graph, i, i * 2, i * 2);\\n            add_edge(&mut graph, i, i * 2 + 1, i * 2 + 1);\\n\\n            match dists[&i] {\\n                Some((_, d)) => {\\n                    dists.insert(i * 2, Some((i, d + i * 2)));\\n                    dists.insert(i * 2 + 1, Some((i, d + i * 2 + 1)));\\n                }\\n                None => {\\n                    dists.insert(i * 2, Some((i, i * 2)));\\n                    dists.insert(i * 2 + 1, Some((i, i * 2 + 1)));\\n                }\\n            }\\n        }\\n\\n        assert_eq!(dijkstra(&graph, &1), dists);\\n    }\\n\\n    #[test]\\n    fn graph_1() {\\n        let mut graph = BTreeMap::new();\\n        add_edge(&mut graph, 'a', 'c', 12);\\n        add_edge(&mut graph, 'a', 'd', 60);\\n        add_edge(&mut graph, 'b', 'a', 10);\\n        add_edge(&mut graph, 'c', 'b', 20);\\n        add_edge(&mut graph, 'c', 'd', 32);\\n        add_edge(&mut graph, 'e', 'a', 7);\\n\\n        let mut dists_a = BTreeMap::new();\\n        dists_a.insert('a', None);\\n        dists_a.insert('c', Some(('a', 12)));\\n        dists_a.insert('d', Some(('c', 44)));\\n        dists_a.insert('b', Some(('c', 32)));\\n        assert_eq!(dijkstra(&graph, &'a'), dists_a);\\n\\n        let mut dists_b = BTreeMap::new();\\n        dists_b.insert('b', None);\\n        dists_b.insert('a', Some(('b', 10)));\\n        dists_b.insert('c', Some(('a', 22)));\\n        dists_b.insert('d', Some(('c', 54)));\\n        assert_eq!(dijkstra(&graph, &'b'), dists_b);\\n\\n        let mut dists_c = BTreeMap::new();\\n        dists_c.insert('c', None);\\n        dists_c.insert('b', Some(('c', 20)));\\n        dists_c.insert('d', Some(('c', 32)));\\n        dists_c.insert('a', Some(('b', 30)));\\n        assert_eq!(dijkstra(&graph, &'c'), dists_c);\\n\\n        let mut dists_d = BTreeMap::new();\\n        dists_d.insert('d', None);\\n        assert_eq!(dijkstra(&graph, &'d'), dists_d);\\n\\n        let mut dists_e = BTreeMap::new();\\n        dists_e.insert('e', None);\\n        dists_e.insert('a', Some(('e', 7)));\\n        dists_e.insert('c', Some(('a', 19)));\\n        dists_e.insert('d', Some(('c', 51)));\\n        dists_e.insert('b', Some(('c', 39)));\\n        assert_eq!(dijkstra(&graph, &'e'), dists_e);\\n    }\\n}\\n\"",
    "minimum spanning tree": "\"use std::vec::Vec;\\n\\n#[derive(Debug)]\\npub struct Edge {\\n    source: i64,\\n    destination: i64,\\n    cost: i64,\\n}\\n\\nimpl PartialEq for Edge {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.source == other.source\\n            && self.destination == other.destination\\n            && self.cost == other.cost\\n    }\\n}\\n\\nimpl Eq for Edge {}\\n\\nimpl Edge {\\n    fn new(source: i64, destination: i64, cost: i64) -> Self {\\n        Self {\\n            source,\\n            destination,\\n            cost,\\n        }\\n    }\\n}\\n\\nfn make_sets(number_of_vertices: i64) -> Vec<i64> {\\n    let mut parent: Vec<i64> = Vec::with_capacity(number_of_vertices as usize);\\n    for i in 0..number_of_vertices {\\n        parent.push(i);\\n    }\\n    parent\\n}\\n\\nfn find(parent: &mut Vec<i64>, x: i64) -> i64 {\\n    let idx: usize = x as usize;\\n    if parent[idx] != x {\\n        parent[idx] = find(parent, parent[idx]);\\n    }\\n    parent[idx]\\n}\\n\\nfn merge(parent: &mut Vec<i64>, x: i64, y: i64) {\\n    let idx_x: usize = find(parent, x) as usize;\\n    let parent_y: i64 = find(parent, y);\\n    parent[idx_x] = parent_y;\\n}\\n\\nfn is_same_set(parent: &mut Vec<i64>, x: i64, y: i64) -> bool {\\n    find(parent, x) == find(parent, y)\\n}\\n\\npub fn kruskal(mut edges: Vec<Edge>, number_of_vertices: i64) -> (i64, Vec<Edge>) {\\n    let mut parent: Vec<i64> = make_sets(number_of_vertices);\\n\\n    edges.sort_unstable_by(|a, b| a.cost.cmp(&b.cost));\\n    let mut total_cost: i64 = 0;\\n    let mut final_edges: Vec<Edge> = Vec::new();\\n    let mut merge_count: i64 = 0;\\n    for edge in edges.iter() {\\n        if merge_count >= number_of_vertices - 1 {\\n            break;\\n        }\\n\\n        let source: i64 = edge.source;\\n        let destination: i64 = edge.destination;\\n        if !is_same_set(&mut parent, source, destination) {\\n            merge(&mut parent, source, destination);\\n            merge_count += 1;\\n            let cost: i64 = edge.cost;\\n            total_cost += cost;\\n            let final_edge: Edge = Edge::new(source, destination, cost);\\n            final_edges.push(final_edge);\\n        }\\n    }\\n    (total_cost, final_edges)\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_seven_vertices_eleven_edges() {\\n        let mut edges: Vec<Edge> = Vec::new();\\n        edges.push(Edge::new(0, 1, 7));\\n        edges.push(Edge::new(0, 3, 5));\\n        edges.push(Edge::new(1, 2, 8));\\n        edges.push(Edge::new(1, 3, 9));\\n        edges.push(Edge::new(1, 4, 7));\\n        edges.push(Edge::new(2, 4, 5));\\n        edges.push(Edge::new(3, 4, 15));\\n        edges.push(Edge::new(3, 5, 6));\\n        edges.push(Edge::new(4, 5, 8));\\n        edges.push(Edge::new(4, 6, 9));\\n        edges.push(Edge::new(5, 6, 11));\\n\\n        let number_of_vertices: i64 = 7;\\n\\n        let expected_total_cost = 39;\\n        let mut expected_used_edges: Vec<Edge> = Vec::new();\\n        expected_used_edges.push(Edge::new(0, 3, 5));\\n        expected_used_edges.push(Edge::new(2, 4, 5));\\n        expected_used_edges.push(Edge::new(3, 5, 6));\\n        expected_used_edges.push(Edge::new(0, 1, 7));\\n        expected_used_edges.push(Edge::new(1, 4, 7));\\n        expected_used_edges.push(Edge::new(4, 6, 9));\\n\\n        let (actual_total_cost, actual_final_edges) = kruskal(edges, number_of_vertices);\\n\\n        assert_eq!(actual_total_cost, expected_total_cost);\\n        assert_eq!(actual_final_edges, expected_used_edges);\\n    }\\n\\n    #[test]\\n    fn test_ten_vertices_twenty_edges() {\\n        let mut edges: Vec<Edge> = Vec::new();\\n        edges.push(Edge::new(0, 1, 3));\\n        edges.push(Edge::new(0, 3, 6));\\n        edges.push(Edge::new(0, 4, 9));\\n        edges.push(Edge::new(1, 2, 2));\\n        edges.push(Edge::new(1, 3, 4));\\n        edges.push(Edge::new(1, 4, 9));\\n        edges.push(Edge::new(2, 3, 2));\\n        edges.push(Edge::new(2, 5, 8));\\n        edges.push(Edge::new(2, 6, 9));\\n        edges.push(Edge::new(3, 6, 9));\\n        edges.push(Edge::new(4, 5, 8));\\n        edges.push(Edge::new(4, 9, 18));\\n        edges.push(Edge::new(5, 6, 7));\\n        edges.push(Edge::new(5, 8, 9));\\n        edges.push(Edge::new(5, 9, 10));\\n        edges.push(Edge::new(6, 7, 4));\\n        edges.push(Edge::new(6, 8, 5));\\n        edges.push(Edge::new(7, 8, 1));\\n        edges.push(Edge::new(7, 9, 4));\\n        edges.push(Edge::new(8, 9, 3));\\n\\n        let number_of_vertices: i64 = 10;\\n\\n        let expected_total_cost = 38;\\n        let mut expected_used_edges = Vec::new();\\n        expected_used_edges.push(Edge::new(7, 8, 1));\\n        expected_used_edges.push(Edge::new(1, 2, 2));\\n        expected_used_edges.push(Edge::new(2, 3, 2));\\n        expected_used_edges.push(Edge::new(0, 1, 3));\\n        expected_used_edges.push(Edge::new(8, 9, 3));\\n        expected_used_edges.push(Edge::new(6, 7, 4));\\n        expected_used_edges.push(Edge::new(5, 6, 7));\\n        expected_used_edges.push(Edge::new(2, 5, 8));\\n        expected_used_edges.push(Edge::new(4, 5, 8));\\n\\n        let (actual_total_cost, actual_final_edges) = kruskal(edges, number_of_vertices);\\n\\n        assert_eq!(actual_total_cost, expected_total_cost);\\n        assert_eq!(actual_final_edges, expected_used_edges);\\n    }\\n}\\n\"",
    "prim": "\"use std::cmp::Reverse;\\nuse std::collections::{BTreeMap, BinaryHeap};\\nuse std::ops::Add;\\n\\ntype Graph<V, E> = BTreeMap<V, BTreeMap<V, E>>;\\n\\nfn add_edge<V: Ord + Copy, E: Ord + Add + Copy>(graph: &mut Graph<V, E>, v1: V, v2: V, c: E) {\\n    graph.entry(v1).or_insert_with(BTreeMap::new).insert(v2, c);\\n    graph.entry(v2).or_insert_with(BTreeMap::new).insert(v1, c);\\n}\\n\\n// selects a start and run the algorithm from it\\npub fn prim<V: Ord + Copy + std::fmt::Debug, E: Ord + Add + Copy + std::fmt::Debug>(\\n    graph: &Graph<V, E>,\\n) -> Graph<V, E> {\\n    match graph.keys().next() {\\n        Some(v) => prim_with_start(graph, *v),\\n        None => BTreeMap::new(),\\n    }\\n}\\n\\n// only works for a connected graph\\n// if the given graph is not connected it will return the MST of the connected subgraph\\npub fn prim_with_start<V: Ord + Copy, E: Ord + Add + Copy>(\\n    graph: &Graph<V, E>,\\n    start: V,\\n) -> Graph<V, E> {\\n    // will contain the MST\\n    let mut mst: Graph<V, E> = Graph::new();\\n    // a priority queue based on a binary heap, used to get the cheapest edge\\n    // the elements are an edge: the cost, destination and source\\n    let mut prio = BinaryHeap::new();\\n\\n    mst.insert(start, BTreeMap::new());\\n\\n    for (v, c) in &graph[&start] {\\n        // the heap is a max heap, we have to use Reverse when adding to simulate a min heap\\n        prio.push(Reverse((*c, v, start)));\\n    }\\n\\n    while let Some(Reverse((dist, t, prev))) = prio.pop() {\\n        // the destination of the edge has already been seen\\n        if mst.contains_key(t) {\\n            continue;\\n        }\\n\\n        // the destination is a new vertex\\n        add_edge(&mut mst, prev, *t, dist);\\n\\n        for (v, c) in &graph[t] {\\n            if !mst.contains_key(v) {\\n                prio.push(Reverse((*c, v, *t)));\\n            }\\n        }\\n    }\\n\\n    mst\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::{add_edge, prim, Graph};\\n    use std::collections::BTreeMap;\\n\\n    #[test]\\n    fn empty() {\\n        assert_eq!(prim::<usize, usize>(&BTreeMap::new()), BTreeMap::new());\\n    }\\n\\n    #[test]\\n    fn single_vertex() {\\n        let mut graph: Graph<usize, usize> = BTreeMap::new();\\n        graph.insert(42, BTreeMap::new());\\n\\n        assert_eq!(prim(&graph), graph);\\n    }\\n\\n    #[test]\\n    fn single_edge() {\\n        let mut graph = BTreeMap::new();\\n\\n        add_edge(&mut graph, 42, 666, 12);\\n\\n        assert_eq!(prim(&graph), graph);\\n    }\\n\\n    #[test]\\n    fn tree_1() {\\n        let mut graph = BTreeMap::new();\\n\\n        add_edge(&mut graph, 0, 1, 10);\\n        add_edge(&mut graph, 0, 2, 11);\\n        add_edge(&mut graph, 2, 3, 12);\\n        add_edge(&mut graph, 2, 4, 13);\\n        add_edge(&mut graph, 1, 5, 14);\\n        add_edge(&mut graph, 1, 6, 15);\\n        add_edge(&mut graph, 3, 7, 16);\\n\\n        assert_eq!(prim(&graph), graph);\\n    }\\n\\n    #[test]\\n    fn tree_2() {\\n        let mut graph = BTreeMap::new();\\n\\n        add_edge(&mut graph, 1, 2, 11);\\n        add_edge(&mut graph, 2, 3, 12);\\n        add_edge(&mut graph, 2, 4, 13);\\n        add_edge(&mut graph, 4, 5, 14);\\n        add_edge(&mut graph, 4, 6, 15);\\n        add_edge(&mut graph, 6, 7, 16);\\n\\n        assert_eq!(prim(&graph), graph);\\n    }\\n\\n    #[test]\\n    fn tree_3() {\\n        let mut graph = BTreeMap::new();\\n\\n        for i in 1..100 {\\n            add_edge(&mut graph, i, 2 * i, i);\\n            add_edge(&mut graph, i, 2 * i + 1, -i);\\n        }\\n\\n        assert_eq!(prim(&graph), graph);\\n    }\\n\\n    #[test]\\n    fn graph_1() {\\n        let mut graph = BTreeMap::new();\\n        add_edge(&mut graph, 'a', 'b', 6);\\n        add_edge(&mut graph, 'a', 'c', 7);\\n        add_edge(&mut graph, 'a', 'e', 2);\\n        add_edge(&mut graph, 'a', 'f', 3);\\n        add_edge(&mut graph, 'b', 'c', 5);\\n        add_edge(&mut graph, 'c', 'e', 5);\\n        add_edge(&mut graph, 'd', 'e', 4);\\n        add_edge(&mut graph, 'd', 'f', 1);\\n        add_edge(&mut graph, 'e', 'f', 2);\\n\\n        let mut ans = BTreeMap::new();\\n        add_edge(&mut ans, 'd', 'f', 1);\\n        add_edge(&mut ans, 'e', 'f', 2);\\n        add_edge(&mut ans, 'a', 'e', 2);\\n        add_edge(&mut ans, 'b', 'c', 5);\\n        add_edge(&mut ans, 'c', 'e', 5);\\n\\n        assert_eq!(prim(&graph), ans);\\n    }\\n\\n    #[test]\\n    fn graph_2() {\\n        let mut graph = BTreeMap::new();\\n        add_edge(&mut graph, 1, 2, 6);\\n        add_edge(&mut graph, 1, 3, 1);\\n        add_edge(&mut graph, 1, 4, 5);\\n        add_edge(&mut graph, 2, 3, 5);\\n        add_edge(&mut graph, 2, 5, 3);\\n        add_edge(&mut graph, 3, 4, 5);\\n        add_edge(&mut graph, 3, 5, 6);\\n        add_edge(&mut graph, 3, 6, 4);\\n        add_edge(&mut graph, 4, 6, 2);\\n        add_edge(&mut graph, 5, 6, 6);\\n\\n        let mut ans = BTreeMap::new();\\n        add_edge(&mut ans, 1, 3, 1);\\n        add_edge(&mut ans, 4, 6, 2);\\n        add_edge(&mut ans, 2, 5, 3);\\n        add_edge(&mut ans, 2, 3, 5);\\n        add_edge(&mut ans, 3, 6, 4);\\n\\n        assert_eq!(prim(&graph), ans);\\n    }\\n\\n    #[test]\\n    fn graph_3() {\\n        let mut graph = BTreeMap::new();\\n        add_edge(&mut graph, \\\"v1\\\", \\\"v2\\\", 1);\\n        add_edge(&mut graph, \\\"v1\\\", \\\"v3\\\", 3);\\n        add_edge(&mut graph, \\\"v1\\\", \\\"v5\\\", 6);\\n        add_edge(&mut graph, \\\"v2\\\", \\\"v3\\\", 2);\\n        add_edge(&mut graph, \\\"v2\\\", \\\"v4\\\", 3);\\n        add_edge(&mut graph, \\\"v2\\\", \\\"v5\\\", 5);\\n        add_edge(&mut graph, \\\"v3\\\", \\\"v4\\\", 5);\\n        add_edge(&mut graph, \\\"v3\\\", \\\"v6\\\", 2);\\n        add_edge(&mut graph, \\\"v4\\\", \\\"v5\\\", 2);\\n        add_edge(&mut graph, \\\"v4\\\", \\\"v6\\\", 4);\\n        add_edge(&mut graph, \\\"v5\\\", \\\"v6\\\", 1);\\n\\n        let mut ans = BTreeMap::new();\\n        add_edge(&mut ans, \\\"v1\\\", \\\"v2\\\", 1);\\n        add_edge(&mut ans, \\\"v5\\\", \\\"v6\\\", 1);\\n        add_edge(&mut ans, \\\"v2\\\", \\\"v3\\\", 2);\\n        add_edge(&mut ans, \\\"v3\\\", \\\"v6\\\", 2);\\n        add_edge(&mut ans, \\\"v4\\\", \\\"v5\\\", 2);\\n\\n        assert_eq!(prim(&graph), ans);\\n    }\\n}\\n\"",
    "extended euclidean algorithm": "\"fn update_step(a: &mut i32, old_a: &mut i32, quotient: i32) {\\n    let temp = *a;\\n    *a = *old_a - quotient * temp;\\n    *old_a = temp;\\n}\\n\\npub fn extended_euclidean_algorithm(a: i32, b: i32) -> (i32, i32, i32) {\\n    let (mut old_r, mut rem) = (a, b);\\n    let (mut old_s, mut coeff_s) = (1, 0);\\n    let (mut old_t, mut coeff_t) = (0, 1);\\n\\n    while rem != 0 {\\n        let quotient = old_r / rem;\\n\\n        update_step(&mut rem, &mut old_r, quotient);\\n        update_step(&mut coeff_s, &mut old_s, quotient);\\n        update_step(&mut coeff_t, &mut old_t, quotient);\\n    }\\n\\n    (old_r, old_s, old_t)\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        assert_eq!(extended_euclidean_algorithm(101, 13), (1, 4, -31));\\n        assert_eq!(extended_euclidean_algorithm(123, 19), (1, -2, 13));\\n        assert_eq!(extended_euclidean_algorithm(25, 36), (1, 13, -9));\\n        assert_eq!(extended_euclidean_algorithm(69, 54), (3, -7, 9));\\n        assert_eq!(extended_euclidean_algorithm(55, 79), (1, 23, -16));\\n        assert_eq!(extended_euclidean_algorithm(33, 44), (11, -1, 1));\\n        assert_eq!(extended_euclidean_algorithm(50, 70), (10, 3, -2));\\n    }\\n}\\n\"",
    "greatest common divisor": "\"/// Greatest Common Divisor.\\n///\\n/// greatest_common_divisor(num1, num2) returns the greatest number of num1 and num2.\\n///\\n/// Wikipedia reference: https://en.wikipedia.org/wiki/Greatest_common_divisor\\n/// gcd(a, b) = gcd(a, -b) = gcd(-a, b) = gcd(-a, -b) by definition of divisibility\\n\\npub fn greatest_common_divisor_recursive(a: i64, b: i64) -> i64 {\\n    if a == 0 {\\n        b.abs()\\n    } else {\\n        greatest_common_divisor_recursive(b % a, a)\\n    }\\n}\\n\\npub fn greatest_common_divisor_iterative(mut a: i64, mut b: i64) -> i64 {\\n    while a != 0 {\\n        let remainder = b % a;\\n        b = a;\\n        a = remainder;\\n    }\\n    b.abs()\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn positive_number_recursive() {\\n        assert_eq!(greatest_common_divisor_recursive(4, 16), 4);\\n        assert_eq!(greatest_common_divisor_recursive(16, 4), 4);\\n        assert_eq!(greatest_common_divisor_recursive(3, 5), 1);\\n        assert_eq!(greatest_common_divisor_recursive(40, 40), 40);\\n        assert_eq!(greatest_common_divisor_recursive(27, 12), 3);\\n    }\\n\\n    #[test]\\n    fn positive_number_iterative() {\\n        assert_eq!(greatest_common_divisor_iterative(4, 16), 4);\\n        assert_eq!(greatest_common_divisor_iterative(16, 4), 4);\\n        assert_eq!(greatest_common_divisor_iterative(3, 5), 1);\\n        assert_eq!(greatest_common_divisor_iterative(40, 40), 40);\\n        assert_eq!(greatest_common_divisor_iterative(27, 12), 3);\\n    }\\n\\n    #[test]\\n    fn negative_number_recursive() {\\n        assert_eq!(greatest_common_divisor_recursive(-32, -8), 8);\\n        assert_eq!(greatest_common_divisor_recursive(-8, -32), 8);\\n        assert_eq!(greatest_common_divisor_recursive(-3, -5), 1);\\n        assert_eq!(greatest_common_divisor_recursive(-40, -40), 40);\\n        assert_eq!(greatest_common_divisor_recursive(-12, -27), 3);\\n    }\\n\\n    #[test]\\n    fn negative_number_iterative() {\\n        assert_eq!(greatest_common_divisor_iterative(-32, -8), 8);\\n        assert_eq!(greatest_common_divisor_iterative(-8, -32), 8);\\n        assert_eq!(greatest_common_divisor_iterative(-3, -5), 1);\\n        assert_eq!(greatest_common_divisor_iterative(-40, -40), 40);\\n        assert_eq!(greatest_common_divisor_iterative(-12, -27), 3);\\n    }\\n\\n    #[test]\\n    fn mix_recursive() {\\n        assert_eq!(greatest_common_divisor_recursive(0, -5), 5);\\n        assert_eq!(greatest_common_divisor_recursive(-5, 0), 5);\\n        assert_eq!(greatest_common_divisor_recursive(-64, 32), 32);\\n        assert_eq!(greatest_common_divisor_recursive(-32, 64), 32);\\n        assert_eq!(greatest_common_divisor_recursive(-40, 40), 40);\\n        assert_eq!(greatest_common_divisor_recursive(12, -27), 3);\\n    }\\n\\n    #[test]\\n    fn mix_iterative() {\\n        assert_eq!(greatest_common_divisor_iterative(0, -5), 5);\\n        assert_eq!(greatest_common_divisor_iterative(-5, 0), 5);\\n        assert_eq!(greatest_common_divisor_iterative(-64, 32), 32);\\n        assert_eq!(greatest_common_divisor_iterative(-32, 64), 32);\\n        assert_eq!(greatest_common_divisor_iterative(-40, 40), 40);\\n        assert_eq!(greatest_common_divisor_iterative(12, -27), 3);\\n    }\\n}\\n\"",
    "pascal triangle": "\"/// ## Paslcal's triangle problem\\n\\n/// pascal_triangle(num_rows) returns the first num_rows of Pascal's triangle.\\n/// About Pascal's triangle: https://en.wikipedia.org/wiki/Pascal%27s_triangle\\n///\\n/// Arguments:\\n///     * `num_rows` - number of rows of triangle\\n/// Complexity\\n///     - time complexity: O(n^2),\\n///     - space complexity: O(n^2),\\npub fn pascal_triangle(num_rows: i32) -> Vec<Vec<i32>> {\\n    let mut ans: Vec<Vec<i32>> = vec![];\\n\\n    for i in 1..num_rows + 1 {\\n        let mut vec: Vec<i32> = vec![1];\\n\\n        let mut res: i32 = 1;\\n        for k in 1..i {\\n            res *= i - k;\\n            res /= k;\\n            vec.push(res);\\n        }\\n        ans.push(vec);\\n    }\\n\\n    ans\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::pascal_triangle;\\n\\n    #[test]\\n    fn test() {\\n        assert_eq!(pascal_triangle(3), vec![vec![1], vec![1, 1], vec![1, 2, 1]]);\\n        assert_eq!(\\n            pascal_triangle(4),\\n            vec![vec![1], vec![1, 1], vec![1, 2, 1], vec![1, 3, 3, 1]]\\n        );\\n        assert_eq!(\\n            pascal_triangle(5),\\n            vec![\\n                vec![1],\\n                vec![1, 1],\\n                vec![1, 2, 1],\\n                vec![1, 3, 3, 1],\\n                vec![1, 4, 6, 4, 1]\\n            ]\\n        );\\n    }\\n}\\n\"",
    "perfect numbers": "\"pub fn is_perfect_number(num: usize) -> bool {\\n    let mut sum = 0;\\n\\n    for i in 1..num - 1 {\\n        if num % i == 0 {\\n            sum += i;\\n        }\\n    }\\n\\n    num == sum\\n}\\n\\npub fn perfect_numbers(max: usize) -> Vec<usize> {\\n    let mut result: Vec<usize> = Vec::new();\\n\\n    // It is not known if there are any odd perfect numbers, so we go around all the numbers.\\n    for i in 1..max + 1 {\\n        if is_perfect_number(i) {\\n            result.push(i);\\n        }\\n    }\\n\\n    result\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        assert_eq!(is_perfect_number(6), true);\\n        assert_eq!(is_perfect_number(28), true);\\n        assert_eq!(is_perfect_number(496), true);\\n        assert_eq!(is_perfect_number(8128), true);\\n\\n        assert_eq!(is_perfect_number(5), false);\\n        assert_eq!(is_perfect_number(86), false);\\n        assert_eq!(is_perfect_number(497), false);\\n        assert_eq!(is_perfect_number(8120), false);\\n\\n        assert_eq!(perfect_numbers(10), vec![6]);\\n        assert_eq!(perfect_numbers(100), vec![6, 28]);\\n        assert_eq!(perfect_numbers(496), vec![6, 28, 496]);\\n        assert_eq!(perfect_numbers(1000), vec![6, 28, 496]);\\n    }\\n}\\n\"",
    "prime check": "\"pub fn prime_check(num: usize) -> bool {\\n    if (num > 1) & (num < 4) {\\n        return true;\\n    } else if (num < 2) || (num % 2 == 0) {\\n        return false;\\n    }\\n\\n    let stop: usize = (num as f64).sqrt() as usize + 1;\\n    for i in (3..stop).step_by(2) {\\n        if num % i == 0 {\\n            return false;\\n        }\\n    }\\n    true\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        assert_eq!(prime_check(3), true);\\n        assert_eq!(prime_check(7), true);\\n        assert_eq!(prime_check(11), true);\\n        assert_eq!(prime_check(2003), true);\\n\\n        assert_eq!(prime_check(4), false);\\n        assert_eq!(prime_check(6), false);\\n        assert_eq!(prime_check(21), false);\\n        assert_eq!(prime_check(2004), false);\\n    }\\n}\\n\"",
    "prime numbers": "\"pub fn prime_numbers(max: usize) -> Vec<usize> {\\n    let mut result: Vec<usize> = Vec::new();\\n\\n    if max >= 2 {\\n        result.push(2)\\n    }\\n    for i in (3..max + 1).step_by(2) {\\n        let stop: usize = (i as f64).sqrt() as usize + 1;\\n        let mut status: bool = true;\\n\\n        for j in (3..stop).step_by(2) {\\n            if i % j == 0 {\\n                status = false\\n            }\\n        }\\n        if status {\\n            result.push(i)\\n        }\\n    }\\n\\n    result\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        assert_eq!(prime_numbers(0), vec![]);\\n        assert_eq!(prime_numbers(11), vec![2, 3, 5, 7, 11]);\\n        assert_eq!(prime_numbers(25), vec![2, 3, 5, 7, 11, 13, 17, 19, 23]);\\n        assert_eq!(\\n            prime_numbers(33),\\n            vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\\n        );\\n    }\\n}\\n\"",
    "trial division": "\"fn floor(value: f64, scale: u8) -> f64 {\\n    let multiplier = 10i64.pow(scale as u32) as f64;\\n    (value * multiplier).floor()\\n}\\n\\nfn double_to_int(amount: f64) -> i128 {\\n    amount.round() as i128\\n}\\n\\npub fn trial_division(mut num: i128) -> Vec<i128> {\\n    let mut result: Vec<i128> = vec![];\\n\\n    while num % 2 == 0 {\\n        result.push(2);\\n        num /= 2;\\n        num = double_to_int(floor(num as f64, 0))\\n    }\\n    let mut f: i128 = 3;\\n\\n    while f.pow(2) <= num {\\n        if num % f == 0 {\\n            result.push(f);\\n            num /= f;\\n            num = double_to_int(floor(num as f64, 0))\\n        } else {\\n            f += 2\\n        }\\n    }\\n\\n    if num != 1 {\\n        result.push(num)\\n    }\\n    result\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        assert_eq!(trial_division(9), vec!(3, 3));\\n        assert_eq!(trial_division(10), vec!(2, 5));\\n        assert_eq!(trial_division(11), vec!(11));\\n        assert_eq!(trial_division(33), vec!(3, 11));\\n        assert_eq!(trial_division(2003), vec!(2003));\\n        assert_eq!(trial_division(100001), vec!(11, 9091));\\n    }\\n}\\n\"",
    "binary search": "\"use std::cmp::Ordering;\\n\\npub fn binary_search<T: Ord>(item: &T, arr: &[T]) -> Option<usize> {\\n    let mut left = 0;\\n    let mut right = arr.len();\\n\\n    while left < right {\\n        let mid = left + (right - left) / 2;\\n\\n        match item.cmp(&arr[mid]) {\\n            Ordering::Less => right = mid,\\n            Ordering::Equal => return Some(mid),\\n            Ordering::Greater => left = mid + 1,\\n        }\\n    }\\n    None\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn empty() {\\n        let index = binary_search(&\\\"a\\\", &vec![]);\\n        assert_eq!(index, None);\\n    }\\n\\n    #[test]\\n    fn one_item() {\\n        let index = binary_search(&\\\"a\\\", &vec![\\\"a\\\"]);\\n        assert_eq!(index, Some(0));\\n    }\\n\\n    #[test]\\n    fn search_strings() {\\n        let index = binary_search(&\\\"a\\\", &vec![\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"google\\\", \\\"zoo\\\"]);\\n        assert_eq!(index, Some(0));\\n    }\\n\\n    #[test]\\n    fn search_ints() {\\n        let index = binary_search(&4, &vec![1, 2, 3, 4]);\\n        assert_eq!(index, Some(3));\\n\\n        let index = binary_search(&3, &vec![1, 2, 3, 4]);\\n        assert_eq!(index, Some(2));\\n\\n        let index = binary_search(&2, &vec![1, 2, 3, 4]);\\n        assert_eq!(index, Some(1));\\n\\n        let index = binary_search(&1, &vec![1, 2, 3, 4]);\\n        assert_eq!(index, Some(0));\\n    }\\n\\n    #[test]\\n    fn not_found() {\\n        let index = binary_search(&5, &vec![1, 2, 3, 4]);\\n        assert_eq!(index, None);\\n    }\\n}\\n\"",
    "binary search recursive": "\"use std::cmp::Ordering;\\n\\npub fn binary_search_rec<T: Ord>(\\n    list_of_items: &[T],\\n    target: &T,\\n    left: &usize,\\n    right: &usize,\\n) -> Option<usize> {\\n    if left >= right {\\n        return None;\\n    }\\n\\n    let middle: usize = left + (right - left) / 2;\\n    match target.cmp(&list_of_items[middle]) {\\n        Ordering::Less => binary_search_rec(list_of_items, target, left, &middle),\\n        Ordering::Greater => binary_search_rec(list_of_items, target, &(middle + 1), right),\\n        Ordering::Equal => Some(middle),\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    const LEFT: usize = 0;\\n\\n    #[test]\\n    fn fail_empty_list() {\\n        let list_of_items = vec![];\\n        assert_eq!(\\n            binary_search_rec(&list_of_items, &1, &LEFT, &list_of_items.len()),\\n            None\\n        );\\n    }\\n\\n    #[test]\\n    fn success_one_item() {\\n        let list_of_items = vec![30];\\n        assert_eq!(\\n            binary_search_rec(&list_of_items, &30, &LEFT, &list_of_items.len()),\\n            Some(0)\\n        );\\n    }\\n\\n    #[test]\\n    fn success_search_strings() {\\n        let say_hello_list = vec![\\\"hi\\\", \\\"olá\\\", \\\"salut\\\"];\\n        let right = say_hello_list.len();\\n        assert_eq!(\\n            binary_search_rec(&say_hello_list, &\\\"hi\\\", &LEFT, &right),\\n            Some(0)\\n        );\\n        assert_eq!(\\n            binary_search_rec(&say_hello_list, &\\\"salut\\\", &LEFT, &right),\\n            Some(2)\\n        );\\n    }\\n\\n    #[test]\\n    fn fail_search_strings() {\\n        let say_hello_list = vec![\\\"hi\\\", \\\"olá\\\", \\\"salut\\\"];\\n        for target in &[\\\"adiós\\\", \\\"你好\\\"] {\\n            assert_eq!(\\n                binary_search_rec(&say_hello_list, target, &LEFT, &say_hello_list.len()),\\n                None\\n            );\\n        }\\n    }\\n\\n    #[test]\\n    fn success_search_integers() {\\n        let integers = vec![0, 10, 20, 30, 40, 50, 60, 70, 80, 90];\\n        for (index, target) in integers.iter().enumerate() {\\n            assert_eq!(\\n                binary_search_rec(&integers, target, &LEFT, &integers.len()),\\n                Some(index)\\n            )\\n        }\\n    }\\n\\n    #[test]\\n    fn fail_search_integers() {\\n        let integers = vec![0, 10, 20, 30, 40, 50, 60, 70, 80, 90];\\n        for target in &[100, 444, 336] {\\n            assert_eq!(\\n                binary_search_rec(&integers, target, &LEFT, &integers.len()),\\n                None\\n            );\\n        }\\n    }\\n\\n    #[test]\\n    fn fail_search_unsorted_strings_list() {\\n        let unsorted_strings = vec![\\\"salut\\\", \\\"olá\\\", \\\"hi\\\"];\\n        for target in &[\\\"hi\\\", \\\"salut\\\"] {\\n            assert_eq!(\\n                binary_search_rec(&unsorted_strings, target, &LEFT, &unsorted_strings.len()),\\n                None\\n            );\\n        }\\n    }\\n\\n    #[test]\\n    fn fail_search_unsorted_integers_list() {\\n        let unsorted_integers = vec![90, 80, 70, 60, 50, 40, 30, 20, 10, 0];\\n        for target in &[0, 80, 90] {\\n            assert_eq!(\\n                binary_search_rec(&unsorted_integers, target, &LEFT, &unsorted_integers.len()),\\n                None\\n            );\\n        }\\n    }\\n\\n    #[test]\\n    fn success_search_string_in_middle_of_unsorted_list() {\\n        let unsorted_strings = vec![\\\"salut\\\", \\\"olá\\\", \\\"hi\\\"];\\n        assert_eq!(\\n            binary_search_rec(&unsorted_strings, &\\\"olá\\\", &LEFT, &unsorted_strings.len()),\\n            Some(1)\\n        );\\n    }\\n\\n    #[test]\\n    fn success_search_integer_in_middle_of_unsorted_list() {\\n        let unsorted_integers = vec![90, 80, 70];\\n        assert_eq!(\\n            binary_search_rec(&unsorted_integers, &80, &LEFT, &unsorted_integers.len()),\\n            Some(1)\\n        );\\n    }\\n}\\n\"",
    "kth smallest": "\"use crate::sorting::partition;\\nuse std::cmp::{Ordering, PartialOrd};\\n\\n/// Returns k-th smallest element of an array, i.e. its order statistics.\\n/// Time complexity is O(n^2) in the worst case, but only O(n) on average.\\n/// It mutates the input, and therefore does not require additional space.\\npub fn kth_smallest<T>(input: &mut [T], k: usize) -> Option<T>\\nwhere\\n    T: PartialOrd + Copy,\\n{\\n    if input.is_empty() {\\n        return None;\\n    }\\n\\n    let kth = _kth_smallest(input, k, 0, input.len() - 1);\\n    Some(kth)\\n}\\n\\nfn _kth_smallest<T>(input: &mut [T], k: usize, lo: usize, hi: usize) -> T\\nwhere\\n    T: PartialOrd + Copy,\\n{\\n    if lo == hi {\\n        return input[lo];\\n    }\\n\\n    let pivot = partition(input, lo as isize, hi as isize) as usize;\\n    let i = pivot - lo + 1;\\n\\n    match k.cmp(&i) {\\n        Ordering::Equal => input[pivot],\\n        Ordering::Less => _kth_smallest(input, k, lo, pivot - 1),\\n        Ordering::Greater => _kth_smallest(input, k - i, pivot + 1, hi),\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn empty() {\\n        let mut zero: [u8; 0] = [];\\n        let first = kth_smallest(&mut zero, 1);\\n\\n        assert_eq!(None, first);\\n    }\\n\\n    #[test]\\n    fn one_element() {\\n        let mut one = [1];\\n        let first = kth_smallest(&mut one, 1);\\n\\n        assert_eq!(1, first.unwrap());\\n    }\\n\\n    #[test]\\n    fn many_elements() {\\n        // 0 1 3 4 5 7 8 9 9 10 12 13 16 17\\n        let mut many = [9, 17, 3, 16, 13, 10, 1, 5, 7, 12, 4, 8, 9, 0];\\n\\n        let first = kth_smallest(&mut many, 1);\\n        let third = kth_smallest(&mut many, 3);\\n        let sixth = kth_smallest(&mut many, 6);\\n        let fourteenth = kth_smallest(&mut many, 14);\\n\\n        assert_eq!(0, first.unwrap());\\n        assert_eq!(3, third.unwrap());\\n        assert_eq!(7, sixth.unwrap());\\n        assert_eq!(17, fourteenth.unwrap());\\n    }\\n}\\n\"",
    "linear search": "\"use std::cmp::PartialEq;\\n\\npub fn linear_search<T: PartialEq>(item: &T, arr: &[T]) -> Option<usize> {\\n    for (i, data) in arr.iter().enumerate() {\\n        if item == data {\\n            return Some(i);\\n        }\\n    }\\n\\n    None\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn search_strings() {\\n        let index = linear_search(&\\\"a\\\", &vec![\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"google\\\", \\\"zoo\\\"]);\\n        assert_eq!(index, Some(0));\\n    }\\n\\n    #[test]\\n    fn search_ints() {\\n        let index = linear_search(&4, &vec![1, 2, 3, 4]);\\n        assert_eq!(index, Some(3));\\n\\n        let index = linear_search(&3, &vec![1, 2, 3, 4]);\\n        assert_eq!(index, Some(2));\\n\\n        let index = linear_search(&2, &vec![1, 2, 3, 4]);\\n        assert_eq!(index, Some(1));\\n\\n        let index = linear_search(&1, &vec![1, 2, 3, 4]);\\n        assert_eq!(index, Some(0));\\n    }\\n\\n    #[test]\\n    fn not_found() {\\n        let index = linear_search(&5, &vec![1, 2, 3, 4]);\\n        assert_eq!(index, None);\\n    }\\n\\n    #[test]\\n    fn empty() {\\n        let index = linear_search(&1, &vec![]);\\n        assert_eq!(index, None);\\n    }\\n}\\n\"",
    "bubble sort": "\"pub fn bubble_sort<T: Ord>(arr: &mut [T]) {\\n    for i in 0..arr.len() {\\n        for j in 0..arr.len() - 1 - i {\\n            if arr[j] > arr[j + 1] {\\n                arr.swap(j, j + 1);\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn descending() {\\n        //descending\\n        let mut ve1 = vec![6, 5, 4, 3, 2, 1];\\n        bubble_sort(&mut ve1);\\n        for i in 0..ve1.len() - 1 {\\n            assert!(ve1[i] <= ve1[i + 1]);\\n        }\\n    }\\n\\n    #[test]\\n    fn ascending() {\\n        //pre-sorted\\n        let mut ve2 = vec![1, 2, 3, 4, 5, 6];\\n        bubble_sort(&mut ve2);\\n        for i in 0..ve2.len() - 1 {\\n            assert!(ve2[i] <= ve2[i + 1]);\\n        }\\n    }\\n}\\n\"",
    "bucket sort": "\"/// Sort a slice using bucket sort algorithm.\\n///\\n/// Time complexity is `O(n + k)` on average, where `n` is the number of elements,\\n/// `k` is the number of buckets used in process.\\n///\\n/// Space complexity is `O(n + k)`, as it sorts not in-place.\\npub fn bucket_sort(arr: &[usize]) -> Vec<usize> {\\n    if arr.is_empty() {\\n        return vec![];\\n    }\\n\\n    let max = *arr.iter().max().unwrap();\\n    let len = arr.len();\\n    let mut buckets = vec![vec![]; len + 1];\\n\\n    for x in arr {\\n        buckets[len * *x / max].push(*x);\\n    }\\n\\n    for bucket in buckets.iter_mut() {\\n        super::insertion_sort(bucket);\\n    }\\n\\n    let mut result = vec![];\\n    for bucket in buckets {\\n        for x in bucket {\\n            result.push(x);\\n        }\\n    }\\n\\n    result\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::super::is_sorted;\\n    use super::*;\\n\\n    #[test]\\n    fn empty() {\\n        let arr: [usize; 0] = [];\\n        let res = bucket_sort(&arr);\\n        assert!(is_sorted(&res));\\n    }\\n\\n    #[test]\\n    fn one_element() {\\n        let arr: [usize; 1] = [4];\\n        let res = bucket_sort(&arr);\\n        assert!(is_sorted(&res));\\n    }\\n\\n    #[test]\\n    fn already_sorted() {\\n        let arr: [usize; 3] = [10, 9, 105];\\n        let res = bucket_sort(&arr);\\n        assert!(is_sorted(&res));\\n    }\\n\\n    #[test]\\n    fn basic() {\\n        let arr: [usize; 4] = [35, 53, 1, 0];\\n        let res = bucket_sort(&arr);\\n        assert!(is_sorted(&res));\\n    }\\n\\n    #[test]\\n    fn odd_number_of_elements() {\\n        let arr: Vec<usize> = vec![1, 21, 5, 11, 58];\\n        let res = bucket_sort(&arr);\\n        assert!(is_sorted(&res));\\n    }\\n\\n    #[test]\\n    fn repeated_elements() {\\n        let arr: Vec<usize> = vec![542, 542, 542, 542];\\n        let res = bucket_sort(&arr);\\n        assert!(is_sorted(&res));\\n    }\\n}\\n\"",
    "cocktail shaker sort": "\"pub fn cocktail_shaker_sort<T: Ord>(arr: &mut [T]) {\\n    let len = arr.len();\\n\\n    if len == 0 {\\n        return;\\n    }\\n\\n    loop {\\n        let mut swapped = false;\\n\\n        for i in 0..(len - 1).clamp(0, len) {\\n            if arr[i] > arr[i + 1] {\\n                arr.swap(i, i + 1);\\n                swapped = true;\\n            }\\n        }\\n\\n        if !swapped {\\n            break;\\n        }\\n\\n        swapped = false;\\n\\n        for i in (0..(len - 1).clamp(0, len)).rev() {\\n            if arr[i] > arr[i + 1] {\\n                arr.swap(i, i + 1);\\n                swapped = true;\\n            }\\n        }\\n\\n        if !swapped {\\n            break;\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        let mut arr = vec![5, 2, 1, 3, 4, 6];\\n        cocktail_shaker_sort(&mut arr);\\n        assert_eq!(arr, vec![1, 2, 3, 4, 5, 6]);\\n    }\\n\\n    #[test]\\n    fn empty() {\\n        let mut arr = Vec::<i32>::new();\\n        cocktail_shaker_sort(&mut arr);\\n        assert_eq!(arr, vec![]);\\n    }\\n\\n    #[test]\\n    fn one_element() {\\n        let mut arr = vec![1];\\n        cocktail_shaker_sort(&mut arr);\\n        assert_eq!(arr, vec![1]);\\n    }\\n\\n    #[test]\\n    fn pre_sorted() {\\n        let mut arr = vec![1, 2, 3, 4, 5, 6];\\n        cocktail_shaker_sort(&mut arr);\\n        assert_eq!(arr, vec![1, 2, 3, 4, 5, 6]);\\n    }\\n}\\n\"",
    "comb sort": "\"pub fn comb_sort<T: Ord>(arr: &mut [T]) {\\n    let mut gap = arr.len();\\n    let shrink = 1.3;\\n    let mut sorted = false;\\n\\n    while !sorted {\\n        gap = (gap as f32 / shrink).floor() as usize;\\n        if gap <= 1 {\\n            gap = 1;\\n            sorted = true;\\n        }\\n        for i in 0..arr.len() - gap {\\n            let j = i + gap;\\n            if arr[i] > arr[j] {\\n                arr.swap(i, j);\\n                sorted = false;\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn descending() {\\n        //descending\\n        let mut ve1 = vec![6, 5, 4, 3, 2, 1];\\n        comb_sort(&mut ve1);\\n        for i in 0..ve1.len() - 1 {\\n            assert!(ve1[i] <= ve1[i + 1]);\\n        }\\n    }\\n\\n    #[test]\\n    fn ascending() {\\n        //pre-sorted\\n        let mut ve2 = vec![1, 2, 3, 4, 5, 6];\\n        comb_sort(&mut ve2);\\n        for i in 0..ve2.len() - 1 {\\n            assert!(ve2[i] <= ve2[i + 1]);\\n        }\\n    }\\n}\\n\"",
    "counting sort": "\"/// In place counting sort for collections of u32\\n/// O(n + maxval) in time, where maxval is the biggest value an input can possibly take\\n/// O(maxval) in memory\\n/// u32 is chosen arbitrarly, a counting sort probably should'nt be used on data that requires bigger types.\\n\\npub fn counting_sort(arr: &mut [u32], maxval: usize) {\\n    let mut occurences: Vec<usize> = vec![0; maxval + 1];\\n\\n    for &data in arr.iter() {\\n        occurences[data as usize] += 1;\\n    }\\n\\n    let mut i = 0;\\n    for (data, &number) in occurences.iter().enumerate() {\\n        for _ in 0..number {\\n            arr[i] = data as u32;\\n            i += 1;\\n        }\\n    }\\n}\\n\\nuse std::ops::AddAssign;\\n/// Generic implementation of a counting sort for all usigned types\\npub fn generic_counting_sort<T: Into<u64> + From<u8> + AddAssign + Copy>(\\n    arr: &mut [T],\\n    maxval: usize,\\n) {\\n    let mut occurences: Vec<usize> = vec![0; maxval + 1];\\n\\n    for &data in arr.iter() {\\n        occurences[data.into() as usize] += 1;\\n    }\\n\\n    // Current index in output array\\n    let mut i = 0;\\n\\n    // current data point, necessary to be type-safe\\n    let mut data = T::from(0);\\n\\n    // This will iterate from 0 to the largest data point in `arr`\\n    // `number` contains the occurances of the data point `data`\\n    for &number in occurences.iter() {\\n        for _ in 0..number {\\n            arr[i] = data;\\n            i += 1;\\n        }\\n\\n        data += T::from(1);\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::super::is_sorted;\\n    use super::*;\\n\\n    #[test]\\n    fn counting_sort_descending() {\\n        let mut ve1 = vec![6, 5, 4, 3, 2, 1];\\n        counting_sort(&mut ve1, 6);\\n\\n        assert!(is_sorted(&ve1));\\n    }\\n\\n    #[test]\\n    fn counting_sort_pre_sorted() {\\n        let mut ve2 = vec![1, 2, 3, 4, 5, 6];\\n        counting_sort(&mut ve2, 6);\\n\\n        assert!(is_sorted(&ve2));\\n    }\\n\\n    #[test]\\n    fn generic_counting_sort() {\\n        let mut ve1: Vec<u8> = vec![100, 30, 60, 10, 20, 120, 1];\\n        super::generic_counting_sort(&mut ve1, 120);\\n\\n        assert!(is_sorted(&ve1));\\n    }\\n\\n    #[test]\\n    fn presorted_u64_counting_sort() {\\n        let mut ve2: Vec<u64> = vec![1, 2, 3, 4, 5, 6];\\n        super::generic_counting_sort(&mut ve2, 6);\\n\\n        assert!(is_sorted(&ve2));\\n    }\\n}\\n\"",
    "gnome sort": "\"use std::cmp;\\n\\npub fn gnome_sort<T>(arr: &[T]) -> Vec<T>\\nwhere\\n    T: cmp::PartialEq + cmp::PartialOrd + Clone,\\n{\\n    let mut arr = arr.to_vec();\\n    let mut i: usize = 1;\\n    let mut j: usize = 2;\\n\\n    while i < arr.len() {\\n        if arr[i - 1] < arr[i] {\\n            i = j;\\n            j = i + 1;\\n        } else {\\n            arr.swap(i - 1, i);\\n            i -= 1;\\n            if i == 0 {\\n                i = j;\\n                j += 1;\\n            }\\n        }\\n    }\\n    arr\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        let res = gnome_sort(&vec![6, 5, -8, 3, 2, 3]);\\n        assert_eq!(res, vec![-8, 2, 3, 3, 5, 6]);\\n    }\\n\\n    #[test]\\n    fn already_sorted() {\\n        let res = gnome_sort(&vec![\\\"a\\\", \\\"b\\\", \\\"c\\\"]);\\n        assert_eq!(res, vec![\\\"a\\\", \\\"b\\\", \\\"c\\\"]);\\n    }\\n\\n    #[test]\\n    fn odd_number_of_elements() {\\n        let res = gnome_sort(&vec![\\\"d\\\", \\\"a\\\", \\\"c\\\", \\\"e\\\", \\\"b\\\"]);\\n        assert_eq!(res, vec![\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\"]);\\n    }\\n\\n    #[test]\\n    fn one_element() {\\n        let res = gnome_sort(&vec![3]);\\n        assert_eq!(res, vec![3]);\\n    }\\n\\n    #[test]\\n    fn empty() {\\n        let res = gnome_sort(&Vec::<u8>::new());\\n        assert_eq!(res, vec![]);\\n    }\\n}\\n\"",
    "heap sort": "\"/// Sort a mutable slice using heap sort.\\n///\\n/// Heap sort is an in-place O(n log n) sorting algorithm. It is based on a\\n/// max heap, a binary tree data structure whose main feature is that\\n/// parent nodes are always greater or equal to their child nodes.\\n///\\n/// # Max Heap Implementation\\n///\\n/// A max heap can be efficiently implemented with an array.\\n/// For example, the binary tree:\\n/// ```text\\n///     1\\n///  2     3\\n/// 4 5   6 7\\n/// ```\\n///\\n/// ... is represented by the following array:\\n/// ```text\\n/// 1 23 4567\\n/// ```\\n///\\n/// Given the index `i` of a node, parent and child indices can be calculated\\n/// as follows:\\n/// ```text\\n/// parent(i)      = (i-1) / 2\\n/// left_child(i)  = 2*i + 1\\n/// right_child(i) = 2*i + 2\\n/// ```\\n\\n/// # Algorithm\\n///\\n/// Heap sort has two steps:\\n///   1. Convert the input array to a max heap.\\n///   2. Partition the array into heap part and sorted part. Initially the\\n///      heap consists of the whole array and the sorted part is empty:\\n///      ```text\\n///      arr: [ heap                    |]\\n///      ```\\n///\\n///      Repeatedly swap the root (i.e. the largest) element of the heap with\\n///      the last element of the heap and increase the sorted part by one:\\n///      ```text\\n///      arr: [ root ...   last | sorted ]\\n///       --> [ last ... | root   sorted ]\\n///      ```\\n///\\n///      After each swap, fix the heap to make it a valid max heap again.\\n///      Once the heap is empty, `arr` is completely sorted.\\npub fn heap_sort<T: Ord>(arr: &mut [T]) {\\n    if arr.len() <= 1 {\\n        return; // already sorted\\n    }\\n\\n    heapify(arr);\\n\\n    for end in (1..arr.len()).rev() {\\n        arr.swap(0, end);\\n        move_down(&mut arr[..end], 0);\\n    }\\n}\\n\\n/// Convert `arr` into a max heap.\\nfn heapify<T: Ord>(arr: &mut [T]) {\\n    let last_parent = (arr.len() - 2) / 2;\\n    for i in (0..=last_parent).rev() {\\n        move_down(arr, i);\\n    }\\n}\\n\\n/// Move the element at `root` down until `arr` is a max heap again.\\n///\\n/// This assumes that the subtrees under `root` are valid max heaps already.\\nfn move_down<T: Ord>(arr: &mut [T], mut root: usize) {\\n    let last = arr.len() - 1;\\n    loop {\\n        let left = 2 * root + 1;\\n        if left > last {\\n            break;\\n        }\\n        let right = left + 1;\\n        let max = if right <= last && arr[right] > arr[left] {\\n            right\\n        } else {\\n            left\\n        };\\n\\n        if arr[max] > arr[root] {\\n            arr.swap(root, max);\\n        }\\n        root = max;\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn empty() {\\n        let mut arr: Vec<i32> = Vec::new();\\n        heap_sort(&mut arr);\\n        assert_eq!(&arr, &[]);\\n    }\\n\\n    #[test]\\n    fn single_element() {\\n        let mut arr = vec![1];\\n        heap_sort(&mut arr);\\n        assert_eq!(&arr, &[1]);\\n    }\\n\\n    #[test]\\n    fn sorted_array() {\\n        let mut arr = vec![1, 2, 3, 4];\\n        heap_sort(&mut arr);\\n        assert_eq!(&arr, &[1, 2, 3, 4]);\\n    }\\n\\n    #[test]\\n    fn unsorted_array() {\\n        let mut arr = vec![3, 4, 2, 1];\\n        heap_sort(&mut arr);\\n        assert_eq!(&arr, &[1, 2, 3, 4]);\\n    }\\n\\n    #[test]\\n    fn odd_number_of_elements() {\\n        let mut arr = vec![3, 4, 2, 1, 7];\\n        heap_sort(&mut arr);\\n        assert_eq!(&arr, &[1, 2, 3, 4, 7]);\\n    }\\n\\n    #[test]\\n    fn repeated_elements() {\\n        let mut arr = vec![542, 542, 542, 542];\\n        heap_sort(&mut arr);\\n        assert_eq!(&arr, &vec![542, 542, 542, 542]);\\n    }\\n}\\n\"",
    "insertion sort": "\"use std::cmp;\\n\\n/// Sorts a mutable slice using in-place insertion sort algorithm.\\n///\\n/// Time complexity is `O(n^2)`, where `n` is the number of elements.\\n/// Space complexity is `O(1)` as it sorts elements in-place.\\npub fn insertion_sort<T>(arr: &mut [T])\\nwhere\\n    T: cmp::PartialOrd + Copy,\\n{\\n    for i in 1..arr.len() {\\n        let cur = arr[i];\\n        let mut j = i - 1;\\n\\n        while arr[j] > cur {\\n            arr.swap(j + 1, j);\\n            if j == 0 {\\n                break;\\n            }\\n            j -= 1;\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::super::is_sorted;\\n    use super::*;\\n\\n    #[test]\\n    fn empty() {\\n        let mut arr: [u8; 0] = [];\\n        insertion_sort(&mut arr);\\n        assert!(is_sorted(&arr));\\n    }\\n\\n    #[test]\\n    fn one_element() {\\n        let mut arr: [char; 1] = ['a'];\\n        insertion_sort(&mut arr);\\n        assert!(is_sorted(&arr));\\n    }\\n\\n    #[test]\\n    fn already_sorted() {\\n        let mut arr: [&str; 3] = [\\\"a\\\", \\\"b\\\", \\\"c\\\"];\\n        insertion_sort(&mut arr);\\n        assert!(is_sorted(&arr));\\n    }\\n\\n    #[test]\\n    fn basic() {\\n        let mut arr: [&str; 4] = [\\\"d\\\", \\\"a\\\", \\\"c\\\", \\\"b\\\"];\\n        insertion_sort(&mut arr);\\n        assert!(is_sorted(&arr));\\n    }\\n\\n    #[test]\\n    fn odd_number_of_elements() {\\n        let mut arr: Vec<&str> = vec![\\\"d\\\", \\\"a\\\", \\\"c\\\", \\\"e\\\", \\\"b\\\"];\\n        insertion_sort(&mut arr);\\n        assert!(is_sorted(&arr));\\n    }\\n\\n    #[test]\\n    fn repeated_elements() {\\n        let mut arr: Vec<usize> = vec![542, 542, 542, 542];\\n        insertion_sort(&mut arr);\\n        assert!(is_sorted(&arr));\\n    }\\n}\\n\"",
    "merge sort": "\"fn _merge<T: Ord + Copy>(arr: &mut [T], lo: usize, mid: usize, hi: usize) {\\n    // create temporary arrays to support merge\\n    let mut left_half = Vec::new();\\n    let mut right_half = Vec::new();\\n    for v in arr.iter().take(mid + 1).skip(lo) {\\n        left_half.push(*v);\\n    }\\n    for v in arr.iter().take(hi + 1).skip(mid + 1) {\\n        right_half.push(*v);\\n    }\\n\\n    let lsize = left_half.len();\\n    let rsize = right_half.len();\\n\\n    // pointers to track the positions while merging\\n    let mut l = 0;\\n    let mut r = 0;\\n    let mut a = lo;\\n\\n    // pick smaller element one by one from either left or right half\\n    while l < lsize && r < rsize {\\n        if left_half[l] < right_half[r] {\\n            arr[a] = left_half[l];\\n            l += 1;\\n        } else {\\n            arr[a] = right_half[r];\\n            r += 1;\\n        }\\n        a += 1;\\n    }\\n\\n    // put all the remaining ones\\n    while l < lsize {\\n        arr[a] = left_half[l];\\n        l += 1;\\n        a += 1;\\n    }\\n\\n    while r < rsize {\\n        arr[a] = right_half[r];\\n        r += 1;\\n        a += 1;\\n    }\\n}\\n\\nfn _merge_sort<T: Ord + Copy>(arr: &mut [T], lo: usize, hi: usize) {\\n    if lo < hi {\\n        let mid = lo + (hi - lo) / 2;\\n        _merge_sort(arr, lo, mid);\\n        _merge_sort(arr, mid + 1, hi);\\n        _merge(arr, lo, mid, hi);\\n    }\\n}\\n\\npub fn merge_sort<T: Ord + Copy>(arr: &mut [T]) {\\n    let len = arr.len();\\n    if len > 1 {\\n        _merge_sort(arr, 0, len - 1);\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        let mut res = vec![10, 8, 4, 3, 1, 9, 2, 7, 5, 6];\\n        merge_sort(&mut res);\\n        assert_eq!(res, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\\n    }\\n\\n    #[test]\\n    fn basic_string() {\\n        let mut res = vec![\\\"a\\\", \\\"bb\\\", \\\"d\\\", \\\"cc\\\"];\\n        merge_sort(&mut res);\\n        assert_eq!(res, vec![\\\"a\\\", \\\"bb\\\", \\\"cc\\\", \\\"d\\\"]);\\n    }\\n\\n    #[test]\\n    fn empty() {\\n        let mut res = Vec::<u8>::new();\\n        merge_sort(&mut res);\\n        assert_eq!(res, vec![]);\\n    }\\n\\n    #[test]\\n    fn one_element() {\\n        let mut res = vec![1];\\n        merge_sort(&mut res);\\n        assert_eq!(res, vec![1]);\\n    }\\n\\n    #[test]\\n    fn pre_sorted() {\\n        let mut res = vec![1, 2, 3, 4];\\n        merge_sort(&mut res);\\n        assert_eq!(res, vec![1, 2, 3, 4]);\\n    }\\n\\n    #[test]\\n    fn reverse_sorted() {\\n        let mut res = vec![4, 3, 2, 1];\\n        merge_sort(&mut res);\\n        assert_eq!(res, vec![1, 2, 3, 4]);\\n    }\\n}\\n\"",
    "odd even sort": "\"pub fn odd_even_sort<T: Ord>(arr: &mut [T]) {\\n    let len = arr.len();\\n    if len == 0 {\\n        return;\\n    }\\n\\n    let mut sorted = false;\\n    while !sorted {\\n        sorted = true;\\n\\n        for i in (1..len - 1).step_by(2) {\\n            if arr[i] > arr[i + 1] {\\n                arr.swap(i, i + 1);\\n                sorted = false;\\n            }\\n        }\\n\\n        for i in (0..len - 1).step_by(2) {\\n            if arr[i] > arr[i + 1] {\\n                arr.swap(i, i + 1);\\n                sorted = false;\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        let mut arr = vec![3, 5, 1, 2, 4, 6];\\n        odd_even_sort(&mut arr);\\n        assert_eq!(arr, vec![1, 2, 3, 4, 5, 6]);\\n    }\\n\\n    #[test]\\n    fn empty() {\\n        let mut arr = Vec::<i32>::new();\\n        odd_even_sort(&mut arr);\\n        assert_eq!(arr, vec![]);\\n    }\\n\\n    #[test]\\n    fn one_element() {\\n        let mut arr = vec![3];\\n        odd_even_sort(&mut arr);\\n        assert_eq!(arr, vec![3]);\\n    }\\n\\n    #[test]\\n    fn pre_sorted() {\\n        let mut arr = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\\n        odd_even_sort(&mut arr);\\n        assert_eq!(arr, vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\\n    }\\n}\\n\"",
    "quick sort": "\"use std::cmp::PartialOrd;\\n\\npub fn partition<T: PartialOrd>(arr: &mut [T], lo: isize, hi: isize) -> isize {\\n    let pivot = hi as usize;\\n    let mut i = lo - 1;\\n    let mut j = hi;\\n\\n    loop {\\n        i += 1;\\n        while arr[i as usize] < arr[pivot] {\\n            i += 1;\\n        }\\n        j -= 1;\\n        while j >= 0 && arr[j as usize] > arr[pivot] {\\n            j -= 1;\\n        }\\n        if i >= j {\\n            break;\\n        } else {\\n            arr.swap(i as usize, j as usize);\\n        }\\n    }\\n    arr.swap(i as usize, pivot as usize);\\n    i\\n}\\nfn _quick_sort<T: Ord>(arr: &mut [T], lo: isize, hi: isize) {\\n    if lo < hi {\\n        let p = partition(arr, lo, hi);\\n        _quick_sort(arr, lo, p - 1);\\n        _quick_sort(arr, p + 1, hi);\\n    }\\n}\\npub fn quick_sort<T: Ord>(arr: &mut [T]) {\\n    let len = arr.len();\\n    _quick_sort(arr, 0, (len - 1) as isize);\\n}\\n\"",
    "radix sort": "\"/// Sorts the elements of `arr` in-place using radix sort.\\n///\\n/// Time complexity is `O((n + b) * logb(k))`, where `n` is the number of elements,\\n/// `b` is the base (the radix), and `k` is the largest element.\\n/// When `n` and `b` are roughly the same maginitude, this algorithm runs in linear time.\\n///\\n/// Space complexity is `O(n + b)`.\\npub fn radix_sort(arr: &mut [u64]) {\\n    let max: usize = match arr.iter().max() {\\n        Some(&x) => x as usize,\\n        None => return,\\n    };\\n    // Make radix a power of 2 close to arr.len() for optimal runtime\\n    let radix = arr.len().next_power_of_two();\\n    // Counting sort by each digit from least to most significant\\n    let mut place = 1;\\n    while place <= max {\\n        let digit_of = |x| x as usize / place % radix;\\n        // Count digit occurrences\\n        let mut counter = vec![0; radix];\\n        for &x in arr.iter() {\\n            counter[digit_of(x)] += 1;\\n        }\\n        // Compute last index of each digit\\n        for i in 1..radix {\\n            counter[i] += counter[i - 1];\\n        }\\n        // Write elements to their new indices\\n        for &x in arr.to_owned().iter().rev() {\\n            counter[digit_of(x)] -= 1;\\n            arr[counter[digit_of(x)]] = x;\\n        }\\n        place *= radix;\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::super::is_sorted;\\n    use super::radix_sort;\\n\\n    #[test]\\n    fn empty() {\\n        let mut a: [u64; 0] = [];\\n        radix_sort(&mut a);\\n        assert!(is_sorted(&a));\\n    }\\n\\n    #[test]\\n    fn descending() {\\n        let mut v = vec![201, 127, 64, 37, 24, 4, 1];\\n        radix_sort(&mut v);\\n        assert!(is_sorted(&v));\\n    }\\n\\n    #[test]\\n    fn ascending() {\\n        let mut v = vec![1, 4, 24, 37, 64, 127, 201];\\n        radix_sort(&mut v);\\n        assert!(is_sorted(&v));\\n    }\\n}\\n\"",
    "selection sort": "\"pub fn selection_sort<T: Ord>(arr: &mut [T]) {\\n    let len = arr.len();\\n    for left in 0..len {\\n        let mut smallest = left;\\n        for right in (left + 1)..len {\\n            if arr[right] < arr[smallest] {\\n                smallest = right;\\n            }\\n        }\\n        arr.swap(smallest, left);\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        let mut res = vec![\\\"d\\\", \\\"a\\\", \\\"c\\\", \\\"b\\\"];\\n        selection_sort(&mut res);\\n        assert_eq!(res, vec![\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"]);\\n    }\\n\\n    #[test]\\n    fn empty() {\\n        let mut res = Vec::<u8>::new();\\n        selection_sort(&mut res);\\n        assert_eq!(res, vec![]);\\n    }\\n\\n    #[test]\\n    fn one_element() {\\n        let mut res = vec![\\\"a\\\"];\\n        selection_sort(&mut res);\\n        assert_eq!(res, vec![\\\"a\\\"]);\\n    }\\n\\n    #[test]\\n    fn pre_sorted() {\\n        let mut res = vec![\\\"a\\\", \\\"b\\\", \\\"c\\\"];\\n        selection_sort(&mut res);\\n        assert_eq!(res, vec![\\\"a\\\", \\\"b\\\", \\\"c\\\"]);\\n    }\\n}\\n\"",
    "shell sort": "\"pub fn shell_sort<T: Ord + Copy>(values: &mut Vec<T>) {\\n    // shell sort works by swiping the value at a given gap and decreasing the gap to 1\\n    fn insertion<T: Ord + Copy>(values: &mut Vec<T>, start: usize, gap: usize) {\\n        for i in ((start + gap)..values.len()).step_by(gap) {\\n            let val_current = values[i];\\n            let mut pos = i;\\n            // make swaps\\n            while pos >= gap && values[pos - gap] > val_current {\\n                values[pos] = values[pos - gap];\\n                pos -= gap;\\n            }\\n            values[pos] = val_current;\\n        }\\n    }\\n\\n    let mut count_sublist = values.len() / 2; // makes gap as long as half of the array\\n    while count_sublist > 0 {\\n        for pos_start in 0..count_sublist {\\n            insertion(values, pos_start, count_sublist);\\n        }\\n        count_sublist /= 2; // makes gap as half of previous\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::shell_sort;\\n\\n    #[test]\\n    fn basic() {\\n        let mut vec = vec![3, 5, 6, 3, 1, 4];\\n        shell_sort(&mut vec);\\n        for i in 0..vec.len() - 1 {\\n            assert!(vec[i] <= vec[i + 1]);\\n        }\\n    }\\n\\n    #[test]\\n    fn empty() {\\n        let mut vec: Vec<i32> = vec![];\\n        shell_sort(&mut vec);\\n        assert_eq!(vec, vec![]);\\n    }\\n\\n    #[test]\\n    fn reverse() {\\n        let mut vec = vec![6, 5, 4, 3, 2, 1];\\n        shell_sort(&mut vec);\\n        for i in 0..vec.len() - 1 {\\n            assert!(vec[i] <= vec[i + 1]);\\n        }\\n    }\\n\\n    #[test]\\n    fn already_sorted() {\\n        let mut vec = vec![1, 2, 3, 4, 5, 6];\\n        shell_sort(&mut vec);\\n        for i in 0..vec.len() - 1 {\\n            assert!(vec[i] <= vec[i + 1]);\\n        }\\n    }\\n}\\n\"",
    "stooge sort": "\"fn _stooge_sort<T: Ord>(arr: &mut [T], start: usize, end: usize) {\\n    if arr[start] > arr[end] {\\n        arr.swap(start, end);\\n    }\\n\\n    if start + 1 >= end {\\n        return;\\n    }\\n\\n    let k = (end - start + 1) / 3;\\n\\n    _stooge_sort(arr, start, end - k);\\n    _stooge_sort(arr, start + k, end);\\n    _stooge_sort(arr, start, end - k);\\n}\\n\\npub fn stooge_sort<T: Ord>(arr: &mut [T]) {\\n    let len = arr.len();\\n    if len == 0 {\\n        return;\\n    }\\n\\n    _stooge_sort(arr, 0, len - 1);\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        let mut vec = vec![3, 5, 6, 3, 1, 4];\\n        stooge_sort(&mut vec);\\n        for i in 0..vec.len() - 1 {\\n            assert!(vec[i] <= vec[i + 1]);\\n        }\\n    }\\n\\n    #[test]\\n    fn empty() {\\n        let mut vec: Vec<i32> = vec![];\\n        stooge_sort(&mut vec);\\n        assert_eq!(vec, vec![]);\\n    }\\n\\n    #[test]\\n    fn reverse() {\\n        let mut vec = vec![6, 5, 4, 3, 2, 1];\\n        stooge_sort(&mut vec);\\n        for i in 0..vec.len() - 1 {\\n            assert!(vec[i] <= vec[i + 1]);\\n        }\\n    }\\n\\n    #[test]\\n    fn already_sorted() {\\n        let mut vec = vec![1, 2, 3, 4, 5, 6];\\n        stooge_sort(&mut vec);\\n        for i in 0..vec.len() - 1 {\\n            assert!(vec[i] <= vec[i + 1]);\\n        }\\n    }\\n}\\n\"",
    "aho corasick": "\"use std::cell::RefCell;\\nuse std::collections::BTreeMap;\\nuse std::collections::VecDeque;\\nuse std::rc::{Rc, Weak};\\n\\n#[derive(Default)]\\nstruct ACNode {\\n    trans: BTreeMap<char, Rc<RefCell<ACNode>>>,\\n    suffix: Weak<RefCell<ACNode>>, // the suffix(fail) link\\n    lengths: Vec<usize>,           // lengths of matched patterns ended at this node\\n}\\n\\n#[derive(Default)]\\npub struct AhoCorasick {\\n    root: Rc<RefCell<ACNode>>,\\n}\\n\\nimpl AhoCorasick {\\n    pub fn new(words: &[&str]) -> Self {\\n        let root = Rc::new(RefCell::new(ACNode::default()));\\n        for word in words {\\n            let mut cur = Rc::clone(&root);\\n            for c in word.chars() {\\n                cur = Rc::clone(Rc::clone(&cur).borrow_mut().trans.entry(c).or_default());\\n            }\\n            cur.borrow_mut().lengths.push(word.len());\\n        }\\n        Self::build_suffix(Rc::clone(&root));\\n        Self { root }\\n    }\\n\\n    fn build_suffix(root: Rc<RefCell<ACNode>>) {\\n        let mut q = VecDeque::new();\\n        q.push_back(Rc::clone(&root));\\n        while let Some(parent) = q.pop_front() {\\n            let parent = parent.borrow();\\n            for (c, child) in &parent.trans {\\n                q.push_back(Rc::clone(child));\\n                let mut child = child.borrow_mut();\\n                let mut suffix = parent.suffix.upgrade();\\n                loop {\\n                    match &suffix {\\n                        None => {\\n                            child.lengths.extend(root.borrow().lengths.clone());\\n                            child.suffix = Rc::downgrade(&root);\\n                            break;\\n                        }\\n                        Some(node) => {\\n                            if node.borrow().trans.contains_key(c) {\\n                                let node = &node.borrow().trans[c];\\n                                child.lengths.extend(node.borrow().lengths.clone());\\n                                child.suffix = Rc::downgrade(node);\\n                                break;\\n                            } else {\\n                                suffix = suffix.unwrap().borrow().suffix.upgrade();\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    pub fn search<'a>(&self, s: &'a str) -> Vec<&'a str> {\\n        let mut ans = vec![];\\n        let mut cur = Rc::clone(&self.root);\\n        for (i, c) in s.chars().enumerate() {\\n            loop {\\n                if let Some(child) = Rc::clone(&cur).borrow().trans.get(&c) {\\n                    cur = Rc::clone(child);\\n                    break;\\n                }\\n                let suffix = cur.borrow().suffix.clone();\\n                match suffix.upgrade() {\\n                    Some(node) => cur = node,\\n                    None => break,\\n                }\\n            }\\n            for &len in &cur.borrow().lengths {\\n                ans.push(&s[i - len + 1..=i]);\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_aho_corasick() {\\n        let dict = [\\\"abc\\\", \\\"abcd\\\", \\\"xyz\\\", \\\"acxy\\\", \\\"efg\\\", \\\"123\\\", \\\"678\\\", \\\"6543\\\"];\\n        let ac = AhoCorasick::new(&dict);\\n        let res = ac.search(\\\"ababcxyzacxy12678acxy6543\\\");\\n        assert_eq!(res, [\\\"abc\\\", \\\"xyz\\\", \\\"acxy\\\", \\\"678\\\", \\\"acxy\\\", \\\"6543\\\",]);\\n    }\\n}\\n\"",
    "burrows wheeler transform": "\"pub fn burrows_wheeler_transform(input: String) -> (String, usize) {\\n    let len = input.len();\\n\\n    let mut table = Vec::<String>::with_capacity(len);\\n    for i in 0..len {\\n        table.push(input[i..].to_owned() + &input[..i]);\\n    }\\n    table.sort_by_key(|a| a.to_lowercase());\\n\\n    let mut encoded = String::new();\\n    let mut index: usize = 0;\\n    for (i, item) in table.iter().enumerate().take(len) {\\n        encoded.push(item.chars().last().unwrap());\\n        if item.eq(&input) {\\n            index = i;\\n        }\\n    }\\n\\n    (encoded, index)\\n}\\n\\npub fn inv_burrows_wheeler_transform(input: (String, usize)) -> String {\\n    let len = input.0.len();\\n    let mut table = Vec::<(usize, char)>::with_capacity(len);\\n    for i in 0..len {\\n        table.push((i, input.0.chars().nth(i).unwrap()));\\n    }\\n\\n    table.sort_by(|a, b| a.1.cmp(&b.1));\\n\\n    let mut decoded = String::new();\\n    let mut idx = input.1;\\n    for _ in 0..len {\\n        decoded.push(table[idx].1);\\n        idx = table[idx].0;\\n    }\\n\\n    decoded\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn basic() {\\n        assert_eq!(\\n            inv_burrows_wheeler_transform(burrows_wheeler_transform(\\\"CARROT\\\".to_string())),\\n            \\\"CARROT\\\"\\n        );\\n        assert_eq!(\\n            inv_burrows_wheeler_transform(burrows_wheeler_transform(\\\"TOMATO\\\".to_string())),\\n            \\\"TOMATO\\\"\\n        );\\n        assert_eq!(\\n            inv_burrows_wheeler_transform(burrows_wheeler_transform(\\\"THISISATEST\\\".to_string())),\\n            \\\"THISISATEST\\\"\\n        );\\n        assert_eq!(\\n            inv_burrows_wheeler_transform(burrows_wheeler_transform(\\\"THEALGORITHMS\\\".to_string())),\\n            \\\"THEALGORITHMS\\\"\\n        );\\n        assert_eq!(\\n            inv_burrows_wheeler_transform(burrows_wheeler_transform(\\\"RUST\\\".to_string())),\\n            \\\"RUST\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn special_characters() {\\n        assert_eq!(\\n            inv_burrows_wheeler_transform(burrows_wheeler_transform(\\\"!.!.!??.=::\\\".to_string())),\\n            \\\"!.!.!??.=::\\\"\\n        );\\n        assert_eq!(\\n            inv_burrows_wheeler_transform(burrows_wheeler_transform(\\n                \\\"!{}{}(((&&%%!??.=::\\\".to_string()\\n            )),\\n            \\\"!{}{}(((&&%%!??.=::\\\"\\n        );\\n        assert_eq!(\\n            inv_burrows_wheeler_transform(burrows_wheeler_transform(\\\"//&$[]\\\".to_string())),\\n            \\\"//&$[]\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn empty() {\\n        assert_eq!(\\n            inv_burrows_wheeler_transform(burrows_wheeler_transform(\\\"\\\".to_string())),\\n            \\\"\\\"\\n        );\\n    }\\n}\\n\"",
    "knuth morris pratt": "\"pub fn knuth_morris_pratt(st: String, pat: String) -> Vec<usize> {\\n    if st.is_empty() || pat.is_empty() {\\n        return vec![];\\n    }\\n\\n    let string = st.into_bytes();\\n    let pattern = pat.into_bytes();\\n\\n    // build the partial match table\\n    let mut partial = vec![0];\\n    for i in 1..pattern.len() {\\n        let mut j = partial[i - 1];\\n        while j > 0 && pattern[j] != pattern[i] {\\n            j = partial[j - 1];\\n        }\\n        partial.push(if pattern[j] == pattern[i] { j + 1 } else { j });\\n    }\\n\\n    // and read 'string' to find 'pattern'\\n    let mut ret = vec![];\\n    let mut j = 0;\\n\\n    for (i, &c) in string.iter().enumerate() {\\n        while j > 0 && c != pattern[j] {\\n            j = partial[j - 1];\\n        }\\n        if c == pattern[j] {\\n            j += 1;\\n        }\\n        if j == pattern.len() {\\n            ret.push(i + 1 - j);\\n            j = partial[j - 1];\\n        }\\n    }\\n\\n    ret\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn each_letter_matches() {\\n        let index = knuth_morris_pratt(\\\"aaa\\\".to_string(), \\\"a\\\".to_string());\\n        assert_eq!(index, vec![0, 1, 2]);\\n    }\\n\\n    #[test]\\n    fn a_few_separate_matches() {\\n        let index = knuth_morris_pratt(\\\"abababa\\\".to_string(), \\\"ab\\\".to_string());\\n        assert_eq!(index, vec![0, 2, 4]);\\n    }\\n\\n    #[test]\\n    fn one_match() {\\n        let index =\\n            knuth_morris_pratt(\\\"ABC ABCDAB ABCDABCDABDE\\\".to_string(), \\\"ABCDABD\\\".to_string());\\n        assert_eq!(index, vec![15]);\\n    }\\n\\n    #[test]\\n    fn lots_of_matches() {\\n        let index = knuth_morris_pratt(\\\"aaabaabaaaaa\\\".to_string(), \\\"aa\\\".to_string());\\n        assert_eq!(index, vec![0, 1, 4, 7, 8, 9, 10]);\\n    }\\n\\n    #[test]\\n    fn lots_of_intricate_matches() {\\n        let index = knuth_morris_pratt(\\\"ababababa\\\".to_string(), \\\"aba\\\".to_string());\\n        assert_eq!(index, vec![0, 2, 4, 6]);\\n    }\\n\\n    #[test]\\n    fn not_found0() {\\n        let index = knuth_morris_pratt(\\\"abcde\\\".to_string(), \\\"f\\\".to_string());\\n        assert_eq!(index, vec![]);\\n    }\\n\\n    #[test]\\n    fn not_found1() {\\n        let index = knuth_morris_pratt(\\\"abcde\\\".to_string(), \\\"ac\\\".to_string());\\n        assert_eq!(index, vec![]);\\n    }\\n\\n    #[test]\\n    fn not_found2() {\\n        let index = knuth_morris_pratt(\\\"ababab\\\".to_string(), \\\"bababa\\\".to_string());\\n        assert_eq!(index, vec![]);\\n    }\\n\\n    #[test]\\n    fn empty_string() {\\n        let index = knuth_morris_pratt(\\\"\\\".to_string(), \\\"abcdef\\\".to_string());\\n        assert_eq!(index, vec![]);\\n    }\\n}\\n\"",
    "manacher": "\"pub fn manacher(s: String) -> String {\\n    let l = s.len();\\n    if l <= 1 {\\n        return s;\\n    }\\n\\n    // MEMO: We need to detect odd palindrome as well,\\n    // therefore, inserting dummy string so that\\n    // we can find a pair with dummy center character.\\n    let mut chars: Vec<char> = Vec::with_capacity(s.len() * 2 + 1);\\n    for c in s.chars() {\\n        chars.push('#');\\n        chars.push(c);\\n    }\\n    chars.push('#');\\n\\n    // List: storing the length of palindrome at each index of string\\n    let mut length_of_palindrome = vec![1usize; chars.len()];\\n    // Integer: Current checking palindrome's center index\\n    let mut current_center: usize = 0;\\n    // Integer: Right edge index existing the radius away from current center\\n    let mut right_from_current_center: usize = 0;\\n\\n    for i in 0..chars.len() {\\n        // 1: Check if we are looking at right side of palindrome.\\n        if right_from_current_center > i && i > current_center {\\n            // 1-1: If so copy from the left side of palindrome.\\n            // If the value + index exceeds the right edge index, we should cut and check palindrome later #3.\\n            length_of_palindrome[i] = std::cmp::min(\\n                right_from_current_center - i,\\n                length_of_palindrome[2 * current_center - i],\\n            );\\n            // 1-2: Move the checking palindrome to new index if it exceeds the right edge.\\n            if length_of_palindrome[i] + i >= right_from_current_center {\\n                current_center = i;\\n                right_from_current_center = length_of_palindrome[i] + i;\\n                // 1-3: If radius exceeds the end of list, it means checking is over.\\n                // You will never get the larger value because the string will get only shorter.\\n                if right_from_current_center >= chars.len() - 1 {\\n                    break;\\n                }\\n            } else {\\n                // 1-4: If the checking index doesn't exceeds the right edge,\\n                // it means the length is just as same as the left side.\\n                // You don't need to check anymore.\\n                continue;\\n            }\\n        }\\n\\n        // Integer: Current radius from checking index\\n        // If it's copied from left side and more than 1,\\n        // it means it's ensured so you don't need to check inside radius.\\n        let mut radius: usize = (length_of_palindrome[i] - 1) / 2;\\n        radius += 1;\\n        // 2: Checking palindrome.\\n        // Need to care about overflow usize.\\n        while i >= radius && i + radius <= chars.len() - 1 && chars[i - radius] == chars[i + radius]\\n        {\\n            length_of_palindrome[i] += 2;\\n            radius += 1;\\n        }\\n    }\\n\\n    // 3: Find the maximum length and generate answer.\\n    let center_of_max = length_of_palindrome\\n        .iter()\\n        .enumerate()\\n        .max_by_key(|(_, &value)| value)\\n        .map(|(idx, _)| idx)\\n        .unwrap();\\n    let radius_of_max = (length_of_palindrome[center_of_max] - 1) / 2;\\n    let answer = &chars[(center_of_max - radius_of_max)..(center_of_max + radius_of_max + 1)]\\n        .iter()\\n        .collect::<String>();\\n    answer.replace(\\\"#\\\", \\\"\\\")\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::manacher;\\n\\n    #[test]\\n    fn get_longest_palindrome_by_manacher() {\\n        assert_eq!(manacher(\\\"babad\\\".to_string()), \\\"aba\\\".to_string());\\n        assert_eq!(manacher(\\\"cbbd\\\".to_string()), \\\"bb\\\".to_string());\\n        assert_eq!(manacher(\\\"a\\\".to_string()), \\\"a\\\".to_string());\\n\\n        let ac_ans = manacher(\\\"ac\\\".to_string());\\n        assert!(ac_ans == \\\"a\\\".to_string() || ac_ans == \\\"c\\\".to_string());\\n    }\\n}\\n\"",
    "rabin karp": "\"pub fn rabin_karp(target: String, pattern: String) -> Vec<usize> {\\n    // Quick exit\\n    if target.is_empty() || pattern.is_empty() || pattern.len() > target.len() {\\n        return vec![];\\n    }\\n\\n    let string: String = (&pattern[0..pattern.len()]).to_string();\\n    let hash_pattern = hash(string.clone());\\n    let mut ret = vec![];\\n    for i in 0..(target.len() - pattern.len() + 1) {\\n        let s = (&target[i..(i + pattern.len())]).to_string();\\n        let string_hash = hash(s.clone());\\n\\n        if string_hash == hash_pattern && s == string {\\n            ret.push(i);\\n        }\\n    }\\n    ret\\n}\\n\\nfn hash(mut s: String) -> u16 {\\n    let prime: u16 = 101;\\n    let last_char = s\\n        .drain(s.len() - 1..)\\n        .next()\\n        .expect(\\\"Failed to get the last char of the string\\\");\\n    let mut res: u16 = 0;\\n    for (i, &c) in s.as_bytes().iter().enumerate() {\\n        if i == 0 {\\n            res = (c as u16 * 256) % prime;\\n        } else {\\n            res = (((res + c as u16) % 101) * 256) % 101;\\n        }\\n    }\\n    (res + last_char as u16) % prime\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn hi_hash() {\\n        let hash_result = hash(\\\"hi\\\".to_string());\\n        assert_eq!(hash_result, 65);\\n    }\\n\\n    #[test]\\n    fn abr_hash() {\\n        let hash_result = hash(\\\"abr\\\".to_string());\\n        assert_eq!(hash_result, 4);\\n    }\\n\\n    #[test]\\n    fn bra_hash() {\\n        let hash_result = hash(\\\"bra\\\".to_string());\\n        assert_eq!(hash_result, 30);\\n    }\\n\\n    // Attribution to @pgimalac for his tests from Knuth-Morris-Pratt\\n    #[test]\\n    fn each_letter_matches() {\\n        let index = rabin_karp(\\\"aaa\\\".to_string(), \\\"a\\\".to_string());\\n        assert_eq!(index, vec![0, 1, 2]);\\n    }\\n\\n    #[test]\\n    fn a_few_separate_matches() {\\n        let index = rabin_karp(\\\"abababa\\\".to_string(), \\\"ab\\\".to_string());\\n        assert_eq!(index, vec![0, 2, 4]);\\n    }\\n\\n    #[test]\\n    fn one_match() {\\n        let index = rabin_karp(\\\"ABC ABCDAB ABCDABCDABDE\\\".to_string(), \\\"ABCDABD\\\".to_string());\\n        assert_eq!(index, vec![15]);\\n    }\\n\\n    #[test]\\n    fn lots_of_matches() {\\n        let index = rabin_karp(\\\"aaabaabaaaaa\\\".to_string(), \\\"aa\\\".to_string());\\n        assert_eq!(index, vec![0, 1, 4, 7, 8, 9, 10]);\\n    }\\n\\n    #[test]\\n    fn lots_of_intricate_matches() {\\n        let index = rabin_karp(\\\"ababababa\\\".to_string(), \\\"aba\\\".to_string());\\n        assert_eq!(index, vec![0, 2, 4, 6]);\\n    }\\n\\n    #[test]\\n    fn not_found0() {\\n        let index = rabin_karp(\\\"abcde\\\".to_string(), \\\"f\\\".to_string());\\n        assert_eq!(index, vec![]);\\n    }\\n\\n    #[test]\\n    fn not_found1() {\\n        let index = rabin_karp(\\\"abcde\\\".to_string(), \\\"ac\\\".to_string());\\n        assert_eq!(index, vec![]);\\n    }\\n\\n    #[test]\\n    fn not_found2() {\\n        let index = rabin_karp(\\\"ababab\\\".to_string(), \\\"bababa\\\".to_string());\\n        assert_eq!(index, vec![]);\\n    }\\n\\n    #[test]\\n    fn empty_string() {\\n        let index = rabin_karp(\\\"\\\".to_string(), \\\"abcdef\\\".to_string());\\n        assert_eq!(index, vec![]);\\n    }\\n}\\n\"",
    "reverse": "\"pub fn reverse(text: &str) -> String {\\n    text.chars().rev().collect()\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_simple() {\\n        assert_eq!(reverse(\\\"racecar\\\"), \\\"racecar\\\");\\n    }\\n\\n    #[test]\\n    fn test_sentence() {\\n        assert_eq!(reverse(\\\"step on no pets\\\"), \\\"step on no pets\\\");\\n    }\\n}\\n\""
  }
}
