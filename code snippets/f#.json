{
  "f#": {
    "abs": "\"namespace Algorithms.Math\\n\\nmodule Abs =\\n    let absVal num = if num < 0 then -num else num\\n\"",
    "abs max": "\"namespace Algorithms.Math\\n\\nmodule AbsMax =\\n    let absMax (x: int list) =\\n        let mutable j = x.[0]\\n\\n        for i in x do\\n            if abs i > abs j then j <- i\\n\\n        j\\n\"",
    "abs min": "\"namespace Algorithms.Math\\n\\nmodule AbsMin =\\n    let absMin (x: int list) =\\n        let mutable j = x.[0]\\n\\n        for i in x do\\n            if abs i < abs j then j <- i\\n\\n        j\\n\"",
    "factorial": "\"namespace Algorithms.Math\\n\\nmodule Factorial =\\n    let CalculateFactorial num =\\n        if (num < 0)\\n            then failwith \\\"No Factorial for negative numbers\\\"\\n            else [1..num] |> Seq.fold (fun acc n -> acc * n) 1\"",
    "fibonacci": "\"namespace Algorithms.Math\\n\\nmodule Fibonacci =\\n    let rec PrintSerie (one: int) (two: int) =\\n        let fibo = one + two\\n        System.Console.WriteLine fibo\\n        PrintSerie two fibo\"",
    "perfect  numbers": "\"namespace Algorithms.Math\\n\\nmodule Perfect_Numbers =\\n    let IsPerfect (number: int) =\\n        match number with\\n        | number when number <= 0 -> false\\n        | number ->\\n            let total =\\n                seq { 1 .. number - 1 }\\n                |> Seq.filter (fun n -> number % n = 0)\\n                |> Seq.sum\\n\\n            total = number\\n\"",
    "power": "\"namespace Algorithms.Math\\n\\nmodule Power =\\n    let Pow x powerOf =\\n        [1..powerOf] |> Seq.fold (fun acc _ -> acc * x) 1\"",
    "binary search": "\"﻿namespace Algorithms.Search\\r\\n\\r\\nopen System\\r\\n\\r\\nmodule BinarySearch =\\r\\n    let rec byRecursion (sortedData: IComparable [], item: int, left: int, right: int) =\\r\\n\\r\\n        let middle = left + (right - left) / 2\\r\\n\\r\\n        match sortedData.[middle] with\\r\\n        | s when s.CompareTo(sortedData.[middle]) > item -> byRecursion (sortedData, item, left, middle - 1)\\r\\n        | s when s.CompareTo(sortedData.[middle]) < item -> byRecursion (sortedData, item, left, middle + 1)\\r\\n        | _ -> middle\\r\\n\\r\\n    /// <summary>\\r\\n    /// Finds index of item in array that equals to item searched for,\\r\\n    /// time complexity: O(log(n)),\\r\\n    /// space complexity: O(1),\\r\\n    /// where n - array size.\\r\\n    /// </summary>\\r\\n    /// <param name=\\\"sortedData\\\">Sorted array to search in.</param>\\r\\n    /// <param name=\\\"item\\\">Item to search for.</param>\\r\\n    /// <returns>Index of item that equals to item searched for or -1 if none found.</returns>\\r\\n    let rec findIndex (sortedData: IComparable [], item: int) =\\r\\n\\r\\n        let left = 0\\r\\n        let right = sortedData.Length - 1\\r\\n\\r\\n        let middle = left + (right - left) / 2\\r\\n        let currentItem = sortedData.[middle]\\r\\n\\r\\n        match currentItem with\\r\\n        | c when c.CompareTo(sortedData.[middle]) > item -> findIndex (sortedData, item)\\r\\n        | c when c.CompareTo(sortedData.[middle]) < item -> findIndex (sortedData, item)\\r\\n        | _ -> item\\r\\n\"",
    "bubble  sort": "\"﻿namespace Algorithms.Sort\\n\\nmodule BubbleSort =\\n    let rec Sort list: 'T [] =\\n        let mutable updated = false\\n        let mutable list = list |> Array.copy\\n        for index in 0 .. list.Length - 1 do\\n            if index < list.Length - 1 then\\n                let current = list.[index]\\n                let next = list.[index + 1]\\n                if next < current then\\n                    list.[index] <- next\\n                    list.[index + 1] <- current\\n                    updated <- true\\n        if updated then list <- Sort list\\n        list\\n\"",
    "comb  sort": "\"﻿namespace Algorithms.Sort\\n\\nmodule CombSort =\\n    let Sort list: 'T [] =\\n        let mutable list = list |> Array.copy\\n        let mutable gap = double list.Length\\n        let mutable swaps = true\\n        while gap > 1.0 || swaps do\\n            gap <- gap / 1.247330950103979\\n            if gap < 1.0 then gap <- 1.0\\n            let mutable i = 0\\n            swaps <- false\\n            while i + int gap < list.Length do\\n                let igap = i + int gap\\n                if list.[i] > list.[igap] then\\n                    let swap = list.[i]\\n                    list.[i] <- list.[igap]\\n                    list.[igap] <- swap\\n                    swaps <- true\\n                i <- i + 1\\n        list\\n\"",
    "cycle  sort": "\"﻿namespace Algorithms.Sort\\n\\nmodule CycleSort =\\n    let Sort list: 'T [] =\\n        let mutable list = list |> Array.copy\\n        let mutable writes = 0\\n        for index in 0 .. list.Length - 1 do\\n            let mutable value = list.[index]\\n            let mutable pos = index\\n            for i in index + 1 .. list.Length - 1 do\\n                if list.[i] < value then pos <- pos + 1\\n            if pos <> index then\\n                while value = list.[pos] do\\n                    pos <- pos + 1\\n                let mutable tmp = list.[pos]\\n                list.[pos] <- value\\n                value <- tmp\\n                writes <- writes + 1\\n                while pos <> index do\\n                    pos <- index\\n                    for i in index + 1 .. list.Length - 1 do\\n                        if list.[i] < value then pos <- pos + 1\\n                    while value = list.[pos] do\\n                        pos <- pos + 1\\n                    tmp <- list.[pos]\\n                    list.[pos] <- value\\n                    value <- tmp\\n                    writes <- writes + 1\\n        list\\n\"",
    "gnome  sort": "\"﻿namespace Algorithms.Sort\\n\\nmodule GnomeSort =\\n    let Sort list: 'T [] =\\n        let mutable list = list |> Array.copy\\n        let mutable first = 1\\n        let mutable second = 2\\n        while first < list.Length do\\n            if list.[first - 1] <= list.[first] then\\n                first <- second\\n                second <- second + 1\\n            else\\n                let tmp = list.[first - 1]\\n                list.[first - 1] <- list.[first]\\n                list.[first] <- tmp\\n                first <- first - 1\\n                if first = 0 then\\n                    first <- 1\\n                    second <- 2\\n        list\\n\"",
    "heap  sort": "\"namespace Algorithms.Sort\\n\\nmodule HeapSort =\\n    let inline swap (a: 'T []) i j =\\n        let temp = a.[i]\\n        a.[i] <- a.[j]\\n        a.[j] <- temp\\n\\n    let inline sift cmp (a: 'T []) start count =\\n        let rec loop root child =\\n            if root * 2 + 1 < count then\\n                let p =\\n                    child < count\\n                    - 1\\n                    && cmp a.[child] a.[child + 1] < 0\\n\\n                let child = if p then child + 1 else child\\n                if cmp a.[root] a.[child] < 0 then\\n                    swap a root child\\n                    loop child (child * 2 + 1)\\n\\n        loop start (start * 2 + 1)\\n\\n    let inline heapsort cmp (a: 'T []) =\\n        let n = a.Length\\n        for start = n / 2 - 1 downto 0 do\\n            sift cmp a start n\\n        for term = n - 1 downto 1 do\\n            swap a term 0\\n            sift cmp a 0 term\\n\"",
    "insertion  sort": "\"﻿namespace Algorithms.Sort\\n\\nmodule InsertionSort =\\n    let Sort list: 'T [] =\\n        let mutable list = list |> Array.copy\\n        for index in 1 .. list.Length - 1 do\\n            let item = list.[index]\\n            let mutable j = index\\n            while j > 0 && list.[j - 1] > item do\\n                list.[j] <- list.[j - 1]\\n                j <- j - 1\\n            list.[j] <- item\\n        list\\n\"",
    "merge  sort": "\"namespace Algorithms.Sort\\n\\nmodule MergeSort =\\n    let split list =\\n        let rec aux l acc1 acc2 =\\n            match l with\\n            | [] -> (acc1, acc2)\\n            | [ x ] -> (x :: acc1, acc2)\\n            | x :: y :: tail -> aux tail (x :: acc1) (y :: acc2)\\n\\n        aux list [] []\\n\\n    let rec merge l1 l2 =\\n        match (l1, l2) with\\n        | (x, []) -> x\\n        | ([], y) -> y\\n        | (x :: tx, y :: ty) -> if x <= y then x :: merge tx l2 else y :: merge l1 ty\\n\\n    let rec sort list =\\n        match list with\\n        | [] -> []\\n        | [ x ] -> [ x ]\\n        | _ ->\\n            let (l1, l2) = split list\\n            merge (sort l1) (sort l2)\\n\"",
    "pancake  sort": "\"namespace Algorithms.Sort\\n\\nmodule PancakeSort =\\n    let show data =\\n        data |> Array.iter (printf \\\"%d \\\")\\n        printfn \\\"\\\"\\n\\n    let split (data: int []) pos = data.[0..pos], data.[(pos + 1)..]\\n\\n    let flip items pos =\\n        let lower, upper = split items pos\\n        Array.append (Array.rev lower) upper\\n\\n    let sort items =\\n        let rec loop data limit =\\n            if limit <= 0 then\\n                data\\n            else\\n                let lower, upper = split data limit\\n\\n                let indexOfMax =\\n                    lower |> Array.findIndex ((=) (Array.max lower))\\n\\n                let partialSort =\\n                    Array.append (flip lower indexOfMax |> Array.rev) upper\\n\\n                loop partialSort (limit - 1)\\n\\n        loop items ((Array.length items) - 1)\\n\"",
    "quick  sort": "\"namespace Algorithms.Sort\\r\\n\\r\\nmodule QuickSort =\\r\\n    let Sort lst =\\r\\n        let rec aux l cont =\\r\\n            match l with\\r\\n            | [] -> cont []\\r\\n            | pivot :: rest ->\\r\\n                let left, right =\\r\\n                    rest |> List.partition (fun i -> i < pivot)\\r\\n\\r\\n                aux left (fun acc_left -> aux right (fun acc_right -> cont (acc_left @ pivot :: acc_right)))\\r\\n\\r\\n        aux lst (id)\\r\\n\"",
    "capitalize": "\"namespace Algorithms.Strings\\n\\nmodule Capitalize =\\n    /// <summary>\\n    /// This function will capitalize the first letter of a sentence or a word\\n    /// </summary>\\n    /// <example>\\n    /// <code>\\n    /// capitalize(\\\"hello world\\\")\\n    /// 'Hello world'\\n    ///\\n    /// capitalize(\\\"123 hello world\\\")\\n    /// '123 hello world'\\n    ///\\n    /// capitalize(\\\" hello world\\\")\\n    /// ' hello world'\\n    ///\\n    /// capitalize(\\\"a\\\")\\n    /// 'A'\\n    ///\\n    /// capitalize(\\\"\\\")\\n    /// ''\\n    /// </code>\\n    /// </example>\\n    /// <param name=\\\"sentence\\\">String to capitalize.</param>\\n    /// <returns>Capitalized string</returns>\\n    let capitalize (sentence: string) =\\n        match sentence with\\n        | \\\"\\\" -> \\\"\\\"\\n        | s when s.[0] >= 'a' && s.[0] <= 'z' ->\\n            sentence\\n                .Remove(0, 1)\\n                .Insert(0, (string) ((char) ((int) s.[0] - 32)))\\n        | _ -> sentence\\n\"",
    "check anagrams": "\"﻿namespace Algorithms.Strings\\n\\n/// wiki: https://en.wikipedia.org/wiki/Anagram\\nmodule CheckAnagrams =\\n    /// <summary>\\n    /// Two strings are anagrams if they are made of the same letters\\n    /// arranged differently (ignoring the case).\\n    /// </summary>\\n    /// <example>\\n    /// <code>\\n    /// check_anagrams('Silent', 'Listen')\\n    /// True\\n    ///\\n    /// check_anagrams('This is a string', 'Is this a string')\\n    /// True\\n    ///\\n    /// check_anagrams('This is    a      string', 'Is     this a string')\\n    /// True\\n    ///\\n    /// check_anagrams('There', 'Their')\\n    /// False\\n    /// </code>\\n    /// </example>\\n    /// <param name=\\\"string1\\\">First string</param>\\n    /// <param name=\\\"string2\\\">Second string</param>\\n    /// <returns>Boolean</returns>\\n    let isAnagram (string1: string, string2: string): bool =\\n        let a =\\n            string1.ToLower().ToCharArray()\\n            |> Array.filter (fun chars -> chars <> ' ')\\n            |> Array.sort\\n            |> System.String.Concat\\n\\n        let b =\\n            string2.ToLower().ToCharArray()\\n            |> Array.filter (fun chars -> chars <> ' ')\\n            |> Array.sort\\n            |> System.String.Concat\\n\\n        a = b\\n\"",
    "check pangram": "\"﻿namespace Algorithms.Strings\\n\\n/// wiki: https://en.wikipedia.org/wiki/Pangram\\nmodule CheckPangram =\\n    type System.Char with\\n        member this.IsUpper(): bool =\\n            match this with\\n            | c when c >= 'A' && c <= 'Z' -> true\\n            | _ -> false\\n\\n        member this.IsLower(): bool =\\n            match this with\\n            | c when c >= 'a' && c <= 'z' -> true\\n            | _ -> false\\n\\n        member this.Lower(): char =\\n            match this with\\n            | c when c >= 'A' && c <= 'Z' -> (char) ((int) this + 32)\\n            | _ -> this\\n\\n        member this.Upper(): char =\\n            match this with\\n            | c when c >= 'a' && c <= 'z' -> (char) ((int) this - 32)\\n            | _ -> this\\n\\n    let checkPangram (inputString: string): bool =\\n        let mutable frequency = Set.empty\\n        let inputStr = inputString.Replace(\\\" \\\", \\\"\\\") // Replacing all the whitespace in our sentence\\n\\n        for alpha in inputStr do\\n            if 'a' <= alpha.Lower() && alpha.Lower() <= 'z' then\\n                frequency <- frequency.Add(alpha.Lower())\\n\\n        match frequency.Count with\\n        | 26 -> true\\n        | _ -> if inputStr = \\\"\\\" then true else false\\n\\n    let checkPangramFaster (inputString: string): bool =\\n        let mutable flag = [| for i in 1 .. 26 -> false |]\\n\\n        for char in inputString do\\n            if char.IsLower() then\\n                flag.SetValue(true, (int) char - (int) 'a')\\n\\n        flag |> Array.forall (id)\\n\"",
    "is palindrome": "\"﻿namespace Algorithms.Strings\\n\\nmodule IsPalindrome =\\n    /// <summary>\\n    /// Determine whether the string is palindrome\\n    /// </summary>\\n    /// <param name=\\\"str\\\"></param>\\n    /// <returns>Boolean</returns>\\n    let isPalindrome (str: string): bool =\\n        let str =\\n            str.ToLower()\\n            |> Seq.filter (System.Char.IsLetterOrDigit)\\n            |> Seq.toList\\n\\n        str = (str |> List.rev)\\n\"",
    "jaro winkler": "\"namespace Algorithms.Strings\\n\\nopen Microsoft.FSharp.Collections\\n\\nmodule JaroWinkler =\\n    /// <summary>\\n    /// Jaro–Winkler distance is a string metric measuring an edit distance between two\\n    /// sequences.\\n    /// Output value is between 0.0 and 1.0.\\n    /// </summary>\\n    /// <param name=\\\"str1\\\"></param>\\n    /// <param name=\\\"str2\\\"></param>\\n    /// <returns></returns>\\n    let jaroWinkler (str1: string, str2: string): float =\\n        let getMatchedCharacters (_str1: string, _str2: string): string =\\n            let mutable istr1 = _str1\\n            let mutable istr2 = _str2\\n            let mutable matched = []\\n    \\n            let limit =\\n                int (floor (double (min _str1.Length str2.Length) / 2.0))\\n    \\n            istr1\\n            |> Seq.iteri\\n                (fun i l ->\\n                    let left = int(max 0 (i - limit))\\n    \\n                    let right = int(min (i + limit + 1) istr2.Length)\\n    \\n                    if (istr2.[left..right - 1]).Contains(l) then\\n                        matched <- List.append matched [ (string) l ]\\n                        let myIndex = (istr2.IndexOf(l))\\n                        istr2 <- $\\\"{istr2.[0..istr2.IndexOf(l) - 1]} {istr2.[istr2.IndexOf(l) + 1..]}\\\")\\n    \\n            matched |> List.fold (+) \\\"\\\"\\n    \\n        // matching characters\\n        let matching1 = getMatchedCharacters (str1, str2)\\n        let matching2 = getMatchedCharacters (str2, str1)\\n        let matchCount = matching1.Length\\n        let mutable jaro = 0.0\\n    \\n        // Transposition\\n        let transpositions =\\n            floor (\\n                double (\\n                    (double)\\n                        [ for c1, c2 in List.zip [ matching1 ] [ matching2 ] do if c1 <> c2 then (c1, c2) ]\\n                            .Length\\n                )\\n            )\\n    \\n        if matchCount = 0 then\\n            jaro <- 0.0\\n        else\\n            jaro <-\\n                1.0 / 3.0\\n                * ((double) matchCount / (double) str1.Length\\n                   + (double) matchCount / (double) str2.Length\\n                   + ((double) matchCount - transpositions)\\n                     / (double) matchCount)\\n    \\n        // Common prefix up to 4 characters\\n        let mutable prefixLen = 0\\n\\n        let mutable c1C2BoolList : bool list = []\\n\\n        if str1.Length = str2.Length then\\n            for c1, c2 in Array.zip (str1.[..4].ToCharArray()) (str2.[..4].ToCharArray()) do\\n                if c1 = c2 then\\n                    c1C2BoolList <- List.append c1C2BoolList [true]\\n                else\\n                    c1C2BoolList <- List.append c1C2BoolList [false]\\n            if (c1C2BoolList |> List.exists(fun x -> (not x))) then\\n                prefixLen <- prefixLen + (c1C2BoolList |> List.findIndex(fun x -> (not x)))\\n        jaro + 0.1 * (double) prefixLen * (1.0 - jaro)\"",
    "knuth morris pratt": "\"﻿namespace Algorithms.Strings\\n\\nmodule KnuthMorrisPratt =\\n    let getFailureArray (pattern: string): list<int> =\\n        let mutable failure = [ 0 ]\\n        let mutable i = 0\\n        let mutable j = 1\\n\\n        while j < pattern.Length do\\n            if pattern.[i] = pattern.[j] then\\n                i <- i + 1\\n            elif i > 0 then\\n                i <- failure.[i - 1]\\n\\n            j <- j + 1\\n            failure <- failure |> List.append [ i ]\\n\\n        failure\\n\\n    /// <summary>\\n    /// The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text\\n    /// with complexity O(n + m)\\n    /// </summary>\\n    /// <param name=\\\"pattern\\\"></param>\\n    /// <param name=\\\"text\\\"></param>\\n    /// <returns></returns>\\n    let kmp (pattern: string, text: string): bool =\\n        // 1) Construct the failure array\\n        let failure = getFailureArray pattern\\n\\n        let mutable result = false\\n\\n        // 2) Step through text searching for pattern\\n        let mutable i, j = 0, 0 // Index into text, pattern\\n\\n        while i < text.Length do\\n            if pattern.[j] = text.[i] then\\n                if j = pattern.Length - 1 && (not result) then\\n                    result <- true\\n\\n                j <- j + 1\\n\\n            // If this is a prefix in our pattern\\n            // just go back far enough to continue\\n            elif j > 0 && (not result) then\\n                j <- failure.[j - 1]\\n\\n            i <- i + 1\\n\\n        result\\n\"",
    "levenshtein distance": "\"﻿namespace Algorithms.Strings\\n\\nmodule LevenshteinDistance =\\n    /// <summary>\\n    /// Implementation of the levenshtein distance in F#.\\n    /// </summary>\\n    /// <param name=\\\"firstWord\\\">The first word to measure the difference.</param>\\n    /// <param name=\\\"secondWord\\\">The second word to measure the difference.</param>\\n    /// <returns></returns>\\n    let rec levenshteinDistance (firstWord: string, secondWord: string): int =\\n        // The longer word should come first\\n\\n        match secondWord.Length with\\n        | s when s > firstWord.Length -> levenshteinDistance (secondWord, firstWord)\\n        | 0 -> firstWord.Length\\n        | _ ->\\n            let mutable previousRow = [ 0 .. secondWord.Length ]\\n\\n            firstWord\\n            |> Seq.iteri\\n                (fun i c1 ->\\n                    let mutable currentRow = [ i + 1 ]\\n\\n                    secondWord\\n                    |> Seq.iteri\\n                        (fun j c2 ->\\n                            let insertions = previousRow.[j + 1] + 1\\n                            let deletions = currentRow.[j] + 1\\n\\n                            let substitutions =\\n                                previousRow.[j] + (if c1 <> c2 then 1 else 0)\\n\\n                            // Get the minimum to append to the current row\\n                            currentRow <-\\n                                currentRow\\n                                |> List.append [ (min insertions (min deletions substitutions)) ])\\n\\n                    previousRow <- currentRow |> List.rev)\\n\\n            previousRow |> List.rev |> List.item 0\\n\"",
    "lower": "\"﻿namespace Algorithms.Strings\\n\\nmodule Lower =\\n    /// <summary>\\n    /// Will convert the entire string to lowercase letters\\n    /// </summary>\\n    /// <example>\\n    /// <code>\\n    /// lower(\\\"wow\\\")\\n    /// 'wow'\\n    ///\\n    /// lower(\\\"HellZo\\\")\\n    /// hellzo'\\n    ///\\n    /// lower(\\\"WHAT\\\")\\n    /// 'what'\\n    ///\\n    /// lower(\\\"wh[]32\\\")\\n    /// 'wh[]32'\\n    ///\\n    /// lower(\\\"whAT\\\")\\n    /// 'what'\\n    /// </code>\\n    /// </example>\\n    /// <param name=\\\"input\\\"></param>\\n    /// <returns></returns>\\n    let lower (input: string): string =\\n        input.Split()\\n        |> Array.map\\n            (fun word ->\\n                word.ToCharArray()\\n                |> Array.map\\n                    (fun character ->\\n                        if character >= 'A' && character <= 'Z' then\\n                            char (int character + 32)\\n                        else\\n                            character)\\n                |> (fun characters -> System.String.Concat(characters)))\\n        |> String.concat \\\" \\\"\\n\"",
    "manacher": "\"﻿namespace Algorithms.Strings\\n\\nmodule Manacher =\\n    type List<'a> with\\n        member this.LengthInDouble = (double) this.Length\\n\\n    let palindromicString (inputString: string): string =\\n\\n        let mutable maxLength = 0\\n\\n        // If input_string is \\\"aba\\\" than new_input_string become \\\"a|b|a\\\"\\n        let mutable newInputString = \\\"\\\"\\n        let mutable outputString = \\\"\\\"\\n\\n        // Append each character + \\\"|\\\" in new_string for range(0, length-1)\\n        for i in inputString.[..(inputString.Length - 1)] do\\n            newInputString <- newInputString + string (i) + \\\"|\\\"\\n\\n        printfn \\\"%A\\\" newInputString\\n        // Append last character\\n        newInputString <- newInputString + (string) inputString.[^1]\\n\\n        // We will store the starting and ending of previous furthest ending palindromic\\n        // substring\\n        let mutable l, r = 0, 0\\n\\n        // length.[i] shows the length of palindromic substring with center i\\n        let length =\\n            [ for i in 0 .. newInputString.Length -> 1 ]\\n            |> Array.ofList\\n\\n\\n\\n        let mutable start = 0\\n\\n        // For each character in new_string find corresponding palindromic string\\n        for i in 0 .. newInputString.Length do\\n            // k = 1 if i > r else min(length[l + r - i] // 2, r - i + 1)\\n            let mutable k =\\n                if i > r then\\n                    1\\n                else\\n                    min ((int) (floor ([ l + r - 1 ].LengthInDouble / 2.0))) (r - i + 1)\\n\\n            while i - k >= 0\\n                  && i + k < newInputString.Length\\n                  && newInputString.[k + i] = newInputString.[i - k] do\\n                k <- k + 1\\n\\n                length.[i] <- 2 * k - 1\\n\\n                // Does this string end after the previously explored end (that is r) ?\\n                // if yes the update the new r to the last index of this\\n                if i + k - 1 > r then\\n                    l <- i - k + 1 // noqa: E741\\n                    r <- i + k - 1\\n\\n                // update max_length and start position\\n                if maxLength < length.[i] then\\n                    maxLength <- length.[i]\\n                    start <- i\\n\\n        // create that string\\n        let s =\\n            newInputString.[int (floor (((double) start - (double) maxLength / 2.0)))..(int) (floor ((double) start + (double) maxLength / 2.0 + 1.0))]\\n\\n        for i in s do\\n            if i <> '|' then\\n                outputString <- outputString + (string) i\\n\\n\\n        outputString\\n\"",
    "min cost string conversion": "\"﻿/// Algorithm for calculating the most cost-efficient sequence for converting one string\\n/// into another.\\n/// The only allowed operations are\\n/// --- Cost to copy a character is copy_cost\\n/// --- Cost to replace a character is replace_cost\\n/// --- Cost to delete a character is delete_cost\\n/// --- Cost to insert a character is insert_cost\\n///\\nnamespace Algorithms.Strings\\n\\nmodule MinCostStringConversion =\\n    let computeTransformTables\\n        (\\n            sourceString: string,\\n            destinationString: string,\\n            copyCost: int,\\n            replaceCost: int,\\n            deleteCost: int,\\n            insertCost: int\\n        ): list<int> * list<string> =\\n        let sourceSeq = [ sourceString ]\\n        let destinationSeq = [ destinationString ]\\n        let lenSourceSeq = sourceSeq.Length\\n        let lenDestinationSeq = destinationSeq.Length\\n\\n        let costs =\\n            [| for i in 0 .. (lenSourceSeq + 1) -> [| for i in 0 .. lenDestinationSeq + 1 -> 0 |] |]\\n\\n        let ops =\\n            [| for i in 0 .. lenSourceSeq + 1 -> [| for i in 0 .. lenDestinationSeq + 1 -> \\\"\\\" |] |]\\n\\n        for i = 1 to lenSourceSeq + 1 do\\n            costs.[i].[0] <- i * deleteCost\\n            ops.[i].[0] <- sprintf \\\"D%s\\\" (sourceSeq.[i - 1])\\n\\n        for i = 1 to lenDestinationSeq + 1 do\\n            costs.[0].[i] <- i * insertCost\\n            ops.[0].[i] <- sprintf \\\"I%s\\\" (destinationSeq.[i - 1])\\n\\n        for i in 1 .. lenSourceSeq + 1 do\\n            for j in 1 .. lenDestinationSeq + 1 do\\n                if sourceSeq.[i - 1] = destinationSeq.[j - 1] then\\n                    costs.[i].[j] <- costs.[i - 1].[j - 1] + copyCost\\n                    ops.[i].[j] <- sprintf \\\"C%s\\\" (sourceSeq.[i - 1])\\n                else\\n                    costs.[i].[j] <- costs.[i - 1].[j - 1] + replaceCost\\n\\n                    ops.[i].[j] <-\\n                        sprintf\\n                            \\\"R%s\\\"\\n                            (sourceSeq.[i - 1]\\n                             + (string) (destinationSeq.[j - 1]))\\n\\n                if costs.[i - 1].[j] + deleteCost < costs.[i].[j] then\\n                    costs.[i].[j] <- costs.[i - 1].[j] + deleteCost\\n                    ops.[i].[j] <- sprintf \\\"D%s\\\" (sourceSeq.[i - 1])\\n\\n                if costs.[i].[j - 1] + insertCost < costs.[i].[j] then\\n                    costs.[i].[j] <- costs.[i].[j - 1] + insertCost\\n                    ops.[i].[j] <- sprintf \\\"I%s\\\" (destinationSeq.[j - 1])\\n\\n        costs |> Seq.cast<int> |> Seq.toList, ops |> Seq.cast<string> |> Seq.toList\\n\\n    let rec assembleTransformation (ops: list<string>, i: int, j: int): list<string> =\\n        if i = 0 && j = 0 then\\n            List.empty\\n        else\\n            match ops.[i].[j] with\\n            | o when o = 'C' || o = 'R' ->\\n                let mutable seq =\\n                    assembleTransformation (ops, i - 1, j - 1)\\n                    |> List.toArray\\n\\n                let ch =\\n                    [ ((string) ops.[i].[j]) ] |> List.toArray\\n\\n                seq <- seq |> Array.append ch\\n                seq |> List.ofArray\\n            | 'D' ->\\n                let mutable seq =\\n                    assembleTransformation (ops, i - 1, j)\\n                    |> List.toArray\\n\\n                let ch =\\n                    [ ((string) ops.[i].[j]) ] |> List.toArray\\n\\n                seq <- seq |> Array.append ch\\n                seq |> List.ofArray\\n            | _ ->\\n                let mutable seq =\\n                    assembleTransformation (ops, i, j - 1)\\n                    |> List.toArray\\n\\n                let ch =\\n                    [ ((string) ops.[i].[j]) ] |> List.toArray\\n\\n                seq <- seq |> Array.append ch\\n                seq |> List.ofArray\\n\"",
    "naive string search": "\"﻿namespace Algorithms.Strings\\n\\n/// <summary>\\n/// https://en.wikipedia.org/wiki/String-searching_algorithm#Na%C3%AFve_string_search\\n///\\n/// This algorithm tries to find the pattern from every position of\\n/// the mainString if pattern is found from position i it add it to\\n/// the answer and does the same for position i+1\\n/// </summary>\\n///\\n/// <remarks>\\n/// Complexity : O(n*m)\\n///     n=length of main string\\n///     m=length of pattern string\\n/// </remarks>\\nmodule NaiveStringSearch =\\n    /// <summary>\\n    /// </summary>\\n    /// <example>\\n    /// <code>\\n    /// naive_pattern_search(\\\"ABAAABCDBBABCDDEBCABC\\\", \\\"ABC\\\")\\n    /// [4, 10, 18]\\n    ///\\n    /// naive_pattern_search(\\\"ABC\\\", \\\"ABAAABCDBBABCDDEBCABC\\\")\\n    /// []\\n    ///\\n    /// naive_pattern_search(\\\"\\\", \\\"ABC\\\")\\n    /// []\\n    ///\\n    /// naive_pattern_search(\\\"TEST\\\", \\\"TEST\\\")\\n    /// [0]\\n    ///\\n    /// naive_pattern_search(\\\"ABCDEGFTEST\\\", \\\"TEST\\\")\\n    /// [7]\\n    /// </code>\\n    /// </example>\\n    /// <param name=\\\"s\\\"></param>\\n    /// <param name=\\\"pattern\\\"></param>\\n    /// <returns>List of positions</returns>\\n    let naivePatternSearch (s: string, pattern: string): int list =\\n        s.ToCharArray()\\n        |> Seq.mapi\\n            (fun i x ->\\n                let myv = pattern.[0]\\n\\n                if x = pattern.[0] then\\n                    (i, s.[i..(i + (pattern.Length - 1))])\\n                else\\n                    (i, \\\"\\\"))\\n        |> Seq.where (fun (i, x) -> pattern = x)\\n        |> Seq.map (fun (i, x) -> i)\\n        |> List.ofSeq\\n\"",
    "prefix function": "\"﻿namespace Algorithms.Strings\\n\\n/// https://cp-algorithms.com/string/prefix-function.html\\n///\\n/// Prefix function Knuth–Morris–Pratt algorithm\\n///\\n/// Different algorithm than Knuth-Morris-Pratt pattern finding\\n///\\n/// E.x. Finding longest prefix which is also suffix\\n/// Time Complexity: O(n) - where n is the length of the string\\nmodule PrefixFunction =\\n\\n    /// <summary>\\n    /// For the given string this function computes value for each <c>index(i)</c>,\\n    /// which represents the longest coincidence of prefix and suffix\\n    /// for given substring <c>inputString[0...i]</c>.\\n    /// For the value of the first element the algorithm always returns 0\\n    /// </summary>\\n    /// <example>\\n    /// <code>\\n    /// prefix_function \\\"aabcdaabc\\\"\\n    /// [0, 1, 0, 0, 0, 1, 2, 3, 4]\\n    ///\\n    /// prefix_function(\\\"asdasdad\\\")\\n    /// [0, 0, 0, 1, 2, 3, 4, 0]\\n    /// </code>\\n    /// </example>\\n    /// <param name=\\\"inputString\\\"></param>\\n    /// <returns>A string of <c>int</c></returns>\\n    let prefixFunction (inputString: string): list<int> =\\n\\n        // List for the result values\\n        let mutable prefixResult =\\n            [| for i in 0 .. (inputString.Length - 1) -> 0 |]\\n\\n        for i = 1 to (inputString.Length - 1) do\\n            // Use last results for better performance - dynamic programming\\n            let mutable j = prefixResult.[i - 1]\\n\\n            while j > 0 && inputString.[i] <> inputString.[j] do\\n                j <- prefixResult.[j - 1]\\n\\n            if inputString.[i] = inputString.[j] then\\n                j <- j + 1\\n\\n            prefixResult.SetValue(j, i)\\n\\n        prefixResult |> List.ofArray\\n\\n    /// <summary>\\n    /// Prefix-function use case\\n    /// Finding longest prefix which is suffix as well\\n    /// </summary>\\n    /// <example>\\n    /// <code>\\n    /// longest_prefix \\\"aabcdaabc\\\"\\n    /// 4\\n    /// longest_prefix \\\"asdasdad\\\"\\n    /// 4\\n    /// longest_prefix \\\"abcab\\\"\\n    /// 2\\n    /// </code>\\n    /// </example>\\n    /// <param name=\\\"inputString\\\"></param>\\n    /// <returns>Returns <c>int</c></returns>\\n    let longestPrefix (inputString: string): int =\\n        // Just returning maximum value of the array gives us answer\\n        prefixFunction (inputString)\\n        |> System.Linq.Enumerable.Max\\n\"",
    "rabin karp": "\"﻿namespace Algorithms.Strings\\n\\nmodule RabinKarp =\\n    /// Numbers of alphabet which we call base\\n    let alphabetSize = 256L\\n\\n    /// Modulus to hash a string\\n    let modulus = 1000003L\\n\\n    let nfmod (a: int64, b: int64) =\\n        let aD = double a\\n        let bD = double b\\n        int64 (aD - bD * floor (aD / bD))\\n\\n    /// <summary>\\n    /// The Rabin-Karp Algorithm for finding a pattern within a piece of text\\n    /// with complexity O(nm), most efficient when it is used with multiple patterns\\n    /// as it is able to check if any of a set of patterns match a section of text in o(1)\\n    /// given the precomputed hashes.\\n    /// </summary>\\n    /// <remarks>\\n    /// This will be the simple version which only assumes one pattern is being searched\\n    /// for but it's not hard to modify\\n    ///\\n    /// 1) Calculate pattern hash\\n    ///\\n    /// 2) Step through the text one character at a time passing a window with the same\\n    /// length as the pattern\\n    /// calculating the hash of the text within the window compare it with the hash\\n    /// of the pattern. Only testing equality if the hashes match\\n    /// </remarks>\\n    /// <param name=\\\"pattern\\\"></param>\\n    /// <param name=\\\"text\\\"></param>\\n    /// <returns></returns>\\n    let rabinKarp (pattern: string, text: string): bool =\\n\\n        let mutable result = false\\n\\n        let patLen = pattern.Length\\n        let textLen = text.Length\\n\\n        match patLen with\\n        | p when p > textLen -> false\\n        | _ ->\\n            let mutable patternHash = 0L\\n            let mutable textHash = 0L\\n            let mutable modulusPower = 1L\\n\\n\\n            // Calculating the hash of pattern and substring of text\\n            for i in 0 .. (patLen - 1) do\\n                patternHash <- (int64 (pattern.[i]) + patternHash * alphabetSize) % modulus\\n                textHash <- (int64 (text.[i]) + textHash * alphabetSize) % modulus\\n\\n                if i <> (patLen - 1) then\\n                    modulusPower <- (modulusPower * alphabetSize) % modulus\\n\\n\\n            for i in 0 .. (textLen - patLen + 1) do\\n                if textHash = patternHash\\n                   && text.[i..i + (patLen - 1)] = pattern then\\n                    result <- true\\n\\n                if not result then\\n                    if i <> (textLen - patLen) then\\n                        let first =\\n                            (textHash - int64 (text.[i]) * modulusPower)\\n                            * alphabetSize\\n\\n                        let second = int64 (text.[i + patLen])\\n                        let third = (first + second) % modulus\\n\\n                        textHash <-\\n                            ((((textHash - int64 (text.[i]) * modulusPower)\\n                               * alphabetSize)\\n                              + int64 (text.[i + patLen])) % modulus)\\n                            + modulus\\n\\n            result\\n\"",
    "remove duplicates": "\"﻿namespace Algorithms.Strings\\r\\n\\r\\nmodule RemoveDuplicates =\\r\\n    /// <summary>\\r\\n    /// Remove duplicates from sentence\\r\\n    /// </summary>\\r\\n    let removeDuplicates (str: string) =\\r\\n        str.Split() |> Array.distinct |> String.concat \\\" \\\"\\r\\n\"",
    "reverse letters": "\"﻿namespace Algorithms.Strings\\r\\n\\r\\nmodule ReverseLetters =\\r\\n    /// <summary>\\r\\n    /// Reverses letters in a given string without adjusting the position of the words\\r\\n    /// </summary>\\r\\n    /// <param name=\\\"input\\\">String to reverse.</param>\\r\\n    /// <returns>Reversed string</returns>\\r\\n    let reverseLetters (input: string) =\\r\\n        input.Split()\\r\\n        |> Array.map\\r\\n            (fun x ->\\r\\n                x.ToCharArray()\\r\\n                |> Array.rev\\r\\n                |> (fun c -> System.String.Concat(c)))\\r\\n        |> String.concat \\\" \\\"\\r\\n\"",
    "reverse words": "\"﻿namespace Algorithms.Strings\\r\\n\\r\\nmodule ReverseWords =\\r\\n    /// <summary>\\r\\n    /// Reverses words in a given string\\r\\n    /// </summary>\\r\\n    /// <param name=\\\"input\\\">String to reverse.</param>\\r\\n    /// <returns>Reversed string</returns>\\r\\n    let reverseWords (input: string): string =\\r\\n        input.Split() |> Seq.rev |> String.concat \\\" \\\"\\r\\n\"",
    "split": "\"﻿namespace Algorithms.Strings\\r\\n\\r\\ntype Split() =\\r\\n    /// <summary>\\r\\n    /// Will split the string up into all the values separated by the separator\\r\\n    /// </summary>\\r\\n    /// <param name=\\\"str\\\">String to split into lists</param>\\r\\n    /// <param name=\\\"separator\\\">The separator on what you would like to separate your strings</param>\\r\\n    /// <returns>A string list</returns>\\r\\n    static member Split(str: string, ?separator0: char): string list =\\r\\n        let mutable newStringList: string list = []\\r\\n        let separator = defaultArg separator0 ' '\\r\\n        let mutable value = \\\"\\\"\\r\\n\\r\\n        if str.Contains separator then\\r\\n            for c in str do\\r\\n                match (string) c with\\r\\n                | c when c.Contains separator ->\\r\\n                    newStringList <- newStringList |> List.append <| [ value ]\\r\\n                    value <- \\\"\\\"\\r\\n                | _ -> value <- value + (string) c\\r\\n\\r\\n            if value <> \\\"\\\" then\\r\\n                newStringList <- newStringList |> List.append <| [ value ]\\r\\n                value <- \\\"\\\"\\r\\n        else\\r\\n            newStringList <- [ value ]\\r\\n\\r\\n        newStringList\\r\\n\"",
    "swap case": "\"﻿namespace Algorithms.Strings\\n\\nmodule SwapCase =\\n    type System.Char with\\n        member this.IsUpper(): bool =\\n            match this with\\n            | c when c >= 'A' && c <= 'Z' -> true\\n            | _ -> false\\n\\n        member this.IsLower(): bool =\\n            match this with\\n            | c when c >= 'a' && c <= 'z' -> true\\n            | _ -> false\\n\\n        member this.Lower(): char =\\n            match this with\\n            | c when c >= 'A' && c <= 'Z' -> (char) ((int) this + 32)\\n            | _ -> this\\n\\n        member this.Upper(): char =\\n            match this with\\n            | c when c >= 'a' && c <= 'z' -> (char) ((int) this - 32)\\n            | _ -> this\\n\\n    /// <summary>\\n    /// This function will convert all lowercase letters to uppercase letters and vice versa\\n    /// </summary>\\n    let swapCase (sentence: string): string =\\n        let mutable newString = \\\"\\\"\\n        for character in sentence do\\n            match character with\\n            | c when c.IsUpper() -> newString <- newString + (string) (character.Lower())\\n            | c when c.IsLower() -> newString <- newString + (string) (character.Upper())\\n            | _ -> newString <- newString + (string) character\\n        newString\\n\"",
    "upper": "\"﻿namespace Algorithms.Strings\\n\\nmodule Upper =\\n    /// <summary>\\n    /// Will convert the entire string to uppercase letters\\n    /// </summary>\\n    /// <param name=\\\"input\\\">String to change to uppercase.</param>\\n    /// <returns>Uppercased string</returns>\\n    let upper (input: string) =\\n        input.Split()\\n        |> Array.map\\n            (fun word ->\\n                word.ToCharArray()\\n                |> Array.map\\n                    (fun character ->\\n                        if character >= 'a' && character <= 'z' then\\n                            char (int character - 32)\\n                        else\\n                            character)\\n                |> (fun characters -> System.String.Concat(characters)))\\n        |> String.concat \\\" \\\"\\n\"",
    "word occurrence": "\"﻿namespace Algorithms.Strings\\r\\n\\r\\nopen System.Collections.Generic\\r\\n\\r\\nmodule WordOccurrence =\\r\\n    let wordOccurrence (sentence: string): Map<string, int> =\\r\\n        // Creating a dictionary containing count of each word\\r\\n        let mutable occurrence: Map<string, int> = Map.empty\\r\\n\\r\\n        for word in sentence.Split() do\\r\\n            match word with\\r\\n            | \\\"\\\" -> ignore word\\r\\n            | w when occurrence.ContainsKey(word) -> printfn \\\"%A\\\" (word)\\r\\n            | _ -> occurrence <- occurrence.Add(word, 1)\\r\\n\\r\\n        occurrence\\r\\n\"",
    "z function": "\"﻿///https://cp-algorithms.com/string/z-function.html\\r\\n///\\r\\n///Z-function or Z algorithm\\r\\n///\\r\\n///Efficient algorithm for pattern occurrence in a string\\r\\n///\\r\\n///Time Complexity: O(n) - where n is the length of the string\\r\\nnamespace Algorithms.Strings\\r\\n\\r\\nmodule ZFunction =\\r\\n\\r\\n    let goNext (i, zResult: array<int>, s: string) =\\r\\n        i + zResult.[i] < s.Length\\r\\n        && s.[zResult.[i]] = s.[i + zResult.[i]]\\r\\n\\r\\n    /// <summary>\\r\\n    /// For the given string this function computes value for each index,\\r\\n    /// which represents the maximal length substring starting from the index\\r\\n    /// and is the same as the prefix of the same size\\r\\n    /// </summary>\\r\\n    /// <param name=\\\"inputString\\\"></param>\\r\\n    /// <returns></returns>\\r\\n    let zFunction (inputString: string): list<int> =\\r\\n        let mutable zResult =\\r\\n            [| for i in 1 .. inputString.Length -> 0 |]\\r\\n        // Initialize interval's left pointer and right pointer\\r\\n        let mutable leftPointer, rightPointer = 0, 0\\r\\n\\r\\n        for i in 1 .. inputString.Length - 1 do\\r\\n            // Case when current index is inside the interval\\r\\n            if i <= rightPointer then\\r\\n                let minEdge =\\r\\n                    min (rightPointer - i + 1) (zResult.[i - leftPointer])\\r\\n\\r\\n                zResult.SetValue(minEdge, i)\\r\\n\\r\\n            while goNext (i, zResult, inputString) do\\r\\n                zResult.[i] <- zResult.[i] + 1\\r\\n\\r\\n            // if new index's result gives us more right interval,\\r\\n            // we've to update left_pointer and right_pointer\\r\\n            if i + zResult.[i] - 1 > rightPointer then\\r\\n                leftPointer <- i\\r\\n                rightPointer <- i + zResult.[i] - 1\\r\\n\\r\\n        zResult |> List.ofArray\\r\\n\\r\\n\\r\\n    let findPattern (pattern: string, inputString: string): int =\\r\\n        let mutable answer = 0\\r\\n        // Concatenate 'pattern' and 'input_str' and call z_function\\r\\n        // with concatenated string\\r\\n        let zResult = zFunction (pattern + inputString)\\r\\n\\r\\n        for value in zResult do\\r\\n            // If value is greater then length of the pattern string\\r\\n            // that means this index is starting position of substring\\r\\n            // which is equal to pattern string\\r\\n            if value >= pattern.Length then\\r\\n                answer <- answer + 1\\r\\n\\r\\n        answer\\r\\n\""
  }
}
