{
  "python": {
    "bisection": "\"\\\"\\\"\\\"\\nGiven a function on floating number f(x) and two floating numbers ‘a’ and ‘b’ such that\\nf(a) * f(b) < 0 and f(x) is continuous in [a, b].\\nHere f(x) represents algebraic or transcendental equation.\\nFind root of function in interval [a, b] (Or find a value of x such that f(x) is 0)\\n\\nhttps://en.wikipedia.org/wiki/Bisection_method\\n\\\"\\\"\\\"\\n\\n\\ndef equation(x: float) -> float:\\n    \\\"\\\"\\\"\\n    >>> equation(5)\\n    -15\\n    >>> equation(0)\\n    10\\n    >>> equation(-5)\\n    -15\\n    >>> equation(0.1)\\n    9.99\\n    >>> equation(-0.1)\\n    9.99\\n    \\\"\\\"\\\"\\n    return 10 - x * x\\n\\n\\ndef bisection(a: float, b: float) -> float:\\n    \\\"\\\"\\\"\\n    >>> bisection(-2, 5)\\n    3.1611328125\\n    >>> bisection(0, 6)\\n    3.158203125\\n    >>> bisection(2, 3)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Wrong space!\\n    \\\"\\\"\\\"\\n    # Bolzano theory in order to find if there is a root between a and b\\n    if equation(a) * equation(b) >= 0:\\n        raise ValueError(\\\"Wrong space!\\\")\\n\\n    c = a\\n    while (b - a) >= 0.01:\\n        # Find middle point\\n        c = (a + b) / 2\\n        # Check if middle point is root\\n        if equation(c) == 0.0:\\n            break\\n        # Decide the side to repeat the steps\\n        if equation(c) * equation(a) < 0:\\n            b = c\\n        else:\\n            a = c\\n    return c\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    print(bisection(-2, 5))\\n    print(bisection(0, 6))\\n\"",
    "gaussian elimination": "\"\\\"\\\"\\\"\\nGaussian elimination method for solving a system of linear equations.\\nGaussian elimination - https://en.wikipedia.org/wiki/Gaussian_elimination\\n\\\"\\\"\\\"\\n\\n\\nimport numpy as np\\n\\n\\ndef retroactive_resolution(coefficients: np.matrix, vector: np.ndarray) -> np.ndarray:\\n    \\\"\\\"\\\"\\n    This function performs a retroactive linear system resolution\\n        for triangular matrix\\n\\n    Examples:\\n        2x1 + 2x2 - 1x3 = 5         2x1 + 2x2 = -1\\n        0x1 - 2x2 - 1x3 = -7        0x1 - 2x2 = -1\\n        0x1 + 0x2 + 5x3 = 15\\n    >>> gaussian_elimination([[2, 2, -1], [0, -2, -1], [0, 0, 5]], [[5], [-7], [15]])\\n    array([[2.],\\n           [2.],\\n           [3.]])\\n    >>> gaussian_elimination([[2, 2], [0, -2]], [[-1], [-1]])\\n    array([[-1. ],\\n           [ 0.5]])\\n    \\\"\\\"\\\"\\n\\n    rows, columns = np.shape(coefficients)\\n\\n    x = np.zeros((rows, 1), dtype=float)\\n    for row in reversed(range(rows)):\\n        sum = 0\\n        for col in range(row + 1, columns):\\n            sum += coefficients[row, col] * x[col]\\n\\n        x[row, 0] = (vector[row] - sum) / coefficients[row, row]\\n\\n    return x\\n\\n\\ndef gaussian_elimination(coefficients: np.matrix, vector: np.ndarray) -> np.ndarray:\\n    \\\"\\\"\\\"\\n    This function performs Gaussian elimination method\\n\\n    Examples:\\n        1x1 - 4x2 - 2x3 = -2        1x1 + 2x2 = 5\\n        5x1 + 2x2 - 2x3 = -3        5x1 + 2x2 = 5\\n        1x1 - 1x2 + 0x3 = 4\\n    >>> gaussian_elimination([[1, -4, -2], [5, 2, -2], [1, -1, 0]], [[-2], [-3], [4]])\\n    array([[ 2.3 ],\\n           [-1.7 ],\\n           [ 5.55]])\\n    >>> gaussian_elimination([[1, 2], [5, 2]], [[5], [5]])\\n    array([[0. ],\\n           [2.5]])\\n    \\\"\\\"\\\"\\n    # coefficients must to be a square matrix so we need to check first\\n    rows, columns = np.shape(coefficients)\\n    if rows != columns:\\n        return np.array((), dtype=float)\\n\\n    # augmented matrix\\n    augmented_mat = np.concatenate((coefficients, vector), axis=1)\\n    augmented_mat = augmented_mat.astype(\\\"float64\\\")\\n\\n    # scale the matrix leaving it triangular\\n    for row in range(rows - 1):\\n        pivot = augmented_mat[row, row]\\n        for col in range(row + 1, columns):\\n            factor = augmented_mat[col, row] / pivot\\n            augmented_mat[col, :] -= factor * augmented_mat[row, :]\\n\\n    x = retroactive_resolution(\\n        augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]\\n    )\\n\\n    return x\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "intersection": "\"import math\\nfrom typing import Callable\\n\\n\\ndef intersection(function: Callable[[float], float], x0: float, x1: float) -> float:\\n    \\\"\\\"\\\"\\n    function is the f we want to find its root\\n    x0 and x1 are two random starting points\\n    >>> intersection(lambda x: x ** 3 - 1, -5, 5)\\n    0.9999999999954654\\n    >>> intersection(lambda x: x ** 3 - 1, 5, 5)\\n    Traceback (most recent call last):\\n    ...\\n    ZeroDivisionError: float division by zero, could not find root\\n    >>> intersection(lambda x: x ** 3 - 1, 100, 200)\\n    1.0000000000003888\\n    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\\n    0.9999999998088019\\n    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\\n    2.9999999998088023\\n    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\\n    3.0000000001786042\\n    >>> intersection(math.sin, -math.pi, math.pi)\\n    0.0\\n    >>> intersection(math.cos, -math.pi, math.pi)\\n    Traceback (most recent call last):\\n    ...\\n    ZeroDivisionError: float division by zero, could not find root\\n    \\\"\\\"\\\"\\n    x_n: float = x0\\n    x_n1: float = x1\\n    while True:\\n        if x_n == x_n1 or function(x_n1) == function(x_n):\\n            raise ZeroDivisionError(\\\"float division by zero, could not find root\\\")\\n        x_n2: float = x_n1 - (\\n            function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))\\n        )\\n        if abs(x_n2 - x_n1) < 10 ** -5:\\n            return x_n2\\n        x_n = x_n1\\n        x_n1 = x_n2\\n\\n\\ndef f(x: float) -> float:\\n    return math.pow(x, 3) - (2 * x) - 5\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(intersection(f, 3, 3.5))\\n\"",
    "in static equilibrium": "\"\\\"\\\"\\\"\\r\\nChecks if a system of forces is in static equilibrium.\\r\\n\\\"\\\"\\\"\\r\\nfrom __future__ import annotations\\r\\n\\r\\nfrom numpy import array, cos, cross, ndarray, radians, sin\\r\\n\\r\\n\\r\\ndef polar_force(\\r\\n    magnitude: float, angle: float, radian_mode: bool = False\\r\\n) -> list[float]:\\r\\n    \\\"\\\"\\\"\\r\\n    Resolves force along rectangular components.\\r\\n    (force, angle) => (force_x, force_y)\\r\\n    >>> polar_force(10, 45)\\r\\n    [7.0710678118654755, 7.071067811865475]\\r\\n    >>> polar_force(10, 3.14, radian_mode=True)\\r\\n    [-9.999987317275394, 0.01592652916486828]\\r\\n    \\\"\\\"\\\"\\r\\n    if radian_mode:\\r\\n        return [magnitude * cos(angle), magnitude * sin(angle)]\\r\\n    return [magnitude * cos(radians(angle)), magnitude * sin(radians(angle))]\\r\\n\\r\\n\\r\\ndef in_static_equilibrium(\\r\\n    forces: ndarray, location: ndarray, eps: float = 10 ** -1\\r\\n) -> bool:\\r\\n    \\\"\\\"\\\"\\r\\n    Check if a system is in equilibrium.\\r\\n    It takes two numpy.array objects.\\r\\n    forces ==>  [\\r\\n                        [force1_x, force1_y],\\r\\n                        [force2_x, force2_y],\\r\\n                        ....]\\r\\n    location ==>  [\\r\\n                        [x1, y1],\\r\\n                        [x2, y2],\\r\\n                        ....]\\r\\n    >>> force = array([[1, 1], [-1, 2]])\\r\\n    >>> location = array([[1, 0], [10, 0]])\\r\\n    >>> in_static_equilibrium(force, location)\\r\\n    False\\r\\n    \\\"\\\"\\\"\\r\\n    # summation of moments is zero\\r\\n    moments: ndarray = cross(location, forces)\\r\\n    sum_moments: float = sum(moments)\\r\\n    return abs(sum_moments) < eps\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    # Test to check if it works\\r\\n    forces = array(\\r\\n        [polar_force(718.4, 180 - 30), polar_force(879.54, 45), polar_force(100, -90)]\\r\\n    )\\r\\n\\r\\n    location = array([[0, 0], [0, 0], [0, 0]])\\r\\n\\r\\n    assert in_static_equilibrium(forces, location)\\r\\n\\r\\n    # Problem 1 in image_data/2D_problems.jpg\\r\\n    forces = array(\\r\\n        [\\r\\n            polar_force(30 * 9.81, 15),\\r\\n            polar_force(215, 180 - 45),\\r\\n            polar_force(264, 90 - 30),\\r\\n        ]\\r\\n    )\\r\\n\\r\\n    location = array([[0, 0], [0, 0], [0, 0]])\\r\\n\\r\\n    assert in_static_equilibrium(forces, location)\\r\\n\\r\\n    # Problem in image_data/2D_problems_1.jpg\\r\\n    forces = array([[0, -2000], [0, -1200], [0, 15600], [0, -12400]])\\r\\n\\r\\n    location = array([[0, 0], [6, 0], [10, 0], [12, 0]])\\r\\n\\r\\n    assert in_static_equilibrium(forces, location)\\r\\n\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "jacobi iteration method": "\"\\\"\\\"\\\"\\r\\nJacobi Iteration Method - https://en.wikipedia.org/wiki/Jacobi_method\\r\\n\\\"\\\"\\\"\\r\\nfrom __future__ import annotations\\r\\n\\r\\nimport numpy as np\\r\\n\\r\\n\\r\\n# Method to find solution of system of linear equations\\r\\ndef jacobi_iteration_method(\\r\\n    coefficient_matrix: np.ndarray,\\r\\n    constant_matrix: np.ndarray,\\r\\n    init_val: list,\\r\\n    iterations: int,\\r\\n) -> list[float]:\\r\\n    \\\"\\\"\\\"\\r\\n    Jacobi Iteration Method:\\r\\n    An iterative algorithm to determine the solutions of strictly diagonally dominant\\r\\n    system of linear equations\\r\\n\\r\\n    4x1 +  x2 +  x3 =  2\\r\\n     x1 + 5x2 + 2x3 = -6\\r\\n     x1 + 2x2 + 4x3 = -4\\r\\n\\r\\n    x_init = [0.5, -0.5 , -0.5]\\r\\n\\r\\n    Examples:\\r\\n\\r\\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\\r\\n    >>> constant = np.array([[2], [-6], [-4]])\\r\\n    >>> init_val = [0.5, -0.5, -0.5]\\r\\n    >>> iterations = 3\\r\\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\\r\\n    [0.909375, -1.14375, -0.7484375]\\r\\n\\r\\n\\r\\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2]])\\r\\n    >>> constant = np.array([[2], [-6], [-4]])\\r\\n    >>> init_val = [0.5, -0.5, -0.5]\\r\\n    >>> iterations = 3\\r\\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\\r\\n    Traceback (most recent call last):\\r\\n    ...\\r\\n    ValueError: Coefficient matrix dimensions must be nxn but received 2x3\\r\\n\\r\\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\\r\\n    >>> constant = np.array([[2], [-6]])\\r\\n    >>> init_val = [0.5, -0.5, -0.5]\\r\\n    >>> iterations = 3\\r\\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\\r\\n    Traceback (most recent call last):\\r\\n    ...\\r\\n    ValueError: Coefficient and constant matrices dimensions must be nxn and nx1 but\\r\\n                received 3x3 and 2x1\\r\\n\\r\\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\\r\\n    >>> constant = np.array([[2], [-6], [-4]])\\r\\n    >>> init_val = [0.5, -0.5]\\r\\n    >>> iterations = 3\\r\\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\\r\\n    Traceback (most recent call last):\\r\\n    ...\\r\\n    ValueError: Number of initial values must be equal to number of rows in coefficient\\r\\n                matrix but received 2 and 3\\r\\n\\r\\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\\r\\n    >>> constant = np.array([[2], [-6], [-4]])\\r\\n    >>> init_val = [0.5, -0.5, -0.5]\\r\\n    >>> iterations = 0\\r\\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\\r\\n    Traceback (most recent call last):\\r\\n    ...\\r\\n    ValueError: Iterations must be at least 1\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    rows1, cols1 = coefficient_matrix.shape\\r\\n    rows2, cols2 = constant_matrix.shape\\r\\n\\r\\n    if rows1 != cols1:\\r\\n        raise ValueError(\\r\\n            f\\\"Coefficient matrix dimensions must be nxn but received {rows1}x{cols1}\\\"\\r\\n        )\\r\\n\\r\\n    if cols2 != 1:\\r\\n        raise ValueError(f\\\"Constant matrix must be nx1 but received {rows2}x{cols2}\\\")\\r\\n\\r\\n    if rows1 != rows2:\\r\\n        raise ValueError(\\r\\n            f\\\"\\\"\\\"Coefficient and constant matrices dimensions must be nxn and nx1 but\\r\\n            received {rows1}x{cols1} and {rows2}x{cols2}\\\"\\\"\\\"\\r\\n        )\\r\\n\\r\\n    if len(init_val) != rows1:\\r\\n        raise ValueError(\\r\\n            f\\\"\\\"\\\"Number of initial values must be equal to number of rows in coefficient\\r\\n            matrix but received {len(init_val)} and {rows1}\\\"\\\"\\\"\\r\\n        )\\r\\n\\r\\n    if iterations <= 0:\\r\\n        raise ValueError(\\\"Iterations must be at least 1\\\")\\r\\n\\r\\n    table = np.concatenate((coefficient_matrix, constant_matrix), axis=1)\\r\\n\\r\\n    rows, cols = table.shape\\r\\n\\r\\n    strictly_diagonally_dominant(table)\\r\\n\\r\\n    # Iterates the whole matrix for given number of times\\r\\n    for i in range(iterations):\\r\\n        new_val = []\\r\\n        for row in range(rows):\\r\\n            temp = 0\\r\\n            for col in range(cols):\\r\\n                if col == row:\\r\\n                    denom = table[row][col]\\r\\n                elif col == cols - 1:\\r\\n                    val = table[row][col]\\r\\n                else:\\r\\n                    temp += (-1) * table[row][col] * init_val[col]\\r\\n            temp = (temp + val) / denom\\r\\n            new_val.append(temp)\\r\\n        init_val = new_val\\r\\n\\r\\n    return [float(i) for i in new_val]\\r\\n\\r\\n\\r\\n# Checks if the given matrix is strictly diagonally dominant\\r\\ndef strictly_diagonally_dominant(table: np.ndarray) -> bool:\\r\\n    \\\"\\\"\\\"\\r\\n    >>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 4, -4]])\\r\\n    >>> strictly_diagonally_dominant(table)\\r\\n    True\\r\\n\\r\\n    >>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 3, -4]])\\r\\n    >>> strictly_diagonally_dominant(table)\\r\\n    Traceback (most recent call last):\\r\\n    ...\\r\\n    ValueError: Coefficient matrix is not strictly diagonally dominant\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    rows, cols = table.shape\\r\\n\\r\\n    is_diagonally_dominant = True\\r\\n\\r\\n    for i in range(0, rows):\\r\\n        sum = 0\\r\\n        for j in range(0, cols - 1):\\r\\n            if i == j:\\r\\n                continue\\r\\n            else:\\r\\n                sum += table[i][j]\\r\\n\\r\\n        if table[i][i] <= sum:\\r\\n            raise ValueError(\\\"Coefficient matrix is not strictly diagonally dominant\\\")\\r\\n\\r\\n    return is_diagonally_dominant\\r\\n\\r\\n\\r\\n# Test Cases\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "lu decomposition": "\"\\\"\\\"\\\"Lower-Upper (LU) Decomposition.\\n\\nReference:\\n- https://en.wikipedia.org/wiki/LU_decomposition\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport numpy as np\\n\\n\\ndef lower_upper_decomposition(table: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\\n    \\\"\\\"\\\"Lower-Upper (LU) Decomposition\\n\\n    Example:\\n\\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])\\n    >>> outcome = lower_upper_decomposition(matrix)\\n    >>> outcome[0]\\n    array([[1. , 0. , 0. ],\\n           [0. , 1. , 0. ],\\n           [2.5, 8. , 1. ]])\\n    >>> outcome[1]\\n    array([[  2. ,  -2. ,   1. ],\\n           [  0. ,   1. ,   2. ],\\n           [  0. ,   0. , -17.5]])\\n\\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2]])\\n    >>> lower_upper_decomposition(matrix)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: 'table' has to be of square shaped array but got a 2x3 array:\\n    [[ 2 -2  1]\\n     [ 0  1  2]]\\n    \\\"\\\"\\\"\\n    # Table that contains our data\\n    # Table has to be a square array so we need to check first\\n    rows, columns = np.shape(table)\\n    if rows != columns:\\n        raise ValueError(\\n            f\\\"'table' has to be of square shaped array but got a {rows}x{columns} \\\"\\n            + f\\\"array:\\\\n{table}\\\"\\n        )\\n    lower = np.zeros((rows, columns))\\n    upper = np.zeros((rows, columns))\\n    for i in range(columns):\\n        for j in range(i):\\n            total = 0\\n            for k in range(j):\\n                total += lower[i][k] * upper[k][j]\\n            lower[i][j] = (table[i][j] - total) / upper[j][j]\\n        lower[i][i] = 1\\n        for j in range(i, columns):\\n            total = 0\\n            for k in range(i):\\n                total += lower[i][k] * upper[k][j]\\n            upper[i][j] = table[i][j] - total\\n    return lower, upper\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "newton forward interpolation": "\"# https://www.geeksforgeeks.org/newton-forward-backward-interpolation/\\nfrom __future__ import annotations\\n\\nimport math\\n\\n\\n# for calculating u value\\ndef ucal(u: float, p: int) -> float:\\n    \\\"\\\"\\\"\\n    >>> ucal(1, 2)\\n    0\\n    >>> ucal(1.1, 2)\\n    0.11000000000000011\\n    >>> ucal(1.2, 2)\\n    0.23999999999999994\\n    \\\"\\\"\\\"\\n    temp = u\\n    for i in range(1, p):\\n        temp = temp * (u - i)\\n    return temp\\n\\n\\ndef main() -> None:\\n    n = int(input(\\\"enter the numbers of values: \\\"))\\n    y: list[list[float]] = []\\n    for i in range(n):\\n        y.append([])\\n    for i in range(n):\\n        for j in range(n):\\n            y[i].append(j)\\n            y[i][j] = 0\\n\\n    print(\\\"enter the values of parameters in a list: \\\")\\n    x = list(map(int, input().split()))\\n\\n    print(\\\"enter the values of corresponding parameters: \\\")\\n    for i in range(n):\\n        y[i][0] = float(input())\\n\\n    value = int(input(\\\"enter the value to interpolate: \\\"))\\n    u = (value - x[0]) / (x[1] - x[0])\\n\\n    # for calculating forward difference table\\n\\n    for i in range(1, n):\\n        for j in range(n - i):\\n            y[j][i] = y[j + 1][i - 1] - y[j][i - 1]\\n\\n    summ = y[0][0]\\n    for i in range(1, n):\\n        summ += (ucal(u, i) * y[0][i]) / math.factorial(i)\\n\\n    print(f\\\"the value at {value} is {summ}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "newton method": "\"\\\"\\\"\\\"Newton's Method.\\\"\\\"\\\"\\n\\n# Newton's Method - https://en.wikipedia.org/wiki/Newton%27s_method\\nfrom typing import Callable\\n\\nRealFunc = Callable[[float], float]  # type alias for a real -> real function\\n\\n\\n# function is the f(x) and derivative is the f'(x)\\ndef newton(\\n    function: RealFunc,\\n    derivative: RealFunc,\\n    starting_int: int,\\n) -> float:\\n    \\\"\\\"\\\"\\n    >>> newton(lambda x: x ** 3 - 2 * x - 5, lambda x: 3 * x ** 2 - 2, 3)\\n    2.0945514815423474\\n    >>> newton(lambda x: x ** 3 - 1, lambda x: 3 * x ** 2, -2)\\n    1.0\\n    >>> newton(lambda x: x ** 3 - 1, lambda x: 3 * x ** 2, -4)\\n    1.0000000000000102\\n    >>> import math\\n    >>> newton(math.sin, math.cos, 1)\\n    0.0\\n    >>> newton(math.sin, math.cos, 2)\\n    3.141592653589793\\n    >>> newton(math.cos, lambda x: -math.sin(x), 2)\\n    1.5707963267948966\\n    >>> newton(math.cos, lambda x: -math.sin(x), 0)\\n    Traceback (most recent call last):\\n    ...\\n    ZeroDivisionError: Could not find root\\n    \\\"\\\"\\\"\\n    prev_guess = float(starting_int)\\n    while True:\\n        try:\\n            next_guess = prev_guess - function(prev_guess) / derivative(prev_guess)\\n        except ZeroDivisionError:\\n            raise ZeroDivisionError(\\\"Could not find root\\\") from None\\n        if abs(prev_guess - next_guess) < 10 ** -5:\\n            return next_guess\\n        prev_guess = next_guess\\n\\n\\ndef f(x: float) -> float:\\n    return (x ** 3) - (2 * x) - 5\\n\\n\\ndef f1(x: float) -> float:\\n    return 3 * (x ** 2) - 2\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(newton(f, f1, 3))\\n\"",
    "newton raphson": "\"\\\"\\\"\\\"\\n    Author: P Shreyas Shetty\\n    Implementation of Newton-Raphson method for solving equations of kind\\n    f(x) = 0. It is an iterative method where solution is found by the expression\\n        x[n+1] = x[n] + f(x[n])/f'(x[n])\\n    If no solution exists, then either the solution will not be found when iteration\\n    limit is reached or the gradient f'(x[n]) approaches zero. In both cases, exception\\n    is raised. If iteration limit is reached, try increasing maxiter.\\n    \\\"\\\"\\\"\\nimport math as m\\n\\n\\ndef calc_derivative(f, a, h=0.001):\\n    \\\"\\\"\\\"\\n    Calculates derivative at point a for function f using finite difference\\n    method\\n    \\\"\\\"\\\"\\n    return (f(a + h) - f(a - h)) / (2 * h)\\n\\n\\ndef newton_raphson(f, x0=0, maxiter=100, step=0.0001, maxerror=1e-6, logsteps=False):\\n\\n    a = x0  # set the initial guess\\n    steps = [a]\\n    error = abs(f(a))\\n    f1 = lambda x: calc_derivative(f, x, h=step)  # noqa: E731  Derivative of f(x)\\n    for _ in range(maxiter):\\n        if f1(a) == 0:\\n            raise ValueError(\\\"No converging solution found\\\")\\n        a = a - f(a) / f1(a)  # Calculate the next estimate\\n        if logsteps:\\n            steps.append(a)\\n        if error < maxerror:\\n            break\\n    else:\\n        raise ValueError(\\\"Iteration limit reached, no converging solution found\\\")\\n    if logsteps:\\n        # If logstep is true, then log intermediate steps\\n        return a, error, steps\\n    return a, error\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from matplotlib import pyplot as plt\\n\\n    f = lambda x: m.tanh(x) ** 2 - m.exp(3 * x)  # noqa: E731\\n    solution, error, steps = newton_raphson(\\n        f, x0=10, maxiter=1000, step=1e-6, logsteps=True\\n    )\\n    plt.plot([abs(f(x)) for x in steps])\\n    plt.xlabel(\\\"step\\\")\\n    plt.ylabel(\\\"error\\\")\\n    plt.show()\\n    print(f\\\"solution = {{{solution:f}}}, error = {{{error:f}}}\\\")\\n\"",
    "secant method": "\"\\\"\\\"\\\"\\nImplementing Secant method in Python\\nAuthor: dimgrichr\\n\\\"\\\"\\\"\\nfrom math import exp\\n\\n\\ndef f(x: float) -> float:\\n    \\\"\\\"\\\"\\n    >>> f(5)\\n    39.98652410600183\\n    \\\"\\\"\\\"\\n    return 8 * x - 2 * exp(-x)\\n\\n\\ndef secant_method(lower_bound: float, upper_bound: float, repeats: int) -> float:\\n    \\\"\\\"\\\"\\n    >>> secant_method(1, 3, 2)\\n    0.2139409276214589\\n    \\\"\\\"\\\"\\n    x0 = lower_bound\\n    x1 = upper_bound\\n    for i in range(0, repeats):\\n        x0, x1 = x1, x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0))\\n    return x1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(f\\\"Example: {secant_method(1, 3, 2)}\\\")\\n\"",
    "butterworth filter": "\"from math import cos, sin, sqrt, tau\\n\\nfrom audio_filters.iir_filter import IIRFilter\\n\\n\\\"\\\"\\\"\\nCreate 2nd-order IIR filters with Butterworth design.\\n\\nCode based on https://webaudio.github.io/Audio-EQ-Cookbook/audio-eq-cookbook.html\\nAlternatively you can use scipy.signal.butter, which should yield the same results.\\n\\\"\\\"\\\"\\n\\n\\ndef make_lowpass(\\n    frequency: int, samplerate: int, q_factor: float = 1 / sqrt(2)\\n) -> IIRFilter:\\n    \\\"\\\"\\\"\\n    Creates a low-pass filter\\n\\n    >>> filter = make_lowpass(1000, 48000)\\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.004277569313094809,\\n     0.008555138626189618, 0.004277569313094809]\\n    \\\"\\\"\\\"\\n    w0 = tau * frequency / samplerate\\n    _sin = sin(w0)\\n    _cos = cos(w0)\\n    alpha = _sin / (2 * q_factor)\\n\\n    b0 = (1 - _cos) / 2\\n    b1 = 1 - _cos\\n\\n    a0 = 1 + alpha\\n    a1 = -2 * _cos\\n    a2 = 1 - alpha\\n\\n    filt = IIRFilter(2)\\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b0])\\n    return filt\\n\\n\\ndef make_highpass(\\n    frequency: int, samplerate: int, q_factor: float = 1 / sqrt(2)\\n) -> IIRFilter:\\n    \\\"\\\"\\\"\\n    Creates a high-pass filter\\n\\n    >>> filter = make_highpass(1000, 48000)\\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9957224306869052,\\n     -1.9914448613738105, 0.9957224306869052]\\n    \\\"\\\"\\\"\\n    w0 = tau * frequency / samplerate\\n    _sin = sin(w0)\\n    _cos = cos(w0)\\n    alpha = _sin / (2 * q_factor)\\n\\n    b0 = (1 + _cos) / 2\\n    b1 = -1 - _cos\\n\\n    a0 = 1 + alpha\\n    a1 = -2 * _cos\\n    a2 = 1 - alpha\\n\\n    filt = IIRFilter(2)\\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b0])\\n    return filt\\n\\n\\ndef make_bandpass(\\n    frequency: int, samplerate: int, q_factor: float = 1 / sqrt(2)\\n) -> IIRFilter:\\n    \\\"\\\"\\\"\\n    Creates a band-pass filter\\n\\n    >>> filter = make_bandpass(1000, 48000)\\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.06526309611002579,\\n     0, -0.06526309611002579]\\n    \\\"\\\"\\\"\\n    w0 = tau * frequency / samplerate\\n    _sin = sin(w0)\\n    _cos = cos(w0)\\n    alpha = _sin / (2 * q_factor)\\n\\n    b0 = _sin / 2\\n    b1 = 0\\n    b2 = -b0\\n\\n    a0 = 1 + alpha\\n    a1 = -2 * _cos\\n    a2 = 1 - alpha\\n\\n    filt = IIRFilter(2)\\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\\n    return filt\\n\\n\\ndef make_allpass(\\n    frequency: int, samplerate: int, q_factor: float = 1 / sqrt(2)\\n) -> IIRFilter:\\n    \\\"\\\"\\\"\\n    Creates an all-pass filter\\n\\n    >>> filter = make_allpass(1000, 48000)\\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9077040443587427,\\n     -1.9828897227476208, 1.0922959556412573]\\n    \\\"\\\"\\\"\\n    w0 = tau * frequency / samplerate\\n    _sin = sin(w0)\\n    _cos = cos(w0)\\n    alpha = _sin / (2 * q_factor)\\n\\n    b0 = 1 - alpha\\n    b1 = -2 * _cos\\n    b2 = 1 + alpha\\n\\n    filt = IIRFilter(2)\\n    filt.set_coefficients([b2, b1, b0], [b0, b1, b2])\\n    return filt\\n\\n\\ndef make_peak(\\n    frequency: int, samplerate: int, gain_db: float, q_factor: float = 1 / sqrt(2)\\n) -> IIRFilter:\\n    \\\"\\\"\\\"\\n    Creates a peak filter\\n\\n    >>> filter = make_peak(1000, 48000, 6)\\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\\n    [1.0653405327119334, -1.9828897227476208, 0.9346594672880666, 1.1303715025601122,\\n     -1.9828897227476208, 0.8696284974398878]\\n    \\\"\\\"\\\"\\n    w0 = tau * frequency / samplerate\\n    _sin = sin(w0)\\n    _cos = cos(w0)\\n    alpha = _sin / (2 * q_factor)\\n    big_a = 10 ** (gain_db / 40)\\n\\n    b0 = 1 + alpha * big_a\\n    b1 = -2 * _cos\\n    b2 = 1 - alpha * big_a\\n    a0 = 1 + alpha / big_a\\n    a1 = -2 * _cos\\n    a2 = 1 - alpha / big_a\\n\\n    filt = IIRFilter(2)\\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\\n    return filt\\n\\n\\ndef make_lowshelf(\\n    frequency: int, samplerate: int, gain_db: float, q_factor: float = 1 / sqrt(2)\\n) -> IIRFilter:\\n    \\\"\\\"\\\"\\n    Creates a low-shelf filter\\n\\n    >>> filter = make_lowshelf(1000, 48000, 6)\\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\\n    [3.0409336710888786, -5.608870992220748, 2.602157875636628, 3.139954022810743,\\n     -5.591841778072785, 2.5201667380627257]\\n    \\\"\\\"\\\"\\n    w0 = tau * frequency / samplerate\\n    _sin = sin(w0)\\n    _cos = cos(w0)\\n    alpha = _sin / (2 * q_factor)\\n    big_a = 10 ** (gain_db / 40)\\n    pmc = (big_a + 1) - (big_a - 1) * _cos\\n    ppmc = (big_a + 1) + (big_a - 1) * _cos\\n    mpc = (big_a - 1) - (big_a + 1) * _cos\\n    pmpc = (big_a - 1) + (big_a + 1) * _cos\\n    aa2 = 2 * sqrt(big_a) * alpha\\n\\n    b0 = big_a * (pmc + aa2)\\n    b1 = 2 * big_a * mpc\\n    b2 = big_a * (pmc - aa2)\\n    a0 = ppmc + aa2\\n    a1 = -2 * pmpc\\n    a2 = ppmc - aa2\\n\\n    filt = IIRFilter(2)\\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\\n    return filt\\n\\n\\ndef make_highshelf(\\n    frequency: int, samplerate: int, gain_db: float, q_factor: float = 1 / sqrt(2)\\n) -> IIRFilter:\\n    \\\"\\\"\\\"\\n    Creates a high-shelf filter\\n\\n    >>> filter = make_highshelf(1000, 48000, 6)\\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\\n    [2.2229172136088806, -3.9587208137297303, 1.7841414181566304, 4.295432981120543,\\n     -7.922740859457287, 3.6756456963725253]\\n    \\\"\\\"\\\"\\n    w0 = tau * frequency / samplerate\\n    _sin = sin(w0)\\n    _cos = cos(w0)\\n    alpha = _sin / (2 * q_factor)\\n    big_a = 10 ** (gain_db / 40)\\n    pmc = (big_a + 1) - (big_a - 1) * _cos\\n    ppmc = (big_a + 1) + (big_a - 1) * _cos\\n    mpc = (big_a - 1) - (big_a + 1) * _cos\\n    pmpc = (big_a - 1) + (big_a + 1) * _cos\\n    aa2 = 2 * sqrt(big_a) * alpha\\n\\n    b0 = big_a * (ppmc + aa2)\\n    b1 = -2 * big_a * pmpc\\n    b2 = big_a * (ppmc - aa2)\\n    a0 = pmc + aa2\\n    a1 = 2 * mpc\\n    a2 = pmc - aa2\\n\\n    filt = IIRFilter(2)\\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\\n    return filt\\n\"",
    "iir filter": "\"from __future__ import annotations\\n\\n\\nclass IIRFilter:\\n    r\\\"\\\"\\\"\\n    N-Order IIR filter\\n    Assumes working with float samples normalized on [-1, 1]\\n\\n    ---\\n\\n    Implementation details:\\n    Based on the 2nd-order function from\\n     https://en.wikipedia.org/wiki/Digital_biquad_filter,\\n    this generalized N-order function was made.\\n\\n    Using the following transfer function\\n    H(z)=\\\\frac{b_{0}+b_{1}z^{-1}+b_{2}z^{-2}+...+b_{k}z^{-k}}{a_{0}+a_{1}z^{-1}+a_{2}z^{-2}+...+a_{k}z^{-k}}\\n    we can rewrite this to\\n    y[n]={\\\\frac{1}{a_{0}}}\\\\left(\\\\left(b_{0}x[n]+b_{1}x[n-1]+b_{2}x[n-2]+...+b_{k}x[n-k]\\\\right)-\\\\left(a_{1}y[n-1]+a_{2}y[n-2]+...+a_{k}y[n-k]\\\\right)\\\\right)\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, order: int) -> None:\\n        self.order = order\\n\\n        # a_{0} ... a_{k}\\n        self.a_coeffs = [1.0] + [0.0] * order\\n        # b_{0} ... b_{k}\\n        self.b_coeffs = [1.0] + [0.0] * order\\n\\n        # x[n-1] ... x[n-k]\\n        self.input_history = [0.0] * self.order\\n        # y[n-1] ... y[n-k]\\n        self.output_history = [0.0] * self.order\\n\\n    def set_coefficients(self, a_coeffs: list[float], b_coeffs: list[float]) -> None:\\n        \\\"\\\"\\\"\\n        Set the coefficients for the IIR filter. These should both be of size order + 1.\\n        a_0 may be left out, and it will use 1.0 as default value.\\n\\n        This method works well with scipy's filter design functions\\n            >>> # Make a 2nd-order 1000Hz butterworth lowpass filter\\n            >>> import scipy.signal\\n            >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,\\n            ...                                          btype='lowpass',\\n            ...                                          fs=48000)\\n            >>> filt = IIRFilter(2)\\n            >>> filt.set_coefficients(a_coeffs, b_coeffs)\\n        \\\"\\\"\\\"\\n        if len(a_coeffs) < self.order:\\n            a_coeffs = [1.0] + a_coeffs\\n\\n        if len(a_coeffs) != self.order + 1:\\n            raise ValueError(\\n                f\\\"Expected a_coeffs to have {self.order + 1} elements for {self.order}\\\"\\n                f\\\"-order filter, got {len(a_coeffs)}\\\"\\n            )\\n\\n        if len(b_coeffs) != self.order + 1:\\n            raise ValueError(\\n                f\\\"Expected b_coeffs to have {self.order + 1} elements for {self.order}\\\"\\n                f\\\"-order filter, got {len(a_coeffs)}\\\"\\n            )\\n\\n        self.a_coeffs = a_coeffs\\n        self.b_coeffs = b_coeffs\\n\\n    def process(self, sample: float) -> float:\\n        \\\"\\\"\\\"\\n        Calculate y[n]\\n\\n        >>> filt = IIRFilter(2)\\n        >>> filt.process(0)\\n        0.0\\n        \\\"\\\"\\\"\\n        result = 0.0\\n\\n        # Start at index 1 and do index 0 at the end.\\n        for i in range(1, self.order + 1):\\n            result += (\\n                self.b_coeffs[i] * self.input_history[i - 1]\\n                - self.a_coeffs[i] * self.output_history[i - 1]\\n            )\\n\\n        result = (result + self.b_coeffs[0] * sample) / self.a_coeffs[0]\\n\\n        self.input_history[1:] = self.input_history[:-1]\\n        self.output_history[1:] = self.output_history[:-1]\\n\\n        self.input_history[0] = sample\\n        self.output_history[0] = result\\n\\n        return result\\n\"",
    "show response": "\"from __future__ import annotations\\n\\nfrom math import pi\\nfrom typing import Protocol\\n\\nimport matplotlib.pyplot as plt\\nimport numpy as np\\n\\n\\nclass FilterType(Protocol):\\n    def process(self, sample: float) -> float:\\n        \\\"\\\"\\\"\\n        Calculate y[n]\\n\\n        >>> issubclass(FilterType, Protocol)\\n        True\\n        \\\"\\\"\\\"\\n        return 0.0\\n\\n\\ndef get_bounds(\\n    fft_results: np.ndarray, samplerate: int\\n) -> tuple[int | float, int | float]:\\n    \\\"\\\"\\\"\\n    Get bounds for printing fft results\\n\\n    >>> import numpy\\n    >>> array = numpy.linspace(-20.0, 20.0, 1000)\\n    >>> get_bounds(array, 1000)\\n    (-20, 20)\\n    \\\"\\\"\\\"\\n    lowest = min([-20, np.min(fft_results[1 : samplerate // 2 - 1])])\\n    highest = max([20, np.max(fft_results[1 : samplerate // 2 - 1])])\\n    return lowest, highest\\n\\n\\ndef show_frequency_response(filter: FilterType, samplerate: int) -> None:\\n    \\\"\\\"\\\"\\n    Show frequency response of a filter\\n\\n    >>> from audio_filters.iir_filter import IIRFilter\\n    >>> filt = IIRFilter(4)\\n    >>> show_frequency_response(filt, 48000)\\n    \\\"\\\"\\\"\\n\\n    size = 512\\n    inputs = [1] + [0] * (size - 1)\\n    outputs = [filter.process(item) for item in inputs]\\n\\n    filler = [0] * (samplerate - size)  # zero-padding\\n    outputs += filler\\n    fft_out = np.abs(np.fft.fft(outputs))\\n    fft_db = 20 * np.log10(fft_out)\\n\\n    # Frequencies on log scale from 24 to nyquist frequency\\n    plt.xlim(24, samplerate / 2 - 1)\\n    plt.xlabel(\\\"Frequency (Hz)\\\")\\n    plt.xscale(\\\"log\\\")\\n\\n    # Display within reasonable bounds\\n    bounds = get_bounds(fft_db, samplerate)\\n    plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))\\n    plt.ylabel(\\\"Gain (dB)\\\")\\n\\n    plt.plot(fft_db)\\n    plt.show()\\n\\n\\ndef show_phase_response(filter: FilterType, samplerate: int) -> None:\\n    \\\"\\\"\\\"\\n    Show phase response of a filter\\n\\n    >>> from audio_filters.iir_filter import IIRFilter\\n    >>> filt = IIRFilter(4)\\n    >>> show_phase_response(filt, 48000)\\n    \\\"\\\"\\\"\\n\\n    size = 512\\n    inputs = [1] + [0] * (size - 1)\\n    outputs = [filter.process(item) for item in inputs]\\n\\n    filler = [0] * (samplerate - size)  # zero-padding\\n    outputs += filler\\n    fft_out = np.angle(np.fft.fft(outputs))\\n\\n    # Frequencies on log scale from 24 to nyquist frequency\\n    plt.xlim(24, samplerate / 2 - 1)\\n    plt.xlabel(\\\"Frequency (Hz)\\\")\\n    plt.xscale(\\\"log\\\")\\n\\n    plt.ylim(-2 * pi, 2 * pi)\\n    plt.ylabel(\\\"Phase shift (Radians)\\\")\\n    plt.plot(np.unwrap(fft_out, -2 * pi))\\n    plt.show()\\n\"",
    "all combinations": "\"\\\"\\\"\\\"\\n        In this problem, we want to determine all possible combinations of k\\n        numbers out of 1 ... n. We use backtracking to solve this problem.\\n        Time complexity: O(C(n,k)) which is O(n choose k) = O((n!/(k! * (n - k)!)))\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef generate_all_combinations(n: int, k: int) -> list[list[int]]:\\n    \\\"\\\"\\\"\\n    >>> generate_all_combinations(n=4, k=2)\\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\\n    \\\"\\\"\\\"\\n\\n    result: list[list[int]] = []\\n    create_all_state(1, n, k, [], result)\\n    return result\\n\\n\\ndef create_all_state(\\n    increment: int,\\n    total_number: int,\\n    level: int,\\n    current_list: list[int],\\n    total_list: list[list[int]],\\n) -> None:\\n    if level == 0:\\n        total_list.append(current_list[:])\\n        return\\n\\n    for i in range(increment, total_number - level + 2):\\n        current_list.append(i)\\n        create_all_state(i + 1, total_number, level - 1, current_list, total_list)\\n        current_list.pop()\\n\\n\\ndef print_all_state(total_list: list[list[int]]) -> None:\\n    for i in total_list:\\n        print(*i)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    n = 4\\n    k = 2\\n    total_list = generate_all_combinations(n, k)\\n    print_all_state(total_list)\\n\"",
    "all permutations": "\"\\\"\\\"\\\"\\n        In this problem, we want to determine all possible permutations\\n        of the given sequence. We use backtracking to solve this problem.\\n\\n        Time complexity: O(n! * n),\\n        where n denotes the length of the given sequence.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef generate_all_permutations(sequence: list[int | str]) -> None:\\n    create_state_space_tree(sequence, [], 0, [0 for i in range(len(sequence))])\\n\\n\\ndef create_state_space_tree(\\n    sequence: list[int | str],\\n    current_sequence: list[int | str],\\n    index: int,\\n    index_used: list[int],\\n) -> None:\\n    \\\"\\\"\\\"\\n    Creates a state space tree to iterate through each branch using DFS.\\n    We know that each state has exactly len(sequence) - index children.\\n    It terminates when it reaches the end of the given sequence.\\n    \\\"\\\"\\\"\\n\\n    if index == len(sequence):\\n        print(current_sequence)\\n        return\\n\\n    for i in range(len(sequence)):\\n        if not index_used[i]:\\n            current_sequence.append(sequence[i])\\n            index_used[i] = True\\n            create_state_space_tree(sequence, current_sequence, index + 1, index_used)\\n            current_sequence.pop()\\n            index_used[i] = False\\n\\n\\n\\\"\\\"\\\"\\nremove the comment to take an input from the user\\n\\nprint(\\\"Enter the elements\\\")\\nsequence = list(map(int, input().split()))\\n\\\"\\\"\\\"\\n\\nsequence: list[int | str] = [3, 1, 2, 4]\\ngenerate_all_permutations(sequence)\\n\\nsequence_2: list[int | str] = [\\\"A\\\", \\\"B\\\", \\\"C\\\"]\\ngenerate_all_permutations(sequence_2)\\n\"",
    "all subsequences": "\"\\\"\\\"\\\"\\nIn this problem, we want to determine all possible subsequences\\nof the given sequence. We use backtracking to solve this problem.\\n\\nTime complexity: O(2^n),\\nwhere n denotes the length of the given sequence.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom typing import Any\\n\\n\\ndef generate_all_subsequences(sequence: list[Any]) -> None:\\n    create_state_space_tree(sequence, [], 0)\\n\\n\\ndef create_state_space_tree(\\n    sequence: list[Any], current_subsequence: list[Any], index: int\\n) -> None:\\n    \\\"\\\"\\\"\\n    Creates a state space tree to iterate through each branch using DFS.\\n    We know that each state has exactly two children.\\n    It terminates when it reaches the end of the given sequence.\\n    \\\"\\\"\\\"\\n\\n    if index == len(sequence):\\n        print(current_subsequence)\\n        return\\n\\n    create_state_space_tree(sequence, current_subsequence, index + 1)\\n    current_subsequence.append(sequence[index])\\n    create_state_space_tree(sequence, current_subsequence, index + 1)\\n    current_subsequence.pop()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    seq: list[Any] = [3, 1, 2, 4]\\n    generate_all_subsequences(seq)\\n\\n    seq.clear()\\n    seq.extend([\\\"A\\\", \\\"B\\\", \\\"C\\\"])\\n    generate_all_subsequences(seq)\\n\"",
    "coloring": "\"\\\"\\\"\\\"\\n    Graph Coloring also called \\\"m coloring problem\\\"\\n    consists of coloring a given graph with at most m colors\\n    such that no adjacent vertices are assigned the same color\\n\\n    Wikipedia: https://en.wikipedia.org/wiki/Graph_coloring\\n\\\"\\\"\\\"\\n\\n\\ndef valid_coloring(\\n    neighbours: list[int], colored_vertices: list[int], color: int\\n) -> bool:\\n    \\\"\\\"\\\"\\n    For each neighbour check if the coloring constraint is satisfied\\n    If any of the neighbours fail the constraint return False\\n    If all neighbours validate the constraint return True\\n\\n    >>> neighbours = [0,1,0,1,0]\\n    >>> colored_vertices = [0, 2, 1, 2, 0]\\n\\n    >>> color = 1\\n    >>> valid_coloring(neighbours, colored_vertices, color)\\n    True\\n\\n    >>> color = 2\\n    >>> valid_coloring(neighbours, colored_vertices, color)\\n    False\\n    \\\"\\\"\\\"\\n    # Does any neighbour not satisfy the constraints\\n    return not any(\\n        neighbour == 1 and colored_vertices[i] == color\\n        for i, neighbour in enumerate(neighbours)\\n    )\\n\\n\\ndef util_color(\\n    graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Pseudo-Code\\n\\n    Base Case:\\n    1. Check if coloring is complete\\n        1.1 If complete return True (meaning that we successfully colored the graph)\\n\\n    Recursive Step:\\n    2. Iterates over each color:\\n        Check if the current coloring is valid:\\n            2.1. Color given vertex\\n            2.2. Do recursive call, check if this coloring leads to a solution\\n            2.4. if current coloring leads to a solution return\\n            2.5. Uncolor given vertex\\n\\n    >>> graph = [[0, 1, 0, 0, 0],\\n    ...          [1, 0, 1, 0, 1],\\n    ...          [0, 1, 0, 1, 0],\\n    ...          [0, 1, 1, 0, 0],\\n    ...          [0, 1, 0, 0, 0]]\\n    >>> max_colors = 3\\n    >>> colored_vertices = [0, 1, 0, 0, 0]\\n    >>> index = 3\\n\\n    >>> util_color(graph, max_colors, colored_vertices, index)\\n    True\\n\\n    >>> max_colors = 2\\n    >>> util_color(graph, max_colors, colored_vertices, index)\\n    False\\n    \\\"\\\"\\\"\\n\\n    # Base Case\\n    if index == len(graph):\\n        return True\\n\\n    # Recursive Step\\n    for i in range(max_colors):\\n        if valid_coloring(graph[index], colored_vertices, i):\\n            # Color current vertex\\n            colored_vertices[index] = i\\n            # Validate coloring\\n            if util_color(graph, max_colors, colored_vertices, index + 1):\\n                return True\\n            # Backtrack\\n            colored_vertices[index] = -1\\n    return False\\n\\n\\ndef color(graph: list[list[int]], max_colors: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    Wrapper function to call subroutine called util_color\\n    which will either return True or False.\\n    If True is returned colored_vertices list is filled with correct colorings\\n\\n    >>> graph = [[0, 1, 0, 0, 0],\\n    ...          [1, 0, 1, 0, 1],\\n    ...          [0, 1, 0, 1, 0],\\n    ...          [0, 1, 1, 0, 0],\\n    ...          [0, 1, 0, 0, 0]]\\n\\n    >>> max_colors = 3\\n    >>> color(graph, max_colors)\\n    [0, 1, 0, 2, 0]\\n\\n    >>> max_colors = 2\\n    >>> color(graph, max_colors)\\n    []\\n    \\\"\\\"\\\"\\n    colored_vertices = [-1] * len(graph)\\n\\n    if util_color(graph, max_colors, colored_vertices, 0):\\n        return colored_vertices\\n\\n    return []\\n\"",
    "hamiltonian cycle": "\"\\\"\\\"\\\"\\n    A Hamiltonian cycle (Hamiltonian circuit) is a graph cycle\\n    through a graph that visits each node exactly once.\\n    Determining whether such paths and cycles exist in graphs\\n    is the 'Hamiltonian path problem', which is NP-complete.\\n\\n    Wikipedia: https://en.wikipedia.org/wiki/Hamiltonian_path\\n\\\"\\\"\\\"\\n\\n\\ndef valid_connection(\\n    graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int]\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Checks whether it is possible to add next into path by validating 2 statements\\n    1. There should be path between current and next vertex\\n    2. Next vertex should not be in path\\n    If both validations succeed we return True, saying that it is possible to connect\\n    this vertices, otherwise we return False\\n\\n    Case 1:Use exact graph as in main function, with initialized values\\n    >>> graph = [[0, 1, 0, 1, 0],\\n    ...          [1, 0, 1, 1, 1],\\n    ...          [0, 1, 0, 0, 1],\\n    ...          [1, 1, 0, 0, 1],\\n    ...          [0, 1, 1, 1, 0]]\\n    >>> path = [0, -1, -1, -1, -1, 0]\\n    >>> curr_ind = 1\\n    >>> next_ver = 1\\n    >>> valid_connection(graph, next_ver, curr_ind, path)\\n    True\\n\\n    Case 2: Same graph, but trying to connect to node that is already in path\\n    >>> path = [0, 1, 2, 4, -1, 0]\\n    >>> curr_ind = 4\\n    >>> next_ver = 1\\n    >>> valid_connection(graph, next_ver, curr_ind, path)\\n    False\\n    \\\"\\\"\\\"\\n\\n    # 1. Validate that path exists between current and next vertices\\n    if graph[path[curr_ind - 1]][next_ver] == 0:\\n        return False\\n\\n    # 2. Validate that next vertex is not already in path\\n    return not any(vertex == next_ver for vertex in path)\\n\\n\\ndef util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:\\n    \\\"\\\"\\\"\\n    Pseudo-Code\\n    Base Case:\\n    1. Check if we visited all of vertices\\n        1.1 If last visited vertex has path to starting vertex return True either\\n            return False\\n    Recursive Step:\\n    2. Iterate over each vertex\\n        Check if next vertex is valid for transiting from current vertex\\n            2.1 Remember next vertex as next transition\\n            2.2 Do recursive call and check if going to this vertex solves problem\\n            2.3 If next vertex leads to solution return True\\n            2.4 Else backtrack, delete remembered vertex\\n\\n    Case 1: Use exact graph as in main function, with initialized values\\n    >>> graph = [[0, 1, 0, 1, 0],\\n    ...          [1, 0, 1, 1, 1],\\n    ...          [0, 1, 0, 0, 1],\\n    ...          [1, 1, 0, 0, 1],\\n    ...          [0, 1, 1, 1, 0]]\\n    >>> path = [0, -1, -1, -1, -1, 0]\\n    >>> curr_ind = 1\\n    >>> util_hamilton_cycle(graph, path, curr_ind)\\n    True\\n    >>> print(path)\\n    [0, 1, 2, 4, 3, 0]\\n\\n    Case 2: Use exact graph as in previous case, but in the properties taken from\\n        middle of calculation\\n    >>> graph = [[0, 1, 0, 1, 0],\\n    ...          [1, 0, 1, 1, 1],\\n    ...          [0, 1, 0, 0, 1],\\n    ...          [1, 1, 0, 0, 1],\\n    ...          [0, 1, 1, 1, 0]]\\n    >>> path = [0, 1, 2, -1, -1, 0]\\n    >>> curr_ind = 3\\n    >>> util_hamilton_cycle(graph, path, curr_ind)\\n    True\\n    >>> print(path)\\n    [0, 1, 2, 4, 3, 0]\\n    \\\"\\\"\\\"\\n\\n    # Base Case\\n    if curr_ind == len(graph):\\n        # return whether path exists between current and starting vertices\\n        return graph[path[curr_ind - 1]][path[0]] == 1\\n\\n    # Recursive Step\\n    for next in range(0, len(graph)):\\n        if valid_connection(graph, next, curr_ind, path):\\n            # Insert current vertex  into path as next transition\\n            path[curr_ind] = next\\n            # Validate created path\\n            if util_hamilton_cycle(graph, path, curr_ind + 1):\\n                return True\\n            # Backtrack\\n            path[curr_ind] = -1\\n    return False\\n\\n\\ndef hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:\\n    r\\\"\\\"\\\"\\n    Wrapper function to call subroutine called util_hamilton_cycle,\\n    which will either return array of vertices indicating hamiltonian cycle\\n    or an empty list indicating that hamiltonian cycle was not found.\\n    Case 1:\\n    Following graph consists of 5 edges.\\n    If we look closely, we can see that there are multiple Hamiltonian cycles.\\n    For example one result is when we iterate like:\\n    (0)->(1)->(2)->(4)->(3)->(0)\\n\\n    (0)---(1)---(2)\\n     |   /   \\\\   |\\n     |  /     \\\\  |\\n     | /       \\\\ |\\n     |/         \\\\|\\n    (3)---------(4)\\n    >>> graph = [[0, 1, 0, 1, 0],\\n    ...          [1, 0, 1, 1, 1],\\n    ...          [0, 1, 0, 0, 1],\\n    ...          [1, 1, 0, 0, 1],\\n    ...          [0, 1, 1, 1, 0]]\\n    >>> hamilton_cycle(graph)\\n    [0, 1, 2, 4, 3, 0]\\n\\n    Case 2:\\n    Same Graph as it was in Case 1, changed starting index from default to 3\\n\\n    (0)---(1)---(2)\\n     |   /   \\\\   |\\n     |  /     \\\\  |\\n     | /       \\\\ |\\n     |/         \\\\|\\n    (3)---------(4)\\n    >>> graph = [[0, 1, 0, 1, 0],\\n    ...          [1, 0, 1, 1, 1],\\n    ...          [0, 1, 0, 0, 1],\\n    ...          [1, 1, 0, 0, 1],\\n    ...          [0, 1, 1, 1, 0]]\\n    >>> hamilton_cycle(graph, 3)\\n    [3, 0, 1, 2, 4, 3]\\n\\n    Case 3:\\n    Following Graph is exactly what it was before, but edge 3-4 is removed.\\n    Result is that there is no Hamiltonian Cycle anymore.\\n\\n    (0)---(1)---(2)\\n     |   /   \\\\   |\\n     |  /     \\\\  |\\n     | /       \\\\ |\\n     |/         \\\\|\\n    (3)         (4)\\n    >>> graph = [[0, 1, 0, 1, 0],\\n    ...          [1, 0, 1, 1, 1],\\n    ...          [0, 1, 0, 0, 1],\\n    ...          [1, 1, 0, 0, 0],\\n    ...          [0, 1, 1, 0, 0]]\\n    >>> hamilton_cycle(graph,4)\\n    []\\n    \\\"\\\"\\\"\\n\\n    # Initialize path with -1, indicating that we have not visited them yet\\n    path = [-1] * (len(graph) + 1)\\n    # initialize start and end of path with starting index\\n    path[0] = path[-1] = start_index\\n    # evaluate and if we find answer return path either return empty array\\n    return path if util_hamilton_cycle(graph, path, 1) else []\\n\"",
    "knight tour": "\"# Knight Tour Intro: https://www.youtube.com/watch?v=ab_dY3dZFHM\\n\\nfrom __future__ import annotations\\n\\n\\ndef get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\\n    \\\"\\\"\\\"\\n    Find all the valid positions a knight can move to from the current position.\\n\\n    >>> get_valid_pos((1, 3), 4)\\n    [(2, 1), (0, 1), (3, 2)]\\n    \\\"\\\"\\\"\\n\\n    y, x = position\\n    positions = [\\n        (y + 1, x + 2),\\n        (y - 1, x + 2),\\n        (y + 1, x - 2),\\n        (y - 1, x - 2),\\n        (y + 2, x + 1),\\n        (y + 2, x - 1),\\n        (y - 2, x + 1),\\n        (y - 2, x - 1),\\n    ]\\n    permissible_positions = []\\n\\n    for position in positions:\\n        y_test, x_test = position\\n        if 0 <= y_test < n and 0 <= x_test < n:\\n            permissible_positions.append(position)\\n\\n    return permissible_positions\\n\\n\\ndef is_complete(board: list[list[int]]) -> bool:\\n    \\\"\\\"\\\"\\n    Check if the board (matrix) has been completely filled with non-zero values.\\n\\n    >>> is_complete([[1]])\\n    True\\n\\n    >>> is_complete([[1, 2], [3, 0]])\\n    False\\n    \\\"\\\"\\\"\\n\\n    return not any(elem == 0 for row in board for elem in row)\\n\\n\\ndef open_knight_tour_helper(\\n    board: list[list[int]], pos: tuple[int, int], curr: int\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Helper function to solve knight tour problem.\\n    \\\"\\\"\\\"\\n\\n    if is_complete(board):\\n        return True\\n\\n    for position in get_valid_pos(pos, len(board)):\\n        y, x = position\\n\\n        if board[y][x] == 0:\\n            board[y][x] = curr + 1\\n            if open_knight_tour_helper(board, position, curr + 1):\\n                return True\\n            board[y][x] = 0\\n\\n    return False\\n\\n\\ndef open_knight_tour(n: int) -> list[list[int]]:\\n    \\\"\\\"\\\"\\n    Find the solution for the knight tour problem for a board of size n. Raises\\n    ValueError if the tour cannot be performed for the given size.\\n\\n    >>> open_knight_tour(1)\\n    [[1]]\\n\\n    >>> open_knight_tour(2)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Open Kight Tour cannot be performed on a board of size 2\\n    \\\"\\\"\\\"\\n\\n    board = [[0 for i in range(n)] for j in range(n)]\\n\\n    for i in range(n):\\n        for j in range(n):\\n            board[i][j] = 1\\n            if open_knight_tour_helper(board, (i, j), 1):\\n                return board\\n            board[i][j] = 0\\n\\n    raise ValueError(f\\\"Open Kight Tour cannot be performed on a board of size {n}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "minimax": "\"\\\"\\\"\\\"\\nMinimax helps to achieve maximum score in a game by checking all possible moves\\ndepth is current depth in game tree.\\n\\nnodeIndex is index of current node in scores[].\\nif move is of maximizer return true else false\\nleaves of game tree is stored in scores[]\\nheight is maximum height of Game tree\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport math\\n\\n\\ndef minimax(\\n    depth: int, node_index: int, is_max: bool, scores: list[int], height: float\\n) -> int:\\n    \\\"\\\"\\\"\\n    >>> import math\\n    >>> scores = [90, 23, 6, 33, 21, 65, 123, 34423]\\n    >>> height = math.log(len(scores), 2)\\n    >>> minimax(0, 0, True, scores, height)\\n    65\\n    >>> minimax(-1, 0, True, scores, height)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Depth cannot be less than 0\\n    >>> minimax(0, 0, True, [], 2)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Scores cannot be empty\\n    >>> scores = [3, 5, 2, 9, 12, 5, 23, 23]\\n    >>> height = math.log(len(scores), 2)\\n    >>> minimax(0, 0, True, scores, height)\\n    12\\n    \\\"\\\"\\\"\\n\\n    if depth < 0:\\n        raise ValueError(\\\"Depth cannot be less than 0\\\")\\n\\n    if len(scores) == 0:\\n        raise ValueError(\\\"Scores cannot be empty\\\")\\n\\n    if depth == height:\\n        return scores[node_index]\\n\\n    if is_max:\\n        return max(\\n            minimax(depth + 1, node_index * 2, False, scores, height),\\n            minimax(depth + 1, node_index * 2 + 1, False, scores, height),\\n        )\\n\\n    return min(\\n        minimax(depth + 1, node_index * 2, True, scores, height),\\n        minimax(depth + 1, node_index * 2 + 1, True, scores, height),\\n    )\\n\\n\\ndef main() -> None:\\n    scores = [90, 23, 6, 33, 21, 65, 123, 34423]\\n    height = math.log(len(scores), 2)\\n    print(\\\"Optimal value : \\\", end=\\\"\\\")\\n    print(minimax(0, 0, True, scores, height))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "n queens": "\"\\\"\\\"\\\"\\n\\n The nqueens problem is of placing N queens on a N * N\\n chess board such that no queen can attack any other queens placed\\n on that chess board.\\n This means that one queen cannot have any other queen on its horizontal, vertical and\\n diagonal lines.\\n\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nsolution = []\\n\\n\\ndef isSafe(board: list[list[int]], row: int, column: int) -> bool:\\n    \\\"\\\"\\\"\\n    This function returns a boolean value True if it is safe to place a queen there\\n    considering the current state of the board.\\n\\n    Parameters :\\n    board(2D matrix) : board\\n    row ,column : coordinates of the cell on a board\\n\\n    Returns :\\n    Boolean Value\\n\\n    \\\"\\\"\\\"\\n    for i in range(len(board)):\\n        if board[row][i] == 1:\\n            return False\\n    for i in range(len(board)):\\n        if board[i][column] == 1:\\n            return False\\n    for i, j in zip(range(row, -1, -1), range(column, -1, -1)):\\n        if board[i][j] == 1:\\n            return False\\n    for i, j in zip(range(row, -1, -1), range(column, len(board))):\\n        if board[i][j] == 1:\\n            return False\\n    return True\\n\\n\\ndef solve(board: list[list[int]], row: int) -> bool:\\n    \\\"\\\"\\\"\\n    It creates a state space tree and calls the safe function until it receives a\\n    False Boolean and terminates that branch and backtracks to the next\\n    possible solution branch.\\n    \\\"\\\"\\\"\\n    if row >= len(board):\\n        \\\"\\\"\\\"\\n        If the row number exceeds N we have board with a successful combination\\n        and that combination is appended to the solution list and the board is printed.\\n\\n        \\\"\\\"\\\"\\n        solution.append(board)\\n        printboard(board)\\n        print()\\n        return True\\n    for i in range(len(board)):\\n        \\\"\\\"\\\"\\n        For every row it iterates through each column to check if it is feasible to\\n        place a queen there.\\n        If all the combinations for that particular branch are successful the board is\\n        reinitialized for the next possible combination.\\n        \\\"\\\"\\\"\\n        if isSafe(board, row, i):\\n            board[row][i] = 1\\n            solve(board, row + 1)\\n            board[row][i] = 0\\n    return False\\n\\n\\ndef printboard(board: list[list[int]]) -> None:\\n    \\\"\\\"\\\"\\n    Prints the boards that have a successful combination.\\n    \\\"\\\"\\\"\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j] == 1:\\n                print(\\\"Q\\\", end=\\\" \\\")\\n            else:\\n                print(\\\".\\\", end=\\\" \\\")\\n        print()\\n\\n\\n# n=int(input(\\\"The no. of queens\\\"))\\nn = 8\\nboard = [[0 for i in range(n)] for j in range(n)]\\nsolve(board, 0)\\nprint(\\\"The total no. of solutions are :\\\", len(solution))\\n\"",
    "n queens math": "\"r\\\"\\\"\\\"\\nProblem:\\n\\nThe n queens problem is: placing N queens on a N * N chess board such that no queen\\ncan attack any other queens placed on that chess board.  This means that one queen\\ncannot have any other queen on its horizontal, vertical and diagonal lines.\\n\\nSolution:\\n\\nTo solve this problem we will use simple math. First we know the queen can move in all\\nthe possible ways, we can simplify it in this: vertical, horizontal, diagonal left and\\n diagonal right.\\n\\nWe can visualize it like this:\\n\\nleft diagonal = \\\\\\nright diagonal = /\\n\\nOn a chessboard vertical movement could be the rows and horizontal movement could be\\nthe columns.\\n\\nIn programming we can use an array, and in this array each index could be the rows and\\neach value in the array could be the column. For example:\\n\\n    . Q . .     We have this chessboard with one queen in each column and each queen\\n    . . . Q     can't attack to each other.\\n    Q . . .     The array for this example would look like this: [1, 3, 0, 2]\\n    . . Q .\\n\\nSo if we use an array and we verify that each value in the array is different to each\\nother we know that at least the queens can't attack each other in horizontal and\\nvertical.\\n\\nAt this point we have it halfway completed and we will treat the chessboard as a\\nCartesian plane.  Hereinafter we are going to remember basic math, so in the school we\\nlearned this formula:\\n\\n    Slope of a line:\\n\\n           y2 - y1\\n     m = ----------\\n          x2 - x1\\n\\nThis formula allow us to get the slope. For the angles 45º (right diagonal) and 135º\\n(left diagonal) this formula gives us m = 1, and m = -1 respectively.\\n\\nSee::\\nhttps://www.enotes.com/homework-help/write-equation-line-that-hits-origin-45-degree-1474860\\n\\nThen we have this other formula:\\n\\nSlope intercept:\\n\\ny = mx + b\\n\\nb is where the line crosses the Y axis (to get more information see:\\nhttps://www.mathsisfun.com/y_intercept.html), if we change the formula to solve for b\\nwe would have:\\n\\ny - mx = b\\n\\nAnd since we already have the m values for the angles 45º and 135º, this formula would\\nlook like this:\\n\\n45º: y - (1)x = b\\n45º: y - x = b\\n\\n135º: y - (-1)x = b\\n135º: y + x = b\\n\\ny = row\\nx = column\\n\\nApplying these two formulas we can check if a queen in some position is being attacked\\nfor another one or vice versa.\\n\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef depth_first_search(\\n    possible_board: list[int],\\n    diagonal_right_collisions: list[int],\\n    diagonal_left_collisions: list[int],\\n    boards: list[list[str]],\\n    n: int,\\n) -> None:\\n    \\\"\\\"\\\"\\n    >>> boards = []\\n    >>> depth_first_search([], [], [], boards, 4)\\n    >>> for board in boards:\\n    ...     print(board)\\n    ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\\n    ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']\\n    \\\"\\\"\\\"\\n\\n    # Get next row in the current board (possible_board) to fill it with a queen\\n    row = len(possible_board)\\n\\n    # If row is equal to the size of the board it means there are a queen in each row in\\n    # the current board (possible_board)\\n    if row == n:\\n        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\\n        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\\n        boards.append([\\\". \\\" * i + \\\"Q \\\" + \\\". \\\" * (n - 1 - i) for i in possible_board])\\n        return\\n\\n    # We iterate each column in the row to find all possible results in each row\\n    for col in range(n):\\n\\n        # We apply that we learned previously. First we check that in the current board\\n        # (possible_board) there are not other same value because if there is it means\\n        # that there are a collision in vertical. Then we apply the two formulas we\\n        # learned before:\\n        #\\n        # 45º: y - x = b or 45: row - col = b\\n        # 135º: y + x = b or row + col = b.\\n        #\\n        # And we verify if the results of this two formulas not exist in their variables\\n        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)\\n        #\\n        # If any or these are True it means there is a collision so we continue to the\\n        # next value in the for loop.\\n        if (\\n            col in possible_board\\n            or row - col in diagonal_right_collisions\\n            or row + col in diagonal_left_collisions\\n        ):\\n            continue\\n\\n        # If it is False we call dfs function again and we update the inputs\\n        depth_first_search(\\n            possible_board + [col],\\n            diagonal_right_collisions + [row - col],\\n            diagonal_left_collisions + [row + col],\\n            boards,\\n            n,\\n        )\\n\\n\\ndef n_queens_solution(n: int) -> None:\\n    boards: list[list[str]] = []\\n    depth_first_search([], [], [], boards, n)\\n\\n    # Print all the boards\\n    for board in boards:\\n        for column in board:\\n            print(column)\\n        print(\\\"\\\")\\n\\n    print(len(boards), \\\"solutions were found.\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    n_queens_solution(4)\\n\"",
    "rat in maze": "\"from __future__ import annotations\\n\\n\\ndef solve_maze(maze: list[list[int]]) -> bool:\\n    \\\"\\\"\\\"\\n    This method solves the \\\"rat in maze\\\" problem.\\n    In this problem we have some n by n matrix, a start point and an end point.\\n    We want to go from the start to the end. In this matrix zeroes represent walls\\n    and ones paths we can use.\\n    Parameters :\\n        maze(2D matrix) : maze\\n    Returns:\\n        Return: True if the maze has a solution or False if it does not.\\n    >>> maze = [[0, 1, 0, 1, 1],\\n    ...         [0, 0, 0, 0, 0],\\n    ...         [1, 0, 1, 0, 1],\\n    ...         [0, 0, 1, 0, 0],\\n    ...         [1, 0, 0, 1, 0]]\\n    >>> solve_maze(maze)\\n    [1, 0, 0, 0, 0]\\n    [1, 1, 1, 1, 0]\\n    [0, 0, 0, 1, 0]\\n    [0, 0, 0, 1, 1]\\n    [0, 0, 0, 0, 1]\\n    True\\n\\n    >>> maze = [[0, 1, 0, 1, 1],\\n    ...         [0, 0, 0, 0, 0],\\n    ...         [0, 0, 0, 0, 1],\\n    ...         [0, 0, 0, 0, 0],\\n    ...         [0, 0, 0, 0, 0]]\\n    >>> solve_maze(maze)\\n    [1, 0, 0, 0, 0]\\n    [1, 0, 0, 0, 0]\\n    [1, 0, 0, 0, 0]\\n    [1, 0, 0, 0, 0]\\n    [1, 1, 1, 1, 1]\\n    True\\n\\n    >>> maze = [[0, 0, 0],\\n    ...         [0, 1, 0],\\n    ...         [1, 0, 0]]\\n    >>> solve_maze(maze)\\n    [1, 1, 1]\\n    [0, 0, 1]\\n    [0, 0, 1]\\n    True\\n\\n    >>> maze = [[0, 1, 0],\\n    ...         [0, 1, 0],\\n    ...         [1, 0, 0]]\\n    >>> solve_maze(maze)\\n    No solution exists!\\n    False\\n\\n    >>> maze = [[0, 1],\\n    ...         [1, 0]]\\n    >>> solve_maze(maze)\\n    No solution exists!\\n    False\\n    \\\"\\\"\\\"\\n    size = len(maze)\\n    # We need to create solution object to save path.\\n    solutions = [[0 for _ in range(size)] for _ in range(size)]\\n    solved = run_maze(maze, 0, 0, solutions)\\n    if solved:\\n        print(\\\"\\\\n\\\".join(str(row) for row in solutions))\\n    else:\\n        print(\\\"No solution exists!\\\")\\n    return solved\\n\\n\\ndef run_maze(maze: list[list[int]], i: int, j: int, solutions: list[list[int]]) -> bool:\\n    \\\"\\\"\\\"\\n    This method is recursive starting from (i, j) and going in one of four directions:\\n    up, down, left, right.\\n    If a path is found to destination it returns True otherwise it returns False.\\n    Parameters:\\n        maze(2D matrix) : maze\\n        i, j : coordinates of matrix\\n        solutions(2D matrix) : solutions\\n    Returns:\\n        Boolean if path is found True, Otherwise False.\\n    \\\"\\\"\\\"\\n    size = len(maze)\\n    # Final check point.\\n    if i == j == (size - 1):\\n        solutions[i][j] = 1\\n        return True\\n\\n    lower_flag = (not (i < 0)) and (not (j < 0))  # Check lower bounds\\n    upper_flag = (i < size) and (j < size)  # Check upper bounds\\n\\n    if lower_flag and upper_flag:\\n        # check for already visited and block points.\\n        block_flag = (not (solutions[i][j])) and (not (maze[i][j]))\\n        if block_flag:\\n            # check visited\\n            solutions[i][j] = 1\\n\\n            # check for directions\\n            if (\\n                run_maze(maze, i + 1, j, solutions)\\n                or run_maze(maze, i, j + 1, solutions)\\n                or run_maze(maze, i - 1, j, solutions)\\n                or run_maze(maze, i, j - 1, solutions)\\n            ):\\n                return True\\n\\n            solutions[i][j] = 0\\n            return False\\n    return False\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "sudoku": "\"\\\"\\\"\\\"\\nGiven a partially filled 9×9 2D array, the objective is to fill a 9×9\\nsquare grid with digits numbered 1 to 9, so that every row, column, and\\nand each of the nine 3×3 sub-grids contains all of the digits.\\n\\nThis can be solved using Backtracking and is similar to n-queens.\\nWe check to see if a cell is safe or not and recursively call the\\nfunction on the next column to see if it returns True. if yes, we\\nhave solved the puzzle. else, we backtrack and place another number\\nin that cell and repeat this process.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nMatrix = list[list[int]]\\n\\n# assigning initial values to the grid\\ninitial_grid: Matrix = [\\n    [3, 0, 6, 5, 0, 8, 4, 0, 0],\\n    [5, 2, 0, 0, 0, 0, 0, 0, 0],\\n    [0, 8, 7, 0, 0, 0, 0, 3, 1],\\n    [0, 0, 3, 0, 1, 0, 0, 8, 0],\\n    [9, 0, 0, 8, 6, 3, 0, 0, 5],\\n    [0, 5, 0, 0, 9, 0, 6, 0, 0],\\n    [1, 3, 0, 0, 0, 0, 2, 5, 0],\\n    [0, 0, 0, 0, 0, 0, 0, 7, 4],\\n    [0, 0, 5, 2, 0, 6, 3, 0, 0],\\n]\\n\\n# a grid with no solution\\nno_solution: Matrix = [\\n    [5, 0, 6, 5, 0, 8, 4, 0, 3],\\n    [5, 2, 0, 0, 0, 0, 0, 0, 2],\\n    [1, 8, 7, 0, 0, 0, 0, 3, 1],\\n    [0, 0, 3, 0, 1, 0, 0, 8, 0],\\n    [9, 0, 0, 8, 6, 3, 0, 0, 5],\\n    [0, 5, 0, 0, 9, 0, 6, 0, 0],\\n    [1, 3, 0, 0, 0, 0, 2, 5, 0],\\n    [0, 0, 0, 0, 0, 0, 0, 7, 4],\\n    [0, 0, 5, 2, 0, 6, 3, 0, 0],\\n]\\n\\n\\ndef is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:\\n    \\\"\\\"\\\"\\n    This function checks the grid to see if each row,\\n    column, and the 3x3 subgrids contain the digit 'n'.\\n    It returns False if it is not 'safe' (a duplicate digit\\n    is found) else returns True if it is 'safe'\\n    \\\"\\\"\\\"\\n    for i in range(9):\\n        if grid[row][i] == n or grid[i][column] == n:\\n            return False\\n\\n    for i in range(3):\\n        for j in range(3):\\n            if grid[(row - row % 3) + i][(column - column % 3) + j] == n:\\n                return False\\n\\n    return True\\n\\n\\ndef find_empty_location(grid: Matrix) -> tuple[int, int] | None:\\n    \\\"\\\"\\\"\\n    This function finds an empty location so that we can assign a number\\n    for that particular row and column.\\n    \\\"\\\"\\\"\\n    for i in range(9):\\n        for j in range(9):\\n            if grid[i][j] == 0:\\n                return i, j\\n    return None\\n\\n\\ndef sudoku(grid: Matrix) -> Matrix | None:\\n    \\\"\\\"\\\"\\n    Takes a partially filled-in grid and attempts to assign values to\\n    all unassigned locations in such a way to meet the requirements\\n    for Sudoku solution (non-duplication across rows, columns, and boxes)\\n\\n    >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE\\n    [[3, 1, 6, 5, 7, 8, 4, 9, 2],\\n     [5, 2, 9, 1, 3, 4, 7, 6, 8],\\n     [4, 8, 7, 6, 2, 9, 5, 3, 1],\\n     [2, 6, 3, 4, 1, 5, 9, 8, 7],\\n     [9, 7, 4, 8, 6, 3, 1, 2, 5],\\n     [8, 5, 1, 7, 9, 2, 6, 4, 3],\\n     [1, 3, 8, 9, 4, 7, 2, 5, 6],\\n     [6, 9, 2, 3, 5, 1, 8, 7, 4],\\n     [7, 4, 5, 2, 8, 6, 3, 1, 9]]\\n     >>> sudoku(no_solution) is None\\n     True\\n    \\\"\\\"\\\"\\n    if location := find_empty_location(grid):\\n        row, column = location\\n    else:\\n        # If the location is ``None``, then the grid is solved.\\n        return grid\\n\\n    for digit in range(1, 10):\\n        if is_safe(grid, row, column, digit):\\n            grid[row][column] = digit\\n\\n            if sudoku(grid) is not None:\\n                return grid\\n\\n            grid[row][column] = 0\\n\\n    return None\\n\\n\\ndef print_solution(grid: Matrix) -> None:\\n    \\\"\\\"\\\"\\n    A function to print the solution in the form\\n    of a 9x9 grid\\n    \\\"\\\"\\\"\\n    for row in grid:\\n        for cell in row:\\n            print(cell, end=\\\" \\\")\\n        print()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # make a copy of grid so that you can compare with the unmodified grid\\n    for example_grid in (initial_grid, no_solution):\\n        print(\\\"\\\\nExample grid:\\\\n\\\" + \\\"=\\\" * 20)\\n        print_solution(example_grid)\\n        print(\\\"\\\\nExample grid solution:\\\")\\n        solution = sudoku(example_grid)\\n        if solution is not None:\\n            print_solution(solution)\\n        else:\\n            print(\\\"Cannot find a solution.\\\")\\n\"",
    "sum of subsets": "\"\\\"\\\"\\\"\\n        The sum-of-subsetsproblem states that a set of non-negative integers, and a\\n        value M, determine all possible subsets of the given set whose summation sum\\n        equal to given M.\\n\\n        Summation of the chosen numbers must be equal to given number M and one number\\n        can be used only once.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef generate_sum_of_subsets_soln(nums: list[int], max_sum: int) -> list[list[int]]:\\n    result: list[list[int]] = []\\n    path: list[int] = []\\n    num_index = 0\\n    remaining_nums_sum = sum(nums)\\n    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)\\n    return result\\n\\n\\ndef create_state_space_tree(\\n    nums: list[int],\\n    max_sum: int,\\n    num_index: int,\\n    path: list[int],\\n    result: list[list[int]],\\n    remaining_nums_sum: int,\\n) -> None:\\n    \\\"\\\"\\\"\\n    Creates a state space tree to iterate through each branch using DFS.\\n    It terminates the branching of a node when any of the two conditions\\n    given below satisfy.\\n    This algorithm follows depth-fist-search and backtracks when the node is not\\n    branchable.\\n\\n    \\\"\\\"\\\"\\n    if sum(path) > max_sum or (remaining_nums_sum + sum(path)) < max_sum:\\n        return\\n    if sum(path) == max_sum:\\n        result.append(path)\\n        return\\n    for num_index in range(num_index, len(nums)):\\n        create_state_space_tree(\\n            nums,\\n            max_sum,\\n            num_index + 1,\\n            path + [nums[num_index]],\\n            result,\\n            remaining_nums_sum - nums[num_index],\\n        )\\n\\n\\n\\\"\\\"\\\"\\nremove the comment to take an input from the user\\n\\nprint(\\\"Enter the elements\\\")\\nnums = list(map(int, input().split()))\\nprint(\\\"Enter max_sum sum\\\")\\nmax_sum = int(input())\\n\\n\\\"\\\"\\\"\\nnums = [3, 34, 4, 12, 5, 2]\\nmax_sum = 9\\nresult = generate_sum_of_subsets_soln(nums, max_sum)\\nprint(*result)\\n\"",
    "binary and operator": "\"# https://www.tutorialspoint.com/python3/bitwise_operators_example.htm\\n\\n\\ndef binary_and(a: int, b: int) -> str:\\n    \\\"\\\"\\\"\\n    Take in 2 integers, convert them to binary,\\n    return a binary number that is the\\n    result of a binary and operation on the integers provided.\\n\\n    >>> binary_and(25, 32)\\n    '0b000000'\\n    >>> binary_and(37, 50)\\n    '0b100000'\\n    >>> binary_and(21, 30)\\n    '0b10100'\\n    >>> binary_and(58, 73)\\n    '0b0001000'\\n    >>> binary_and(0, 255)\\n    '0b00000000'\\n    >>> binary_and(256, 256)\\n    '0b100000000'\\n    >>> binary_and(0, -1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: the value of both inputs must be positive\\n    >>> binary_and(0, 1.1)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: 'float' object cannot be interpreted as an integer\\n    >>> binary_and(\\\"0\\\", \\\"1\\\")\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: '<' not supported between instances of 'str' and 'int'\\n    \\\"\\\"\\\"\\n    if a < 0 or b < 0:\\n        raise ValueError(\\\"the value of both inputs must be positive\\\")\\n\\n    a_binary = str(bin(a))[2:]  # remove the leading \\\"0b\\\"\\n    b_binary = str(bin(b))[2:]  # remove the leading \\\"0b\\\"\\n\\n    max_len = max(len(a_binary), len(b_binary))\\n\\n    return \\\"0b\\\" + \\\"\\\".join(\\n        str(int(char_a == \\\"1\\\" and char_b == \\\"1\\\"))\\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "binary count setbits": "\"def binary_count_setbits(a: int) -> int:\\n    \\\"\\\"\\\"\\n    Take in 1 integer, return a number that is\\n    the number of 1's in binary representation of that number.\\n\\n    >>> binary_count_setbits(25)\\n    3\\n    >>> binary_count_setbits(36)\\n    2\\n    >>> binary_count_setbits(16)\\n    1\\n    >>> binary_count_setbits(58)\\n    4\\n    >>> binary_count_setbits(4294967295)\\n    32\\n    >>> binary_count_setbits(0)\\n    0\\n    >>> binary_count_setbits(-10)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input value must be a positive integer\\n    >>> binary_count_setbits(0.8)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: Input value must be a 'int' type\\n    >>> binary_count_setbits(\\\"0\\\")\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: '<' not supported between instances of 'str' and 'int'\\n    \\\"\\\"\\\"\\n    if a < 0:\\n        raise ValueError(\\\"Input value must be a positive integer\\\")\\n    elif isinstance(a, float):\\n        raise TypeError(\\\"Input value must be a 'int' type\\\")\\n    return bin(a).count(\\\"1\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "binary count trailing zeros": "\"from math import log2\\n\\n\\ndef binary_count_trailing_zeros(a: int) -> int:\\n    \\\"\\\"\\\"\\n    Take in 1 integer, return a number that is\\n    the number of trailing zeros in binary representation of that number.\\n\\n    >>> binary_count_trailing_zeros(25)\\n    0\\n    >>> binary_count_trailing_zeros(36)\\n    2\\n    >>> binary_count_trailing_zeros(16)\\n    4\\n    >>> binary_count_trailing_zeros(58)\\n    1\\n    >>> binary_count_trailing_zeros(4294967296)\\n    32\\n    >>> binary_count_trailing_zeros(0)\\n    0\\n    >>> binary_count_trailing_zeros(-10)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input value must be a positive integer\\n    >>> binary_count_trailing_zeros(0.8)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: Input value must be a 'int' type\\n    >>> binary_count_trailing_zeros(\\\"0\\\")\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: '<' not supported between instances of 'str' and 'int'\\n    \\\"\\\"\\\"\\n    if a < 0:\\n        raise ValueError(\\\"Input value must be a positive integer\\\")\\n    elif isinstance(a, float):\\n        raise TypeError(\\\"Input value must be a 'int' type\\\")\\n    return 0 if (a == 0) else int(log2(a & -a))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "binary or operator": "\"# https://www.tutorialspoint.com/python3/bitwise_operators_example.htm\\r\\n\\r\\n\\r\\ndef binary_or(a: int, b: int) -> str:\\r\\n    \\\"\\\"\\\"\\r\\n    Take in 2 integers, convert them to binary, and return a binary number that is the\\r\\n    result of a binary or operation on the integers provided.\\r\\n\\r\\n    >>> binary_or(25, 32)\\r\\n    '0b111001'\\r\\n    >>> binary_or(37, 50)\\r\\n    '0b110111'\\r\\n    >>> binary_or(21, 30)\\r\\n    '0b11111'\\r\\n    >>> binary_or(58, 73)\\r\\n    '0b1111011'\\r\\n    >>> binary_or(0, 255)\\r\\n    '0b11111111'\\r\\n    >>> binary_or(0, 256)\\r\\n    '0b100000000'\\r\\n    >>> binary_or(0, -1)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: the value of both inputs must be positive\\r\\n    >>> binary_or(0, 1.1)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    TypeError: 'float' object cannot be interpreted as an integer\\r\\n    >>> binary_or(\\\"0\\\", \\\"1\\\")\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    TypeError: '<' not supported between instances of 'str' and 'int'\\r\\n    \\\"\\\"\\\"\\r\\n    if a < 0 or b < 0:\\r\\n        raise ValueError(\\\"the value of both inputs must be positive\\\")\\r\\n    a_binary = str(bin(a))[2:]  # remove the leading \\\"0b\\\"\\r\\n    b_binary = str(bin(b))[2:]\\r\\n    max_len = max(len(a_binary), len(b_binary))\\r\\n    return \\\"0b\\\" + \\\"\\\".join(\\r\\n        str(int(\\\"1\\\" in (char_a, char_b)))\\r\\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\\r\\n    )\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "binary shifts": "\"# Information on binary shifts:\\n# https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types\\n# https://www.interviewcake.com/concept/java/bit-shift\\n\\n\\ndef logical_left_shift(number: int, shift_amount: int) -> str:\\n    \\\"\\\"\\\"\\n    Take in 2 positive integers.\\n    'number' is the integer to be logically left shifted 'shift_amount' times.\\n    i.e. (number << shift_amount)\\n    Return the shifted binary representation.\\n\\n    >>> logical_left_shift(0, 1)\\n    '0b00'\\n    >>> logical_left_shift(1, 1)\\n    '0b10'\\n    >>> logical_left_shift(1, 5)\\n    '0b100000'\\n    >>> logical_left_shift(17, 2)\\n    '0b1000100'\\n    >>> logical_left_shift(1983, 4)\\n    '0b111101111110000'\\n    >>> logical_left_shift(1, -1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: both inputs must be positive integers\\n    \\\"\\\"\\\"\\n    if number < 0 or shift_amount < 0:\\n        raise ValueError(\\\"both inputs must be positive integers\\\")\\n\\n    binary_number = str(bin(number))\\n    binary_number += \\\"0\\\" * shift_amount\\n    return binary_number\\n\\n\\ndef logical_right_shift(number: int, shift_amount: int) -> str:\\n    \\\"\\\"\\\"\\n    Take in positive 2 integers.\\n    'number' is the integer to be logically right shifted 'shift_amount' times.\\n    i.e. (number >>> shift_amount)\\n    Return the shifted binary representation.\\n\\n    >>> logical_right_shift(0, 1)\\n    '0b0'\\n    >>> logical_right_shift(1, 1)\\n    '0b0'\\n    >>> logical_right_shift(1, 5)\\n    '0b0'\\n    >>> logical_right_shift(17, 2)\\n    '0b100'\\n    >>> logical_right_shift(1983, 4)\\n    '0b1111011'\\n    >>> logical_right_shift(1, -1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: both inputs must be positive integers\\n    \\\"\\\"\\\"\\n    if number < 0 or shift_amount < 0:\\n        raise ValueError(\\\"both inputs must be positive integers\\\")\\n\\n    binary_number = str(bin(number))[2:]\\n    if shift_amount >= len(binary_number):\\n        return \\\"0b0\\\"\\n    shifted_binary_number = binary_number[: len(binary_number) - shift_amount]\\n    return \\\"0b\\\" + shifted_binary_number\\n\\n\\ndef arithmetic_right_shift(number: int, shift_amount: int) -> str:\\n    \\\"\\\"\\\"\\n    Take in 2 integers.\\n    'number' is the integer to be arithmetically right shifted 'shift_amount' times.\\n    i.e. (number >> shift_amount)\\n    Return the shifted binary representation.\\n\\n    >>> arithmetic_right_shift(0, 1)\\n    '0b00'\\n    >>> arithmetic_right_shift(1, 1)\\n    '0b00'\\n    >>> arithmetic_right_shift(-1, 1)\\n    '0b11'\\n    >>> arithmetic_right_shift(17, 2)\\n    '0b000100'\\n    >>> arithmetic_right_shift(-17, 2)\\n    '0b111011'\\n    >>> arithmetic_right_shift(-1983, 4)\\n    '0b111110000100'\\n    \\\"\\\"\\\"\\n    if number >= 0:  # Get binary representation of positive number\\n        binary_number = \\\"0\\\" + str(bin(number)).strip(\\\"-\\\")[2:]\\n    else:  # Get binary (2's complement) representation of negative number\\n        binary_number_length = len(bin(number)[3:])  # Find 2's complement of number\\n        binary_number = bin(abs(number) - (1 << binary_number_length))[3:]\\n        binary_number = (\\n            \\\"1\\\" + \\\"0\\\" * (binary_number_length - len(binary_number)) + binary_number\\n        )\\n\\n    if shift_amount >= len(binary_number):\\n        return \\\"0b\\\" + binary_number[0] * len(binary_number)\\n    return (\\n        \\\"0b\\\"\\n        + binary_number[0] * shift_amount\\n        + binary_number[: len(binary_number) - shift_amount]\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "binary twos complement": "\"# Information on 2's complement: https://en.wikipedia.org/wiki/Two%27s_complement\\n\\n\\ndef twos_complement(number: int) -> str:\\n    \\\"\\\"\\\"\\n    Take in a negative integer 'number'.\\n    Return the two's complement representation of 'number'.\\n\\n    >>> twos_complement(0)\\n    '0b0'\\n    >>> twos_complement(-1)\\n    '0b11'\\n    >>> twos_complement(-5)\\n    '0b1011'\\n    >>> twos_complement(-17)\\n    '0b101111'\\n    >>> twos_complement(-207)\\n    '0b100110001'\\n    >>> twos_complement(1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: input must be a negative integer\\n    \\\"\\\"\\\"\\n    if number > 0:\\n        raise ValueError(\\\"input must be a negative integer\\\")\\n    binary_number_length = len(bin(number)[3:])\\n    twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]\\n    twos_complement_number = (\\n        (\\n            \\\"1\\\"\\n            + \\\"0\\\" * (binary_number_length - len(twos_complement_number))\\n            + twos_complement_number\\n        )\\n        if number < 0\\n        else \\\"0\\\"\\n    )\\n    return \\\"0b\\\" + twos_complement_number\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "binary xor operator": "\"# https://www.tutorialspoint.com/python3/bitwise_operators_example.htm\\n\\n\\ndef binary_xor(a: int, b: int) -> str:\\n    \\\"\\\"\\\"\\n    Take in 2 integers, convert them to binary,\\n    return a binary number that is the\\n    result of a binary xor operation on the integers provided.\\n\\n    >>> binary_xor(25, 32)\\n    '0b111001'\\n    >>> binary_xor(37, 50)\\n    '0b010111'\\n    >>> binary_xor(21, 30)\\n    '0b01011'\\n    >>> binary_xor(58, 73)\\n    '0b1110011'\\n    >>> binary_xor(0, 255)\\n    '0b11111111'\\n    >>> binary_xor(256, 256)\\n    '0b000000000'\\n    >>> binary_xor(0, -1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: the value of both inputs must be positive\\n    >>> binary_xor(0, 1.1)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: 'float' object cannot be interpreted as an integer\\n    >>> binary_xor(\\\"0\\\", \\\"1\\\")\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: '<' not supported between instances of 'str' and 'int'\\n    \\\"\\\"\\\"\\n    if a < 0 or b < 0:\\n        raise ValueError(\\\"the value of both inputs must be positive\\\")\\n\\n    a_binary = str(bin(a))[2:]  # remove the leading \\\"0b\\\"\\n    b_binary = str(bin(b))[2:]  # remove the leading \\\"0b\\\"\\n\\n    max_len = max(len(a_binary), len(b_binary))\\n\\n    return \\\"0b\\\" + \\\"\\\".join(\\n        str(int(char_a != char_b))\\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "count 1s brian kernighan method": "\"def get_1s_count(number: int) -> int:\\n    \\\"\\\"\\\"\\n    Count the number of set bits in a 32 bit integer using Brian Kernighan's way.\\n    Ref - http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\\n    >>> get_1s_count(25)\\n    3\\n    >>> get_1s_count(37)\\n    3\\n    >>> get_1s_count(21)\\n    3\\n    >>> get_1s_count(58)\\n    4\\n    >>> get_1s_count(0)\\n    0\\n    >>> get_1s_count(256)\\n    1\\n    >>> get_1s_count(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: the value of input must be positive\\n    >>> get_1s_count(0.8)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: Input value must be an 'int' type\\n    \\\"\\\"\\\"\\n    if number < 0:\\n        raise ValueError(\\\"the value of input must be positive\\\")\\n    elif isinstance(number, float):\\n        raise TypeError(\\\"Input value must be an 'int' type\\\")\\n    count = 0\\n    while number:\\n        # This way we arrive at next set bit (next 1) instead of looping\\n        # through each bit and checking for 1s hence the\\n        # loop won't run 32 times it will only run the number of `1` times\\n        number &= number - 1\\n        count += 1\\n    return count\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "count number of one bits": "\"def get_set_bits_count(number: int) -> int:\\n    \\\"\\\"\\\"\\n    Count the number of set bits in a 32 bit integer\\n    >>> get_set_bits_count(25)\\n    3\\n    >>> get_set_bits_count(37)\\n    3\\n    >>> get_set_bits_count(21)\\n    3\\n    >>> get_set_bits_count(58)\\n    4\\n    >>> get_set_bits_count(0)\\n    0\\n    >>> get_set_bits_count(256)\\n    1\\n    >>> get_set_bits_count(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: the value of input must be positive\\n    \\\"\\\"\\\"\\n    if number < 0:\\n        raise ValueError(\\\"the value of input must be positive\\\")\\n    result = 0\\n    while number:\\n        if number % 2 == 1:\\n            result += 1\\n        number = number >> 1\\n    return result\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "gray code sequence": "\"def gray_code(bit_count: int) -> list:\\n    \\\"\\\"\\\"\\n    Takes in an integer n and returns a n-bit\\n    gray code sequence\\n    An n-bit gray code sequence is a sequence of 2^n\\n    integers where:\\n\\n    a) Every integer is between [0,2^n -1] inclusive\\n    b) The sequence begins with 0\\n    c) An integer appears at most one times in the sequence\\n    d)The binary representation of every pair of integers differ\\n       by exactly one bit\\n    e) The binary representation of first and last bit also\\n       differ by exactly one bit\\n\\n    >>> gray_code(2)\\n    [0, 1, 3, 2]\\n\\n    >>> gray_code(1)\\n    [0, 1]\\n\\n    >>> gray_code(3)\\n    [0, 1, 3, 2, 6, 7, 5, 4]\\n\\n    >>> gray_code(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The given input must be positive\\n\\n    >>> gray_code(10.6)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: unsupported operand type(s) for <<: 'int' and 'float'\\n    \\\"\\\"\\\"\\n\\n    # bit count represents no. of bits in the gray code\\n    if bit_count < 0:\\n        raise ValueError(\\\"The given input must be positive\\\")\\n\\n    # get the generated string sequence\\n    sequence = gray_code_sequence_string(bit_count)\\n    #\\n    # convert them to integers\\n    for i in range(len(sequence)):\\n        sequence[i] = int(sequence[i], 2)\\n\\n    return sequence\\n\\n\\ndef gray_code_sequence_string(bit_count: int) -> list:\\n    \\\"\\\"\\\"\\n    Will output the n-bit grey sequence as a\\n    string of bits\\n\\n    >>> gray_code_sequence_string(2)\\n    ['00', '01', '11', '10']\\n\\n    >>> gray_code_sequence_string(1)\\n    ['0', '1']\\n    \\\"\\\"\\\"\\n\\n    # The approach is a recursive one\\n    # Base case achieved when either n = 0 or n=1\\n    if bit_count == 0:\\n        return [\\\"0\\\"]\\n\\n    if bit_count == 1:\\n        return [\\\"0\\\", \\\"1\\\"]\\n\\n    seq_len = 1 << bit_count  # defines the length of the sequence\\n    # 1<< n is equivalent to 2^n\\n\\n    # recursive answer will generate answer for n-1 bits\\n    smaller_sequence = gray_code_sequence_string(bit_count - 1)\\n\\n    sequence = []\\n\\n    # append 0 to first half of the smaller sequence generated\\n    for i in range(seq_len // 2):\\n        generated_no = \\\"0\\\" + smaller_sequence[i]\\n        sequence.append(generated_no)\\n\\n    # append 1 to second half ... start from the end of the list\\n    for i in reversed(range(seq_len // 2)):\\n        generated_no = \\\"1\\\" + smaller_sequence[i]\\n        sequence.append(generated_no)\\n\\n    return sequence\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "reverse bits": "\"def get_reverse_bit_string(number: int) -> str:\\n    \\\"\\\"\\\"\\n    return the bit string of an integer\\n\\n    >>> get_reverse_bit_string(9)\\n    '10010000000000000000000000000000'\\n    >>> get_reverse_bit_string(43)\\n    '11010100000000000000000000000000'\\n    >>> get_reverse_bit_string(2873)\\n    '10011100110100000000000000000000'\\n    >>> get_reverse_bit_string(\\\"this is not a number\\\")\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: operation can not be conducted on a object of type str\\n    \\\"\\\"\\\"\\n    if not isinstance(number, int):\\n        raise TypeError(\\n            \\\"operation can not be conducted on a object of type \\\"\\n            f\\\"{type(number).__name__}\\\"\\n        )\\n    bit_string = \\\"\\\"\\n    for _ in range(0, 32):\\n        bit_string += str(number % 2)\\n        number = number >> 1\\n    return bit_string\\n\\n\\ndef reverse_bit(number: int) -> str:\\n    \\\"\\\"\\\"\\n    Take in an 32 bit integer, reverse its bits,\\n    return a string of reverse bits\\n\\n    result of a reverse_bit and operation on the integer provided.\\n\\n    >>> reverse_bit(25)\\n    '00000000000000000000000000011001'\\n    >>> reverse_bit(37)\\n    '00000000000000000000000000100101'\\n    >>> reverse_bit(21)\\n    '00000000000000000000000000010101'\\n    >>> reverse_bit(58)\\n    '00000000000000000000000000111010'\\n    >>> reverse_bit(0)\\n    '00000000000000000000000000000000'\\n    >>> reverse_bit(256)\\n    '00000000000000000000000100000000'\\n    >>> reverse_bit(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: the value of input must be positive\\n\\n    >>> reverse_bit(1.1)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: Input value must be a 'int' type\\n\\n    >>> reverse_bit(\\\"0\\\")\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: '<' not supported between instances of 'str' and 'int'\\n    \\\"\\\"\\\"\\n    if number < 0:\\n        raise ValueError(\\\"the value of input must be positive\\\")\\n    elif isinstance(number, float):\\n        raise TypeError(\\\"Input value must be a 'int' type\\\")\\n    elif isinstance(number, str):\\n        raise TypeError(\\\"'<' not supported between instances of 'str' and 'int'\\\")\\n    result = 0\\n    # iterator over [1 to 32],since we are dealing with 32 bit integer\\n    for _ in range(1, 33):\\n        # left shift the bits by unity\\n        result = result << 1\\n        # get the end bit\\n        end_bit = number % 2\\n        # right shift the bits by unity\\n        number = number >> 1\\n        # add that bit to our ans\\n        result = result | end_bit\\n    return get_reverse_bit_string(result)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "single bit manipulation operations": "\"#!/usr/bin/env python3\\n\\n\\\"\\\"\\\"Provide the functionality to manipulate a single bit.\\\"\\\"\\\"\\n\\n\\ndef set_bit(number: int, position: int) -> int:\\n    \\\"\\\"\\\"\\n    Set the bit at position to 1.\\n\\n    Details: perform bitwise or for given number and X.\\n    Where X is a number with all the bits – zeroes and bit on given\\n    position – one.\\n\\n    >>> set_bit(0b1101, 1) # 0b1111\\n    15\\n    >>> set_bit(0b0, 5) # 0b100000\\n    32\\n    >>> set_bit(0b1111, 1) # 0b1111\\n    15\\n    \\\"\\\"\\\"\\n    return number | (1 << position)\\n\\n\\ndef clear_bit(number: int, position: int) -> int:\\n    \\\"\\\"\\\"\\n    Set the bit at position to 0.\\n\\n    Details: perform bitwise and for given number and X.\\n    Where X is a number with all the bits – ones and bit on given\\n    position – zero.\\n\\n    >>> clear_bit(0b10010, 1) # 0b10000\\n    16\\n    >>> clear_bit(0b0, 5) # 0b0\\n    0\\n    \\\"\\\"\\\"\\n    return number & ~(1 << position)\\n\\n\\ndef flip_bit(number: int, position: int) -> int:\\n    \\\"\\\"\\\"\\n    Flip the bit at position.\\n\\n    Details: perform bitwise xor for given number and X.\\n    Where X is a number with all the bits – zeroes and bit on given\\n    position – one.\\n\\n    >>> flip_bit(0b101, 1) # 0b111\\n    7\\n    >>> flip_bit(0b101, 0) # 0b100\\n    4\\n    \\\"\\\"\\\"\\n    return number ^ (1 << position)\\n\\n\\ndef is_bit_set(number: int, position: int) -> bool:\\n    \\\"\\\"\\\"\\n    Is the bit at position set?\\n\\n    Details: Shift the bit at position to be the first (smallest) bit.\\n    Then check if the first bit is set by anding the shifted number with 1.\\n\\n    >>> is_bit_set(0b1010, 0)\\n    False\\n    >>> is_bit_set(0b1010, 1)\\n    True\\n    >>> is_bit_set(0b1010, 2)\\n    False\\n    >>> is_bit_set(0b1010, 3)\\n    True\\n    >>> is_bit_set(0b0, 17)\\n    False\\n    \\\"\\\"\\\"\\n    return ((number >> position) & 1) == 1\\n\\n\\ndef get_bit(number: int, position: int) -> int:\\n    \\\"\\\"\\\"\\n    Get the bit at the given position\\n\\n    Details: perform bitwise and for the given number and X,\\n    Where X is a number with all the bits – zeroes and bit on given position – one.\\n    If the result is not equal to 0, then the bit on the given position is 1, else 0.\\n\\n    >>> get_bit(0b1010, 0)\\n    0\\n    >>> get_bit(0b1010, 1)\\n    1\\n    >>> get_bit(0b1010, 2)\\n    0\\n    >>> get_bit(0b1010, 3)\\n    1\\n    \\\"\\\"\\\"\\n    return int((number & (1 << position)) != 0)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "chinese remainder theorem": "\"\\\"\\\"\\\"\\nChinese Remainder Theorem:\\nGCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\\n\\nIf GCD(a,b) = 1, then for any remainder ra modulo a and any remainder rb modulo b\\nthere exists integer n, such that n = ra (mod a) and n = ra(mod b).  If n1 and n2 are\\ntwo such integers, then n1=n2(mod ab)\\n\\nAlgorithm :\\n\\n1. Use extended euclid algorithm to find x,y such that a*x + b*y = 1\\n2. Take n = ra*by + rb*ax\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\n# Extended Euclid\\ndef extended_euclid(a: int, b: int) -> tuple[int, int]:\\n    \\\"\\\"\\\"\\n    >>> extended_euclid(10, 6)\\n    (-1, 2)\\n\\n    >>> extended_euclid(7, 5)\\n    (-2, 3)\\n\\n    \\\"\\\"\\\"\\n    if b == 0:\\n        return (1, 0)\\n    (x, y) = extended_euclid(b, a % b)\\n    k = a // b\\n    return (y, x - k * y)\\n\\n\\n# Uses ExtendedEuclid to find inverses\\ndef chinese_remainder_theorem(n1: int, r1: int, n2: int, r2: int) -> int:\\n    \\\"\\\"\\\"\\n    >>> chinese_remainder_theorem(5,1,7,3)\\n    31\\n\\n    Explanation : 31 is the smallest number such that\\n                (i)  When we divide it by 5, we get remainder 1\\n                (ii) When we divide it by 7, we get remainder 3\\n\\n    >>> chinese_remainder_theorem(6,1,4,3)\\n    14\\n\\n    \\\"\\\"\\\"\\n    (x, y) = extended_euclid(n1, n2)\\n    m = n1 * n2\\n    n = r2 * x * n1 + r1 * y * n2\\n    return (n % m + m) % m\\n\\n\\n# ----------SAME SOLUTION USING InvertModulo instead ExtendedEuclid----------------\\n\\n# This function find the inverses of a i.e., a^(-1)\\ndef invert_modulo(a: int, n: int) -> int:\\n    \\\"\\\"\\\"\\n    >>> invert_modulo(2, 5)\\n    3\\n\\n    >>> invert_modulo(8,7)\\n    1\\n\\n    \\\"\\\"\\\"\\n    (b, x) = extended_euclid(a, n)\\n    if b < 0:\\n        b = (b % n + n) % n\\n    return b\\n\\n\\n# Same a above using InvertingModulo\\ndef chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:\\n    \\\"\\\"\\\"\\n    >>> chinese_remainder_theorem2(5,1,7,3)\\n    31\\n\\n    >>> chinese_remainder_theorem2(6,1,4,3)\\n    14\\n\\n    \\\"\\\"\\\"\\n    x, y = invert_modulo(n1, n2), invert_modulo(n2, n1)\\n    m = n1 * n2\\n    n = r2 * x * n1 + r1 * y * n2\\n    return (n % m + m) % m\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod(name=\\\"chinese_remainder_theorem\\\", verbose=True)\\n    testmod(name=\\\"chinese_remainder_theorem2\\\", verbose=True)\\n    testmod(name=\\\"invert_modulo\\\", verbose=True)\\n    testmod(name=\\\"extended_euclid\\\", verbose=True)\\n\"",
    "diophantine equation": "\"from __future__ import annotations\\n\\n\\ndef diophantine(a: int, b: int, c: int) -> tuple[float, float]:\\n    \\\"\\\"\\\"\\n    Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\\n    diophantine equation a*x + b*y = c has a solution (where x and y are integers)\\n    iff gcd(a,b) divides c.\\n\\n    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\\n\\n    >>> diophantine(10,6,14)\\n    (-7.0, 14.0)\\n\\n    >>> diophantine(391,299,-69)\\n    (9.0, -12.0)\\n\\n    But above equation has one more solution i.e., x = -4, y = 5.\\n    That's why we need diophantine all solution function.\\n\\n    \\\"\\\"\\\"\\n\\n    assert (\\n        c % greatest_common_divisor(a, b) == 0\\n    )  # greatest_common_divisor(a,b) function implemented below\\n    (d, x, y) = extended_gcd(a, b)  # extended_gcd(a,b) function implemented below\\n    r = c / d\\n    return (r * x, r * y)\\n\\n\\ndef diophantine_all_soln(a: int, b: int, c: int, n: int = 2) -> None:\\n    \\\"\\\"\\\"\\n    Lemma : if n|ab and gcd(a,n) = 1, then n|b.\\n\\n    Finding All solutions of Diophantine Equations:\\n\\n    Theorem : Let gcd(a,b) = d, a = d*p, b = d*q. If (x0,y0) is a solution of\\n    Diophantine Equation a*x + b*y = c.  a*x0 + b*y0 = c, then all the\\n    solutions have the form a(x0 + t*q) + b(y0 - t*p) = c,\\n    where t is an arbitrary integer.\\n\\n    n is the number of solution you want, n = 2 by default\\n\\n    >>> diophantine_all_soln(10, 6, 14)\\n    -7.0 14.0\\n    -4.0 9.0\\n\\n    >>> diophantine_all_soln(10, 6, 14, 4)\\n    -7.0 14.0\\n    -4.0 9.0\\n    -1.0 4.0\\n    2.0 -1.0\\n\\n    >>> diophantine_all_soln(391, 299, -69, n = 4)\\n    9.0 -12.0\\n    22.0 -29.0\\n    35.0 -46.0\\n    48.0 -63.0\\n\\n    \\\"\\\"\\\"\\n    (x0, y0) = diophantine(a, b, c)  # Initial value\\n    d = greatest_common_divisor(a, b)\\n    p = a // d\\n    q = b // d\\n\\n    for i in range(n):\\n        x = x0 + i * q\\n        y = y0 - i * p\\n        print(x, y)\\n\\n\\ndef greatest_common_divisor(a: int, b: int) -> int:\\n    \\\"\\\"\\\"\\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\\n\\n    Euclid's Algorithm\\n\\n    >>> greatest_common_divisor(7,5)\\n    1\\n\\n    Note : In number theory, two integers a and b are said to be relatively prime,\\n           mutually prime, or co-prime if the only positive integer (factor) that\\n           divides both of them is 1  i.e., gcd(a,b) = 1.\\n\\n    >>> greatest_common_divisor(121, 11)\\n    11\\n\\n    \\\"\\\"\\\"\\n    if a < b:\\n        a, b = b, a\\n\\n    while a % b != 0:\\n        a, b = b, a % b\\n\\n    return b\\n\\n\\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\\n    \\\"\\\"\\\"\\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\\n    x and y, then d = gcd(a,b)\\n\\n    >>> extended_gcd(10, 6)\\n    (2, -1, 2)\\n\\n    >>> extended_gcd(7, 5)\\n    (1, -2, 3)\\n\\n    \\\"\\\"\\\"\\n    assert a >= 0 and b >= 0\\n\\n    if b == 0:\\n        d, x, y = a, 1, 0\\n    else:\\n        (d, p, q) = extended_gcd(b, a % b)\\n        x = q\\n        y = p - q * (a // b)\\n\\n    assert a % d == 0 and b % d == 0\\n    assert d == a * x + b * y\\n\\n    return (d, x, y)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod(name=\\\"diophantine\\\", verbose=True)\\n    testmod(name=\\\"diophantine_all_soln\\\", verbose=True)\\n    testmod(name=\\\"extended_gcd\\\", verbose=True)\\n    testmod(name=\\\"greatest_common_divisor\\\", verbose=True)\\n\"",
    "modular division": "\"from __future__ import annotations\\n\\n\\ndef modular_division(a: int, b: int, n: int) -> int:\\n    \\\"\\\"\\\"\\n    Modular Division :\\n    An efficient algorithm for dividing b by a modulo n.\\n\\n    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\\n\\n    Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should\\n    return an integer x such that 0≤x≤n−1, and  b/a=x(modn) (that is, b=ax(modn)).\\n\\n    Theorem:\\n    a has a multiplicative inverse modulo n iff gcd(a,n) = 1\\n\\n\\n    This find x = b*a^(-1) mod n\\n    Uses ExtendedEuclid to find the inverse of a\\n\\n    >>> modular_division(4,8,5)\\n    2\\n\\n    >>> modular_division(3,8,5)\\n    1\\n\\n    >>> modular_division(4, 11, 5)\\n    4\\n\\n    \\\"\\\"\\\"\\n    assert n > 1 and a > 0 and greatest_common_divisor(a, n) == 1\\n    (d, t, s) = extended_gcd(n, a)  # Implemented below\\n    x = (b * s) % n\\n    return x\\n\\n\\ndef invert_modulo(a: int, n: int) -> int:\\n    \\\"\\\"\\\"\\n    This function find the inverses of a i.e., a^(-1)\\n\\n    >>> invert_modulo(2, 5)\\n    3\\n\\n    >>> invert_modulo(8,7)\\n    1\\n\\n    \\\"\\\"\\\"\\n    (b, x) = extended_euclid(a, n)  # Implemented below\\n    if b < 0:\\n        b = (b % n + n) % n\\n    return b\\n\\n\\n# ------------------ Finding Modular division using invert_modulo -------------------\\n\\n\\ndef modular_division2(a: int, b: int, n: int) -> int:\\n    \\\"\\\"\\\"\\n    This function used the above inversion of a to find x = (b*a^(-1))mod n\\n\\n    >>> modular_division2(4,8,5)\\n    2\\n\\n    >>> modular_division2(3,8,5)\\n    1\\n\\n    >>> modular_division2(4, 11, 5)\\n    4\\n\\n    \\\"\\\"\\\"\\n    s = invert_modulo(a, n)\\n    x = (b * s) % n\\n    return x\\n\\n\\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\\n    \\\"\\\"\\\"\\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\\n    and y, then d = gcd(a,b)\\n    >>> extended_gcd(10, 6)\\n    (2, -1, 2)\\n\\n    >>> extended_gcd(7, 5)\\n    (1, -2, 3)\\n\\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\\n\\n    \\\"\\\"\\\"\\n    assert a >= 0 and b >= 0\\n\\n    if b == 0:\\n        d, x, y = a, 1, 0\\n    else:\\n        (d, p, q) = extended_gcd(b, a % b)\\n        x = q\\n        y = p - q * (a // b)\\n\\n    assert a % d == 0 and b % d == 0\\n    assert d == a * x + b * y\\n\\n    return (d, x, y)\\n\\n\\ndef extended_euclid(a: int, b: int) -> tuple[int, int]:\\n    \\\"\\\"\\\"\\n    Extended Euclid\\n    >>> extended_euclid(10, 6)\\n    (-1, 2)\\n\\n    >>> extended_euclid(7, 5)\\n    (-2, 3)\\n\\n    \\\"\\\"\\\"\\n    if b == 0:\\n        return (1, 0)\\n    (x, y) = extended_euclid(b, a % b)\\n    k = a // b\\n    return (y, x - k * y)\\n\\n\\ndef greatest_common_divisor(a: int, b: int) -> int:\\n    \\\"\\\"\\\"\\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\\n    Euclid's Algorithm\\n\\n    >>> greatest_common_divisor(7,5)\\n    1\\n\\n    Note : In number theory, two integers a and b are said to be relatively prime,\\n        mutually prime, or co-prime if the only positive integer (factor) that divides\\n        both of them is 1  i.e., gcd(a,b) = 1.\\n\\n    >>> greatest_common_divisor(121, 11)\\n    11\\n\\n    \\\"\\\"\\\"\\n    if a < b:\\n        a, b = b, a\\n\\n    while a % b != 0:\\n        a, b = b, a % b\\n\\n    return b\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod(name=\\\"modular_division\\\", verbose=True)\\n    testmod(name=\\\"modular_division2\\\", verbose=True)\\n    testmod(name=\\\"invert_modulo\\\", verbose=True)\\n    testmod(name=\\\"extended_gcd\\\", verbose=True)\\n    testmod(name=\\\"extended_euclid\\\", verbose=True)\\n    testmod(name=\\\"greatest_common_divisor\\\", verbose=True)\\n\"",
    "quine mc cluskey": "\"from __future__ import annotations\\n\\n\\ndef compare_string(string1: str, string2: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> compare_string('0010','0110')\\n    '0_10'\\n\\n    >>> compare_string('0110','1101')\\n    'X'\\n    \\\"\\\"\\\"\\n    l1 = list(string1)\\n    l2 = list(string2)\\n    count = 0\\n    for i in range(len(l1)):\\n        if l1[i] != l2[i]:\\n            count += 1\\n            l1[i] = \\\"_\\\"\\n    if count > 1:\\n        return \\\"X\\\"\\n    else:\\n        return \\\"\\\".join(l1)\\n\\n\\ndef check(binary: list[str]) -> list[str]:\\n    \\\"\\\"\\\"\\n    >>> check(['0.00.01.5'])\\n    ['0.00.01.5']\\n    \\\"\\\"\\\"\\n    pi = []\\n    while 1:\\n        check1 = [\\\"$\\\"] * len(binary)\\n        temp = []\\n        for i in range(len(binary)):\\n            for j in range(i + 1, len(binary)):\\n                k = compare_string(binary[i], binary[j])\\n                if k != \\\"X\\\":\\n                    check1[i] = \\\"*\\\"\\n                    check1[j] = \\\"*\\\"\\n                    temp.append(k)\\n        for i in range(len(binary)):\\n            if check1[i] == \\\"$\\\":\\n                pi.append(binary[i])\\n        if len(temp) == 0:\\n            return pi\\n        binary = list(set(temp))\\n\\n\\ndef decimal_to_binary(no_of_variable: int, minterms: list[float]) -> list[str]:\\n    \\\"\\\"\\\"\\n    >>> decimal_to_binary(3,[1.5])\\n    ['0.00.01.5']\\n    \\\"\\\"\\\"\\n    temp = []\\n    s = \\\"\\\"\\n    for m in minterms:\\n        for i in range(no_of_variable):\\n            s = str(m % 2) + s\\n            m //= 2\\n        temp.append(s)\\n        s = \\\"\\\"\\n    return temp\\n\\n\\ndef is_for_table(string1: str, string2: str, count: int) -> bool:\\n    \\\"\\\"\\\"\\n    >>> is_for_table('__1','011',2)\\n    True\\n\\n    >>> is_for_table('01_','001',1)\\n    False\\n    \\\"\\\"\\\"\\n    l1 = list(string1)\\n    l2 = list(string2)\\n    count_n = 0\\n    for i in range(len(l1)):\\n        if l1[i] != l2[i]:\\n            count_n += 1\\n    if count_n == count:\\n        return True\\n    else:\\n        return False\\n\\n\\ndef selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:\\n    \\\"\\\"\\\"\\n    >>> selection([[1]],['0.00.01.5'])\\n    ['0.00.01.5']\\n\\n    >>> selection([[1]],['0.00.01.5'])\\n    ['0.00.01.5']\\n    \\\"\\\"\\\"\\n    temp = []\\n    select = [0] * len(chart)\\n    for i in range(len(chart[0])):\\n        count = 0\\n        rem = -1\\n        for j in range(len(chart)):\\n            if chart[j][i] == 1:\\n                count += 1\\n                rem = j\\n        if count == 1:\\n            select[rem] = 1\\n    for i in range(len(select)):\\n        if select[i] == 1:\\n            for j in range(len(chart[0])):\\n                if chart[i][j] == 1:\\n                    for k in range(len(chart)):\\n                        chart[k][j] = 0\\n            temp.append(prime_implicants[i])\\n    while 1:\\n        max_n = 0\\n        rem = -1\\n        count_n = 0\\n        for i in range(len(chart)):\\n            count_n = chart[i].count(1)\\n            if count_n > max_n:\\n                max_n = count_n\\n                rem = i\\n\\n        if max_n == 0:\\n            return temp\\n\\n        temp.append(prime_implicants[rem])\\n\\n        for i in range(len(chart[0])):\\n            if chart[rem][i] == 1:\\n                for j in range(len(chart)):\\n                    chart[j][i] = 0\\n\\n\\ndef prime_implicant_chart(\\n    prime_implicants: list[str], binary: list[str]\\n) -> list[list[int]]:\\n    \\\"\\\"\\\"\\n    >>> prime_implicant_chart(['0.00.01.5'],['0.00.01.5'])\\n    [[1]]\\n    \\\"\\\"\\\"\\n    chart = [[0 for x in range(len(binary))] for x in range(len(prime_implicants))]\\n    for i in range(len(prime_implicants)):\\n        count = prime_implicants[i].count(\\\"_\\\")\\n        for j in range(len(binary)):\\n            if is_for_table(prime_implicants[i], binary[j], count):\\n                chart[i][j] = 1\\n\\n    return chart\\n\\n\\ndef main() -> None:\\n    no_of_variable = int(input(\\\"Enter the no. of variables\\\\n\\\"))\\n    minterms = [\\n        float(x)\\n        for x in input(\\n            \\\"Enter the decimal representation of Minterms 'Spaces Separated'\\\\n\\\"\\n        ).split()\\n    ]\\n    binary = decimal_to_binary(no_of_variable, minterms)\\n\\n    prime_implicants = check(binary)\\n    print(\\\"Prime Implicants are:\\\")\\n    print(prime_implicants)\\n    chart = prime_implicant_chart(prime_implicants, binary)\\n\\n    essential_prime_implicants = selection(chart, prime_implicants)\\n    print(\\\"Essential Prime Implicants are:\\\")\\n    print(essential_prime_implicants)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "conways game of life": "\"\\\"\\\"\\\"\\nConway's Game of Life implemented in Python.\\nhttps://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom PIL import Image\\n\\n# Define glider example\\nGLIDER = [\\n    [0, 1, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 1, 0, 0, 0, 0, 0],\\n    [1, 1, 1, 0, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 0, 0, 0, 0],\\n]\\n\\n# Define blinker example\\nBLINKER = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\\n\\n\\ndef new_generation(cells: list[list[int]]) -> list[list[int]]:\\n    \\\"\\\"\\\"\\n    Generates the next generation for a given state of Conway's Game of Life.\\n    >>> new_generation(BLINKER)\\n    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\\n    \\\"\\\"\\\"\\n    next_generation = []\\n    for i in range(len(cells)):\\n        next_generation_row = []\\n        for j in range(len(cells[i])):\\n            # Get the number of live neighbours\\n            neighbour_count = 0\\n            if i > 0 and j > 0:\\n                neighbour_count += cells[i - 1][j - 1]\\n            if i > 0:\\n                neighbour_count += cells[i - 1][j]\\n            if i > 0 and j < len(cells[i]) - 1:\\n                neighbour_count += cells[i - 1][j + 1]\\n            if j > 0:\\n                neighbour_count += cells[i][j - 1]\\n            if j < len(cells[i]) - 1:\\n                neighbour_count += cells[i][j + 1]\\n            if i < len(cells) - 1 and j > 0:\\n                neighbour_count += cells[i + 1][j - 1]\\n            if i < len(cells) - 1:\\n                neighbour_count += cells[i + 1][j]\\n            if i < len(cells) - 1 and j < len(cells[i]) - 1:\\n                neighbour_count += cells[i + 1][j + 1]\\n\\n            # Rules of the game of life (excerpt from Wikipedia):\\n            # 1. Any live cell with two or three live neighbours survives.\\n            # 2. Any dead cell with three live neighbours becomes a live cell.\\n            # 3. All other live cells die in the next generation.\\n            #    Similarly, all other dead cells stay dead.\\n            alive = cells[i][j] == 1\\n            if (\\n                (alive and 2 <= neighbour_count <= 3)\\n                or not alive\\n                and neighbour_count == 3\\n            ):\\n                next_generation_row.append(1)\\n            else:\\n                next_generation_row.append(0)\\n\\n        next_generation.append(next_generation_row)\\n    return next_generation\\n\\n\\ndef generate_images(cells: list[list[int]], frames: int) -> list[Image.Image]:\\n    \\\"\\\"\\\"\\n    Generates a list of images of subsequent Game of Life states.\\n    \\\"\\\"\\\"\\n    images = []\\n    for _ in range(frames):\\n        # Create output image\\n        img = Image.new(\\\"RGB\\\", (len(cells[0]), len(cells)))\\n        pixels = img.load()\\n\\n        # Save cells to image\\n        for x in range(len(cells)):\\n            for y in range(len(cells[0])):\\n                colour = 255 - cells[y][x] * 255\\n                pixels[x, y] = (colour, colour, colour)\\n\\n        # Save image\\n        images.append(img)\\n        cells = new_generation(cells)\\n    return images\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    images = generate_images(GLIDER, 16)\\n    images[0].save(\\\"out.gif\\\", save_all=True, append_images=images[1:])\\n\"",
    "game of life": "\"\\\"\\\"\\\"Conway's Game Of Life, Author Anurag Kumar(mailto:anuragkumarak95@gmail.com)\\n\\nRequirements:\\n  - numpy\\n  - random\\n  - time\\n  - matplotlib\\n\\nPython:\\n  - 3.5\\n\\nUsage:\\n  - $python3 game_o_life <canvas_size:int>\\n\\nGame-Of-Life Rules:\\n\\n 1.\\n Any live cell with fewer than two live neighbours\\n dies, as if caused by under-population.\\n 2.\\n Any live cell with two or three live neighbours lives\\n on to the next generation.\\n 3.\\n Any live cell with more than three live neighbours\\n dies, as if by over-population.\\n 4.\\n Any dead cell with exactly three live neighbours be-\\n comes a live cell, as if by reproduction.\\n \\\"\\\"\\\"\\nimport random\\nimport sys\\n\\nimport numpy as np\\nfrom matplotlib import pyplot as plt\\nfrom matplotlib.colors import ListedColormap\\n\\nusage_doc = \\\"Usage of script: script_nama <size_of_canvas:int>\\\"\\n\\nchoice = [0] * 100 + [1] * 10\\nrandom.shuffle(choice)\\n\\n\\ndef create_canvas(size: int) -> list[list[bool]]:\\n    canvas = [[False for i in range(size)] for j in range(size)]\\n    return canvas\\n\\n\\ndef seed(canvas: list[list[bool]]) -> None:\\n    for i, row in enumerate(canvas):\\n        for j, _ in enumerate(row):\\n            canvas[i][j] = bool(random.getrandbits(1))\\n\\n\\ndef run(canvas: list[list[bool]]) -> list[list[bool]]:\\n    \\\"\\\"\\\"This  function runs the rules of game through all points, and changes their\\n    status accordingly.(in the same canvas)\\n    @Args:\\n    --\\n    canvas : canvas of population to run the rules on.\\n\\n    @returns:\\n    --\\n    None\\n    \\\"\\\"\\\"\\n    current_canvas = np.array(canvas)\\n    next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))\\n    for r, row in enumerate(current_canvas):\\n        for c, pt in enumerate(row):\\n            # print(r-1,r+2,c-1,c+2)\\n            next_gen_canvas[r][c] = __judge_point(\\n                pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]\\n            )\\n\\n    current_canvas = next_gen_canvas\\n    del next_gen_canvas  # cleaning memory as we move on.\\n    return_canvas: list[list[bool]] = current_canvas.tolist()\\n    return return_canvas\\n\\n\\ndef __judge_point(pt: bool, neighbours: list[list[bool]]) -> bool:\\n    dead = 0\\n    alive = 0\\n    # finding dead or alive neighbours count.\\n    for i in neighbours:\\n        for status in i:\\n            if status:\\n                alive += 1\\n            else:\\n                dead += 1\\n\\n    # handling duplicate entry for focus pt.\\n    if pt:\\n        alive -= 1\\n    else:\\n        dead -= 1\\n\\n    # running the rules of game here.\\n    state = pt\\n    if pt:\\n        if alive < 2:\\n            state = False\\n        elif alive == 2 or alive == 3:\\n            state = True\\n        elif alive > 3:\\n            state = False\\n    else:\\n        if alive == 3:\\n            state = True\\n\\n    return state\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    if len(sys.argv) != 2:\\n        raise Exception(usage_doc)\\n\\n    canvas_size = int(sys.argv[1])\\n    # main working structure of this module.\\n    c = create_canvas(canvas_size)\\n    seed(c)\\n    fig, ax = plt.subplots()\\n    fig.show()\\n    cmap = ListedColormap([\\\"w\\\", \\\"k\\\"])\\n    try:\\n        while True:\\n            c = run(c)\\n            ax.matshow(c, cmap=cmap)\\n            fig.canvas.draw()\\n            ax.cla()\\n    except KeyboardInterrupt:\\n        # do nothing.\\n        pass\\n\"",
    "nagel schrekenberg": "\"\\\"\\\"\\\"\\nSimulate the evolution of a highway with only one road that is a loop.\\nThe highway is divided in cells, each cell can have at most one car in it.\\nThe highway is a loop so when a car comes to one end, it will come out on the other.\\nEach car is represented by its speed (from 0 to 5).\\n\\nSome information about speed:\\n    -1 means that the cell on the highway is empty\\n    0 to 5 are the speed of the cars with 0 being the lowest and 5 the highest\\n\\nhighway: list[int]  Where every position and speed of every car will be stored\\nprobability         The probability that a driver will slow down\\ninitial_speed       The speed of the cars a the start\\nfrequency           How many cells there are between two cars at the start\\nmax_speed           The maximum speed a car can go to\\nnumber_of_cells     How many cell are there in the highway\\nnumber_of_update    How many times will the position be updated\\n\\nMore information here: https://en.wikipedia.org/wiki/Nagel%E2%80%93Schreckenberg_model\\n\\nExamples for doctest:\\n>>> simulate(construct_highway(6, 3, 0), 2, 0, 2)\\n[[0, -1, -1, 0, -1, -1], [-1, 1, -1, -1, 1, -1], [-1, -1, 1, -1, -1, 1]]\\n>>> simulate(construct_highway(5, 2, -2), 3, 0, 2)\\n[[0, -1, 0, -1, 0], [0, -1, 0, -1, -1], [0, -1, -1, 1, -1], [-1, 1, -1, 0, -1]]\\n\\\"\\\"\\\"\\nfrom random import randint, random\\n\\n\\ndef construct_highway(\\n    number_of_cells: int,\\n    frequency: int,\\n    initial_speed: int,\\n    random_frequency: bool = False,\\n    random_speed: bool = False,\\n    max_speed: int = 5,\\n) -> list:\\n    \\\"\\\"\\\"\\n    Build the highway following the parameters given\\n    >>> construct_highway(10, 2, 6)\\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\\n    >>> construct_highway(10, 10, 2)\\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\\n    \\\"\\\"\\\"\\n\\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\\n    i = 0\\n    if initial_speed < 0:\\n        initial_speed = 0\\n    while i < number_of_cells:\\n        highway[0][i] = (\\n            randint(0, max_speed) if random_speed else initial_speed\\n        )  # Place the cars\\n        i += (\\n            randint(1, max_speed * 2) if random_frequency else frequency\\n        )  # Arbitrary number, may need tuning\\n    return highway\\n\\n\\ndef get_distance(highway_now: list, car_index: int) -> int:\\n    \\\"\\\"\\\"\\n    Get the distance between a car (at index car_index) and the next car\\n    >>> get_distance([6, -1, 6, -1, 6], 2)\\n    1\\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\\n    3\\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\\n    4\\n    \\\"\\\"\\\"\\n\\n    distance = 0\\n    cells = highway_now[car_index + 1 :]\\n    for cell in range(len(cells)):  # May need a better name for this\\n        if cells[cell] != -1:  # If the cell is not empty then\\n            return distance  # we have the distance we wanted\\n        distance += 1\\n    # Here if the car is near the end of the highway\\n    return distance + get_distance(highway_now, -1)\\n\\n\\ndef update(highway_now: list, probability: float, max_speed: int) -> list:\\n    \\\"\\\"\\\"\\n    Update the speed of the cars\\n    >>> update([-1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)\\n    [-1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 4]\\n    >>> update([-1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)\\n    [-1, -1, 3, -1, -1, -1, -1, 1]\\n    \\\"\\\"\\\"\\n\\n    number_of_cells = len(highway_now)\\n    # Beforce calculations, the highway is empty\\n    next_highway = [-1] * number_of_cells\\n\\n    for car_index in range(number_of_cells):\\n        if highway_now[car_index] != -1:\\n            # Add 1 to the current speed of the car and cap the speed\\n            next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)\\n            # Number of empty cell before the next car\\n            dn = get_distance(highway_now, car_index) - 1\\n            # We can't have the car causing an accident\\n            next_highway[car_index] = min(next_highway[car_index], dn)\\n            if random() < probability:\\n                # Randomly, a driver will slow down\\n                next_highway[car_index] = max(next_highway[car_index] - 1, 0)\\n    return next_highway\\n\\n\\ndef simulate(\\n    highway: list, number_of_update: int, probability: float, max_speed: int\\n) -> list:\\n    \\\"\\\"\\\"\\n    The main function, it will simulate the evolution of the highway\\n    >>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3)\\n    [[-1, 2, -1, -1, -1, 3], [-1, -1, -1, 2, -1, 0], [1, -1, -1, 0, -1, -1]]\\n    >>> simulate([[-1, 2, -1, 3]], 4, 0.0, 3)\\n    [[-1, 2, -1, 3], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0]]\\n    \\\"\\\"\\\"\\n\\n    number_of_cells = len(highway[0])\\n\\n    for i in range(number_of_update):\\n        next_speeds_calculated = update(highway[i], probability, max_speed)\\n        real_next_speeds = [-1] * number_of_cells\\n\\n        for car_index in range(number_of_cells):\\n            speed = next_speeds_calculated[car_index]\\n            if speed != -1:\\n                # Change the position based on the speed (with % to create the loop)\\n                index = (car_index + speed) % number_of_cells\\n                # Commit the change of position\\n                real_next_speeds[index] = speed\\n        highway.append(real_next_speeds)\\n\\n    return highway\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "one dimensional": "\"\\\"\\\"\\\"\\nReturn an image of 16 generations of one-dimensional cellular automata based on a given\\nruleset number\\nhttps://mathworld.wolfram.com/ElementaryCellularAutomaton.html\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\nfrom PIL import Image\\n\\n# Define the first generation of cells\\n# fmt: off\\nCELLS = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\\n          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\\n# fmt: on\\n\\n\\ndef format_ruleset(ruleset: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    >>> format_ruleset(11100)\\n    [0, 0, 0, 1, 1, 1, 0, 0]\\n    >>> format_ruleset(0)\\n    [0, 0, 0, 0, 0, 0, 0, 0]\\n    >>> format_ruleset(11111111)\\n    [1, 1, 1, 1, 1, 1, 1, 1]\\n    \\\"\\\"\\\"\\n    return [int(c) for c in f\\\"{ruleset:08}\\\"[:8]]\\n\\n\\ndef new_generation(cells: list[list[int]], rule: list[int], time: int) -> list[int]:\\n    population = len(cells[0])  # 31\\n    next_generation = []\\n    for i in range(population):\\n        # Get the neighbors of each cell\\n        # Handle neighbours outside bounds by using 0 as their value\\n        left_neighbor = 0 if i == 0 else cells[time][i - 1]\\n        right_neighbor = 0 if i == population - 1 else cells[time][i + 1]\\n        # Define a new cell and add it to the new generation\\n        situation = 7 - int(f\\\"{left_neighbor}{cells[time][i]}{right_neighbor}\\\", 2)\\n        next_generation.append(rule[situation])\\n    return next_generation\\n\\n\\ndef generate_image(cells: list[list[int]]) -> Image.Image:\\n    \\\"\\\"\\\"\\n    Convert the cells into a greyscale PIL.Image.Image and return it to the caller.\\n    >>> from random import random\\n    >>> cells = [[random() for w in range(31)] for h in range(16)]\\n    >>> img = generate_image(cells)\\n    >>> isinstance(img, Image.Image)\\n    True\\n    >>> img.width, img.height\\n    (31, 16)\\n    \\\"\\\"\\\"\\n    # Create the output image\\n    img = Image.new(\\\"RGB\\\", (len(cells[0]), len(cells)))\\n    pixels = img.load()\\n    # Generates image\\n    for w in range(img.width):\\n        for h in range(img.height):\\n            color = 255 - int(255 * cells[h][w])\\n            pixels[w, h] = (color, color, color)\\n    return img\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    rule_num = bin(int(input(\\\"Rule:\\\\n\\\").strip()))[2:]\\n    rule = format_ruleset(int(rule_num))\\n    for time in range(16):\\n        CELLS.append(new_generation(CELLS, rule, time))\\n    img = generate_image(CELLS)\\n    # Uncomment to save the image\\n    # img.save(f\\\"rule_{rule_num}.png\\\")\\n    img.show()\\n\"",
    "a1z26": "\"\\\"\\\"\\\"\\nConvert a string of characters to a sequence of numbers\\ncorresponding to the character's position in the alphabet.\\n\\nhttps://www.dcode.fr/letter-number-cipher\\nhttp://bestcodes.weebly.com/a1z26.html\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef encode(plain: str) -> list[int]:\\n    \\\"\\\"\\\"\\n    >>> encode(\\\"myname\\\")\\n    [13, 25, 14, 1, 13, 5]\\n    \\\"\\\"\\\"\\n    return [ord(elem) - 96 for elem in plain]\\n\\n\\ndef decode(encoded: list[int]) -> str:\\n    \\\"\\\"\\\"\\n    >>> decode([13, 25, 14, 1, 13, 5])\\n    'myname'\\n    \\\"\\\"\\\"\\n    return \\\"\\\".join(chr(elem + 96) for elem in encoded)\\n\\n\\ndef main() -> None:\\n    encoded = encode(input(\\\"-> \\\").strip().lower())\\n    print(\\\"Encoded: \\\", encoded)\\n    print(\\\"Decoded:\\\", decode(encoded))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "affine cipher": "\"import random\\nimport sys\\n\\nfrom . import cryptomath_module as cryptomath\\n\\nSYMBOLS = (\\n    r\\\"\\\"\\\" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\\\"\\\"\\\"\\n    r\\\"\\\"\\\"abcdefghijklmnopqrstuvwxyz{|}~\\\"\\\"\\\"\\n)\\n\\n\\ndef check_keys(keyA: int, keyB: int, mode: str) -> None:\\n    if mode == \\\"encrypt\\\":\\n        if keyA == 1:\\n            sys.exit(\\n                \\\"The affine cipher becomes weak when key \\\"\\n                \\\"A is set to 1. Choose different key\\\"\\n            )\\n        if keyB == 0:\\n            sys.exit(\\n                \\\"The affine cipher becomes weak when key \\\"\\n                \\\"B is set to 0. Choose different key\\\"\\n            )\\n    if keyA < 0 or keyB < 0 or keyB > len(SYMBOLS) - 1:\\n        sys.exit(\\n            \\\"Key A must be greater than 0 and key B must \\\"\\n            f\\\"be between 0 and {len(SYMBOLS) - 1}.\\\"\\n        )\\n    if cryptomath.gcd(keyA, len(SYMBOLS)) != 1:\\n        sys.exit(\\n            f\\\"Key A {keyA} and the symbol set size {len(SYMBOLS)} \\\"\\n            \\\"are not relatively prime. Choose a different key.\\\"\\n        )\\n\\n\\ndef encrypt_message(key: int, message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> encrypt_message(4545, 'The affine cipher is a type of monoalphabetic '\\n    ...                       'substitution cipher.')\\n    'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF{xIp~{HL}Gi'\\n    \\\"\\\"\\\"\\n    keyA, keyB = divmod(key, len(SYMBOLS))\\n    check_keys(keyA, keyB, \\\"encrypt\\\")\\n    cipherText = \\\"\\\"\\n    for symbol in message:\\n        if symbol in SYMBOLS:\\n            symIndex = SYMBOLS.find(symbol)\\n            cipherText += SYMBOLS[(symIndex * keyA + keyB) % len(SYMBOLS)]\\n        else:\\n            cipherText += symbol\\n    return cipherText\\n\\n\\ndef decrypt_message(key: int, message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> decrypt_message(4545, 'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF'\\n    ...                       '{xIp~{HL}Gi')\\n    'The affine cipher is a type of monoalphabetic substitution cipher.'\\n    \\\"\\\"\\\"\\n    keyA, keyB = divmod(key, len(SYMBOLS))\\n    check_keys(keyA, keyB, \\\"decrypt\\\")\\n    plainText = \\\"\\\"\\n    modInverseOfkeyA = cryptomath.find_mod_inverse(keyA, len(SYMBOLS))\\n    for symbol in message:\\n        if symbol in SYMBOLS:\\n            symIndex = SYMBOLS.find(symbol)\\n            plainText += SYMBOLS[(symIndex - keyB) * modInverseOfkeyA % len(SYMBOLS)]\\n        else:\\n            plainText += symbol\\n    return plainText\\n\\n\\ndef get_random_key() -> int:\\n    while True:\\n        keyA = random.randint(2, len(SYMBOLS))\\n        keyB = random.randint(2, len(SYMBOLS))\\n        if cryptomath.gcd(keyA, len(SYMBOLS)) == 1 and keyB % len(SYMBOLS) != 0:\\n            return keyA * len(SYMBOLS) + keyB\\n\\n\\ndef main() -> None:\\n    \\\"\\\"\\\"\\n    >>> key = get_random_key()\\n    >>> msg = \\\"This is a test!\\\"\\n    >>> decrypt_message(key, encrypt_message(key, msg)) == msg\\n    True\\n    \\\"\\\"\\\"\\n    message = input(\\\"Enter message: \\\").strip()\\n    key = int(input(\\\"Enter key [2000 - 9000]: \\\").strip())\\n    mode = input(\\\"Encrypt/Decrypt [E/D]: \\\").strip().lower()\\n\\n    if mode.startswith(\\\"e\\\"):\\n        mode = \\\"encrypt\\\"\\n        translated = encrypt_message(key, message)\\n    elif mode.startswith(\\\"d\\\"):\\n        mode = \\\"decrypt\\\"\\n        translated = decrypt_message(key, message)\\n    print(f\\\"\\\\n{mode.title()}ed text: \\\\n{translated}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    # main()\\n\"",
    "atbash": "\"\\\"\\\"\\\" https://en.wikipedia.org/wiki/Atbash \\\"\\\"\\\"\\nimport string\\n\\n\\ndef atbash_slow(sequence: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> atbash_slow(\\\"ABCDEFG\\\")\\n    'ZYXWVUT'\\n\\n    >>> atbash_slow(\\\"aW;;123BX\\\")\\n    'zD;;123YC'\\n    \\\"\\\"\\\"\\n    output = \\\"\\\"\\n    for i in sequence:\\n        extract = ord(i)\\n        if 65 <= extract <= 90:\\n            output += chr(155 - extract)\\n        elif 97 <= extract <= 122:\\n            output += chr(219 - extract)\\n        else:\\n            output += i\\n    return output\\n\\n\\ndef atbash(sequence: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> atbash(\\\"ABCDEFG\\\")\\n    'ZYXWVUT'\\n\\n    >>> atbash(\\\"aW;;123BX\\\")\\n    'zD;;123YC'\\n    \\\"\\\"\\\"\\n    letters = string.ascii_letters\\n    letters_reversed = string.ascii_lowercase[::-1] + string.ascii_uppercase[::-1]\\n    return \\\"\\\".join(\\n        letters_reversed[letters.index(c)] if c in letters else c for c in sequence\\n    )\\n\\n\\ndef benchmark() -> None:\\n    \\\"\\\"\\\"Let's benchmark them side-by-side...\\\"\\\"\\\"\\n    from timeit import timeit\\n\\n    print(\\\"Running performance benchmarks...\\\")\\n    print(\\n        \\\"> atbash_slow()\\\",\\n        timeit(\\n            \\\"atbash_slow(printable)\\\",\\n            setup=\\\"from string import printable ; from __main__ import atbash_slow\\\",\\n        ),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\">      atbash()\\\",\\n        timeit(\\n            \\\"atbash(printable)\\\",\\n            setup=\\\"from string import printable ; from __main__ import atbash\\\",\\n        ),\\n        \\\"seconds\\\",\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    for example in (\\\"ABCDEFGH\\\", \\\"123GGjj\\\", \\\"testStringtest\\\", \\\"with space\\\"):\\n        print(f\\\"{example} encrypted in atbash: {atbash(example)}\\\")\\n    benchmark()\\n\"",
    "baconian cipher": "\"\\\"\\\"\\\"\\nProgram to encode and decode Baconian or Bacon's Cipher\\nWikipedia reference : https://en.wikipedia.org/wiki/Bacon%27s_cipher\\n\\\"\\\"\\\"\\n\\nencode_dict = {\\n    \\\"a\\\": \\\"AAAAA\\\",\\n    \\\"b\\\": \\\"AAAAB\\\",\\n    \\\"c\\\": \\\"AAABA\\\",\\n    \\\"d\\\": \\\"AAABB\\\",\\n    \\\"e\\\": \\\"AABAA\\\",\\n    \\\"f\\\": \\\"AABAB\\\",\\n    \\\"g\\\": \\\"AABBA\\\",\\n    \\\"h\\\": \\\"AABBB\\\",\\n    \\\"i\\\": \\\"ABAAA\\\",\\n    \\\"j\\\": \\\"BBBAA\\\",\\n    \\\"k\\\": \\\"ABAAB\\\",\\n    \\\"l\\\": \\\"ABABA\\\",\\n    \\\"m\\\": \\\"ABABB\\\",\\n    \\\"n\\\": \\\"ABBAA\\\",\\n    \\\"o\\\": \\\"ABBAB\\\",\\n    \\\"p\\\": \\\"ABBBA\\\",\\n    \\\"q\\\": \\\"ABBBB\\\",\\n    \\\"r\\\": \\\"BAAAA\\\",\\n    \\\"s\\\": \\\"BAAAB\\\",\\n    \\\"t\\\": \\\"BAABA\\\",\\n    \\\"u\\\": \\\"BAABB\\\",\\n    \\\"v\\\": \\\"BBBAB\\\",\\n    \\\"w\\\": \\\"BABAA\\\",\\n    \\\"x\\\": \\\"BABAB\\\",\\n    \\\"y\\\": \\\"BABBA\\\",\\n    \\\"z\\\": \\\"BABBB\\\",\\n    \\\" \\\": \\\" \\\",\\n}\\n\\n\\ndecode_dict = {value: key for key, value in encode_dict.items()}\\n\\n\\ndef encode(word: str) -> str:\\n    \\\"\\\"\\\"\\n    Encodes to Baconian cipher\\n\\n    >>> encode(\\\"hello\\\")\\n    'AABBBAABAAABABAABABAABBAB'\\n    >>> encode(\\\"hello world\\\")\\n    'AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB'\\n    >>> encode(\\\"hello world!\\\")\\n    Traceback (most recent call last):\\n        ...\\n    Exception: encode() accepts only letters of the alphabet and spaces\\n    \\\"\\\"\\\"\\n    encoded = \\\"\\\"\\n    for letter in word.lower():\\n        if letter.isalpha() or letter == \\\" \\\":\\n            encoded += encode_dict[letter]\\n        else:\\n            raise Exception(\\\"encode() accepts only letters of the alphabet and spaces\\\")\\n    return encoded\\n\\n\\ndef decode(coded: str) -> str:\\n    \\\"\\\"\\\"\\n    Decodes from Baconian cipher\\n\\n    >>> decode(\\\"AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB\\\")\\n    'hello world'\\n    >>> decode(\\\"AABBBAABAAABABAABABAABBAB\\\")\\n    'hello'\\n    >>> decode(\\\"AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB!\\\")\\n    Traceback (most recent call last):\\n        ...\\n    Exception: decode() accepts only 'A', 'B' and spaces\\n    \\\"\\\"\\\"\\n    if set(coded) - {\\\"A\\\", \\\"B\\\", \\\" \\\"} != set():\\n        raise Exception(\\\"decode() accepts only 'A', 'B' and spaces\\\")\\n    decoded = \\\"\\\"\\n    for word in coded.split():\\n        while len(word) != 0:\\n            decoded += decode_dict[word[:5]]\\n            word = word[5:]\\n        decoded += \\\" \\\"\\n    return decoded.strip()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "base16": "\"import base64\\n\\n\\ndef base16_encode(inp: str) -> bytes:\\n    \\\"\\\"\\\"\\n    Encodes a given utf-8 string into base-16.\\n\\n    >>> base16_encode('Hello World!')\\n    b'48656C6C6F20576F726C6421'\\n    >>> base16_encode('HELLO WORLD!')\\n    b'48454C4C4F20574F524C4421'\\n    >>> base16_encode('')\\n    b''\\n    \\\"\\\"\\\"\\n    # encode the input into a bytes-like object and then encode b16encode that\\n    return base64.b16encode(inp.encode(\\\"utf-8\\\"))\\n\\n\\ndef base16_decode(b16encoded: bytes) -> str:\\n    \\\"\\\"\\\"\\n    Decodes from base-16 to a utf-8 string.\\n\\n    >>> base16_decode(b'48656C6C6F20576F726C6421')\\n    'Hello World!'\\n    >>> base16_decode(b'48454C4C4F20574F524C4421')\\n    'HELLO WORLD!'\\n    >>> base16_decode(b'')\\n    ''\\n    \\\"\\\"\\\"\\n    # b16decode the input into bytes and decode that into a human readable string\\n    return base64.b16decode(b16encoded).decode(\\\"utf-8\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "base32": "\"import base64\\n\\n\\ndef base32_encode(string: str) -> bytes:\\n    \\\"\\\"\\\"\\n    Encodes a given string to base32, returning a bytes-like object\\n    >>> base32_encode(\\\"Hello World!\\\")\\n    b'JBSWY3DPEBLW64TMMQQQ===='\\n    >>> base32_encode(\\\"123456\\\")\\n    b'GEZDGNBVGY======'\\n    >>> base32_encode(\\\"some long complex string\\\")\\n    b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY='\\n    \\\"\\\"\\\"\\n\\n    # encoded the input (we need a bytes like object)\\n    # then, b32encoded the bytes-like object\\n    return base64.b32encode(string.encode(\\\"utf-8\\\"))\\n\\n\\ndef base32_decode(encoded_bytes: bytes) -> str:\\n    \\\"\\\"\\\"\\n    Decodes a given bytes-like object to a string, returning a string\\n    >>> base32_decode(b'JBSWY3DPEBLW64TMMQQQ====')\\n    'Hello World!'\\n    >>> base32_decode(b'GEZDGNBVGY======')\\n    '123456'\\n    >>> base32_decode(b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY=')\\n    'some long complex string'\\n    \\\"\\\"\\\"\\n\\n    # decode the bytes from base32\\n    # then, decode the bytes-like object to return as a string\\n    return base64.b32decode(encoded_bytes).decode(\\\"utf-8\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    test = \\\"Hello World!\\\"\\n    encoded = base32_encode(test)\\n    print(encoded)\\n\\n    decoded = base32_decode(encoded)\\n    print(decoded)\\n\"",
    "base64": "\"B64_CHARSET = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\"\\n\\n\\ndef base64_encode(data: bytes) -> bytes:\\n    \\\"\\\"\\\"Encodes data according to RFC4648.\\n\\n    The data is first transformed to binary and appended with binary digits so that its\\n    length becomes a multiple of 6, then each 6 binary digits will match a character in\\n    the B64_CHARSET string. The number of appended binary digits would later determine\\n    how many \\\"=\\\" signs should be added, the padding.\\n    For every 2 binary digits added, a \\\"=\\\" sign is added in the output.\\n    We can add any binary digits to make it a multiple of 6, for instance, consider the\\n    following example:\\n    \\\"AA\\\" -> 0010100100101001 -> 001010 010010 1001\\n    As can be seen above, 2 more binary digits should be added, so there's 4\\n    possibilities here: 00, 01, 10 or 11.\\n    That being said, Base64 encoding can be used in Steganography to hide data in these\\n    appended digits.\\n\\n    >>> from base64 import b64encode\\n    >>> a = b\\\"This pull request is part of Hacktoberfest20!\\\"\\n    >>> b = b\\\"https://tools.ietf.org/html/rfc4648\\\"\\n    >>> c = b\\\"A\\\"\\n    >>> base64_encode(a) == b64encode(a)\\n    True\\n    >>> base64_encode(b) == b64encode(b)\\n    True\\n    >>> base64_encode(c) == b64encode(c)\\n    True\\n    >>> base64_encode(\\\"abc\\\")\\n    Traceback (most recent call last):\\n      ...\\n    TypeError: a bytes-like object is required, not 'str'\\n    \\\"\\\"\\\"\\n    # Make sure the supplied data is a bytes-like object\\n    if not isinstance(data, bytes):\\n        raise TypeError(\\n            f\\\"a bytes-like object is required, not '{data.__class__.__name__}'\\\"\\n        )\\n\\n    binary_stream = \\\"\\\".join(bin(byte)[2:].zfill(8) for byte in data)\\n\\n    padding_needed = len(binary_stream) % 6 != 0\\n\\n    if padding_needed:\\n        # The padding that will be added later\\n        padding = b\\\"=\\\" * ((6 - len(binary_stream) % 6) // 2)\\n\\n        # Append binary_stream with arbitrary binary digits (0's by default) to make its\\n        # length a multiple of 6.\\n        binary_stream += \\\"0\\\" * (6 - len(binary_stream) % 6)\\n    else:\\n        padding = b\\\"\\\"\\n\\n    # Encode every 6 binary digits to their corresponding Base64 character\\n    return (\\n        \\\"\\\".join(\\n            B64_CHARSET[int(binary_stream[index : index + 6], 2)]\\n            for index in range(0, len(binary_stream), 6)\\n        ).encode()\\n        + padding\\n    )\\n\\n\\ndef base64_decode(encoded_data: str) -> bytes:\\n    \\\"\\\"\\\"Decodes data according to RFC4648.\\n\\n    This does the reverse operation of base64_encode.\\n    We first transform the encoded data back to a binary stream, take off the\\n    previously appended binary digits according to the padding, at this point we\\n    would have a binary stream whose length is multiple of 8, the last step is\\n    to convert every 8 bits to a byte.\\n\\n    >>> from base64 import b64decode\\n    >>> a = \\\"VGhpcyBwdWxsIHJlcXVlc3QgaXMgcGFydCBvZiBIYWNrdG9iZXJmZXN0MjAh\\\"\\n    >>> b = \\\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDg=\\\"\\n    >>> c = \\\"QQ==\\\"\\n    >>> base64_decode(a) == b64decode(a)\\n    True\\n    >>> base64_decode(b) == b64decode(b)\\n    True\\n    >>> base64_decode(c) == b64decode(c)\\n    True\\n    >>> base64_decode(\\\"abc\\\")\\n    Traceback (most recent call last):\\n      ...\\n    AssertionError: Incorrect padding\\n    \\\"\\\"\\\"\\n    # Make sure encoded_data is either a string or a bytes-like object\\n    if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):\\n        raise TypeError(\\n            \\\"argument should be a bytes-like object or ASCII string, not \\\"\\n            f\\\"'{encoded_data.__class__.__name__}'\\\"\\n        )\\n\\n    # In case encoded_data is a bytes-like object, make sure it contains only\\n    # ASCII characters so we convert it to a string object\\n    if isinstance(encoded_data, bytes):\\n        try:\\n            encoded_data = encoded_data.decode(\\\"utf-8\\\")\\n        except UnicodeDecodeError:\\n            raise ValueError(\\\"base64 encoded data should only contain ASCII characters\\\")\\n\\n    padding = encoded_data.count(\\\"=\\\")\\n\\n    # Check if the encoded string contains non base64 characters\\n    if padding:\\n        assert all(\\n            char in B64_CHARSET for char in encoded_data[:-padding]\\n        ), \\\"Invalid base64 character(s) found.\\\"\\n    else:\\n        assert all(\\n            char in B64_CHARSET for char in encoded_data\\n        ), \\\"Invalid base64 character(s) found.\\\"\\n\\n    # Check the padding\\n    assert len(encoded_data) % 4 == 0 and padding < 3, \\\"Incorrect padding\\\"\\n\\n    if padding:\\n        # Remove padding if there is one\\n        encoded_data = encoded_data[:-padding]\\n\\n        binary_stream = \\\"\\\".join(\\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\\n        )[: -padding * 2]\\n    else:\\n        binary_stream = \\\"\\\".join(\\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\\n        )\\n\\n    data = [\\n        int(binary_stream[index : index + 8], 2)\\n        for index in range(0, len(binary_stream), 8)\\n    ]\\n\\n    return bytes(data)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "base85": "\"import base64\\n\\n\\ndef base85_encode(string: str) -> bytes:\\n    \\\"\\\"\\\"\\n    >>> base85_encode(\\\"\\\")\\n    b''\\n    >>> base85_encode(\\\"12345\\\")\\n    b'0etOA2#'\\n    >>> base85_encode(\\\"base 85\\\")\\n    b'@UX=h+?24'\\n    \\\"\\\"\\\"\\n    # encoded the input to a bytes-like object and then a85encode that\\n    return base64.a85encode(string.encode(\\\"utf-8\\\"))\\n\\n\\ndef base85_decode(a85encoded: bytes) -> str:\\n    \\\"\\\"\\\"\\n    >>> base85_decode(b\\\"\\\")\\n    ''\\n    >>> base85_decode(b\\\"0etOA2#\\\")\\n    '12345'\\n    >>> base85_decode(b\\\"@UX=h+?24\\\")\\n    'base 85'\\n    \\\"\\\"\\\"\\n    # a85decode the input into bytes and decode that into a human readable string\\n    return base64.a85decode(a85encoded).decode(\\\"utf-8\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "beaufort cipher": "\"\\\"\\\"\\\"\\nAuthor: Mohit Radadiya\\n\\\"\\\"\\\"\\n\\nfrom string import ascii_uppercase\\n\\ndict1 = {char: i for i, char in enumerate(ascii_uppercase)}\\ndict2 = {i: char for i, char in enumerate(ascii_uppercase)}\\n\\n\\n# This function generates the key in\\n# a cyclic manner until it's length isn't\\n# equal to the length of original text\\ndef generate_key(message: str, key: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> generate_key(\\\"THE GERMAN ATTACK\\\",\\\"SECRET\\\")\\n    'SECRETSECRETSECRE'\\n    \\\"\\\"\\\"\\n    x = len(message)\\n    i = 0\\n    while True:\\n        if x == i:\\n            i = 0\\n        if len(key) == len(message):\\n            break\\n        key += key[i]\\n        i += 1\\n    return key\\n\\n\\n# This function returns the encrypted text\\n# generated with the help of the key\\ndef cipher_text(message: str, key_new: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> cipher_text(\\\"THE GERMAN ATTACK\\\",\\\"SECRETSECRETSECRE\\\")\\n    'BDC PAYUWL JPAIYI'\\n    \\\"\\\"\\\"\\n    cipher_text = \\\"\\\"\\n    i = 0\\n    for letter in message:\\n        if letter == \\\" \\\":\\n            cipher_text += \\\" \\\"\\n        else:\\n            x = (dict1[letter] - dict1[key_new[i]]) % 26\\n            i += 1\\n            cipher_text += dict2[x]\\n    return cipher_text\\n\\n\\n# This function decrypts the encrypted text\\n# and returns the original text\\ndef original_text(cipher_text: str, key_new: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> original_text(\\\"BDC PAYUWL JPAIYI\\\",\\\"SECRETSECRETSECRE\\\")\\n    'THE GERMAN ATTACK'\\n    \\\"\\\"\\\"\\n    or_txt = \\\"\\\"\\n    i = 0\\n    for letter in cipher_text:\\n        if letter == \\\" \\\":\\n            or_txt += \\\" \\\"\\n        else:\\n            x = (dict1[letter] + dict1[key_new[i]] + 26) % 26\\n            i += 1\\n            or_txt += dict2[x]\\n    return or_txt\\n\\n\\ndef main() -> None:\\n    message = \\\"THE GERMAN ATTACK\\\"\\n    key = \\\"SECRET\\\"\\n    key_new = generate_key(message, key)\\n    s = cipher_text(message, key_new)\\n    print(f\\\"Encrypted Text = {s}\\\")\\n    print(f\\\"Original Text = {original_text(s, key_new)}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "bifid": "\"#!/usr/bin/env python3\\n\\n\\\"\\\"\\\"\\nThe Bifid Cipher uses a Polybius Square to encipher a message in a way that\\nmakes it fairly difficult to decipher without knowing the secret.\\n\\nhttps://www.braingle.com/brainteasers/codes/bifid.php\\n\\\"\\\"\\\"\\n\\nimport numpy as np\\n\\n\\nclass BifidCipher:\\n    def __init__(self) -> None:\\n        SQUARE = [\\n            [\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\"],\\n            [\\\"f\\\", \\\"g\\\", \\\"h\\\", \\\"i\\\", \\\"k\\\"],\\n            [\\\"l\\\", \\\"m\\\", \\\"n\\\", \\\"o\\\", \\\"p\\\"],\\n            [\\\"q\\\", \\\"r\\\", \\\"s\\\", \\\"t\\\", \\\"u\\\"],\\n            [\\\"v\\\", \\\"w\\\", \\\"x\\\", \\\"y\\\", \\\"z\\\"],\\n        ]\\n        self.SQUARE = np.array(SQUARE)\\n\\n    def letter_to_numbers(self, letter: str) -> np.ndarray:\\n        \\\"\\\"\\\"\\n        Return the pair of numbers that represents the given letter in the\\n        polybius square\\n\\n        >>> np.array_equal(BifidCipher().letter_to_numbers('a'), [1,1])\\n        True\\n\\n        >>> np.array_equal(BifidCipher().letter_to_numbers('u'), [4,5])\\n        True\\n        \\\"\\\"\\\"\\n        index1, index2 = np.where(self.SQUARE == letter)\\n        indexes = np.concatenate([index1 + 1, index2 + 1])\\n        return indexes\\n\\n    def numbers_to_letter(self, index1: int, index2: int) -> str:\\n        \\\"\\\"\\\"\\n        Return the letter corresponding to the position [index1, index2] in\\n        the polybius square\\n\\n        >>> BifidCipher().numbers_to_letter(4, 5) == \\\"u\\\"\\n        True\\n\\n        >>> BifidCipher().numbers_to_letter(1, 1) == \\\"a\\\"\\n        True\\n        \\\"\\\"\\\"\\n        letter = self.SQUARE[index1 - 1, index2 - 1]\\n        return letter\\n\\n    def encode(self, message: str) -> str:\\n        \\\"\\\"\\\"\\n        Return the encoded version of message according to the polybius cipher\\n\\n        >>> BifidCipher().encode('testmessage') == 'qtltbdxrxlk'\\n        True\\n\\n        >>> BifidCipher().encode('Test Message') == 'qtltbdxrxlk'\\n        True\\n\\n        >>> BifidCipher().encode('test j') == BifidCipher().encode('test i')\\n        True\\n        \\\"\\\"\\\"\\n        message = message.lower()\\n        message = message.replace(\\\" \\\", \\\"\\\")\\n        message = message.replace(\\\"j\\\", \\\"i\\\")\\n\\n        first_step = np.empty((2, len(message)))\\n        for letter_index in range(len(message)):\\n            numbers = self.letter_to_numbers(message[letter_index])\\n\\n            first_step[0, letter_index] = numbers[0]\\n            first_step[1, letter_index] = numbers[1]\\n\\n        second_step = first_step.reshape(2 * len(message))\\n        encoded_message = \\\"\\\"\\n        for numbers_index in range(len(message)):\\n            index1 = int(second_step[numbers_index * 2])\\n            index2 = int(second_step[(numbers_index * 2) + 1])\\n            letter = self.numbers_to_letter(index1, index2)\\n            encoded_message = encoded_message + letter\\n\\n        return encoded_message\\n\\n    def decode(self, message: str) -> str:\\n        \\\"\\\"\\\"\\n        Return the decoded version of message according to the polybius cipher\\n\\n        >>> BifidCipher().decode('qtltbdxrxlk') == 'testmessage'\\n        True\\n        \\\"\\\"\\\"\\n        message = message.lower()\\n        message.replace(\\\" \\\", \\\"\\\")\\n        first_step = np.empty(2 * len(message))\\n        for letter_index in range(len(message)):\\n            numbers = self.letter_to_numbers(message[letter_index])\\n            first_step[letter_index * 2] = numbers[0]\\n            first_step[letter_index * 2 + 1] = numbers[1]\\n\\n        second_step = first_step.reshape((2, len(message)))\\n        decoded_message = \\\"\\\"\\n        for numbers_index in range(len(message)):\\n            index1 = int(second_step[0, numbers_index])\\n            index2 = int(second_step[1, numbers_index])\\n            letter = self.numbers_to_letter(index1, index2)\\n            decoded_message = decoded_message + letter\\n\\n        return decoded_message\\n\"",
    "brute force caesar cipher": "\"def decrypt(message: str) -> None:\\n    \\\"\\\"\\\"\\n    >>> decrypt('TMDETUX PMDVU')\\n    Decryption using Key #0: TMDETUX PMDVU\\n    Decryption using Key #1: SLCDSTW OLCUT\\n    Decryption using Key #2: RKBCRSV NKBTS\\n    Decryption using Key #3: QJABQRU MJASR\\n    Decryption using Key #4: PIZAPQT LIZRQ\\n    Decryption using Key #5: OHYZOPS KHYQP\\n    Decryption using Key #6: NGXYNOR JGXPO\\n    Decryption using Key #7: MFWXMNQ IFWON\\n    Decryption using Key #8: LEVWLMP HEVNM\\n    Decryption using Key #9: KDUVKLO GDUML\\n    Decryption using Key #10: JCTUJKN FCTLK\\n    Decryption using Key #11: IBSTIJM EBSKJ\\n    Decryption using Key #12: HARSHIL DARJI\\n    Decryption using Key #13: GZQRGHK CZQIH\\n    Decryption using Key #14: FYPQFGJ BYPHG\\n    Decryption using Key #15: EXOPEFI AXOGF\\n    Decryption using Key #16: DWNODEH ZWNFE\\n    Decryption using Key #17: CVMNCDG YVMED\\n    Decryption using Key #18: BULMBCF XULDC\\n    Decryption using Key #19: ATKLABE WTKCB\\n    Decryption using Key #20: ZSJKZAD VSJBA\\n    Decryption using Key #21: YRIJYZC URIAZ\\n    Decryption using Key #22: XQHIXYB TQHZY\\n    Decryption using Key #23: WPGHWXA SPGYX\\n    Decryption using Key #24: VOFGVWZ ROFXW\\n    Decryption using Key #25: UNEFUVY QNEWV\\n    \\\"\\\"\\\"\\n    LETTERS = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\n    for key in range(len(LETTERS)):\\n        translated = \\\"\\\"\\n        for symbol in message:\\n            if symbol in LETTERS:\\n                num = LETTERS.find(symbol)\\n                num = num - key\\n                if num < 0:\\n                    num = num + len(LETTERS)\\n                translated = translated + LETTERS[num]\\n            else:\\n                translated = translated + symbol\\n        print(f\\\"Decryption using Key #{key}: {translated}\\\")\\n\\n\\ndef main() -> None:\\n    message = input(\\\"Encrypted message: \\\")\\n    message = message.upper()\\n    decrypt(message)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "caesar cipher": "\"from __future__ import annotations\\n\\nfrom string import ascii_letters\\n\\n\\ndef encrypt(input_string: str, key: int, alphabet: str | None = None) -> str:\\n    \\\"\\\"\\\"\\n    encrypt\\n    =======\\n    Encodes a given string with the caesar cipher and returns the encoded\\n    message\\n\\n    Parameters:\\n    -----------\\n    *   input_string: the plain-text that needs to be encoded\\n    *   key: the number of letters to shift the message by\\n\\n    Optional:\\n    *   alphabet (None): the alphabet used to encode the cipher, if not\\n        specified, the standard english alphabet with upper and lowercase\\n        letters is used\\n\\n    Returns:\\n    *   A string containing the encoded cipher-text\\n\\n    More on the caesar cipher\\n    =========================\\n    The caesar cipher is named after Julius Caesar who used it when sending\\n    secret military messages to his troops. This is a simple substitution cipher\\n    where very character in the plain-text is shifted by a certain number known\\n    as the \\\"key\\\" or \\\"shift\\\".\\n\\n    Example:\\n    Say we have the following message:\\n    \\\"Hello, captain\\\"\\n\\n    And our alphabet is made up of lower and uppercase letters:\\n    \\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\n\\n    And our shift is \\\"2\\\"\\n\\n    We can then encode the message, one letter at a time. \\\"H\\\" would become \\\"J\\\",\\n    since \\\"J\\\" is two letters away, and so on. If the shift is ever two large, or\\n    our letter is at the end of the alphabet, we just start at the beginning\\n    (\\\"Z\\\" would shift to \\\"a\\\" then \\\"b\\\" and so on).\\n\\n    Our final message would be \\\"Jgnnq, ecrvckp\\\"\\n\\n    Further reading\\n    ===============\\n    *   https://en.m.wikipedia.org/wiki/Caesar_cipher\\n\\n    Doctests\\n    ========\\n    >>> encrypt('The quick brown fox jumps over the lazy dog', 8)\\n    'bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo'\\n\\n    >>> encrypt('A very large key', 8000)\\n    's nWjq dSjYW cWq'\\n\\n    >>> encrypt('a lowercase alphabet', 5, 'abcdefghijklmnopqrstuvwxyz')\\n    'f qtbjwhfxj fqumfgjy'\\n    \\\"\\\"\\\"\\n    # Set default alphabet to lower and upper case english chars\\n    alpha = alphabet or ascii_letters\\n\\n    # The final result string\\n    result = \\\"\\\"\\n\\n    for character in input_string:\\n        if character not in alpha:\\n            # Append without encryption if character is not in the alphabet\\n            result += character\\n        else:\\n            # Get the index of the new key and make sure it isn't too large\\n            new_key = (alpha.index(character) + key) % len(alpha)\\n\\n            # Append the encoded character to the alphabet\\n            result += alpha[new_key]\\n\\n    return result\\n\\n\\ndef decrypt(input_string: str, key: int, alphabet: str | None = None) -> str:\\n    \\\"\\\"\\\"\\n    decrypt\\n    =======\\n    Decodes a given string of cipher-text and returns the decoded plain-text\\n\\n    Parameters:\\n    -----------\\n    *   input_string: the cipher-text that needs to be decoded\\n    *   key: the number of letters to shift the message backwards by to decode\\n\\n    Optional:\\n    *   alphabet (None): the alphabet used to decode the cipher, if not\\n        specified, the standard english alphabet with upper and lowercase\\n        letters is used\\n\\n    Returns:\\n    *   A string containing the decoded plain-text\\n\\n    More on the caesar cipher\\n    =========================\\n    The caesar cipher is named after Julius Caesar who used it when sending\\n    secret military messages to his troops. This is a simple substitution cipher\\n    where very character in the plain-text is shifted by a certain number known\\n    as the \\\"key\\\" or \\\"shift\\\". Please keep in mind, here we will be focused on\\n    decryption.\\n\\n    Example:\\n    Say we have the following cipher-text:\\n    \\\"Jgnnq, ecrvckp\\\"\\n\\n    And our alphabet is made up of lower and uppercase letters:\\n    \\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\n\\n    And our shift is \\\"2\\\"\\n\\n    To decode the message, we would do the same thing as encoding, but in\\n    reverse. The first letter, \\\"J\\\" would become \\\"H\\\" (remember: we are decoding)\\n    because \\\"H\\\" is two letters in reverse (to the left) of \\\"J\\\". We would\\n    continue doing this. A letter like \\\"a\\\" would shift back to the end of\\n    the alphabet, and would become \\\"Z\\\" or \\\"Y\\\" and so on.\\n\\n    Our final message would be \\\"Hello, captain\\\"\\n\\n    Further reading\\n    ===============\\n    *   https://en.m.wikipedia.org/wiki/Caesar_cipher\\n\\n    Doctests\\n    ========\\n    >>> decrypt('bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo', 8)\\n    'The quick brown fox jumps over the lazy dog'\\n\\n    >>> decrypt('s nWjq dSjYW cWq', 8000)\\n    'A very large key'\\n\\n    >>> decrypt('f qtbjwhfxj fqumfgjy', 5, 'abcdefghijklmnopqrstuvwxyz')\\n    'a lowercase alphabet'\\n    \\\"\\\"\\\"\\n    # Turn on decode mode by making the key negative\\n    key *= -1\\n\\n    return encrypt(input_string, key, alphabet)\\n\\n\\ndef brute_force(input_string: str, alphabet: str | None = None) -> dict[int, str]:\\n    \\\"\\\"\\\"\\n    brute_force\\n    ===========\\n    Returns all the possible combinations of keys and the decoded strings in the\\n    form of a dictionary\\n\\n    Parameters:\\n    -----------\\n    *   input_string: the cipher-text that needs to be used during brute-force\\n\\n    Optional:\\n    *   alphabet:  (None): the alphabet used to decode the cipher, if not\\n        specified, the standard english alphabet with upper and lowercase\\n        letters is used\\n\\n    More about brute force\\n    ======================\\n    Brute force is when a person intercepts a message or password, not knowing\\n    the key and tries every single combination. This is easy with the caesar\\n    cipher since there are only all the letters in the alphabet. The more\\n    complex the cipher, the larger amount of time it will take to do brute force\\n\\n    Ex:\\n    Say we have a 5 letter alphabet (abcde), for simplicity and we intercepted the\\n    following message:\\n\\n    \\\"dbc\\\"\\n\\n    we could then just write out every combination:\\n    ecd... and so on, until we reach a combination that makes sense:\\n    \\\"cab\\\"\\n\\n    Further reading\\n    ===============\\n    *   https://en.wikipedia.org/wiki/Brute_force\\n\\n    Doctests\\n    ========\\n    >>> brute_force(\\\"jFyuMy xIH'N vLONy zILwy Gy!\\\")[20]\\n    \\\"Please don't brute force me!\\\"\\n\\n    >>> brute_force(1)\\n    Traceback (most recent call last):\\n    TypeError: 'int' object is not iterable\\n    \\\"\\\"\\\"\\n    # Set default alphabet to lower and upper case english chars\\n    alpha = alphabet or ascii_letters\\n\\n    # To store data on all the combinations\\n    brute_force_data = {}\\n\\n    # Cycle through each combination\\n    for key in range(1, len(alpha) + 1):\\n        # Decrypt the message and store the result in the data\\n        brute_force_data[key] = decrypt(input_string, key, alpha)\\n\\n    return brute_force_data\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    while True:\\n        print(f'\\\\n{\\\"-\\\" * 10}\\\\n Menu\\\\n{\\\"-\\\" * 10}')\\n        print(*[\\\"1.Encrypt\\\", \\\"2.Decrypt\\\", \\\"3.BruteForce\\\", \\\"4.Quit\\\"], sep=\\\"\\\\n\\\")\\n\\n        # get user input\\n        choice = input(\\\"\\\\nWhat would you like to do?: \\\").strip() or \\\"4\\\"\\n\\n        # run functions based on what the user chose\\n        if choice not in (\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\"):\\n            print(\\\"Invalid choice, please enter a valid choice\\\")\\n        elif choice == \\\"1\\\":\\n            input_string = input(\\\"Please enter the string to be encrypted: \\\")\\n            key = int(input(\\\"Please enter off-set: \\\").strip())\\n\\n            print(encrypt(input_string, key))\\n        elif choice == \\\"2\\\":\\n            input_string = input(\\\"Please enter the string to be decrypted: \\\")\\n            key = int(input(\\\"Please enter off-set: \\\").strip())\\n\\n            print(decrypt(input_string, key))\\n        elif choice == \\\"3\\\":\\n            input_string = input(\\\"Please enter the string to be decrypted: \\\")\\n            brute_force_data = brute_force(input_string)\\n\\n            for key, value in brute_force_data.items():\\n                print(f\\\"Key: {key} | Message: {value}\\\")\\n\\n        elif choice == \\\"4\\\":\\n            print(\\\"Goodbye.\\\")\\n            break\\n\"",
    "cryptomath module": "\"def gcd(a: int, b: int) -> int:\\n    while a != 0:\\n        a, b = b % a, a\\n    return b\\n\\n\\ndef find_mod_inverse(a: int, m: int) -> int:\\n    if gcd(a, m) != 1:\\n        raise ValueError(f\\\"mod inverse of {a!r} and {m!r} does not exist\\\")\\n    u1, u2, u3 = 1, 0, a\\n    v1, v2, v3 = 0, 1, m\\n    while v3 != 0:\\n        q = u3 // v3\\n        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3\\n    return u1 % m\\n\"",
    "decrypt caesar with chi squared": "\"#!/usr/bin/env python3\\nfrom __future__ import annotations\\n\\n\\ndef decrypt_caesar_with_chi_squared(\\n    ciphertext: str,\\n    cipher_alphabet: list[str] | None = None,\\n    frequencies_dict: dict[str, float] | None = None,\\n    case_sensitive: bool = False,\\n) -> tuple[int, float, str]:\\n    \\\"\\\"\\\"\\n    Basic Usage\\n    ===========\\n    Arguments:\\n    * ciphertext (str): the text to decode (encoded with the caesar cipher)\\n\\n    Optional Arguments:\\n    * cipher_alphabet (list): the alphabet used for the cipher (each letter is\\n      a string separated by commas)\\n    * frequencies_dict (dict): a dictionary of word frequencies where keys are\\n      the letters and values are a percentage representation of the frequency as\\n      a decimal/float\\n    * case_sensitive (bool): a boolean value: True if the case matters during\\n      decryption, False if it doesn't\\n\\n    Returns:\\n    * A tuple in the form of:\\n      (\\n        most_likely_cipher,\\n        most_likely_cipher_chi_squared_value,\\n        decoded_most_likely_cipher\\n      )\\n\\n      where...\\n      - most_likely_cipher is an integer representing the shift of the smallest\\n        chi-squared statistic (most likely key)\\n      - most_likely_cipher_chi_squared_value is a float representing the\\n        chi-squared statistic of the most likely shift\\n      - decoded_most_likely_cipher is a string with the decoded cipher\\n        (decoded by the most_likely_cipher key)\\n\\n\\n    The Chi-squared test\\n    ====================\\n\\n    The caesar cipher\\n    -----------------\\n    The caesar cipher is a very insecure encryption algorithm, however it has\\n    been used since Julius Caesar. The cipher is a simple substitution cipher\\n    where each character in the plain text is replaced by a character in the\\n    alphabet a certain number of characters after the original character. The\\n    number of characters away is called the shift or key. For example:\\n\\n    Plain text: hello\\n    Key: 1\\n    Cipher text: ifmmp\\n    (each letter in hello has been shifted one to the right in the eng. alphabet)\\n\\n    As you can imagine, this doesn't provide lots of security. In fact\\n    decrypting ciphertext by brute-force is extremely easy even by hand. However\\n     one way to do that is the chi-squared test.\\n\\n    The chi-squared test\\n    -------------------\\n    Each letter in the english alphabet has a frequency, or the amount of times\\n    it shows up compared to other letters (usually expressed as a decimal\\n    representing the percentage likelihood). The most common letter in the\\n    english language is \\\"e\\\" with a frequency of 0.11162 or 11.162%. The test is\\n    completed in the following fashion.\\n\\n    1. The ciphertext is decoded in a brute force way (every combination of the\\n       26 possible combinations)\\n    2. For every combination, for each letter in the combination, the average\\n       amount of times the letter should appear the message is calculated by\\n       multiplying the total number of characters by the frequency of the letter\\n\\n       For example:\\n       In a message of 100 characters, e should appear around 11.162 times.\\n\\n     3. Then, to calculate the margin of error (the amount of times the letter\\n        SHOULD appear with the amount of times the letter DOES appear), we use\\n        the chi-squared test. The following formula is used:\\n\\n        Let:\\n        - n be the number of times the letter actually appears\\n        - p be the predicted value of the number of times the letter should\\n          appear (see #2)\\n        - let v be the chi-squared test result (referred to here as chi-squared\\n          value/statistic)\\n\\n        (n - p)^2\\n        --------- = v\\n           p\\n\\n    4. Each chi squared value for each letter is then added up to the total.\\n       The total is the chi-squared statistic for that encryption key.\\n    5. The encryption key with the lowest chi-squared value is the most likely\\n       to be the decoded answer.\\n\\n    Further Reading\\n    ================\\n\\n    * http://practicalcryptography.com/cryptanalysis/text-characterisation/chi-squared-\\n        statistic/\\n    * https://en.wikipedia.org/wiki/Letter_frequency\\n    * https://en.wikipedia.org/wiki/Chi-squared_test\\n    * https://en.m.wikipedia.org/wiki/Caesar_cipher\\n\\n    Doctests\\n    ========\\n    >>> decrypt_caesar_with_chi_squared(\\n    ...    'dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!'\\n    ... )  # doctest: +NORMALIZE_WHITESPACE\\n    (7, 3129.228005747531,\\n     'why is the caesar cipher so popular? it is too easy to crack!')\\n\\n    >>> decrypt_caesar_with_chi_squared('crybd cdbsxq')\\n    (10, 233.35343938980898, 'short string')\\n\\n    >>> decrypt_caesar_with_chi_squared('Crybd Cdbsxq', case_sensitive=True)\\n    (10, 233.35343938980898, 'Short String')\\n\\n    >>> decrypt_caesar_with_chi_squared(12)\\n    Traceback (most recent call last):\\n    AttributeError: 'int' object has no attribute 'lower'\\n    \\\"\\\"\\\"\\n    alphabet_letters = cipher_alphabet or [chr(i) for i in range(97, 123)]\\n\\n    # If the argument is None or the user provided an empty dictionary\\n    if not frequencies_dict:\\n        # Frequencies of letters in the english language (how much they show up)\\n        frequencies = {\\n            \\\"a\\\": 0.08497,\\n            \\\"b\\\": 0.01492,\\n            \\\"c\\\": 0.02202,\\n            \\\"d\\\": 0.04253,\\n            \\\"e\\\": 0.11162,\\n            \\\"f\\\": 0.02228,\\n            \\\"g\\\": 0.02015,\\n            \\\"h\\\": 0.06094,\\n            \\\"i\\\": 0.07546,\\n            \\\"j\\\": 0.00153,\\n            \\\"k\\\": 0.01292,\\n            \\\"l\\\": 0.04025,\\n            \\\"m\\\": 0.02406,\\n            \\\"n\\\": 0.06749,\\n            \\\"o\\\": 0.07507,\\n            \\\"p\\\": 0.01929,\\n            \\\"q\\\": 0.00095,\\n            \\\"r\\\": 0.07587,\\n            \\\"s\\\": 0.06327,\\n            \\\"t\\\": 0.09356,\\n            \\\"u\\\": 0.02758,\\n            \\\"v\\\": 0.00978,\\n            \\\"w\\\": 0.02560,\\n            \\\"x\\\": 0.00150,\\n            \\\"y\\\": 0.01994,\\n            \\\"z\\\": 0.00077,\\n        }\\n    else:\\n        # Custom frequencies dictionary\\n        frequencies = frequencies_dict\\n\\n    if not case_sensitive:\\n        ciphertext = ciphertext.lower()\\n\\n    # Chi squared statistic values\\n    chi_squared_statistic_values: dict[int, tuple[float, str]] = {}\\n\\n    # cycle through all of the shifts\\n    for shift in range(len(alphabet_letters)):\\n        decrypted_with_shift = \\\"\\\"\\n\\n        # decrypt the message with the shift\\n        for letter in ciphertext:\\n            try:\\n                # Try to index the letter in the alphabet\\n                new_key = (alphabet_letters.index(letter.lower()) - shift) % len(\\n                    alphabet_letters\\n                )\\n                decrypted_with_shift += (\\n                    alphabet_letters[new_key].upper()\\n                    if case_sensitive and letter.isupper()\\n                    else alphabet_letters[new_key]\\n                )\\n            except ValueError:\\n                # Append the character if it isn't in the alphabet\\n                decrypted_with_shift += letter\\n\\n        chi_squared_statistic = 0.0\\n\\n        # Loop through each letter in the decoded message with the shift\\n        for letter in decrypted_with_shift:\\n            if case_sensitive:\\n                letter = letter.lower()\\n                if letter in frequencies:\\n                    # Get the amount of times the letter occurs in the message\\n                    occurrences = decrypted_with_shift.lower().count(letter)\\n\\n                    # Get the excepcted amount of times the letter should appear based\\n                    # on letter frequencies\\n                    expected = frequencies[letter] * occurrences\\n\\n                    # Complete the chi squared statistic formula\\n                    chi_letter_value = ((occurrences - expected) ** 2) / expected\\n\\n                    # Add the margin of error to the total chi squared statistic\\n                    chi_squared_statistic += chi_letter_value\\n            else:\\n                if letter.lower() in frequencies:\\n                    # Get the amount of times the letter occurs in the message\\n                    occurrences = decrypted_with_shift.count(letter)\\n\\n                    # Get the excepcted amount of times the letter should appear based\\n                    # on letter frequencies\\n                    expected = frequencies[letter] * occurrences\\n\\n                    # Complete the chi squared statistic formula\\n                    chi_letter_value = ((occurrences - expected) ** 2) / expected\\n\\n                    # Add the margin of error to the total chi squared statistic\\n                    chi_squared_statistic += chi_letter_value\\n\\n        # Add the data to the chi_squared_statistic_values dictionary\\n        chi_squared_statistic_values[shift] = (\\n            chi_squared_statistic,\\n            decrypted_with_shift,\\n        )\\n\\n    # Get the most likely cipher by finding the cipher with the smallest chi squared\\n    # statistic\\n    def chi_squared_statistic_values_sorting_key(key: int) -> tuple[float, str]:\\n        return chi_squared_statistic_values[key]\\n\\n    most_likely_cipher: int = min(\\n        chi_squared_statistic_values,\\n        key=chi_squared_statistic_values_sorting_key,\\n    )\\n\\n    # Get all the data from the most likely cipher (key, decoded message)\\n    (\\n        most_likely_cipher_chi_squared_value,\\n        decoded_most_likely_cipher,\\n    ) = chi_squared_statistic_values[most_likely_cipher]\\n\\n    # Return the data on the most likely shift\\n    return (\\n        most_likely_cipher,\\n        most_likely_cipher_chi_squared_value,\\n        decoded_most_likely_cipher,\\n    )\\n\"",
    "deterministic miller rabin": "\"\\\"\\\"\\\"Created by Nathan Damon, @bizzfitch on github\\n>>> test_miller_rabin()\\n\\\"\\\"\\\"\\n\\n\\ndef miller_rabin(n: int, allow_probable: bool = False) -> bool:\\n    \\\"\\\"\\\"Deterministic Miller-Rabin algorithm for primes ~< 3.32e24.\\n\\n    Uses numerical analysis results to return whether or not the passed number\\n    is prime. If the passed number is above the upper limit, and\\n    allow_probable is True, then a return value of True indicates that n is\\n    probably prime. This test does not allow False negatives- a return value\\n    of False is ALWAYS composite.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The integer to be tested. Since we usually care if a number is prime,\\n        n < 2 returns False instead of raising a ValueError.\\n    allow_probable: bool, default False\\n        Whether or not to test n above the upper bound of the deterministic test.\\n\\n    Raises\\n    ------\\n    ValueError\\n\\n    Reference\\n    ---------\\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\\n    \\\"\\\"\\\"\\n    if n == 2:\\n        return True\\n    if not n % 2 or n < 2:\\n        return False\\n    if n > 5 and n % 10 not in (1, 3, 7, 9):  # can quickly check last digit\\n        return False\\n    if n > 3_317_044_064_679_887_385_961_981 and not allow_probable:\\n        raise ValueError(\\n            \\\"Warning: upper bound of deterministic test is exceeded. \\\"\\n            \\\"Pass allow_probable=True to allow probabilistic test. \\\"\\n            \\\"A return value of True indicates a probable prime.\\\"\\n        )\\n    # array bounds provided by analysis\\n    bounds = [\\n        2_047,\\n        1_373_653,\\n        25_326_001,\\n        3_215_031_751,\\n        2_152_302_898_747,\\n        3_474_749_660_383,\\n        341_550_071_728_321,\\n        1,\\n        3_825_123_056_546_413_051,\\n        1,\\n        1,\\n        318_665_857_834_031_151_167_461,\\n        3_317_044_064_679_887_385_961_981,\\n    ]\\n\\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\\n    for idx, _p in enumerate(bounds, 1):\\n        if n < _p:\\n            # then we have our last prime to check\\n            plist = primes[:idx]\\n            break\\n    d, s = n - 1, 0\\n    # break up n -1 into a power of 2 (s) and\\n    # remaining odd component\\n    # essentially, solve for d * 2 ** s == n - 1\\n    while d % 2 == 0:\\n        d //= 2\\n        s += 1\\n    for prime in plist:\\n        pr = False\\n        for r in range(s):\\n            m = pow(prime, d * 2 ** r, n)\\n            # see article for analysis explanation for m\\n            if (r == 0 and m == 1) or ((m + 1) % n == 0):\\n                pr = True\\n                # this loop will not determine compositeness\\n                break\\n        if pr:\\n            continue\\n        # if pr is False, then the above loop never evaluated to true,\\n        # and the n MUST be composite\\n        return False\\n    return True\\n\\n\\ndef test_miller_rabin() -> None:\\n    \\\"\\\"\\\"Testing a nontrivial (ends in 1, 3, 7, 9) composite\\n    and a prime in each range.\\n    \\\"\\\"\\\"\\n    assert not miller_rabin(561)\\n    assert miller_rabin(563)\\n    # 2047\\n\\n    assert not miller_rabin(838_201)\\n    assert miller_rabin(838_207)\\n    # 1_373_653\\n\\n    assert not miller_rabin(17_316_001)\\n    assert miller_rabin(17_316_017)\\n    # 25_326_001\\n\\n    assert not miller_rabin(3_078_386_641)\\n    assert miller_rabin(3_078_386_653)\\n    # 3_215_031_751\\n\\n    assert not miller_rabin(1_713_045_574_801)\\n    assert miller_rabin(1_713_045_574_819)\\n    # 2_152_302_898_747\\n\\n    assert not miller_rabin(2_779_799_728_307)\\n    assert miller_rabin(2_779_799_728_327)\\n    # 3_474_749_660_383\\n\\n    assert not miller_rabin(113_850_023_909_441)\\n    assert miller_rabin(113_850_023_909_527)\\n    # 341_550_071_728_321\\n\\n    assert not miller_rabin(1_275_041_018_848_804_351)\\n    assert miller_rabin(1_275_041_018_848_804_391)\\n    # 3_825_123_056_546_413_051\\n\\n    assert not miller_rabin(79_666_464_458_507_787_791_867)\\n    assert miller_rabin(79_666_464_458_507_787_791_951)\\n    # 318_665_857_834_031_151_167_461\\n\\n    assert not miller_rabin(552_840_677_446_647_897_660_333)\\n    assert miller_rabin(552_840_677_446_647_897_660_359)\\n    # 3_317_044_064_679_887_385_961_981\\n    # upper limit for probabilistic test\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    test_miller_rabin()\\n\"",
    "diffie": "\"from __future__ import annotations\\r\\n\\r\\n\\r\\ndef find_primitive(n: int) -> int | None:\\r\\n    for r in range(1, n):\\r\\n        li = []\\r\\n        for x in range(n - 1):\\r\\n            val = pow(r, x, n)\\r\\n            if val in li:\\r\\n                break\\r\\n            li.append(val)\\r\\n        else:\\r\\n            return r\\r\\n    return None\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    q = int(input(\\\"Enter a prime number q: \\\"))\\r\\n    a = find_primitive(q)\\r\\n    if a is None:\\r\\n        print(f\\\"Cannot find the primitive for the value: {a!r}\\\")\\r\\n    else:\\r\\n        a_private = int(input(\\\"Enter private key of A: \\\"))\\r\\n        a_public = pow(a, a_private, q)\\r\\n        b_private = int(input(\\\"Enter private key of B: \\\"))\\r\\n        b_public = pow(a, b_private, q)\\r\\n\\r\\n        a_secret = pow(b_public, a_private, q)\\r\\n        b_secret = pow(a_public, b_private, q)\\r\\n\\r\\n        print(\\\"The key value generated by A is: \\\", a_secret)\\r\\n        print(\\\"The key value generated by B is: \\\", b_secret)\\r\\n\"",
    "diffie hellman": "\"from binascii import hexlify\\nfrom hashlib import sha256\\nfrom os import urandom\\n\\n# RFC 3526 - More Modular Exponential (MODP) Diffie-Hellman groups for\\n# Internet Key Exchange (IKE) https://tools.ietf.org/html/rfc3526\\n\\nprimes = {\\n    # 1536-bit\\n    5: {\\n        \\\"prime\\\": int(\\n            \\\"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\\\"\\n            + \\\"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\\\"\\n            + \\\"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\\\"\\n            + \\\"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\\\"\\n            + \\\"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\\\"\\n            + \\\"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\\\"\\n            + \\\"83655D23DCA3AD961C62F356208552BB9ED529077096966D\\\"\\n            + \\\"670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF\\\",\\n            base=16,\\n        ),\\n        \\\"generator\\\": 2,\\n    },\\n    # 2048-bit\\n    14: {\\n        \\\"prime\\\": int(\\n            \\\"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\\\"\\n            + \\\"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\\\"\\n            + \\\"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\\\"\\n            + \\\"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\\\"\\n            + \\\"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\\\"\\n            + \\\"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\\\"\\n            + \\\"83655D23DCA3AD961C62F356208552BB9ED529077096966D\\\"\\n            + \\\"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B\\\"\\n            + \\\"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9\\\"\\n            + \\\"DE2BCBF6955817183995497CEA956AE515D2261898FA0510\\\"\\n            + \\\"15728E5A8AACAA68FFFFFFFFFFFFFFFF\\\",\\n            base=16,\\n        ),\\n        \\\"generator\\\": 2,\\n    },\\n    # 3072-bit\\n    15: {\\n        \\\"prime\\\": int(\\n            \\\"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\\\"\\n            + \\\"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\\\"\\n            + \\\"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\\\"\\n            + \\\"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\\\"\\n            + \\\"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\\\"\\n            + \\\"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\\\"\\n            + \\\"83655D23DCA3AD961C62F356208552BB9ED529077096966D\\\"\\n            + \\\"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B\\\"\\n            + \\\"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9\\\"\\n            + \\\"DE2BCBF6955817183995497CEA956AE515D2261898FA0510\\\"\\n            + \\\"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64\\\"\\n            + \\\"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7\\\"\\n            + \\\"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B\\\"\\n            + \\\"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C\\\"\\n            + \\\"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31\\\"\\n            + \\\"43DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF\\\",\\n            base=16,\\n        ),\\n        \\\"generator\\\": 2,\\n    },\\n    # 4096-bit\\n    16: {\\n        \\\"prime\\\": int(\\n            \\\"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\\\"\\n            + \\\"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\\\"\\n            + \\\"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\\\"\\n            + \\\"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\\\"\\n            + \\\"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\\\"\\n            + \\\"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\\\"\\n            + \\\"83655D23DCA3AD961C62F356208552BB9ED529077096966D\\\"\\n            + \\\"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B\\\"\\n            + \\\"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9\\\"\\n            + \\\"DE2BCBF6955817183995497CEA956AE515D2261898FA0510\\\"\\n            + \\\"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64\\\"\\n            + \\\"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7\\\"\\n            + \\\"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B\\\"\\n            + \\\"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C\\\"\\n            + \\\"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31\\\"\\n            + \\\"43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7\\\"\\n            + \\\"88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA\\\"\\n            + \\\"2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6\\\"\\n            + \\\"287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED\\\"\\n            + \\\"1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9\\\"\\n            + \\\"93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199\\\"\\n            + \\\"FFFFFFFFFFFFFFFF\\\",\\n            base=16,\\n        ),\\n        \\\"generator\\\": 2,\\n    },\\n    # 6144-bit\\n    17: {\\n        \\\"prime\\\": int(\\n            \\\"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08\\\"\\n            + \\\"8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B\\\"\\n            + \\\"302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9\\\"\\n            + \\\"A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6\\\"\\n            + \\\"49286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8\\\"\\n            + \\\"FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D\\\"\\n            + \\\"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C\\\"\\n            + \\\"180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718\\\"\\n            + \\\"3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D\\\"\\n            + \\\"04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7D\\\"\\n            + \\\"B3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D226\\\"\\n            + \\\"1AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200C\\\"\\n            + \\\"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFC\\\"\\n            + \\\"E0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B26\\\"\\n            + \\\"99C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB\\\"\\n            + \\\"04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2\\\"\\n            + \\\"233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127\\\"\\n            + \\\"D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492\\\"\\n            + \\\"36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406\\\"\\n            + \\\"AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918\\\"\\n            + \\\"DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B33205151\\\"\\n            + \\\"2BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03\\\"\\n            + \\\"F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97F\\\"\\n            + \\\"BEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA\\\"\\n            + \\\"CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58B\\\"\\n            + \\\"B7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632\\\"\\n            + \\\"387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E\\\"\\n            + \\\"6DCC4024FFFFFFFFFFFFFFFF\\\",\\n            base=16,\\n        ),\\n        \\\"generator\\\": 2,\\n    },\\n    # 8192-bit\\n    18: {\\n        \\\"prime\\\": int(\\n            \\\"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\\\"\\n            + \\\"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\\\"\\n            + \\\"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\\\"\\n            + \\\"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\\\"\\n            + \\\"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\\\"\\n            + \\\"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\\\"\\n            + \\\"83655D23DCA3AD961C62F356208552BB9ED529077096966D\\\"\\n            + \\\"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B\\\"\\n            + \\\"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9\\\"\\n            + \\\"DE2BCBF6955817183995497CEA956AE515D2261898FA0510\\\"\\n            + \\\"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64\\\"\\n            + \\\"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7\\\"\\n            + \\\"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B\\\"\\n            + \\\"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C\\\"\\n            + \\\"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31\\\"\\n            + \\\"43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7\\\"\\n            + \\\"88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA\\\"\\n            + \\\"2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6\\\"\\n            + \\\"287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED\\\"\\n            + \\\"1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9\\\"\\n            + \\\"93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492\\\"\\n            + \\\"36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BD\\\"\\n            + \\\"F8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831\\\"\\n            + \\\"179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1B\\\"\\n            + \\\"DB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF\\\"\\n            + \\\"5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6\\\"\\n            + \\\"D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F3\\\"\\n            + \\\"23A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA\\\"\\n            + \\\"CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE328\\\"\\n            + \\\"06A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55C\\\"\\n            + \\\"DA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE\\\"\\n            + \\\"12BF2D5B0B7474D6E694F91E6DBE115974A3926F12FEE5E4\\\"\\n            + \\\"38777CB6A932DF8CD8BEC4D073B931BA3BC832B68D9DD300\\\"\\n            + \\\"741FA7BF8AFC47ED2576F6936BA424663AAB639C5AE4F568\\\"\\n            + \\\"3423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD9\\\"\\n            + \\\"22222E04A4037C0713EB57A81A23F0C73473FC646CEA306B\\\"\\n            + \\\"4BCBC8862F8385DDFA9D4B7FA2C087E879683303ED5BDD3A\\\"\\n            + \\\"062B3CF5B3A278A66D2A13F83F44F82DDF310EE074AB6A36\\\"\\n            + \\\"4597E899A0255DC164F31CC50846851DF9AB48195DED7EA1\\\"\\n            + \\\"B1D510BD7EE74D73FAF36BC31ECFA268359046F4EB879F92\\\"\\n            + \\\"4009438B481C6CD7889A002ED5EE382BC9190DA6FC026E47\\\"\\n            + \\\"9558E4475677E9AA9E3050E2765694DFC81F56E880B96E71\\\"\\n            + \\\"60C980DD98EDD3DFFFFFFFFFFFFFFFFF\\\",\\n            base=16,\\n        ),\\n        \\\"generator\\\": 2,\\n    },\\n}\\n\\n\\nclass DiffieHellman:\\n    \\\"\\\"\\\"\\n    Class to represent the Diffie-Hellman key exchange protocol\\n\\n\\n    >>> alice = DiffieHellman()\\n    >>> bob = DiffieHellman()\\n\\n    >>> alice_private = alice.get_private_key()\\n    >>> alice_public = alice.generate_public_key()\\n\\n    >>> bob_private = bob.get_private_key()\\n    >>> bob_public = bob.generate_public_key()\\n\\n    >>> # generating shared key using the DH object\\n    >>> alice_shared = alice.generate_shared_key(bob_public)\\n    >>> bob_shared = bob.generate_shared_key(alice_public)\\n\\n    >>> assert alice_shared == bob_shared\\n\\n    >>> # generating shared key using static methods\\n    >>> alice_shared = DiffieHellman.generate_shared_key_static(\\n    ...     alice_private, bob_public\\n    ... )\\n    >>> bob_shared = DiffieHellman.generate_shared_key_static(\\n    ...     bob_private, alice_public\\n    ... )\\n\\n    >>> assert alice_shared == bob_shared\\n    \\\"\\\"\\\"\\n\\n    # Current minimum recommendation is 2048 bit (group 14)\\n    def __init__(self, group: int = 14) -> None:\\n        if group not in primes:\\n            raise ValueError(\\\"Unsupported Group\\\")\\n        self.prime = primes[group][\\\"prime\\\"]\\n        self.generator = primes[group][\\\"generator\\\"]\\n\\n        self.__private_key = int(hexlify(urandom(32)), base=16)\\n\\n    def get_private_key(self) -> str:\\n        return hex(self.__private_key)[2:]\\n\\n    def generate_public_key(self) -> str:\\n        public_key = pow(self.generator, self.__private_key, self.prime)\\n        return hex(public_key)[2:]\\n\\n    def is_valid_public_key(self, key: int) -> bool:\\n        # check if the other public key is valid based on NIST SP800-56\\n        if 2 <= key and key <= self.prime - 2:\\n            if pow(key, (self.prime - 1) // 2, self.prime) == 1:\\n                return True\\n        return False\\n\\n    def generate_shared_key(self, other_key_str: str) -> str:\\n        other_key = int(other_key_str, base=16)\\n        if not self.is_valid_public_key(other_key):\\n            raise ValueError(\\\"Invalid public key\\\")\\n        shared_key = pow(other_key, self.__private_key, self.prime)\\n        return sha256(str(shared_key).encode()).hexdigest()\\n\\n    @staticmethod\\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\\n        # check if the other public key is valid based on NIST SP800-56\\n        if 2 <= remote_public_key_str and remote_public_key_str <= prime - 2:\\n            if pow(remote_public_key_str, (prime - 1) // 2, prime) == 1:\\n                return True\\n        return False\\n\\n    @staticmethod\\n    def generate_shared_key_static(\\n        local_private_key_str: str, remote_public_key_str: str, group: int = 14\\n    ) -> str:\\n        local_private_key = int(local_private_key_str, base=16)\\n        remote_public_key = int(remote_public_key_str, base=16)\\n        prime = primes[group][\\\"prime\\\"]\\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\\n            raise ValueError(\\\"Invalid public key\\\")\\n        shared_key = pow(remote_public_key, local_private_key, prime)\\n        return sha256(str(shared_key).encode()).hexdigest()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "elgamal key generator": "\"import os\\nimport random\\nimport sys\\n\\nfrom . import cryptomath_module as cryptomath\\nfrom . import rabin_miller\\n\\nmin_primitive_root = 3\\n\\n\\n# I have written my code naively same as definition of primitive root\\n# however every time I run this program, memory exceeded...\\n# so I used 4.80 Algorithm in\\n# Handbook of Applied Cryptography(CRC Press, ISBN : 0-8493-8523-7, October 1996)\\n# and it seems to run nicely!\\ndef primitive_root(p_val: int) -> int:\\n    print(\\\"Generating primitive root of p\\\")\\n    while True:\\n        g = random.randrange(3, p_val)\\n        if pow(g, 2, p_val) == 1:\\n            continue\\n        if pow(g, p_val, p_val) == 1:\\n            continue\\n        return g\\n\\n\\ndef generate_key(key_size: int) -> tuple[tuple[int, int, int, int], tuple[int, int]]:\\n    print(\\\"Generating prime p...\\\")\\n    p = rabin_miller.generateLargePrime(key_size)  # select large prime number.\\n    e_1 = primitive_root(p)  # one primitive root on modulo p.\\n    d = random.randrange(3, p)  # private_key -> have to be greater than 2 for safety.\\n    e_2 = cryptomath.find_mod_inverse(pow(e_1, d, p), p)\\n\\n    public_key = (key_size, e_1, e_2, p)\\n    private_key = (key_size, d)\\n\\n    return public_key, private_key\\n\\n\\ndef make_key_files(name: str, keySize: int) -> None:\\n    if os.path.exists(\\\"%s_pubkey.txt\\\" % name) or os.path.exists(\\n        \\\"%s_privkey.txt\\\" % name\\n    ):\\n        print(\\\"\\\\nWARNING:\\\")\\n        print(\\n            '\\\"%s_pubkey.txt\\\" or \\\"%s_privkey.txt\\\" already exists. \\\\n'\\n            \\\"Use a different name or delete these files and re-run this program.\\\"\\n            % (name, name)\\n        )\\n        sys.exit()\\n\\n    publicKey, privateKey = generate_key(keySize)\\n    print(\\\"\\\\nWriting public key to file %s_pubkey.txt...\\\" % name)\\n    with open(\\\"%s_pubkey.txt\\\" % name, \\\"w\\\") as fo:\\n        fo.write(\\n            \\\"%d,%d,%d,%d\\\" % (publicKey[0], publicKey[1], publicKey[2], publicKey[3])\\n        )\\n\\n    print(\\\"Writing private key to file %s_privkey.txt...\\\" % name)\\n    with open(\\\"%s_privkey.txt\\\" % name, \\\"w\\\") as fo:\\n        fo.write(\\\"%d,%d\\\" % (privateKey[0], privateKey[1]))\\n\\n\\ndef main() -> None:\\n    print(\\\"Making key files...\\\")\\n    make_key_files(\\\"elgamal\\\", 2048)\\n    print(\\\"Key files generation successful\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "enigma machine2": "\"\\\"\\\"\\\"\\nWikipedia: https://en.wikipedia.org/wiki/Enigma_machine\\nVideo explanation: https://youtu.be/QwQVMqfoB2E\\nAlso check out Numberphile's and Computerphile's videos on this topic\\n\\nThis module contains function 'enigma' which emulates\\nthe famous Enigma machine from WWII.\\nModule includes:\\n- enigma function\\n- showcase of function usage\\n- 9 randnomly generated rotors\\n- reflector (aka static rotor)\\n- original alphabet\\n\\nCreated by TrapinchO\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nRotorPositionT = tuple[int, int, int]\\nRotorSelectionT = tuple[str, str, str]\\n\\n\\n# used alphabet --------------------------\\n# from string.ascii_uppercase\\nabc = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\n\\n# -------------------------- default selection --------------------------\\n# rotors --------------------------\\nrotor1 = \\\"EGZWVONAHDCLFQMSIPJBYUKXTR\\\"\\nrotor2 = \\\"FOBHMDKEXQNRAULPGSJVTYICZW\\\"\\nrotor3 = \\\"ZJXESIUQLHAVRMDOYGTNFWPBKC\\\"\\n# reflector --------------------------\\nreflector = {\\n    \\\"A\\\": \\\"N\\\",\\n    \\\"N\\\": \\\"A\\\",\\n    \\\"B\\\": \\\"O\\\",\\n    \\\"O\\\": \\\"B\\\",\\n    \\\"C\\\": \\\"P\\\",\\n    \\\"P\\\": \\\"C\\\",\\n    \\\"D\\\": \\\"Q\\\",\\n    \\\"Q\\\": \\\"D\\\",\\n    \\\"E\\\": \\\"R\\\",\\n    \\\"R\\\": \\\"E\\\",\\n    \\\"F\\\": \\\"S\\\",\\n    \\\"S\\\": \\\"F\\\",\\n    \\\"G\\\": \\\"T\\\",\\n    \\\"T\\\": \\\"G\\\",\\n    \\\"H\\\": \\\"U\\\",\\n    \\\"U\\\": \\\"H\\\",\\n    \\\"I\\\": \\\"V\\\",\\n    \\\"V\\\": \\\"I\\\",\\n    \\\"J\\\": \\\"W\\\",\\n    \\\"W\\\": \\\"J\\\",\\n    \\\"K\\\": \\\"X\\\",\\n    \\\"X\\\": \\\"K\\\",\\n    \\\"L\\\": \\\"Y\\\",\\n    \\\"Y\\\": \\\"L\\\",\\n    \\\"M\\\": \\\"Z\\\",\\n    \\\"Z\\\": \\\"M\\\",\\n}\\n\\n# -------------------------- extra rotors --------------------------\\nrotor4 = \\\"RMDJXFUWGISLHVTCQNKYPBEZOA\\\"\\nrotor5 = \\\"SGLCPQWZHKXAREONTFBVIYJUDM\\\"\\nrotor6 = \\\"HVSICLTYKQUBXDWAJZOMFGPREN\\\"\\nrotor7 = \\\"RZWQHFMVDBKICJLNTUXAGYPSOE\\\"\\nrotor8 = \\\"LFKIJODBEGAMQPXVUHYSTCZRWN\\\"\\nrotor9 = \\\"KOAEGVDHXPQZMLFTYWJNBRCIUS\\\"\\n\\n\\ndef _validator(\\n    rotpos: RotorPositionT, rotsel: RotorSelectionT, pb: str\\n) -> tuple[RotorPositionT, RotorSelectionT, dict[str, str]]:\\n    \\\"\\\"\\\"\\n    Checks if the values can be used for the 'enigma' function\\n\\n    >>> _validator((1,1,1), (rotor1, rotor2, rotor3), 'POLAND')\\n    ((1, 1, 1), ('EGZWVONAHDCLFQMSIPJBYUKXTR', 'FOBHMDKEXQNRAULPGSJVTYICZW', \\\\\\n'ZJXESIUQLHAVRMDOYGTNFWPBKC'), \\\\\\n{'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'})\\n\\n    :param rotpos: rotor_positon\\n    :param rotsel: rotor_selection\\n    :param pb: plugb -> validated and transformed\\n    :return: (rotpos, rotsel, pb)\\n    \\\"\\\"\\\"\\n    # Checks if there are 3 unique rotors\\n\\n    unique_rotsel = len(set(rotsel))\\n    if unique_rotsel < 3:\\n        raise Exception(f\\\"Please use 3 unique rotors (not {unique_rotsel})\\\")\\n\\n    # Checks if rotor positions are valid\\n    rotorpos1, rotorpos2, rotorpos3 = rotpos\\n    if not 0 < rotorpos1 <= len(abc):\\n        raise ValueError(\\n            f\\\"First rotor position is not within range of 1..26 (\\\" f\\\"{rotorpos1}\\\"\\n        )\\n    if not 0 < rotorpos2 <= len(abc):\\n        raise ValueError(\\n            f\\\"Second rotor position is not within range of 1..26 (\\\" f\\\"{rotorpos2})\\\"\\n        )\\n    if not 0 < rotorpos3 <= len(abc):\\n        raise ValueError(\\n            f\\\"Third rotor position is not within range of 1..26 (\\\" f\\\"{rotorpos3})\\\"\\n        )\\n\\n    # Validates string and returns dict\\n    pbdict = _plugboard(pb)\\n\\n    return rotpos, rotsel, pbdict\\n\\n\\ndef _plugboard(pbstring: str) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    https://en.wikipedia.org/wiki/Enigma_machine#Plugboard\\n\\n    >>> _plugboard('PICTURES')\\n    {'P': 'I', 'I': 'P', 'C': 'T', 'T': 'C', 'U': 'R', 'R': 'U', 'E': 'S', 'S': 'E'}\\n    >>> _plugboard('POLAND')\\n    {'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'}\\n\\n    In the code, 'pb' stands for 'plugboard'\\n\\n    Pairs can be separated by spaces\\n    :param pbstring: string containing plugboard setting for the Enigma machine\\n    :return: dictionary containing converted pairs\\n    \\\"\\\"\\\"\\n\\n    # tests the input string if it\\n    # a) is type string\\n    # b) has even length (so pairs can be made)\\n    if not isinstance(pbstring, str):\\n        raise TypeError(f\\\"Plugboard setting isn't type string ({type(pbstring)})\\\")\\n    elif len(pbstring) % 2 != 0:\\n        raise Exception(f\\\"Odd number of symbols ({len(pbstring)})\\\")\\n    elif pbstring == \\\"\\\":\\n        return {}\\n\\n    pbstring.replace(\\\" \\\", \\\"\\\")\\n\\n    # Checks if all characters are unique\\n    tmppbl = set()\\n    for i in pbstring:\\n        if i not in abc:\\n            raise Exception(f\\\"'{i}' not in list of symbols\\\")\\n        elif i in tmppbl:\\n            raise Exception(f\\\"Duplicate symbol ({i})\\\")\\n        else:\\n            tmppbl.add(i)\\n    del tmppbl\\n\\n    # Created the dictionary\\n    pb = {}\\n    for j in range(0, len(pbstring) - 1, 2):\\n        pb[pbstring[j]] = pbstring[j + 1]\\n        pb[pbstring[j + 1]] = pbstring[j]\\n\\n    return pb\\n\\n\\ndef enigma(\\n    text: str,\\n    rotor_position: RotorPositionT,\\n    rotor_selection: RotorSelectionT = (rotor1, rotor2, rotor3),\\n    plugb: str = \\\"\\\",\\n) -> str:\\n    \\\"\\\"\\\"\\n    The only difference with real-world enigma is that I allowed string input.\\n    All characters are converted to uppercase. (non-letter symbol are ignored)\\n    How it works:\\n    (for every letter in the message)\\n\\n    - Input letter goes into the plugboard.\\n    If it is connected to another one, switch it.\\n\\n    - Letter goes through 3 rotors.\\n    Each rotor can be represented as 2 sets of symbol, where one is shuffled.\\n    Each symbol from the first set has corresponding symbol in\\n    the second set and vice versa.\\n\\n    example:\\n    | ABCDEFGHIJKLMNOPQRSTUVWXYZ | e.g. F=D and D=F\\n    | VKLEPDBGRNWTFCJOHQAMUZYIXS |\\n\\n    - Symbol then goes through reflector (static rotor).\\n    There it is switched with paired symbol\\n    The reflector can be represented as2 sets, each with half of the alphanet.\\n    There are usually 10 pairs of letters.\\n\\n    Example:\\n    | ABCDEFGHIJKLM | e.g. E is paired to X\\n    | ZYXWVUTSRQPON | so when E goes in X goes out and vice versa\\n\\n    - Letter then goes through the rotors again\\n\\n    - If the letter is connected to plugboard, it is switched.\\n\\n    - Return the letter\\n\\n    >>> enigma('Hello World!', (1, 2, 1), plugb='pictures')\\n    'KORYH JUHHI!'\\n    >>> enigma('KORYH, juhhi!', (1, 2, 1), plugb='pictures')\\n    'HELLO, WORLD!'\\n    >>> enigma('hello world!', (1, 1, 1), plugb='pictures')\\n    'FPNCZ QWOBU!'\\n    >>> enigma('FPNCZ QWOBU', (1, 1, 1), plugb='pictures')\\n    'HELLO WORLD'\\n\\n\\n    :param text: input message\\n    :param rotor_position: tuple with 3 values in range 1..26\\n    :param rotor_selection: tuple with 3 rotors ()\\n    :param plugb: string containing plugboard configuration (default '')\\n    :return: en/decrypted string\\n    \\\"\\\"\\\"\\n\\n    text = text.upper()\\n    rotor_position, rotor_selection, plugboard = _validator(\\n        rotor_position, rotor_selection, plugb.upper()\\n    )\\n\\n    rotorpos1, rotorpos2, rotorpos3 = rotor_position\\n    rotor1, rotor2, rotor3 = rotor_selection\\n    rotorpos1 -= 1\\n    rotorpos2 -= 1\\n    rotorpos3 -= 1\\n\\n    result = []\\n\\n    # encryption/decryption process --------------------------\\n    for symbol in text:\\n        if symbol in abc:\\n\\n            # 1st plugboard --------------------------\\n            if symbol in plugboard:\\n                symbol = plugboard[symbol]\\n\\n            # rotor ra --------------------------\\n            index = abc.index(symbol) + rotorpos1\\n            symbol = rotor1[index % len(abc)]\\n\\n            # rotor rb --------------------------\\n            index = abc.index(symbol) + rotorpos2\\n            symbol = rotor2[index % len(abc)]\\n\\n            # rotor rc --------------------------\\n            index = abc.index(symbol) + rotorpos3\\n            symbol = rotor3[index % len(abc)]\\n\\n            # reflector --------------------------\\n            # this is the reason you don't need another machine to decipher\\n\\n            symbol = reflector[symbol]\\n\\n            # 2nd rotors\\n            symbol = abc[rotor3.index(symbol) - rotorpos3]\\n            symbol = abc[rotor2.index(symbol) - rotorpos2]\\n            symbol = abc[rotor1.index(symbol) - rotorpos1]\\n\\n            # 2nd plugboard\\n            if symbol in plugboard:\\n                symbol = plugboard[symbol]\\n\\n            # moves/resets rotor positions\\n            rotorpos1 += 1\\n            if rotorpos1 >= len(abc):\\n                rotorpos1 = 0\\n                rotorpos2 += 1\\n            if rotorpos2 >= len(abc):\\n                rotorpos2 = 0\\n                rotorpos3 += 1\\n            if rotorpos3 >= len(abc):\\n                rotorpos3 = 0\\n\\n        # else:\\n        #    pass\\n        #    Error could be also raised\\n        #    raise ValueError(\\n        #       'Invalid symbol('+repr(symbol)+')')\\n        result.append(symbol)\\n\\n    return \\\"\\\".join(result)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    message = \\\"This is my Python script that emulates the Enigma machine from WWII.\\\"\\n    rotor_pos = (1, 1, 1)\\n    pb = \\\"pictures\\\"\\n    rotor_sel = (rotor2, rotor4, rotor8)\\n    en = enigma(message, rotor_pos, rotor_sel, pb)\\n\\n    print(\\\"Encrypted message:\\\", en)\\n    print(\\\"Decrypted message:\\\", enigma(en, rotor_pos, rotor_sel, pb))\\n\"",
    "hill cipher": "\"\\\"\\\"\\\"\\n\\nHill Cipher:\\nThe 'HillCipher' class below implements the Hill Cipher algorithm which uses\\nmodern linear algebra techniques to encode and decode text using an encryption\\nkey matrix.\\n\\nAlgorithm:\\nLet the order of the encryption key be N (as it is a square matrix).\\nYour text is divided into batches of length N and converted to numerical vectors\\nby a simple mapping starting with A=0 and so on.\\n\\nThe key is then multiplied with the newly created batch vector to obtain the\\nencoded vector. After each multiplication modular 36 calculations are performed\\non the vectors so as to bring the numbers between 0 and 36 and then mapped with\\ntheir corresponding alphanumerics.\\n\\nWhile decrypting, the decrypting key is found which is the inverse of the\\nencrypting key modular 36. The same process is repeated for decrypting to get\\nthe original message back.\\n\\nConstraints:\\nThe determinant of the encryption key matrix must be relatively prime w.r.t 36.\\n\\nNote:\\nThis implementation only considers alphanumerics in the text.  If the length of\\nthe text to be encrypted is not a multiple of the break key(the length of one\\nbatch of letters), the last character of the text is added to the text until the\\nlength of the text reaches a multiple of the break_key. So the text after\\ndecrypting might be a little different than the original text.\\n\\nReferences:\\nhttps://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf\\nhttps://www.youtube.com/watch?v=kfmNeskzs2o\\nhttps://www.youtube.com/watch?v=4RhLNDqcjpA\\n\\n\\\"\\\"\\\"\\nimport string\\n\\nimport numpy\\n\\n\\ndef greatest_common_divisor(a: int, b: int) -> int:\\n    \\\"\\\"\\\"\\n    >>> greatest_common_divisor(4, 8)\\n    4\\n    >>> greatest_common_divisor(8, 4)\\n    4\\n    >>> greatest_common_divisor(4, 7)\\n    1\\n    >>> greatest_common_divisor(0, 10)\\n    10\\n    \\\"\\\"\\\"\\n    return b if a == 0 else greatest_common_divisor(b % a, a)\\n\\n\\nclass HillCipher:\\n    key_string = string.ascii_uppercase + string.digits\\n    # This cipher takes alphanumerics into account\\n    # i.e. a total of 36 characters\\n\\n    # take x and return x % len(key_string)\\n    modulus = numpy.vectorize(lambda x: x % 36)\\n\\n    to_int = numpy.vectorize(lambda x: round(x))\\n\\n    def __init__(self, encrypt_key: numpy.ndarray) -> None:\\n        \\\"\\\"\\\"\\n        encrypt_key is an NxN numpy array\\n        \\\"\\\"\\\"\\n        self.encrypt_key = self.modulus(encrypt_key)  # mod36 calc's on the encrypt key\\n        self.check_determinant()  # validate the determinant of the encryption key\\n        self.break_key = encrypt_key.shape[0]\\n\\n    def replace_letters(self, letter: str) -> int:\\n        \\\"\\\"\\\"\\n        >>> hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\\n        >>> hill_cipher.replace_letters('T')\\n        19\\n        >>> hill_cipher.replace_letters('0')\\n        26\\n        \\\"\\\"\\\"\\n        return self.key_string.index(letter)\\n\\n    def replace_digits(self, num: int) -> str:\\n        \\\"\\\"\\\"\\n        >>> hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\\n        >>> hill_cipher.replace_digits(19)\\n        'T'\\n        >>> hill_cipher.replace_digits(26)\\n        '0'\\n        \\\"\\\"\\\"\\n        return self.key_string[round(num)]\\n\\n    def check_determinant(self) -> None:\\n        \\\"\\\"\\\"\\n        >>> hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\\n        >>> hill_cipher.check_determinant()\\n        \\\"\\\"\\\"\\n        det = round(numpy.linalg.det(self.encrypt_key))\\n\\n        if det < 0:\\n            det = det % len(self.key_string)\\n\\n        req_l = len(self.key_string)\\n        if greatest_common_divisor(det, len(self.key_string)) != 1:\\n            raise ValueError(\\n                f\\\"determinant modular {req_l} of encryption key({det}) is not co prime \\\"\\n                f\\\"w.r.t {req_l}.\\\\nTry another key.\\\"\\n            )\\n\\n    def process_text(self, text: str) -> str:\\n        \\\"\\\"\\\"\\n        >>> hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\\n        >>> hill_cipher.process_text('Testing Hill Cipher')\\n        'TESTINGHILLCIPHERR'\\n        >>> hill_cipher.process_text('hello')\\n        'HELLOO'\\n        \\\"\\\"\\\"\\n        chars = [char for char in text.upper() if char in self.key_string]\\n\\n        last = chars[-1]\\n        while len(chars) % self.break_key != 0:\\n            chars.append(last)\\n\\n        return \\\"\\\".join(chars)\\n\\n    def encrypt(self, text: str) -> str:\\n        \\\"\\\"\\\"\\n        >>> hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\\n        >>> hill_cipher.encrypt('testing hill cipher')\\n        'WHXYJOLM9C6XT085LL'\\n        >>> hill_cipher.encrypt('hello')\\n        '85FF00'\\n        \\\"\\\"\\\"\\n        text = self.process_text(text.upper())\\n        encrypted = \\\"\\\"\\n\\n        for i in range(0, len(text) - self.break_key + 1, self.break_key):\\n            batch = text[i : i + self.break_key]\\n            vec = [self.replace_letters(char) for char in batch]\\n            batch_vec = numpy.array([vec]).T\\n            batch_encrypted = self.modulus(self.encrypt_key.dot(batch_vec)).T.tolist()[\\n                0\\n            ]\\n            encrypted_batch = \\\"\\\".join(\\n                self.replace_digits(num) for num in batch_encrypted\\n            )\\n            encrypted += encrypted_batch\\n\\n        return encrypted\\n\\n    def make_decrypt_key(self) -> numpy.ndarray:\\n        \\\"\\\"\\\"\\n        >>> hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\\n        >>> hill_cipher.make_decrypt_key()\\n        array([[ 6, 25],\\n               [ 5, 26]])\\n        \\\"\\\"\\\"\\n        det = round(numpy.linalg.det(self.encrypt_key))\\n\\n        if det < 0:\\n            det = det % len(self.key_string)\\n        det_inv = None\\n        for i in range(len(self.key_string)):\\n            if (det * i) % len(self.key_string) == 1:\\n                det_inv = i\\n                break\\n\\n        inv_key = (\\n            det_inv\\n            * numpy.linalg.det(self.encrypt_key)\\n            * numpy.linalg.inv(self.encrypt_key)\\n        )\\n\\n        return self.to_int(self.modulus(inv_key))\\n\\n    def decrypt(self, text: str) -> str:\\n        \\\"\\\"\\\"\\n        >>> hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\\n        >>> hill_cipher.decrypt('WHXYJOLM9C6XT085LL')\\n        'TESTINGHILLCIPHERR'\\n        >>> hill_cipher.decrypt('85FF00')\\n        'HELLOO'\\n        \\\"\\\"\\\"\\n        decrypt_key = self.make_decrypt_key()\\n        text = self.process_text(text.upper())\\n        decrypted = \\\"\\\"\\n\\n        for i in range(0, len(text) - self.break_key + 1, self.break_key):\\n            batch = text[i : i + self.break_key]\\n            vec = [self.replace_letters(char) for char in batch]\\n            batch_vec = numpy.array([vec]).T\\n            batch_decrypted = self.modulus(decrypt_key.dot(batch_vec)).T.tolist()[0]\\n            decrypted_batch = \\\"\\\".join(\\n                self.replace_digits(num) for num in batch_decrypted\\n            )\\n            decrypted += decrypted_batch\\n\\n        return decrypted\\n\\n\\ndef main() -> None:\\n    N = int(input(\\\"Enter the order of the encryption key: \\\"))\\n    hill_matrix = []\\n\\n    print(\\\"Enter each row of the encryption key with space separated integers\\\")\\n    for _ in range(N):\\n        row = [int(x) for x in input().split()]\\n        hill_matrix.append(row)\\n\\n    hc = HillCipher(numpy.array(hill_matrix))\\n\\n    print(\\\"Would you like to encrypt or decrypt some text? (1 or 2)\\\")\\n    option = input(\\\"\\\\n1. Encrypt\\\\n2. Decrypt\\\\n\\\")\\n    if option == \\\"1\\\":\\n        text_e = input(\\\"What text would you like to encrypt?: \\\")\\n        print(\\\"Your encrypted text is:\\\")\\n        print(hc.encrypt(text_e))\\n    elif option == \\\"2\\\":\\n        text_d = input(\\\"What text would you like to decrypt?: \\\")\\n        print(\\\"Your decrypted text is:\\\")\\n        print(hc.decrypt(text_d))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    main()\\n\"",
    "mixed keyword cypher": "\"def mixed_keyword(key: str = \\\"college\\\", pt: str = \\\"UNIVERSITY\\\") -> str:\\n    \\\"\\\"\\\"\\n\\n    For key:hello\\n\\n    H E L O\\n    A B C D\\n    F G I J\\n    K M N P\\n    Q R S T\\n    U V W X\\n    Y Z\\n    and map vertically\\n\\n    >>> mixed_keyword(\\\"college\\\", \\\"UNIVERSITY\\\")  # doctest: +NORMALIZE_WHITESPACE\\n    {'A': 'C', 'B': 'A', 'C': 'I', 'D': 'P', 'E': 'U', 'F': 'Z', 'G': 'O', 'H': 'B',\\n     'I': 'J', 'J': 'Q', 'K': 'V', 'L': 'L', 'M': 'D', 'N': 'K', 'O': 'R', 'P': 'W',\\n     'Q': 'E', 'R': 'F', 'S': 'M', 'T': 'S', 'U': 'X', 'V': 'G', 'W': 'H', 'X': 'N',\\n     'Y': 'T', 'Z': 'Y'}\\n    'XKJGUFMJST'\\n    \\\"\\\"\\\"\\n    key = key.upper()\\n    pt = pt.upper()\\n    temp = []\\n    for i in key:\\n        if i not in temp:\\n            temp.append(i)\\n    len_temp = len(temp)\\n    # print(temp)\\n    alpha = []\\n    modalpha = []\\n    for j in range(65, 91):\\n        t = chr(j)\\n        alpha.append(t)\\n        if t not in temp:\\n            temp.append(t)\\n    # print(temp)\\n    r = int(26 / 4)\\n    # print(r)\\n    k = 0\\n    for _ in range(r):\\n        s = []\\n        for j in range(len_temp):\\n            s.append(temp[k])\\n            if not (k < 25):\\n                break\\n            k += 1\\n        modalpha.append(s)\\n    # print(modalpha)\\n    d = {}\\n    j = 0\\n    k = 0\\n    for j in range(len_temp):\\n        for m in modalpha:\\n            if not (len(m) - 1 >= j):\\n                break\\n            d[alpha[k]] = m[j]\\n            if not k < 25:\\n                break\\n            k += 1\\n    print(d)\\n    cypher = \\\"\\\"\\n    for i in pt:\\n        cypher += d[i]\\n    return cypher\\n\\n\\nprint(mixed_keyword(\\\"college\\\", \\\"UNIVERSITY\\\"))\\n\"",
    "mono alphabetic ciphers": "\"from typing import Literal\\n\\nLETTERS = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\n\\n\\ndef translate_message(\\n    key: str, message: str, mode: Literal[\\\"encrypt\\\", \\\"decrypt\\\"]\\n) -> str:\\n    \\\"\\\"\\\"\\n    >>> translate_message(\\\"QWERTYUIOPASDFGHJKLZXCVBNM\\\",\\\"Hello World\\\",\\\"encrypt\\\")\\n    'Pcssi Bidsm'\\n    \\\"\\\"\\\"\\n    chars_a = LETTERS if mode == \\\"decrypt\\\" else key\\n    chars_b = key if mode == \\\"decrypt\\\" else LETTERS\\n    translated = \\\"\\\"\\n    # loop through each symbol in the message\\n    for symbol in message:\\n        if symbol.upper() in chars_a:\\n            # encrypt/decrypt the symbol\\n            sym_index = chars_a.find(symbol.upper())\\n            if symbol.isupper():\\n                translated += chars_b[sym_index].upper()\\n            else:\\n                translated += chars_b[sym_index].lower()\\n        else:\\n            # symbol is not in LETTERS, just add it\\n            translated += symbol\\n    return translated\\n\\n\\ndef encrypt_message(key: str, message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> encrypt_message(\\\"QWERTYUIOPASDFGHJKLZXCVBNM\\\", \\\"Hello World\\\")\\n    'Pcssi Bidsm'\\n    \\\"\\\"\\\"\\n    return translate_message(key, message, \\\"encrypt\\\")\\n\\n\\ndef decrypt_message(key: str, message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> decrypt_message(\\\"QWERTYUIOPASDFGHJKLZXCVBNM\\\", \\\"Hello World\\\")\\n    'Itssg Vgksr'\\n    \\\"\\\"\\\"\\n    return translate_message(key, message, \\\"decrypt\\\")\\n\\n\\ndef main() -> None:\\n    message = \\\"Hello World\\\"\\n    key = \\\"QWERTYUIOPASDFGHJKLZXCVBNM\\\"\\n    mode = \\\"decrypt\\\"  # set to 'encrypt' or 'decrypt'\\n\\n    if mode == \\\"encrypt\\\":\\n        translated = encrypt_message(key, message)\\n    elif mode == \\\"decrypt\\\":\\n        translated = decrypt_message(key, message)\\n    print(f\\\"Using the key {key}, the {mode}ed message is: {translated}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "morse code": "\"#!/usr/bin/env python3\\n\\n\\\"\\\"\\\"\\nPython program to translate to and from Morse code.\\n\\nhttps://en.wikipedia.org/wiki/Morse_code\\n\\\"\\\"\\\"\\n\\n# fmt: off\\nMORSE_CODE_DICT = {\\n    \\\"A\\\": \\\".-\\\", \\\"B\\\": \\\"-...\\\", \\\"C\\\": \\\"-.-.\\\", \\\"D\\\": \\\"-..\\\", \\\"E\\\": \\\".\\\", \\\"F\\\": \\\"..-.\\\", \\\"G\\\": \\\"--.\\\",\\n    \\\"H\\\": \\\"....\\\", \\\"I\\\": \\\"..\\\", \\\"J\\\": \\\".---\\\", \\\"K\\\": \\\"-.-\\\", \\\"L\\\": \\\".-..\\\", \\\"M\\\": \\\"--\\\", \\\"N\\\": \\\"-.\\\",\\n    \\\"O\\\": \\\"---\\\", \\\"P\\\": \\\".--.\\\", \\\"Q\\\": \\\"--.-\\\", \\\"R\\\": \\\".-.\\\", \\\"S\\\": \\\"...\\\", \\\"T\\\": \\\"-\\\", \\\"U\\\": \\\"..-\\\",\\n    \\\"V\\\": \\\"...-\\\", \\\"W\\\": \\\".--\\\", \\\"X\\\": \\\"-..-\\\", \\\"Y\\\": \\\"-.--\\\", \\\"Z\\\": \\\"--..\\\", \\\"1\\\": \\\".----\\\",\\n    \\\"2\\\": \\\"..---\\\", \\\"3\\\": \\\"...--\\\", \\\"4\\\": \\\"....-\\\", \\\"5\\\": \\\".....\\\", \\\"6\\\": \\\"-....\\\", \\\"7\\\": \\\"--...\\\",\\n    \\\"8\\\": \\\"---..\\\", \\\"9\\\": \\\"----.\\\", \\\"0\\\": \\\"-----\\\", \\\"&\\\": \\\".-...\\\", \\\"@\\\": \\\".--.-.\\\",\\n    \\\":\\\": \\\"---...\\\", \\\",\\\": \\\"--..--\\\", \\\".\\\": \\\".-.-.-\\\", \\\"'\\\": \\\".----.\\\", '\\\"': \\\".-..-.\\\",\\n    \\\"?\\\": \\\"..--..\\\", \\\"/\\\": \\\"-..-.\\\", \\\"=\\\": \\\"-...-\\\", \\\"+\\\": \\\".-.-.\\\", \\\"-\\\": \\\"-....-\\\",\\n    \\\"(\\\": \\\"-.--.\\\", \\\")\\\": \\\"-.--.-\\\", \\\"!\\\": \\\"-.-.--\\\", \\\" \\\": \\\"/\\\"\\n}  # Exclamation mark is not in ITU-R recommendation\\n# fmt: on\\nREVERSE_DICT = {value: key for key, value in MORSE_CODE_DICT.items()}\\n\\n\\ndef encrypt(message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> encrypt(\\\"Sos!\\\")\\n    '... --- ... -.-.--'\\n    >>> encrypt(\\\"SOS!\\\") == encrypt(\\\"sos!\\\")\\n    True\\n    \\\"\\\"\\\"\\n    return \\\" \\\".join(MORSE_CODE_DICT[char] for char in message.upper())\\n\\n\\ndef decrypt(message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> decrypt('... --- ... -.-.--')\\n    'SOS!'\\n    \\\"\\\"\\\"\\n    return \\\"\\\".join(REVERSE_DICT[char] for char in message.split())\\n\\n\\ndef main() -> None:\\n    \\\"\\\"\\\"\\n    >>> s = \\\"\\\".join(MORSE_CODE_DICT)\\n    >>> decrypt(encrypt(s)) == s\\n    True\\n    \\\"\\\"\\\"\\n    message = \\\"Morse code here!\\\"\\n    print(message)\\n    message = encrypt(message)\\n    print(message)\\n    message = decrypt(message)\\n    print(message)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "onepad cipher": "\"import random\\n\\n\\nclass Onepad:\\n    @staticmethod\\n    def encrypt(text: str) -> tuple[list[int], list[int]]:\\n        \\\"\\\"\\\"Function to encrypt text using pseudo-random numbers\\\"\\\"\\\"\\n        plain = [ord(i) for i in text]\\n        key = []\\n        cipher = []\\n        for i in plain:\\n            k = random.randint(1, 300)\\n            c = (i + k) * k\\n            cipher.append(c)\\n            key.append(k)\\n        return cipher, key\\n\\n    @staticmethod\\n    def decrypt(cipher: list[int], key: list[int]) -> str:\\n        \\\"\\\"\\\"Function to decrypt text using pseudo-random numbers.\\\"\\\"\\\"\\n        plain = []\\n        for i in range(len(key)):\\n            p = int((cipher[i] - (key[i]) ** 2) / key[i])\\n            plain.append(chr(p))\\n        return \\\"\\\".join([i for i in plain])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    c, k = Onepad().encrypt(\\\"Hello\\\")\\n    print(c, k)\\n    print(Onepad().decrypt(c, k))\\n\"",
    "playfair cipher": "\"import itertools\\nimport string\\nfrom typing import Generator, Iterable\\n\\n\\ndef chunker(seq: Iterable[str], size: int) -> Generator[tuple[str, ...], None, None]:\\n    it = iter(seq)\\n    while True:\\n        chunk = tuple(itertools.islice(it, size))\\n        if not chunk:\\n            return\\n        yield chunk\\n\\n\\ndef prepare_input(dirty: str) -> str:\\n    \\\"\\\"\\\"\\n    Prepare the plaintext by up-casing it\\n    and separating repeated letters with X's\\n    \\\"\\\"\\\"\\n\\n    dirty = \\\"\\\".join([c.upper() for c in dirty if c in string.ascii_letters])\\n    clean = \\\"\\\"\\n\\n    if len(dirty) < 2:\\n        return dirty\\n\\n    for i in range(len(dirty) - 1):\\n        clean += dirty[i]\\n\\n        if dirty[i] == dirty[i + 1]:\\n            clean += \\\"X\\\"\\n\\n    clean += dirty[-1]\\n\\n    if len(clean) & 1:\\n        clean += \\\"X\\\"\\n\\n    return clean\\n\\n\\ndef generate_table(key: str) -> list[str]:\\n\\n    # I and J are used interchangeably to allow\\n    # us to use a 5x5 table (25 letters)\\n    alphabet = \\\"ABCDEFGHIKLMNOPQRSTUVWXYZ\\\"\\n    # we're using a list instead of a '2d' array because it makes the math\\n    # for setting up the table and doing the actual encoding/decoding simpler\\n    table = []\\n\\n    # copy key chars into the table if they are in `alphabet` ignoring duplicates\\n    for char in key.upper():\\n        if char not in table and char in alphabet:\\n            table.append(char)\\n\\n    # fill the rest of the table in with the remaining alphabet chars\\n    for char in alphabet:\\n        if char not in table:\\n            table.append(char)\\n\\n    return table\\n\\n\\ndef encode(plaintext: str, key: str) -> str:\\n    table = generate_table(key)\\n    plaintext = prepare_input(plaintext)\\n    ciphertext = \\\"\\\"\\n\\n    # https://en.wikipedia.org/wiki/Playfair_cipher#Description\\n    for char1, char2 in chunker(plaintext, 2):\\n        row1, col1 = divmod(table.index(char1), 5)\\n        row2, col2 = divmod(table.index(char2), 5)\\n\\n        if row1 == row2:\\n            ciphertext += table[row1 * 5 + (col1 + 1) % 5]\\n            ciphertext += table[row2 * 5 + (col2 + 1) % 5]\\n        elif col1 == col2:\\n            ciphertext += table[((row1 + 1) % 5) * 5 + col1]\\n            ciphertext += table[((row2 + 1) % 5) * 5 + col2]\\n        else:  # rectangle\\n            ciphertext += table[row1 * 5 + col2]\\n            ciphertext += table[row2 * 5 + col1]\\n\\n    return ciphertext\\n\\n\\ndef decode(ciphertext: str, key: str) -> str:\\n    table = generate_table(key)\\n    plaintext = \\\"\\\"\\n\\n    # https://en.wikipedia.org/wiki/Playfair_cipher#Description\\n    for char1, char2 in chunker(ciphertext, 2):\\n        row1, col1 = divmod(table.index(char1), 5)\\n        row2, col2 = divmod(table.index(char2), 5)\\n\\n        if row1 == row2:\\n            plaintext += table[row1 * 5 + (col1 - 1) % 5]\\n            plaintext += table[row2 * 5 + (col2 - 1) % 5]\\n        elif col1 == col2:\\n            plaintext += table[((row1 - 1) % 5) * 5 + col1]\\n            plaintext += table[((row2 - 1) % 5) * 5 + col2]\\n        else:  # rectangle\\n            plaintext += table[row1 * 5 + col2]\\n            plaintext += table[row2 * 5 + col1]\\n\\n    return plaintext\\n\"",
    "polybius": "\"#!/usr/bin/env python3\\n\\n\\\"\\\"\\\"\\nA Polybius Square is a table that allows someone to translate letters into numbers.\\n\\nhttps://www.braingle.com/brainteasers/codes/polybius.php\\n\\\"\\\"\\\"\\n\\nimport numpy as np\\n\\n\\nclass PolybiusCipher:\\n    def __init__(self) -> None:\\n        SQUARE = [\\n            [\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\"],\\n            [\\\"f\\\", \\\"g\\\", \\\"h\\\", \\\"i\\\", \\\"k\\\"],\\n            [\\\"l\\\", \\\"m\\\", \\\"n\\\", \\\"o\\\", \\\"p\\\"],\\n            [\\\"q\\\", \\\"r\\\", \\\"s\\\", \\\"t\\\", \\\"u\\\"],\\n            [\\\"v\\\", \\\"w\\\", \\\"x\\\", \\\"y\\\", \\\"z\\\"],\\n        ]\\n        self.SQUARE = np.array(SQUARE)\\n\\n    def letter_to_numbers(self, letter: str) -> np.ndarray:\\n        \\\"\\\"\\\"\\n        Return the pair of numbers that represents the given letter in the\\n        polybius square\\n        >>> np.array_equal(PolybiusCipher().letter_to_numbers('a'), [1,1])\\n        True\\n\\n        >>> np.array_equal(PolybiusCipher().letter_to_numbers('u'), [4,5])\\n        True\\n        \\\"\\\"\\\"\\n        index1, index2 = np.where(self.SQUARE == letter)\\n        indexes = np.concatenate([index1 + 1, index2 + 1])\\n        return indexes\\n\\n    def numbers_to_letter(self, index1: int, index2: int) -> str:\\n        \\\"\\\"\\\"\\n        Return the letter corresponding to the position [index1, index2] in\\n        the polybius square\\n\\n        >>> PolybiusCipher().numbers_to_letter(4, 5) == \\\"u\\\"\\n        True\\n\\n        >>> PolybiusCipher().numbers_to_letter(1, 1) == \\\"a\\\"\\n        True\\n        \\\"\\\"\\\"\\n        return self.SQUARE[index1 - 1, index2 - 1]\\n\\n    def encode(self, message: str) -> str:\\n        \\\"\\\"\\\"\\n        Return the encoded version of message according to the polybius cipher\\n\\n        >>> PolybiusCipher().encode(\\\"test message\\\") == \\\"44154344 32154343112215\\\"\\n        True\\n\\n        >>> PolybiusCipher().encode(\\\"Test Message\\\") == \\\"44154344 32154343112215\\\"\\n        True\\n        \\\"\\\"\\\"\\n        message = message.lower()\\n        message = message.replace(\\\"j\\\", \\\"i\\\")\\n\\n        encoded_message = \\\"\\\"\\n        for letter_index in range(len(message)):\\n            if message[letter_index] != \\\" \\\":\\n                numbers = self.letter_to_numbers(message[letter_index])\\n                encoded_message = encoded_message + str(numbers[0]) + str(numbers[1])\\n            elif message[letter_index] == \\\" \\\":\\n                encoded_message = encoded_message + \\\" \\\"\\n\\n        return encoded_message\\n\\n    def decode(self, message: str) -> str:\\n        \\\"\\\"\\\"\\n        Return the decoded version of message according to the polybius cipher\\n\\n        >>> PolybiusCipher().decode(\\\"44154344 32154343112215\\\") == \\\"test message\\\"\\n        True\\n\\n        >>> PolybiusCipher().decode(\\\"4415434432154343112215\\\") == \\\"testmessage\\\"\\n        True\\n        \\\"\\\"\\\"\\n        message = message.replace(\\\" \\\", \\\"  \\\")\\n        decoded_message = \\\"\\\"\\n        for numbers_index in range(int(len(message) / 2)):\\n            if message[numbers_index * 2] != \\\" \\\":\\n                index1 = message[numbers_index * 2]\\n                index2 = message[numbers_index * 2 + 1]\\n\\n                letter = self.numbers_to_letter(int(index1), int(index2))\\n                decoded_message = decoded_message + letter\\n            elif message[numbers_index * 2] == \\\" \\\":\\n                decoded_message = decoded_message + \\\" \\\"\\n\\n        return decoded_message\\n\"",
    "porta cipher": "\"alphabet = {\\n    \\\"A\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"NOPQRSTUVWXYZ\\\"),\\n    \\\"B\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"NOPQRSTUVWXYZ\\\"),\\n    \\\"C\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"ZNOPQRSTUVWXY\\\"),\\n    \\\"D\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"ZNOPQRSTUVWXY\\\"),\\n    \\\"E\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"YZNOPQRSTUVWX\\\"),\\n    \\\"F\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"YZNOPQRSTUVWX\\\"),\\n    \\\"G\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"XYZNOPQRSTUVW\\\"),\\n    \\\"H\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"XYZNOPQRSTUVW\\\"),\\n    \\\"I\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"WXYZNOPQRSTUV\\\"),\\n    \\\"J\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"WXYZNOPQRSTUV\\\"),\\n    \\\"K\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"VWXYZNOPQRSTU\\\"),\\n    \\\"L\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"VWXYZNOPQRSTU\\\"),\\n    \\\"M\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"UVWXYZNOPQRST\\\"),\\n    \\\"N\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"UVWXYZNOPQRST\\\"),\\n    \\\"O\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"TUVWXYZNOPQRS\\\"),\\n    \\\"P\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"TUVWXYZNOPQRS\\\"),\\n    \\\"Q\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"STUVWXYZNOPQR\\\"),\\n    \\\"R\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"STUVWXYZNOPQR\\\"),\\n    \\\"S\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"RSTUVWXYZNOPQ\\\"),\\n    \\\"T\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"RSTUVWXYZNOPQ\\\"),\\n    \\\"U\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"QRSTUVWXYZNOP\\\"),\\n    \\\"V\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"QRSTUVWXYZNOP\\\"),\\n    \\\"W\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"PQRSTUVWXYZNO\\\"),\\n    \\\"X\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"PQRSTUVWXYZNO\\\"),\\n    \\\"Y\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"OPQRSTUVWXYZN\\\"),\\n    \\\"Z\\\": (\\\"ABCDEFGHIJKLM\\\", \\\"OPQRSTUVWXYZN\\\"),\\n}\\n\\n\\ndef generate_table(key: str) -> list[tuple[str, str]]:\\n    \\\"\\\"\\\"\\n    >>> generate_table('marvin')  # doctest: +NORMALIZE_WHITESPACE\\n    [('ABCDEFGHIJKLM', 'UVWXYZNOPQRST'), ('ABCDEFGHIJKLM', 'NOPQRSTUVWXYZ'),\\n     ('ABCDEFGHIJKLM', 'STUVWXYZNOPQR'), ('ABCDEFGHIJKLM', 'QRSTUVWXYZNOP'),\\n     ('ABCDEFGHIJKLM', 'WXYZNOPQRSTUV'), ('ABCDEFGHIJKLM', 'UVWXYZNOPQRST')]\\n    \\\"\\\"\\\"\\n    return [alphabet[char] for char in key.upper()]\\n\\n\\ndef encrypt(key: str, words: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> encrypt('marvin', 'jessica')\\n    'QRACRWU'\\n    \\\"\\\"\\\"\\n    cipher = \\\"\\\"\\n    count = 0\\n    table = generate_table(key)\\n    for char in words.upper():\\n        cipher += get_opponent(table[count], char)\\n        count = (count + 1) % len(table)\\n    return cipher\\n\\n\\ndef decrypt(key: str, words: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> decrypt('marvin', 'QRACRWU')\\n    'JESSICA'\\n    \\\"\\\"\\\"\\n    return encrypt(key, words)\\n\\n\\ndef get_position(table: tuple[str, str], char: str) -> tuple[int, int]:\\n    \\\"\\\"\\\"\\n    >>> get_position(generate_table('marvin')[0], 'M')\\n    (0, 12)\\n    \\\"\\\"\\\"\\n    # `char` is either in the 0th row or the 1st row\\n    row = 0 if char in table[0] else 1\\n    col = table[row].index(char)\\n    return row, col\\n\\n\\ndef get_opponent(table: tuple[str, str], char: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> get_opponent(generate_table('marvin')[0], 'M')\\n    'T'\\n    \\\"\\\"\\\"\\n    row, col = get_position(table, char.upper())\\n    if row == 1:\\n        return table[0][col]\\n    else:\\n        return table[1][col] if row == 0 else char\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()  # Fist ensure that all our tests are passing...\\n    \\\"\\\"\\\"\\n    Demo:\\n\\n    Enter key: marvin\\n    Enter text to encrypt: jessica\\n    Encrypted: QRACRWU\\n    Decrypted with key: JESSICA\\n    \\\"\\\"\\\"\\n    key = input(\\\"Enter key: \\\").strip()\\n    text = input(\\\"Enter text to encrypt: \\\").strip()\\n    cipher_text = encrypt(key, text)\\n\\n    print(f\\\"Encrypted: {cipher_text}\\\")\\n    print(f\\\"Decrypted with key: {decrypt(key, cipher_text)}\\\")\\n\"",
    "rabin miller": "\"# Primality Testing with the Rabin-Miller Algorithm\\n\\nimport random\\n\\n\\ndef rabinMiller(num: int) -> bool:\\n    s = num - 1\\n    t = 0\\n\\n    while s % 2 == 0:\\n        s = s // 2\\n        t += 1\\n\\n    for trials in range(5):\\n        a = random.randrange(2, num - 1)\\n        v = pow(a, s, num)\\n        if v != 1:\\n            i = 0\\n            while v != (num - 1):\\n                if i == t - 1:\\n                    return False\\n                else:\\n                    i = i + 1\\n                    v = (v ** 2) % num\\n    return True\\n\\n\\ndef isPrime(num: int) -> bool:\\n    if num < 2:\\n        return False\\n\\n    lowPrimes = [\\n        2,\\n        3,\\n        5,\\n        7,\\n        11,\\n        13,\\n        17,\\n        19,\\n        23,\\n        29,\\n        31,\\n        37,\\n        41,\\n        43,\\n        47,\\n        53,\\n        59,\\n        61,\\n        67,\\n        71,\\n        73,\\n        79,\\n        83,\\n        89,\\n        97,\\n        101,\\n        103,\\n        107,\\n        109,\\n        113,\\n        127,\\n        131,\\n        137,\\n        139,\\n        149,\\n        151,\\n        157,\\n        163,\\n        167,\\n        173,\\n        179,\\n        181,\\n        191,\\n        193,\\n        197,\\n        199,\\n        211,\\n        223,\\n        227,\\n        229,\\n        233,\\n        239,\\n        241,\\n        251,\\n        257,\\n        263,\\n        269,\\n        271,\\n        277,\\n        281,\\n        283,\\n        293,\\n        307,\\n        311,\\n        313,\\n        317,\\n        331,\\n        337,\\n        347,\\n        349,\\n        353,\\n        359,\\n        367,\\n        373,\\n        379,\\n        383,\\n        389,\\n        397,\\n        401,\\n        409,\\n        419,\\n        421,\\n        431,\\n        433,\\n        439,\\n        443,\\n        449,\\n        457,\\n        461,\\n        463,\\n        467,\\n        479,\\n        487,\\n        491,\\n        499,\\n        503,\\n        509,\\n        521,\\n        523,\\n        541,\\n        547,\\n        557,\\n        563,\\n        569,\\n        571,\\n        577,\\n        587,\\n        593,\\n        599,\\n        601,\\n        607,\\n        613,\\n        617,\\n        619,\\n        631,\\n        641,\\n        643,\\n        647,\\n        653,\\n        659,\\n        661,\\n        673,\\n        677,\\n        683,\\n        691,\\n        701,\\n        709,\\n        719,\\n        727,\\n        733,\\n        739,\\n        743,\\n        751,\\n        757,\\n        761,\\n        769,\\n        773,\\n        787,\\n        797,\\n        809,\\n        811,\\n        821,\\n        823,\\n        827,\\n        829,\\n        839,\\n        853,\\n        857,\\n        859,\\n        863,\\n        877,\\n        881,\\n        883,\\n        887,\\n        907,\\n        911,\\n        919,\\n        929,\\n        937,\\n        941,\\n        947,\\n        953,\\n        967,\\n        971,\\n        977,\\n        983,\\n        991,\\n        997,\\n    ]\\n\\n    if num in lowPrimes:\\n        return True\\n\\n    for prime in lowPrimes:\\n        if (num % prime) == 0:\\n            return False\\n\\n    return rabinMiller(num)\\n\\n\\ndef generateLargePrime(keysize: int = 1024) -> int:\\n    while True:\\n        num = random.randrange(2 ** (keysize - 1), 2 ** (keysize))\\n        if isPrime(num):\\n            return num\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    num = generateLargePrime()\\n    print((\\\"Prime number:\\\", num))\\n    print((\\\"isPrime:\\\", isPrime(num)))\\n\"",
    "rail fence cipher": "\"\\\"\\\"\\\" https://en.wikipedia.org/wiki/Rail_fence_cipher \\\"\\\"\\\"\\r\\n\\r\\n\\r\\ndef encrypt(input_string: str, key: int) -> str:\\r\\n    \\\"\\\"\\\"\\r\\n    Shuffles the character of a string by placing each of them\\r\\n    in a grid (the height is dependent on the key) in a zigzag\\r\\n    formation and reading it left to right.\\r\\n\\r\\n    >>> encrypt(\\\"Hello World\\\", 4)\\r\\n    'HWe olordll'\\r\\n\\r\\n    >>> encrypt(\\\"This is a message\\\", 0)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Height of grid can't be 0 or negative\\r\\n\\r\\n    >>> encrypt(b\\\"This is a byte string\\\", 5)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    TypeError: sequence item 0: expected str instance, int found\\r\\n    \\\"\\\"\\\"\\r\\n    temp_grid: list[list[str]] = [[] for _ in range(key)]\\r\\n    lowest = key - 1\\r\\n\\r\\n    if key <= 0:\\r\\n        raise ValueError(\\\"Height of grid can't be 0 or negative\\\")\\r\\n    if key == 1 or len(input_string) <= key:\\r\\n        return input_string\\r\\n\\r\\n    for position, character in enumerate(input_string):\\r\\n        num = position % (lowest * 2)  # puts it in bounds\\r\\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\\r\\n        temp_grid[num].append(character)\\r\\n    grid = [\\\"\\\".join(row) for row in temp_grid]\\r\\n    output_string = \\\"\\\".join(grid)\\r\\n\\r\\n    return output_string\\r\\n\\r\\n\\r\\ndef decrypt(input_string: str, key: int) -> str:\\r\\n    \\\"\\\"\\\"\\r\\n    Generates a template based on the key and fills it in with\\r\\n    the characters of the input string and then reading it in\\r\\n    a zigzag formation.\\r\\n\\r\\n    >>> decrypt(\\\"HWe olordll\\\", 4)\\r\\n    'Hello World'\\r\\n\\r\\n    >>> decrypt(\\\"This is a message\\\", -10)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Height of grid can't be 0 or negative\\r\\n\\r\\n    >>> decrypt(\\\"My key is very big\\\", 100)\\r\\n    'My key is very big'\\r\\n    \\\"\\\"\\\"\\r\\n    grid = []\\r\\n    lowest = key - 1\\r\\n\\r\\n    if key <= 0:\\r\\n        raise ValueError(\\\"Height of grid can't be 0 or negative\\\")\\r\\n    if key == 1:\\r\\n        return input_string\\r\\n\\r\\n    temp_grid: list[list[str]] = [[] for _ in range(key)]  # generates template\\r\\n    for position in range(len(input_string)):\\r\\n        num = position % (lowest * 2)  # puts it in bounds\\r\\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\\r\\n        temp_grid[num].append(\\\"*\\\")\\r\\n\\r\\n    counter = 0\\r\\n    for row in temp_grid:  # fills in the characters\\r\\n        splice = input_string[counter : counter + len(row)]\\r\\n        grid.append([character for character in splice])\\r\\n        counter += len(row)\\r\\n\\r\\n    output_string = \\\"\\\"  # reads as zigzag\\r\\n    for position in range(len(input_string)):\\r\\n        num = position % (lowest * 2)  # puts it in bounds\\r\\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\\r\\n        output_string += grid[num][0]\\r\\n        grid[num].pop(0)\\r\\n    return output_string\\r\\n\\r\\n\\r\\ndef bruteforce(input_string: str) -> dict[int, str]:\\r\\n    \\\"\\\"\\\"Uses decrypt function by guessing every key\\r\\n\\r\\n    >>> bruteforce(\\\"HWe olordll\\\")[4]\\r\\n    'Hello World'\\r\\n    \\\"\\\"\\\"\\r\\n    results = {}\\r\\n    for key_guess in range(1, len(input_string)):  # tries every key\\r\\n        results[key_guess] = decrypt(input_string, key_guess)\\r\\n    return results\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "rot13": "\"def dencrypt(s: str, n: int = 13) -> str:\\n    \\\"\\\"\\\"\\n    https://en.wikipedia.org/wiki/ROT13\\n\\n    >>> msg = \\\"My secret bank account number is 173-52946 so don't tell anyone!!\\\"\\n    >>> s = dencrypt(msg)\\n    >>> s\\n    \\\"Zl frperg onax nppbhag ahzore vf 173-52946 fb qba'g gryy nalbar!!\\\"\\n    >>> dencrypt(s) == msg\\n    True\\n    \\\"\\\"\\\"\\n    out = \\\"\\\"\\n    for c in s:\\n        if \\\"A\\\" <= c <= \\\"Z\\\":\\n            out += chr(ord(\\\"A\\\") + (ord(c) - ord(\\\"A\\\") + n) % 26)\\n        elif \\\"a\\\" <= c <= \\\"z\\\":\\n            out += chr(ord(\\\"a\\\") + (ord(c) - ord(\\\"a\\\") + n) % 26)\\n        else:\\n            out += c\\n    return out\\n\\n\\ndef main() -> None:\\n    s0 = input(\\\"Enter message: \\\")\\n\\n    s1 = dencrypt(s0, 13)\\n    print(\\\"Encryption:\\\", s1)\\n\\n    s2 = dencrypt(s1, 13)\\n    print(\\\"Decryption: \\\", s2)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "rsa cipher": "\"import os\\nimport sys\\n\\nfrom . import rsa_key_generator as rkg\\n\\nDEFAULT_BLOCK_SIZE = 128\\nBYTE_SIZE = 256\\n\\n\\ndef get_blocks_from_text(\\n    message: str, block_size: int = DEFAULT_BLOCK_SIZE\\n) -> list[int]:\\n    message_bytes = message.encode(\\\"ascii\\\")\\n\\n    block_ints = []\\n    for block_start in range(0, len(message_bytes), block_size):\\n        block_int = 0\\n        for i in range(block_start, min(block_start + block_size, len(message_bytes))):\\n            block_int += message_bytes[i] * (BYTE_SIZE ** (i % block_size))\\n        block_ints.append(block_int)\\n    return block_ints\\n\\n\\ndef get_text_from_blocks(\\n    block_ints: list[int], message_length: int, block_size: int = DEFAULT_BLOCK_SIZE\\n) -> str:\\n    message: list[str] = []\\n    for block_int in block_ints:\\n        block_message: list[str] = []\\n        for i in range(block_size - 1, -1, -1):\\n            if len(message) + i < message_length:\\n                ascii_number = block_int // (BYTE_SIZE ** i)\\n                block_int = block_int % (BYTE_SIZE ** i)\\n                block_message.insert(0, chr(ascii_number))\\n        message.extend(block_message)\\n    return \\\"\\\".join(message)\\n\\n\\ndef encrypt_message(\\n    message: str, key: tuple[int, int], blockSize: int = DEFAULT_BLOCK_SIZE\\n) -> list[int]:\\n    encrypted_blocks = []\\n    n, e = key\\n\\n    for block in get_blocks_from_text(message, blockSize):\\n        encrypted_blocks.append(pow(block, e, n))\\n    return encrypted_blocks\\n\\n\\ndef decrypt_message(\\n    encrypted_blocks: list[int],\\n    message_length: int,\\n    key: tuple[int, int],\\n    block_size: int = DEFAULT_BLOCK_SIZE,\\n) -> str:\\n    decrypted_blocks = []\\n    n, d = key\\n    for block in encrypted_blocks:\\n        decrypted_blocks.append(pow(block, d, n))\\n    return get_text_from_blocks(decrypted_blocks, message_length, block_size)\\n\\n\\ndef read_key_file(key_filename: str) -> tuple[int, int, int]:\\n    with open(key_filename) as fo:\\n        content = fo.read()\\n    key_size, n, EorD = content.split(\\\",\\\")\\n    return (int(key_size), int(n), int(EorD))\\n\\n\\ndef encrypt_and_write_to_file(\\n    message_filename: str,\\n    key_filename: str,\\n    message: str,\\n    block_size: int = DEFAULT_BLOCK_SIZE,\\n) -> str:\\n    key_size, n, e = read_key_file(key_filename)\\n    if key_size < block_size * 8:\\n        sys.exit(\\n            \\\"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \\\"\\n            \\\"requires the block size to be equal to or greater than the key size. \\\"\\n            \\\"Either decrease the block size or use different keys.\\\"\\n            % (block_size * 8, key_size)\\n        )\\n\\n    encrypted_blocks = [str(i) for i in encrypt_message(message, (n, e), block_size)]\\n\\n    encrypted_content = \\\",\\\".join(encrypted_blocks)\\n    encrypted_content = f\\\"{len(message)}_{block_size}_{encrypted_content}\\\"\\n    with open(message_filename, \\\"w\\\") as fo:\\n        fo.write(encrypted_content)\\n    return encrypted_content\\n\\n\\ndef read_from_file_and_decrypt(message_filename: str, key_filename: str) -> str:\\n    key_size, n, d = read_key_file(key_filename)\\n    with open(message_filename) as fo:\\n        content = fo.read()\\n    message_length_str, block_size_str, encrypted_message = content.split(\\\"_\\\")\\n    message_length = int(message_length_str)\\n    block_size = int(block_size_str)\\n\\n    if key_size < block_size * 8:\\n        sys.exit(\\n            \\\"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \\\"\\n            \\\"requires the block size to be equal to or greater than the key size. \\\"\\n            \\\"Did you specify the correct key file and encrypted file?\\\"\\n            % (block_size * 8, key_size)\\n        )\\n\\n    encrypted_blocks = []\\n    for block in encrypted_message.split(\\\",\\\"):\\n        encrypted_blocks.append(int(block))\\n\\n    return decrypt_message(encrypted_blocks, message_length, (n, d), block_size)\\n\\n\\ndef main() -> None:\\n    filename = \\\"encrypted_file.txt\\\"\\n    response = input(r\\\"Encrypt\\\\Decrypt [e\\\\d]: \\\")\\n\\n    if response.lower().startswith(\\\"e\\\"):\\n        mode = \\\"encrypt\\\"\\n    elif response.lower().startswith(\\\"d\\\"):\\n        mode = \\\"decrypt\\\"\\n\\n    if mode == \\\"encrypt\\\":\\n        if not os.path.exists(\\\"rsa_pubkey.txt\\\"):\\n            rkg.makeKeyFiles(\\\"rsa\\\", 1024)\\n\\n        message = input(\\\"\\\\nEnter message: \\\")\\n        pubkey_filename = \\\"rsa_pubkey.txt\\\"\\n        print(\\\"Encrypting and writing to %s...\\\" % (filename))\\n        encryptedText = encrypt_and_write_to_file(filename, pubkey_filename, message)\\n\\n        print(\\\"\\\\nEncrypted text:\\\")\\n        print(encryptedText)\\n\\n    elif mode == \\\"decrypt\\\":\\n        privkey_filename = \\\"rsa_privkey.txt\\\"\\n        print(\\\"Reading from %s and decrypting...\\\" % (filename))\\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\\n        print(\\\"writing decryption to rsa_decryption.txt...\\\")\\n        with open(\\\"rsa_decryption.txt\\\", \\\"w\\\") as dec:\\n            dec.write(decrypted_text)\\n\\n        print(\\\"\\\\nDecryption:\\\")\\n        print(decrypted_text)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "rsa factorization": "\"\\\"\\\"\\\"\\r\\nAn RSA prime factor algorithm.\\r\\n\\r\\nThe program can efficiently factor RSA prime number given the private key d and\\r\\npublic key e.\\r\\nSource: on page 3 of https://crypto.stanford.edu/~dabo/papers/RSA-survey.pdf\\r\\nMore readable source: https://www.di-mgt.com.au/rsa_factorize_n.html\\r\\nlarge number can take minutes to factor, therefore are not included in doctest.\\r\\n\\\"\\\"\\\"\\r\\nfrom __future__ import annotations\\r\\n\\r\\nimport math\\r\\nimport random\\r\\n\\r\\n\\r\\ndef rsafactor(d: int, e: int, N: int) -> list[int]:\\r\\n    \\\"\\\"\\\"\\r\\n    This function returns the factors of N, where p*q=N\\r\\n      Return: [p, q]\\r\\n\\r\\n    We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.\\r\\n    The pair (N, e) is the public key. As its name suggests, it is public and is used to\\r\\n        encrypt messages.\\r\\n    The pair (N, d) is the secret key or private key and is known only to the recipient\\r\\n        of encrypted messages.\\r\\n\\r\\n    >>> rsafactor(3, 16971, 25777)\\r\\n    [149, 173]\\r\\n    >>> rsafactor(7331, 11, 27233)\\r\\n    [113, 241]\\r\\n    >>> rsafactor(4021, 13, 17711)\\r\\n    [89, 199]\\r\\n    \\\"\\\"\\\"\\r\\n    k = d * e - 1\\r\\n    p = 0\\r\\n    q = 0\\r\\n    while p == 0:\\r\\n        g = random.randint(2, N - 1)\\r\\n        t = k\\r\\n        while True:\\r\\n            if t % 2 == 0:\\r\\n                t = t // 2\\r\\n                x = (g ** t) % N\\r\\n                y = math.gcd(x - 1, N)\\r\\n                if x > 1 and y > 1:\\r\\n                    p = y\\r\\n                    q = N // y\\r\\n                    break  # find the correct factors\\r\\n            else:\\r\\n                break  # t is not divisible by 2, break and choose another g\\r\\n    return sorted([p, q])\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "rsa key generator": "\"import os\\nimport random\\nimport sys\\n\\nfrom . import cryptomath_module as cryptoMath\\nfrom . import rabin_miller as rabinMiller\\n\\n\\ndef main() -> None:\\n    print(\\\"Making key files...\\\")\\n    makeKeyFiles(\\\"rsa\\\", 1024)\\n    print(\\\"Key files generation successful.\\\")\\n\\n\\ndef generateKey(keySize: int) -> tuple[tuple[int, int], tuple[int, int]]:\\n    print(\\\"Generating prime p...\\\")\\n    p = rabinMiller.generateLargePrime(keySize)\\n    print(\\\"Generating prime q...\\\")\\n    q = rabinMiller.generateLargePrime(keySize)\\n    n = p * q\\n\\n    print(\\\"Generating e that is relatively prime to (p - 1) * (q - 1)...\\\")\\n    while True:\\n        e = random.randrange(2 ** (keySize - 1), 2 ** (keySize))\\n        if cryptoMath.gcd(e, (p - 1) * (q - 1)) == 1:\\n            break\\n\\n    print(\\\"Calculating d that is mod inverse of e...\\\")\\n    d = cryptoMath.find_mod_inverse(e, (p - 1) * (q - 1))\\n\\n    publicKey = (n, e)\\n    privateKey = (n, d)\\n    return (publicKey, privateKey)\\n\\n\\ndef makeKeyFiles(name: str, keySize: int) -> None:\\n    if os.path.exists(\\\"%s_pubkey.txt\\\" % (name)) or os.path.exists(\\n        \\\"%s_privkey.txt\\\" % (name)\\n    ):\\n        print(\\\"\\\\nWARNING:\\\")\\n        print(\\n            '\\\"%s_pubkey.txt\\\" or \\\"%s_privkey.txt\\\" already exists. \\\\n'\\n            \\\"Use a different name or delete these files and re-run this program.\\\"\\n            % (name, name)\\n        )\\n        sys.exit()\\n\\n    publicKey, privateKey = generateKey(keySize)\\n    print(\\\"\\\\nWriting public key to file %s_pubkey.txt...\\\" % name)\\n    with open(\\\"%s_pubkey.txt\\\" % name, \\\"w\\\") as out_file:\\n        out_file.write(f\\\"{keySize},{publicKey[0]},{publicKey[1]}\\\")\\n\\n    print(\\\"Writing private key to file %s_privkey.txt...\\\" % name)\\n    with open(\\\"%s_privkey.txt\\\" % name, \\\"w\\\") as out_file:\\n        out_file.write(f\\\"{keySize},{privateKey[0]},{privateKey[1]}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "shuffled shift cipher": "\"from __future__ import annotations\\n\\nimport random\\nimport string\\n\\n\\nclass ShuffledShiftCipher:\\n    \\\"\\\"\\\"\\n    This algorithm uses the Caesar Cipher algorithm but removes the option to\\n    use brute force to decrypt the message.\\n\\n    The passcode is a a random password from the selection buffer of\\n    1. uppercase letters of the English alphabet\\n    2. lowercase letters of the English alphabet\\n    3. digits from 0 to 9\\n\\n    Using unique characters from the passcode, the normal list of characters,\\n    that can be allowed in the plaintext, is pivoted and shuffled. Refer to docstring\\n    of __make_key_list() to learn more about the shuffling.\\n\\n    Then, using the passcode, a number is calculated which is used to encrypt the\\n    plaintext message with the normal shift cipher method, only in this case, the\\n    reference, to look back at while decrypting, is shuffled.\\n\\n    Each cipher object can possess an optional argument as passcode, without which a\\n    new passcode is generated for that object automatically.\\n    cip1 = ShuffledShiftCipher('d4usr9TWxw9wMD')\\n    cip2 = ShuffledShiftCipher()\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, passcode: str | None = None) -> None:\\n        \\\"\\\"\\\"\\n        Initializes a cipher object with a passcode as it's entity\\n        Note: No new passcode is generated if user provides a passcode\\n        while creating the object\\n        \\\"\\\"\\\"\\n        self.__passcode = passcode or self.__passcode_creator()\\n        self.__key_list = self.__make_key_list()\\n        self.__shift_key = self.__make_shift_key()\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"\\n        :return: passcode of the cipher object\\n        \\\"\\\"\\\"\\n        return \\\"Passcode is: \\\" + \\\"\\\".join(self.__passcode)\\n\\n    def __neg_pos(self, iterlist: list[int]) -> list[int]:\\n        \\\"\\\"\\\"\\n        Mutates the list by changing the sign of each alternate element\\n\\n        :param iterlist: takes a list iterable\\n        :return: the mutated list\\n\\n        \\\"\\\"\\\"\\n        for i in range(1, len(iterlist), 2):\\n            iterlist[i] *= -1\\n        return iterlist\\n\\n    def __passcode_creator(self) -> list[str]:\\n        \\\"\\\"\\\"\\n        Creates a random password from the selection buffer of\\n        1. uppercase letters of the English alphabet\\n        2. lowercase letters of the English alphabet\\n        3. digits from 0 to 9\\n\\n        :rtype: list\\n        :return: a password of a random length between 10 to 20\\n        \\\"\\\"\\\"\\n        choices = string.ascii_letters + string.digits\\n        password = [random.choice(choices) for _ in range(random.randint(10, 20))]\\n        return password\\n\\n    def __make_key_list(self) -> list[str]:\\n        \\\"\\\"\\\"\\n        Shuffles the ordered character choices by pivoting at breakpoints\\n        Breakpoints are the set of characters in the passcode\\n\\n        eg:\\n            if, ABCDEFGHIJKLMNOPQRSTUVWXYZ are the possible characters\\n            and CAMERA is the passcode\\n            then, breakpoints = [A,C,E,M,R] # sorted set of characters from passcode\\n            shuffled parts: [A,CB,ED,MLKJIHGF,RQPON,ZYXWVUTS]\\n            shuffled __key_list : ACBEDMLKJIHGFRQPONZYXWVUTS\\n\\n        Shuffling only 26 letters of the english alphabet can generate 26!\\n        combinations for the shuffled list. In the program we consider, a set of\\n        97 characters (including letters, digits, punctuation and whitespaces),\\n        thereby creating a possibility of 97! combinations (which is a 152 digit number\\n        in itself), thus diminishing the possibility of a brute force approach.\\n        Moreover, shift keys even introduce a multiple of 26 for a brute force approach\\n        for each of the already 97! combinations.\\n        \\\"\\\"\\\"\\n        # key_list_options contain nearly all printable except few elements from\\n        # string.whitespace\\n        key_list_options = (\\n            string.ascii_letters + string.digits + string.punctuation + \\\" \\\\t\\\\n\\\"\\n        )\\n\\n        keys_l = []\\n\\n        # creates points known as breakpoints to break the key_list_options at those\\n        # points and pivot each substring\\n        breakpoints = sorted(set(self.__passcode))\\n        temp_list: list[str] = []\\n\\n        # algorithm for creating a new shuffled list, keys_l, out of key_list_options\\n        for i in key_list_options:\\n            temp_list.extend(i)\\n\\n            # checking breakpoints at which to pivot temporary sublist and add it into\\n            # keys_l\\n            if i in breakpoints or i == key_list_options[-1]:\\n                keys_l.extend(temp_list[::-1])\\n                temp_list.clear()\\n\\n        # returning a shuffled keys_l to prevent brute force guessing of shift key\\n        return keys_l\\n\\n    def __make_shift_key(self) -> int:\\n        \\\"\\\"\\\"\\n        sum() of the mutated list of ascii values of all characters where the\\n        mutated list is the one returned by __neg_pos()\\n        \\\"\\\"\\\"\\n        num = sum(self.__neg_pos([ord(x) for x in self.__passcode]))\\n        return num if num > 0 else len(self.__passcode)\\n\\n    def decrypt(self, encoded_message: str) -> str:\\n        \\\"\\\"\\\"\\n        Performs shifting of the encoded_message w.r.t. the shuffled __key_list\\n        to create the decoded_message\\n\\n        >>> ssc = ShuffledShiftCipher('4PYIXyqeQZr44')\\n        >>> ssc.decrypt(\\\"d>**-1z6&'5z'5z:z+-='$'>=zp:>5:#z<'.&>#\\\")\\n        'Hello, this is a modified Caesar cipher'\\n\\n        \\\"\\\"\\\"\\n        decoded_message = \\\"\\\"\\n\\n        # decoding shift like Caesar cipher algorithm implementing negative shift or\\n        # reverse shift or left shift\\n        for i in encoded_message:\\n            position = self.__key_list.index(i)\\n            decoded_message += self.__key_list[\\n                (position - self.__shift_key) % -len(self.__key_list)\\n            ]\\n\\n        return decoded_message\\n\\n    def encrypt(self, plaintext: str) -> str:\\n        \\\"\\\"\\\"\\n        Performs shifting of the plaintext w.r.t. the shuffled __key_list\\n        to create the encoded_message\\n\\n        >>> ssc = ShuffledShiftCipher('4PYIXyqeQZr44')\\n        >>> ssc.encrypt('Hello, this is a modified Caesar cipher')\\n        \\\"d>**-1z6&'5z'5z:z+-='$'>=zp:>5:#z<'.&>#\\\"\\n\\n        \\\"\\\"\\\"\\n        encoded_message = \\\"\\\"\\n\\n        # encoding shift like Caesar cipher algorithm implementing positive shift or\\n        # forward shift or right shift\\n        for i in plaintext:\\n            position = self.__key_list.index(i)\\n            encoded_message += self.__key_list[\\n                (position + self.__shift_key) % len(self.__key_list)\\n            ]\\n\\n        return encoded_message\\n\\n\\ndef test_end_to_end(msg: str = \\\"Hello, this is a modified Caesar cipher\\\") -> str:\\n    \\\"\\\"\\\"\\n    >>> test_end_to_end()\\n    'Hello, this is a modified Caesar cipher'\\n    \\\"\\\"\\\"\\n    cip1 = ShuffledShiftCipher()\\n    return cip1.decrypt(cip1.encrypt(msg))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "simple keyword cypher": "\"def remove_duplicates(key: str) -> str:\\n    \\\"\\\"\\\"\\n    Removes duplicate alphabetic characters in a keyword (letter is ignored after its\\n        first appearance).\\n    :param key: Keyword to use\\n    :return: String with duplicates removed\\n    >>> remove_duplicates('Hello World!!')\\n    'Helo Wrd'\\n    \\\"\\\"\\\"\\n\\n    key_no_dups = \\\"\\\"\\n    for ch in key:\\n        if ch == \\\" \\\" or ch not in key_no_dups and ch.isalpha():\\n            key_no_dups += ch\\n    return key_no_dups\\n\\n\\ndef create_cipher_map(key: str) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Returns a cipher map given a keyword.\\n    :param key: keyword to use\\n    :return: dictionary cipher map\\n    \\\"\\\"\\\"\\n    # Create alphabet list\\n    alphabet = [chr(i + 65) for i in range(26)]\\n    # Remove duplicate characters from key\\n    key = remove_duplicates(key.upper())\\n    offset = len(key)\\n    # First fill cipher with key characters\\n    cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}\\n    # Then map remaining characters in alphabet to\\n    # the alphabet from the beginning\\n    for i in range(len(cipher_alphabet), 26):\\n        char = alphabet[i - offset]\\n        # Ensure we are not mapping letters to letters previously mapped\\n        while char in key:\\n            offset -= 1\\n            char = alphabet[i - offset]\\n        cipher_alphabet[alphabet[i]] = char\\n    return cipher_alphabet\\n\\n\\ndef encipher(message: str, cipher_map: dict[str, str]) -> str:\\n    \\\"\\\"\\\"\\n    Enciphers a message given a cipher map.\\n    :param message: Message to encipher\\n    :param cipher_map: Cipher map\\n    :return: enciphered string\\n    >>> encipher('Hello World!!', create_cipher_map('Goodbye!!'))\\n    'CYJJM VMQJB!!'\\n    \\\"\\\"\\\"\\n    return \\\"\\\".join(cipher_map.get(ch, ch) for ch in message.upper())\\n\\n\\ndef decipher(message: str, cipher_map: dict[str, str]) -> str:\\n    \\\"\\\"\\\"\\n    Deciphers a message given a cipher map\\n    :param message: Message to decipher\\n    :param cipher_map: Dictionary mapping to use\\n    :return: Deciphered string\\n    >>> cipher_map = create_cipher_map('Goodbye!!')\\n    >>> decipher(encipher('Hello World!!', cipher_map), cipher_map)\\n    'HELLO WORLD!!'\\n    \\\"\\\"\\\"\\n    # Reverse our cipher mappings\\n    rev_cipher_map = {v: k for k, v in cipher_map.items()}\\n    return \\\"\\\".join(rev_cipher_map.get(ch, ch) for ch in message.upper())\\n\\n\\ndef main() -> None:\\n    \\\"\\\"\\\"\\n    Handles I/O\\n    :return: void\\n    \\\"\\\"\\\"\\n    message = input(\\\"Enter message to encode or decode: \\\").strip()\\n    key = input(\\\"Enter keyword: \\\").strip()\\n    option = input(\\\"Encipher or decipher? E/D:\\\").strip()[0].lower()\\n    try:\\n        func = {\\\"e\\\": encipher, \\\"d\\\": decipher}[option]\\n    except KeyError:\\n        raise KeyError(\\\"invalid input option\\\")\\n    cipher_map = create_cipher_map(key)\\n    print(func(message, cipher_map))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "simple substitution cipher": "\"import random\\nimport sys\\n\\nLETTERS = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\n\\n\\ndef main() -> None:\\n    message = input(\\\"Enter message: \\\")\\n    key = \\\"LFWOAYUISVKMNXPBDCRJTQEGHZ\\\"\\n    resp = input(\\\"Encrypt/Decrypt [e/d]: \\\")\\n\\n    checkValidKey(key)\\n\\n    if resp.lower().startswith(\\\"e\\\"):\\n        mode = \\\"encrypt\\\"\\n        translated = encryptMessage(key, message)\\n    elif resp.lower().startswith(\\\"d\\\"):\\n        mode = \\\"decrypt\\\"\\n        translated = decryptMessage(key, message)\\n\\n    print(f\\\"\\\\n{mode.title()}ion: \\\\n{translated}\\\")\\n\\n\\ndef checkValidKey(key: str) -> None:\\n    keyList = list(key)\\n    lettersList = list(LETTERS)\\n    keyList.sort()\\n    lettersList.sort()\\n\\n    if keyList != lettersList:\\n        sys.exit(\\\"Error in the key or symbol set.\\\")\\n\\n\\ndef encryptMessage(key: str, message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> encryptMessage('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Harshil Darji')\\n    'Ilcrism Olcvs'\\n    \\\"\\\"\\\"\\n    return translateMessage(key, message, \\\"encrypt\\\")\\n\\n\\ndef decryptMessage(key: str, message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> decryptMessage('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Ilcrism Olcvs')\\n    'Harshil Darji'\\n    \\\"\\\"\\\"\\n    return translateMessage(key, message, \\\"decrypt\\\")\\n\\n\\ndef translateMessage(key: str, message: str, mode: str) -> str:\\n    translated = \\\"\\\"\\n    charsA = LETTERS\\n    charsB = key\\n\\n    if mode == \\\"decrypt\\\":\\n        charsA, charsB = charsB, charsA\\n\\n    for symbol in message:\\n        if symbol.upper() in charsA:\\n            symIndex = charsA.find(symbol.upper())\\n            if symbol.isupper():\\n                translated += charsB[symIndex].upper()\\n            else:\\n                translated += charsB[symIndex].lower()\\n        else:\\n            translated += symbol\\n\\n    return translated\\n\\n\\ndef getRandomKey() -> str:\\n    key = list(LETTERS)\\n    random.shuffle(key)\\n    return \\\"\\\".join(key)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "trafid cipher": "\"# https://en.wikipedia.org/wiki/Trifid_cipher\\r\\nfrom __future__ import annotations\\r\\n\\r\\n\\r\\ndef __encryptPart(messagePart: str, character2Number: dict[str, str]) -> str:\\r\\n    one, two, three = \\\"\\\", \\\"\\\", \\\"\\\"\\r\\n    tmp = []\\r\\n\\r\\n    for character in messagePart:\\r\\n        tmp.append(character2Number[character])\\r\\n\\r\\n    for each in tmp:\\r\\n        one += each[0]\\r\\n        two += each[1]\\r\\n        three += each[2]\\r\\n\\r\\n    return one + two + three\\r\\n\\r\\n\\r\\ndef __decryptPart(\\r\\n    messagePart: str, character2Number: dict[str, str]\\r\\n) -> tuple[str, str, str]:\\r\\n    tmp, thisPart = \\\"\\\", \\\"\\\"\\r\\n    result = []\\r\\n\\r\\n    for character in messagePart:\\r\\n        thisPart += character2Number[character]\\r\\n\\r\\n    for digit in thisPart:\\r\\n        tmp += digit\\r\\n        if len(tmp) == len(messagePart):\\r\\n            result.append(tmp)\\r\\n            tmp = \\\"\\\"\\r\\n\\r\\n    return result[0], result[1], result[2]\\r\\n\\r\\n\\r\\ndef __prepare(\\r\\n    message: str, alphabet: str\\r\\n) -> tuple[str, str, dict[str, str], dict[str, str]]:\\r\\n    # Validate message and alphabet, set to upper and remove spaces\\r\\n    alphabet = alphabet.replace(\\\" \\\", \\\"\\\").upper()\\r\\n    message = message.replace(\\\" \\\", \\\"\\\").upper()\\r\\n\\r\\n    # Check length and characters\\r\\n    if len(alphabet) != 27:\\r\\n        raise KeyError(\\\"Length of alphabet has to be 27.\\\")\\r\\n    for each in message:\\r\\n        if each not in alphabet:\\r\\n            raise ValueError(\\\"Each message character has to be included in alphabet!\\\")\\r\\n\\r\\n    # Generate dictionares\\r\\n    numbers = (\\r\\n        \\\"111\\\",\\r\\n        \\\"112\\\",\\r\\n        \\\"113\\\",\\r\\n        \\\"121\\\",\\r\\n        \\\"122\\\",\\r\\n        \\\"123\\\",\\r\\n        \\\"131\\\",\\r\\n        \\\"132\\\",\\r\\n        \\\"133\\\",\\r\\n        \\\"211\\\",\\r\\n        \\\"212\\\",\\r\\n        \\\"213\\\",\\r\\n        \\\"221\\\",\\r\\n        \\\"222\\\",\\r\\n        \\\"223\\\",\\r\\n        \\\"231\\\",\\r\\n        \\\"232\\\",\\r\\n        \\\"233\\\",\\r\\n        \\\"311\\\",\\r\\n        \\\"312\\\",\\r\\n        \\\"313\\\",\\r\\n        \\\"321\\\",\\r\\n        \\\"322\\\",\\r\\n        \\\"323\\\",\\r\\n        \\\"331\\\",\\r\\n        \\\"332\\\",\\r\\n        \\\"333\\\",\\r\\n    )\\r\\n    character2Number = {}\\r\\n    number2Character = {}\\r\\n    for letter, number in zip(alphabet, numbers):\\r\\n        character2Number[letter] = number\\r\\n        number2Character[number] = letter\\r\\n\\r\\n    return message, alphabet, character2Number, number2Character\\r\\n\\r\\n\\r\\ndef encryptMessage(\\r\\n    message: str, alphabet: str = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\\\", period: int = 5\\r\\n) -> str:\\r\\n    message, alphabet, character2Number, number2Character = __prepare(message, alphabet)\\r\\n    encrypted, encrypted_numeric = \\\"\\\", \\\"\\\"\\r\\n\\r\\n    for i in range(0, len(message) + 1, period):\\r\\n        encrypted_numeric += __encryptPart(message[i : i + period], character2Number)\\r\\n\\r\\n    for i in range(0, len(encrypted_numeric), 3):\\r\\n        encrypted += number2Character[encrypted_numeric[i : i + 3]]\\r\\n\\r\\n    return encrypted\\r\\n\\r\\n\\r\\ndef decryptMessage(\\r\\n    message: str, alphabet: str = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\\\", period: int = 5\\r\\n) -> str:\\r\\n    message, alphabet, character2Number, number2Character = __prepare(message, alphabet)\\r\\n    decrypted_numeric = []\\r\\n    decrypted = \\\"\\\"\\r\\n\\r\\n    for i in range(0, len(message) + 1, period):\\r\\n        a, b, c = __decryptPart(message[i : i + period], character2Number)\\r\\n\\r\\n        for j in range(0, len(a)):\\r\\n            decrypted_numeric.append(a[j] + b[j] + c[j])\\r\\n\\r\\n    for each in decrypted_numeric:\\r\\n        decrypted += number2Character[each]\\r\\n\\r\\n    return decrypted\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    msg = \\\"DEFEND THE EAST WALL OF THE CASTLE.\\\"\\r\\n    encrypted = encryptMessage(msg, \\\"EPSDUCVWYM.ZLKXNBTFGORIJHAQ\\\")\\r\\n    decrypted = decryptMessage(encrypted, \\\"EPSDUCVWYM.ZLKXNBTFGORIJHAQ\\\")\\r\\n    print(f\\\"Encrypted: {encrypted}\\\\nDecrypted: {decrypted}\\\")\\r\\n\"",
    "transposition cipher": "\"import math\\n\\n\\\"\\\"\\\"\\nIn cryptography, the TRANSPOSITION cipher is a method of encryption where the\\npositions of plaintext are shifted a certain number(determined by the key) that\\nfollows a regular system that results in the permuted text, known as the encrypted\\ntext. The type of transposition cipher demonstrated under is the ROUTE cipher.\\n\\\"\\\"\\\"\\n\\n\\ndef main() -> None:\\n    message = input(\\\"Enter message: \\\")\\n    key = int(input(\\\"Enter key [2-%s]: \\\" % (len(message) - 1)))\\n    mode = input(\\\"Encryption/Decryption [e/d]: \\\")\\n\\n    if mode.lower().startswith(\\\"e\\\"):\\n        text = encryptMessage(key, message)\\n    elif mode.lower().startswith(\\\"d\\\"):\\n        text = decryptMessage(key, message)\\n\\n    # Append pipe symbol (vertical bar) to identify spaces at the end.\\n    print(\\\"Output:\\\\n%s\\\" % (text + \\\"|\\\"))\\n\\n\\ndef encryptMessage(key: int, message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> encryptMessage(6, 'Harshil Darji')\\n    'Hlia rDsahrij'\\n    \\\"\\\"\\\"\\n    cipherText = [\\\"\\\"] * key\\n    for col in range(key):\\n        pointer = col\\n        while pointer < len(message):\\n            cipherText[col] += message[pointer]\\n            pointer += key\\n    return \\\"\\\".join(cipherText)\\n\\n\\ndef decryptMessage(key: int, message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> decryptMessage(6, 'Hlia rDsahrij')\\n    'Harshil Darji'\\n    \\\"\\\"\\\"\\n    numCols = math.ceil(len(message) / key)\\n    numRows = key\\n    numShadedBoxes = (numCols * numRows) - len(message)\\n    plainText = [\\\"\\\"] * numCols\\n    col = 0\\n    row = 0\\n\\n    for symbol in message:\\n        plainText[col] += symbol\\n        col += 1\\n\\n        if (\\n            (col == numCols)\\n            or (col == numCols - 1)\\n            and (row >= numRows - numShadedBoxes)\\n        ):\\n            col = 0\\n            row += 1\\n\\n    return \\\"\\\".join(plainText)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "transposition cipher encrypt decrypt file": "\"import os\\nimport sys\\nimport time\\n\\nfrom . import transposition_cipher as transCipher\\n\\n\\ndef main() -> None:\\n    inputFile = \\\"Prehistoric Men.txt\\\"\\n    outputFile = \\\"Output.txt\\\"\\n    key = int(input(\\\"Enter key: \\\"))\\n    mode = input(\\\"Encrypt/Decrypt [e/d]: \\\")\\n\\n    if not os.path.exists(inputFile):\\n        print(\\\"File %s does not exist. Quitting...\\\" % inputFile)\\n        sys.exit()\\n    if os.path.exists(outputFile):\\n        print(\\\"Overwrite %s? [y/n]\\\" % outputFile)\\n        response = input(\\\"> \\\")\\n        if not response.lower().startswith(\\\"y\\\"):\\n            sys.exit()\\n\\n    startTime = time.time()\\n    if mode.lower().startswith(\\\"e\\\"):\\n        with open(inputFile) as f:\\n            content = f.read()\\n        translated = transCipher.encryptMessage(key, content)\\n    elif mode.lower().startswith(\\\"d\\\"):\\n        with open(outputFile) as f:\\n            content = f.read()\\n        translated = transCipher.decryptMessage(key, content)\\n\\n    with open(outputFile, \\\"w\\\") as outputObj:\\n        outputObj.write(translated)\\n\\n    totalTime = round(time.time() - startTime, 2)\\n    print((\\\"Done (\\\", totalTime, \\\"seconds )\\\"))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "vigenere cipher": "\"LETTERS = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\n\\n\\ndef main() -> None:\\n    message = input(\\\"Enter message: \\\")\\n    key = input(\\\"Enter key [alphanumeric]: \\\")\\n    mode = input(\\\"Encrypt/Decrypt [e/d]: \\\")\\n\\n    if mode.lower().startswith(\\\"e\\\"):\\n        mode = \\\"encrypt\\\"\\n        translated = encryptMessage(key, message)\\n    elif mode.lower().startswith(\\\"d\\\"):\\n        mode = \\\"decrypt\\\"\\n        translated = decryptMessage(key, message)\\n\\n    print(\\\"\\\\n%sed message:\\\" % mode.title())\\n    print(translated)\\n\\n\\ndef encryptMessage(key: str, message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> encryptMessage('HDarji', 'This is Harshil Darji from Dharmaj.')\\n    'Akij ra Odrjqqs Gaisq muod Mphumrs.'\\n    \\\"\\\"\\\"\\n    return translateMessage(key, message, \\\"encrypt\\\")\\n\\n\\ndef decryptMessage(key: str, message: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> decryptMessage('HDarji', 'Akij ra Odrjqqs Gaisq muod Mphumrs.')\\n    'This is Harshil Darji from Dharmaj.'\\n    \\\"\\\"\\\"\\n    return translateMessage(key, message, \\\"decrypt\\\")\\n\\n\\ndef translateMessage(key: str, message: str, mode: str) -> str:\\n    translated = []\\n    keyIndex = 0\\n    key = key.upper()\\n\\n    for symbol in message:\\n        num = LETTERS.find(symbol.upper())\\n        if num != -1:\\n            if mode == \\\"encrypt\\\":\\n                num += LETTERS.find(key[keyIndex])\\n            elif mode == \\\"decrypt\\\":\\n                num -= LETTERS.find(key[keyIndex])\\n\\n            num %= len(LETTERS)\\n\\n            if symbol.isupper():\\n                translated.append(LETTERS[num])\\n            elif symbol.islower():\\n                translated.append(LETTERS[num].lower())\\n\\n            keyIndex += 1\\n            if keyIndex == len(key):\\n                keyIndex = 0\\n        else:\\n            translated.append(symbol)\\n    return \\\"\\\".join(translated)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "xor cipher": "\"\\\"\\\"\\\"\\n        author: Christian Bender\\n        date: 21.12.2017\\n        class: XORCipher\\n\\n        This class implements the XOR-cipher algorithm and provides\\n        some useful methods for encrypting and decrypting strings and\\n        files.\\n\\n        Overview about methods\\n\\n        - encrypt : list of char\\n        - decrypt : list of char\\n        - encrypt_string : str\\n        - decrypt_string : str\\n        - encrypt_file : boolean\\n        - decrypt_file : boolean\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\nclass XORCipher:\\n    def __init__(self, key: int = 0):\\n        \\\"\\\"\\\"\\n        simple constructor that receives a key or uses\\n        default key = 0\\n        \\\"\\\"\\\"\\n\\n        # private field\\n        self.__key = key\\n\\n    def encrypt(self, content: str, key: int) -> list[str]:\\n        \\\"\\\"\\\"\\n        input: 'content' of type string and 'key' of type int\\n        output: encrypted string 'content' as a list of chars\\n        if key not passed the method uses the key by the constructor.\\n        otherwise key = 1\\n        \\\"\\\"\\\"\\n\\n        # precondition\\n        assert isinstance(key, int) and isinstance(content, str)\\n\\n        key = key or self.__key or 1\\n\\n        # make sure key is an appropriate size\\n        key %= 255\\n\\n        return [chr(ord(ch) ^ key) for ch in content]\\n\\n    def decrypt(self, content: str, key: int) -> list[str]:\\n        \\\"\\\"\\\"\\n        input: 'content' of type list and 'key' of type int\\n        output: decrypted string 'content' as a list of chars\\n        if key not passed the method uses the key by the constructor.\\n        otherwise key = 1\\n        \\\"\\\"\\\"\\n\\n        # precondition\\n        assert isinstance(key, int) and isinstance(content, list)\\n\\n        key = key or self.__key or 1\\n\\n        # make sure key is an appropriate size\\n        key %= 255\\n\\n        return [chr(ord(ch) ^ key) for ch in content]\\n\\n    def encrypt_string(self, content: str, key: int = 0) -> str:\\n        \\\"\\\"\\\"\\n        input: 'content' of type string and 'key' of type int\\n        output: encrypted string 'content'\\n        if key not passed the method uses the key by the constructor.\\n        otherwise key = 1\\n        \\\"\\\"\\\"\\n\\n        # precondition\\n        assert isinstance(key, int) and isinstance(content, str)\\n\\n        key = key or self.__key or 1\\n\\n        # make sure key can be any size\\n        while key > 255:\\n            key -= 255\\n\\n        # This will be returned\\n        ans = \\\"\\\"\\n\\n        for ch in content:\\n            ans += chr(ord(ch) ^ key)\\n\\n        return ans\\n\\n    def decrypt_string(self, content: str, key: int = 0) -> str:\\n        \\\"\\\"\\\"\\n        input: 'content' of type string and 'key' of type int\\n        output: decrypted string 'content'\\n        if key not passed the method uses the key by the constructor.\\n        otherwise key = 1\\n        \\\"\\\"\\\"\\n\\n        # precondition\\n        assert isinstance(key, int) and isinstance(content, str)\\n\\n        key = key or self.__key or 1\\n\\n        # make sure key can be any size\\n        while key > 255:\\n            key -= 255\\n\\n        # This will be returned\\n        ans = \\\"\\\"\\n\\n        for ch in content:\\n            ans += chr(ord(ch) ^ key)\\n\\n        return ans\\n\\n    def encrypt_file(self, file: str, key: int = 0) -> bool:\\n        \\\"\\\"\\\"\\n        input: filename (str) and a key (int)\\n        output: returns true if encrypt process was\\n        successful otherwise false\\n        if key not passed the method uses the key by the constructor.\\n        otherwise key = 1\\n        \\\"\\\"\\\"\\n\\n        # precondition\\n        assert isinstance(file, str) and isinstance(key, int)\\n\\n        try:\\n            with open(file) as fin:\\n                with open(\\\"encrypt.out\\\", \\\"w+\\\") as fout:\\n\\n                    # actual encrypt-process\\n                    for line in fin:\\n                        fout.write(self.encrypt_string(line, key))\\n\\n        except OSError:\\n            return False\\n\\n        return True\\n\\n    def decrypt_file(self, file: str, key: int) -> bool:\\n        \\\"\\\"\\\"\\n        input: filename (str) and a key (int)\\n        output: returns true if decrypt process was\\n        successful otherwise false\\n        if key not passed the method uses the key by the constructor.\\n        otherwise key = 1\\n        \\\"\\\"\\\"\\n\\n        # precondition\\n        assert isinstance(file, str) and isinstance(key, int)\\n\\n        try:\\n            with open(file) as fin:\\n                with open(\\\"decrypt.out\\\", \\\"w+\\\") as fout:\\n\\n                    # actual encrypt-process\\n                    for line in fin:\\n                        fout.write(self.decrypt_string(line, key))\\n\\n        except OSError:\\n            return False\\n\\n        return True\\n\\n\\n# Tests\\n# crypt = XORCipher()\\n# key = 67\\n\\n# # test encrypt\\n# print(crypt.encrypt(\\\"hallo welt\\\",key))\\n# # test decrypt\\n# print(crypt.decrypt(crypt.encrypt(\\\"hallo welt\\\",key), key))\\n\\n# # test encrypt_string\\n# print(crypt.encrypt_string(\\\"hallo welt\\\",key))\\n\\n# # test decrypt_string\\n# print(crypt.decrypt_string(crypt.encrypt_string(\\\"hallo welt\\\",key),key))\\n\\n# if (crypt.encrypt_file(\\\"test.txt\\\",key)):\\n#       print(\\\"encrypt successful\\\")\\n# else:\\n#       print(\\\"encrypt unsuccessful\\\")\\n\\n# if (crypt.decrypt_file(\\\"encrypt.out\\\",key)):\\n#       print(\\\"decrypt successful\\\")\\n# else:\\n#       print(\\\"decrypt unsuccessful\\\")\\n\"",
    "burrows wheeler": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform\\n\\nThe Burrows–Wheeler transform (BWT, also called block-sorting compression)\\nrearranges a character string into runs of similar characters. This is useful\\nfor compression, since it tends to be easy to compress a string that has runs\\nof repeated characters by techniques such as move-to-front transform and\\nrun-length encoding. More importantly, the transformation is reversible,\\nwithout needing to store any additional data except the position of the first\\noriginal character. The BWT is thus a \\\"free\\\" method of improving the efficiency\\nof text compression algorithms, costing only some extra computation.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom typing import TypedDict\\n\\n\\nclass BWTTransformDict(TypedDict):\\n    bwt_string: str\\n    idx_original_string: int\\n\\n\\ndef all_rotations(s: str) -> list[str]:\\n    \\\"\\\"\\\"\\n    :param s: The string that will be rotated len(s) times.\\n    :return: A list with the rotations.\\n    :raises TypeError: If s is not an instance of str.\\n    Examples:\\n\\n    >>> all_rotations(\\\"^BANANA|\\\") # doctest: +NORMALIZE_WHITESPACE\\n    ['^BANANA|', 'BANANA|^', 'ANANA|^B', 'NANA|^BA', 'ANA|^BAN', 'NA|^BANA',\\n    'A|^BANAN', '|^BANANA']\\n    >>> all_rotations(\\\"a_asa_da_casa\\\") # doctest: +NORMALIZE_WHITESPACE\\n    ['a_asa_da_casa', '_asa_da_casaa', 'asa_da_casaa_', 'sa_da_casaa_a',\\n    'a_da_casaa_as', '_da_casaa_asa', 'da_casaa_asa_', 'a_casaa_asa_d',\\n    '_casaa_asa_da', 'casaa_asa_da_', 'asaa_asa_da_c', 'saa_asa_da_ca',\\n    'aa_asa_da_cas']\\n    >>> all_rotations(\\\"panamabanana\\\") # doctest: +NORMALIZE_WHITESPACE\\n    ['panamabanana', 'anamabananap', 'namabananapa', 'amabananapan',\\n    'mabananapana', 'abananapanam', 'bananapanama', 'ananapanamab',\\n    'nanapanamaba', 'anapanamaban', 'napanamabana', 'apanamabanan']\\n    >>> all_rotations(5)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: The parameter s type must be str.\\n    \\\"\\\"\\\"\\n    if not isinstance(s, str):\\n        raise TypeError(\\\"The parameter s type must be str.\\\")\\n\\n    return [s[i:] + s[:i] for i in range(len(s))]\\n\\n\\ndef bwt_transform(s: str) -> BWTTransformDict:\\n    \\\"\\\"\\\"\\n    :param s: The string that will be used at bwt algorithm\\n    :return: the string composed of the last char of each row of the ordered\\n    rotations and the index of the original string at ordered rotations list\\n    :raises TypeError: If the s parameter type is not str\\n    :raises ValueError: If the s parameter is empty\\n    Examples:\\n\\n    >>> bwt_transform(\\\"^BANANA\\\")\\n    {'bwt_string': 'BNN^AAA', 'idx_original_string': 6}\\n    >>> bwt_transform(\\\"a_asa_da_casa\\\")\\n    {'bwt_string': 'aaaadss_c__aa', 'idx_original_string': 3}\\n    >>> bwt_transform(\\\"panamabanana\\\")\\n    {'bwt_string': 'mnpbnnaaaaaa', 'idx_original_string': 11}\\n    >>> bwt_transform(4)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: The parameter s type must be str.\\n    >>> bwt_transform('')\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The parameter s must not be empty.\\n    \\\"\\\"\\\"\\n    if not isinstance(s, str):\\n        raise TypeError(\\\"The parameter s type must be str.\\\")\\n    if not s:\\n        raise ValueError(\\\"The parameter s must not be empty.\\\")\\n\\n    rotations = all_rotations(s)\\n    rotations.sort()  # sort the list of rotations in alphabetically order\\n    # make a string composed of the last char of each rotation\\n    response: BWTTransformDict = {\\n        \\\"bwt_string\\\": \\\"\\\".join([word[-1] for word in rotations]),\\n        \\\"idx_original_string\\\": rotations.index(s),\\n    }\\n    return response\\n\\n\\ndef reverse_bwt(bwt_string: str, idx_original_string: int) -> str:\\n    \\\"\\\"\\\"\\n    :param bwt_string: The string returned from bwt algorithm execution\\n    :param idx_original_string: A 0-based index of the string that was used to\\n    generate bwt_string at ordered rotations list\\n    :return: The string used to generate bwt_string when bwt was executed\\n    :raises TypeError: If the bwt_string parameter type is not str\\n    :raises ValueError: If the bwt_string parameter is empty\\n    :raises TypeError: If the idx_original_string type is not int or if not\\n    possible to cast it to int\\n    :raises ValueError: If the idx_original_string value is lower than 0 or\\n    greater than len(bwt_string) - 1\\n\\n    >>> reverse_bwt(\\\"BNN^AAA\\\", 6)\\n    '^BANANA'\\n    >>> reverse_bwt(\\\"aaaadss_c__aa\\\", 3)\\n    'a_asa_da_casa'\\n    >>> reverse_bwt(\\\"mnpbnnaaaaaa\\\", 11)\\n    'panamabanana'\\n    >>> reverse_bwt(4, 11)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: The parameter bwt_string type must be str.\\n    >>> reverse_bwt(\\\"\\\", 11)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The parameter bwt_string must not be empty.\\n    >>> reverse_bwt(\\\"mnpbnnaaaaaa\\\", \\\"asd\\\") # doctest: +NORMALIZE_WHITESPACE\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: The parameter idx_original_string type must be int or passive\\n    of cast to int.\\n    >>> reverse_bwt(\\\"mnpbnnaaaaaa\\\", -1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The parameter idx_original_string must not be lower than 0.\\n    >>> reverse_bwt(\\\"mnpbnnaaaaaa\\\", 12) # doctest: +NORMALIZE_WHITESPACE\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The parameter idx_original_string must be lower than\\n    len(bwt_string).\\n    >>> reverse_bwt(\\\"mnpbnnaaaaaa\\\", 11.0)\\n    'panamabanana'\\n    >>> reverse_bwt(\\\"mnpbnnaaaaaa\\\", 11.4)\\n    'panamabanana'\\n    \\\"\\\"\\\"\\n    if not isinstance(bwt_string, str):\\n        raise TypeError(\\\"The parameter bwt_string type must be str.\\\")\\n    if not bwt_string:\\n        raise ValueError(\\\"The parameter bwt_string must not be empty.\\\")\\n    try:\\n        idx_original_string = int(idx_original_string)\\n    except ValueError:\\n        raise TypeError(\\n            \\\"The parameter idx_original_string type must be int or passive\\\"\\n            \\\" of cast to int.\\\"\\n        )\\n    if idx_original_string < 0:\\n        raise ValueError(\\\"The parameter idx_original_string must not be lower than 0.\\\")\\n    if idx_original_string >= len(bwt_string):\\n        raise ValueError(\\n            \\\"The parameter idx_original_string must be lower than\\\" \\\" len(bwt_string).\\\"\\n        )\\n\\n    ordered_rotations = [\\\"\\\"] * len(bwt_string)\\n    for x in range(len(bwt_string)):\\n        for i in range(len(bwt_string)):\\n            ordered_rotations[i] = bwt_string[i] + ordered_rotations[i]\\n        ordered_rotations.sort()\\n    return ordered_rotations[idx_original_string]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    entry_msg = \\\"Provide a string that I will generate its BWT transform: \\\"\\n    s = input(entry_msg).strip()\\n    result = bwt_transform(s)\\n    print(\\n        f\\\"Burrows Wheeler transform for string '{s}' results \\\"\\n        f\\\"in '{result['bwt_string']}'\\\"\\n    )\\n    original_string = reverse_bwt(result[\\\"bwt_string\\\"], result[\\\"idx_original_string\\\"])\\n    print(\\n        f\\\"Reversing Burrows Wheeler transform for entry '{result['bwt_string']}' \\\"\\n        f\\\"we get original string '{original_string}'\\\"\\n    )\\n\"",
    "huffman": "\"from __future__ import annotations\\n\\nimport sys\\n\\n\\nclass Letter:\\n    def __init__(self, letter: str, freq: int):\\n        self.letter: str = letter\\n        self.freq: int = freq\\n        self.bitstring: dict[str, str] = {}\\n\\n    def __repr__(self) -> str:\\n        return f\\\"{self.letter}:{self.freq}\\\"\\n\\n\\nclass TreeNode:\\n    def __init__(self, freq: int, left: Letter | TreeNode, right: Letter | TreeNode):\\n        self.freq: int = freq\\n        self.left: Letter | TreeNode = left\\n        self.right: Letter | TreeNode = right\\n\\n\\ndef parse_file(file_path: str) -> list[Letter]:\\n    \\\"\\\"\\\"\\n    Read the file and build a dict of all letters and their\\n    frequencies, then convert the dict into a list of Letters.\\n    \\\"\\\"\\\"\\n    chars: dict[str, int] = {}\\n    with open(file_path) as f:\\n        while True:\\n            c = f.read(1)\\n            if not c:\\n                break\\n            chars[c] = chars[c] + 1 if c in chars.keys() else 1\\n    return sorted((Letter(c, f) for c, f in chars.items()), key=lambda l: l.freq)\\n\\n\\ndef build_tree(letters: list[Letter]) -> Letter | TreeNode:\\n    \\\"\\\"\\\"\\n    Run through the list of Letters and build the min heap\\n    for the Huffman Tree.\\n    \\\"\\\"\\\"\\n    response: list[Letter | TreeNode] = letters  # type: ignore\\n    while len(response) > 1:\\n        left = response.pop(0)\\n        right = response.pop(0)\\n        total_freq = left.freq + right.freq\\n        node = TreeNode(total_freq, left, right)\\n        response.append(node)\\n        response.sort(key=lambda l: l.freq)\\n    return response[0]\\n\\n\\ndef traverse_tree(root: Letter | TreeNode, bitstring: str) -> list[Letter]:\\n    \\\"\\\"\\\"\\n    Recursively traverse the Huffman Tree to set each\\n    Letter's bitstring dictionary, and return the list of Letters\\n    \\\"\\\"\\\"\\n    if type(root) is Letter:\\n        root.bitstring[root.letter] = bitstring\\n        return [root]\\n    treenode: TreeNode = root  # type: ignore\\n    letters = []\\n    letters += traverse_tree(treenode.left, bitstring + \\\"0\\\")\\n    letters += traverse_tree(treenode.right, bitstring + \\\"1\\\")\\n    return letters\\n\\n\\ndef huffman(file_path: str) -> None:\\n    \\\"\\\"\\\"\\n    Parse the file, build the tree, then run through the file\\n    again, using the letters dictionary to find and print out the\\n    bitstring for each letter.\\n    \\\"\\\"\\\"\\n    letters_list = parse_file(file_path)\\n    root = build_tree(letters_list)\\n    letters = {\\n        k: v for letter in traverse_tree(root, \\\"\\\") for k, v in letter.bitstring.items()\\n    }\\n    print(f\\\"Huffman Coding  of {file_path}: \\\")\\n    with open(file_path) as f:\\n        while True:\\n            c = f.read(1)\\n            if not c:\\n                break\\n            print(letters[c], end=\\\" \\\")\\n    print()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # pass the file path to the huffman function\\n    huffman(sys.argv[1])\\n\"",
    "lempel ziv": "\"\\\"\\\"\\\"\\n    One of the several implementations of Lempel–Ziv–Welch compression algorithm\\n    https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\\n\\\"\\\"\\\"\\n\\nimport math\\nimport os\\nimport sys\\n\\n\\ndef read_file_binary(file_path: str) -> str:\\n    \\\"\\\"\\\"\\n    Reads given file as bytes and returns them as a long string\\n    \\\"\\\"\\\"\\n    result = \\\"\\\"\\n    try:\\n        with open(file_path, \\\"rb\\\") as binary_file:\\n            data = binary_file.read()\\n        for dat in data:\\n            curr_byte = f\\\"{dat:08b}\\\"\\n            result += curr_byte\\n        return result\\n    except OSError:\\n        print(\\\"File not accessible\\\")\\n        sys.exit()\\n\\n\\ndef add_key_to_lexicon(\\n    lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str\\n) -> None:\\n    \\\"\\\"\\\"\\n    Adds new strings (curr_string + \\\"0\\\",  curr_string + \\\"1\\\") to the lexicon\\n    \\\"\\\"\\\"\\n    lexicon.pop(curr_string)\\n    lexicon[curr_string + \\\"0\\\"] = last_match_id\\n\\n    if math.log2(index).is_integer():\\n        for curr_key in lexicon:\\n            lexicon[curr_key] = \\\"0\\\" + lexicon[curr_key]\\n\\n    lexicon[curr_string + \\\"1\\\"] = bin(index)[2:]\\n\\n\\ndef compress_data(data_bits: str) -> str:\\n    \\\"\\\"\\\"\\n    Compresses given data_bits using Lempel–Ziv–Welch compression algorithm\\n    and returns the result as a string\\n    \\\"\\\"\\\"\\n    lexicon = {\\\"0\\\": \\\"0\\\", \\\"1\\\": \\\"1\\\"}\\n    result, curr_string = \\\"\\\", \\\"\\\"\\n    index = len(lexicon)\\n\\n    for i in range(len(data_bits)):\\n        curr_string += data_bits[i]\\n        if curr_string not in lexicon:\\n            continue\\n\\n        last_match_id = lexicon[curr_string]\\n        result += last_match_id\\n        add_key_to_lexicon(lexicon, curr_string, index, last_match_id)\\n        index += 1\\n        curr_string = \\\"\\\"\\n\\n    while curr_string != \\\"\\\" and curr_string not in lexicon:\\n        curr_string += \\\"0\\\"\\n\\n    if curr_string != \\\"\\\":\\n        last_match_id = lexicon[curr_string]\\n        result += last_match_id\\n\\n    return result\\n\\n\\ndef add_file_length(source_path: str, compressed: str) -> str:\\n    \\\"\\\"\\\"\\n    Adds given file's length in front (using Elias  gamma coding) of the compressed\\n    string\\n    \\\"\\\"\\\"\\n    file_length = os.path.getsize(source_path)\\n    file_length_binary = bin(file_length)[2:]\\n    length_length = len(file_length_binary)\\n\\n    return \\\"0\\\" * (length_length - 1) + file_length_binary + compressed\\n\\n\\ndef write_file_binary(file_path: str, to_write: str) -> None:\\n    \\\"\\\"\\\"\\n    Writes given to_write string (should only consist of 0's and 1's) as bytes in the\\n    file\\n    \\\"\\\"\\\"\\n    byte_length = 8\\n    try:\\n        with open(file_path, \\\"wb\\\") as opened_file:\\n            result_byte_array = [\\n                to_write[i : i + byte_length]\\n                for i in range(0, len(to_write), byte_length)\\n            ]\\n\\n            if len(result_byte_array[-1]) % byte_length == 0:\\n                result_byte_array.append(\\\"10000000\\\")\\n            else:\\n                result_byte_array[-1] += \\\"1\\\" + \\\"0\\\" * (\\n                    byte_length - len(result_byte_array[-1]) - 1\\n                )\\n\\n            for elem in result_byte_array:\\n                opened_file.write(int(elem, 2).to_bytes(1, byteorder=\\\"big\\\"))\\n    except OSError:\\n        print(\\\"File not accessible\\\")\\n        sys.exit()\\n\\n\\ndef compress(source_path: str, destination_path: str) -> None:\\n    \\\"\\\"\\\"\\n    Reads source file, compresses it and writes the compressed result in destination\\n    file\\n    \\\"\\\"\\\"\\n    data_bits = read_file_binary(source_path)\\n    compressed = compress_data(data_bits)\\n    compressed = add_file_length(source_path, compressed)\\n    write_file_binary(destination_path, compressed)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    compress(sys.argv[1], sys.argv[2])\\n\"",
    "lempel ziv decompress": "\"\\\"\\\"\\\"\\n    One of the several implementations of Lempel–Ziv–Welch decompression algorithm\\n    https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\\n\\\"\\\"\\\"\\n\\nimport math\\nimport sys\\n\\n\\ndef read_file_binary(file_path: str) -> str:\\n    \\\"\\\"\\\"\\n    Reads given file as bytes and returns them as a long string\\n    \\\"\\\"\\\"\\n    result = \\\"\\\"\\n    try:\\n        with open(file_path, \\\"rb\\\") as binary_file:\\n            data = binary_file.read()\\n        for dat in data:\\n            curr_byte = f\\\"{dat:08b}\\\"\\n            result += curr_byte\\n        return result\\n    except OSError:\\n        print(\\\"File not accessible\\\")\\n        sys.exit()\\n\\n\\ndef decompress_data(data_bits: str) -> str:\\n    \\\"\\\"\\\"\\n    Decompresses given data_bits using Lempel–Ziv–Welch compression algorithm\\n    and returns the result as a string\\n    \\\"\\\"\\\"\\n    lexicon = {\\\"0\\\": \\\"0\\\", \\\"1\\\": \\\"1\\\"}\\n    result, curr_string = \\\"\\\", \\\"\\\"\\n    index = len(lexicon)\\n\\n    for i in range(len(data_bits)):\\n        curr_string += data_bits[i]\\n        if curr_string not in lexicon:\\n            continue\\n\\n        last_match_id = lexicon[curr_string]\\n        result += last_match_id\\n        lexicon[curr_string] = last_match_id + \\\"0\\\"\\n\\n        if math.log2(index).is_integer():\\n            newLex = {}\\n            for curr_key in list(lexicon):\\n                newLex[\\\"0\\\" + curr_key] = lexicon.pop(curr_key)\\n            lexicon = newLex\\n\\n        lexicon[bin(index)[2:]] = last_match_id + \\\"1\\\"\\n        index += 1\\n        curr_string = \\\"\\\"\\n    return result\\n\\n\\ndef write_file_binary(file_path: str, to_write: str) -> None:\\n    \\\"\\\"\\\"\\n    Writes given to_write string (should only consist of 0's and 1's) as bytes in the\\n    file\\n    \\\"\\\"\\\"\\n    byte_length = 8\\n    try:\\n        with open(file_path, \\\"wb\\\") as opened_file:\\n            result_byte_array = [\\n                to_write[i : i + byte_length]\\n                for i in range(0, len(to_write), byte_length)\\n            ]\\n\\n            if len(result_byte_array[-1]) % byte_length == 0:\\n                result_byte_array.append(\\\"10000000\\\")\\n            else:\\n                result_byte_array[-1] += \\\"1\\\" + \\\"0\\\" * (\\n                    byte_length - len(result_byte_array[-1]) - 1\\n                )\\n\\n            for elem in result_byte_array[:-1]:\\n                opened_file.write(int(elem, 2).to_bytes(1, byteorder=\\\"big\\\"))\\n    except OSError:\\n        print(\\\"File not accessible\\\")\\n        sys.exit()\\n\\n\\ndef remove_prefix(data_bits: str) -> str:\\n    \\\"\\\"\\\"\\n    Removes size prefix, that compressed file should have\\n    Returns the result\\n    \\\"\\\"\\\"\\n    counter = 0\\n    for letter in data_bits:\\n        if letter == \\\"1\\\":\\n            break\\n        counter += 1\\n\\n    data_bits = data_bits[counter:]\\n    data_bits = data_bits[counter + 1 :]\\n    return data_bits\\n\\n\\ndef compress(source_path: str, destination_path: str) -> None:\\n    \\\"\\\"\\\"\\n    Reads source file, decompresses it and writes the result in destination file\\n    \\\"\\\"\\\"\\n    data_bits = read_file_binary(source_path)\\n    data_bits = remove_prefix(data_bits)\\n    decompressed = decompress_data(data_bits)\\n    write_file_binary(destination_path, decompressed)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    compress(sys.argv[1], sys.argv[2])\\n\"",
    "peak signal to noise ratio": "\"\\\"\\\"\\\"\\nPeak signal-to-noise ratio - PSNR\\n    https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio\\nSource:\\nhttps://tutorials.techonical.com/how-to-calculate-psnr-value-of-two-images-using-python\\n\\\"\\\"\\\"\\n\\nimport math\\nimport os\\n\\nimport cv2\\nimport numpy as np\\n\\n\\ndef psnr(original: float, contrast: float) -> float:\\n    mse = np.mean((original - contrast) ** 2)\\n    if mse == 0:\\n        return 100\\n    PIXEL_MAX = 255.0\\n    PSNR = 20 * math.log10(PIXEL_MAX / math.sqrt(mse))\\n    return PSNR\\n\\n\\ndef main() -> None:\\n    dir_path = os.path.dirname(os.path.realpath(__file__))\\n    # Loading images (original image and compressed image)\\n    original = cv2.imread(os.path.join(dir_path, \\\"image_data/original_image.png\\\"))\\n    contrast = cv2.imread(os.path.join(dir_path, \\\"image_data/compressed_image.png\\\"), 1)\\n\\n    original2 = cv2.imread(os.path.join(dir_path, \\\"image_data/PSNR-example-base.png\\\"))\\n    contrast2 = cv2.imread(\\n        os.path.join(dir_path, \\\"image_data/PSNR-example-comp-10.jpg\\\"), 1\\n    )\\n\\n    # Value expected: 29.73dB\\n    print(\\\"-- First Test --\\\")\\n    print(f\\\"PSNR value is {psnr(original, contrast)} dB\\\")\\n\\n    # # Value expected: 31.53dB (Wikipedia Example)\\n    print(\\\"\\\\n-- Second Test --\\\")\\n    print(f\\\"PSNR value is {psnr(original2, contrast2)} dB\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "cnn classification": "\"\\\"\\\"\\\"\\nConvolutional Neural Network\\n\\nObjective : To train a CNN model detect if TB is present in Lung X-ray or not.\\n\\nResources CNN Theory :\\n    https://en.wikipedia.org/wiki/Convolutional_neural_network\\nResources Tensorflow : https://www.tensorflow.org/tutorials/images/cnn\\n\\nDownload dataset from :\\nhttps://lhncbc.nlm.nih.gov/LHC-publications/pubs/TuberculosisChestXrayImageDataSets.html\\n\\n1. Download the dataset folder and create two folder training set and test set\\nin the parent dataste folder\\n2. Move 30-40 image from both TB positive and TB Negative folder\\nin the test set folder\\n3. The labels of the iamges will be extracted from the folder name\\nthe image is present in.\\n\\n\\\"\\\"\\\"\\n\\n# Part 1 - Building the CNN\\n\\nimport numpy as np\\n\\n# Importing the Keras libraries and packages\\nimport tensorflow as tf\\nfrom tensorflow.keras import layers, models\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    # Initialising the CNN\\n    classifier = models.Sequential()\\n\\n    # Step 1 - Convolution\\n    classifier.add(\\n        layers.Conv2D(32, (3, 3), input_shape=(64, 64, 3), activation=\\\"relu\\\")\\n    )\\n\\n    # Step 2 - Pooling\\n    classifier.add(layers.MaxPooling2D(pool_size=(2, 2)))\\n\\n    # Adding a second convolutional layer\\n    classifier.add(layers.Conv2D(32, (3, 3), activation=\\\"relu\\\"))\\n    classifier.add(layers.MaxPooling2D(pool_size=(2, 2)))\\n\\n    # Step 3 - Flattening\\n    classifier.add(layers.Flatten())\\n\\n    # Step 4 - Full connection\\n    classifier.add(layers.Dense(units=128, activation=\\\"relu\\\"))\\n    classifier.add(layers.Dense(units=1, activation=\\\"sigmoid\\\"))\\n\\n    # Compiling the CNN\\n    classifier.compile(\\n        optimizer=\\\"adam\\\", loss=\\\"binary_crossentropy\\\", metrics=[\\\"accuracy\\\"]\\n    )\\n\\n    # Part 2 - Fitting the CNN to the images\\n\\n    # Load Trained model weights\\n\\n    # from keras.models import load_model\\n    # regressor=load_model('cnn.h5')\\n\\n    train_datagen = tf.keras.preprocessing.image.ImageDataGenerator(\\n        rescale=1.0 / 255, shear_range=0.2, zoom_range=0.2, horizontal_flip=True\\n    )\\n\\n    test_datagen = tf.keras.preprocessing.image.ImageDataGenerator(rescale=1.0 / 255)\\n\\n    training_set = train_datagen.flow_from_directory(\\n        \\\"dataset/training_set\\\", target_size=(64, 64), batch_size=32, class_mode=\\\"binary\\\"\\n    )\\n\\n    test_set = test_datagen.flow_from_directory(\\n        \\\"dataset/test_set\\\", target_size=(64, 64), batch_size=32, class_mode=\\\"binary\\\"\\n    )\\n\\n    classifier.fit_generator(\\n        training_set, steps_per_epoch=5, epochs=30, validation_data=test_set\\n    )\\n\\n    classifier.save(\\\"cnn.h5\\\")\\n\\n    # Part 3 - Making new predictions\\n\\n    test_image = tf.keras.preprocessing.image.load_img(\\n        \\\"dataset/single_prediction/image.png\\\", target_size=(64, 64)\\n    )\\n    test_image = tf.keras.preprocessing.image.img_to_array(test_image)\\n    test_image = np.expand_dims(test_image, axis=0)\\n    result = classifier.predict(test_image)\\n    training_set.class_indices\\n    if result[0][0] == 0:\\n        prediction = \\\"Normal\\\"\\n    if result[0][0] == 1:\\n        prediction = \\\"Abnormality detected\\\"\\n\"",
    "flip augmentation": "\"import glob\\nimport os\\nimport random\\nfrom string import ascii_lowercase, digits\\n\\nimport cv2\\n\\n\\\"\\\"\\\"\\nFlip image and bounding box for computer vision task\\nhttps://paperswithcode.com/method/randomhorizontalflip\\n\\\"\\\"\\\"\\n\\n# Params\\nLABEL_DIR = \\\"\\\"\\nIMAGE_DIR = \\\"\\\"\\nOUTPUT_DIR = \\\"\\\"\\nFLIP_TYPE = 1  # (0 is vertical, 1 is horizontal)\\n\\n\\ndef main() -> None:\\n    \\\"\\\"\\\"\\n    Get images list and annotations list from input dir.\\n    Update new images and annotations.\\n    Save images and annotations in output dir.\\n    >>> pass  # A doctest is not possible for this function.\\n    \\\"\\\"\\\"\\n    img_paths, annos = get_dataset(LABEL_DIR, IMAGE_DIR)\\n    print(\\\"Processing...\\\")\\n    new_images, new_annos, paths = update_image_and_anno(img_paths, annos, FLIP_TYPE)\\n\\n    for index, image in enumerate(new_images):\\n        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\\n        letter_code = random_chars(32)\\n        file_name = paths[index].split(os.sep)[-1].rsplit(\\\".\\\", 1)[0]\\n        file_root = f\\\"{OUTPUT_DIR}/{file_name}_FLIP_{letter_code}\\\"\\n        cv2.imwrite(f\\\"/{file_root}.jpg\\\", image, [cv2.IMWRITE_JPEG_QUALITY, 85])\\n        print(f\\\"Success {index+1}/{len(new_images)} with {file_name}\\\")\\n        annos_list = []\\n        for anno in new_annos[index]:\\n            obj = f\\\"{anno[0]} {anno[1]} {anno[2]} {anno[3]} {anno[4]}\\\"\\n            annos_list.append(obj)\\n        with open(f\\\"/{file_root}.txt\\\", \\\"w\\\") as outfile:\\n            outfile.write(\\\"\\\\n\\\".join(line for line in annos_list))\\n\\n\\ndef get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:\\n    \\\"\\\"\\\"\\n    - label_dir <type: str>: Path to label include annotation of images\\n    - img_dir <type: str>: Path to folder contain images\\n    Return <type: list>: List of images path and labels\\n    >>> pass  # A doctest is not possible for this function.\\n    \\\"\\\"\\\"\\n    img_paths = []\\n    labels = []\\n    for label_file in glob.glob(os.path.join(label_dir, \\\"*.txt\\\")):\\n        label_name = label_file.split(os.sep)[-1].rsplit(\\\".\\\", 1)[0]\\n        with open(label_file) as in_file:\\n            obj_lists = in_file.readlines()\\n        img_path = os.path.join(img_dir, f\\\"{label_name}.jpg\\\")\\n\\n        boxes = []\\n        for obj_list in obj_lists:\\n            obj = obj_list.rstrip(\\\"\\\\n\\\").split(\\\" \\\")\\n            boxes.append(\\n                [\\n                    int(obj[0]),\\n                    float(obj[1]),\\n                    float(obj[2]),\\n                    float(obj[3]),\\n                    float(obj[4]),\\n                ]\\n            )\\n        if not boxes:\\n            continue\\n        img_paths.append(img_path)\\n        labels.append(boxes)\\n    return img_paths, labels\\n\\n\\ndef update_image_and_anno(\\n    img_list: list, anno_list: list, flip_type: int = 1\\n) -> tuple[list, list, list]:\\n    \\\"\\\"\\\"\\n    - img_list <type: list>: list of all images\\n    - anno_list <type: list>: list of all annotations of specific image\\n    - flip_type <type: int>: 0 is vertical, 1 is horizontal\\n    Return:\\n        - new_imgs_list <type: narray>: image after resize\\n        - new_annos_lists <type: list>: list of new annotation after scale\\n        - path_list <type: list>: list the name of image file\\n    >>> pass  # A doctest is not possible for this function.\\n    \\\"\\\"\\\"\\n    new_annos_lists = []\\n    path_list = []\\n    new_imgs_list = []\\n    for idx in range(len(img_list)):\\n        new_annos = []\\n        path = img_list[idx]\\n        path_list.append(path)\\n        img_annos = anno_list[idx]\\n        img = cv2.imread(path)\\n        if flip_type == 1:\\n            new_img = cv2.flip(img, flip_type)\\n            for bbox in img_annos:\\n                x_center_new = 1 - bbox[1]\\n                new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])\\n        elif flip_type == 0:\\n            new_img = cv2.flip(img, flip_type)\\n            for bbox in img_annos:\\n                y_center_new = 1 - bbox[2]\\n                new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])\\n        new_annos_lists.append(new_annos)\\n        new_imgs_list.append(new_img)\\n    return new_imgs_list, new_annos_lists, path_list\\n\\n\\ndef random_chars(number_char: int = 32) -> str:\\n    \\\"\\\"\\\"\\n    Automatic generate random 32 characters.\\n    Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\\n    >>> len(random_chars(32))\\n    32\\n    \\\"\\\"\\\"\\n    assert number_char > 1, \\\"The number of character should greater than 1\\\"\\n    letter_code = ascii_lowercase + digits\\n    return \\\"\\\".join(random.choice(letter_code) for _ in range(number_char))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n    print(\\\"DONE ✅\\\")\\n\"",
    "harris corner": "\"import cv2\\nimport numpy as np\\n\\n\\\"\\\"\\\"\\nHarris Corner Detector\\nhttps://en.wikipedia.org/wiki/Harris_Corner_Detector\\n\\\"\\\"\\\"\\n\\n\\nclass Harris_Corner:\\n    def __init__(self, k: float, window_size: int):\\n\\n        \\\"\\\"\\\"\\n        k : is an empirically determined constant in [0.04,0.06]\\n        window_size : neighbourhoods considered\\n        \\\"\\\"\\\"\\n\\n        if k in (0.04, 0.06):\\n            self.k = k\\n            self.window_size = window_size\\n        else:\\n            raise ValueError(\\\"invalid k value\\\")\\n\\n    def __str__(self) -> str:\\n\\n        return f\\\"Harris Corner  detection with k : {self.k}\\\"\\n\\n    def detect(self, img_path: str) -> tuple[cv2.Mat, list[list[int]]]:\\n\\n        \\\"\\\"\\\"\\n        Returns the image with corners identified\\n        img_path  : path of the image\\n        output : list of the corner positions, image\\n        \\\"\\\"\\\"\\n\\n        img = cv2.imread(img_path, 0)\\n        h, w = img.shape\\n        corner_list: list[list[int]] = []\\n        color_img = img.copy()\\n        color_img = cv2.cvtColor(color_img, cv2.COLOR_GRAY2RGB)\\n        dy, dx = np.gradient(img)\\n        ixx = dx ** 2\\n        iyy = dy ** 2\\n        ixy = dx * dy\\n        k = 0.04\\n        offset = self.window_size // 2\\n        for y in range(offset, h - offset):\\n            for x in range(offset, w - offset):\\n                wxx = ixx[\\n                    y - offset : y + offset + 1, x - offset : x + offset + 1\\n                ].sum()\\n                wyy = iyy[\\n                    y - offset : y + offset + 1, x - offset : x + offset + 1\\n                ].sum()\\n                wxy = ixy[\\n                    y - offset : y + offset + 1, x - offset : x + offset + 1\\n                ].sum()\\n\\n                det = (wxx * wyy) - (wxy ** 2)\\n                trace = wxx + wyy\\n                r = det - k * (trace ** 2)\\n                # Can change the value\\n                if r > 0.5:\\n                    corner_list.append([x, y, r])\\n                    color_img.itemset((y, x, 0), 0)\\n                    color_img.itemset((y, x, 1), 0)\\n                    color_img.itemset((y, x, 2), 255)\\n        return color_img, corner_list\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    edge_detect = Harris_Corner(0.04, 3)\\n    color_img, _ = edge_detect.detect(\\\"path_to_image\\\")\\n    cv2.imwrite(\\\"detect.png\\\", color_img)\\n\"",
    "mean threshold": "\"from PIL import Image\\n\\n\\\"\\\"\\\"\\nMean thresholding algorithm for image processing\\nhttps://en.wikipedia.org/wiki/Thresholding_(image_processing)\\n\\\"\\\"\\\"\\n\\n\\ndef mean_threshold(image: Image) -> Image:\\n    \\\"\\\"\\\"\\n    image: is a grayscale PIL image object\\n    \\\"\\\"\\\"\\n    height, width = image.size\\n    mean = 0\\n    pixels = image.load()\\n    for i in range(width):\\n        for j in range(height):\\n            pixel = pixels[j, i]\\n            mean += pixel\\n    mean //= width * height\\n\\n    for j in range(width):\\n        for i in range(height):\\n            pixels[i, j] = 255 if pixels[i, j] > mean else 0\\n    return image\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    image = mean_threshold(Image.open(\\\"path_to_image\\\").convert(\\\"L\\\"))\\n    image.save(\\\"output_image_path\\\")\\n\"",
    "mosaic augmentation": "\"\\\"\\\"\\\"Source: https://github.com/jason9075/opencv-mosaic-data-aug\\\"\\\"\\\"\\n\\nimport glob\\nimport os\\nimport random\\nfrom string import ascii_lowercase, digits\\n\\nimport cv2\\nimport numpy as np\\n\\n# Parrameters\\nOUTPUT_SIZE = (720, 1280)  # Height, Width\\nSCALE_RANGE = (0.4, 0.6)  # if height or width lower than this scale, drop it.\\nFILTER_TINY_SCALE = 1 / 100\\nLABEL_DIR = \\\"\\\"\\nIMG_DIR = \\\"\\\"\\nOUTPUT_DIR = \\\"\\\"\\nNUMBER_IMAGES = 250\\n\\n\\ndef main() -> None:\\n    \\\"\\\"\\\"\\n    Get images list and annotations list from input dir.\\n    Update new images and annotations.\\n    Save images and annotations in output dir.\\n    >>> pass  # A doctest is not possible for this function.\\n    \\\"\\\"\\\"\\n    img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)\\n    for index in range(NUMBER_IMAGES):\\n        idxs = random.sample(range(len(annos)), 4)\\n        new_image, new_annos, path = update_image_and_anno(\\n            img_paths,\\n            annos,\\n            idxs,\\n            OUTPUT_SIZE,\\n            SCALE_RANGE,\\n            filter_scale=FILTER_TINY_SCALE,\\n        )\\n\\n        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\\n        letter_code = random_chars(32)\\n        file_name = path.split(os.sep)[-1].rsplit(\\\".\\\", 1)[0]\\n        file_root = f\\\"{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}\\\"\\n        cv2.imwrite(f\\\"{file_root}.jpg\\\", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])\\n        print(f\\\"Succeeded {index+1}/{NUMBER_IMAGES} with {file_name}\\\")\\n        annos_list = []\\n        for anno in new_annos:\\n            width = anno[3] - anno[1]\\n            height = anno[4] - anno[2]\\n            x_center = anno[1] + width / 2\\n            y_center = anno[2] + height / 2\\n            obj = f\\\"{anno[0]} {x_center} {y_center} {width} {height}\\\"\\n            annos_list.append(obj)\\n        with open(f\\\"{file_root}.txt\\\", \\\"w\\\") as outfile:\\n            outfile.write(\\\"\\\\n\\\".join(line for line in annos_list))\\n\\n\\ndef get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:\\n    \\\"\\\"\\\"\\n    - label_dir <type: str>: Path to label include annotation of images\\n    - img_dir <type: str>: Path to folder contain images\\n    Return <type: list>: List of images path and labels\\n    >>> pass  # A doctest is not possible for this function.\\n    \\\"\\\"\\\"\\n    img_paths = []\\n    labels = []\\n    for label_file in glob.glob(os.path.join(label_dir, \\\"*.txt\\\")):\\n        label_name = label_file.split(os.sep)[-1].rsplit(\\\".\\\", 1)[0]\\n        with open(label_file) as in_file:\\n            obj_lists = in_file.readlines()\\n        img_path = os.path.join(img_dir, f\\\"{label_name}.jpg\\\")\\n\\n        boxes = []\\n        for obj_list in obj_lists:\\n            obj = obj_list.rstrip(\\\"\\\\n\\\").split(\\\" \\\")\\n            xmin = float(obj[1]) - float(obj[3]) / 2\\n            ymin = float(obj[2]) - float(obj[4]) / 2\\n            xmax = float(obj[1]) + float(obj[3]) / 2\\n            ymax = float(obj[2]) + float(obj[4]) / 2\\n\\n            boxes.append([int(obj[0]), xmin, ymin, xmax, ymax])\\n        if not boxes:\\n            continue\\n        img_paths.append(img_path)\\n        labels.append(boxes)\\n    return img_paths, labels\\n\\n\\ndef update_image_and_anno(\\n    all_img_list: list,\\n    all_annos: list,\\n    idxs: list[int],\\n    output_size: tuple[int, int],\\n    scale_range: tuple[float, float],\\n    filter_scale: float = 0.0,\\n) -> tuple[list, list, str]:\\n    \\\"\\\"\\\"\\n    - all_img_list <type: list>: list of all images\\n    - all_annos <type: list>: list of all annotations of specific image\\n    - idxs <type: list>: index of image in list\\n    - output_size <type: tuple>: size of output image (Height, Width)\\n    - scale_range <type: tuple>: range of scale image\\n    - filter_scale <type: float>: the condition of downscale image and bounding box\\n    Return:\\n        - output_img <type: narray>: image after resize\\n        - new_anno <type: list>: list of new annotation after scale\\n        - path[0] <type: string>: get the name of image file\\n    >>> pass  # A doctest is not possible for this function.\\n    \\\"\\\"\\\"\\n    output_img = np.zeros([output_size[0], output_size[1], 3], dtype=np.uint8)\\n    scale_x = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])\\n    scale_y = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])\\n    divid_point_x = int(scale_x * output_size[1])\\n    divid_point_y = int(scale_y * output_size[0])\\n\\n    new_anno = []\\n    path_list = []\\n    for i, index in enumerate(idxs):\\n        path = all_img_list[index]\\n        path_list.append(path)\\n        img_annos = all_annos[index]\\n        img = cv2.imread(path)\\n        if i == 0:  # top-left\\n            img = cv2.resize(img, (divid_point_x, divid_point_y))\\n            output_img[:divid_point_y, :divid_point_x, :] = img\\n            for bbox in img_annos:\\n                xmin = bbox[1] * scale_x\\n                ymin = bbox[2] * scale_y\\n                xmax = bbox[3] * scale_x\\n                ymax = bbox[4] * scale_y\\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\\n        elif i == 1:  # top-right\\n            img = cv2.resize(img, (output_size[1] - divid_point_x, divid_point_y))\\n            output_img[:divid_point_y, divid_point_x : output_size[1], :] = img\\n            for bbox in img_annos:\\n                xmin = scale_x + bbox[1] * (1 - scale_x)\\n                ymin = bbox[2] * scale_y\\n                xmax = scale_x + bbox[3] * (1 - scale_x)\\n                ymax = bbox[4] * scale_y\\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\\n        elif i == 2:  # bottom-left\\n            img = cv2.resize(img, (divid_point_x, output_size[0] - divid_point_y))\\n            output_img[divid_point_y : output_size[0], :divid_point_x, :] = img\\n            for bbox in img_annos:\\n                xmin = bbox[1] * scale_x\\n                ymin = scale_y + bbox[2] * (1 - scale_y)\\n                xmax = bbox[3] * scale_x\\n                ymax = scale_y + bbox[4] * (1 - scale_y)\\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\\n        else:  # bottom-right\\n            img = cv2.resize(\\n                img, (output_size[1] - divid_point_x, output_size[0] - divid_point_y)\\n            )\\n            output_img[\\n                divid_point_y : output_size[0], divid_point_x : output_size[1], :\\n            ] = img\\n            for bbox in img_annos:\\n                xmin = scale_x + bbox[1] * (1 - scale_x)\\n                ymin = scale_y + bbox[2] * (1 - scale_y)\\n                xmax = scale_x + bbox[3] * (1 - scale_x)\\n                ymax = scale_y + bbox[4] * (1 - scale_y)\\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\\n\\n    # Remove bounding box small than scale of filter\\n    if 0 < filter_scale:\\n        new_anno = [\\n            anno\\n            for anno in new_anno\\n            if filter_scale < (anno[3] - anno[1]) and filter_scale < (anno[4] - anno[2])\\n        ]\\n\\n    return output_img, new_anno, path_list[0]\\n\\n\\ndef random_chars(number_char: int) -> str:\\n    \\\"\\\"\\\"\\n    Automatic generate random 32 characters.\\n    Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\\n    >>> len(random_chars(32))\\n    32\\n    \\\"\\\"\\\"\\n    assert number_char > 1, \\\"The number of character should greater than 1\\\"\\n    letter_code = ascii_lowercase + digits\\n    return \\\"\\\".join(random.choice(letter_code) for _ in range(number_char))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n    print(\\\"DONE ✅\\\")\\n\"",
    "pooling functions": "\"# Source : https://computersciencewiki.org/index.php/Max-pooling_/_Pooling\\n# Importing the libraries\\nimport numpy as np\\nfrom PIL import Image\\n\\n\\n# Maxpooling Function\\ndef maxpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\\n    \\\"\\\"\\\"\\n    This function is used to perform maxpooling on the input array of 2D matrix(image)\\n    Args:\\n        arr: numpy array\\n        size: size of pooling matrix\\n        stride: the number of pixels shifts over the input matrix\\n    Returns:\\n        numpy array of maxpooled matrix\\n    Sample Input Output:\\n    >>> maxpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\\n    array([[ 6.,  8.],\\n           [14., 16.]])\\n    >>> maxpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\\n    array([[241., 180.],\\n           [241., 157.]])\\n    \\\"\\\"\\\"\\n    arr = np.array(arr)\\n    if arr.shape[0] != arr.shape[1]:\\n        raise ValueError(\\\"The input array is not a square matrix\\\")\\n    i = 0\\n    j = 0\\n    mat_i = 0\\n    mat_j = 0\\n\\n    # compute the shape of the output matrix\\n    maxpool_shape = (arr.shape[0] - size) // stride + 1\\n    # initialize the output matrix with zeros of shape maxpool_shape\\n    updated_arr = np.zeros((maxpool_shape, maxpool_shape))\\n\\n    while i < arr.shape[0]:\\n        if i + size > arr.shape[0]:\\n            # if the end of the matrix is reached, break\\n            break\\n        while j < arr.shape[1]:\\n            # if the end of the matrix is reached, break\\n            if j + size > arr.shape[1]:\\n                break\\n            # compute the maximum of the pooling matrix\\n            updated_arr[mat_i][mat_j] = np.max(arr[i : i + size, j : j + size])\\n            # shift the pooling matrix by stride of column pixels\\n            j += stride\\n            mat_j += 1\\n\\n        # shift the pooling matrix by stride of row pixels\\n        i += stride\\n        mat_i += 1\\n\\n        # reset the column index to 0\\n        j = 0\\n        mat_j = 0\\n\\n    return updated_arr\\n\\n\\n# Averagepooling Function\\ndef avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\\n    \\\"\\\"\\\"\\n    This function is used to perform avgpooling on the input array of 2D matrix(image)\\n    Args:\\n        arr: numpy array\\n        size: size of pooling matrix\\n        stride: the number of pixels shifts over the input matrix\\n    Returns:\\n        numpy array of avgpooled matrix\\n    Sample Input Output:\\n    >>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\\n    array([[ 3.,  5.],\\n           [11., 13.]])\\n    >>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\\n    array([[161., 102.],\\n           [114.,  69.]])\\n    \\\"\\\"\\\"\\n    arr = np.array(arr)\\n    if arr.shape[0] != arr.shape[1]:\\n        raise ValueError(\\\"The input array is not a square matrix\\\")\\n    i = 0\\n    j = 0\\n    mat_i = 0\\n    mat_j = 0\\n\\n    # compute the shape of the output matrix\\n    avgpool_shape = (arr.shape[0] - size) // stride + 1\\n    # initialize the output matrix with zeros of shape avgpool_shape\\n    updated_arr = np.zeros((avgpool_shape, avgpool_shape))\\n\\n    while i < arr.shape[0]:\\n        # if the end of the matrix is reached, break\\n        if i + size > arr.shape[0]:\\n            break\\n        while j < arr.shape[1]:\\n            # if the end of the matrix is reached, break\\n            if j + size > arr.shape[1]:\\n                break\\n            # compute the average of the pooling matrix\\n            updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))\\n            # shift the pooling matrix by stride of column pixels\\n            j += stride\\n            mat_j += 1\\n\\n        # shift the pooling matrix by stride of row pixels\\n        i += stride\\n        mat_i += 1\\n        # reset the column index to 0\\n        j = 0\\n        mat_j = 0\\n\\n    return updated_arr\\n\\n\\n# Main Function\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod(name=\\\"avgpooling\\\", verbose=True)\\n\\n    # Loading the image\\n    image = Image.open(\\\"path_to_image\\\")\\n\\n    # Converting the image to numpy array and maxpooling, displaying the result\\n    # Ensure that the image is a square matrix\\n\\n    Image.fromarray(maxpooling(np.array(image), size=3, stride=2)).show()\\n\\n    # Converting the image to numpy array and averagepooling, displaying the result\\n    # Ensure that the image is a square matrix\\n\\n    Image.fromarray(avgpooling(np.array(image), size=3, stride=2)).show()\\n\"",
    "binary to decimal": "\"def bin_to_decimal(bin_string: str) -> int:\\n    \\\"\\\"\\\"\\n    Convert a binary value to its decimal equivalent\\n\\n    >>> bin_to_decimal(\\\"101\\\")\\n    5\\n    >>> bin_to_decimal(\\\" 1010   \\\")\\n    10\\n    >>> bin_to_decimal(\\\"-11101\\\")\\n    -29\\n    >>> bin_to_decimal(\\\"0\\\")\\n    0\\n    >>> bin_to_decimal(\\\"a\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Non-binary value was passed to the function\\n    >>> bin_to_decimal(\\\"\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Empty string was passed to the function\\n    >>> bin_to_decimal(\\\"39\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Non-binary value was passed to the function\\n    \\\"\\\"\\\"\\n    bin_string = str(bin_string).strip()\\n    if not bin_string:\\n        raise ValueError(\\\"Empty string was passed to the function\\\")\\n    is_negative = bin_string[0] == \\\"-\\\"\\n    if is_negative:\\n        bin_string = bin_string[1:]\\n    if not all(char in \\\"01\\\" for char in bin_string):\\n        raise ValueError(\\\"Non-binary value was passed to the function\\\")\\n    decimal_number = 0\\n    for char in bin_string:\\n        decimal_number = 2 * decimal_number + int(char)\\n    return -decimal_number if is_negative else decimal_number\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "binary to hexadecimal": "\"def bin_to_hexadecimal(binary_str: str) -> str:\\n    \\\"\\\"\\\"\\n    Converting a binary string into hexadecimal using Grouping Method\\n\\n    >>> bin_to_hexadecimal('101011111')\\n    '0x15f'\\n    >>> bin_to_hexadecimal(' 1010   ')\\n    '0x0a'\\n    >>> bin_to_hexadecimal('-11101')\\n    '-0x1d'\\n    >>> bin_to_hexadecimal('a')\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Non-binary value was passed to the function\\n    >>> bin_to_hexadecimal('')\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Empty string was passed to the function\\n    \\\"\\\"\\\"\\n    BITS_TO_HEX = {\\n        \\\"0000\\\": \\\"0\\\",\\n        \\\"0001\\\": \\\"1\\\",\\n        \\\"0010\\\": \\\"2\\\",\\n        \\\"0011\\\": \\\"3\\\",\\n        \\\"0100\\\": \\\"4\\\",\\n        \\\"0101\\\": \\\"5\\\",\\n        \\\"0110\\\": \\\"6\\\",\\n        \\\"0111\\\": \\\"7\\\",\\n        \\\"1000\\\": \\\"8\\\",\\n        \\\"1001\\\": \\\"9\\\",\\n        \\\"1010\\\": \\\"a\\\",\\n        \\\"1011\\\": \\\"b\\\",\\n        \\\"1100\\\": \\\"c\\\",\\n        \\\"1101\\\": \\\"d\\\",\\n        \\\"1110\\\": \\\"e\\\",\\n        \\\"1111\\\": \\\"f\\\",\\n    }\\n\\n    # Sanitising parameter\\n    binary_str = str(binary_str).strip()\\n\\n    # Exceptions\\n    if not binary_str:\\n        raise ValueError(\\\"Empty string was passed to the function\\\")\\n    is_negative = binary_str[0] == \\\"-\\\"\\n    binary_str = binary_str[1:] if is_negative else binary_str\\n    if not all(char in \\\"01\\\" for char in binary_str):\\n        raise ValueError(\\\"Non-binary value was passed to the function\\\")\\n\\n    binary_str = (\\n        \\\"0\\\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str\\n    )\\n\\n    hexadecimal = []\\n    for x in range(0, len(binary_str), 4):\\n        hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])\\n    hexadecimal_str = \\\"0x\\\" + \\\"\\\".join(hexadecimal)\\n\\n    return \\\"-\\\" + hexadecimal_str if is_negative else hexadecimal_str\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "binary to octal": "\"\\\"\\\"\\\"\\nThe function below will convert any binary string to the octal equivalent.\\n\\n>>> bin_to_octal(\\\"1111\\\")\\n'17'\\n\\n>>> bin_to_octal(\\\"101010101010011\\\")\\n'52523'\\n\\n>>> bin_to_octal(\\\"\\\")\\nTraceback (most recent call last):\\n...\\nValueError: Empty string was passed to the function\\n>>> bin_to_octal(\\\"a-1\\\")\\nTraceback (most recent call last):\\n...\\nValueError: Non-binary value was passed to the function\\n\\\"\\\"\\\"\\n\\n\\ndef bin_to_octal(bin_string: str) -> str:\\n    if not all(char in \\\"01\\\" for char in bin_string):\\n        raise ValueError(\\\"Non-binary value was passed to the function\\\")\\n    if not bin_string:\\n        raise ValueError(\\\"Empty string was passed to the function\\\")\\n    oct_string = \\\"\\\"\\n    while len(bin_string) % 3 != 0:\\n        bin_string = \\\"0\\\" + bin_string\\n    bin_string_in_3_list = [\\n        bin_string[index : index + 3]\\n        for index in range(len(bin_string))\\n        if index % 3 == 0\\n    ]\\n    for bin_group in bin_string_in_3_list:\\n        oct_val = 0\\n        for index, val in enumerate(bin_group):\\n            oct_val += int(2 ** (2 - index) * int(val))\\n        oct_string += str(oct_val)\\n    return oct_string\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "decimal to any": "\"\\\"\\\"\\\"Convert a positive Decimal Number to Any Other Representation\\\"\\\"\\\"\\n\\n\\ndef decimal_to_any(num: int, base: int) -> str:\\n    \\\"\\\"\\\"\\n    Convert a positive integer to another base as str.\\n    >>> decimal_to_any(0, 2)\\n    '0'\\n    >>> decimal_to_any(5, 4)\\n    '11'\\n    >>> decimal_to_any(20, 3)\\n    '202'\\n    >>> decimal_to_any(58, 16)\\n    '3A'\\n    >>> decimal_to_any(243, 17)\\n    'E5'\\n    >>> decimal_to_any(34923, 36)\\n    'QY3'\\n    >>> decimal_to_any(10, 11)\\n    'A'\\n    >>> decimal_to_any(16, 16)\\n    '10'\\n    >>> decimal_to_any(36, 36)\\n    '10'\\n    >>> # negatives will error\\n    >>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: parameter must be positive int\\n    >>> # floats will error\\n    >>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    TypeError: int() can't convert non-string with explicit base\\n    >>> # a float base will error\\n    >>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    TypeError: 'float' object cannot be interpreted as an integer\\n    >>> # a str base will error\\n    >>> decimal_to_any(10, '16') # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    TypeError: 'str' object cannot be interpreted as an integer\\n    >>> # a base less than 2 will error\\n    >>> decimal_to_any(7, 0) # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: base must be >= 2\\n    >>> # a base greater than 36 will error\\n    >>> decimal_to_any(34, 37) # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: base must be <= 36\\n    \\\"\\\"\\\"\\n    if isinstance(num, float):\\n        raise TypeError(\\\"int() can't convert non-string with explicit base\\\")\\n    if num < 0:\\n        raise ValueError(\\\"parameter must be positive int\\\")\\n    if isinstance(base, str):\\n        raise TypeError(\\\"'str' object cannot be interpreted as an integer\\\")\\n    if isinstance(base, float):\\n        raise TypeError(\\\"'float' object cannot be interpreted as an integer\\\")\\n    if base in (0, 1):\\n        raise ValueError(\\\"base must be >= 2\\\")\\n    if base > 36:\\n        raise ValueError(\\\"base must be <= 36\\\")\\n    # fmt: off\\n    ALPHABET_VALUES = {'10': 'A', '11': 'B', '12': 'C', '13': 'D', '14': 'E', '15': 'F',\\n                       '16': 'G', '17': 'H', '18': 'I', '19': 'J', '20': 'K', '21': 'L',\\n                       '22': 'M', '23': 'N', '24': 'O', '25': 'P', '26': 'Q', '27': 'R',\\n                       '28': 'S', '29': 'T', '30': 'U', '31': 'V', '32': 'W', '33': 'X',\\n                       '34': 'Y', '35': 'Z'}\\n    # fmt: on\\n    new_value = \\\"\\\"\\n    mod = 0\\n    div = 0\\n    while div != 1:\\n        div, mod = divmod(num, base)\\n        if base >= 11 and 9 < mod < 36:\\n            actual_value = ALPHABET_VALUES[str(mod)]\\n            mod = actual_value\\n        new_value += str(mod)\\n        div = num // base\\n        num = div\\n        if div == 0:\\n            return str(new_value[::-1])\\n        elif div == 1:\\n            new_value += str(div)\\n            return str(new_value[::-1])\\n\\n    return new_value[::-1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    for base in range(2, 37):\\n        for num in range(1000):\\n            assert int(decimal_to_any(num, base), base) == num, (\\n                num,\\n                base,\\n                decimal_to_any(num, base),\\n                int(decimal_to_any(num, base), base),\\n            )\\n\"",
    "decimal to binary": "\"\\\"\\\"\\\"Convert a Decimal Number to a Binary Number.\\\"\\\"\\\"\\n\\n\\ndef decimal_to_binary(num: int) -> str:\\n\\n    \\\"\\\"\\\"\\n    Convert an Integer Decimal Number to a Binary Number as str.\\n    >>> decimal_to_binary(0)\\n    '0b0'\\n    >>> decimal_to_binary(2)\\n    '0b10'\\n    >>> decimal_to_binary(7)\\n    '0b111'\\n    >>> decimal_to_binary(35)\\n    '0b100011'\\n    >>> # negatives work too\\n    >>> decimal_to_binary(-2)\\n    '-0b10'\\n    >>> # other floats will error\\n    >>> decimal_to_binary(16.16) # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    TypeError: 'float' object cannot be interpreted as an integer\\n    >>> # strings will error as well\\n    >>> decimal_to_binary('0xfffff') # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    TypeError: 'str' object cannot be interpreted as an integer\\n    \\\"\\\"\\\"\\n\\n    if isinstance(num, float):\\n        raise TypeError(\\\"'float' object cannot be interpreted as an integer\\\")\\n    if isinstance(num, str):\\n        raise TypeError(\\\"'str' object cannot be interpreted as an integer\\\")\\n\\n    if num == 0:\\n        return \\\"0b0\\\"\\n\\n    negative = False\\n\\n    if num < 0:\\n        negative = True\\n        num = -num\\n\\n    binary: list[int] = []\\n    while num > 0:\\n        binary.insert(0, num % 2)\\n        num >>= 1\\n\\n    if negative:\\n        return \\\"-0b\\\" + \\\"\\\".join(str(e) for e in binary)\\n\\n    return \\\"0b\\\" + \\\"\\\".join(str(e) for e in binary)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "decimal to binary recursion": "\"def binary_recursive(decimal: int) -> str:\\n    \\\"\\\"\\\"\\n    Take a positive integer value and return its binary equivalent.\\n    >>> binary_recursive(1000)\\n    '1111101000'\\n    >>> binary_recursive(\\\"72\\\")\\n    '1001000'\\n    >>> binary_recursive(\\\"number\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: invalid literal for int() with base 10: 'number'\\n    \\\"\\\"\\\"\\n    decimal = int(decimal)\\n    if decimal in (0, 1):  # Exit cases for the recursion\\n        return str(decimal)\\n    div, mod = divmod(decimal, 2)\\n    return binary_recursive(div) + str(mod)\\n\\n\\ndef main(number: str) -> str:\\n    \\\"\\\"\\\"\\n    Take an integer value and raise ValueError for wrong inputs,\\n    call the function above and return the output with prefix \\\"0b\\\" & \\\"-0b\\\"\\n    for positive and negative integers respectively.\\n    >>> main(0)\\n    '0b0'\\n    >>> main(40)\\n    '0b101000'\\n    >>> main(-40)\\n    '-0b101000'\\n    >>> main(40.8)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Input value is not an integer\\n    >>> main(\\\"forty\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Input value is not an integer\\n    \\\"\\\"\\\"\\n    number = str(number).strip()\\n    if not number:\\n        raise ValueError(\\\"No input value was provided\\\")\\n    negative = \\\"-\\\" if number.startswith(\\\"-\\\") else \\\"\\\"\\n    number = number.lstrip(\\\"-\\\")\\n    if not number.isnumeric():\\n        raise ValueError(\\\"Input value is not an integer\\\")\\n    return f\\\"{negative}0b{binary_recursive(int(number))}\\\"\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "decimal to hexadecimal": "\"\\\"\\\"\\\" Convert Base 10 (Decimal) Values to Hexadecimal Representations \\\"\\\"\\\"\\n\\n# set decimal value for each hexadecimal digit\\nvalues = {\\n    0: \\\"0\\\",\\n    1: \\\"1\\\",\\n    2: \\\"2\\\",\\n    3: \\\"3\\\",\\n    4: \\\"4\\\",\\n    5: \\\"5\\\",\\n    6: \\\"6\\\",\\n    7: \\\"7\\\",\\n    8: \\\"8\\\",\\n    9: \\\"9\\\",\\n    10: \\\"a\\\",\\n    11: \\\"b\\\",\\n    12: \\\"c\\\",\\n    13: \\\"d\\\",\\n    14: \\\"e\\\",\\n    15: \\\"f\\\",\\n}\\n\\n\\ndef decimal_to_hexadecimal(decimal: float) -> str:\\n    \\\"\\\"\\\"\\n    take integer decimal value, return hexadecimal representation as str beginning\\n    with 0x\\n    >>> decimal_to_hexadecimal(5)\\n    '0x5'\\n    >>> decimal_to_hexadecimal(15)\\n    '0xf'\\n    >>> decimal_to_hexadecimal(37)\\n    '0x25'\\n    >>> decimal_to_hexadecimal(255)\\n    '0xff'\\n    >>> decimal_to_hexadecimal(4096)\\n    '0x1000'\\n    >>> decimal_to_hexadecimal(999098)\\n    '0xf3eba'\\n    >>> # negatives work too\\n    >>> decimal_to_hexadecimal(-256)\\n    '-0x100'\\n    >>> # floats are acceptable if equivalent to an int\\n    >>> decimal_to_hexadecimal(17.0)\\n    '0x11'\\n    >>> # other floats will error\\n    >>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    AssertionError\\n    >>> # strings will error as well\\n    >>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    AssertionError\\n    >>> # results are the same when compared to Python's default hex function\\n    >>> decimal_to_hexadecimal(-256) == hex(-256)\\n    True\\n    \\\"\\\"\\\"\\n    assert type(decimal) in (int, float) and decimal == int(decimal)\\n    decimal = int(decimal)\\n    hexadecimal = \\\"\\\"\\n    negative = False\\n    if decimal < 0:\\n        negative = True\\n        decimal *= -1\\n    while decimal > 0:\\n        decimal, remainder = divmod(decimal, 16)\\n        hexadecimal = values[remainder] + hexadecimal\\n    hexadecimal = \\\"0x\\\" + hexadecimal\\n    if negative:\\n        hexadecimal = \\\"-\\\" + hexadecimal\\n    return hexadecimal\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "decimal to octal": "\"\\\"\\\"\\\"Convert a Decimal Number to an Octal Number.\\\"\\\"\\\"\\n\\nimport math\\n\\n# Modified from:\\n# https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/DecimalToOctal.js\\n\\n\\ndef decimal_to_octal(num: int) -> str:\\n    \\\"\\\"\\\"Convert a Decimal Number to an Octal Number.\\n\\n    >>> all(decimal_to_octal(i) == oct(i) for i\\n    ...     in (0, 2, 8, 64, 65, 216, 255, 256, 512))\\n    True\\n    \\\"\\\"\\\"\\n    octal = 0\\n    counter = 0\\n    while num > 0:\\n        remainder = num % 8\\n        octal = octal + (remainder * math.floor(math.pow(10, counter)))\\n        counter += 1\\n        num = math.floor(num / 8)  # basically /= 8 without remainder if any\\n        # This formatting removes trailing '.0' from `octal`.\\n    return f\\\"0o{int(octal)}\\\"\\n\\n\\ndef main() -> None:\\n    \\\"\\\"\\\"Print octal equivalents of decimal numbers.\\\"\\\"\\\"\\n    print(\\\"\\\\n2 in octal is:\\\")\\n    print(decimal_to_octal(2))  # = 2\\n    print(\\\"\\\\n8 in octal is:\\\")\\n    print(decimal_to_octal(8))  # = 10\\n    print(\\\"\\\\n65 in octal is:\\\")\\n    print(decimal_to_octal(65))  # = 101\\n    print(\\\"\\\\n216 in octal is:\\\")\\n    print(decimal_to_octal(216))  # = 330\\n    print(\\\"\\\\n512 in octal is:\\\")\\n    print(decimal_to_octal(512))  # = 1000\\n    print(\\\"\\\\n\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "hexadecimal to decimal": "\"hex_table = {hex(i)[2:]: i for i in range(16)}  # Use [:2] to strip off the leading '0x'\\n\\n\\ndef hex_to_decimal(hex_string: str) -> int:\\n    \\\"\\\"\\\"\\n    Convert a hexadecimal value to its decimal equivalent\\n    #https://www.programiz.com/python-programming/methods/built-in/hex\\n\\n    >>> hex_to_decimal(\\\"a\\\")\\n    10\\n    >>> hex_to_decimal(\\\"12f\\\")\\n    303\\n    >>> hex_to_decimal(\\\"   12f   \\\")\\n    303\\n    >>> hex_to_decimal(\\\"FfFf\\\")\\n    65535\\n    >>> hex_to_decimal(\\\"-Ff\\\")\\n    -255\\n    >>> hex_to_decimal(\\\"F-f\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Non-hexadecimal value was passed to the function\\n    >>> hex_to_decimal(\\\"\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Empty string was passed to the function\\n    >>> hex_to_decimal(\\\"12m\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Non-hexadecimal value was passed to the function\\n    \\\"\\\"\\\"\\n    hex_string = hex_string.strip().lower()\\n    if not hex_string:\\n        raise ValueError(\\\"Empty string was passed to the function\\\")\\n    is_negative = hex_string[0] == \\\"-\\\"\\n    if is_negative:\\n        hex_string = hex_string[1:]\\n    if not all(char in hex_table for char in hex_string):\\n        raise ValueError(\\\"Non-hexadecimal value was passed to the function\\\")\\n    decimal_number = 0\\n    for char in hex_string:\\n        decimal_number = 16 * decimal_number + hex_table[char]\\n    return -decimal_number if is_negative else decimal_number\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "hex to bin": "\"def hex_to_bin(hex_num: str) -> int:\\n    \\\"\\\"\\\"\\n    Convert a hexadecimal value to its binary equivalent\\n    #https://stackoverflow.com/questions/1425493/convert-hex-to-binary\\n    Here, we have used the bitwise right shift operator: >>\\n    Shifts the bits of the number to the right and fills 0 on voids left as a result.\\n    Similar effect as of dividing the number with some power of two.\\n    Example:\\n    a = 10\\n    a >> 1 = 5\\n\\n    >>> hex_to_bin(\\\"AC\\\")\\n    10101100\\n    >>> hex_to_bin(\\\"9A4\\\")\\n    100110100100\\n    >>> hex_to_bin(\\\"   12f   \\\")\\n    100101111\\n    >>> hex_to_bin(\\\"FfFf\\\")\\n    1111111111111111\\n    >>> hex_to_bin(\\\"-fFfF\\\")\\n    -1111111111111111\\n    >>> hex_to_bin(\\\"F-f\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Invalid value was passed to the function\\n    >>> hex_to_bin(\\\"\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: No value was passed to the function\\n    \\\"\\\"\\\"\\n\\n    hex_num = hex_num.strip()\\n    if not hex_num:\\n        raise ValueError(\\\"No value was passed to the function\\\")\\n\\n    is_negative = hex_num[0] == \\\"-\\\"\\n    if is_negative:\\n        hex_num = hex_num[1:]\\n\\n    try:\\n        int_num = int(hex_num, 16)\\n    except ValueError:\\n        raise ValueError(\\\"Invalid value was passed to the function\\\")\\n\\n    bin_str = \\\"\\\"\\n    while int_num > 0:\\n        bin_str = str(int_num % 2) + bin_str\\n        int_num >>= 1\\n\\n    return int((\\\"-\\\" + bin_str) if is_negative else bin_str)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "length conversion": "\"\\\"\\\"\\\"\\r\\nConversion of length units.\\r\\nAvailable Units:- Metre,Kilometre,Feet,Inch,Centimeter,Yard,Foot,Mile,Millimeter\\r\\n\\r\\nUSAGE :\\r\\n-> Import this file into their respective project.\\r\\n-> Use the function length_conversion() for conversion of length units.\\r\\n-> Parameters :\\r\\n    -> value : The number of from units you want to convert\\r\\n    -> from_type : From which type you want to convert\\r\\n    -> to_type : To which type you want to convert\\r\\n\\r\\nREFERENCES :\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Meter\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Kilometer\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Feet\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Inch\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Centimeter\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Yard\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Foot\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Mile\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Millimeter\\r\\n\\\"\\\"\\\"\\r\\n\\r\\nfrom collections import namedtuple\\r\\n\\r\\nfrom_to = namedtuple(\\\"from_to\\\", \\\"from_ to\\\")\\r\\n\\r\\nTYPE_CONVERSION = {\\r\\n    \\\"millimeter\\\": \\\"mm\\\",\\r\\n    \\\"centimeter\\\": \\\"cm\\\",\\r\\n    \\\"meter\\\": \\\"m\\\",\\r\\n    \\\"kilometer\\\": \\\"km\\\",\\r\\n    \\\"inch\\\": \\\"in\\\",\\r\\n    \\\"inche\\\": \\\"in\\\",  # Trailing 's' has been stripped off\\r\\n    \\\"feet\\\": \\\"ft\\\",\\r\\n    \\\"foot\\\": \\\"ft\\\",\\r\\n    \\\"yard\\\": \\\"yd\\\",\\r\\n    \\\"mile\\\": \\\"mi\\\",\\r\\n}\\r\\n\\r\\nMETRIC_CONVERSION = {\\r\\n    \\\"mm\\\": from_to(0.001, 1000),\\r\\n    \\\"cm\\\": from_to(0.01, 100),\\r\\n    \\\"m\\\": from_to(1, 1),\\r\\n    \\\"km\\\": from_to(1000, 0.001),\\r\\n    \\\"in\\\": from_to(0.0254, 39.3701),\\r\\n    \\\"ft\\\": from_to(0.3048, 3.28084),\\r\\n    \\\"yd\\\": from_to(0.9144, 1.09361),\\r\\n    \\\"mi\\\": from_to(1609.34, 0.000621371),\\r\\n}\\r\\n\\r\\n\\r\\ndef length_conversion(value: float, from_type: str, to_type: str) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Conversion between length units.\\r\\n\\r\\n    >>> length_conversion(4, \\\"METER\\\", \\\"FEET\\\")\\r\\n    13.12336\\r\\n    >>> length_conversion(4, \\\"M\\\", \\\"FT\\\")\\r\\n    13.12336\\r\\n    >>> length_conversion(1, \\\"meter\\\", \\\"kilometer\\\")\\r\\n    0.001\\r\\n    >>> length_conversion(1, \\\"kilometer\\\", \\\"inch\\\")\\r\\n    39370.1\\r\\n    >>> length_conversion(3, \\\"kilometer\\\", \\\"mile\\\")\\r\\n    1.8641130000000001\\r\\n    >>> length_conversion(2, \\\"feet\\\", \\\"meter\\\")\\r\\n    0.6096\\r\\n    >>> length_conversion(4, \\\"feet\\\", \\\"yard\\\")\\r\\n    1.333329312\\r\\n    >>> length_conversion(1, \\\"inch\\\", \\\"meter\\\")\\r\\n    0.0254\\r\\n    >>> length_conversion(2, \\\"inch\\\", \\\"mile\\\")\\r\\n    3.15656468e-05\\r\\n    >>> length_conversion(2, \\\"centimeter\\\", \\\"millimeter\\\")\\r\\n    20.0\\r\\n    >>> length_conversion(2, \\\"centimeter\\\", \\\"yard\\\")\\r\\n    0.0218722\\r\\n    >>> length_conversion(4, \\\"yard\\\", \\\"meter\\\")\\r\\n    3.6576\\r\\n    >>> length_conversion(4, \\\"yard\\\", \\\"kilometer\\\")\\r\\n    0.0036576\\r\\n    >>> length_conversion(3, \\\"foot\\\", \\\"meter\\\")\\r\\n    0.9144000000000001\\r\\n    >>> length_conversion(3, \\\"foot\\\", \\\"inch\\\")\\r\\n    36.00001944\\r\\n    >>> length_conversion(4, \\\"mile\\\", \\\"kilometer\\\")\\r\\n    6.43736\\r\\n    >>> length_conversion(2, \\\"miles\\\", \\\"InChEs\\\")\\r\\n    126719.753468\\r\\n    >>> length_conversion(3, \\\"millimeter\\\", \\\"centimeter\\\")\\r\\n    0.3\\r\\n    >>> length_conversion(3, \\\"mm\\\", \\\"in\\\")\\r\\n    0.1181103\\r\\n    >>> length_conversion(4, \\\"wrongUnit\\\", \\\"inch\\\")\\r\\n    Traceback (most recent call last):\\r\\n      ...\\r\\n    ValueError: Invalid 'from_type' value: 'wrongUnit'.\\r\\n    Conversion abbreviations are: mm, cm, m, km, in, ft, yd, mi\\r\\n    \\\"\\\"\\\"\\r\\n    new_from = from_type.lower().rstrip(\\\"s\\\")\\r\\n    new_from = TYPE_CONVERSION.get(new_from, new_from)\\r\\n    new_to = to_type.lower().rstrip(\\\"s\\\")\\r\\n    new_to = TYPE_CONVERSION.get(new_to, new_to)\\r\\n    if new_from not in METRIC_CONVERSION:\\r\\n        raise ValueError(\\r\\n            f\\\"Invalid 'from_type' value: {from_type!r}.\\\\n\\\"\\r\\n            f\\\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\\\"\\r\\n        )\\r\\n    if new_to not in METRIC_CONVERSION:\\r\\n        raise ValueError(\\r\\n            f\\\"Invalid 'to_type' value: {to_type!r}.\\\\n\\\"\\r\\n            f\\\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\\\"\\r\\n        )\\r\\n    return value * METRIC_CONVERSION[new_from].from_ * METRIC_CONVERSION[new_to].to\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "molecular chemistry": "\"\\\"\\\"\\\"\\nFunctions useful for doing molecular chemistry:\\n* molarity_to_normality\\n* moles_to_pressure\\n* moles_to_volume\\n* pressure_and_volume_to_temperature\\n\\\"\\\"\\\"\\n\\n\\ndef molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\\n    \\\"\\\"\\\"\\n    Convert molarity to normality.\\n      Volume is taken in litres.\\n\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\\n\\n      >>> molarity_to_normality(2, 3.1, 0.31)\\n      20\\n      >>> molarity_to_normality(4, 11.4, 5.7)\\n      8\\n    \\\"\\\"\\\"\\n    return round(float(moles / volume) * nfactor)\\n\\n\\ndef moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\\n    \\\"\\\"\\\"\\n    Convert moles to pressure.\\n      Ideal gas laws are used.\\n      Temperature is taken in kelvin.\\n      Volume is taken in litres.\\n      Pressure has atm as SI unit.\\n\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\\n\\n      >>> moles_to_pressure(0.82, 3, 300)\\n      90\\n      >>> moles_to_pressure(8.2, 5, 200)\\n      10\\n    \\\"\\\"\\\"\\n    return round(float((moles * 0.0821 * temperature) / (volume)))\\n\\n\\ndef moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\\n    \\\"\\\"\\\"\\n    Convert moles to volume.\\n      Ideal gas laws are used.\\n      Temperature is taken in kelvin.\\n      Volume is taken in litres.\\n      Pressure has atm as SI unit.\\n\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\\n\\n      >>> moles_to_volume(0.82, 3, 300)\\n      90\\n      >>> moles_to_volume(8.2, 5, 200)\\n      10\\n    \\\"\\\"\\\"\\n    return round(float((moles * 0.0821 * temperature) / (pressure)))\\n\\n\\ndef pressure_and_volume_to_temperature(\\n    pressure: float, moles: float, volume: float\\n) -> float:\\n    \\\"\\\"\\\"\\n    Convert pressure and volume to temperature.\\n      Ideal gas laws are used.\\n      Temperature is taken in kelvin.\\n      Volume is taken in litres.\\n      Pressure has atm as SI unit.\\n\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\\n\\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\\n      20\\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\\n      60\\n    \\\"\\\"\\\"\\n    return round(float((pressure * volume) / (0.0821 * moles)))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "octal to decimal": "\"def oct_to_decimal(oct_string: str) -> int:\\n    \\\"\\\"\\\"\\n    Convert a octal value to its decimal equivalent\\n\\n    >>> oct_to_decimal(\\\"12\\\")\\n    10\\n    >>> oct_to_decimal(\\\" 12   \\\")\\n    10\\n    >>> oct_to_decimal(\\\"-45\\\")\\n    -37\\n    >>> oct_to_decimal(\\\"2-0Fm\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Non-octal value was passed to the function\\n    >>> oct_to_decimal(\\\"\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Empty string was passed to the function\\n    >>> oct_to_decimal(\\\"19\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Non-octal value was passed to the function\\n    \\\"\\\"\\\"\\n    oct_string = str(oct_string).strip()\\n    if not oct_string:\\n        raise ValueError(\\\"Empty string was passed to the function\\\")\\n    is_negative = oct_string[0] == \\\"-\\\"\\n    if is_negative:\\n        oct_string = oct_string[1:]\\n    if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):\\n        raise ValueError(\\\"Non-octal value was passed to the function\\\")\\n    decimal_number = 0\\n    for char in oct_string:\\n        decimal_number = 8 * decimal_number + int(char)\\n    if is_negative:\\n        decimal_number = -decimal_number\\n    return decimal_number\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "prefix conversions": "\"\\\"\\\"\\\"\\nConvert International System of Units (SI) and Binary prefixes\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom enum import Enum\\n\\n\\nclass SI_Unit(Enum):\\n    yotta = 24\\n    zetta = 21\\n    exa = 18\\n    peta = 15\\n    tera = 12\\n    giga = 9\\n    mega = 6\\n    kilo = 3\\n    hecto = 2\\n    deca = 1\\n    deci = -1\\n    centi = -2\\n    milli = -3\\n    micro = -6\\n    nano = -9\\n    pico = -12\\n    femto = -15\\n    atto = -18\\n    zepto = -21\\n    yocto = -24\\n\\n\\nclass Binary_Unit(Enum):\\n    yotta = 8\\n    zetta = 7\\n    exa = 6\\n    peta = 5\\n    tera = 4\\n    giga = 3\\n    mega = 2\\n    kilo = 1\\n\\n\\ndef convert_si_prefix(\\n    known_amount: float,\\n    known_prefix: str | SI_Unit,\\n    unknown_prefix: str | SI_Unit,\\n) -> float:\\n    \\\"\\\"\\\"\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Binary_prefix\\n    Wikipedia reference: https://en.wikipedia.org/wiki/International_System_of_Units\\n    >>> convert_si_prefix(1, SI_Unit.giga, SI_Unit.mega)\\n    1000\\n    >>> convert_si_prefix(1, SI_Unit.mega, SI_Unit.giga)\\n    0.001\\n    >>> convert_si_prefix(1, SI_Unit.kilo, SI_Unit.kilo)\\n    1\\n    >>> convert_si_prefix(1, 'giga', 'mega')\\n    1000\\n    >>> convert_si_prefix(1, 'gIGa', 'mEGa')\\n    1000\\n    \\\"\\\"\\\"\\n    if isinstance(known_prefix, str):\\n        known_prefix = SI_Unit[known_prefix.lower()]\\n    if isinstance(unknown_prefix, str):\\n        unknown_prefix = SI_Unit[unknown_prefix.lower()]\\n    unknown_amount: float = known_amount * (\\n        10 ** (known_prefix.value - unknown_prefix.value)\\n    )\\n    return unknown_amount\\n\\n\\ndef convert_binary_prefix(\\n    known_amount: float,\\n    known_prefix: str | Binary_Unit,\\n    unknown_prefix: str | Binary_Unit,\\n) -> float:\\n    \\\"\\\"\\\"\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Metric_prefix\\n    >>> convert_binary_prefix(1, Binary_Unit.giga, Binary_Unit.mega)\\n    1024\\n    >>> convert_binary_prefix(1, Binary_Unit.mega, Binary_Unit.giga)\\n    0.0009765625\\n    >>> convert_binary_prefix(1, Binary_Unit.kilo, Binary_Unit.kilo)\\n    1\\n    >>> convert_binary_prefix(1, 'giga', 'mega')\\n    1024\\n    >>> convert_binary_prefix(1, 'gIGa', 'mEGa')\\n    1024\\n    \\\"\\\"\\\"\\n    if isinstance(known_prefix, str):\\n        known_prefix = Binary_Unit[known_prefix.lower()]\\n    if isinstance(unknown_prefix, str):\\n        unknown_prefix = Binary_Unit[unknown_prefix.lower()]\\n    unknown_amount: float = known_amount * (\\n        2 ** ((known_prefix.value - unknown_prefix.value) * 10)\\n    )\\n    return unknown_amount\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "pressure conversions": "\"\\\"\\\"\\\"\\r\\nConversion of pressure units.\\r\\nAvailable Units:- Pascal,Bar,Kilopascal,Megapascal,psi(pound per square inch),\\r\\ninHg(in mercury column),torr,atm\\r\\nUSAGE :\\r\\n-> Import this file into their respective project.\\r\\n-> Use the function pressure_conversion() for conversion of pressure units.\\r\\n-> Parameters :\\r\\n    -> value : The number of from units you want to convert\\r\\n    -> from_type : From which type you want to convert\\r\\n    -> to_type : To which type you want to convert\\r\\nREFERENCES :\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Pascal_(unit)\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Pound_per_square_inch\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Inch_of_mercury\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Torr\\r\\n-> https://en.wikipedia.org/wiki/Standard_atmosphere_(unit)\\r\\n-> https://msestudent.com/what-are-the-units-of-pressure/\\r\\n-> https://www.unitconverters.net/pressure-converter.html\\r\\n\\\"\\\"\\\"\\r\\n\\r\\nfrom collections import namedtuple\\r\\n\\r\\nfrom_to = namedtuple(\\\"from_to\\\", \\\"from_ to\\\")\\r\\n\\r\\nPRESSURE_CONVERSION = {\\r\\n    \\\"atm\\\": from_to(1, 1),\\r\\n    \\\"pascal\\\": from_to(0.0000098, 101325),\\r\\n    \\\"bar\\\": from_to(0.986923, 1.01325),\\r\\n    \\\"kilopascal\\\": from_to(0.00986923, 101.325),\\r\\n    \\\"megapascal\\\": from_to(9.86923, 0.101325),\\r\\n    \\\"psi\\\": from_to(0.068046, 14.6959),\\r\\n    \\\"inHg\\\": from_to(0.0334211, 29.9213),\\r\\n    \\\"torr\\\": from_to(0.00131579, 760),\\r\\n}\\r\\n\\r\\n\\r\\ndef pressure_conversion(value: float, from_type: str, to_type: str) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Conversion between pressure units.\\r\\n    >>> pressure_conversion(4, \\\"atm\\\", \\\"pascal\\\")\\r\\n    405300\\r\\n    >>> pressure_conversion(1, \\\"pascal\\\", \\\"psi\\\")\\r\\n    0.00014401981999999998\\r\\n    >>> pressure_conversion(1, \\\"bar\\\", \\\"atm\\\")\\r\\n    0.986923\\r\\n    >>> pressure_conversion(3, \\\"kilopascal\\\", \\\"bar\\\")\\r\\n    0.029999991892499998\\r\\n    >>> pressure_conversion(2, \\\"megapascal\\\", \\\"psi\\\")\\r\\n    290.074434314\\r\\n    >>> pressure_conversion(4, \\\"psi\\\", \\\"torr\\\")\\r\\n    206.85984\\r\\n    >>> pressure_conversion(1, \\\"inHg\\\", \\\"atm\\\")\\r\\n    0.0334211\\r\\n    >>> pressure_conversion(1, \\\"torr\\\", \\\"psi\\\")\\r\\n    0.019336718261000002\\r\\n    >>> pressure_conversion(4, \\\"wrongUnit\\\", \\\"atm\\\")\\r\\n    Traceback (most recent call last):\\r\\n      File \\\"/usr/lib/python3.8/doctest.py\\\", line 1336, in __run\\r\\n        exec(compile(example.source, filename, \\\"single\\\",\\r\\n      File \\\"<doctest __main__.pressure_conversion[8]>\\\", line 1, in <module>\\r\\n        pressure_conversion(4, \\\"wrongUnit\\\", \\\"atm\\\")\\r\\n      File \\\"<string>\\\", line 67, in pressure_conversion\\r\\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\\r\\n    atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr\\r\\n    \\\"\\\"\\\"\\r\\n    if from_type not in PRESSURE_CONVERSION:\\r\\n        raise ValueError(\\r\\n            f\\\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\\\n\\\"\\r\\n            + \\\", \\\".join(PRESSURE_CONVERSION)\\r\\n        )\\r\\n    if to_type not in PRESSURE_CONVERSION:\\r\\n        raise ValueError(\\r\\n            f\\\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\\\n\\\"\\r\\n            + \\\", \\\".join(PRESSURE_CONVERSION)\\r\\n        )\\r\\n    return (\\r\\n        value * PRESSURE_CONVERSION[from_type].from_ * PRESSURE_CONVERSION[to_type].to\\r\\n    )\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "rgb hsv conversion": "\"\\\"\\\"\\\"\\nThe RGB color model is an additive color model in which red, green, and blue light\\nare added together in various ways to reproduce a broad array of colors. The name\\nof the model comes from the initials of the three additive primary colors, red,\\ngreen, and blue. Meanwhile, the HSV representation models how colors appear under\\nlight. In it, colors are represented using three components: hue, saturation and\\n(brightness-)value. This file provides functions for converting colors from one\\nrepresentation to the other.\\n\\n(description adapted from https://en.wikipedia.org/wiki/RGB_color_model and\\nhttps://en.wikipedia.org/wiki/HSL_and_HSV).\\n\\\"\\\"\\\"\\n\\n\\ndef hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\\n    \\\"\\\"\\\"\\n    Conversion from the HSV-representation to the RGB-representation.\\n    Expected RGB-values taken from\\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\\n\\n    >>> hsv_to_rgb(0, 0, 0)\\n    [0, 0, 0]\\n    >>> hsv_to_rgb(0, 0, 1)\\n    [255, 255, 255]\\n    >>> hsv_to_rgb(0, 1, 1)\\n    [255, 0, 0]\\n    >>> hsv_to_rgb(60, 1, 1)\\n    [255, 255, 0]\\n    >>> hsv_to_rgb(120, 1, 1)\\n    [0, 255, 0]\\n    >>> hsv_to_rgb(240, 1, 1)\\n    [0, 0, 255]\\n    >>> hsv_to_rgb(300, 1, 1)\\n    [255, 0, 255]\\n    >>> hsv_to_rgb(180, 0.5, 0.5)\\n    [64, 128, 128]\\n    >>> hsv_to_rgb(234, 0.14, 0.88)\\n    [193, 196, 224]\\n    >>> hsv_to_rgb(330, 0.75, 0.5)\\n    [128, 32, 80]\\n    \\\"\\\"\\\"\\n    if hue < 0 or hue > 360:\\n        raise Exception(\\\"hue should be between 0 and 360\\\")\\n\\n    if saturation < 0 or saturation > 1:\\n        raise Exception(\\\"saturation should be between 0 and 1\\\")\\n\\n    if value < 0 or value > 1:\\n        raise Exception(\\\"value should be between 0 and 1\\\")\\n\\n    chroma = value * saturation\\n    hue_section = hue / 60\\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\\n    match_value = value - chroma\\n\\n    if hue_section >= 0 and hue_section <= 1:\\n        red = round(255 * (chroma + match_value))\\n        green = round(255 * (second_largest_component + match_value))\\n        blue = round(255 * (match_value))\\n    elif hue_section > 1 and hue_section <= 2:\\n        red = round(255 * (second_largest_component + match_value))\\n        green = round(255 * (chroma + match_value))\\n        blue = round(255 * (match_value))\\n    elif hue_section > 2 and hue_section <= 3:\\n        red = round(255 * (match_value))\\n        green = round(255 * (chroma + match_value))\\n        blue = round(255 * (second_largest_component + match_value))\\n    elif hue_section > 3 and hue_section <= 4:\\n        red = round(255 * (match_value))\\n        green = round(255 * (second_largest_component + match_value))\\n        blue = round(255 * (chroma + match_value))\\n    elif hue_section > 4 and hue_section <= 5:\\n        red = round(255 * (second_largest_component + match_value))\\n        green = round(255 * (match_value))\\n        blue = round(255 * (chroma + match_value))\\n    else:\\n        red = round(255 * (chroma + match_value))\\n        green = round(255 * (match_value))\\n        blue = round(255 * (second_largest_component + match_value))\\n\\n    return [red, green, blue]\\n\\n\\ndef rgb_to_hsv(red: int, green: int, blue: int) -> list[float]:\\n    \\\"\\\"\\\"\\n    Conversion from the RGB-representation to the HSV-representation.\\n    The tested values are the reverse values from the hsv_to_rgb-doctests.\\n    Function \\\"approximately_equal_hsv\\\" is needed because of small deviations due to\\n    rounding for the RGB-values.\\n\\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 0), [0, 0, 0])\\n    True\\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 255), [0, 0, 1])\\n    True\\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 0), [0, 1, 1])\\n    True\\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 0), [60, 1, 1])\\n    True\\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 255, 0), [120, 1, 1])\\n    True\\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 255), [240, 1, 1])\\n    True\\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 255), [300, 1, 1])\\n    True\\n    >>> approximately_equal_hsv(rgb_to_hsv(64, 128, 128), [180, 0.5, 0.5])\\n    True\\n    >>> approximately_equal_hsv(rgb_to_hsv(193, 196, 224), [234, 0.14, 0.88])\\n    True\\n    >>> approximately_equal_hsv(rgb_to_hsv(128, 32, 80), [330, 0.75, 0.5])\\n    True\\n    \\\"\\\"\\\"\\n    if red < 0 or red > 255:\\n        raise Exception(\\\"red should be between 0 and 255\\\")\\n\\n    if green < 0 or green > 255:\\n        raise Exception(\\\"green should be between 0 and 255\\\")\\n\\n    if blue < 0 or blue > 255:\\n        raise Exception(\\\"blue should be between 0 and 255\\\")\\n\\n    float_red = red / 255\\n    float_green = green / 255\\n    float_blue = blue / 255\\n    value = max(max(float_red, float_green), float_blue)\\n    chroma = value - min(min(float_red, float_green), float_blue)\\n    saturation = 0 if value == 0 else chroma / value\\n\\n    if chroma == 0:\\n        hue = 0.0\\n    elif value == float_red:\\n        hue = 60 * (0 + (float_green - float_blue) / chroma)\\n    elif value == float_green:\\n        hue = 60 * (2 + (float_blue - float_red) / chroma)\\n    else:\\n        hue = 60 * (4 + (float_red - float_green) / chroma)\\n\\n    hue = (hue + 360) % 360\\n\\n    return [hue, saturation, value]\\n\\n\\ndef approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\\n    \\\"\\\"\\\"\\n    Utility-function to check that two hsv-colors are approximately equal\\n\\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\\n    True\\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\\n    True\\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\\n    False\\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\\n    False\\n    \\\"\\\"\\\"\\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\\n\\n    return check_hue and check_saturation and check_value\\n\"",
    "roman numerals": "\"def roman_to_int(roman: str) -> int:\\r\\n    \\\"\\\"\\\"\\r\\n    LeetCode No. 13 Roman to Integer\\r\\n    Given a roman numeral, convert it to an integer.\\r\\n    Input is guaranteed to be within the range from 1 to 3999.\\r\\n    https://en.wikipedia.org/wiki/Roman_numerals\\r\\n    >>> tests = {\\\"III\\\": 3, \\\"CLIV\\\": 154, \\\"MIX\\\": 1009, \\\"MMD\\\": 2500, \\\"MMMCMXCIX\\\": 3999}\\r\\n    >>> all(roman_to_int(key) == value for key, value in tests.items())\\r\\n    True\\r\\n    \\\"\\\"\\\"\\r\\n    vals = {\\\"I\\\": 1, \\\"V\\\": 5, \\\"X\\\": 10, \\\"L\\\": 50, \\\"C\\\": 100, \\\"D\\\": 500, \\\"M\\\": 1000}\\r\\n    total = 0\\r\\n    place = 0\\r\\n    while place < len(roman):\\r\\n        if (place + 1 < len(roman)) and (vals[roman[place]] < vals[roman[place + 1]]):\\r\\n            total += vals[roman[place + 1]] - vals[roman[place]]\\r\\n            place += 2\\r\\n        else:\\r\\n            total += vals[roman[place]]\\r\\n            place += 1\\r\\n    return total\\r\\n\\r\\n\\r\\ndef int_to_roman(number: int) -> str:\\r\\n    \\\"\\\"\\\"\\r\\n    Given a integer, convert it to an roman numeral.\\r\\n    https://en.wikipedia.org/wiki/Roman_numerals\\r\\n    >>> tests = {\\\"III\\\": 3, \\\"CLIV\\\": 154, \\\"MIX\\\": 1009, \\\"MMD\\\": 2500, \\\"MMMCMXCIX\\\": 3999}\\r\\n    >>> all(int_to_roman(value) == key for key, value in tests.items())\\r\\n    True\\r\\n    \\\"\\\"\\\"\\r\\n    ROMAN = [\\r\\n        (1000, \\\"M\\\"),\\r\\n        (900, \\\"CM\\\"),\\r\\n        (500, \\\"D\\\"),\\r\\n        (400, \\\"CD\\\"),\\r\\n        (100, \\\"C\\\"),\\r\\n        (90, \\\"XC\\\"),\\r\\n        (50, \\\"L\\\"),\\r\\n        (40, \\\"XL\\\"),\\r\\n        (10, \\\"X\\\"),\\r\\n        (9, \\\"IX\\\"),\\r\\n        (5, \\\"V\\\"),\\r\\n        (4, \\\"IV\\\"),\\r\\n        (1, \\\"I\\\"),\\r\\n    ]\\r\\n    result = []\\r\\n    for (arabic, roman) in ROMAN:\\r\\n        (factor, number) = divmod(number, arabic)\\r\\n        result.append(roman * factor)\\r\\n        if number == 0:\\r\\n            break\\r\\n    return \\\"\\\".join(result)\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "temperature conversions": "\"\\\"\\\"\\\" Convert between different units of temperature \\\"\\\"\\\"\\n\\n\\ndef celsius_to_fahrenheit(celsius: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Celsius to Fahrenheit and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\n\\n    >>> celsius_to_fahrenheit(273.354, 3)\\n    524.037\\n    >>> celsius_to_fahrenheit(273.354, 0)\\n    524.0\\n    >>> celsius_to_fahrenheit(-40.0)\\n    -40.0\\n    >>> celsius_to_fahrenheit(-20.0)\\n    -4.0\\n    >>> celsius_to_fahrenheit(0)\\n    32.0\\n    >>> celsius_to_fahrenheit(20)\\n    68.0\\n    >>> celsius_to_fahrenheit(\\\"40\\\")\\n    104.0\\n    >>> celsius_to_fahrenheit(\\\"celsius\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'celsius'\\n    \\\"\\\"\\\"\\n    return round((float(celsius) * 9 / 5) + 32, ndigits)\\n\\n\\ndef celsius_to_kelvin(celsius: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Celsius to Kelvin and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\n\\n    >>> celsius_to_kelvin(273.354, 3)\\n    546.504\\n    >>> celsius_to_kelvin(273.354, 0)\\n    547.0\\n    >>> celsius_to_kelvin(0)\\n    273.15\\n    >>> celsius_to_kelvin(20.0)\\n    293.15\\n    >>> celsius_to_kelvin(\\\"40\\\")\\n    313.15\\n    >>> celsius_to_kelvin(\\\"celsius\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'celsius'\\n    \\\"\\\"\\\"\\n    return round(float(celsius) + 273.15, ndigits)\\n\\n\\ndef celsius_to_rankine(celsius: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Celsius to Rankine and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\n\\n    >>> celsius_to_rankine(273.354, 3)\\n    983.707\\n    >>> celsius_to_rankine(273.354, 0)\\n    984.0\\n    >>> celsius_to_rankine(0)\\n    491.67\\n    >>> celsius_to_rankine(20.0)\\n    527.67\\n    >>> celsius_to_rankine(\\\"40\\\")\\n    563.67\\n    >>> celsius_to_rankine(\\\"celsius\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'celsius'\\n    \\\"\\\"\\\"\\n    return round((float(celsius) * 9 / 5) + 491.67, ndigits)\\n\\n\\ndef fahrenheit_to_celsius(fahrenheit: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Fahrenheit to Celsius and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\n\\n    >>> fahrenheit_to_celsius(273.354, 3)\\n    134.086\\n    >>> fahrenheit_to_celsius(273.354, 0)\\n    134.0\\n    >>> fahrenheit_to_celsius(0)\\n    -17.78\\n    >>> fahrenheit_to_celsius(20.0)\\n    -6.67\\n    >>> fahrenheit_to_celsius(40.0)\\n    4.44\\n    >>> fahrenheit_to_celsius(60)\\n    15.56\\n    >>> fahrenheit_to_celsius(80)\\n    26.67\\n    >>> fahrenheit_to_celsius(\\\"100\\\")\\n    37.78\\n    >>> fahrenheit_to_celsius(\\\"fahrenheit\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'fahrenheit'\\n    \\\"\\\"\\\"\\n    return round((float(fahrenheit) - 32) * 5 / 9, ndigits)\\n\\n\\ndef fahrenheit_to_kelvin(fahrenheit: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Fahrenheit to Kelvin and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\n\\n    >>> fahrenheit_to_kelvin(273.354, 3)\\n    407.236\\n    >>> fahrenheit_to_kelvin(273.354, 0)\\n    407.0\\n    >>> fahrenheit_to_kelvin(0)\\n    255.37\\n    >>> fahrenheit_to_kelvin(20.0)\\n    266.48\\n    >>> fahrenheit_to_kelvin(40.0)\\n    277.59\\n    >>> fahrenheit_to_kelvin(60)\\n    288.71\\n    >>> fahrenheit_to_kelvin(80)\\n    299.82\\n    >>> fahrenheit_to_kelvin(\\\"100\\\")\\n    310.93\\n    >>> fahrenheit_to_kelvin(\\\"fahrenheit\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'fahrenheit'\\n    \\\"\\\"\\\"\\n    return round(((float(fahrenheit) - 32) * 5 / 9) + 273.15, ndigits)\\n\\n\\ndef fahrenheit_to_rankine(fahrenheit: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Fahrenheit to Rankine and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\n\\n    >>> fahrenheit_to_rankine(273.354, 3)\\n    733.024\\n    >>> fahrenheit_to_rankine(273.354, 0)\\n    733.0\\n    >>> fahrenheit_to_rankine(0)\\n    459.67\\n    >>> fahrenheit_to_rankine(20.0)\\n    479.67\\n    >>> fahrenheit_to_rankine(40.0)\\n    499.67\\n    >>> fahrenheit_to_rankine(60)\\n    519.67\\n    >>> fahrenheit_to_rankine(80)\\n    539.67\\n    >>> fahrenheit_to_rankine(\\\"100\\\")\\n    559.67\\n    >>> fahrenheit_to_rankine(\\\"fahrenheit\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'fahrenheit'\\n    \\\"\\\"\\\"\\n    return round(float(fahrenheit) + 459.67, ndigits)\\n\\n\\ndef kelvin_to_celsius(kelvin: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Kelvin to Celsius and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\n\\n    >>> kelvin_to_celsius(273.354, 3)\\n    0.204\\n    >>> kelvin_to_celsius(273.354, 0)\\n    0.0\\n    >>> kelvin_to_celsius(273.15)\\n    0.0\\n    >>> kelvin_to_celsius(300)\\n    26.85\\n    >>> kelvin_to_celsius(\\\"315.5\\\")\\n    42.35\\n    >>> kelvin_to_celsius(\\\"kelvin\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'kelvin'\\n    \\\"\\\"\\\"\\n    return round(float(kelvin) - 273.15, ndigits)\\n\\n\\ndef kelvin_to_fahrenheit(kelvin: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Kelvin to Fahrenheit and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\n\\n    >>> kelvin_to_fahrenheit(273.354, 3)\\n    32.367\\n    >>> kelvin_to_fahrenheit(273.354, 0)\\n    32.0\\n    >>> kelvin_to_fahrenheit(273.15)\\n    32.0\\n    >>> kelvin_to_fahrenheit(300)\\n    80.33\\n    >>> kelvin_to_fahrenheit(\\\"315.5\\\")\\n    108.23\\n    >>> kelvin_to_fahrenheit(\\\"kelvin\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'kelvin'\\n    \\\"\\\"\\\"\\n    return round(((float(kelvin) - 273.15) * 9 / 5) + 32, ndigits)\\n\\n\\ndef kelvin_to_rankine(kelvin: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Kelvin to Rankine and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\n\\n    >>> kelvin_to_rankine(273.354, 3)\\n    492.037\\n    >>> kelvin_to_rankine(273.354, 0)\\n    492.0\\n    >>> kelvin_to_rankine(0)\\n    0.0\\n    >>> kelvin_to_rankine(20.0)\\n    36.0\\n    >>> kelvin_to_rankine(\\\"40\\\")\\n    72.0\\n    >>> kelvin_to_rankine(\\\"kelvin\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'kelvin'\\n    \\\"\\\"\\\"\\n    return round((float(kelvin) * 9 / 5), ndigits)\\n\\n\\ndef rankine_to_celsius(rankine: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Rankine to Celsius and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\\n\\n    >>> rankine_to_celsius(273.354, 3)\\n    -121.287\\n    >>> rankine_to_celsius(273.354, 0)\\n    -121.0\\n    >>> rankine_to_celsius(273.15)\\n    -121.4\\n    >>> rankine_to_celsius(300)\\n    -106.48\\n    >>> rankine_to_celsius(\\\"315.5\\\")\\n    -97.87\\n    >>> rankine_to_celsius(\\\"rankine\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'rankine'\\n    \\\"\\\"\\\"\\n    return round((float(rankine) - 491.67) * 5 / 9, ndigits)\\n\\n\\ndef rankine_to_fahrenheit(rankine: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Rankine to Fahrenheit and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\\n\\n    >>> rankine_to_fahrenheit(273.15)\\n    -186.52\\n    >>> rankine_to_fahrenheit(300)\\n    -159.67\\n    >>> rankine_to_fahrenheit(\\\"315.5\\\")\\n    -144.17\\n    >>> rankine_to_fahrenheit(\\\"rankine\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'rankine'\\n    \\\"\\\"\\\"\\n    return round(float(rankine) - 459.67, ndigits)\\n\\n\\ndef rankine_to_kelvin(rankine: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from Rankine to Kelvin and round it to 2 decimal places.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\\n\\n    >>> rankine_to_kelvin(0)\\n    0.0\\n    >>> rankine_to_kelvin(20.0)\\n    11.11\\n    >>> rankine_to_kelvin(\\\"40\\\")\\n    22.22\\n    >>> rankine_to_kelvin(\\\"rankine\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'rankine'\\n    \\\"\\\"\\\"\\n    return round((float(rankine) * 5 / 9), ndigits)\\n\\n\\ndef reaumur_to_kelvin(reaumur: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from reaumur to Kelvin and round it to 2 decimal places.\\n    Reference:- http://www.csgnetwork.com/temp2conv.html\\n\\n    >>> reaumur_to_kelvin(0)\\n    273.15\\n    >>> reaumur_to_kelvin(20.0)\\n    298.15\\n    >>> reaumur_to_kelvin(40)\\n    323.15\\n    >>> reaumur_to_kelvin(\\\"reaumur\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'reaumur'\\n    \\\"\\\"\\\"\\n    return round((float(reaumur) * 1.25 + 273.15), ndigits)\\n\\n\\ndef reaumur_to_fahrenheit(reaumur: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from reaumur to fahrenheit and round it to 2 decimal places.\\n    Reference:- http://www.csgnetwork.com/temp2conv.html\\n\\n    >>> reaumur_to_fahrenheit(0)\\n    32.0\\n    >>> reaumur_to_fahrenheit(20.0)\\n    77.0\\n    >>> reaumur_to_fahrenheit(40)\\n    122.0\\n    >>> reaumur_to_fahrenheit(\\\"reaumur\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'reaumur'\\n    \\\"\\\"\\\"\\n    return round((float(reaumur) * 2.25 + 32), ndigits)\\n\\n\\ndef reaumur_to_celsius(reaumur: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from reaumur to celsius and round it to 2 decimal places.\\n    Reference:- http://www.csgnetwork.com/temp2conv.html\\n\\n    >>> reaumur_to_celsius(0)\\n    0.0\\n    >>> reaumur_to_celsius(20.0)\\n    25.0\\n    >>> reaumur_to_celsius(40)\\n    50.0\\n    >>> reaumur_to_celsius(\\\"reaumur\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'reaumur'\\n    \\\"\\\"\\\"\\n    return round((float(reaumur) * 1.25), ndigits)\\n\\n\\ndef reaumur_to_rankine(reaumur: float, ndigits: int = 2) -> float:\\n    \\\"\\\"\\\"\\n    Convert a given value from reaumur to rankine and round it to 2 decimal places.\\n    Reference:- http://www.csgnetwork.com/temp2conv.html\\n\\n    >>> reaumur_to_rankine(0)\\n    491.67\\n    >>> reaumur_to_rankine(20.0)\\n    536.67\\n    >>> reaumur_to_rankine(40)\\n    581.67\\n    >>> reaumur_to_rankine(\\\"reaumur\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: could not convert string to float: 'reaumur'\\n    \\\"\\\"\\\"\\n    return round((float(reaumur) * 2.25 + 32 + 459.67), ndigits)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "volume conversions": "\"\\\"\\\"\\\"\\r\\nConversion of volume units.\\r\\nAvailable Units:- Cubic metre,Litre,KiloLitre,Gallon,Cubic yard,Cubic foot,cup\\r\\nUSAGE :\\r\\n-> Import this file into their respective project.\\r\\n-> Use the function length_conversion() for conversion of volume units.\\r\\n-> Parameters :\\r\\n    -> value : The number of from units you want to convert\\r\\n    -> from_type : From which type you want to convert\\r\\n    -> to_type : To which type you want to convert\\r\\nREFERENCES :\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Cubic_metre\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Litre\\r\\n-> Wikipedia reference: https://en.wiktionary.org/wiki/kilolitre\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Gallon\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Cubic_yard\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Cubic_foot\\r\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Cup_(unit)\\r\\n\\\"\\\"\\\"\\r\\n\\r\\nfrom collections import namedtuple\\r\\n\\r\\nfrom_to = namedtuple(\\\"from_to\\\", \\\"from_ to\\\")\\r\\n\\r\\nMETRIC_CONVERSION = {\\r\\n    \\\"cubicmeter\\\": from_to(1, 1),\\r\\n    \\\"litre\\\": from_to(0.001, 1000),\\r\\n    \\\"kilolitre\\\": from_to(1, 1),\\r\\n    \\\"gallon\\\": from_to(0.00454, 264.172),\\r\\n    \\\"cubicyard\\\": from_to(0.76455, 1.30795),\\r\\n    \\\"cubicfoot\\\": from_to(0.028, 35.3147),\\r\\n    \\\"cup\\\": from_to(0.000236588, 4226.75),\\r\\n}\\r\\n\\r\\n\\r\\ndef volume_conversion(value: float, from_type: str, to_type: str) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Conversion between volume units.\\r\\n    >>> volume_conversion(4, \\\"cubicmeter\\\", \\\"litre\\\")\\r\\n    4000\\r\\n    >>> volume_conversion(1, \\\"litre\\\", \\\"gallon\\\")\\r\\n    0.264172\\r\\n    >>> volume_conversion(1, \\\"kilolitre\\\", \\\"cubicmeter\\\")\\r\\n    1\\r\\n    >>> volume_conversion(3, \\\"gallon\\\", \\\"cubicyard\\\")\\r\\n    0.017814279\\r\\n    >>> volume_conversion(2, \\\"cubicyard\\\", \\\"litre\\\")\\r\\n    1529.1\\r\\n    >>> volume_conversion(4, \\\"cubicfoot\\\", \\\"cup\\\")\\r\\n    473.396\\r\\n    >>> volume_conversion(1, \\\"cup\\\", \\\"kilolitre\\\")\\r\\n    0.000236588\\r\\n    >>> volume_conversion(4, \\\"wrongUnit\\\", \\\"litre\\\")\\r\\n    Traceback (most recent call last):\\r\\n      File \\\"/usr/lib/python3.8/doctest.py\\\", line 1336, in __run\\r\\n        exec(compile(example.source, filename, \\\"single\\\",\\r\\n      File \\\"<doctest __main__.volume_conversion[7]>\\\", line 1, in <module>\\r\\n        volume_conversion(4, \\\"wrongUnit\\\", \\\"litre\\\")\\r\\n      File \\\"<string>\\\", line 62, in volume_conversion\\r\\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\\r\\n    cubicmeter, litre, kilolitre, gallon, cubicyard, cubicfoot, cup\\r\\n    \\\"\\\"\\\"\\r\\n    if from_type not in METRIC_CONVERSION:\\r\\n        raise ValueError(\\r\\n            f\\\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\\\n\\\"\\r\\n            + \\\", \\\".join(METRIC_CONVERSION)\\r\\n        )\\r\\n    if to_type not in METRIC_CONVERSION:\\r\\n        raise ValueError(\\r\\n            f\\\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\\\n\\\"\\r\\n            + \\\", \\\".join(METRIC_CONVERSION)\\r\\n        )\\r\\n    return value * METRIC_CONVERSION[from_type].from_ * METRIC_CONVERSION[to_type].to\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "weight conversion": "\"\\\"\\\"\\\"\\nConversion of weight units.\\n\\n__author__ = \\\"Anubhav Solanki\\\"\\n__license__ = \\\"MIT\\\"\\n__version__ = \\\"1.1.0\\\"\\n__maintainer__ = \\\"Anubhav Solanki\\\"\\n__email__ = \\\"anubhavsolanki0@gmail.com\\\"\\n\\nUSAGE :\\n-> Import this file into their respective project.\\n-> Use the function weight_conversion() for conversion of weight units.\\n-> Parameters :\\n    -> from_type : From which type you want to convert\\n    -> to_type : To which type you want to convert\\n    -> value : the value which you want to convert\\n\\nREFERENCES :\\n\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Kilogram\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Gram\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Millimetre\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Tonne\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Long_ton\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Short_ton\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Pound\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Ounce\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Fineness#Karat\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Dalton_(unit)\\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Stone_(unit)\\n\\\"\\\"\\\"\\n\\nKILOGRAM_CHART: dict[str, float] = {\\n    \\\"kilogram\\\": 1,\\n    \\\"gram\\\": pow(10, 3),\\n    \\\"milligram\\\": pow(10, 6),\\n    \\\"metric-ton\\\": pow(10, -3),\\n    \\\"long-ton\\\": 0.0009842073,\\n    \\\"short-ton\\\": 0.0011023122,\\n    \\\"pound\\\": 2.2046244202,\\n    \\\"stone\\\": 0.1574731728,\\n    \\\"ounce\\\": 35.273990723,\\n    \\\"carrat\\\": 5000,\\n    \\\"atomic-mass-unit\\\": 6.022136652e26,\\n}\\n\\nWEIGHT_TYPE_CHART: dict[str, float] = {\\n    \\\"kilogram\\\": 1,\\n    \\\"gram\\\": pow(10, -3),\\n    \\\"milligram\\\": pow(10, -6),\\n    \\\"metric-ton\\\": pow(10, 3),\\n    \\\"long-ton\\\": 1016.04608,\\n    \\\"short-ton\\\": 907.184,\\n    \\\"pound\\\": 0.453592,\\n    \\\"stone\\\": 6.35029,\\n    \\\"ounce\\\": 0.0283495,\\n    \\\"carrat\\\": 0.0002,\\n    \\\"atomic-mass-unit\\\": 1.660540199e-27,\\n}\\n\\n\\ndef weight_conversion(from_type: str, to_type: str, value: float) -> float:\\n    \\\"\\\"\\\"\\n    Conversion of weight unit with the help of KILOGRAM_CHART\\n\\n    \\\"kilogram\\\" : 1,\\n    \\\"gram\\\" : pow(10, 3),\\n    \\\"milligram\\\" : pow(10, 6),\\n    \\\"metric-ton\\\" : pow(10, -3),\\n    \\\"long-ton\\\" : 0.0009842073,\\n    \\\"short-ton\\\" : 0.0011023122,\\n    \\\"pound\\\" : 2.2046244202,\\n    \\\"stone\\\": 0.1574731728,\\n    \\\"ounce\\\" : 35.273990723,\\n    \\\"carrat\\\" : 5000,\\n    \\\"atomic-mass-unit\\\" : 6.022136652E+26\\n\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"kilogram\\\",4)\\n    4\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"gram\\\",1)\\n    1000\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"milligram\\\",4)\\n    4000000\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"metric-ton\\\",4)\\n    0.004\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"long-ton\\\",3)\\n    0.0029526219\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"short-ton\\\",1)\\n    0.0011023122\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"pound\\\",4)\\n    8.8184976808\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"stone\\\",5)\\n    0.7873658640000001\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"ounce\\\",4)\\n    141.095962892\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"carrat\\\",3)\\n    15000\\n    >>> weight_conversion(\\\"kilogram\\\",\\\"atomic-mass-unit\\\",1)\\n    6.022136652e+26\\n    >>> weight_conversion(\\\"gram\\\",\\\"kilogram\\\",1)\\n    0.001\\n    >>> weight_conversion(\\\"gram\\\",\\\"gram\\\",3)\\n    3.0\\n    >>> weight_conversion(\\\"gram\\\",\\\"milligram\\\",2)\\n    2000.0\\n    >>> weight_conversion(\\\"gram\\\",\\\"metric-ton\\\",4)\\n    4e-06\\n    >>> weight_conversion(\\\"gram\\\",\\\"long-ton\\\",3)\\n    2.9526219e-06\\n    >>> weight_conversion(\\\"gram\\\",\\\"short-ton\\\",3)\\n    3.3069366000000003e-06\\n    >>> weight_conversion(\\\"gram\\\",\\\"pound\\\",3)\\n    0.0066138732606\\n    >>> weight_conversion(\\\"gram\\\",\\\"stone\\\",4)\\n    0.0006298926912000001\\n    >>> weight_conversion(\\\"gram\\\",\\\"ounce\\\",1)\\n    0.035273990723\\n    >>> weight_conversion(\\\"gram\\\",\\\"carrat\\\",2)\\n    10.0\\n    >>> weight_conversion(\\\"gram\\\",\\\"atomic-mass-unit\\\",1)\\n    6.022136652e+23\\n    >>> weight_conversion(\\\"milligram\\\",\\\"kilogram\\\",1)\\n    1e-06\\n    >>> weight_conversion(\\\"milligram\\\",\\\"gram\\\",2)\\n    0.002\\n    >>> weight_conversion(\\\"milligram\\\",\\\"milligram\\\",3)\\n    3.0\\n    >>> weight_conversion(\\\"milligram\\\",\\\"metric-ton\\\",3)\\n    3e-09\\n    >>> weight_conversion(\\\"milligram\\\",\\\"long-ton\\\",3)\\n    2.9526219e-09\\n    >>> weight_conversion(\\\"milligram\\\",\\\"short-ton\\\",1)\\n    1.1023122e-09\\n    >>> weight_conversion(\\\"milligram\\\",\\\"pound\\\",3)\\n    6.6138732605999995e-06\\n    >>> weight_conversion(\\\"milligram\\\",\\\"ounce\\\",2)\\n    7.054798144599999e-05\\n    >>> weight_conversion(\\\"milligram\\\",\\\"carrat\\\",1)\\n    0.005\\n    >>> weight_conversion(\\\"milligram\\\",\\\"atomic-mass-unit\\\",1)\\n    6.022136652e+20\\n    >>> weight_conversion(\\\"metric-ton\\\",\\\"kilogram\\\",2)\\n    2000\\n    >>> weight_conversion(\\\"metric-ton\\\",\\\"gram\\\",2)\\n    2000000\\n    >>> weight_conversion(\\\"metric-ton\\\",\\\"milligram\\\",3)\\n    3000000000\\n    >>> weight_conversion(\\\"metric-ton\\\",\\\"metric-ton\\\",2)\\n    2.0\\n    >>> weight_conversion(\\\"metric-ton\\\",\\\"long-ton\\\",3)\\n    2.9526219\\n    >>> weight_conversion(\\\"metric-ton\\\",\\\"short-ton\\\",2)\\n    2.2046244\\n    >>> weight_conversion(\\\"metric-ton\\\",\\\"pound\\\",3)\\n    6613.8732606\\n    >>> weight_conversion(\\\"metric-ton\\\",\\\"ounce\\\",4)\\n    141095.96289199998\\n    >>> weight_conversion(\\\"metric-ton\\\",\\\"carrat\\\",4)\\n    20000000\\n    >>> weight_conversion(\\\"metric-ton\\\",\\\"atomic-mass-unit\\\",1)\\n    6.022136652e+29\\n    >>> weight_conversion(\\\"long-ton\\\",\\\"kilogram\\\",4)\\n    4064.18432\\n    >>> weight_conversion(\\\"long-ton\\\",\\\"gram\\\",4)\\n    4064184.32\\n    >>> weight_conversion(\\\"long-ton\\\",\\\"milligram\\\",3)\\n    3048138240.0\\n    >>> weight_conversion(\\\"long-ton\\\",\\\"metric-ton\\\",4)\\n    4.06418432\\n    >>> weight_conversion(\\\"long-ton\\\",\\\"long-ton\\\",3)\\n    2.999999907217152\\n    >>> weight_conversion(\\\"long-ton\\\",\\\"short-ton\\\",1)\\n    1.119999989746176\\n    >>> weight_conversion(\\\"long-ton\\\",\\\"pound\\\",3)\\n    6720.000000049448\\n    >>> weight_conversion(\\\"long-ton\\\",\\\"ounce\\\",1)\\n    35840.000000060514\\n    >>> weight_conversion(\\\"long-ton\\\",\\\"carrat\\\",4)\\n    20320921.599999998\\n    >>> weight_conversion(\\\"long-ton\\\",\\\"atomic-mass-unit\\\",4)\\n    2.4475073353955697e+30\\n    >>> weight_conversion(\\\"short-ton\\\",\\\"kilogram\\\",3)\\n    2721.5519999999997\\n    >>> weight_conversion(\\\"short-ton\\\",\\\"gram\\\",3)\\n    2721552.0\\n    >>> weight_conversion(\\\"short-ton\\\",\\\"milligram\\\",1)\\n    907184000.0\\n    >>> weight_conversion(\\\"short-ton\\\",\\\"metric-ton\\\",4)\\n    3.628736\\n    >>> weight_conversion(\\\"short-ton\\\",\\\"long-ton\\\",3)\\n    2.6785713457296\\n    >>> weight_conversion(\\\"short-ton\\\",\\\"short-ton\\\",3)\\n    2.9999999725344\\n    >>> weight_conversion(\\\"short-ton\\\",\\\"pound\\\",2)\\n    4000.0000000294335\\n    >>> weight_conversion(\\\"short-ton\\\",\\\"ounce\\\",4)\\n    128000.00000021611\\n    >>> weight_conversion(\\\"short-ton\\\",\\\"carrat\\\",4)\\n    18143680.0\\n    >>> weight_conversion(\\\"short-ton\\\",\\\"atomic-mass-unit\\\",1)\\n    5.463186016507968e+29\\n    >>> weight_conversion(\\\"pound\\\",\\\"kilogram\\\",4)\\n    1.814368\\n    >>> weight_conversion(\\\"pound\\\",\\\"gram\\\",2)\\n    907.184\\n    >>> weight_conversion(\\\"pound\\\",\\\"milligram\\\",3)\\n    1360776.0\\n    >>> weight_conversion(\\\"pound\\\",\\\"metric-ton\\\",3)\\n    0.001360776\\n    >>> weight_conversion(\\\"pound\\\",\\\"long-ton\\\",2)\\n    0.0008928571152432\\n    >>> weight_conversion(\\\"pound\\\",\\\"short-ton\\\",1)\\n    0.0004999999954224\\n    >>> weight_conversion(\\\"pound\\\",\\\"pound\\\",3)\\n    3.0000000000220752\\n    >>> weight_conversion(\\\"pound\\\",\\\"ounce\\\",1)\\n    16.000000000027015\\n    >>> weight_conversion(\\\"pound\\\",\\\"carrat\\\",1)\\n    2267.96\\n    >>> weight_conversion(\\\"pound\\\",\\\"atomic-mass-unit\\\",4)\\n    1.0926372033015936e+27\\n    >>> weight_conversion(\\\"stone\\\",\\\"kilogram\\\",5)\\n    31.751450000000002\\n    >>> weight_conversion(\\\"stone\\\",\\\"gram\\\",2)\\n    12700.58\\n    >>> weight_conversion(\\\"stone\\\",\\\"milligram\\\",3)\\n    19050870.0\\n    >>> weight_conversion(\\\"stone\\\",\\\"metric-ton\\\",3)\\n    0.01905087\\n    >>> weight_conversion(\\\"stone\\\",\\\"long-ton\\\",3)\\n    0.018750005325351003\\n    >>> weight_conversion(\\\"stone\\\",\\\"short-ton\\\",3)\\n    0.021000006421614002\\n    >>> weight_conversion(\\\"stone\\\",\\\"pound\\\",2)\\n    28.00000881870372\\n    >>> weight_conversion(\\\"stone\\\",\\\"ounce\\\",1)\\n    224.00007054835967\\n    >>> weight_conversion(\\\"stone\\\",\\\"carrat\\\",2)\\n    63502.9\\n    >>> weight_conversion(\\\"ounce\\\",\\\"kilogram\\\",3)\\n    0.0850485\\n    >>> weight_conversion(\\\"ounce\\\",\\\"gram\\\",3)\\n    85.0485\\n    >>> weight_conversion(\\\"ounce\\\",\\\"milligram\\\",4)\\n    113398.0\\n    >>> weight_conversion(\\\"ounce\\\",\\\"metric-ton\\\",4)\\n    0.000113398\\n    >>> weight_conversion(\\\"ounce\\\",\\\"long-ton\\\",4)\\n    0.0001116071394054\\n    >>> weight_conversion(\\\"ounce\\\",\\\"short-ton\\\",4)\\n    0.0001249999988556\\n    >>> weight_conversion(\\\"ounce\\\",\\\"pound\\\",1)\\n    0.0625000000004599\\n    >>> weight_conversion(\\\"ounce\\\",\\\"ounce\\\",2)\\n    2.000000000003377\\n    >>> weight_conversion(\\\"ounce\\\",\\\"carrat\\\",1)\\n    141.7475\\n    >>> weight_conversion(\\\"ounce\\\",\\\"atomic-mass-unit\\\",1)\\n    1.70724563015874e+25\\n    >>> weight_conversion(\\\"carrat\\\",\\\"kilogram\\\",1)\\n    0.0002\\n    >>> weight_conversion(\\\"carrat\\\",\\\"gram\\\",4)\\n    0.8\\n    >>> weight_conversion(\\\"carrat\\\",\\\"milligram\\\",2)\\n    400.0\\n    >>> weight_conversion(\\\"carrat\\\",\\\"metric-ton\\\",2)\\n    4.0000000000000003e-07\\n    >>> weight_conversion(\\\"carrat\\\",\\\"long-ton\\\",3)\\n    5.9052438e-07\\n    >>> weight_conversion(\\\"carrat\\\",\\\"short-ton\\\",4)\\n    8.818497600000002e-07\\n    >>> weight_conversion(\\\"carrat\\\",\\\"pound\\\",1)\\n    0.00044092488404000004\\n    >>> weight_conversion(\\\"carrat\\\",\\\"ounce\\\",2)\\n    0.0141095962892\\n    >>> weight_conversion(\\\"carrat\\\",\\\"carrat\\\",4)\\n    4.0\\n    >>> weight_conversion(\\\"carrat\\\",\\\"atomic-mass-unit\\\",4)\\n    4.8177093216e+23\\n    >>> weight_conversion(\\\"atomic-mass-unit\\\",\\\"kilogram\\\",4)\\n    6.642160796e-27\\n    >>> weight_conversion(\\\"atomic-mass-unit\\\",\\\"gram\\\",2)\\n    3.321080398e-24\\n    >>> weight_conversion(\\\"atomic-mass-unit\\\",\\\"milligram\\\",2)\\n    3.3210803980000002e-21\\n    >>> weight_conversion(\\\"atomic-mass-unit\\\",\\\"metric-ton\\\",3)\\n    4.9816205970000004e-30\\n    >>> weight_conversion(\\\"atomic-mass-unit\\\",\\\"long-ton\\\",3)\\n    4.9029473573977584e-30\\n    >>> weight_conversion(\\\"atomic-mass-unit\\\",\\\"short-ton\\\",1)\\n    1.830433719948128e-30\\n    >>> weight_conversion(\\\"atomic-mass-unit\\\",\\\"pound\\\",3)\\n    1.0982602420317504e-26\\n    >>> weight_conversion(\\\"atomic-mass-unit\\\",\\\"ounce\\\",2)\\n    1.1714775914938915e-25\\n    >>> weight_conversion(\\\"atomic-mass-unit\\\",\\\"carrat\\\",2)\\n    1.660540199e-23\\n    >>> weight_conversion(\\\"atomic-mass-unit\\\",\\\"atomic-mass-unit\\\",2)\\n    1.999999998903455\\n    \\\"\\\"\\\"\\n    if to_type not in KILOGRAM_CHART or from_type not in WEIGHT_TYPE_CHART:\\n        raise ValueError(\\n            f\\\"Invalid 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\\\\n\\\"\\n            f\\\"Supported values are: {', '.join(WEIGHT_TYPE_CHART)}\\\"\\n        )\\n    return value * KILOGRAM_CHART[to_type] * WEIGHT_TYPE_CHART[from_type]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "change brightness": "\"from PIL import Image\\n\\n\\ndef change_brightness(img: Image, level: float) -> Image:\\n    \\\"\\\"\\\"\\n    Change the brightness of a PIL Image to a given level.\\n    \\\"\\\"\\\"\\n\\n    def brightness(c: int) -> float:\\n        \\\"\\\"\\\"\\n        Fundamental Transformation/Operation that'll be performed on\\n        every bit.\\n        \\\"\\\"\\\"\\n        return 128 + level + (c - 128)\\n\\n    if not -255.0 <= level <= 255.0:\\n        raise ValueError(\\\"level must be between -255.0 (black) and 255.0 (white)\\\")\\n    return img.point(brightness)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # Load image\\n    with Image.open(\\\"image_data/lena.jpg\\\") as img:\\n        # Change brightness to 100\\n        brigt_img = change_brightness(img, 100)\\n        brigt_img.save(\\\"image_data/lena_brightness.png\\\", format=\\\"png\\\")\\n\"",
    "change contrast": "\"\\\"\\\"\\\"\\r\\nChanging contrast with PIL\\r\\n\\r\\nThis algorithm is used in\\r\\nhttps://noivce.pythonanywhere.com/ Python web app.\\r\\n\\r\\npython/black: True\\r\\nflake8 : True\\r\\n\\\"\\\"\\\"\\r\\n\\r\\nfrom PIL import Image\\r\\n\\r\\n\\r\\ndef change_contrast(img: Image, level: int) -> Image:\\r\\n    \\\"\\\"\\\"\\r\\n    Function to change contrast\\r\\n    \\\"\\\"\\\"\\r\\n    factor = (259 * (level + 255)) / (255 * (259 - level))\\r\\n\\r\\n    def contrast(c: int) -> int:\\r\\n        \\\"\\\"\\\"\\r\\n        Fundamental Transformation/Operation that'll be performed on\\r\\n        every bit.\\r\\n        \\\"\\\"\\\"\\r\\n        return int(128 + factor * (c - 128))\\r\\n\\r\\n    return img.point(contrast)\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    # Load image\\r\\n    with Image.open(\\\"image_data/lena.jpg\\\") as img:\\r\\n        # Change contrast to 170\\r\\n        cont_img = change_contrast(img, 170)\\r\\n        cont_img.save(\\\"image_data/lena_high_contrast.png\\\", format=\\\"png\\\")\\r\\n\"",
    "convert to negative": "\"\\\"\\\"\\\"\\n    Implemented an algorithm using opencv to convert a colored image into its negative\\n\\\"\\\"\\\"\\nfrom cv2 import destroyAllWindows, imread, imshow, waitKey\\n\\n\\ndef convert_to_negative(img):\\n    # getting number of pixels in the image\\n    pixel_h, pixel_v = img.shape[0], img.shape[1]\\n\\n    # converting each pixel's color to its negative\\n    for i in range(pixel_h):\\n        for j in range(pixel_v):\\n            img[i][j] = [255, 255, 255] - img[i][j]\\n\\n    return img\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # read original image\\n    img = imread(\\\"image_data/lena.jpg\\\", 1)\\n\\n    # convert to its negative\\n    neg = convert_to_negative(img)\\n\\n    # show result image\\n    imshow(\\\"negative of original image\\\", img)\\n    waitKey(0)\\n    destroyAllWindows()\\n\"",
    "index calculation": "\"# Author: João Gustavo A. Amorim\\n# Author email: joaogustavoamorim@gmail.com\\n# Coding date:  jan 2019\\n# python/black: True\\n\\n# Imports\\nimport numpy as np\\n\\n\\n# Class implemented to calculus the index\\nclass IndexCalculation:\\n    \\\"\\\"\\\"\\n    # Class Summary\\n            This algorithm consists in calculating vegetation indices, these\\n        indices can be used for precision agriculture for example (or remote\\n        sensing). There are functions to define the data and to calculate the\\n        implemented indices.\\n\\n    # Vegetation index\\n        https://en.wikipedia.org/wiki/Vegetation_Index\\n        A Vegetation Index (VI) is a spectral transformation of two or more bands\\n        designed to enhance the contribution of vegetation properties and allow\\n        reliable spatial and temporal inter-comparisons of terrestrial\\n        photosynthetic activity and canopy structural variations\\n\\n    # Information about channels (Wavelength range for each)\\n        * nir - near-infrared\\n            https://www.malvernpanalytical.com/br/products/technology/near-infrared-spectroscopy\\n            Wavelength Range 700 nm to 2500 nm\\n        * Red Edge\\n            https://en.wikipedia.org/wiki/Red_edge\\n            Wavelength Range 680 nm to 730 nm\\n        * red\\n            https://en.wikipedia.org/wiki/Color\\n            Wavelength Range 635 nm to 700 nm\\n        * blue\\n            https://en.wikipedia.org/wiki/Color\\n            Wavelength Range 450 nm to 490 nm\\n        * green\\n            https://en.wikipedia.org/wiki/Color\\n            Wavelength Range 520 nm to 560 nm\\n\\n\\n    # Implemented index list\\n            #\\\"abbreviationOfIndexName\\\" -- list of channels used\\n\\n            #\\\"ARVI2\\\"            --  red, nir\\n            #\\\"CCCI\\\"             --  red, redEdge, nir\\n            #\\\"CVI\\\"              --  red, green, nir\\n            #\\\"GLI\\\"              --  red, green, blue\\n            #\\\"NDVI\\\"             --  red, nir\\n            #\\\"BNDVI\\\"            --  blue, nir\\n            #\\\"redEdgeNDVI\\\"      --  red, redEdge\\n            #\\\"GNDVI\\\"            --  green, nir\\n            #\\\"GBNDVI\\\"           --  green, blue, nir\\n            #\\\"GRNDVI\\\"           --  red, green, nir\\n            #\\\"RBNDVI\\\"           --  red, blue, nir\\n            #\\\"PNDVI\\\"            --  red, green, blue, nir\\n            #\\\"ATSAVI\\\"           --  red, nir\\n            #\\\"BWDRVI\\\"           --  blue, nir\\n            #\\\"CIgreen\\\"          --  green, nir\\n            #\\\"CIrededge\\\"        --  redEdge, nir\\n            #\\\"CI\\\"               --  red, blue\\n            #\\\"CTVI\\\"             --  red, nir\\n            #\\\"GDVI\\\"             --  green, nir\\n            #\\\"EVI\\\"              --  red, blue, nir\\n            #\\\"GEMI\\\"             --  red, nir\\n            #\\\"GOSAVI\\\"           --  green, nir\\n            #\\\"GSAVI\\\"            --  green, nir\\n            #\\\"Hue\\\"              --  red, green, blue\\n            #\\\"IVI\\\"              --  red, nir\\n            #\\\"IPVI\\\"             --  red, nir\\n            #\\\"I\\\"                --  red, green, blue\\n            #\\\"RVI\\\"              --  red, nir\\n            #\\\"MRVI\\\"             --  red, nir\\n            #\\\"MSAVI\\\"            --  red, nir\\n            #\\\"NormG\\\"            --  red, green, nir\\n            #\\\"NormNIR\\\"          --  red, green, nir\\n            #\\\"NormR\\\"            --  red, green, nir\\n            #\\\"NGRDI\\\"            --  red, green\\n            #\\\"RI\\\"               --  red, green\\n            #\\\"S\\\"                --  red, green, blue\\n            #\\\"IF\\\"               --  red, green, blue\\n            #\\\"DVI\\\"              --  red, nir\\n            #\\\"TVI\\\"              --  red, nir\\n            #\\\"NDRE\\\"               --  redEdge, nir\\n\\n    #list of all index implemented\\n        #allIndex = [\\\"ARVI2\\\", \\\"CCCI\\\", \\\"CVI\\\", \\\"GLI\\\", \\\"NDVI\\\", \\\"BNDVI\\\", \\\"redEdgeNDVI\\\",\\n                    \\\"GNDVI\\\", \\\"GBNDVI\\\", \\\"GRNDVI\\\", \\\"RBNDVI\\\", \\\"PNDVI\\\", \\\"ATSAVI\\\",\\n                    \\\"BWDRVI\\\", \\\"CIgreen\\\", \\\"CIrededge\\\", \\\"CI\\\", \\\"CTVI\\\", \\\"GDVI\\\", \\\"EVI\\\",\\n                    \\\"GEMI\\\", \\\"GOSAVI\\\", \\\"GSAVI\\\", \\\"Hue\\\", \\\"IVI\\\", \\\"IPVI\\\", \\\"I\\\", \\\"RVI\\\",\\n                    \\\"MRVI\\\", \\\"MSAVI\\\", \\\"NormG\\\", \\\"NormNIR\\\", \\\"NormR\\\", \\\"NGRDI\\\", \\\"RI\\\",\\n                    \\\"S\\\", \\\"IF\\\", \\\"DVI\\\", \\\"TVI\\\", \\\"NDRE\\\"]\\n\\n    #list of index with not blue channel\\n        #notBlueIndex = [\\\"ARVI2\\\", \\\"CCCI\\\", \\\"CVI\\\", \\\"NDVI\\\", \\\"redEdgeNDVI\\\", \\\"GNDVI\\\",\\n                         \\\"GRNDVI\\\", \\\"ATSAVI\\\", \\\"CIgreen\\\", \\\"CIrededge\\\", \\\"CTVI\\\", \\\"GDVI\\\",\\n                         \\\"GEMI\\\", \\\"GOSAVI\\\", \\\"GSAVI\\\", \\\"IVI\\\", \\\"IPVI\\\", \\\"RVI\\\", \\\"MRVI\\\",\\n                         \\\"MSAVI\\\", \\\"NormG\\\", \\\"NormNIR\\\", \\\"NormR\\\", \\\"NGRDI\\\", \\\"RI\\\", \\\"DVI\\\",\\n                         \\\"TVI\\\", \\\"NDRE\\\"]\\n\\n    #list of index just with RGB channels\\n        #RGBIndex = [\\\"GLI\\\", \\\"CI\\\", \\\"Hue\\\", \\\"I\\\", \\\"NGRDI\\\", \\\"RI\\\", \\\"S\\\", \\\"IF\\\"]\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, red=None, green=None, blue=None, redEdge=None, nir=None):\\n        # print(\\\"Numpy version: \\\" + np.__version__)\\n        self.setMatrices(red=red, green=green, blue=blue, redEdge=redEdge, nir=nir)\\n\\n    def setMatrices(self, red=None, green=None, blue=None, redEdge=None, nir=None):\\n        if red is not None:\\n            self.red = red\\n        if green is not None:\\n            self.green = green\\n        if blue is not None:\\n            self.blue = blue\\n        if redEdge is not None:\\n            self.redEdge = redEdge\\n        if nir is not None:\\n            self.nir = nir\\n        return True\\n\\n    def calculation(\\n        self, index=\\\"\\\", red=None, green=None, blue=None, redEdge=None, nir=None\\n    ):\\n        \\\"\\\"\\\"\\n        performs the calculation of the index with the values instantiated in the class\\n        :str index: abbreviation of index name to perform\\n        \\\"\\\"\\\"\\n        self.setMatrices(red=red, green=green, blue=blue, redEdge=redEdge, nir=nir)\\n        funcs = {\\n            \\\"ARVI2\\\": self.ARVI2,\\n            \\\"CCCI\\\": self.CCCI,\\n            \\\"CVI\\\": self.CVI,\\n            \\\"GLI\\\": self.GLI,\\n            \\\"NDVI\\\": self.NDVI,\\n            \\\"BNDVI\\\": self.BNDVI,\\n            \\\"redEdgeNDVI\\\": self.redEdgeNDVI,\\n            \\\"GNDVI\\\": self.GNDVI,\\n            \\\"GBNDVI\\\": self.GBNDVI,\\n            \\\"GRNDVI\\\": self.GRNDVI,\\n            \\\"RBNDVI\\\": self.RBNDVI,\\n            \\\"PNDVI\\\": self.PNDVI,\\n            \\\"ATSAVI\\\": self.ATSAVI,\\n            \\\"BWDRVI\\\": self.BWDRVI,\\n            \\\"CIgreen\\\": self.CIgreen,\\n            \\\"CIrededge\\\": self.CIrededge,\\n            \\\"CI\\\": self.CI,\\n            \\\"CTVI\\\": self.CTVI,\\n            \\\"GDVI\\\": self.GDVI,\\n            \\\"EVI\\\": self.EVI,\\n            \\\"GEMI\\\": self.GEMI,\\n            \\\"GOSAVI\\\": self.GOSAVI,\\n            \\\"GSAVI\\\": self.GSAVI,\\n            \\\"Hue\\\": self.Hue,\\n            \\\"IVI\\\": self.IVI,\\n            \\\"IPVI\\\": self.IPVI,\\n            \\\"I\\\": self.I,\\n            \\\"RVI\\\": self.RVI,\\n            \\\"MRVI\\\": self.MRVI,\\n            \\\"MSAVI\\\": self.MSAVI,\\n            \\\"NormG\\\": self.NormG,\\n            \\\"NormNIR\\\": self.NormNIR,\\n            \\\"NormR\\\": self.NormR,\\n            \\\"NGRDI\\\": self.NGRDI,\\n            \\\"RI\\\": self.RI,\\n            \\\"S\\\": self.S,\\n            \\\"IF\\\": self.IF,\\n            \\\"DVI\\\": self.DVI,\\n            \\\"TVI\\\": self.TVI,\\n            \\\"NDRE\\\": self.NDRE,\\n        }\\n\\n        try:\\n            return funcs[index]()\\n        except KeyError:\\n            print(\\\"Index not in the list!\\\")\\n            return False\\n\\n    def ARVI2(self):\\n        \\\"\\\"\\\"\\n        Atmospherically Resistant Vegetation Index 2\\n        https://www.indexdatabase.de/db/i-single.php?id=396\\n        :return: index\\n            −0.18+1.17*(self.nir−self.red)/(self.nir+self.red)\\n        \\\"\\\"\\\"\\n        return -0.18 + (1.17 * ((self.nir - self.red) / (self.nir + self.red)))\\n\\n    def CCCI(self):\\n        \\\"\\\"\\\"\\n        Canopy Chlorophyll Content Index\\n        https://www.indexdatabase.de/db/i-single.php?id=224\\n        :return: index\\n        \\\"\\\"\\\"\\n        return ((self.nir - self.redEdge) / (self.nir + self.redEdge)) / (\\n            (self.nir - self.red) / (self.nir + self.red)\\n        )\\n\\n    def CVI(self):\\n        \\\"\\\"\\\"\\n        Chlorophyll vegetation index\\n        https://www.indexdatabase.de/db/i-single.php?id=391\\n        :return: index\\n        \\\"\\\"\\\"\\n        return self.nir * (self.red / (self.green ** 2))\\n\\n    def GLI(self):\\n        \\\"\\\"\\\"\\n        self.green leaf index\\n        https://www.indexdatabase.de/db/i-single.php?id=375\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (2 * self.green - self.red - self.blue) / (\\n            2 * self.green + self.red + self.blue\\n        )\\n\\n    def NDVI(self):\\n        \\\"\\\"\\\"\\n        Normalized Difference self.nir/self.red Normalized Difference Vegetation\\n        Index, Calibrated NDVI - CDVI\\n        https://www.indexdatabase.de/db/i-single.php?id=58\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir - self.red) / (self.nir + self.red)\\n\\n    def BNDVI(self):\\n        \\\"\\\"\\\"\\n            Normalized Difference self.nir/self.blue self.blue-normalized difference\\n        vegetation index\\n        https://www.indexdatabase.de/db/i-single.php?id=135\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir - self.blue) / (self.nir + self.blue)\\n\\n    def redEdgeNDVI(self):\\n        \\\"\\\"\\\"\\n        Normalized Difference self.rededge/self.red\\n        https://www.indexdatabase.de/db/i-single.php?id=235\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.redEdge - self.red) / (self.redEdge + self.red)\\n\\n    def GNDVI(self):\\n        \\\"\\\"\\\"\\n        Normalized Difference self.nir/self.green self.green NDVI\\n        https://www.indexdatabase.de/db/i-single.php?id=401\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir - self.green) / (self.nir + self.green)\\n\\n    def GBNDVI(self):\\n        \\\"\\\"\\\"\\n        self.green-self.blue NDVI\\n        https://www.indexdatabase.de/db/i-single.php?id=186\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir - (self.green + self.blue)) / (\\n            self.nir + (self.green + self.blue)\\n        )\\n\\n    def GRNDVI(self):\\n        \\\"\\\"\\\"\\n        self.green-self.red NDVI\\n        https://www.indexdatabase.de/db/i-single.php?id=185\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir - (self.green + self.red)) / (\\n            self.nir + (self.green + self.red)\\n        )\\n\\n    def RBNDVI(self):\\n        \\\"\\\"\\\"\\n        self.red-self.blue NDVI\\n        https://www.indexdatabase.de/db/i-single.php?id=187\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir - (self.blue + self.red)) / (self.nir + (self.blue + self.red))\\n\\n    def PNDVI(self):\\n        \\\"\\\"\\\"\\n        Pan NDVI\\n        https://www.indexdatabase.de/db/i-single.php?id=188\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir - (self.green + self.red + self.blue)) / (\\n            self.nir + (self.green + self.red + self.blue)\\n        )\\n\\n    def ATSAVI(self, X=0.08, a=1.22, b=0.03):\\n        \\\"\\\"\\\"\\n        Adjusted transformed soil-adjusted VI\\n        https://www.indexdatabase.de/db/i-single.php?id=209\\n        :return: index\\n        \\\"\\\"\\\"\\n        return a * (\\n            (self.nir - a * self.red - b)\\n            / (a * self.nir + self.red - a * b + X * (1 + a ** 2))\\n        )\\n\\n    def BWDRVI(self):\\n        \\\"\\\"\\\"\\n        self.blue-wide dynamic range vegetation index\\n        https://www.indexdatabase.de/db/i-single.php?id=136\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (0.1 * self.nir - self.blue) / (0.1 * self.nir + self.blue)\\n\\n    def CIgreen(self):\\n        \\\"\\\"\\\"\\n        Chlorophyll Index self.green\\n        https://www.indexdatabase.de/db/i-single.php?id=128\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir / self.green) - 1\\n\\n    def CIrededge(self):\\n        \\\"\\\"\\\"\\n        Chlorophyll Index self.redEdge\\n        https://www.indexdatabase.de/db/i-single.php?id=131\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir / self.redEdge) - 1\\n\\n    def CI(self):\\n        \\\"\\\"\\\"\\n        Coloration Index\\n        https://www.indexdatabase.de/db/i-single.php?id=11\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.red - self.blue) / self.red\\n\\n    def CTVI(self):\\n        \\\"\\\"\\\"\\n        Corrected Transformed Vegetation Index\\n        https://www.indexdatabase.de/db/i-single.php?id=244\\n        :return: index\\n        \\\"\\\"\\\"\\n        ndvi = self.NDVI()\\n        return ((ndvi + 0.5) / (abs(ndvi + 0.5))) * (abs(ndvi + 0.5) ** (1 / 2))\\n\\n    def GDVI(self):\\n        \\\"\\\"\\\"\\n        Difference self.nir/self.green self.green Difference Vegetation Index\\n        https://www.indexdatabase.de/db/i-single.php?id=27\\n        :return: index\\n        \\\"\\\"\\\"\\n        return self.nir - self.green\\n\\n    def EVI(self):\\n        \\\"\\\"\\\"\\n        Enhanced Vegetation Index\\n        https://www.indexdatabase.de/db/i-single.php?id=16\\n        :return: index\\n        \\\"\\\"\\\"\\n        return 2.5 * (\\n            (self.nir - self.red) / (self.nir + 6 * self.red - 7.5 * self.blue + 1)\\n        )\\n\\n    def GEMI(self):\\n        \\\"\\\"\\\"\\n        Global Environment Monitoring Index\\n        https://www.indexdatabase.de/db/i-single.php?id=25\\n        :return: index\\n        \\\"\\\"\\\"\\n        n = (2 * (self.nir ** 2 - self.red ** 2) + 1.5 * self.nir + 0.5 * self.red) / (\\n            self.nir + self.red + 0.5\\n        )\\n        return n * (1 - 0.25 * n) - (self.red - 0.125) / (1 - self.red)\\n\\n    def GOSAVI(self, Y=0.16):\\n        \\\"\\\"\\\"\\n        self.green Optimized Soil Adjusted Vegetation Index\\n        https://www.indexdatabase.de/db/i-single.php?id=29\\n        mit Y = 0,16\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir - self.green) / (self.nir + self.green + Y)\\n\\n    def GSAVI(self, L=0.5):\\n        \\\"\\\"\\\"\\n        self.green Soil Adjusted Vegetation Index\\n        https://www.indexdatabase.de/db/i-single.php?id=31\\n        mit L = 0,5\\n        :return: index\\n        \\\"\\\"\\\"\\n        return ((self.nir - self.green) / (self.nir + self.green + L)) * (1 + L)\\n\\n    def Hue(self):\\n        \\\"\\\"\\\"\\n        Hue\\n        https://www.indexdatabase.de/db/i-single.php?id=34\\n        :return: index\\n        \\\"\\\"\\\"\\n        return np.arctan(\\n            ((2 * self.red - self.green - self.blue) / 30.5) * (self.green - self.blue)\\n        )\\n\\n    def IVI(self, a=None, b=None):\\n        \\\"\\\"\\\"\\n        Ideal vegetation index\\n        https://www.indexdatabase.de/db/i-single.php?id=276\\n        b=intercept of vegetation line\\n        a=soil line slope\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir - b) / (a * self.red)\\n\\n    def IPVI(self):\\n        \\\"\\\"\\\"\\n        Infraself.red percentage vegetation index\\n        https://www.indexdatabase.de/db/i-single.php?id=35\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.nir / ((self.nir + self.red) / 2)) * (self.NDVI() + 1)\\n\\n    def I(self):  # noqa: E741,E743\\n        \\\"\\\"\\\"\\n        Intensity\\n        https://www.indexdatabase.de/db/i-single.php?id=36\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.red + self.green + self.blue) / 30.5\\n\\n    def RVI(self):\\n        \\\"\\\"\\\"\\n        Ratio-Vegetation-Index\\n        http://www.seos-project.eu/modules/remotesensing/remotesensing-c03-s01-p01.html\\n        :return: index\\n        \\\"\\\"\\\"\\n        return self.nir / self.red\\n\\n    def MRVI(self):\\n        \\\"\\\"\\\"\\n        Modified Normalized Difference Vegetation Index RVI\\n        https://www.indexdatabase.de/db/i-single.php?id=275\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.RVI() - 1) / (self.RVI() + 1)\\n\\n    def MSAVI(self):\\n        \\\"\\\"\\\"\\n        Modified Soil Adjusted Vegetation Index\\n        https://www.indexdatabase.de/db/i-single.php?id=44\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (\\n            (2 * self.nir + 1)\\n            - ((2 * self.nir + 1) ** 2 - 8 * (self.nir - self.red)) ** (1 / 2)\\n        ) / 2\\n\\n    def NormG(self):\\n        \\\"\\\"\\\"\\n        Norm G\\n        https://www.indexdatabase.de/db/i-single.php?id=50\\n        :return: index\\n        \\\"\\\"\\\"\\n        return self.green / (self.nir + self.red + self.green)\\n\\n    def NormNIR(self):\\n        \\\"\\\"\\\"\\n        Norm self.nir\\n        https://www.indexdatabase.de/db/i-single.php?id=51\\n        :return: index\\n        \\\"\\\"\\\"\\n        return self.nir / (self.nir + self.red + self.green)\\n\\n    def NormR(self):\\n        \\\"\\\"\\\"\\n        Norm R\\n        https://www.indexdatabase.de/db/i-single.php?id=52\\n        :return: index\\n        \\\"\\\"\\\"\\n        return self.red / (self.nir + self.red + self.green)\\n\\n    def NGRDI(self):\\n        \\\"\\\"\\\"\\n            Normalized Difference self.green/self.red Normalized self.green self.red\\n        difference index, Visible Atmospherically Resistant Indices self.green\\n        (VIself.green)\\n        https://www.indexdatabase.de/db/i-single.php?id=390\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.green - self.red) / (self.green + self.red)\\n\\n    def RI(self):\\n        \\\"\\\"\\\"\\n        Normalized Difference self.red/self.green self.redness Index\\n        https://www.indexdatabase.de/db/i-single.php?id=74\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.red - self.green) / (self.red + self.green)\\n\\n    def S(self):\\n        \\\"\\\"\\\"\\n        Saturation\\n        https://www.indexdatabase.de/db/i-single.php?id=77\\n        :return: index\\n        \\\"\\\"\\\"\\n        max = np.max([np.max(self.red), np.max(self.green), np.max(self.blue)])\\n        min = np.min([np.min(self.red), np.min(self.green), np.min(self.blue)])\\n        return (max - min) / max\\n\\n    def IF(self):\\n        \\\"\\\"\\\"\\n        Shape Index\\n        https://www.indexdatabase.de/db/i-single.php?id=79\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (2 * self.red - self.green - self.blue) / (self.green - self.blue)\\n\\n    def DVI(self):\\n        \\\"\\\"\\\"\\n        Simple Ratio self.nir/self.red Difference Vegetation Index, Vegetation Index\\n        Number (VIN)\\n        https://www.indexdatabase.de/db/i-single.php?id=12\\n        :return: index\\n        \\\"\\\"\\\"\\n        return self.nir / self.red\\n\\n    def TVI(self):\\n        \\\"\\\"\\\"\\n        Transformed Vegetation Index\\n        https://www.indexdatabase.de/db/i-single.php?id=98\\n        :return: index\\n        \\\"\\\"\\\"\\n        return (self.NDVI() + 0.5) ** (1 / 2)\\n\\n    def NDRE(self):\\n        return (self.nir - self.redEdge) / (self.nir + self.redEdge)\\n\\n\\n\\\"\\\"\\\"\\n# genering a random matrices to test this class\\nred     = np.ones((1000,1000, 1),dtype=\\\"float64\\\") * 46787\\ngreen   = np.ones((1000,1000, 1),dtype=\\\"float64\\\") * 23487\\nblue    = np.ones((1000,1000, 1),dtype=\\\"float64\\\") * 14578\\nredEdge = np.ones((1000,1000, 1),dtype=\\\"float64\\\") * 51045\\nnir     = np.ones((1000,1000, 1),dtype=\\\"float64\\\") * 52200\\n\\n# Examples of how to use the class\\n\\n# instantiating the class\\ncl = IndexCalculation()\\n\\n# instantiating the class with the values\\n#cl = indexCalculation(red=red, green=green, blue=blue, redEdge=redEdge, nir=nir)\\n\\n# how set the values after instantiate the class cl, (for update the data or when don't\\n# instantiating the class with the values)\\ncl.setMatrices(red=red, green=green, blue=blue, redEdge=redEdge, nir=nir)\\n\\n# calculating the indices for the instantiated values in the class\\n    # Note: the CCCI index can be changed to any index implemented in the class.\\nindexValue_form1    = cl.calculation(\\\"CCCI\\\", red=red, green=green, blue=blue,\\n                                     redEdge=redEdge, nir=nir).astype(np.float64)\\nindexValue_form2    = cl.CCCI()\\n\\n# calculating the index with the values directly -- you can set just the values\\n# preferred  note: the *calculation* function performs the function *setMatrices*\\nindexValue_form3    = cl.calculation(\\\"CCCI\\\", red=red, green=green, blue=blue,\\n                                     redEdge=redEdge, nir=nir).astype(np.float64)\\n\\nprint(\\\"Form 1: \\\"+np.array2string(indexValue_form1, precision=20, separator=', ',\\n      floatmode='maxprec_equal'))\\nprint(\\\"Form 2: \\\"+np.array2string(indexValue_form2, precision=20, separator=', ',\\n      floatmode='maxprec_equal'))\\nprint(\\\"Form 3: \\\"+np.array2string(indexValue_form3, precision=20, separator=', ',\\n      floatmode='maxprec_equal'))\\n\\n# A list of examples results for different type of data at NDVI\\n# float16 ->    0.31567383              #NDVI (red = 50, nir = 100)\\n# float32 ->    0.31578946              #NDVI (red = 50, nir = 100)\\n# float64 ->    0.3157894736842105      #NDVI (red = 50, nir = 100)\\n# longdouble -> 0.3157894736842105      #NDVI (red = 50, nir = 100)\\n\\\"\\\"\\\"\\n\"",
    "sepia": "\"\\\"\\\"\\\"\\n    Implemented an algorithm using opencv to tone an image with sepia technique\\n\\\"\\\"\\\"\\nfrom cv2 import destroyAllWindows, imread, imshow, waitKey\\n\\n\\ndef make_sepia(img, factor: int):\\n    \\\"\\\"\\\"\\n    Function create sepia tone.\\n    Source: https://en.wikipedia.org/wiki/Sepia_(color)\\n    \\\"\\\"\\\"\\n    pixel_h, pixel_v = img.shape[0], img.shape[1]\\n\\n    def to_grayscale(blue, green, red):\\n        \\\"\\\"\\\"\\n        Helper function to create pixel's greyscale representation\\n        Src: https://pl.wikipedia.org/wiki/YUV\\n        \\\"\\\"\\\"\\n        return 0.2126 * red + 0.587 * green + 0.114 * blue\\n\\n    def normalize(value):\\n        \\\"\\\"\\\"Helper function to normalize R/G/B value -> return 255 if value > 255\\\"\\\"\\\"\\n        return min(value, 255)\\n\\n    for i in range(pixel_h):\\n        for j in range(pixel_v):\\n            greyscale = int(to_grayscale(*img[i][j]))\\n            img[i][j] = [\\n                normalize(greyscale),\\n                normalize(greyscale + factor),\\n                normalize(greyscale + 2 * factor),\\n            ]\\n\\n    return img\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # read original image\\n    images = {\\n        percentage: imread(\\\"image_data/lena.jpg\\\", 1) for percentage in (10, 20, 30, 40)\\n    }\\n\\n    for percentage, img in images.items():\\n        make_sepia(img, percentage)\\n\\n    for percentage, img in images.items():\\n        imshow(f\\\"Original image with sepia (factor: {percentage})\\\", img)\\n\\n    waitKey(0)\\n    destroyAllWindows()\\n\"",
    "test digital image processing": "\"\\\"\\\"\\\"\\nPyTest's for Digital Image Processing\\n\\\"\\\"\\\"\\nfrom cv2 import COLOR_BGR2GRAY, cvtColor, imread\\nfrom numpy import array, uint8\\nfrom PIL import Image\\n\\nfrom digital_image_processing import change_contrast as cc\\nfrom digital_image_processing import convert_to_negative as cn\\nfrom digital_image_processing import sepia as sp\\nfrom digital_image_processing.dithering import burkes as bs\\nfrom digital_image_processing.edge_detection import canny as canny\\nfrom digital_image_processing.filters import convolve as conv\\nfrom digital_image_processing.filters import gaussian_filter as gg\\nfrom digital_image_processing.filters import median_filter as med\\nfrom digital_image_processing.filters import sobel_filter as sob\\nfrom digital_image_processing.resize import resize as rs\\n\\nimg = imread(r\\\"digital_image_processing/image_data/lena_small.jpg\\\")\\ngray = cvtColor(img, COLOR_BGR2GRAY)\\n\\n\\n# Test: convert_to_negative()\\ndef test_convert_to_negative():\\n    negative_img = cn.convert_to_negative(img)\\n    # assert negative_img array for at least one True\\n    assert negative_img.any()\\n\\n\\n# Test: change_contrast()\\ndef test_change_contrast():\\n    with Image.open(\\\"digital_image_processing/image_data/lena_small.jpg\\\") as img:\\n        # Work around assertion for response\\n        assert str(cc.change_contrast(img, 110)).startswith(\\n            \\\"<PIL.Image.Image image mode=RGB size=100x100 at\\\"\\n        )\\n\\n\\n# canny.gen_gaussian_kernel()\\ndef test_gen_gaussian_kernel():\\n    resp = canny.gen_gaussian_kernel(9, sigma=1.4)\\n    # Assert ambiguous array\\n    assert resp.all()\\n\\n\\n# canny.py\\ndef test_canny():\\n    canny_img = imread(\\\"digital_image_processing/image_data/lena_small.jpg\\\", 0)\\n    # assert ambiguous array for all == True\\n    assert canny_img.all()\\n    canny_array = canny.canny(canny_img)\\n    # assert canny array for at least one True\\n    assert canny_array.any()\\n\\n\\n# filters/gaussian_filter.py\\ndef test_gen_gaussian_kernel_filter():\\n    assert gg.gaussian_filter(gray, 5, sigma=0.9).all()\\n\\n\\ndef test_convolve_filter():\\n    # laplace diagonals\\n    Laplace = array([[0.25, 0.5, 0.25], [0.5, -3, 0.5], [0.25, 0.5, 0.25]])\\n    res = conv.img_convolve(gray, Laplace).astype(uint8)\\n    assert res.any()\\n\\n\\ndef test_median_filter():\\n    assert med.median_filter(gray, 3).any()\\n\\n\\ndef test_sobel_filter():\\n    grad, theta = sob.sobel_filter(gray)\\n    assert grad.any() and theta.any()\\n\\n\\ndef test_sepia():\\n    sepia = sp.make_sepia(img, 20)\\n    assert sepia.all()\\n\\n\\ndef test_burkes(file_path: str = \\\"digital_image_processing/image_data/lena_small.jpg\\\"):\\n    burkes = bs.Burkes(imread(file_path, 1), 120)\\n    burkes.process()\\n    assert burkes.output_img.any()\\n\\n\\ndef test_nearest_neighbour(\\n    file_path: str = \\\"digital_image_processing/image_data/lena_small.jpg\\\",\\n):\\n    nn = rs.NearestNeighbour(imread(file_path, 1), 400, 200)\\n    nn.process()\\n    assert nn.output.any()\\n\"",
    "closest pair of points": "\"\\\"\\\"\\\"\\nThe algorithm finds distance between closest pair of points\\nin the given n points.\\nApproach used -> Divide and conquer\\nThe points are sorted based on Xco-ords and\\nthen based on Yco-ords separately.\\nAnd by applying divide and conquer approach,\\nminimum distance is obtained recursively.\\n\\n>> Closest points can lie on different sides of partition.\\nThis case handled by forming a strip of points\\nwhose Xco-ords distance is less than closest_pair_dis\\nfrom mid-point's Xco-ords. Points sorted based on Yco-ords\\nare used in this step to reduce sorting time.\\nClosest pair distance is found in the strip of points. (closest_in_strip)\\n\\nmin(closest_pair_dis, closest_in_strip) would be the final answer.\\n\\nTime complexity: O(n * log n)\\n\\\"\\\"\\\"\\n\\n\\ndef euclidean_distance_sqr(point1, point2):\\n    \\\"\\\"\\\"\\n    >>> euclidean_distance_sqr([1,2],[2,4])\\n    5\\n    \\\"\\\"\\\"\\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2\\n\\n\\ndef column_based_sort(array, column=0):\\n    \\\"\\\"\\\"\\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\\n    [(3, 0), (5, 1), (4, 2)]\\n    \\\"\\\"\\\"\\n    return sorted(array, key=lambda x: x[column])\\n\\n\\ndef dis_between_closest_pair(points, points_counts, min_dis=float(\\\"inf\\\")):\\n    \\\"\\\"\\\"\\n    brute force approach to find distance between closest pair points\\n\\n    Parameters :\\n    points, points_count, min_dis (list(tuple(int, int)), int, int)\\n\\n    Returns :\\n    min_dis (float):  distance between closest pair of points\\n\\n    >>> dis_between_closest_pair([[1,2],[2,4],[5,7],[8,9],[11,0]],5)\\n    5\\n\\n    \\\"\\\"\\\"\\n\\n    for i in range(points_counts - 1):\\n        for j in range(i + 1, points_counts):\\n            current_dis = euclidean_distance_sqr(points[i], points[j])\\n            if current_dis < min_dis:\\n                min_dis = current_dis\\n    return min_dis\\n\\n\\ndef dis_between_closest_in_strip(points, points_counts, min_dis=float(\\\"inf\\\")):\\n    \\\"\\\"\\\"\\n    closest pair of points in strip\\n\\n    Parameters :\\n    points, points_count, min_dis (list(tuple(int, int)), int, int)\\n\\n    Returns :\\n    min_dis (float):  distance btw closest pair of points in the strip (< min_dis)\\n\\n    >>> dis_between_closest_in_strip([[1,2],[2,4],[5,7],[8,9],[11,0]],5)\\n    85\\n    \\\"\\\"\\\"\\n\\n    for i in range(min(6, points_counts - 1), points_counts):\\n        for j in range(max(0, i - 6), i):\\n            current_dis = euclidean_distance_sqr(points[i], points[j])\\n            if current_dis < min_dis:\\n                min_dis = current_dis\\n    return min_dis\\n\\n\\ndef closest_pair_of_points_sqr(points_sorted_on_x, points_sorted_on_y, points_counts):\\n    \\\"\\\"\\\"divide and conquer approach\\n\\n    Parameters :\\n    points, points_count (list(tuple(int, int)), int)\\n\\n    Returns :\\n    (float):  distance btw closest pair of points\\n\\n    >>> closest_pair_of_points_sqr([(1, 2), (3, 4)], [(5, 6), (7, 8)], 2)\\n    8\\n    \\\"\\\"\\\"\\n\\n    # base case\\n    if points_counts <= 3:\\n        return dis_between_closest_pair(points_sorted_on_x, points_counts)\\n\\n    # recursion\\n    mid = points_counts // 2\\n    closest_in_left = closest_pair_of_points_sqr(\\n        points_sorted_on_x, points_sorted_on_y[:mid], mid\\n    )\\n    closest_in_right = closest_pair_of_points_sqr(\\n        points_sorted_on_y, points_sorted_on_y[mid:], points_counts - mid\\n    )\\n    closest_pair_dis = min(closest_in_left, closest_in_right)\\n\\n    \\\"\\\"\\\"\\n    cross_strip contains the points, whose Xcoords are at a\\n    distance(< closest_pair_dis) from mid's Xcoord\\n    \\\"\\\"\\\"\\n\\n    cross_strip = []\\n    for point in points_sorted_on_x:\\n        if abs(point[0] - points_sorted_on_x[mid][0]) < closest_pair_dis:\\n            cross_strip.append(point)\\n\\n    closest_in_strip = dis_between_closest_in_strip(\\n        cross_strip, len(cross_strip), closest_pair_dis\\n    )\\n    return min(closest_pair_dis, closest_in_strip)\\n\\n\\ndef closest_pair_of_points(points, points_counts):\\n    \\\"\\\"\\\"\\n    >>> closest_pair_of_points([(2, 3), (12, 30)], len([(2, 3), (12, 30)]))\\n    28.792360097775937\\n    \\\"\\\"\\\"\\n    points_sorted_on_x = column_based_sort(points, column=0)\\n    points_sorted_on_y = column_based_sort(points, column=1)\\n    return (\\n        closest_pair_of_points_sqr(\\n            points_sorted_on_x, points_sorted_on_y, points_counts\\n        )\\n    ) ** 0.5\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)]\\n    print(\\\"Distance:\\\", closest_pair_of_points(points, len(points)))\\n\"",
    "convex hull": "\"\\\"\\\"\\\"\\nThe convex hull problem is problem of finding all the vertices of convex polygon, P of\\na set of points in a plane such that all the points are either on the vertices of P or\\ninside P. TH convex hull problem has several applications in geometrical problems,\\ncomputer graphics and game development.\\n\\nTwo algorithms have been implemented for the convex hull problem here.\\n1. A brute-force algorithm which runs in O(n^3)\\n2. A divide-and-conquer algorithm which runs in O(n log(n))\\n\\nThere are other several other algorithms for the convex hull problem\\nwhich have not been implemented here, yet.\\n\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom typing import Iterable\\n\\n\\nclass Point:\\n    \\\"\\\"\\\"\\n    Defines a 2-d point for use by all convex-hull algorithms.\\n\\n    Parameters\\n    ----------\\n    x: an int or a float, the x-coordinate of the 2-d point\\n    y: an int or a float, the y-coordinate of the 2-d point\\n\\n    Examples\\n    --------\\n    >>> Point(1, 2)\\n    (1.0, 2.0)\\n    >>> Point(\\\"1\\\", \\\"2\\\")\\n    (1.0, 2.0)\\n    >>> Point(1, 2) > Point(0, 1)\\n    True\\n    >>> Point(1, 1) == Point(1, 1)\\n    True\\n    >>> Point(-0.5, 1) == Point(0.5, 1)\\n    False\\n    >>> Point(\\\"pi\\\", \\\"e\\\")\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: could not convert string to float: 'pi'\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, x, y):\\n        self.x, self.y = float(x), float(y)\\n\\n    def __eq__(self, other):\\n        return self.x == other.x and self.y == other.y\\n\\n    def __ne__(self, other):\\n        return not self == other\\n\\n    def __gt__(self, other):\\n        if self.x > other.x:\\n            return True\\n        elif self.x == other.x:\\n            return self.y > other.y\\n        return False\\n\\n    def __lt__(self, other):\\n        return not self > other\\n\\n    def __ge__(self, other):\\n        if self.x > other.x:\\n            return True\\n        elif self.x == other.x:\\n            return self.y >= other.y\\n        return False\\n\\n    def __le__(self, other):\\n        if self.x < other.x:\\n            return True\\n        elif self.x == other.x:\\n            return self.y <= other.y\\n        return False\\n\\n    def __repr__(self):\\n        return f\\\"({self.x}, {self.y})\\\"\\n\\n    def __hash__(self):\\n        return hash(self.x)\\n\\n\\ndef _construct_points(\\n    list_of_tuples: list[Point] | list[list[float]] | Iterable[list[float]],\\n) -> list[Point]:\\n    \\\"\\\"\\\"\\n    constructs a list of points from an array-like object of numbers\\n\\n    Arguments\\n    ---------\\n\\n    list_of_tuples: array-like object of type numbers. Acceptable types so far\\n    are lists, tuples and sets.\\n\\n    Returns\\n    --------\\n    points: a list where each item is of type Point. This contains only objects\\n    which can be converted into a Point.\\n\\n    Examples\\n    -------\\n    >>> _construct_points([[1, 1], [2, -1], [0.3, 4]])\\n    [(1.0, 1.0), (2.0, -1.0), (0.3, 4.0)]\\n    >>> _construct_points([1, 2])\\n    Ignoring deformed point 1. All points must have at least 2 coordinates.\\n    Ignoring deformed point 2. All points must have at least 2 coordinates.\\n    []\\n    >>> _construct_points([])\\n    []\\n    >>> _construct_points(None)\\n    []\\n    \\\"\\\"\\\"\\n\\n    points: list[Point] = []\\n    if list_of_tuples:\\n        for p in list_of_tuples:\\n            if isinstance(p, Point):\\n                points.append(p)\\n            else:\\n                try:\\n                    points.append(Point(p[0], p[1]))\\n                except (IndexError, TypeError):\\n                    print(\\n                        f\\\"Ignoring deformed point {p}. All points\\\"\\n                        \\\" must have at least 2 coordinates.\\\"\\n                    )\\n    return points\\n\\n\\ndef _validate_input(points: list[Point] | list[list[float]]) -> list[Point]:\\n    \\\"\\\"\\\"\\n    validates an input instance before a convex-hull algorithms uses it\\n\\n    Parameters\\n    ---------\\n    points: array-like, the 2d points to validate before using with\\n    a convex-hull algorithm. The elements of points must be either lists, tuples or\\n    Points.\\n\\n    Returns\\n    -------\\n    points: array_like, an iterable of all well-defined Points constructed passed in.\\n\\n\\n    Exception\\n    ---------\\n    ValueError: if points is empty or None, or if a wrong data structure like a scalar\\n                 is passed\\n\\n    TypeError: if an iterable but non-indexable object (eg. dictionary) is passed.\\n                The exception to this a set which we'll convert to a list before using\\n\\n\\n    Examples\\n    -------\\n    >>> _validate_input([[1, 2]])\\n    [(1.0, 2.0)]\\n    >>> _validate_input([(1, 2)])\\n    [(1.0, 2.0)]\\n    >>> _validate_input([Point(2, 1), Point(-1, 2)])\\n    [(2.0, 1.0), (-1.0, 2.0)]\\n    >>> _validate_input([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Expecting a list of points but got []\\n    >>> _validate_input(1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Expecting an iterable object but got an non-iterable type 1\\n    \\\"\\\"\\\"\\n\\n    if not hasattr(points, \\\"__iter__\\\"):\\n        raise ValueError(\\n            f\\\"Expecting an iterable object but got an non-iterable type {points}\\\"\\n        )\\n\\n    if not points:\\n        raise ValueError(f\\\"Expecting a list of points but got {points}\\\")\\n\\n    return _construct_points(points)\\n\\n\\ndef _det(a: Point, b: Point, c: Point) -> float:\\n    \\\"\\\"\\\"\\n    Computes the sign perpendicular distance of a 2d point c from a line segment\\n    ab. The sign indicates the direction of c relative to ab.\\n    A Positive value means c is above ab (to the left), while a negative value\\n    means c is below ab (to the right). 0 means all three points are on a straight line.\\n\\n    As a side note, 0.5 * abs|det| is the area of triangle abc\\n\\n    Parameters\\n    ----------\\n    a: point, the point on the left end of line segment ab\\n    b: point, the point on the right end of line segment ab\\n    c: point, the point for which the direction and location is desired.\\n\\n    Returns\\n    --------\\n    det: float, abs(det) is the distance of c from ab. The sign\\n    indicates which side of line segment ab c is. det is computed as\\n    (a_xb_y + c_xa_y + b_xc_y) - (a_yb_x + c_ya_x + b_yc_x)\\n\\n    Examples\\n    ----------\\n    >>> _det(Point(1, 1), Point(1, 2), Point(1, 5))\\n    0.0\\n    >>> _det(Point(0, 0), Point(10, 0), Point(0, 10))\\n    100.0\\n    >>> _det(Point(0, 0), Point(10, 0), Point(0, -10))\\n    -100.0\\n    \\\"\\\"\\\"\\n\\n    det = (a.x * b.y + b.x * c.y + c.x * a.y) - (a.y * b.x + b.y * c.x + c.y * a.x)\\n    return det\\n\\n\\ndef convex_hull_bf(points: list[Point]) -> list[Point]:\\n    \\\"\\\"\\\"\\n    Constructs the convex hull of a set of 2D points using a brute force algorithm.\\n    The algorithm basically considers all combinations of points (i, j) and uses the\\n    definition of convexity to determine whether (i, j) is part of the convex hull or\\n    not.  (i, j) is part of the convex hull if and only iff there are no points on both\\n    sides of the line segment connecting the ij, and there is no point k such that k is\\n    on either end of the ij.\\n\\n    Runtime: O(n^3) - definitely horrible\\n\\n    Parameters\\n    ---------\\n    points: array-like of object of Points, lists or tuples.\\n    The set of  2d points for which the convex-hull is needed\\n\\n    Returns\\n    ------\\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\\n\\n    See Also\\n    --------\\n    convex_hull_recursive,\\n\\n     Examples\\n     ---------\\n     >>> convex_hull_bf([[0, 0], [1, 0], [10, 1]])\\n     [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\\n     >>> convex_hull_bf([[0, 0], [1, 0], [10, 0]])\\n     [(0.0, 0.0), (10.0, 0.0)]\\n     >>> convex_hull_bf([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\\n     ...                 [-0.75, 1]])\\n     [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\\n     >>> convex_hull_bf([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\\n     ...                 (2, -1), (2, -4), (1, -3)])\\n     [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\\n    \\\"\\\"\\\"\\n\\n    points = sorted(_validate_input(points))\\n    n = len(points)\\n    convex_set = set()\\n\\n    for i in range(n - 1):\\n        for j in range(i + 1, n):\\n            points_left_of_ij = points_right_of_ij = False\\n            ij_part_of_convex_hull = True\\n            for k in range(n):\\n                if k != i and k != j:\\n                    det_k = _det(points[i], points[j], points[k])\\n\\n                    if det_k > 0:\\n                        points_left_of_ij = True\\n                    elif det_k < 0:\\n                        points_right_of_ij = True\\n                    else:\\n                        # point[i], point[j], point[k] all lie on a straight line\\n                        # if point[k] is to the left of point[i] or it's to the\\n                        # right of point[j], then point[i], point[j] cannot be\\n                        # part of the convex hull of A\\n                        if points[k] < points[i] or points[k] > points[j]:\\n                            ij_part_of_convex_hull = False\\n                            break\\n\\n                if points_left_of_ij and points_right_of_ij:\\n                    ij_part_of_convex_hull = False\\n                    break\\n\\n            if ij_part_of_convex_hull:\\n                convex_set.update([points[i], points[j]])\\n\\n    return sorted(convex_set)\\n\\n\\ndef convex_hull_recursive(points: list[Point]) -> list[Point]:\\n    \\\"\\\"\\\"\\n    Constructs the convex hull of a set of 2D points using a divide-and-conquer strategy\\n    The algorithm exploits the geometric properties of the problem by repeatedly\\n    partitioning the set of points into smaller hulls, and finding the convex hull of\\n    these smaller hulls.  The union of the convex hull from smaller hulls is the\\n    solution to the convex hull of the larger problem.\\n\\n    Parameter\\n    ---------\\n    points: array-like of object of Points, lists or tuples.\\n    The set of  2d points for which the convex-hull is needed\\n\\n    Runtime: O(n log n)\\n\\n    Returns\\n    -------\\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\\n\\n    Examples\\n    ---------\\n    >>> convex_hull_recursive([[0, 0], [1, 0], [10, 1]])\\n    [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\\n    >>> convex_hull_recursive([[0, 0], [1, 0], [10, 0]])\\n    [(0.0, 0.0), (10.0, 0.0)]\\n    >>> convex_hull_recursive([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\\n    ...                        [-0.75, 1]])\\n    [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\\n    >>> convex_hull_recursive([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\\n    ...                        (2, -1), (2, -4), (1, -3)])\\n    [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\\n\\n    \\\"\\\"\\\"\\n    points = sorted(_validate_input(points))\\n    n = len(points)\\n\\n    # divide all the points into an upper hull and a lower hull\\n    # the left most point and the right most point are definitely\\n    # members of the convex hull by definition.\\n    # use these two anchors to divide all the points into two hulls,\\n    # an upper hull and a lower hull.\\n\\n    # all points to the left (above) the line joining the extreme points belong to the\\n    # upper hull\\n    # all points to the right (below) the line joining the extreme points below to the\\n    # lower hull\\n    # ignore all points on the line joining the extreme points since they cannot be\\n    # part of the convex hull\\n\\n    left_most_point = points[0]\\n    right_most_point = points[n - 1]\\n\\n    convex_set = {left_most_point, right_most_point}\\n    upper_hull = []\\n    lower_hull = []\\n\\n    for i in range(1, n - 1):\\n        det = _det(left_most_point, right_most_point, points[i])\\n\\n        if det > 0:\\n            upper_hull.append(points[i])\\n        elif det < 0:\\n            lower_hull.append(points[i])\\n\\n    _construct_hull(upper_hull, left_most_point, right_most_point, convex_set)\\n    _construct_hull(lower_hull, right_most_point, left_most_point, convex_set)\\n\\n    return sorted(convex_set)\\n\\n\\ndef _construct_hull(\\n    points: list[Point], left: Point, right: Point, convex_set: set[Point]\\n) -> None:\\n    \\\"\\\"\\\"\\n\\n    Parameters\\n    ---------\\n    points: list or None, the hull of points from which to choose the next convex-hull\\n        point\\n    left: Point, the point to the left  of line segment joining left and right\\n    right: The point to the right of the line segment joining left and right\\n    convex_set: set, the current convex-hull. The state of convex-set gets updated by\\n        this function\\n\\n    Note\\n    ----\\n    For the line segment 'ab', 'a' is on the left and 'b' on the right.\\n    but the reverse is true for the line segment 'ba'.\\n\\n    Returns\\n    -------\\n    Nothing, only updates the state of convex-set\\n    \\\"\\\"\\\"\\n    if points:\\n        extreme_point = None\\n        extreme_point_distance = float(\\\"-inf\\\")\\n        candidate_points = []\\n\\n        for p in points:\\n            det = _det(left, right, p)\\n\\n            if det > 0:\\n                candidate_points.append(p)\\n\\n                if det > extreme_point_distance:\\n                    extreme_point_distance = det\\n                    extreme_point = p\\n\\n        if extreme_point:\\n            _construct_hull(candidate_points, left, extreme_point, convex_set)\\n            convex_set.add(extreme_point)\\n            _construct_hull(candidate_points, extreme_point, right, convex_set)\\n\\n\\ndef convex_hull_melkman(points: list[Point]) -> list[Point]:\\n    \\\"\\\"\\\"\\n    Constructs the convex hull of a set of 2D points using the melkman algorithm.\\n    The algorithm works by iteratively inserting points of a simple polygonal chain\\n    (meaning that no line segments between two consecutive points cross each other).\\n    Sorting the points yields such a polygonal chain.\\n\\n    For a detailed description, see http://cgm.cs.mcgill.ca/~athens/cs601/Melkman.html\\n\\n    Runtime: O(n log n) - O(n) if points are already sorted in the input\\n\\n    Parameters\\n    ---------\\n    points: array-like of object of Points, lists or tuples.\\n    The set of 2d points for which the convex-hull is needed\\n\\n    Returns\\n    ------\\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\\n\\n    See Also\\n    --------\\n\\n    Examples\\n    ---------\\n    >>> convex_hull_melkman([[0, 0], [1, 0], [10, 1]])\\n    [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\\n    >>> convex_hull_melkman([[0, 0], [1, 0], [10, 0]])\\n    [(0.0, 0.0), (10.0, 0.0)]\\n    >>> convex_hull_melkman([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\\n    ...                 [-0.75, 1]])\\n    [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\\n    >>> convex_hull_melkman([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\\n    ...                 (2, -1), (2, -4), (1, -3)])\\n    [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\\n    \\\"\\\"\\\"\\n    points = sorted(_validate_input(points))\\n    n = len(points)\\n\\n    convex_hull = points[:2]\\n    for i in range(2, n):\\n        det = _det(convex_hull[1], convex_hull[0], points[i])\\n        if det > 0:\\n            convex_hull.insert(0, points[i])\\n            break\\n        elif det < 0:\\n            convex_hull.append(points[i])\\n            break\\n        else:\\n            convex_hull[1] = points[i]\\n    i += 1\\n\\n    for i in range(i, n):\\n        if (\\n            _det(convex_hull[0], convex_hull[-1], points[i]) > 0\\n            and _det(convex_hull[-1], convex_hull[0], points[1]) < 0\\n        ):\\n            # The point lies within the convex hull\\n            continue\\n\\n        convex_hull.insert(0, points[i])\\n        convex_hull.append(points[i])\\n        while _det(convex_hull[0], convex_hull[1], convex_hull[2]) >= 0:\\n            del convex_hull[1]\\n        while _det(convex_hull[-1], convex_hull[-2], convex_hull[-3]) <= 0:\\n            del convex_hull[-2]\\n\\n    # `convex_hull` is contains the convex hull in circular order\\n    return sorted(convex_hull[1:] if len(convex_hull) > 3 else convex_hull)\\n\\n\\ndef main():\\n    points = [\\n        (0, 3),\\n        (2, 2),\\n        (1, 1),\\n        (2, 1),\\n        (3, 0),\\n        (0, 0),\\n        (3, 3),\\n        (2, -1),\\n        (2, -4),\\n        (1, -3),\\n    ]\\n    # the convex set of points is\\n    # [(0, 0), (0, 3), (1, -3), (2, -4), (3, 0), (3, 3)]\\n    results_bf = convex_hull_bf(points)\\n\\n    results_recursive = convex_hull_recursive(points)\\n    assert results_bf == results_recursive\\n\\n    results_melkman = convex_hull_melkman(points)\\n    assert results_bf == results_melkman\\n\\n    print(results_bf)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "heaps algorithm": "\"\\\"\\\"\\\"\\nHeap's algorithm returns the list of all permutations possible from a list.\\nIt minimizes movement by generating each permutation from the previous one\\nby swapping only two elements.\\nMore information:\\nhttps://en.wikipedia.org/wiki/Heap%27s_algorithm.\\n\\\"\\\"\\\"\\n\\n\\ndef heaps(arr: list) -> list:\\n    \\\"\\\"\\\"\\n    Pure python implementation of the Heap's algorithm (recursive version),\\n    returning all permutations of a list.\\n    >>> heaps([])\\n    [()]\\n    >>> heaps([0])\\n    [(0,)]\\n    >>> heaps([-1, 1])\\n    [(-1, 1), (1, -1)]\\n    >>> heaps([1, 2, 3])\\n    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]\\n    >>> from itertools import permutations\\n    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))\\n    True\\n    >>> all(sorted(heaps(x)) == sorted(permutations(x))\\n    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))\\n    True\\n    \\\"\\\"\\\"\\n\\n    if len(arr) <= 1:\\n        return [tuple(arr)]\\n\\n    res = []\\n\\n    def generate(k: int, arr: list):\\n        if k == 1:\\n            res.append(tuple(arr[:]))\\n            return\\n\\n        generate(k - 1, arr)\\n\\n        for i in range(k - 1):\\n            if k % 2 == 0:  # k is even\\n                arr[i], arr[k - 1] = arr[k - 1], arr[i]\\n            else:  # k is odd\\n                arr[0], arr[k - 1] = arr[k - 1], arr[0]\\n            generate(k - 1, arr)\\n\\n    generate(len(arr), arr)\\n    return res\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    arr = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(heaps(arr))\\n\"",
    "heaps algorithm iterative": "\"\\\"\\\"\\\"\\nHeap's (iterative) algorithm returns the list of all permutations possible from a list.\\nIt minimizes movement by generating each permutation from the previous one\\nby swapping only two elements.\\nMore information:\\nhttps://en.wikipedia.org/wiki/Heap%27s_algorithm.\\n\\\"\\\"\\\"\\n\\n\\ndef heaps(arr: list) -> list:\\n    \\\"\\\"\\\"\\n    Pure python implementation of the iterative Heap's algorithm,\\n    returning all permutations of a list.\\n    >>> heaps([])\\n    [()]\\n    >>> heaps([0])\\n    [(0,)]\\n    >>> heaps([-1, 1])\\n    [(-1, 1), (1, -1)]\\n    >>> heaps([1, 2, 3])\\n    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]\\n    >>> from itertools import permutations\\n    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))\\n    True\\n    >>> all(sorted(heaps(x)) == sorted(permutations(x))\\n    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))\\n    True\\n    \\\"\\\"\\\"\\n\\n    if len(arr) <= 1:\\n        return [tuple(arr)]\\n\\n    res = []\\n\\n    def generate(n: int, arr: list):\\n        c = [0] * n\\n        res.append(tuple(arr))\\n\\n        i = 0\\n        while i < n:\\n            if c[i] < i:\\n                if i % 2 == 0:\\n                    arr[0], arr[i] = arr[i], arr[0]\\n                else:\\n                    arr[c[i]], arr[i] = arr[i], arr[c[i]]\\n                res.append(tuple(arr))\\n                c[i] += 1\\n                i = 0\\n            else:\\n                c[i] = 0\\n                i += 1\\n\\n    generate(len(arr), arr)\\n    return res\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    arr = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(heaps(arr))\\n\"",
    "inversions": "\"\\\"\\\"\\\"\\nGiven an array-like data structure A[1..n], how many pairs\\n(i, j) for all 1 <= i < j <= n such that A[i] > A[j]? These pairs are\\ncalled inversions. Counting the number of such inversions in an array-like\\nobject is the important. Among other things, counting inversions can help\\nus determine how close a given array is to being sorted.\\nIn this implementation, I provide two algorithms, a divide-and-conquer\\nalgorithm which runs in nlogn and the brute-force n^2 algorithm.\\n\\\"\\\"\\\"\\n\\n\\ndef count_inversions_bf(arr):\\n    \\\"\\\"\\\"\\n    Counts the number of inversions using a a naive brute-force algorithm\\n    Parameters\\n    ----------\\n    arr: arr: array-like, the list containing the items for which the number\\n    of inversions is desired. The elements of `arr` must be comparable.\\n    Returns\\n    -------\\n    num_inversions: The total number of inversions in `arr`\\n    Examples\\n    ---------\\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\\n     4\\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\\n     0\\n     >>> count_inversions_bf([])\\n     0\\n    \\\"\\\"\\\"\\n\\n    num_inversions = 0\\n    n = len(arr)\\n\\n    for i in range(n - 1):\\n        for j in range(i + 1, n):\\n            if arr[i] > arr[j]:\\n                num_inversions += 1\\n\\n    return num_inversions\\n\\n\\ndef count_inversions_recursive(arr):\\n    \\\"\\\"\\\"\\n    Counts the number of inversions using a divide-and-conquer algorithm\\n    Parameters\\n    -----------\\n    arr: array-like, the list containing the items for which the number\\n    of inversions is desired. The elements of `arr` must be comparable.\\n    Returns\\n    -------\\n    C: a sorted copy of `arr`.\\n    num_inversions: int, the total number of inversions in 'arr'\\n    Examples\\n    --------\\n    >>> count_inversions_recursive([1, 4, 2, 4, 1])\\n    ([1, 1, 2, 4, 4], 4)\\n    >>> count_inversions_recursive([1, 1, 2, 4, 4])\\n    ([1, 1, 2, 4, 4], 0)\\n    >>> count_inversions_recursive([])\\n    ([], 0)\\n    \\\"\\\"\\\"\\n    if len(arr) <= 1:\\n        return arr, 0\\n    mid = len(arr) // 2\\n    P = arr[0:mid]\\n    Q = arr[mid:]\\n\\n    A, inversion_p = count_inversions_recursive(P)\\n    B, inversions_q = count_inversions_recursive(Q)\\n    C, cross_inversions = _count_cross_inversions(A, B)\\n\\n    num_inversions = inversion_p + inversions_q + cross_inversions\\n    return C, num_inversions\\n\\n\\ndef _count_cross_inversions(P, Q):\\n    \\\"\\\"\\\"\\n    Counts the inversions across two sorted arrays.\\n    And combine the two arrays into one sorted array\\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\\n    if P[i] > Q[j], then (i, j) is a cross inversion\\n    Parameters\\n    ----------\\n    P: array-like, sorted in non-decreasing order\\n    Q: array-like, sorted in non-decreasing order\\n    Returns\\n    ------\\n    R: array-like, a sorted array of the elements of `P` and `Q`\\n    num_inversion: int, the number of inversions across `P` and `Q`\\n    Examples\\n    --------\\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\\n    ([0, 1, 2, 2, 3, 5], 4)\\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\\n    ([1, 2, 3, 3, 4, 5], 0)\\n    \\\"\\\"\\\"\\n\\n    R = []\\n    i = j = num_inversion = 0\\n    while i < len(P) and j < len(Q):\\n        if P[i] > Q[j]:\\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\\n            # These are all inversions. The claim emerges from the\\n            # property that P is sorted.\\n            num_inversion += len(P) - i\\n            R.append(Q[j])\\n            j += 1\\n        else:\\n            R.append(P[i])\\n            i += 1\\n\\n    if i < len(P):\\n        R.extend(P[i:])\\n    else:\\n        R.extend(Q[j:])\\n\\n    return R, num_inversion\\n\\n\\ndef main():\\n    arr_1 = [10, 2, 1, 5, 5, 2, 11]\\n\\n    # this arr has 8 inversions:\\n    # (10, 2), (10, 1), (10, 5), (10, 5), (10, 2), (2, 1), (5, 2), (5, 2)\\n\\n    num_inversions_bf = count_inversions_bf(arr_1)\\n    _, num_inversions_recursive = count_inversions_recursive(arr_1)\\n\\n    assert num_inversions_bf == num_inversions_recursive == 8\\n\\n    print(\\\"number of inversions = \\\", num_inversions_bf)\\n\\n    # testing an array with zero inversion (a sorted arr_1)\\n\\n    arr_1.sort()\\n    num_inversions_bf = count_inversions_bf(arr_1)\\n    _, num_inversions_recursive = count_inversions_recursive(arr_1)\\n\\n    assert num_inversions_bf == num_inversions_recursive == 0\\n    print(\\\"number of inversions = \\\", num_inversions_bf)\\n\\n    # an empty list should also have zero inversions\\n    arr_1 = []\\n    num_inversions_bf = count_inversions_bf(arr_1)\\n    _, num_inversions_recursive = count_inversions_recursive(arr_1)\\n\\n    assert num_inversions_bf == num_inversions_recursive == 0\\n    print(\\\"number of inversions = \\\", num_inversions_bf)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "kth order statistic": "\"\\\"\\\"\\\"\\nFind the kth smallest element in linear time using divide and conquer.\\nRecall we can do this trivially in O(nlogn) time. Sort the list and\\naccess kth element in constant time.\\n\\nThis is a divide and conquer algorithm that can find a solution in O(n) time.\\n\\nFor more information of this algorithm:\\nhttps://web.stanford.edu/class/archive/cs/cs161/cs161.1138/lectures/08/Small08.pdf\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom random import choice\\n\\n\\ndef random_pivot(lst):\\n    \\\"\\\"\\\"\\n    Choose a random pivot for the list.\\n    We can use a more sophisticated algorithm here, such as the median-of-medians\\n    algorithm.\\n    \\\"\\\"\\\"\\n    return choice(lst)\\n\\n\\ndef kth_number(lst: list[int], k: int) -> int:\\n    \\\"\\\"\\\"\\n    Return the kth smallest number in lst.\\n    >>> kth_number([2, 1, 3, 4, 5], 3)\\n    3\\n    >>> kth_number([2, 1, 3, 4, 5], 1)\\n    1\\n    >>> kth_number([2, 1, 3, 4, 5], 5)\\n    5\\n    >>> kth_number([3, 2, 5, 6, 7, 8], 2)\\n    3\\n    >>> kth_number([25, 21, 98, 100, 76, 22, 43, 60, 89, 87], 4)\\n    43\\n    \\\"\\\"\\\"\\n    # pick a pivot and separate into list based on pivot.\\n    pivot = random_pivot(lst)\\n\\n    # partition based on pivot\\n    # linear time\\n    small = [e for e in lst if e < pivot]\\n    big = [e for e in lst if e > pivot]\\n\\n    # if we get lucky, pivot might be the element we want.\\n    # we can easily see this:\\n    # small (elements smaller than k)\\n    # + pivot (kth element)\\n    # + big (elements larger than k)\\n    if len(small) == k - 1:\\n        return pivot\\n    # pivot is in elements bigger than k\\n    elif len(small) < k - 1:\\n        return kth_number(big, k - len(small) - 1)\\n    # pivot is in elements smaller than k\\n    else:\\n        return kth_number(small, k)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "max difference pair": "\"def max_difference(a: list[int]) -> tuple[int, int]:\\n    \\\"\\\"\\\"\\n    We are given an array A[1..n] of integers, n >= 1. We want to\\n    find a pair of indices (i, j) such that\\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\\n\\n    Explanation:\\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\\n\\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\\n    (1, 9)\\n    \\\"\\\"\\\"\\n    # base case\\n    if len(a) == 1:\\n        return a[0], a[0]\\n    else:\\n        # split A into half.\\n        first = a[: len(a) // 2]\\n        second = a[len(a) // 2 :]\\n\\n        # 2 sub problems, 1/2 of original size.\\n        small1, big1 = max_difference(first)\\n        small2, big2 = max_difference(second)\\n\\n        # get min of first and max of second\\n        # linear time\\n        min_first = min(first)\\n        max_second = max(second)\\n\\n        # 3 cases, either (small1, big1),\\n        # (min_first, max_second), (small2, big2)\\n        # constant comparisons\\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\\n            return small2, big2\\n        elif big1 - small1 > max_second - min_first:\\n            return small1, big1\\n        else:\\n            return min_first, max_second\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "max subarray sum": "\"\\\"\\\"\\\"\\nGiven a array of length n, max_subarray_sum() finds\\nthe maximum of sum of contiguous sub-array using divide and conquer method.\\n\\nTime complexity : O(n log n)\\n\\nRef : INTRODUCTION TO ALGORITHMS THIRD EDITION\\n(section : 4, sub-section : 4.1, page : 70)\\n\\n\\\"\\\"\\\"\\n\\n\\ndef max_sum_from_start(array):\\n    \\\"\\\"\\\"This function finds the maximum contiguous sum of array from 0 index\\n\\n    Parameters :\\n    array (list[int]) : given array\\n\\n    Returns :\\n    max_sum (int) : maximum contiguous sum of array from 0 index\\n\\n    \\\"\\\"\\\"\\n    array_sum = 0\\n    max_sum = float(\\\"-inf\\\")\\n    for num in array:\\n        array_sum += num\\n        if array_sum > max_sum:\\n            max_sum = array_sum\\n    return max_sum\\n\\n\\ndef max_cross_array_sum(array, left, mid, right):\\n    \\\"\\\"\\\"This function finds the maximum contiguous sum of left and right arrays\\n\\n    Parameters :\\n    array, left, mid, right (list[int], int, int, int)\\n\\n    Returns :\\n    (int) :  maximum of sum of contiguous sum of left and right arrays\\n\\n    \\\"\\\"\\\"\\n\\n    max_sum_of_left = max_sum_from_start(array[left : mid + 1][::-1])\\n    max_sum_of_right = max_sum_from_start(array[mid + 1 : right + 1])\\n    return max_sum_of_left + max_sum_of_right\\n\\n\\ndef max_subarray_sum(array, left, right):\\n    \\\"\\\"\\\"Maximum contiguous sub-array sum, using divide and conquer method\\n\\n    Parameters :\\n    array, left, right (list[int], int, int) :\\n    given array, current left index and current right index\\n\\n    Returns :\\n    int :  maximum of sum of contiguous sub-array\\n\\n    \\\"\\\"\\\"\\n\\n    # base case: array has only one element\\n    if left == right:\\n        return array[right]\\n\\n    # Recursion\\n    mid = (left + right) // 2\\n    left_half_sum = max_subarray_sum(array, left, mid)\\n    right_half_sum = max_subarray_sum(array, mid + 1, right)\\n    cross_sum = max_cross_array_sum(array, left, mid, right)\\n    return max(left_half_sum, right_half_sum, cross_sum)\\n\\n\\narray = [-2, -5, 6, -2, -3, 1, 5, -6]\\narray_length = len(array)\\nprint(\\n    \\\"Maximum sum of contiguous subarray:\\\", max_subarray_sum(array, 0, array_length - 1)\\n)\\n\"",
    "mergesort": "\"from __future__ import annotations\\n\\n\\ndef merge(left_half: list, right_half: list) -> list:\\n    \\\"\\\"\\\"Helper function for mergesort.\\n\\n    >>> left_half = [-2]\\n    >>> right_half = [-1]\\n    >>> merge(left_half, right_half)\\n    [-2, -1]\\n\\n    >>> left_half = [1,2,3]\\n    >>> right_half = [4,5,6]\\n    >>> merge(left_half, right_half)\\n    [1, 2, 3, 4, 5, 6]\\n\\n    >>> left_half = [-2]\\n    >>> right_half = [-1]\\n    >>> merge(left_half, right_half)\\n    [-2, -1]\\n\\n    >>> left_half = [12, 15]\\n    >>> right_half = [13, 14]\\n    >>> merge(left_half, right_half)\\n    [12, 13, 14, 15]\\n\\n    >>> left_half = []\\n    >>> right_half = []\\n    >>> merge(left_half, right_half)\\n    []\\n    \\\"\\\"\\\"\\n    sorted_array = [None] * (len(right_half) + len(left_half))\\n\\n    pointer1 = 0  # pointer to current index for left Half\\n    pointer2 = 0  # pointer to current index for the right Half\\n    index = 0  # pointer to current index for the sorted array Half\\n\\n    while pointer1 < len(left_half) and pointer2 < len(right_half):\\n        if left_half[pointer1] < right_half[pointer2]:\\n            sorted_array[index] = left_half[pointer1]\\n            pointer1 += 1\\n            index += 1\\n        else:\\n            sorted_array[index] = right_half[pointer2]\\n            pointer2 += 1\\n            index += 1\\n    while pointer1 < len(left_half):\\n        sorted_array[index] = left_half[pointer1]\\n        pointer1 += 1\\n        index += 1\\n\\n    while pointer2 < len(right_half):\\n        sorted_array[index] = right_half[pointer2]\\n        pointer2 += 1\\n        index += 1\\n\\n    return sorted_array\\n\\n\\ndef merge_sort(array: list) -> list:\\n    \\\"\\\"\\\"Returns a list of sorted array elements using merge sort.\\n\\n    >>> from random import shuffle\\n    >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]\\n    >>> shuffle(array)\\n    >>> merge_sort(array)\\n    [-200, -10, -2, 3, 11, 99, 100, 100000]\\n\\n    >>> shuffle(array)\\n    >>> merge_sort(array)\\n    [-200, -10, -2, 3, 11, 99, 100, 100000]\\n\\n    >>> array = [-200]\\n    >>> merge_sort(array)\\n    [-200]\\n\\n    >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]\\n    >>> shuffle(array)\\n    >>> sorted(array) == merge_sort(array)\\n    True\\n\\n    >>> array = [-2]\\n    >>> merge_sort(array)\\n    [-2]\\n\\n    >>> array = []\\n    >>> merge_sort(array)\\n    []\\n\\n    >>> array = [10000000, 1, -1111111111, 101111111112, 9000002]\\n    >>> sorted(array) == merge_sort(array)\\n    True\\n    \\\"\\\"\\\"\\n    if len(array) <= 1:\\n        return array\\n    # the actual formula to calculate the middle element = left + (right - left) // 2\\n    # this avoids integer overflow in case of large N\\n    middle = 0 + (len(array) - 0) // 2\\n\\n    # Split the array into halves till the array length becomes equal to One\\n    # merge the arrays of single length returned by mergeSort function and\\n    # pass them into the merge arrays function which merges the array\\n    left_half = array[:middle]\\n    right_half = array[middle:]\\n\\n    return merge(merge_sort(left_half), merge_sort(right_half))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "peak": "\"\\\"\\\"\\\"\\nFinding the peak of a unimodal list using divide and conquer.\\nA unimodal array is defined as follows: array is increasing up to index p,\\nthen decreasing afterwards. (for p >= 1)\\nAn obvious solution can be performed in O(n),\\nto find the maximum of the array.\\n(From Kleinberg and Tardos. Algorithm Design.\\nAddison Wesley 2006: Chapter 5 Solved Exercise 1)\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef peak(lst: list[int]) -> int:\\n    \\\"\\\"\\\"\\n    Return the peak value of `lst`.\\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\\n    5\\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\\n    10\\n    >>> peak([1, 9, 8, 7])\\n    9\\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\\n    7\\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\\n    4\\n    \\\"\\\"\\\"\\n    # middle index\\n    m = len(lst) // 2\\n\\n    # choose the middle 3 elements\\n    three = lst[m - 1 : m + 2]\\n\\n    # if middle element is peak\\n    if three[1] > three[0] and three[1] > three[2]:\\n        return three[1]\\n\\n    # if increasing, recurse on right\\n    elif three[0] < three[2]:\\n        if len(lst[:m]) == 2:\\n            m -= 1\\n        return peak(lst[m:])\\n\\n    # decreasing\\n    else:\\n        if len(lst[:m]) == 2:\\n            m += 1\\n        return peak(lst[:m])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "power": "\"def actual_power(a: int, b: int):\\n    \\\"\\\"\\\"\\n    Function using divide and conquer to calculate a^b.\\n    It only works for integer a,b.\\n    \\\"\\\"\\\"\\n    if b == 0:\\n        return 1\\n    if (b % 2) == 0:\\n        return actual_power(a, int(b / 2)) * actual_power(a, int(b / 2))\\n    else:\\n        return a * actual_power(a, int(b / 2)) * actual_power(a, int(b / 2))\\n\\n\\ndef power(a: int, b: int) -> float:\\n    \\\"\\\"\\\"\\n    >>> power(4,6)\\n    4096\\n    >>> power(2,3)\\n    8\\n    >>> power(-2,3)\\n    -8\\n    >>> power(2,-3)\\n    0.125\\n    >>> power(-2,-3)\\n    -0.125\\n    \\\"\\\"\\\"\\n    if b < 0:\\n        return 1 / actual_power(a, b)\\n    return actual_power(a, b)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(power(-2, -3))\\n\"",
    "strassen matrix multiplication": "\"from __future__ import annotations\\n\\nimport math\\n\\n\\ndef default_matrix_multiplication(a: list, b: list) -> list:\\n    \\\"\\\"\\\"\\n    Multiplication only for 2x2 matrices\\n    \\\"\\\"\\\"\\n    if len(a) != 2 or len(a[0]) != 2 or len(b) != 2 or len(b[0]) != 2:\\n        raise Exception(\\\"Matrices are not 2x2\\\")\\n    new_matrix = [\\n        [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\\n        [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]],\\n    ]\\n    return new_matrix\\n\\n\\ndef matrix_addition(matrix_a: list, matrix_b: list):\\n    return [\\n        [matrix_a[row][col] + matrix_b[row][col] for col in range(len(matrix_a[row]))]\\n        for row in range(len(matrix_a))\\n    ]\\n\\n\\ndef matrix_subtraction(matrix_a: list, matrix_b: list):\\n    return [\\n        [matrix_a[row][col] - matrix_b[row][col] for col in range(len(matrix_a[row]))]\\n        for row in range(len(matrix_a))\\n    ]\\n\\n\\ndef split_matrix(a: list) -> tuple[list, list, list, list]:\\n    \\\"\\\"\\\"\\n    Given an even length matrix, returns the top_left, top_right, bot_left, bot_right\\n    quadrant.\\n\\n    >>> split_matrix([[4,3,2,4],[2,3,1,1],[6,5,4,3],[8,4,1,6]])\\n    ([[4, 3], [2, 3]], [[2, 4], [1, 1]], [[6, 5], [8, 4]], [[4, 3], [1, 6]])\\n    >>> split_matrix([\\n    ...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6],\\n    ...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6]\\n    ... ])  # doctest: +NORMALIZE_WHITESPACE\\n    ([[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4],\\n      [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1],\\n      [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3],\\n      [8, 4, 1, 6]])\\n    \\\"\\\"\\\"\\n    if len(a) % 2 != 0 or len(a[0]) % 2 != 0:\\n        raise Exception(\\\"Odd matrices are not supported!\\\")\\n\\n    matrix_length = len(a)\\n    mid = matrix_length // 2\\n\\n    top_right = [[a[i][j] for j in range(mid, matrix_length)] for i in range(mid)]\\n    bot_right = [\\n        [a[i][j] for j in range(mid, matrix_length)] for i in range(mid, matrix_length)\\n    ]\\n\\n    top_left = [[a[i][j] for j in range(mid)] for i in range(mid)]\\n    bot_left = [[a[i][j] for j in range(mid)] for i in range(mid, matrix_length)]\\n\\n    return top_left, top_right, bot_left, bot_right\\n\\n\\ndef matrix_dimensions(matrix: list) -> tuple[int, int]:\\n    return len(matrix), len(matrix[0])\\n\\n\\ndef print_matrix(matrix: list) -> None:\\n    for i in range(len(matrix)):\\n        print(matrix[i])\\n\\n\\ndef actual_strassen(matrix_a: list, matrix_b: list) -> list:\\n    \\\"\\\"\\\"\\n    Recursive function to calculate the product of two matrices, using the Strassen\\n    Algorithm.  It only supports even length matrices.\\n    \\\"\\\"\\\"\\n    if matrix_dimensions(matrix_a) == (2, 2):\\n        return default_matrix_multiplication(matrix_a, matrix_b)\\n\\n    a, b, c, d = split_matrix(matrix_a)\\n    e, f, g, h = split_matrix(matrix_b)\\n\\n    t1 = actual_strassen(a, matrix_subtraction(f, h))\\n    t2 = actual_strassen(matrix_addition(a, b), h)\\n    t3 = actual_strassen(matrix_addition(c, d), e)\\n    t4 = actual_strassen(d, matrix_subtraction(g, e))\\n    t5 = actual_strassen(matrix_addition(a, d), matrix_addition(e, h))\\n    t6 = actual_strassen(matrix_subtraction(b, d), matrix_addition(g, h))\\n    t7 = actual_strassen(matrix_subtraction(a, c), matrix_addition(e, f))\\n\\n    top_left = matrix_addition(matrix_subtraction(matrix_addition(t5, t4), t2), t6)\\n    top_right = matrix_addition(t1, t2)\\n    bot_left = matrix_addition(t3, t4)\\n    bot_right = matrix_subtraction(matrix_subtraction(matrix_addition(t1, t5), t3), t7)\\n\\n    # construct the new matrix from our 4 quadrants\\n    new_matrix = []\\n    for i in range(len(top_right)):\\n        new_matrix.append(top_left[i] + top_right[i])\\n    for i in range(len(bot_right)):\\n        new_matrix.append(bot_left[i] + bot_right[i])\\n    return new_matrix\\n\\n\\ndef strassen(matrix1: list, matrix2: list) -> list:\\n    \\\"\\\"\\\"\\n    >>> strassen([[2,1,3],[3,4,6],[1,4,2],[7,6,7]], [[4,2,3,4],[2,1,1,1],[8,6,4,2]])\\n    [[34, 23, 19, 15], [68, 46, 37, 28], [28, 18, 15, 12], [96, 62, 55, 48]]\\n    >>> strassen([[3,7,5,6,9],[1,5,3,7,8],[1,4,4,5,7]], [[2,4],[5,2],[1,7],[5,5],[7,8]])\\n    [[139, 163], [121, 134], [100, 121]]\\n    \\\"\\\"\\\"\\n    if matrix_dimensions(matrix1)[1] != matrix_dimensions(matrix2)[0]:\\n        raise Exception(\\n            f\\\"Unable to multiply these matrices, please check the dimensions. \\\\n\\\"\\n            f\\\"Matrix A:{matrix1} \\\\nMatrix B:{matrix2}\\\"\\n        )\\n    dimension1 = matrix_dimensions(matrix1)\\n    dimension2 = matrix_dimensions(matrix2)\\n\\n    if dimension1[0] == dimension1[1] and dimension2[0] == dimension2[1]:\\n        return [matrix1, matrix2]\\n\\n    maximum = max(max(dimension1), max(dimension2))\\n    maxim = int(math.pow(2, math.ceil(math.log2(maximum))))\\n    new_matrix1 = matrix1\\n    new_matrix2 = matrix2\\n\\n    # Adding zeros to the matrices so that the arrays dimensions are the same and also\\n    # power of 2\\n    for i in range(0, maxim):\\n        if i < dimension1[0]:\\n            for j in range(dimension1[1], maxim):\\n                new_matrix1[i].append(0)\\n        else:\\n            new_matrix1.append([0] * maxim)\\n        if i < dimension2[0]:\\n            for j in range(dimension2[1], maxim):\\n                new_matrix2[i].append(0)\\n        else:\\n            new_matrix2.append([0] * maxim)\\n\\n    final_matrix = actual_strassen(new_matrix1, new_matrix2)\\n\\n    # Removing the additional zeros\\n    for i in range(0, maxim):\\n        if i < dimension1[0]:\\n            for j in range(dimension2[1], maxim):\\n                final_matrix[i].pop()\\n        else:\\n            final_matrix.pop()\\n    return final_matrix\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    matrix1 = [\\n        [2, 3, 4, 5],\\n        [6, 4, 3, 1],\\n        [2, 3, 6, 7],\\n        [3, 1, 2, 4],\\n        [2, 3, 4, 5],\\n        [6, 4, 3, 1],\\n        [2, 3, 6, 7],\\n        [3, 1, 2, 4],\\n        [2, 3, 4, 5],\\n        [6, 2, 3, 1],\\n    ]\\n    matrix2 = [[0, 2, 1, 1], [16, 2, 3, 3], [2, 2, 7, 7], [13, 11, 22, 4]]\\n    print(strassen(matrix1, matrix2))\\n\"",
    "abbreviation": "\"\\\"\\\"\\\"\\nhttps://www.hackerrank.com/challenges/abbr/problem\\nYou can perform the following operation on some string, :\\n\\n1. Capitalize zero or more of 's lowercase letters at some index i\\n   (i.e., make them uppercase).\\n2. Delete all of the remaining lowercase letters in .\\n\\nExample:\\na=daBcd and b=\\\"ABC\\\"\\ndaBcd -> capitalize a and c(dABCd) -> remove d (ABC)\\n\\\"\\\"\\\"\\n\\n\\ndef abbr(a: str, b: str) -> bool:\\n    \\\"\\\"\\\"\\n    >>> abbr(\\\"daBcd\\\", \\\"ABC\\\")\\n    True\\n    >>> abbr(\\\"dBcd\\\", \\\"ABC\\\")\\n    False\\n    \\\"\\\"\\\"\\n    n = len(a)\\n    m = len(b)\\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\\n    dp[0][0] = True\\n    for i in range(n):\\n        for j in range(m + 1):\\n            if dp[i][j]:\\n                if j < m and a[i].upper() == b[j]:\\n                    dp[i + 1][j + 1] = True\\n                if a[i].islower():\\n                    dp[i + 1][j] = True\\n    return dp[n][m]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "all construct": "\"\\\"\\\"\\\"\\nProgram to list all the ways a target string can be\\nconstructed from the given list of substrings\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\\n    \\\"\\\"\\\"\\n        returns the list containing all the possible\\n        combinations a string(target) can be constructed from\\n        the given list of substrings(word_bank)\\n    >>> all_construct(\\\"hello\\\", [\\\"he\\\", \\\"l\\\", \\\"o\\\"])\\n    [['he', 'l', 'l', 'o']]\\n    >>> all_construct(\\\"purple\\\",[\\\"purp\\\",\\\"p\\\",\\\"ur\\\",\\\"le\\\",\\\"purpl\\\"])\\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\\n    \\\"\\\"\\\"\\n\\n    word_bank = word_bank or []\\n    # create a table\\n    table_size: int = len(target) + 1\\n\\n    table: list[list[list[str]]] = []\\n    for i in range(table_size):\\n        table.append([])\\n    # seed value\\n    table[0] = [[]]  # because empty string has empty combination\\n\\n    # iterate through the indices\\n    for i in range(table_size):\\n        # condition\\n        if table[i] != []:\\n            for word in word_bank:\\n                # slice condition\\n                if target[i : i + len(word)] == word:\\n                    new_combinations: list[list[str]] = [\\n                        [word] + way for way in table[i]\\n                    ]\\n                    # adds the word to every combination the current position holds\\n                    # now,push that combination to the table[i+len(word)]\\n                    table[i + len(word)] += new_combinations\\n\\n    # combinations are in reverse order so reverse for better output\\n    for combination in table[len(target)]:\\n        combination.reverse()\\n\\n    return table[len(target)]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(all_construct(\\\"jwajalapa\\\", [\\\"jwa\\\", \\\"j\\\", \\\"w\\\", \\\"a\\\", \\\"la\\\", \\\"lapa\\\"]))\\n    print(all_construct(\\\"rajamati\\\", [\\\"s\\\", \\\"raj\\\", \\\"amat\\\", \\\"raja\\\", \\\"ma\\\", \\\"i\\\", \\\"t\\\"]))\\n    print(\\n        all_construct(\\n            \\\"hexagonosaurus\\\",\\n            [\\\"h\\\", \\\"ex\\\", \\\"hex\\\", \\\"ag\\\", \\\"ago\\\", \\\"ru\\\", \\\"auru\\\", \\\"rus\\\", \\\"go\\\", \\\"no\\\", \\\"o\\\", \\\"s\\\"],\\n        )\\n    )\\n\"",
    "bitmask": "\"\\\"\\\"\\\"\\n\\nThis is a Python implementation for questions involving task assignments between people.\\nHere Bitmasking and DP are used for solving this.\\n\\nQuestion :-\\nWe have N tasks and M people. Each person in M can do only certain of these tasks. Also\\na person can do only one task and a task is performed only by one person.\\nFind the total no of ways in which the tasks can be distributed.\\n\\\"\\\"\\\"\\nfrom collections import defaultdict\\n\\n\\nclass AssignmentUsingBitmask:\\n    def __init__(self, task_performed, total):\\n\\n        self.total_tasks = total  # total no of tasks (N)\\n\\n        # DP table will have a dimension of (2^M)*N\\n        # initially all values are set to -1\\n        self.dp = [\\n            [-1 for i in range(total + 1)] for j in range(2 ** len(task_performed))\\n        ]\\n\\n        self.task = defaultdict(list)  # stores the list of persons for each task\\n\\n        # final_mask is used to check if all persons are included by setting all bits\\n        # to 1\\n        self.final_mask = (1 << len(task_performed)) - 1\\n\\n    def CountWaysUtil(self, mask, task_no):\\n\\n        # if mask == self.finalmask all persons are distributed tasks, return 1\\n        if mask == self.final_mask:\\n            return 1\\n\\n        # if not everyone gets the task and no more tasks are available, return 0\\n        if task_no > self.total_tasks:\\n            return 0\\n\\n        # if case already considered\\n        if self.dp[mask][task_no] != -1:\\n            return self.dp[mask][task_no]\\n\\n        # Number of ways when we don't this task in the arrangement\\n        total_ways_util = self.CountWaysUtil(mask, task_no + 1)\\n\\n        # now assign the tasks one by one to all possible persons and recursively\\n        # assign for the remaining tasks.\\n        if task_no in self.task:\\n            for p in self.task[task_no]:\\n\\n                # if p is already given a task\\n                if mask & (1 << p):\\n                    continue\\n\\n                # assign this task to p and change the mask value. And recursively\\n                # assign tasks with the new mask value.\\n                total_ways_util += self.CountWaysUtil(mask | (1 << p), task_no + 1)\\n\\n        # save the value.\\n        self.dp[mask][task_no] = total_ways_util\\n\\n        return self.dp[mask][task_no]\\n\\n    def countNoOfWays(self, task_performed):\\n\\n        # Store the list of persons for each task\\n        for i in range(len(task_performed)):\\n            for j in task_performed[i]:\\n                self.task[j].append(i)\\n\\n        # call the function to fill the DP table, final answer is stored in dp[0][1]\\n        return self.CountWaysUtil(0, 1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    total_tasks = 5  # total no of tasks (the value of N)\\n\\n    # the list of tasks that can be done by M persons.\\n    task_performed = [[1, 3, 4], [1, 2, 5], [3, 4]]\\n    print(\\n        AssignmentUsingBitmask(task_performed, total_tasks).countNoOfWays(\\n            task_performed\\n        )\\n    )\\n    \\\"\\\"\\\"\\n    For the particular example the tasks can be distributed as\\n    (1,2,3), (1,2,4), (1,5,3), (1,5,4), (3,1,4),\\n    (3,2,4), (3,5,4), (4,1,3), (4,2,3), (4,5,3)\\n    total 10\\n    \\\"\\\"\\\"\\n\"",
    "catalan numbers": "\"\\\"\\\"\\\"\\nPrint all the Catalan numbers from 0 to n, n being the user input.\\n\\n * The Catalan numbers are a sequence of positive integers that\\n * appear in many counting problems in combinatorics [1]. Such\\n * problems include counting [2]:\\n * - The number of Dyck words of length 2n\\n * - The number well-formed expressions with n pairs of parentheses\\n *   (e.g., `()()` is valid but `())(` is not)\\n * - The number of different ways n + 1 factors can be completely\\n *   parenthesized (e.g., for n = 2, C(n) = 2 and (ab)c and a(bc)\\n *   are the two valid ways to parenthesize.\\n * - The number of full binary trees with n + 1 leaves\\n\\n * A Catalan number satisfies the following recurrence relation\\n * which we will use in this algorithm [1].\\n * C(0) = C(1) = 1\\n * C(n) = sum(C(i).C(n-i-1)), from i = 0 to n-1\\n\\n * In addition, the n-th Catalan number can be calculated using\\n * the closed form formula below [1]:\\n * C(n) = (1 / (n + 1)) * (2n choose n)\\n\\n * Sources:\\n *  [1] https://brilliant.org/wiki/catalan-numbers/\\n *  [2] https://en.wikipedia.org/wiki/Catalan_number\\n\\\"\\\"\\\"\\n\\n\\ndef catalan_numbers(upper_limit: int) -> \\\"list[int]\\\":\\n    \\\"\\\"\\\"\\n    Return a list of the Catalan number sequence from 0 through `upper_limit`.\\n\\n    >>> catalan_numbers(5)\\n    [1, 1, 2, 5, 14, 42]\\n    >>> catalan_numbers(2)\\n    [1, 1, 2]\\n    >>> catalan_numbers(-1)\\n    Traceback (most recent call last):\\n    ValueError: Limit for the Catalan sequence must be ≥ 0\\n    \\\"\\\"\\\"\\n    if upper_limit < 0:\\n        raise ValueError(\\\"Limit for the Catalan sequence must be ≥ 0\\\")\\n\\n    catalan_list = [0] * (upper_limit + 1)\\n\\n    # Base case: C(0) = C(1) = 1\\n    catalan_list[0] = 1\\n    if upper_limit > 0:\\n        catalan_list[1] = 1\\n\\n    # Recurrence relation: C(i) = sum(C(j).C(i-j-1)), from j = 0 to i\\n    for i in range(2, upper_limit + 1):\\n        for j in range(i):\\n            catalan_list[i] += catalan_list[j] * catalan_list[i - j - 1]\\n\\n    return catalan_list\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"\\\\n********* Catalan Numbers Using Dynamic Programming ************\\\\n\\\")\\n    print(\\\"\\\\n*** Enter -1 at any time to quit ***\\\")\\n    print(\\\"\\\\nEnter the upper limit (≥ 0) for the Catalan number sequence: \\\", end=\\\"\\\")\\n    try:\\n        while True:\\n            N = int(input().strip())\\n            if N < 0:\\n                print(\\\"\\\\n********* Goodbye!! ************\\\")\\n                break\\n            else:\\n                print(f\\\"The Catalan numbers from 0 through {N} are:\\\")\\n                print(catalan_numbers(N))\\n                print(\\\"Try another upper limit for the sequence: \\\", end=\\\"\\\")\\n    except (NameError, ValueError):\\n        print(\\\"\\\\n********* Invalid input, goodbye! ************\\\\n\\\")\\n\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "climbing stairs": "\"#!/usr/bin/env python3\\n\\n\\ndef climb_stairs(n: int) -> int:\\n    \\\"\\\"\\\"\\n    LeetCdoe No.70: Climbing Stairs\\n    Distinct ways to climb a n step staircase where\\n    each time you can either climb 1 or 2 steps.\\n\\n    Args:\\n        n: number of steps of staircase\\n\\n    Returns:\\n        Distinct ways to climb a n step staircase\\n\\n    Raises:\\n        AssertionError: n not positive integer\\n\\n    >>> climb_stairs(3)\\n    3\\n    >>> climb_stairs(1)\\n    1\\n    >>> climb_stairs(-7)  # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n        ...\\n    AssertionError: n needs to be positive integer, your input -7\\n    \\\"\\\"\\\"\\n    assert (\\n        isinstance(n, int) and n > 0\\n    ), f\\\"n needs to be positive integer, your input {n}\\\"\\n    if n == 1:\\n        return 1\\n    dp = [0] * (n + 1)\\n    dp[0], dp[1] = (1, 1)\\n    for i in range(2, n + 1):\\n        dp[i] = dp[i - 1] + dp[i - 2]\\n    return dp[n]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "edit distance": "\"\\\"\\\"\\\"\\nAuthor  : Turfa Auliarachman\\nDate    : October 12, 2016\\n\\nThis is a pure Python implementation of Dynamic Programming solution to the edit\\ndistance problem.\\n\\nThe problem is :\\nGiven two strings A and B. Find the minimum number of operations to string B such that\\nA = B. The permitted operations are removal,  insertion, and substitution.\\n\\\"\\\"\\\"\\n\\n\\nclass EditDistance:\\n    \\\"\\\"\\\"\\n    Use :\\n    solver              = EditDistance()\\n    editDistanceResult  = solver.solve(firstString, secondString)\\n    \\\"\\\"\\\"\\n\\n    def __init__(self):\\n        self.__prepare__()\\n\\n    def __prepare__(self, N=0, M=0):\\n        self.dp = [[-1 for y in range(0, M)] for x in range(0, N)]\\n\\n    def __solveDP(self, x, y):\\n        if x == -1:\\n            return y + 1\\n        elif y == -1:\\n            return x + 1\\n        elif self.dp[x][y] > -1:\\n            return self.dp[x][y]\\n        else:\\n            if self.A[x] == self.B[y]:\\n                self.dp[x][y] = self.__solveDP(x - 1, y - 1)\\n            else:\\n                self.dp[x][y] = 1 + min(\\n                    self.__solveDP(x, y - 1),\\n                    self.__solveDP(x - 1, y),\\n                    self.__solveDP(x - 1, y - 1),\\n                )\\n\\n            return self.dp[x][y]\\n\\n    def solve(self, A, B):\\n        if isinstance(A, bytes):\\n            A = A.decode(\\\"ascii\\\")\\n\\n        if isinstance(B, bytes):\\n            B = B.decode(\\\"ascii\\\")\\n\\n        self.A = str(A)\\n        self.B = str(B)\\n\\n        self.__prepare__(len(A), len(B))\\n\\n        return self.__solveDP(len(A) - 1, len(B) - 1)\\n\\n\\ndef min_distance_bottom_up(word1: str, word2: str) -> int:\\n    \\\"\\\"\\\"\\n    >>> min_distance_bottom_up(\\\"intention\\\", \\\"execution\\\")\\n    5\\n    >>> min_distance_bottom_up(\\\"intention\\\", \\\"\\\")\\n    9\\n    >>> min_distance_bottom_up(\\\"\\\", \\\"\\\")\\n    0\\n    \\\"\\\"\\\"\\n    m = len(word1)\\n    n = len(word2)\\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n    for i in range(m + 1):\\n        for j in range(n + 1):\\n\\n            if i == 0:  # first string is empty\\n                dp[i][j] = j\\n            elif j == 0:  # second string is empty\\n                dp[i][j] = i\\n            elif (\\n                word1[i - 1] == word2[j - 1]\\n            ):  # last character of both substing is equal\\n                dp[i][j] = dp[i - 1][j - 1]\\n            else:\\n                insert = dp[i][j - 1]\\n                delete = dp[i - 1][j]\\n                replace = dp[i - 1][j - 1]\\n                dp[i][j] = 1 + min(insert, delete, replace)\\n    return dp[m][n]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    solver = EditDistance()\\n\\n    print(\\\"****************** Testing Edit Distance DP Algorithm ******************\\\")\\n    print()\\n\\n    S1 = input(\\\"Enter the first string: \\\").strip()\\n    S2 = input(\\\"Enter the second string: \\\").strip()\\n\\n    print()\\n    print(\\\"The minimum Edit Distance is: %d\\\" % (solver.solve(S1, S2)))\\n    print(\\\"The minimum Edit Distance is: %d\\\" % (min_distance_bottom_up(S1, S2)))\\n    print()\\n    print(\\\"*************** End of Testing Edit Distance DP Algorithm ***************\\\")\\n\"",
    "factorial": "\"# Factorial of a number using memoization\\n\\nfrom functools import lru_cache\\n\\n\\n@lru_cache\\ndef factorial(num: int) -> int:\\n    \\\"\\\"\\\"\\n    >>> factorial(7)\\n    5040\\n    >>> factorial(-1)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Number should not be negative.\\n    >>> [factorial(i) for i in range(10)]\\n    [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\\n    \\\"\\\"\\\"\\n    if num < 0:\\n        raise ValueError(\\\"Number should not be negative.\\\")\\n\\n    return 1 if num in (0, 1) else num * factorial(num - 1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "fast fibonacci": "\"#!/usr/bin/env python3\\n\\n\\\"\\\"\\\"\\nThis program calculates the nth Fibonacci number in O(log(n)).\\nIt's possible to calculate F(1_000_000) in less than a second.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport sys\\n\\n\\ndef fibonacci(n: int) -> int:\\n    \\\"\\\"\\\"\\n    return F(n)\\n    >>> [fibonacci(i) for i in range(13)]\\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\\n    \\\"\\\"\\\"\\n    if n < 0:\\n        raise ValueError(\\\"Negative arguments are not supported\\\")\\n    return _fib(n)[0]\\n\\n\\n# returns (F(n), F(n-1))\\ndef _fib(n: int) -> tuple[int, int]:\\n    if n == 0:  # (F(0), F(1))\\n        return (0, 1)\\n\\n    # F(2n) = F(n)[2F(n+1) − F(n)]\\n    # F(2n+1) = F(n+1)^2+F(n)^2\\n    a, b = _fib(n // 2)\\n    c = a * (b * 2 - a)\\n    d = a * a + b * b\\n    return (d, c + d) if n % 2 else (c, d)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    n = int(sys.argv[1])\\n    print(f\\\"fibonacci({n}) is {fibonacci(n)}\\\")\\n\"",
    "fibonacci": "\"# fibonacci.py\\n\\\"\\\"\\\"\\nCalculates the Fibonacci sequence using iteration, recursion, memoization,\\nand a simplified form of Binet's formula\\n\\nNOTE 1: the iterative, recursive, memoization functions are more accurate than\\nthe Binet's formula function because the Binet formula function  uses floats\\n\\nNOTE 2: the Binet's formula function is much more limited in the size of inputs\\nthat it can handle due to the size limitations of Python floats\\n\\nRESULTS: (n = 20)\\nfib_iterative runtime: 0.0055 ms\\nfib_recursive runtime: 6.5627 ms\\nfib_memoization runtime: 0.0107 ms\\nfib_binet runtime: 0.0174 ms\\n\\\"\\\"\\\"\\n\\nfrom math import sqrt\\nfrom time import time\\n\\n\\ndef time_func(func, *args, **kwargs):\\n    \\\"\\\"\\\"\\n    Times the execution of a function with parameters\\n    \\\"\\\"\\\"\\n    start = time()\\n    output = func(*args, **kwargs)\\n    end = time()\\n    if int(end - start) > 0:\\n        print(f\\\"{func.__name__} runtime: {(end - start):0.4f} s\\\")\\n    else:\\n        print(f\\\"{func.__name__} runtime: {(end - start) * 1000:0.4f} ms\\\")\\n    return output\\n\\n\\ndef fib_iterative(n: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    Calculates the first n (0-indexed) Fibonacci numbers using iteration\\n    >>> fib_iterative(0)\\n    [0]\\n    >>> fib_iterative(1)\\n    [0, 1]\\n    >>> fib_iterative(5)\\n    [0, 1, 1, 2, 3, 5]\\n    >>> fib_iterative(10)\\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\\n    >>> fib_iterative(-1)\\n    Traceback (most recent call last):\\n    ...\\n    Exception: n is negative\\n    \\\"\\\"\\\"\\n    if n < 0:\\n        raise Exception(\\\"n is negative\\\")\\n    if n == 0:\\n        return [0]\\n    fib = [0, 1]\\n    for _ in range(n - 1):\\n        fib.append(fib[-1] + fib[-2])\\n    return fib\\n\\n\\ndef fib_recursive(n: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    Calculates the first n (0-indexed) Fibonacci numbers using recursion\\n    >>> fib_iterative(0)\\n    [0]\\n    >>> fib_iterative(1)\\n    [0, 1]\\n    >>> fib_iterative(5)\\n    [0, 1, 1, 2, 3, 5]\\n    >>> fib_iterative(10)\\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\\n    >>> fib_iterative(-1)\\n    Traceback (most recent call last):\\n    ...\\n    Exception: n is negative\\n    \\\"\\\"\\\"\\n\\n    def fib_recursive_term(i: int) -> int:\\n        \\\"\\\"\\\"\\n        Calculates the i-th (0-indexed) Fibonacci number using recursion\\n        \\\"\\\"\\\"\\n        if i < 0:\\n            raise Exception(\\\"n is negative\\\")\\n        if i < 2:\\n            return i\\n        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)\\n\\n    if n < 0:\\n        raise Exception(\\\"n is negative\\\")\\n    return [fib_recursive_term(i) for i in range(n + 1)]\\n\\n\\ndef fib_memoization(n: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\\n    >>> fib_memoization(0)\\n    [0]\\n    >>> fib_memoization(1)\\n    [0, 1]\\n    >>> fib_memoization(5)\\n    [0, 1, 1, 2, 3, 5]\\n    >>> fib_memoization(10)\\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\\n    >>> fib_iterative(-1)\\n    Traceback (most recent call last):\\n    ...\\n    Exception: n is negative\\n    \\\"\\\"\\\"\\n    if n < 0:\\n        raise Exception(\\\"n is negative\\\")\\n    # Cache must be outside recursuive function\\n    # other it will reset every time it calls itself.\\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\\n\\n    def rec_fn_memoized(num: int) -> int:\\n        if num in cache:\\n            return cache[num]\\n\\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\\n        cache[num] = value\\n        return value\\n\\n    return [rec_fn_memoized(i) for i in range(n + 1)]\\n\\n\\ndef fib_binet(n: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    Calculates the first n (0-indexed) Fibonacci numbers using a simplified form\\n    of Binet's formula:\\n    https://en.m.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding\\n\\n    NOTE 1: this function diverges from fib_iterative at around n = 71, likely\\n    due to compounding floating-point arithmetic errors\\n\\n    NOTE 2: this function doesn't accept n >= 1475 because it overflows\\n    thereafter due to the size limitations of Python floats\\n    >>> fib_binet(0)\\n    [0]\\n    >>> fib_binet(1)\\n    [0, 1]\\n    >>> fib_binet(5)\\n    [0, 1, 1, 2, 3, 5]\\n    >>> fib_binet(10)\\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\\n    >>> fib_binet(-1)\\n    Traceback (most recent call last):\\n    ...\\n    Exception: n is negative\\n    >>> fib_binet(1475)\\n    Traceback (most recent call last):\\n    ...\\n    Exception: n is too large\\n    \\\"\\\"\\\"\\n    if n < 0:\\n        raise Exception(\\\"n is negative\\\")\\n    if n >= 1475:\\n        raise Exception(\\\"n is too large\\\")\\n    sqrt_5 = sqrt(5)\\n    phi = (1 + sqrt_5) / 2\\n    return [round(phi ** i / sqrt_5) for i in range(n + 1)]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    num = 20\\n    time_func(fib_iterative, num)\\n    time_func(fib_recursive, num)\\n    time_func(fib_memoization, num)\\n    time_func(fib_binet, num)\\n\"",
    "floyd warshall": "\"import math\\r\\n\\r\\n\\r\\nclass Graph:\\r\\n    def __init__(self, N=0):  # a graph with Node 0,1,...,N-1\\r\\n        self.N = N\\r\\n        self.W = [\\r\\n            [math.inf for j in range(0, N)] for i in range(0, N)\\r\\n        ]  # adjacency matrix for weight\\r\\n        self.dp = [\\r\\n            [math.inf for j in range(0, N)] for i in range(0, N)\\r\\n        ]  # dp[i][j] stores minimum distance from i to j\\r\\n\\r\\n    def addEdge(self, u, v, w):\\r\\n        self.dp[u][v] = w\\r\\n\\r\\n    def floyd_warshall(self):\\r\\n        for k in range(0, self.N):\\r\\n            for i in range(0, self.N):\\r\\n                for j in range(0, self.N):\\r\\n                    self.dp[i][j] = min(self.dp[i][j], self.dp[i][k] + self.dp[k][j])\\r\\n\\r\\n    def showMin(self, u, v):\\r\\n        return self.dp[u][v]\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    graph = Graph(5)\\r\\n    graph.addEdge(0, 2, 9)\\r\\n    graph.addEdge(0, 4, 10)\\r\\n    graph.addEdge(1, 3, 5)\\r\\n    graph.addEdge(2, 3, 7)\\r\\n    graph.addEdge(3, 0, 10)\\r\\n    graph.addEdge(3, 1, 2)\\r\\n    graph.addEdge(3, 2, 1)\\r\\n    graph.addEdge(3, 4, 6)\\r\\n    graph.addEdge(4, 1, 3)\\r\\n    graph.addEdge(4, 2, 4)\\r\\n    graph.addEdge(4, 3, 9)\\r\\n    graph.floyd_warshall()\\r\\n    graph.showMin(1, 4)\\r\\n    graph.showMin(0, 3)\\r\\n\"",
    "fractional knapsack": "\"from bisect import bisect\\nfrom itertools import accumulate\\n\\n\\ndef fracKnapsack(vl, wt, W, n):\\n    \\\"\\\"\\\"\\n    >>> fracKnapsack([60, 100, 120], [10, 20, 30], 50, 3)\\n    240.0\\n    \\\"\\\"\\\"\\n\\n    r = list(sorted(zip(vl, wt), key=lambda x: x[0] / x[1], reverse=True))\\n    vl, wt = [i[0] for i in r], [i[1] for i in r]\\n    acc = list(accumulate(wt))\\n    k = bisect(acc, W)\\n    return (\\n        0\\n        if k == 0\\n        else sum(vl[:k]) + (W - acc[k - 1]) * (vl[k]) / (wt[k])\\n        if k != n\\n        else sum(vl[:k])\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "fractional knapsack 2": "\"# https://en.wikipedia.org/wiki/Continuous_knapsack_problem\\r\\n# https://www.guru99.com/fractional-knapsack-problem-greedy.html\\r\\n# https://medium.com/walkinthecode/greedy-algorithm-fractional-knapsack-problem-9aba1daecc93\\r\\n\\r\\nfrom __future__ import annotations\\r\\n\\r\\n\\r\\ndef fractional_knapsack(\\r\\n    value: list[int], weight: list[int], capacity: int\\r\\n) -> tuple[float, list[float]]:\\r\\n    \\\"\\\"\\\"\\r\\n    >>> value = [1, 3, 5, 7, 9]\\r\\n    >>> weight = [0.9, 0.7, 0.5, 0.3, 0.1]\\r\\n    >>> fractional_knapsack(value, weight, 5)\\r\\n    (25, [1, 1, 1, 1, 1])\\r\\n    >>> fractional_knapsack(value, weight, 15)\\r\\n    (25, [1, 1, 1, 1, 1])\\r\\n    >>> fractional_knapsack(value, weight, 25)\\r\\n    (25, [1, 1, 1, 1, 1])\\r\\n    >>> fractional_knapsack(value, weight, 26)\\r\\n    (25, [1, 1, 1, 1, 1])\\r\\n    >>> fractional_knapsack(value, weight, -1)\\r\\n    (-90.0, [0, 0, 0, 0, -10.0])\\r\\n    >>> fractional_knapsack([1, 3, 5, 7], weight, 30)\\r\\n    (16, [1, 1, 1, 1])\\r\\n    >>> fractional_knapsack(value, [0.9, 0.7, 0.5, 0.3, 0.1], 30)\\r\\n    (25, [1, 1, 1, 1, 1])\\r\\n    >>> fractional_knapsack([], [], 30)\\r\\n    (0, [])\\r\\n    \\\"\\\"\\\"\\r\\n    index = list(range(len(value)))\\r\\n    ratio = [v / w for v, w in zip(value, weight)]\\r\\n    index.sort(key=lambda i: ratio[i], reverse=True)\\r\\n\\r\\n    max_value: float = 0\\r\\n    fractions: list[float] = [0] * len(value)\\r\\n    for i in index:\\r\\n        if weight[i] <= capacity:\\r\\n            fractions[i] = 1\\r\\n            max_value += value[i]\\r\\n            capacity -= weight[i]\\r\\n        else:\\r\\n            fractions[i] = capacity / weight[i]\\r\\n            max_value += value[i] * capacity / weight[i]\\r\\n            break\\r\\n\\r\\n    return max_value, fractions\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "integer partition": "\"\\\"\\\"\\\"\\nThe number of partitions of a number n into at least k parts equals the number of\\npartitions into exactly k parts plus the number of partitions into at least k-1 parts.\\nSubtracting 1 from each part of a partition of n into k parts gives a partition of n-k\\ninto k parts. These two facts together are used for this algorithm.\\n\\\"\\\"\\\"\\n\\n\\ndef partition(m: int) -> int:\\n    memo: list[list[int]] = [[0 for _ in range(m)] for _ in range(m + 1)]\\n    for i in range(m + 1):\\n        memo[i][0] = 1\\n\\n    for n in range(m + 1):\\n        for k in range(1, m):\\n            memo[n][k] += memo[n][k - 1]\\n            if n - k > 0:\\n                memo[n][k] += memo[n - k - 1][k]\\n\\n    return memo[m][m - 1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import sys\\n\\n    if len(sys.argv) == 1:\\n        try:\\n            n = int(input(\\\"Enter a number: \\\").strip())\\n            print(partition(n))\\n        except ValueError:\\n            print(\\\"Please enter a number.\\\")\\n    else:\\n        try:\\n            n = int(sys.argv[1])\\n            print(partition(n))\\n        except ValueError:\\n            print(\\\"Please pass a number.\\\")\\n\"",
    "iterating through submasks": "\"\\\"\\\"\\\"\\nAuthor : Syed Faizan (3rd Year Student IIIT Pune)\\ngithub : faizan2700\\nYou are given a bitmask m and you want to efficiently iterate through all of\\nits submasks. The mask s is submask of m if only bits that were included in\\nbitmask are set\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef list_of_submasks(mask: int) -> list[int]:\\n\\n    \\\"\\\"\\\"\\n    Args:\\n        mask : number which shows mask ( always integer > 0, zero does not have any\\n            submasks )\\n\\n    Returns:\\n        all_submasks : the list of submasks of mask (mask s is called submask of mask\\n        m if only bits that were included in original mask are set\\n\\n    Raises:\\n        AssertionError: mask not positive integer\\n\\n    >>> list_of_submasks(15)\\n    [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\\n    >>> list_of_submasks(13)\\n    [13, 12, 9, 8, 5, 4, 1]\\n    >>> list_of_submasks(-7)  # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n        ...\\n    AssertionError: mask needs to be positive integer, your input -7\\n    >>> list_of_submasks(0)  # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n        ...\\n    AssertionError: mask needs to be positive integer, your input 0\\n\\n    \\\"\\\"\\\"\\n\\n    assert (\\n        isinstance(mask, int) and mask > 0\\n    ), f\\\"mask needs to be positive integer, your input {mask}\\\"\\n\\n    \\\"\\\"\\\"\\n    first submask iterated will be mask itself then operation will be performed\\n    to get other submasks till we reach empty submask that is zero ( zero is not\\n    included in final submasks list )\\n    \\\"\\\"\\\"\\n    all_submasks = []\\n    submask = mask\\n\\n    while submask:\\n        all_submasks.append(submask)\\n        submask = (submask - 1) & mask\\n\\n    return all_submasks\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "knapsack": "\"\\\"\\\"\\\" A naive recursive implementation of 0-1 Knapsack Problem\\n    https://en.wikipedia.org/wiki/Knapsack_problem\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef knapsack(capacity: int, weights: list[int], values: list[int], counter: int) -> int:\\n    \\\"\\\"\\\"\\n    Returns the maximum value that can be put in a knapsack of a capacity cap,\\n    whereby each weight w has a specific value val.\\n\\n    >>> cap = 50\\n    >>> val = [60, 100, 120]\\n    >>> w = [10, 20, 30]\\n    >>> c = len(val)\\n    >>> knapsack(cap, w, val, c)\\n    220\\n\\n    The result is 220 cause the values of 100 and 120 got the weight of 50\\n    which is the limit of the capacity.\\n    \\\"\\\"\\\"\\n\\n    # Base Case\\n    if counter == 0 or capacity == 0:\\n        return 0\\n\\n    # If weight of the nth item is more than Knapsack of capacity,\\n    #   then this item cannot be included in the optimal solution,\\n    # else return the maximum of two cases:\\n    #   (1) nth item included\\n    #   (2) not included\\n    if weights[counter - 1] > capacity:\\n        return knapsack(capacity, weights, values, counter - 1)\\n    else:\\n        left_capacity = capacity - weights[counter - 1]\\n        new_value_included = values[counter - 1] + knapsack(\\n            left_capacity, weights, values, counter - 1\\n        )\\n        without_new_value = knapsack(capacity, weights, values, counter - 1)\\n        return max(new_value_included, without_new_value)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "k means clustering tensorflow": "\"import tensorflow as tf\\nfrom random import shuffle\\nfrom numpy import array\\n\\n\\ndef TFKMeansCluster(vectors, noofclusters):\\n    \\\"\\\"\\\"\\n    K-Means Clustering using TensorFlow.\\n    'vectors' should be a n*k 2-D NumPy array, where n is the number\\n    of vectors of dimensionality k.\\n    'noofclusters' should be an integer.\\n    \\\"\\\"\\\"\\n\\n    noofclusters = int(noofclusters)\\n    assert noofclusters < len(vectors)\\n\\n    # Find out the dimensionality\\n    dim = len(vectors[0])\\n\\n    # Will help select random centroids from among the available vectors\\n    vector_indices = list(range(len(vectors)))\\n    shuffle(vector_indices)\\n\\n    # GRAPH OF COMPUTATION\\n    # We initialize a new graph and set it as the default during each run\\n    # of this algorithm. This ensures that as this function is called\\n    # multiple times, the default graph doesn't keep getting crowded with\\n    # unused ops and Variables from previous function calls.\\n\\n    graph = tf.Graph()\\n\\n    with graph.as_default():\\n\\n        # SESSION OF COMPUTATION\\n\\n        sess = tf.Session()\\n\\n        ##CONSTRUCTING THE ELEMENTS OF COMPUTATION\\n\\n        ##First lets ensure we have a Variable vector for each centroid,\\n        ##initialized to one of the vectors from the available data points\\n        centroids = [\\n            tf.Variable(vectors[vector_indices[i]]) for i in range(noofclusters)\\n        ]\\n        ##These nodes will assign the centroid Variables the appropriate\\n        ##values\\n        centroid_value = tf.placeholder(\\\"float64\\\", [dim])\\n        cent_assigns = []\\n        for centroid in centroids:\\n            cent_assigns.append(tf.assign(centroid, centroid_value))\\n\\n        ##Variables for cluster assignments of individual vectors(initialized\\n        ##to 0 at first)\\n        assignments = [tf.Variable(0) for i in range(len(vectors))]\\n        ##These nodes will assign an assignment Variable the appropriate\\n        ##value\\n        assignment_value = tf.placeholder(\\\"int32\\\")\\n        cluster_assigns = []\\n        for assignment in assignments:\\n            cluster_assigns.append(tf.assign(assignment, assignment_value))\\n\\n        ##Now lets construct the node that will compute the mean\\n        # The placeholder for the input\\n        mean_input = tf.placeholder(\\\"float\\\", [None, dim])\\n        # The Node/op takes the input and computes a mean along the 0th\\n        # dimension, i.e. the list of input vectors\\n        mean_op = tf.reduce_mean(mean_input, 0)\\n\\n        ##Node for computing Euclidean distances\\n        # Placeholders for input\\n        v1 = tf.placeholder(\\\"float\\\", [dim])\\n        v2 = tf.placeholder(\\\"float\\\", [dim])\\n        euclid_dist = tf.sqrt(tf.reduce_sum(tf.pow(tf.sub(v1, v2), 2)))\\n\\n        ##This node will figure out which cluster to assign a vector to,\\n        ##based on Euclidean distances of the vector from the centroids.\\n        # Placeholder for input\\n        centroid_distances = tf.placeholder(\\\"float\\\", [noofclusters])\\n        cluster_assignment = tf.argmin(centroid_distances, 0)\\n\\n        ##INITIALIZING STATE VARIABLES\\n\\n        ##This will help initialization of all Variables defined with respect\\n        ##to the graph. The Variable-initializer should be defined after\\n        ##all the Variables have been constructed, so that each of them\\n        ##will be included in the initialization.\\n        init_op = tf.initialize_all_variables()\\n\\n        # Initialize all variables\\n        sess.run(init_op)\\n\\n        ##CLUSTERING ITERATIONS\\n\\n        # Now perform the Expectation-Maximization steps of K-Means clustering\\n        # iterations. To keep things simple, we will only do a set number of\\n        # iterations, instead of using a Stopping Criterion.\\n        noofiterations = 100\\n        for iteration_n in range(noofiterations):\\n\\n            ##EXPECTATION STEP\\n            ##Based on the centroid locations till last iteration, compute\\n            ##the _expected_ centroid assignments.\\n            # Iterate over each vector\\n            for vector_n in range(len(vectors)):\\n                vect = vectors[vector_n]\\n                # Compute Euclidean distance between this vector and each\\n                # centroid. Remember that this list cannot be named\\n                #'centroid_distances', since that is the input to the\\n                # cluster assignment node.\\n                distances = [\\n                    sess.run(euclid_dist, feed_dict={v1: vect, v2: sess.run(centroid)})\\n                    for centroid in centroids\\n                ]\\n                # Now use the cluster assignment node, with the distances\\n                # as the input\\n                assignment = sess.run(\\n                    cluster_assignment, feed_dict={centroid_distances: distances}\\n                )\\n                # Now assign the value to the appropriate state variable\\n                sess.run(\\n                    cluster_assigns[vector_n], feed_dict={assignment_value: assignment}\\n                )\\n\\n            ##MAXIMIZATION STEP\\n            # Based on the expected state computed from the Expectation Step,\\n            # compute the locations of the centroids so as to maximize the\\n            # overall objective of minimizing within-cluster Sum-of-Squares\\n            for cluster_n in range(noofclusters):\\n                # Collect all the vectors assigned to this cluster\\n                assigned_vects = [\\n                    vectors[i]\\n                    for i in range(len(vectors))\\n                    if sess.run(assignments[i]) == cluster_n\\n                ]\\n                # Compute new centroid location\\n                new_location = sess.run(\\n                    mean_op, feed_dict={mean_input: array(assigned_vects)}\\n                )\\n                # Assign value to appropriate variable\\n                sess.run(\\n                    cent_assigns[cluster_n], feed_dict={centroid_value: new_location}\\n                )\\n\\n        # Return centroids and assignments\\n        centroids = sess.run(centroids)\\n        assignments = sess.run(assignments)\\n        return centroids, assignments\\n\"",
    "longest common subsequence": "\"\\\"\\\"\\\"\\nLCS Problem Statement: Given two sequences, find the length of longest subsequence\\npresent in both of them.  A subsequence is a sequence that appears in the same relative\\norder, but not necessarily continuous.\\nExample:\\\"abc\\\", \\\"abg\\\" are subsequences of \\\"abcdefgh\\\".\\n\\\"\\\"\\\"\\n\\n\\ndef longest_common_subsequence(x: str, y: str):\\n    \\\"\\\"\\\"\\n    Finds the longest common subsequence between two strings. Also returns the\\n    The subsequence found\\n\\n    Parameters\\n    ----------\\n\\n    x: str, one of the strings\\n    y: str, the other string\\n\\n    Returns\\n    -------\\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\\n    Seq: str, the subsequence found\\n\\n    >>> longest_common_subsequence(\\\"programming\\\", \\\"gaming\\\")\\n    (6, 'gaming')\\n    >>> longest_common_subsequence(\\\"physics\\\", \\\"smartphone\\\")\\n    (2, 'ph')\\n    >>> longest_common_subsequence(\\\"computer\\\", \\\"food\\\")\\n    (1, 'o')\\n    \\\"\\\"\\\"\\n    # find the length of strings\\n\\n    assert x is not None\\n    assert y is not None\\n\\n    m = len(x)\\n    n = len(y)\\n\\n    # declaring the array for storing the dp values\\n    L = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            if x[i - 1] == y[j - 1]:\\n                match = 1\\n            else:\\n                match = 0\\n\\n            L[i][j] = max(L[i - 1][j], L[i][j - 1], L[i - 1][j - 1] + match)\\n\\n    seq = \\\"\\\"\\n    i, j = m, n\\n    while i > 0 and j > 0:\\n        if x[i - 1] == y[j - 1]:\\n            match = 1\\n        else:\\n            match = 0\\n\\n        if L[i][j] == L[i - 1][j - 1] + match:\\n            if match == 1:\\n                seq = x[i - 1] + seq\\n            i -= 1\\n            j -= 1\\n        elif L[i][j] == L[i - 1][j]:\\n            i -= 1\\n        else:\\n            j -= 1\\n\\n    return L[m][n], seq\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    a = \\\"AGGTAB\\\"\\n    b = \\\"GXTXAYB\\\"\\n    expected_ln = 4\\n    expected_subseq = \\\"GTAB\\\"\\n\\n    ln, subseq = longest_common_subsequence(a, b)\\n    print(\\\"len =\\\", ln, \\\", sub-sequence =\\\", subseq)\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "longest increasing subsequence": "\"\\\"\\\"\\\"\\nAuthor  : Mehdi ALAOUI\\n\\nThis is a pure Python implementation of Dynamic Programming solution to the longest\\nincreasing subsequence of a given sequence.\\n\\nThe problem is  :\\nGiven an array, to find the longest and increasing sub-array in that given array and\\nreturn it.\\nExample: [10, 22, 9, 33, 21, 50, 41, 60, 80] as input will return\\n         [10, 22, 33, 41, 60, 80] as output\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\\n    \\\"\\\"\\\"\\n    Some examples\\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\\n    [10, 22, 33, 41, 60, 80]\\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\\n    [1, 2, 3, 9]\\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\\n    [8]\\n    >>> longest_subsequence([1, 1, 1])\\n    [1, 1, 1]\\n    >>> longest_subsequence([])\\n    []\\n    \\\"\\\"\\\"\\n    array_length = len(array)\\n    # If the array contains only one element, we return it (it's the stop condition of\\n    # recursion)\\n    if array_length <= 1:\\n        return array\\n        # Else\\n    pivot = array[0]\\n    isFound = False\\n    i = 1\\n    longest_subseq: list[int] = []\\n    while not isFound and i < array_length:\\n        if array[i] < pivot:\\n            isFound = True\\n            temp_array = [element for element in array[i:] if element >= array[i]]\\n            temp_array = longest_subsequence(temp_array)\\n            if len(temp_array) > len(longest_subseq):\\n                longest_subseq = temp_array\\n        else:\\n            i += 1\\n\\n    temp_array = [element for element in array[1:] if element >= pivot]\\n    temp_array = [pivot] + longest_subsequence(temp_array)\\n    if len(temp_array) > len(longest_subseq):\\n        return temp_array\\n    else:\\n        return longest_subseq\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "longest increasing subsequence o(nlogn)": "\"#############################\\n# Author: Aravind Kashyap\\n# File: lis.py\\n# comments: This programme outputs the Longest Strictly Increasing Subsequence in\\n#           O(NLogN) Where N is the Number of elements in the list\\n#############################\\nfrom __future__ import annotations\\n\\n\\ndef CeilIndex(v, l, r, key):  # noqa: E741\\n    while r - l > 1:\\n        m = (l + r) // 2\\n        if v[m] >= key:\\n            r = m\\n        else:\\n            l = m  # noqa: E741\\n    return r\\n\\n\\ndef LongestIncreasingSubsequenceLength(v: list[int]) -> int:\\n    \\\"\\\"\\\"\\n    >>> LongestIncreasingSubsequenceLength([2, 5, 3, 7, 11, 8, 10, 13, 6])\\n    6\\n    >>> LongestIncreasingSubsequenceLength([])\\n    0\\n    >>> LongestIncreasingSubsequenceLength([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3,\\n    ...                                     11, 7, 15])\\n    6\\n    >>> LongestIncreasingSubsequenceLength([5, 4, 3, 2, 1])\\n    1\\n    \\\"\\\"\\\"\\n    if len(v) == 0:\\n        return 0\\n\\n    tail = [0] * len(v)\\n    length = 1\\n\\n    tail[0] = v[0]\\n\\n    for i in range(1, len(v)):\\n        if v[i] < tail[0]:\\n            tail[0] = v[i]\\n        elif v[i] > tail[length - 1]:\\n            tail[length] = v[i]\\n            length += 1\\n        else:\\n            tail[CeilIndex(tail, -1, length - 1, v[i])] = v[i]\\n\\n    return length\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "longest sub array": "\"\\\"\\\"\\\"\\nAuthor  : Yvonne\\n\\nThis is a pure Python implementation of Dynamic Programming solution to the\\n    longest_sub_array problem.\\n\\nThe problem is  :\\nGiven an array, to find the longest and continuous sub array and get the max sum of the\\n    sub array in the given array.\\n\\\"\\\"\\\"\\n\\n\\nclass SubArray:\\n    def __init__(self, arr):\\n        # we need a list not a string, so do something to change the type\\n        self.array = arr.split(\\\",\\\")\\n        print((\\\"the input array is:\\\", self.array))\\n\\n    def solve_sub_array(self):\\n        rear = [int(self.array[0])] * len(self.array)\\n        sum_value = [int(self.array[0])] * len(self.array)\\n        for i in range(1, len(self.array)):\\n            sum_value[i] = max(\\n                int(self.array[i]) + sum_value[i - 1], int(self.array[i])\\n            )\\n            rear[i] = max(sum_value[i], rear[i - 1])\\n        return rear[len(self.array) - 1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    whole_array = input(\\\"please input some numbers:\\\")\\n    array = SubArray(whole_array)\\n    re = array.solve_sub_array()\\n    print((\\\"the results is:\\\", re))\\n\"",
    "matrix chain order": "\"import sys\\n\\n\\\"\\\"\\\"\\nDynamic Programming\\nImplementation of Matrix Chain Multiplication\\nTime Complexity: O(n^3)\\nSpace Complexity: O(n^2)\\n\\\"\\\"\\\"\\n\\n\\ndef MatrixChainOrder(array):\\n    N = len(array)\\n    Matrix = [[0 for x in range(N)] for x in range(N)]\\n    Sol = [[0 for x in range(N)] for x in range(N)]\\n\\n    for ChainLength in range(2, N):\\n        for a in range(1, N - ChainLength + 1):\\n            b = a + ChainLength - 1\\n\\n            Matrix[a][b] = sys.maxsize\\n            for c in range(a, b):\\n                cost = (\\n                    Matrix[a][c] + Matrix[c + 1][b] + array[a - 1] * array[c] * array[b]\\n                )\\n                if cost < Matrix[a][b]:\\n                    Matrix[a][b] = cost\\n                    Sol[a][b] = c\\n    return Matrix, Sol\\n\\n\\n# Print order of matrix with Ai as Matrix\\ndef PrintOptimalSolution(OptimalSolution, i, j):\\n    if i == j:\\n        print(\\\"A\\\" + str(i), end=\\\" \\\")\\n    else:\\n        print(\\\"(\\\", end=\\\" \\\")\\n        PrintOptimalSolution(OptimalSolution, i, OptimalSolution[i][j])\\n        PrintOptimalSolution(OptimalSolution, OptimalSolution[i][j] + 1, j)\\n        print(\\\")\\\", end=\\\" \\\")\\n\\n\\ndef main():\\n    array = [30, 35, 15, 5, 10, 20, 25]\\n    n = len(array)\\n    # Size of matrix created from above array will be\\n    # 30*35 35*15 15*5 5*10 10*20 20*25\\n    Matrix, OptimalSolution = MatrixChainOrder(array)\\n\\n    print(\\\"No. of Operation required: \\\" + str(Matrix[1][n - 1]))\\n    PrintOptimalSolution(OptimalSolution, 1, n - 1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "max non adjacent sum": "\"# Video Explanation: https://www.youtube.com/watch?v=6w60Zi1NtL8&feature=emb_logo\\n\\nfrom __future__ import annotations\\n\\n\\ndef maximum_non_adjacent_sum(nums: list[int]) -> int:\\n    \\\"\\\"\\\"\\n    Find the maximum non-adjacent sum of the integers in the nums input list\\n\\n    >>> print(maximum_non_adjacent_sum([1, 2, 3]))\\n    4\\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\\n    18\\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\\n    0\\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\\n    500\\n    \\\"\\\"\\\"\\n    if not nums:\\n        return 0\\n    max_including = nums[0]\\n    max_excluding = 0\\n    for num in nums[1:]:\\n        max_including, max_excluding = (\\n            max_excluding + num,\\n            max(max_including, max_excluding),\\n        )\\n    return max(max_excluding, max_including)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "max sub array": "\"\\\"\\\"\\\"\\nauthor : Mayank Kumar Jha (mk9440)\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef find_max_sub_array(A, low, high):\\n    if low == high:\\n        return low, high, A[low]\\n    else:\\n        mid = (low + high) // 2\\n        left_low, left_high, left_sum = find_max_sub_array(A, low, mid)\\n        right_low, right_high, right_sum = find_max_sub_array(A, mid + 1, high)\\n        cross_left, cross_right, cross_sum = find_max_cross_sum(A, low, mid, high)\\n        if left_sum >= right_sum and left_sum >= cross_sum:\\n            return left_low, left_high, left_sum\\n        elif right_sum >= left_sum and right_sum >= cross_sum:\\n            return right_low, right_high, right_sum\\n        else:\\n            return cross_left, cross_right, cross_sum\\n\\n\\ndef find_max_cross_sum(A, low, mid, high):\\n    left_sum, max_left = -999999999, -1\\n    right_sum, max_right = -999999999, -1\\n    summ = 0\\n    for i in range(mid, low - 1, -1):\\n        summ += A[i]\\n        if summ > left_sum:\\n            left_sum = summ\\n            max_left = i\\n    summ = 0\\n    for i in range(mid + 1, high + 1):\\n        summ += A[i]\\n        if summ > right_sum:\\n            right_sum = summ\\n            max_right = i\\n    return max_left, max_right, (left_sum + right_sum)\\n\\n\\ndef max_sub_array(nums: list[int]) -> int:\\n    \\\"\\\"\\\"\\n    Finds the contiguous subarray which has the largest sum and return its sum.\\n\\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\\n    6\\n\\n    An empty (sub)array has sum 0.\\n    >>> max_sub_array([])\\n    0\\n\\n    If all elements are negative, the largest subarray would be the empty array,\\n    having the sum 0.\\n    >>> max_sub_array([-1, -2, -3])\\n    0\\n    >>> max_sub_array([5, -2, -3])\\n    5\\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\\n    187\\n    \\\"\\\"\\\"\\n    best = 0\\n    current = 0\\n    for i in nums:\\n        current += i\\n        if current < 0:\\n            current = 0\\n        best = max(best, current)\\n    return best\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    \\\"\\\"\\\"\\n    A random simulation of this algorithm.\\n    \\\"\\\"\\\"\\n    import time\\n    from random import randint\\n\\n    from matplotlib import pyplot as plt\\n\\n    inputs = [10, 100, 1000, 10000, 50000, 100000, 200000, 300000, 400000, 500000]\\n    tim = []\\n    for i in inputs:\\n        li = [randint(1, i) for j in range(i)]\\n        strt = time.time()\\n        (find_max_sub_array(li, 0, len(li) - 1))\\n        end = time.time()\\n        tim.append(end - strt)\\n    print(\\\"No of Inputs       Time Taken\\\")\\n    for i in range(len(inputs)):\\n        print(inputs[i], \\\"\\\\t\\\\t\\\", tim[i])\\n    plt.plot(inputs, tim)\\n    plt.xlabel(\\\"Number of Inputs\\\")\\n    plt.ylabel(\\\"Time taken in seconds \\\")\\n    plt.show()\\n\"",
    "max sum contiguous subsequence": "\"def max_subarray_sum(nums: list) -> int:\\n    \\\"\\\"\\\"\\n    >>> max_subarray_sum([6 , 9, -1, 3, -7, -5, 10])\\n    17\\n    \\\"\\\"\\\"\\n    if not nums:\\n        return 0\\n    n = len(nums)\\n\\n    res, s, s_pre = nums[0], nums[0], nums[0]\\n    for i in range(1, n):\\n        s = max(nums[i], s_pre + nums[i])\\n        s_pre = s\\n        res = max(res, s)\\n    return res\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    nums = [6, 9, -1, 3, -7, -5, 10]\\n    print(max_subarray_sum(nums))\\n\"",
    "minimum coin change": "\"\\\"\\\"\\\"\\nYou have m types of coins available in infinite quantities\\nwhere the value of each coins is given in the array S=[S0,... Sm-1]\\nCan you determine number of ways of making change for n units using\\nthe given types of coins?\\nhttps://www.hackerrank.com/challenges/coin-change/problem\\n\\\"\\\"\\\"\\n\\n\\ndef dp_count(S, n):\\n    \\\"\\\"\\\"\\n    >>> dp_count([1, 2, 3], 4)\\n    4\\n    >>> dp_count([1, 2, 3], 7)\\n    8\\n    >>> dp_count([2, 5, 3, 6], 10)\\n    5\\n    >>> dp_count([10], 99)\\n    0\\n    >>> dp_count([4, 5, 6], 0)\\n    1\\n    >>> dp_count([1, 2, 3], -5)\\n    0\\n    \\\"\\\"\\\"\\n    if n < 0:\\n        return 0\\n    # table[i] represents the number of ways to get to amount i\\n    table = [0] * (n + 1)\\n\\n    # There is exactly 1 way to get to zero(You pick no coins).\\n    table[0] = 1\\n\\n    # Pick all coins one by one and update table[] values\\n    # after the index greater than or equal to the value of the\\n    # picked coin\\n    for coin_val in S:\\n        for j in range(coin_val, n + 1):\\n            table[j] += table[j - coin_val]\\n\\n    return table[n]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "minimum cost path": "\"# Youtube Explanation: https://www.youtube.com/watch?v=lBRtnuxg-gU\\n\\nfrom __future__ import annotations\\n\\n\\ndef minimum_cost_path(matrix: list[list[int]]) -> int:\\n    \\\"\\\"\\\"\\n    Find the minimum cost traced by all possible paths from top left to bottom right in\\n    a given matrix\\n\\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\\n    6\\n\\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\\n    7\\n    \\\"\\\"\\\"\\n\\n    # preprocessing the first row\\n    for i in range(1, len(matrix[0])):\\n        matrix[0][i] += matrix[0][i - 1]\\n\\n    # preprocessing the first column\\n    for i in range(1, len(matrix)):\\n        matrix[i][0] += matrix[i - 1][0]\\n\\n    # updating the path cost for current position\\n    for i in range(1, len(matrix)):\\n        for j in range(1, len(matrix[0])):\\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\\n\\n    return matrix[-1][-1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "minimum partition": "\"\\\"\\\"\\\"\\nPartition a set into two subsets such that the difference of subset sums is minimum\\n\\\"\\\"\\\"\\n\\n\\ndef findMin(arr):\\n    n = len(arr)\\n    s = sum(arr)\\n\\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\\n\\n    for i in range(1, n + 1):\\n        dp[i][0] = True\\n\\n    for i in range(1, s + 1):\\n        dp[0][i] = False\\n\\n    for i in range(1, n + 1):\\n        for j in range(1, s + 1):\\n            dp[i][j] = dp[i][j - 1]\\n\\n            if arr[i - 1] <= j:\\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\\n\\n    for j in range(int(s / 2), -1, -1):\\n        if dp[n][j] is True:\\n            diff = s - 2 * j\\n            break\\n\\n    return diff\\n\"",
    "minimum steps to one": "\"\\\"\\\"\\\"\\nYouTube Explanation: https://www.youtube.com/watch?v=f2xi3c1S95M\\n\\nGiven an integer n, return the minimum steps to 1\\n\\nAVAILABLE STEPS:\\n    * Decrement by 1\\n    * if n is divisible by 2, divide by 2\\n    * if n is divisible by 3, divide by 3\\n\\n\\nExample 1: n = 10\\n10 -> 9 -> 3 -> 1\\nResult: 3 steps\\n\\nExample 2: n = 15\\n15 -> 5 -> 4 -> 2 -> 1\\nResult: 4 steps\\n\\nExample 3: n = 6\\n6 -> 2 -> 1\\nResult: 2 step\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\n__author__ = \\\"Alexander Joslin\\\"\\n\\n\\ndef min_steps_to_one(number: int) -> int:\\n    \\\"\\\"\\\"\\n    Minimum steps to 1 implemented using tabulation.\\n    >>> min_steps_to_one(10)\\n    3\\n    >>> min_steps_to_one(15)\\n    4\\n    >>> min_steps_to_one(6)\\n    2\\n\\n    :param number:\\n    :return int:\\n    \\\"\\\"\\\"\\n\\n    if number <= 0:\\n        raise ValueError(f\\\"n must be greater than 0. Got n = {number}\\\")\\n\\n    table = [number + 1] * (number + 1)\\n\\n    # starting position\\n    table[1] = 0\\n    for i in range(1, number):\\n        table[i + 1] = min(table[i + 1], table[i] + 1)\\n        # check if out of bounds\\n        if i * 2 <= number:\\n            table[i * 2] = min(table[i * 2], table[i] + 1)\\n        # check if out of bounds\\n        if i * 3 <= number:\\n            table[i * 3] = min(table[i * 3], table[i] + 1)\\n    return table[number]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "optimal binary search tree": "\"#!/usr/bin/env python3\\n\\n# This Python program implements an optimal binary search tree (abbreviated BST)\\n# building dynamic programming algorithm that delivers O(n^2) performance.\\n#\\n# The goal of the optimal BST problem is to build a low-cost BST for a\\n# given set of nodes, each with its own key and frequency. The frequency\\n# of the node is defined as how many time the node is being searched.\\n# The search cost of binary search tree is given by this formula:\\n#\\n# cost(1, n) = sum{i = 1 to n}((depth(node_i) + 1) * node_i_freq)\\n#\\n# where n is number of nodes in the BST. The characteristic of low-cost\\n# BSTs is having a faster overall search time than other implementations.\\n# The reason for their fast search time is that the nodes with high\\n# frequencies will be placed near the root of the tree while the nodes\\n# with low frequencies will be placed near the leaves of the tree thus\\n# reducing search time in the most frequent instances.\\nimport sys\\nfrom random import randint\\n\\n\\nclass Node:\\n    \\\"\\\"\\\"Binary Search Tree Node\\\"\\\"\\\"\\n\\n    def __init__(self, key, freq):\\n        self.key = key\\n        self.freq = freq\\n\\n    def __str__(self):\\n        \\\"\\\"\\\"\\n        >>> str(Node(1, 2))\\n        'Node(key=1, freq=2)'\\n        \\\"\\\"\\\"\\n        return f\\\"Node(key={self.key}, freq={self.freq})\\\"\\n\\n\\ndef print_binary_search_tree(root, key, i, j, parent, is_left):\\n    \\\"\\\"\\\"\\n    Recursive function to print a BST from a root table.\\n\\n    >>> key = [3, 8, 9, 10, 17, 21]\\n    >>> root = [[0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 3], [0, 0, 2, 3, 3, 3], \\\\\\n                [0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 5]]\\n    >>> print_binary_search_tree(root, key, 0, 5, -1, False)\\n    8 is the root of the binary search tree.\\n    3 is the left child of key 8.\\n    10 is the right child of key 8.\\n    9 is the left child of key 10.\\n    21 is the right child of key 10.\\n    17 is the left child of key 21.\\n    \\\"\\\"\\\"\\n    if i > j or i < 0 or j > len(root) - 1:\\n        return\\n\\n    node = root[i][j]\\n    if parent == -1:  # root does not have a parent\\n        print(f\\\"{key[node]} is the root of the binary search tree.\\\")\\n    elif is_left:\\n        print(f\\\"{key[node]} is the left child of key {parent}.\\\")\\n    else:\\n        print(f\\\"{key[node]} is the right child of key {parent}.\\\")\\n\\n    print_binary_search_tree(root, key, i, node - 1, key[node], True)\\n    print_binary_search_tree(root, key, node + 1, j, key[node], False)\\n\\n\\ndef find_optimal_binary_search_tree(nodes):\\n    \\\"\\\"\\\"\\n    This function calculates and prints the optimal binary search tree.\\n    The dynamic programming algorithm below runs in O(n^2) time.\\n    Implemented from CLRS (Introduction to Algorithms) book.\\n    https://en.wikipedia.org/wiki/Introduction_to_Algorithms\\n\\n    >>> find_optimal_binary_search_tree([Node(12, 8), Node(10, 34), Node(20, 50), \\\\\\n                                         Node(42, 3), Node(25, 40), Node(37, 30)])\\n    Binary search tree nodes:\\n    Node(key=10, freq=34)\\n    Node(key=12, freq=8)\\n    Node(key=20, freq=50)\\n    Node(key=25, freq=40)\\n    Node(key=37, freq=30)\\n    Node(key=42, freq=3)\\n    <BLANKLINE>\\n    The cost of optimal BST for given tree nodes is 324.\\n    20 is the root of the binary search tree.\\n    10 is the left child of key 20.\\n    12 is the right child of key 10.\\n    25 is the right child of key 20.\\n    37 is the right child of key 25.\\n    42 is the right child of key 37.\\n    \\\"\\\"\\\"\\n    # Tree nodes must be sorted first, the code below sorts the keys in\\n    # increasing order and rearrange its frequencies accordingly.\\n    nodes.sort(key=lambda node: node.key)\\n\\n    n = len(nodes)\\n\\n    keys = [nodes[i].key for i in range(n)]\\n    freqs = [nodes[i].freq for i in range(n)]\\n\\n    # This 2D array stores the overall tree cost (which's as minimized as possible);\\n    # for a single key, cost is equal to frequency of the key.\\n    dp = [[freqs[i] if i == j else 0 for j in range(n)] for i in range(n)]\\n    # sum[i][j] stores the sum of key frequencies between i and j inclusive in nodes\\n    # array\\n    sum = [[freqs[i] if i == j else 0 for j in range(n)] for i in range(n)]\\n    # stores tree roots that will be used later for constructing binary search tree\\n    root = [[i if i == j else 0 for j in range(n)] for i in range(n)]\\n\\n    for interval_length in range(2, n + 1):\\n        for i in range(n - interval_length + 1):\\n            j = i + interval_length - 1\\n\\n            dp[i][j] = sys.maxsize  # set the value to \\\"infinity\\\"\\n            sum[i][j] = sum[i][j - 1] + freqs[j]\\n\\n            # Apply Knuth's optimization\\n            # Loop without optimization: for r in range(i, j + 1):\\n            for r in range(root[i][j - 1], root[i + 1][j] + 1):  # r is a temporal root\\n                left = dp[i][r - 1] if r != i else 0  # optimal cost for left subtree\\n                right = dp[r + 1][j] if r != j else 0  # optimal cost for right subtree\\n                cost = left + sum[i][j] + right\\n\\n                if dp[i][j] > cost:\\n                    dp[i][j] = cost\\n                    root[i][j] = r\\n\\n    print(\\\"Binary search tree nodes:\\\")\\n    for node in nodes:\\n        print(node)\\n\\n    print(f\\\"\\\\nThe cost of optimal BST for given tree nodes is {dp[0][n - 1]}.\\\")\\n    print_binary_search_tree(root, keys, 0, n - 1, -1, False)\\n\\n\\ndef main():\\n    # A sample binary search tree\\n    nodes = [Node(i, randint(1, 50)) for i in range(10, 0, -1)]\\n    find_optimal_binary_search_tree(nodes)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "rod cutting": "\"\\\"\\\"\\\"\\nThis module provides two implementations for the rod-cutting problem:\\n1. A naive recursive implementation which has an exponential runtime\\n2. Two dynamic programming implementations which have quadratic runtime\\n\\nThe rod-cutting problem is the problem of finding the maximum possible revenue\\nobtainable from a rod of length ``n`` given a list of prices for each integral piece\\nof the rod. The maximum revenue can thus be obtained by cutting the rod and selling the\\npieces separately or not cutting it at all if the price of it is the maximum obtainable.\\n\\n\\\"\\\"\\\"\\n\\n\\ndef naive_cut_rod_recursive(n: int, prices: list):\\n    \\\"\\\"\\\"\\n    Solves the rod-cutting problem via naively without using the benefit of dynamic\\n    programming. The results is the same sub-problems are solved several times\\n    leading to an exponential runtime\\n\\n    Runtime: O(2^n)\\n\\n    Arguments\\n    -------\\n    n: int, the length of the rod\\n    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\\n    price for a rod of length ``i``\\n\\n    Returns\\n    -------\\n    The maximum revenue obtainable for a rod of length n given the list of prices\\n    for each piece.\\n\\n    Examples\\n    --------\\n    >>> naive_cut_rod_recursive(4, [1, 5, 8, 9])\\n    10\\n    >>> naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\\n    30\\n    \\\"\\\"\\\"\\n\\n    _enforce_args(n, prices)\\n    if n == 0:\\n        return 0\\n    max_revue = float(\\\"-inf\\\")\\n    for i in range(1, n + 1):\\n        max_revue = max(\\n            max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)\\n        )\\n\\n    return max_revue\\n\\n\\ndef top_down_cut_rod(n: int, prices: list):\\n    \\\"\\\"\\\"\\n    Constructs a top-down dynamic programming solution for the rod-cutting\\n    problem via memoization. This function serves as a wrapper for\\n    _top_down_cut_rod_recursive\\n\\n    Runtime: O(n^2)\\n\\n    Arguments\\n    --------\\n    n: int, the length of the rod\\n    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\\n    price for a rod of length ``i``\\n\\n    Note\\n    ----\\n    For convenience and because Python's lists using 0-indexing, length(max_rev) =\\n    n + 1, to accommodate for the revenue obtainable from a rod of length 0.\\n\\n    Returns\\n    -------\\n    The maximum revenue obtainable for a rod of length n given the list of prices\\n    for each piece.\\n\\n    Examples\\n    -------\\n    >>> top_down_cut_rod(4, [1, 5, 8, 9])\\n    10\\n    >>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\\n    30\\n    \\\"\\\"\\\"\\n    _enforce_args(n, prices)\\n    max_rev = [float(\\\"-inf\\\") for _ in range(n + 1)]\\n    return _top_down_cut_rod_recursive(n, prices, max_rev)\\n\\n\\ndef _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):\\n    \\\"\\\"\\\"\\n    Constructs a top-down dynamic programming solution for the rod-cutting problem\\n    via memoization.\\n\\n    Runtime: O(n^2)\\n\\n    Arguments\\n    --------\\n    n: int, the length of the rod\\n    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\\n    price for a rod of length ``i``\\n    max_rev: list, the computed maximum revenue for a piece of rod.\\n    ``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``\\n\\n    Returns\\n    -------\\n    The maximum revenue obtainable for a rod of length n given the list of prices\\n    for each piece.\\n    \\\"\\\"\\\"\\n    if max_rev[n] >= 0:\\n        return max_rev[n]\\n    elif n == 0:\\n        return 0\\n    else:\\n        max_revenue = float(\\\"-inf\\\")\\n        for i in range(1, n + 1):\\n            max_revenue = max(\\n                max_revenue,\\n                prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),\\n            )\\n\\n        max_rev[n] = max_revenue\\n\\n    return max_rev[n]\\n\\n\\ndef bottom_up_cut_rod(n: int, prices: list):\\n    \\\"\\\"\\\"\\n    Constructs a bottom-up dynamic programming solution for the rod-cutting problem\\n\\n    Runtime: O(n^2)\\n\\n    Arguments\\n    ----------\\n    n: int, the maximum length of the rod.\\n    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\\n    price for a rod of length ``i``\\n\\n    Returns\\n    -------\\n    The maximum revenue obtainable from cutting a rod of length n given\\n    the prices for each piece of rod p.\\n\\n    Examples\\n    -------\\n    >>> bottom_up_cut_rod(4, [1, 5, 8, 9])\\n    10\\n    >>> bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\\n    30\\n    \\\"\\\"\\\"\\n    _enforce_args(n, prices)\\n\\n    # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of\\n    # length 0.\\n    max_rev = [float(\\\"-inf\\\") for _ in range(n + 1)]\\n    max_rev[0] = 0\\n\\n    for i in range(1, n + 1):\\n        max_revenue_i = max_rev[i]\\n        for j in range(1, i + 1):\\n            max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])\\n\\n        max_rev[i] = max_revenue_i\\n\\n    return max_rev[n]\\n\\n\\ndef _enforce_args(n: int, prices: list):\\n    \\\"\\\"\\\"\\n    Basic checks on the arguments to the rod-cutting algorithms\\n\\n    n: int, the length of the rod\\n    prices: list, the price list for each piece of rod.\\n\\n    Throws ValueError:\\n\\n    if n is negative or there are fewer items in the price list than the length of\\n    the rod\\n    \\\"\\\"\\\"\\n    if n < 0:\\n        raise ValueError(f\\\"n must be greater than or equal to 0. Got n = {n}\\\")\\n\\n    if n > len(prices):\\n        raise ValueError(\\n            f\\\"Each integral piece of rod must have a corresponding \\\"\\n            f\\\"price. Got n = {n} but length of prices = {len(prices)}\\\"\\n        )\\n\\n\\ndef main():\\n    prices = [6, 10, 12, 15, 20, 23]\\n    n = len(prices)\\n\\n    # the best revenue comes from cutting the rod into 6 pieces, each\\n    # of length 1 resulting in a revenue of 6 * 6 = 36.\\n    expected_max_revenue = 36\\n\\n    max_rev_top_down = top_down_cut_rod(n, prices)\\n    max_rev_bottom_up = bottom_up_cut_rod(n, prices)\\n    max_rev_naive = naive_cut_rod_recursive(n, prices)\\n\\n    assert expected_max_revenue == max_rev_top_down\\n    assert max_rev_top_down == max_rev_bottom_up\\n    assert max_rev_bottom_up == max_rev_naive\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "subset generation": "\"# Print all subset combinations of n element in given set of r element.\\n\\n\\ndef combination_util(arr, n, r, index, data, i):\\n    \\\"\\\"\\\"\\n    Current combination is ready to be printed, print it\\n    arr[]  ---> Input Array\\n    data[] ---> Temporary array to store current combination\\n    start & end ---> Staring and Ending indexes in arr[]\\n    index  ---> Current index in data[]\\n    r ---> Size of a combination to be printed\\n    \\\"\\\"\\\"\\n    if index == r:\\n        for j in range(r):\\n            print(data[j], end=\\\" \\\")\\n        print(\\\" \\\")\\n        return\\n    #  When no more elements are there to put in data[]\\n    if i >= n:\\n        return\\n    # current is included, put next at next location\\n    data[index] = arr[i]\\n    combination_util(arr, n, r, index + 1, data, i + 1)\\n    # current is excluded, replace it with\\n    # next (Note that i+1 is passed, but\\n    # index is not changed)\\n    combination_util(arr, n, r, index, data, i + 1)\\n    # The main function that prints all combinations\\n    # of size r in arr[] of size n. This function\\n    # mainly uses combinationUtil()\\n\\n\\ndef print_combination(arr, n, r):\\n    # A temporary array to store all combination one by one\\n    data = [0] * r\\n    # Print all combination using temporary array 'data[]'\\n    combination_util(arr, n, r, 0, data, 0)\\n\\n\\n# Driver function to check for above function\\narr = [10, 20, 30, 40, 50]\\nprint_combination(arr, len(arr), 3)\\n# This code is contributed by Ambuj sahu\\n\"",
    "sum of subset": "\"def isSumSubset(arr, arrLen, requiredSum):\\n    \\\"\\\"\\\"\\n    >>> isSumSubset([2, 4, 6, 8], 4, 5)\\n    False\\n    >>> isSumSubset([2, 4, 6, 8], 4, 14)\\n    True\\n    \\\"\\\"\\\"\\n    # a subset value says 1 if that subset sum can be formed else 0\\n    # initially no subsets can be formed hence False/0\\n    subset = [[False for i in range(requiredSum + 1)] for i in range(arrLen + 1)]\\n\\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\\n    # hence True/1\\n    for i in range(arrLen + 1):\\n        subset[i][0] = True\\n\\n    # sum is not zero and set is empty then false\\n    for i in range(1, requiredSum + 1):\\n        subset[0][i] = False\\n\\n    for i in range(1, arrLen + 1):\\n        for j in range(1, requiredSum + 1):\\n            if arr[i - 1] > j:\\n                subset[i][j] = subset[i - 1][j]\\n            if arr[i - 1] <= j:\\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\\n\\n    # uncomment to print the subset\\n    # for i in range(arrLen+1):\\n    #     print(subset[i])\\n    print(subset[arrLen][requiredSum])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "carrier concentration": "\"# https://en.wikipedia.org/wiki/Charge_carrier_density\\n# https://www.pveducation.org/pvcdrom/pn-junctions/equilibrium-carrier-concentration\\n# http://www.ece.utep.edu/courses/ee3329/ee3329/Studyguide/ToC/Fundamentals/Carriers/concentrations.html\\n\\nfrom __future__ import annotations\\n\\n\\ndef carrier_concentration(\\n    electron_conc: float,\\n    hole_conc: float,\\n    intrinsic_conc: float,\\n) -> tuple:\\n    \\\"\\\"\\\"\\n    This function can calculate any one of the three -\\n    1. Electron Concentration\\n    2, Hole Concentration\\n    3. Intrinsic Concentration\\n    given the other two.\\n    Examples -\\n    >>> carrier_concentration(electron_conc=25, hole_conc=100, intrinsic_conc=0)\\n    ('intrinsic_conc', 50.0)\\n    >>> carrier_concentration(electron_conc=0, hole_conc=1600, intrinsic_conc=200)\\n    ('electron_conc', 25.0)\\n    >>> carrier_concentration(electron_conc=1000, hole_conc=0, intrinsic_conc=1200)\\n    ('hole_conc', 1440.0)\\n    >>> carrier_concentration(electron_conc=1000, hole_conc=400, intrinsic_conc=1200)\\n    Traceback (most recent call last):\\n        File \\\"<stdin>\\\", line 37, in <module>\\n    ValueError: You cannot supply more or less than 2 values\\n    >>> carrier_concentration(electron_conc=-1000, hole_conc=0, intrinsic_conc=1200)\\n    Traceback (most recent call last):\\n        File \\\"<stdin>\\\", line 40, in <module>\\n    ValueError: Electron concentration cannot be negative in a semiconductor\\n    >>> carrier_concentration(electron_conc=0, hole_conc=-400, intrinsic_conc=1200)\\n    Traceback (most recent call last):\\n        File \\\"<stdin>\\\", line 44, in <module>\\n    ValueError: Hole concentration cannot be negative in a semiconductor\\n    >>> carrier_concentration(electron_conc=0, hole_conc=400, intrinsic_conc=-1200)\\n    Traceback (most recent call last):\\n        File \\\"<stdin>\\\", line 48, in <module>\\n    ValueError: Intrinsic concentration cannot be negative in a semiconductor\\n    \\\"\\\"\\\"\\n    if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:\\n        raise ValueError(\\\"You cannot supply more or less than 2 values\\\")\\n    elif electron_conc < 0:\\n        raise ValueError(\\\"Electron concentration cannot be negative in a semiconductor\\\")\\n    elif hole_conc < 0:\\n        raise ValueError(\\\"Hole concentration cannot be negative in a semiconductor\\\")\\n    elif intrinsic_conc < 0:\\n        raise ValueError(\\n            \\\"Intrinsic concentration cannot be negative in a semiconductor\\\"\\n        )\\n    elif electron_conc == 0:\\n        return (\\n            \\\"electron_conc\\\",\\n            intrinsic_conc ** 2 / hole_conc,\\n        )\\n    elif hole_conc == 0:\\n        return (\\n            \\\"hole_conc\\\",\\n            intrinsic_conc ** 2 / electron_conc,\\n        )\\n    elif intrinsic_conc == 0:\\n        return (\\n            \\\"intrinsic_conc\\\",\\n            (electron_conc * hole_conc) ** 0.5,\\n        )\\n    else:\\n        return (-1, -1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "coulombs law": "\"# https://en.wikipedia.org/wiki/Coulomb%27s_law\\n\\nfrom __future__ import annotations\\n\\nCOULOMBS_CONSTANT = 8.988e9  # units = N * m^s * C^-2\\n\\n\\ndef couloumbs_law(\\n    force: float, charge1: float, charge2: float, distance: float\\n) -> dict[str, float]:\\n\\n    \\\"\\\"\\\"\\n    Apply Coulomb's Law on any three given values. These can be force, charge1,\\n    charge2, or distance, and then in a Python dict return name/value pair of\\n    the zero value.\\n\\n    Coulomb's Law states that the magnitude of the electrostatic force of\\n    attraction or repulsion between two point charges is directly proportional\\n    to the product of the magnitudes of charges and inversely proportional to\\n    the square of the distance between them.\\n\\n    Reference\\n    ----------\\n    Coulomb (1785) \\\"Premier mémoire sur l’électricité et le magnétisme,\\\"\\n    Histoire de l’Académie Royale des Sciences, pp. 569–577.\\n\\n    Parameters\\n    ----------\\n    force : float with units in Newtons\\n\\n    charge1 : float with units in Coulombs\\n\\n    charge2 : float with units in Coulombs\\n\\n    distance : float with units in meters\\n\\n    Returns\\n    -------\\n    result : dict name/value pair of the zero value\\n\\n    >>> couloumbs_law(force=0, charge1=3, charge2=5, distance=2000)\\n    {'force': 33705.0}\\n\\n    >>> couloumbs_law(force=10, charge1=3, charge2=5, distance=0)\\n    {'distance': 116112.01488218177}\\n\\n    >>> couloumbs_law(force=10, charge1=0, charge2=5, distance=2000)\\n    {'charge1': 0.0008900756564307966}\\n\\n    >>> couloumbs_law(force=0, charge1=0, charge2=5, distance=2000)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: One and only one argument must be 0\\n\\n    >>> couloumbs_law(force=0, charge1=3, charge2=5, distance=-2000)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Distance cannot be negative\\n\\n    \\\"\\\"\\\"\\n\\n    charge_product = abs(charge1 * charge2)\\n\\n    if (force, charge1, charge2, distance).count(0) != 1:\\n        raise ValueError(\\\"One and only one argument must be 0\\\")\\n    if distance < 0:\\n        raise ValueError(\\\"Distance cannot be negative\\\")\\n    if force == 0:\\n        force = COULOMBS_CONSTANT * charge_product / (distance ** 2)\\n        return {\\\"force\\\": force}\\n    elif charge1 == 0:\\n        charge1 = abs(force) * (distance ** 2) / (COULOMBS_CONSTANT * charge2)\\n        return {\\\"charge1\\\": charge1}\\n    elif charge2 == 0:\\n        charge2 = abs(force) * (distance ** 2) / (COULOMBS_CONSTANT * charge1)\\n        return {\\\"charge2\\\": charge2}\\n    elif distance == 0:\\n        distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5\\n        return {\\\"distance\\\": distance}\\n    raise ValueError(\\\"Exactly one argument must be 0\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "electric power": "\"# https://en.m.wikipedia.org/wiki/Electric_power\\nfrom __future__ import annotations\\n\\nfrom collections import namedtuple\\n\\n\\ndef electric_power(voltage: float, current: float, power: float) -> tuple:\\n    \\\"\\\"\\\"\\n    This function can calculate any one of the three (voltage, current, power),\\n    fundamental value of electrical system.\\n    examples are below:\\n    >>> electric_power(voltage=0, current=2, power=5)\\n    result(name='voltage', value=2.5)\\n    >>> electric_power(voltage=2, current=2, power=0)\\n    result(name='power', value=4.0)\\n    >>> electric_power(voltage=-2, current=3, power=0)\\n    result(name='power', value=6.0)\\n    >>> electric_power(voltage=2, current=4, power=2)\\n    Traceback (most recent call last):\\n        File \\\"<stdin>\\\", line 15, in <module>\\n    ValueError: Only one argument must be 0\\n    >>> electric_power(voltage=0, current=0, power=2)\\n    Traceback (most recent call last):\\n        File \\\"<stdin>\\\", line 19, in <module>\\n    ValueError: Only one argument must be 0\\n    >>> electric_power(voltage=0, current=2, power=-4)\\n    Traceback (most recent call last):\\n        File \\\"<stdin>\\\", line 23, in <modulei\\n    ValueError: Power cannot be negative in any electrical/electronics system\\n    >>> electric_power(voltage=2.2, current=2.2, power=0)\\n    result(name='power', value=4.84)\\n    \\\"\\\"\\\"\\n    result = namedtuple(\\\"result\\\", \\\"name value\\\")\\n    if (voltage, current, power).count(0) != 1:\\n        raise ValueError(\\\"Only one argument must be 0\\\")\\n    elif power < 0:\\n        raise ValueError(\\n            \\\"Power cannot be negative in any electrical/electronics system\\\"\\n        )\\n    elif voltage == 0:\\n        return result(\\\"voltage\\\", power / current)\\n    elif current == 0:\\n        return result(\\\"current\\\", power / voltage)\\n    elif power == 0:\\n        return result(\\\"power\\\", float(round(abs(voltage * current), 2)))\\n    else:\\n        raise ValueError(\\\"Exactly one argument must be 0\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "ohms law": "\"# https://en.wikipedia.org/wiki/Ohm%27s_law\\nfrom __future__ import annotations\\n\\n\\ndef ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:\\n    \\\"\\\"\\\"\\n    Apply Ohm's Law, on any two given electrical values, which can be voltage, current,\\n    and resistance, and then in a Python dict return name/value pair of the zero value.\\n\\n    >>> ohms_law(voltage=10, resistance=5, current=0)\\n    {'current': 2.0}\\n    >>> ohms_law(voltage=0, current=0, resistance=10)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: One and only one argument must be 0\\n    >>> ohms_law(voltage=0, current=1, resistance=-2)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Resistance cannot be negative\\n    >>> ohms_law(resistance=0, voltage=-10, current=1)\\n    {'resistance': -10.0}\\n    >>> ohms_law(voltage=0, current=-1.5, resistance=2)\\n    {'voltage': -3.0}\\n    \\\"\\\"\\\"\\n    if (voltage, current, resistance).count(0) != 1:\\n        raise ValueError(\\\"One and only one argument must be 0\\\")\\n    if resistance < 0:\\n        raise ValueError(\\\"Resistance cannot be negative\\\")\\n    if voltage == 0:\\n        return {\\\"voltage\\\": float(current * resistance)}\\n    elif current == 0:\\n        return {\\\"current\\\": voltage / resistance}\\n    elif resistance == 0:\\n        return {\\\"resistance\\\": voltage / current}\\n    else:\\n        raise ValueError(\\\"Exactly one argument must be 0\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "mytext": "\"Hello\\nThis is sample data\\n«küßî»\\n“ЌύБЇ”\\n😀😉\\n😋\\n\"",
    "receive file": "\"if __name__ == \\\"__main__\\\":\\n    import socket  # Import socket module\\n\\n    sock = socket.socket()  # Create a socket object\\n    host = socket.gethostname()  # Get local machine name\\n    port = 12312\\n\\n    sock.connect((host, port))\\n    sock.send(b\\\"Hello server!\\\")\\n\\n    with open(\\\"Received_file\\\", \\\"wb\\\") as out_file:\\n        print(\\\"File opened\\\")\\n        print(\\\"Receiving data...\\\")\\n        while True:\\n            data = sock.recv(1024)\\n            print(f\\\"{data = }\\\")\\n            if not data:\\n                break\\n            out_file.write(data)  # Write data to a file\\n\\n    print(\\\"Successfully got the file\\\")\\n    sock.close()\\n    print(\\\"Connection closed\\\")\\n\"",
    "send file": "\"def send_file(filename: str = \\\"mytext.txt\\\", testing: bool = False) -> None:\\n    import socket\\n\\n    port = 12312  # Reserve a port for your service.\\n    sock = socket.socket()  # Create a socket object\\n    host = socket.gethostname()  # Get local machine name\\n    sock.bind((host, port))  # Bind to the port\\n    sock.listen(5)  # Now wait for client connection.\\n\\n    print(\\\"Server listening....\\\")\\n\\n    while True:\\n        conn, addr = sock.accept()  # Establish connection with client.\\n        print(f\\\"Got connection from {addr}\\\")\\n        data = conn.recv(1024)\\n        print(f\\\"Server received: {data = }\\\")\\n\\n        with open(filename, \\\"rb\\\") as in_file:\\n            data = in_file.read(1024)\\n            while data:\\n                conn.send(data)\\n                print(f\\\"Sent {data!r}\\\")\\n                data = in_file.read(1024)\\n\\n        print(\\\"Done sending\\\")\\n        conn.close()\\n        if testing:  # Allow the test to complete\\n            break\\n\\n    sock.shutdown(1)\\n    sock.close()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    send_file()\\n\"",
    "about": "\"### Interest\\n\\n* Compound Interest: \\\"Compound interest is calculated by multiplying the initial principal amount by one plus the annual interest rate raised to the number of compound periods minus one.\\\" [Compound Interest](https://www.investopedia.com/)\\n* Simple Interest: \\\"Simple interest paid or received over a certain period is a fixed percentage of the principal amount that was borrowed or lent. \\\" [Simple Interest](https://www.investopedia.com/)\\n\"",
    "equated monthly installments": "\"\\\"\\\"\\\"\\nProgram to calculate the amortization amount per month, given\\n- Principal borrowed\\n- Rate of interest per annum\\n- Years to repay the loan\\n\\nWikipedia Reference: https://en.wikipedia.org/wiki/Equated_monthly_installment\\n\\\"\\\"\\\"\\n\\n\\ndef equated_monthly_installments(\\n    principal: float, rate_per_annum: float, years_to_repay: int\\n) -> float:\\n    \\\"\\\"\\\"\\n    Formula for amortization amount per month:\\n    A = p * r * (1 + r)^n / ((1 + r)^n - 1)\\n    where p is the principal, r is the rate of interest per month\\n    and n is the number of payments\\n\\n    >>> equated_monthly_installments(25000, 0.12, 3)\\n    830.3577453212793\\n    >>> equated_monthly_installments(25000, 0.12, 10)\\n    358.67737100646826\\n    >>> equated_monthly_installments(0, 0.12, 3)\\n    Traceback (most recent call last):\\n        ...\\n    Exception: Principal borrowed must be > 0\\n    >>> equated_monthly_installments(25000, -1, 3)\\n    Traceback (most recent call last):\\n        ...\\n    Exception: Rate of interest must be >= 0\\n    >>> equated_monthly_installments(25000, 0.12, 0)\\n    Traceback (most recent call last):\\n        ...\\n    Exception: Years to repay must be an integer > 0\\n    \\\"\\\"\\\"\\n    if principal <= 0:\\n        raise Exception(\\\"Principal borrowed must be > 0\\\")\\n    if rate_per_annum < 0:\\n        raise Exception(\\\"Rate of interest must be >= 0\\\")\\n    if years_to_repay <= 0 or not isinstance(years_to_repay, int):\\n        raise Exception(\\\"Years to repay must be an integer > 0\\\")\\n\\n    # Yearly rate is divided by 12 to get monthly rate\\n    rate_per_month = rate_per_annum / 12\\n\\n    # Years to repay is multiplied by 12 to get number of payments as payment is monthly\\n    number_of_payments = years_to_repay * 12\\n\\n    return (\\n        principal\\n        * rate_per_month\\n        * (1 + rate_per_month) ** number_of_payments\\n        / ((1 + rate_per_month) ** number_of_payments - 1)\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "interest": "\"# https://www.investopedia.com\\n\\nfrom __future__ import annotations\\n\\n\\ndef simple_interest(\\n    principal: float, daily_interest_rate: float, days_between_payments: int\\n) -> float:\\n    \\\"\\\"\\\"\\n    >>> simple_interest(18000.0, 0.06, 3)\\n    3240.0\\n    >>> simple_interest(0.5, 0.06, 3)\\n    0.09\\n    >>> simple_interest(18000.0, 0.01, 10)\\n    1800.0\\n    >>> simple_interest(18000.0, 0.0, 3)\\n    0.0\\n    >>> simple_interest(5500.0, 0.01, 100)\\n    5500.0\\n    >>> simple_interest(10000.0, -0.06, 3)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: daily_interest_rate must be >= 0\\n    >>> simple_interest(-10000.0, 0.06, 3)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: principal must be > 0\\n    >>> simple_interest(5500.0, 0.01, -5)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: days_between_payments must be > 0\\n    \\\"\\\"\\\"\\n    if days_between_payments <= 0:\\n        raise ValueError(\\\"days_between_payments must be > 0\\\")\\n    if daily_interest_rate < 0:\\n        raise ValueError(\\\"daily_interest_rate must be >= 0\\\")\\n    if principal <= 0:\\n        raise ValueError(\\\"principal must be > 0\\\")\\n    return principal * daily_interest_rate * days_between_payments\\n\\n\\ndef compound_interest(\\n    principal: float,\\n    nominal_annual_interest_rate_percentage: float,\\n    number_of_compounding_periods: int,\\n) -> float:\\n    \\\"\\\"\\\"\\n    >>> compound_interest(10000.0, 0.05, 3)\\n    1576.2500000000014\\n    >>> compound_interest(10000.0, 0.05, 1)\\n    500.00000000000045\\n    >>> compound_interest(0.5, 0.05, 3)\\n    0.07881250000000006\\n    >>> compound_interest(10000.0, 0.06, -4)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: number_of_compounding_periods must be > 0\\n    >>> compound_interest(10000.0, -3.5, 3.0)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: nominal_annual_interest_rate_percentage must be >= 0\\n    >>> compound_interest(-5500.0, 0.01, 5)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: principal must be > 0\\n    \\\"\\\"\\\"\\n    if number_of_compounding_periods <= 0:\\n        raise ValueError(\\\"number_of_compounding_periods must be > 0\\\")\\n    if nominal_annual_interest_rate_percentage < 0:\\n        raise ValueError(\\\"nominal_annual_interest_rate_percentage must be >= 0\\\")\\n    if principal <= 0:\\n        raise ValueError(\\\"principal must be > 0\\\")\\n\\n    return principal * (\\n        (1 + nominal_annual_interest_rate_percentage) ** number_of_compounding_periods\\n        - 1\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "julia sets": "\"\\\"\\\"\\\"Author Alexandre De Zotti\\n\\nDraws Julia sets of quadratic polynomials and exponential maps.\\n More specifically, this iterates the function a fixed number of times\\n then plots whether the absolute value of the last iterate is greater than\\n a fixed threshold (named \\\"escape radius\\\"). For the exponential map this is not\\n really an escape radius but rather a convenient way to approximate the Julia\\n set with bounded orbits.\\n\\nThe examples presented here are:\\n- The Cauliflower Julia set, see e.g.\\nhttps://en.wikipedia.org/wiki/File:Julia_z2%2B0,25.png\\n- Other examples from https://en.wikipedia.org/wiki/Julia_set\\n- An exponential map Julia set, ambiantly homeomorphic to the examples in\\nhttp://www.math.univ-toulouse.fr/~cheritat/GalII/galery.html\\n and\\nhttps://ddd.uab.cat/pub/pubmat/02141493v43n1/02141493v43n1p27.pdf\\n\\nRemark: Some overflow runtime warnings are suppressed. This is because of the\\n way the iteration loop is implemented, using numpy's efficient computations.\\n Overflows and infinites are replaced after each step by a large number.\\n\\\"\\\"\\\"\\n\\nimport warnings\\nfrom typing import Any, Callable\\n\\nimport numpy\\nfrom matplotlib import pyplot\\n\\nc_cauliflower = 0.25 + 0.0j\\nc_polynomial_1 = -0.4 + 0.6j\\nc_polynomial_2 = -0.1 + 0.651j\\nc_exponential = -2.0\\nnb_iterations = 56\\nwindow_size = 2.0\\nnb_pixels = 666\\n\\n\\ndef eval_exponential(c_parameter: complex, z_values: numpy.ndarray) -> numpy.ndarray:\\n    \\\"\\\"\\\"\\n    Evaluate $e^z + c$.\\n    >>> eval_exponential(0, 0)\\n    1.0\\n    >>> abs(eval_exponential(1, numpy.pi*1.j)) < 1e-15\\n    True\\n    >>> abs(eval_exponential(1.j, 0)-1-1.j) < 1e-15\\n    True\\n    \\\"\\\"\\\"\\n    return numpy.exp(z_values) + c_parameter\\n\\n\\ndef eval_quadratic_polynomial(\\n    c_parameter: complex, z_values: numpy.ndarray\\n) -> numpy.ndarray:\\n    \\\"\\\"\\\"\\n    >>> eval_quadratic_polynomial(0, 2)\\n    4\\n    >>> eval_quadratic_polynomial(-1, 1)\\n    0\\n    >>> round(eval_quadratic_polynomial(1.j, 0).imag)\\n    1\\n    >>> round(eval_quadratic_polynomial(1.j, 0).real)\\n    0\\n    \\\"\\\"\\\"\\n    return z_values * z_values + c_parameter\\n\\n\\ndef prepare_grid(window_size: float, nb_pixels: int) -> numpy.ndarray:\\n    \\\"\\\"\\\"\\n    Create a grid of complex values of size nb_pixels*nb_pixels with real and\\n     imaginary parts ranging from -window_size to window_size (inclusive).\\n    Returns a numpy array.\\n\\n    >>> prepare_grid(1,3)\\n    array([[-1.-1.j, -1.+0.j, -1.+1.j],\\n           [ 0.-1.j,  0.+0.j,  0.+1.j],\\n           [ 1.-1.j,  1.+0.j,  1.+1.j]])\\n    \\\"\\\"\\\"\\n    x = numpy.linspace(-window_size, window_size, nb_pixels)\\n    x = x.reshape((nb_pixels, 1))\\n    y = numpy.linspace(-window_size, window_size, nb_pixels)\\n    y = y.reshape((1, nb_pixels))\\n    return x + 1.0j * y\\n\\n\\ndef iterate_function(\\n    eval_function: Callable[[Any, numpy.ndarray], numpy.ndarray],\\n    function_params: Any,\\n    nb_iterations: int,\\n    z_0: numpy.ndarray,\\n    infinity: float = None,\\n) -> numpy.ndarray:\\n    \\\"\\\"\\\"\\n    Iterate the function \\\"eval_function\\\" exactly nb_iterations times.\\n    The first argument of the function is a parameter which is contained in\\n    function_params. The variable z_0 is an array that contains the initial\\n    values to iterate from.\\n    This function returns the final iterates.\\n\\n    >>> iterate_function(eval_quadratic_polynomial, 0, 3, numpy.array([0,1,2])).shape\\n    (3,)\\n    >>> numpy.round(iterate_function(eval_quadratic_polynomial,\\n    ... 0,\\n    ... 3,\\n    ... numpy.array([0,1,2]))[0])\\n    0j\\n    >>> numpy.round(iterate_function(eval_quadratic_polynomial,\\n    ... 0,\\n    ... 3,\\n    ... numpy.array([0,1,2]))[1])\\n    (1+0j)\\n    >>> numpy.round(iterate_function(eval_quadratic_polynomial,\\n    ... 0,\\n    ... 3,\\n    ... numpy.array([0,1,2]))[2])\\n    (256+0j)\\n    \\\"\\\"\\\"\\n\\n    z_n = z_0.astype(\\\"complex64\\\")\\n    for i in range(nb_iterations):\\n        z_n = eval_function(function_params, z_n)\\n        if infinity is not None:\\n            numpy.nan_to_num(z_n, copy=False, nan=infinity)\\n            z_n[abs(z_n) == numpy.inf] = infinity\\n    return z_n\\n\\n\\ndef show_results(\\n    function_label: str,\\n    function_params: Any,\\n    escape_radius: float,\\n    z_final: numpy.ndarray,\\n) -> None:\\n    \\\"\\\"\\\"\\n    Plots of whether the absolute value of z_final is greater than\\n    the value of escape_radius. Adds the function_label and function_params to\\n    the title.\\n\\n    >>> show_results('80', 0, 1, numpy.array([[0,1,.5],[.4,2,1.1],[.2,1,1.3]]))\\n    \\\"\\\"\\\"\\n\\n    abs_z_final = (abs(z_final)).transpose()\\n    abs_z_final[:, :] = abs_z_final[::-1, :]\\n    pyplot.matshow(abs_z_final < escape_radius)\\n    pyplot.title(f\\\"Julia set of ${function_label}$, $c={function_params}$\\\")\\n    pyplot.show()\\n\\n\\ndef ignore_overflow_warnings() -> None:\\n    \\\"\\\"\\\"\\n    Ignore some overflow and invalid value warnings.\\n\\n    >>> ignore_overflow_warnings()\\n    \\\"\\\"\\\"\\n    warnings.filterwarnings(\\n        \\\"ignore\\\", category=RuntimeWarning, message=\\\"overflow encountered in multiply\\\"\\n    )\\n    warnings.filterwarnings(\\n        \\\"ignore\\\",\\n        category=RuntimeWarning,\\n        message=\\\"invalid value encountered in multiply\\\",\\n    )\\n    warnings.filterwarnings(\\n        \\\"ignore\\\", category=RuntimeWarning, message=\\\"overflow encountered in absolute\\\"\\n    )\\n    warnings.filterwarnings(\\n        \\\"ignore\\\", category=RuntimeWarning, message=\\\"overflow encountered in exp\\\"\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    z_0 = prepare_grid(window_size, nb_pixels)\\n\\n    ignore_overflow_warnings()  # See file header for explanations\\n\\n    nb_iterations = 24\\n    escape_radius = 2 * abs(c_cauliflower) + 1\\n    z_final = iterate_function(\\n        eval_quadratic_polynomial,\\n        c_cauliflower,\\n        nb_iterations,\\n        z_0,\\n        infinity=1.1 * escape_radius,\\n    )\\n    show_results(\\\"z^2+c\\\", c_cauliflower, escape_radius, z_final)\\n\\n    nb_iterations = 64\\n    escape_radius = 2 * abs(c_polynomial_1) + 1\\n    z_final = iterate_function(\\n        eval_quadratic_polynomial,\\n        c_polynomial_1,\\n        nb_iterations,\\n        z_0,\\n        infinity=1.1 * escape_radius,\\n    )\\n    show_results(\\\"z^2+c\\\", c_polynomial_1, escape_radius, z_final)\\n\\n    nb_iterations = 161\\n    escape_radius = 2 * abs(c_polynomial_2) + 1\\n    z_final = iterate_function(\\n        eval_quadratic_polynomial,\\n        c_polynomial_2,\\n        nb_iterations,\\n        z_0,\\n        infinity=1.1 * escape_radius,\\n    )\\n    show_results(\\\"z^2+c\\\", c_polynomial_2, escape_radius, z_final)\\n\\n    nb_iterations = 12\\n    escape_radius = 10000.0\\n    z_final = iterate_function(\\n        eval_exponential,\\n        c_exponential,\\n        nb_iterations,\\n        z_0 + 2,\\n        infinity=1.0e10,\\n    )\\n    show_results(\\\"e^z+c\\\", c_exponential, escape_radius, z_final)\\n\"",
    "koch snowflake": "\"\\\"\\\"\\\"\\nDescription\\n    The Koch snowflake is a fractal curve and one of the earliest fractals to\\n    have been described. The Koch snowflake can be built up iteratively, in a\\n    sequence of stages. The first stage is an equilateral triangle, and each\\n    successive stage is formed by adding outward bends to each side of the\\n    previous stage, making smaller equilateral triangles.\\n    This can be achieved through the following steps for each line:\\n        1. divide the line segment into three segments of equal length.\\n        2. draw an equilateral triangle that has the middle segment from step 1\\n        as its base and points outward.\\n        3. remove the line segment that is the base of the triangle from step 2.\\n    (description adapted from https://en.wikipedia.org/wiki/Koch_snowflake )\\n    (for a more detailed explanation and an implementation in the\\n    Processing language, see  https://natureofcode.com/book/chapter-8-fractals/\\n    #84-the-koch-curve-and-the-arraylist-technique )\\n\\nRequirements (pip):\\n    - matplotlib\\n    - numpy\\n\\\"\\\"\\\"\\n\\n\\nfrom __future__ import annotations\\n\\nimport matplotlib.pyplot as plt  # type: ignore\\nimport numpy\\n\\n# initial triangle of Koch snowflake\\nVECTOR_1 = numpy.array([0, 0])\\nVECTOR_2 = numpy.array([0.5, 0.8660254])\\nVECTOR_3 = numpy.array([1, 0])\\nINITIAL_VECTORS = [VECTOR_1, VECTOR_2, VECTOR_3, VECTOR_1]\\n\\n# uncomment for simple Koch curve instead of Koch snowflake\\n# INITIAL_VECTORS = [VECTOR_1, VECTOR_3]\\n\\n\\ndef iterate(initial_vectors: list[numpy.ndarray], steps: int) -> list[numpy.ndarray]:\\n    \\\"\\\"\\\"\\n    Go through the number of iterations determined by the argument \\\"steps\\\".\\n    Be careful with high values (above 5) since the time to calculate increases\\n    exponentially.\\n    >>> iterate([numpy.array([0, 0]), numpy.array([1, 0])], 1)\\n    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , \\\\\\n0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]\\n    \\\"\\\"\\\"\\n    vectors = initial_vectors\\n    for i in range(steps):\\n        vectors = iteration_step(vectors)\\n    return vectors\\n\\n\\ndef iteration_step(vectors: list[numpy.ndarray]) -> list[numpy.ndarray]:\\n    \\\"\\\"\\\"\\n    Loops through each pair of adjacent vectors. Each line between two adjacent\\n    vectors is divided into 4 segments by adding 3 additional vectors in-between\\n    the original two vectors. The vector in the middle is constructed through a\\n    60 degree rotation so it is bent outwards.\\n    >>> iteration_step([numpy.array([0, 0]), numpy.array([1, 0])])\\n    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , \\\\\\n0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]\\n    \\\"\\\"\\\"\\n    new_vectors = []\\n    for i, start_vector in enumerate(vectors[:-1]):\\n        end_vector = vectors[i + 1]\\n        new_vectors.append(start_vector)\\n        difference_vector = end_vector - start_vector\\n        new_vectors.append(start_vector + difference_vector / 3)\\n        new_vectors.append(\\n            start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)\\n        )\\n        new_vectors.append(start_vector + difference_vector * 2 / 3)\\n    new_vectors.append(vectors[-1])\\n    return new_vectors\\n\\n\\ndef rotate(vector: numpy.ndarray, angle_in_degrees: float) -> numpy.ndarray:\\n    \\\"\\\"\\\"\\n    Standard rotation of a 2D vector with a rotation matrix\\n    (see https://en.wikipedia.org/wiki/Rotation_matrix )\\n    >>> rotate(numpy.array([1, 0]), 60)\\n    array([0.5      , 0.8660254])\\n    >>> rotate(numpy.array([1, 0]), 90)\\n    array([6.123234e-17, 1.000000e+00])\\n    \\\"\\\"\\\"\\n    theta = numpy.radians(angle_in_degrees)\\n    c, s = numpy.cos(theta), numpy.sin(theta)\\n    rotation_matrix = numpy.array(((c, -s), (s, c)))\\n    return numpy.dot(rotation_matrix, vector)\\n\\n\\ndef plot(vectors: list[numpy.ndarray]) -> None:\\n    \\\"\\\"\\\"\\n    Utility function to plot the vectors using matplotlib.pyplot\\n    No doctest was implemented since this function does not have a return value\\n    \\\"\\\"\\\"\\n    # avoid stretched display of graph\\n    axes = plt.gca()\\n    axes.set_aspect(\\\"equal\\\")\\n\\n    # matplotlib.pyplot.plot takes a list of all x-coordinates and a list of all\\n    # y-coordinates as inputs, which are constructed from the vector-list using\\n    # zip()\\n    x_coordinates, y_coordinates = zip(*vectors)\\n    plt.plot(x_coordinates, y_coordinates)\\n    plt.show()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    processed_vectors = iterate(INITIAL_VECTORS, 5)\\n    plot(processed_vectors)\\n\"",
    "mandelbrot": "\"\\\"\\\"\\\"\\r\\nThe Mandelbrot set is the set of complex numbers \\\"c\\\" for which the series\\r\\n\\\"z_(n+1) = z_n * z_n + c\\\" does not diverge, i.e. remains bounded. Thus, a\\r\\ncomplex number \\\"c\\\" is a member of the Mandelbrot set if, when starting with\\r\\n\\\"z_0 = 0\\\" and applying the iteration repeatedly, the absolute value of\\r\\n\\\"z_n\\\" remains bounded for all \\\"n > 0\\\". Complex numbers can be written as\\r\\n\\\"a + b*i\\\": \\\"a\\\" is the real component, usually drawn on the x-axis, and \\\"b*i\\\"\\r\\nis the imaginary component, usually drawn on the y-axis. Most visualizations\\r\\nof the Mandelbrot set use a color-coding to indicate after how many steps in\\r\\nthe series the numbers outside the set diverge. Images of the Mandelbrot set\\r\\nexhibit an elaborate and infinitely complicated boundary that reveals\\r\\nprogressively ever-finer recursive detail at increasing magnifications, making\\r\\nthe boundary of the Mandelbrot set a fractal curve.\\r\\n(description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set )\\r\\n(see also https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set )\\r\\n\\\"\\\"\\\"\\r\\n\\r\\n\\r\\nimport colorsys\\r\\n\\r\\nfrom PIL import Image  # type: ignore\\r\\n\\r\\n\\r\\ndef get_distance(x: float, y: float, max_step: int) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Return the relative distance (= step/max_step) after which the complex number\\r\\n    constituted by this x-y-pair diverges. Members of the Mandelbrot set do not\\r\\n    diverge so their distance is 1.\\r\\n\\r\\n    >>> get_distance(0, 0, 50)\\r\\n    1.0\\r\\n    >>> get_distance(0.5, 0.5, 50)\\r\\n    0.061224489795918366\\r\\n    >>> get_distance(2, 0, 50)\\r\\n    0.0\\r\\n    \\\"\\\"\\\"\\r\\n    a = x\\r\\n    b = y\\r\\n    for step in range(max_step):\\r\\n        a_new = a * a - b * b + x\\r\\n        b = 2 * a * b + y\\r\\n        a = a_new\\r\\n\\r\\n        # divergence happens for all complex number with an absolute value\\r\\n        # greater than 4\\r\\n        if a * a + b * b > 4:\\r\\n            break\\r\\n    return step / (max_step - 1)\\r\\n\\r\\n\\r\\ndef get_black_and_white_rgb(distance: float) -> tuple:\\r\\n    \\\"\\\"\\\"\\r\\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\\r\\n    set is black, everything else is white.\\r\\n\\r\\n    >>> get_black_and_white_rgb(0)\\r\\n    (255, 255, 255)\\r\\n    >>> get_black_and_white_rgb(0.5)\\r\\n    (255, 255, 255)\\r\\n    >>> get_black_and_white_rgb(1)\\r\\n    (0, 0, 0)\\r\\n    \\\"\\\"\\\"\\r\\n    if distance == 1:\\r\\n        return (0, 0, 0)\\r\\n    else:\\r\\n        return (255, 255, 255)\\r\\n\\r\\n\\r\\ndef get_color_coded_rgb(distance: float) -> tuple:\\r\\n    \\\"\\\"\\\"\\r\\n    Color-coding taking the relative distance into account. The Mandelbrot set\\r\\n    is black.\\r\\n\\r\\n    >>> get_color_coded_rgb(0)\\r\\n    (255, 0, 0)\\r\\n    >>> get_color_coded_rgb(0.5)\\r\\n    (0, 255, 255)\\r\\n    >>> get_color_coded_rgb(1)\\r\\n    (0, 0, 0)\\r\\n    \\\"\\\"\\\"\\r\\n    if distance == 1:\\r\\n        return (0, 0, 0)\\r\\n    else:\\r\\n        return tuple(round(i * 255) for i in colorsys.hsv_to_rgb(distance, 1, 1))\\r\\n\\r\\n\\r\\ndef get_image(\\r\\n    image_width: int = 800,\\r\\n    image_height: int = 600,\\r\\n    figure_center_x: float = -0.6,\\r\\n    figure_center_y: float = 0,\\r\\n    figure_width: float = 3.2,\\r\\n    max_step: int = 50,\\r\\n    use_distance_color_coding: bool = True,\\r\\n) -> Image.Image:\\r\\n    \\\"\\\"\\\"\\r\\n    Function to generate the image of the Mandelbrot set. Two types of coordinates\\r\\n    are used: image-coordinates that refer to the pixels and figure-coordinates\\r\\n    that refer to the complex numbers inside and outside the Mandelbrot set. The\\r\\n    figure-coordinates in the arguments of this function determine which section\\r\\n    of the Mandelbrot set is viewed. The main area of the Mandelbrot set is\\r\\n    roughly between \\\"-1.5 < x < 0.5\\\" and \\\"-1 < y < 1\\\" in the figure-coordinates.\\r\\n\\r\\n    Commenting out tests that slow down pytest...\\r\\n    # 13.35s call     fractals/mandelbrot.py::mandelbrot.get_image\\r\\n    # >>> get_image().load()[0,0]\\r\\n    (255, 0, 0)\\r\\n    # >>> get_image(use_distance_color_coding = False).load()[0,0]\\r\\n    (255, 255, 255)\\r\\n    \\\"\\\"\\\"\\r\\n    img = Image.new(\\\"RGB\\\", (image_width, image_height))\\r\\n    pixels = img.load()\\r\\n\\r\\n    # loop through the image-coordinates\\r\\n    for image_x in range(image_width):\\r\\n        for image_y in range(image_height):\\r\\n\\r\\n            # determine the figure-coordinates based on the image-coordinates\\r\\n            figure_height = figure_width / image_width * image_height\\r\\n            figure_x = figure_center_x + (image_x / image_width - 0.5) * figure_width\\r\\n            figure_y = figure_center_y + (image_y / image_height - 0.5) * figure_height\\r\\n\\r\\n            distance = get_distance(figure_x, figure_y, max_step)\\r\\n\\r\\n            # color the corresponding pixel based on the selected coloring-function\\r\\n            if use_distance_color_coding:\\r\\n                pixels[image_x, image_y] = get_color_coded_rgb(distance)\\r\\n            else:\\r\\n                pixels[image_x, image_y] = get_black_and_white_rgb(distance)\\r\\n\\r\\n    return img\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\\r\\n    # colored version, full figure\\r\\n    img = get_image()\\r\\n\\r\\n    # uncomment for colored version, different section, zoomed in\\r\\n    # img = get_image(figure_center_x = -0.6, figure_center_y = -0.4,\\r\\n    # figure_width = 0.8)\\r\\n\\r\\n    # uncomment for black and white version, full figure\\r\\n    # img = get_image(use_distance_color_coding = False)\\r\\n\\r\\n    # uncomment to save the image\\r\\n    # img.save(\\\"mandelbrot.png\\\")\\r\\n\\r\\n    img.show()\\r\\n\"",
    "sierpinski triangle": "\"#!/usr/bin/python\\n\\n\\\"\\\"\\\"Author Anurag Kumar | anuragkumarak95@gmail.com | git/anuragkumarak95\\n\\nSimple example of Fractal generation using recursive function.\\n\\nWhat is Sierpinski Triangle?\\n>>The Sierpinski triangle (also with the original orthography Sierpinski), also called\\nthe Sierpinski gasket or the Sierpinski Sieve, is a fractal and attractive fixed set\\nwith the overall shape of an equilateral triangle, subdivided recursively into smaller\\nequilateral triangles. Originally constructed as a curve, this is one of the basic\\nexamples of self-similar sets, i.e., it is a mathematically generated pattern that can\\nbe reproducible at any magnification or reduction. It is named after the Polish\\nmathematician Wacław Sierpinski, but appeared as a decorative pattern many centuries\\nprior to the work of Sierpinski.\\n\\nRequirements(pip):\\n  - turtle\\n\\nPython:\\n  - 2.6\\n\\nUsage:\\n  - $python sierpinski_triangle.py <int:depth_for_fractal>\\n\\nCredits: This code was written by editing the code from\\nhttp://www.riannetrujillo.com/blog/python-fractal/\\n\\n\\\"\\\"\\\"\\nimport sys\\nimport turtle\\n\\nPROGNAME = \\\"Sierpinski Triangle\\\"\\n\\npoints = [[-175, -125], [0, 175], [175, -125]]  # size of triangle\\n\\n\\ndef getMid(p1, p2):\\n    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)  # find midpoint\\n\\n\\ndef triangle(points, depth):\\n\\n    myPen.up()\\n    myPen.goto(points[0][0], points[0][1])\\n    myPen.down()\\n    myPen.goto(points[1][0], points[1][1])\\n    myPen.goto(points[2][0], points[2][1])\\n    myPen.goto(points[0][0], points[0][1])\\n\\n    if depth > 0:\\n        triangle(\\n            [points[0], getMid(points[0], points[1]), getMid(points[0], points[2])],\\n            depth - 1,\\n        )\\n        triangle(\\n            [points[1], getMid(points[0], points[1]), getMid(points[1], points[2])],\\n            depth - 1,\\n        )\\n        triangle(\\n            [points[2], getMid(points[2], points[1]), getMid(points[0], points[2])],\\n            depth - 1,\\n        )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    if len(sys.argv) != 2:\\n        raise ValueError(\\n            \\\"right format for using this script: \\\"\\n            \\\"$python fractals.py <int:depth_for_fractal>\\\"\\n        )\\n    myPen = turtle.Turtle()\\n    myPen.ht()\\n    myPen.speed(5)\\n    myPen.pencolor(\\\"red\\\")\\n    triangle(points, int(sys.argv[1]))\\n\"",
    "fuzzy operations": "\"\\\"\\\"\\\"\\nREADME, Author - Jigyasa Gandhi(mailto:jigsgandhi97@gmail.com)\\nRequirements:\\n  - scikit-fuzzy\\n  - numpy\\n  - matplotlib\\nPython:\\n  - 3.5\\n\\\"\\\"\\\"\\nimport numpy as np\\n\\ntry:\\n    import skfuzzy as fuzz\\nexcept ImportError:\\n    fuzz = None\\n\\nif __name__ == \\\"__main__\\\":\\n    # Create universe of discourse in Python using linspace ()\\n    X = np.linspace(start=0, stop=75, num=75, endpoint=True, retstep=False)\\n\\n    # Create two fuzzy sets by defining any membership function\\n    # (trapmf(), gbellmf(), gaussmf(), etc).\\n    abc1 = [0, 25, 50]\\n    abc2 = [25, 50, 75]\\n    young = fuzz.membership.trimf(X, abc1)\\n    middle_aged = fuzz.membership.trimf(X, abc2)\\n\\n    # Compute the different operations using inbuilt functions.\\n    one = np.ones(75)\\n    zero = np.zeros((75,))\\n    # 1. Union = max(µA(x), µB(x))\\n    union = fuzz.fuzzy_or(X, young, X, middle_aged)[1]\\n    # 2. Intersection = min(µA(x), µB(x))\\n    intersection = fuzz.fuzzy_and(X, young, X, middle_aged)[1]\\n    # 3. Complement (A) = (1- min(µA(x))\\n    complement_a = fuzz.fuzzy_not(young)\\n    # 4. Difference (A/B) = min(µA(x),(1- µB(x)))\\n    difference = fuzz.fuzzy_and(X, young, X, fuzz.fuzzy_not(middle_aged)[1])[1]\\n    # 5. Algebraic Sum = [µA(x) + µB(x) – (µA(x) * µB(x))]\\n    alg_sum = young + middle_aged - (young * middle_aged)\\n    # 6. Algebraic Product = (µA(x) * µB(x))\\n    alg_product = young * middle_aged\\n    # 7. Bounded Sum = min[1,(µA(x), µB(x))]\\n    bdd_sum = fuzz.fuzzy_and(X, one, X, young + middle_aged)[1]\\n    # 8. Bounded difference = min[0,(µA(x), µB(x))]\\n    bdd_difference = fuzz.fuzzy_or(X, zero, X, young - middle_aged)[1]\\n\\n    # max-min composition\\n    # max-product composition\\n\\n    # Plot each set A, set B and each operation result using plot() and subplot().\\n    from matplotlib import pyplot as plt\\n\\n    plt.figure()\\n\\n    plt.subplot(4, 3, 1)\\n    plt.plot(X, young)\\n    plt.title(\\\"Young\\\")\\n    plt.grid(True)\\n\\n    plt.subplot(4, 3, 2)\\n    plt.plot(X, middle_aged)\\n    plt.title(\\\"Middle aged\\\")\\n    plt.grid(True)\\n\\n    plt.subplot(4, 3, 3)\\n    plt.plot(X, union)\\n    plt.title(\\\"union\\\")\\n    plt.grid(True)\\n\\n    plt.subplot(4, 3, 4)\\n    plt.plot(X, intersection)\\n    plt.title(\\\"intersection\\\")\\n    plt.grid(True)\\n\\n    plt.subplot(4, 3, 5)\\n    plt.plot(X, complement_a)\\n    plt.title(\\\"complement_a\\\")\\n    plt.grid(True)\\n\\n    plt.subplot(4, 3, 6)\\n    plt.plot(X, difference)\\n    plt.title(\\\"difference a/b\\\")\\n    plt.grid(True)\\n\\n    plt.subplot(4, 3, 7)\\n    plt.plot(X, alg_sum)\\n    plt.title(\\\"alg_sum\\\")\\n    plt.grid(True)\\n\\n    plt.subplot(4, 3, 8)\\n    plt.plot(X, alg_product)\\n    plt.title(\\\"alg_product\\\")\\n    plt.grid(True)\\n\\n    plt.subplot(4, 3, 9)\\n    plt.plot(X, bdd_sum)\\n    plt.title(\\\"bdd_sum\\\")\\n    plt.grid(True)\\n\\n    plt.subplot(4, 3, 10)\\n    plt.plot(X, bdd_difference)\\n    plt.title(\\\"bdd_difference\\\")\\n    plt.grid(True)\\n\\n    plt.subplots_adjust(hspace=0.5)\\n    plt.show()\\n\"",
    "basic string": "\"\\\"\\\"\\\"\\nSimple multithreaded algorithm to show how the 4 phases of a genetic algorithm works\\n(Evaluation, Selection, Crossover and Mutation)\\nhttps://en.wikipedia.org/wiki/Genetic_algorithm\\nAuthor: D4rkia\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\nimport random\\n\\n# Maximum size of the population.  bigger could be faster but is more memory expensive\\nN_POPULATION = 200\\n# Number of elements selected in every generation for evolution the selection takes\\n# place from the best to the worst of that generation must be smaller than N_POPULATION\\nN_SELECTED = 50\\n# Probability that an element of a generation can mutate changing one of its genes this\\n# guarantees that all genes will be used during evolution\\nMUTATION_PROBABILITY = 0.4\\n# just a seed to improve randomness required by the algorithm\\nrandom.seed(random.randint(0, 1000))\\n\\n\\ndef basic(target: str, genes: list[str], debug: bool = True) -> tuple[int, int, str]:\\n    \\\"\\\"\\\"\\n    Verify that the target contains no genes besides the ones inside genes variable.\\n\\n    >>> from string import ascii_lowercase\\n    >>> basic(\\\"doctest\\\", ascii_lowercase, debug=False)[2]\\n    'doctest'\\n    >>> genes = list(ascii_lowercase)\\n    >>> genes.remove(\\\"e\\\")\\n    >>> basic(\\\"test\\\", genes)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: ['e'] is not in genes list, evolution cannot converge\\n    >>> genes.remove(\\\"s\\\")\\n    >>> basic(\\\"test\\\", genes)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: ['e', 's'] is not in genes list, evolution cannot converge\\n    >>> genes.remove(\\\"t\\\")\\n    >>> basic(\\\"test\\\", genes)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: ['e', 's', 't'] is not in genes list, evolution cannot converge\\n    \\\"\\\"\\\"\\n\\n    # Verify if N_POPULATION is bigger than N_SELECTED\\n    if N_POPULATION < N_SELECTED:\\n        raise ValueError(f\\\"{N_POPULATION} must be bigger than {N_SELECTED}\\\")\\n    # Verify that the target contains no genes besides the ones inside genes variable.\\n    not_in_genes_list = sorted({c for c in target if c not in genes})\\n    if not_in_genes_list:\\n        raise ValueError(\\n            f\\\"{not_in_genes_list} is not in genes list, evolution cannot converge\\\"\\n        )\\n\\n    # Generate random starting population\\n    population = []\\n    for _ in range(N_POPULATION):\\n        population.append(\\\"\\\".join([random.choice(genes) for i in range(len(target))]))\\n\\n    # Just some logs to know what the algorithms is doing\\n    generation, total_population = 0, 0\\n\\n    # This loop will end when we will find a perfect match for our target\\n    while True:\\n        generation += 1\\n        total_population += len(population)\\n\\n        # Random population created now it's time to evaluate\\n        def evaluate(item: str, main_target: str = target) -> tuple[str, float]:\\n            \\\"\\\"\\\"\\n            Evaluate how similar the item is with the target by just\\n            counting each char in the right position\\n            >>> evaluate(\\\"Helxo Worlx\\\", Hello World)\\n            [\\\"Helxo Worlx\\\", 9]\\n            \\\"\\\"\\\"\\n            score = len(\\n                [g for position, g in enumerate(item) if g == main_target[position]]\\n            )\\n            return (item, float(score))\\n\\n        # Adding a bit of concurrency can make everything faster,\\n        #\\n        # import concurrent.futures\\n        # population_score: list[tuple[str, float]] = []\\n        # with concurrent.futures.ThreadPoolExecutor(\\n        #                                   max_workers=NUM_WORKERS) as executor:\\n        #     futures = {executor.submit(evaluate, item) for item in population}\\n        #     concurrent.futures.wait(futures)\\n        #     population_score = [item.result() for item in futures]\\n        #\\n        # but with a simple algorithm like this will probably be slower\\n        # we just need to call evaluate for every item inside population\\n        population_score = [evaluate(item) for item in population]\\n\\n        # Check if there is a matching evolution\\n        population_score = sorted(population_score, key=lambda x: x[1], reverse=True)\\n        if population_score[0][0] == target:\\n            return (generation, total_population, population_score[0][0])\\n\\n        # Print the Best result every 10 generation\\n        # just to know that the algorithm is working\\n        if debug and generation % 10 == 0:\\n            print(\\n                f\\\"\\\\nGeneration: {generation}\\\"\\n                f\\\"\\\\nTotal Population:{total_population}\\\"\\n                f\\\"\\\\nBest score: {population_score[0][1]}\\\"\\n                f\\\"\\\\nBest string: {population_score[0][0]}\\\"\\n            )\\n\\n        # Flush the old population keeping some of the best evolutions\\n        # Keeping this avoid regression of evolution\\n        population_best = population[: int(N_POPULATION / 3)]\\n        population.clear()\\n        population.extend(population_best)\\n        # Normalize population score from 0 to 1\\n        population_score = [\\n            (item, score / len(target)) for item, score in population_score\\n        ]\\n\\n        # Select, Crossover and Mutate a new population\\n        def select(parent_1: tuple[str, float]) -> list[str]:\\n            \\\"\\\"\\\"Select the second parent and generate new population\\\"\\\"\\\"\\n            pop = []\\n            # Generate more child proportionally to the fitness score\\n            child_n = int(parent_1[1] * 100) + 1\\n            child_n = 10 if child_n >= 10 else child_n\\n            for _ in range(child_n):\\n                parent_2 = population_score[random.randint(0, N_SELECTED)][0]\\n                child_1, child_2 = crossover(parent_1[0], parent_2)\\n                # Append new string to the population list\\n                pop.append(mutate(child_1))\\n                pop.append(mutate(child_2))\\n            return pop\\n\\n        def crossover(parent_1: str, parent_2: str) -> tuple[str, str]:\\n            \\\"\\\"\\\"Slice and combine two string in a random point\\\"\\\"\\\"\\n            random_slice = random.randint(0, len(parent_1) - 1)\\n            child_1 = parent_1[:random_slice] + parent_2[random_slice:]\\n            child_2 = parent_2[:random_slice] + parent_1[random_slice:]\\n            return (child_1, child_2)\\n\\n        def mutate(child: str) -> str:\\n            \\\"\\\"\\\"Mutate a random gene of a child with another one from the list\\\"\\\"\\\"\\n            child_list = list(child)\\n            if random.uniform(0, 1) < MUTATION_PROBABILITY:\\n                child_list[random.randint(0, len(child)) - 1] = random.choice(genes)\\n            return \\\"\\\".join(child_list)\\n\\n        # This is Selection\\n        for i in range(N_SELECTED):\\n            population.extend(select(population_score[int(i)]))\\n            # Check if the population has already reached the maximum value and if so,\\n            # break the cycle.  if this check is disabled the algorithm will take\\n            # forever to compute large strings but will also calculate small string in\\n            # a lot fewer generations\\n            if len(population) > N_POPULATION:\\n                break\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    target_str = (\\n        \\\"This is a genetic algorithm to evaluate, combine, evolve, and mutate a string!\\\"\\n    )\\n    genes_list = list(\\n        \\\" ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm\\\"\\n        \\\"nopqrstuvwxyz.,;!?+-*#@^'èéòà€ù=)(&%$£/\\\\\\\\\\\"\\n    )\\n    print(\\n        \\\"\\\\nGeneration: %s\\\\nTotal Population: %s\\\\nTarget: %s\\\"\\n        % basic(target_str, genes_list)\\n    )\\n\"",
    "haversine distance": "\"from math import asin, atan, cos, radians, sin, sqrt, tan\\n\\n\\ndef haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\\n    \\\"\\\"\\\"\\n    Calculate great circle distance between two points in a sphere,\\n    given longitudes and latitudes https://en.wikipedia.org/wiki/Haversine_formula\\n\\n    We know that the globe is \\\"sort of\\\" spherical, so a path between two points\\n    isn't exactly a straight line. We need to account for the Earth's curvature\\n    when calculating distance from point A to B. This effect is negligible for\\n    small distances but adds up as distance increases. The Haversine method treats\\n    the earth as a sphere which allows us to \\\"project\\\" the two points A and B\\n    onto the surface of that sphere and approximate the spherical distance between\\n    them. Since the Earth is not a perfect sphere, other methods which model the\\n    Earth's ellipsoidal nature are more accurate but a quick and modifiable\\n    computation like Haversine can be handy for shorter range distances.\\n\\n    Args:\\n        lat1, lon1: latitude and longitude of coordinate 1\\n        lat2, lon2: latitude and longitude of coordinate 2\\n    Returns:\\n        geographical distance between two points in metres\\n    >>> from collections import namedtuple\\n    >>> point_2d = namedtuple(\\\"point_2d\\\", \\\"lat lon\\\")\\n    >>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)\\n    >>> YOSEMITE = point_2d(37.864742, -119.537521)\\n    >>> f\\\"{haversine_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters\\\"\\n    '254,352 meters'\\n    \\\"\\\"\\\"\\n    # CONSTANTS per WGS84 https://en.wikipedia.org/wiki/World_Geodetic_System\\n    # Distance in metres(m)\\n    AXIS_A = 6378137.0\\n    AXIS_B = 6356752.314245\\n    RADIUS = 6378137\\n    # Equation parameters\\n    # Equation https://en.wikipedia.org/wiki/Haversine_formula#Formulation\\n    flattening = (AXIS_A - AXIS_B) / AXIS_A\\n    phi_1 = atan((1 - flattening) * tan(radians(lat1)))\\n    phi_2 = atan((1 - flattening) * tan(radians(lat2)))\\n    lambda_1 = radians(lon1)\\n    lambda_2 = radians(lon2)\\n    # Equation\\n    sin_sq_phi = sin((phi_2 - phi_1) / 2)\\n    sin_sq_lambda = sin((lambda_2 - lambda_1) / 2)\\n    # Square both values\\n    sin_sq_phi *= sin_sq_phi\\n    sin_sq_lambda *= sin_sq_lambda\\n    h_value = sqrt(sin_sq_phi + (cos(phi_1) * cos(phi_2) * sin_sq_lambda))\\n    return 2 * RADIUS * asin(h_value)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "lamberts ellipsoidal distance": "\"from math import atan, cos, radians, sin, tan\\n\\nfrom .haversine_distance import haversine_distance\\n\\n\\ndef lamberts_ellipsoidal_distance(\\n    lat1: float, lon1: float, lat2: float, lon2: float\\n) -> float:\\n\\n    \\\"\\\"\\\"\\n    Calculate the shortest distance along the surface of an ellipsoid between\\n    two points on the surface of earth given longitudes and latitudes\\n    https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines\\n\\n    NOTE: This algorithm uses geodesy/haversine_distance.py to compute central angle,\\n        sigma\\n\\n    Representing the earth as an ellipsoid allows us to approximate distances between\\n    points on the surface much better than a sphere. Ellipsoidal formulas treat the\\n    Earth as an oblate ellipsoid which means accounting for the flattening that happens\\n    at the North and South poles. Lambert's formulae provide accuracy on the order of\\n    10 meteres over thousands of kilometeres. Other methods can provide\\n    millimeter-level accuracy but this is a simpler method to calculate long range\\n    distances without increasing computational intensity.\\n\\n    Args:\\n        lat1, lon1: latitude and longitude of coordinate 1\\n        lat2, lon2: latitude and longitude of coordinate 2\\n    Returns:\\n        geographical distance between two points in metres\\n\\n    >>> from collections import namedtuple\\n    >>> point_2d = namedtuple(\\\"point_2d\\\", \\\"lat lon\\\")\\n    >>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)\\n    >>> YOSEMITE = point_2d(37.864742, -119.537521)\\n    >>> NEW_YORK = point_2d(40.713019, -74.012647)\\n    >>> VENICE = point_2d(45.443012, 12.313071)\\n    >>> f\\\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters\\\"\\n    '254,351 meters'\\n    >>> f\\\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *NEW_YORK):0,.0f} meters\\\"\\n    '4,138,992 meters'\\n    >>> f\\\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *VENICE):0,.0f} meters\\\"\\n    '9,737,326 meters'\\n    \\\"\\\"\\\"\\n\\n    # CONSTANTS per WGS84 https://en.wikipedia.org/wiki/World_Geodetic_System\\n    # Distance in metres(m)\\n    AXIS_A = 6378137.0\\n    AXIS_B = 6356752.314245\\n    EQUATORIAL_RADIUS = 6378137\\n\\n    # Equation Parameters\\n    # https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines\\n    flattening = (AXIS_A - AXIS_B) / AXIS_A\\n    # Parametric latitudes\\n    # https://en.wikipedia.org/wiki/Latitude#Parametric_(or_reduced)_latitude\\n    b_lat1 = atan((1 - flattening) * tan(radians(lat1)))\\n    b_lat2 = atan((1 - flattening) * tan(radians(lat2)))\\n\\n    # Compute central angle between two points\\n    # using haversine theta. sigma =  haversine_distance / equatorial radius\\n    sigma = haversine_distance(lat1, lon1, lat2, lon2) / EQUATORIAL_RADIUS\\n\\n    # Intermediate P and Q values\\n    P_value = (b_lat1 + b_lat2) / 2\\n    Q_value = (b_lat2 - b_lat1) / 2\\n\\n    # Intermediate X value\\n    # X = (sigma - sin(sigma)) * sin^2Pcos^2Q / cos^2(sigma/2)\\n    X_numerator = (sin(P_value) ** 2) * (cos(Q_value) ** 2)\\n    X_demonimator = cos(sigma / 2) ** 2\\n    X_value = (sigma - sin(sigma)) * (X_numerator / X_demonimator)\\n\\n    # Intermediate Y value\\n    # Y = (sigma + sin(sigma)) * cos^2Psin^2Q / sin^2(sigma/2)\\n    Y_numerator = (cos(P_value) ** 2) * (sin(Q_value) ** 2)\\n    Y_denominator = sin(sigma / 2) ** 2\\n    Y_value = (sigma + sin(sigma)) * (Y_numerator / Y_denominator)\\n\\n    return EQUATORIAL_RADIUS * (sigma - ((flattening / 2) * (X_value + Y_value)))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "bezier curve": "\"# https://en.wikipedia.org/wiki/B%C3%A9zier_curve\\n# https://www.tutorialspoint.com/computer_graphics/computer_graphics_curves.htm\\nfrom __future__ import annotations\\n\\nfrom scipy.special import comb  # type: ignore\\n\\n\\nclass BezierCurve:\\n    \\\"\\\"\\\"\\n    Bezier curve is a weighted sum of a set of control points.\\n    Generate Bezier curves from a given set of control points.\\n    This implementation works only for 2d coordinates in the xy plane.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, list_of_points: list[tuple[float, float]]):\\n        \\\"\\\"\\\"\\n        list_of_points: Control points in the xy plane on which to interpolate. These\\n            points control the behavior (shape) of the Bezier curve.\\n        \\\"\\\"\\\"\\n        self.list_of_points = list_of_points\\n        # Degree determines the flexibility of the curve.\\n        # Degree = 1 will produce a straight line.\\n        self.degree = len(list_of_points) - 1\\n\\n    def basis_function(self, t: float) -> list[float]:\\n        \\\"\\\"\\\"\\n        The basis function determines the weight of each control point at time t.\\n            t: time value between 0 and 1 inclusive at which to evaluate the basis of\\n               the curve.\\n        returns the x, y values of basis function at time t\\n\\n        >>> curve = BezierCurve([(1,1), (1,2)])\\n        >>> curve.basis_function(0)\\n        [1.0, 0.0]\\n        >>> curve.basis_function(1)\\n        [0.0, 1.0]\\n        \\\"\\\"\\\"\\n        assert 0 <= t <= 1, \\\"Time t must be between 0 and 1.\\\"\\n        output_values: list[float] = []\\n        for i in range(len(self.list_of_points)):\\n            # basis function for each i\\n            output_values.append(\\n                comb(self.degree, i) * ((1 - t) ** (self.degree - i)) * (t ** i)\\n            )\\n        # the basis must sum up to 1 for it to produce a valid Bezier curve.\\n        assert round(sum(output_values), 5) == 1\\n        return output_values\\n\\n    def bezier_curve_function(self, t: float) -> tuple[float, float]:\\n        \\\"\\\"\\\"\\n        The function to produce the values of the Bezier curve at time t.\\n            t: the value of time t at which to evaluate the Bezier function\\n        Returns the x, y coordinates of the Bezier curve at time t.\\n            The first point in the curve is when t = 0.\\n            The last point in the curve is when t = 1.\\n\\n        >>> curve = BezierCurve([(1,1), (1,2)])\\n        >>> curve.bezier_curve_function(0)\\n        (1.0, 1.0)\\n        >>> curve.bezier_curve_function(1)\\n        (1.0, 2.0)\\n        \\\"\\\"\\\"\\n\\n        assert 0 <= t <= 1, \\\"Time t must be between 0 and 1.\\\"\\n\\n        basis_function = self.basis_function(t)\\n        x = 0.0\\n        y = 0.0\\n        for i in range(len(self.list_of_points)):\\n            # For all points, sum up the product of i-th basis function and i-th point.\\n            x += basis_function[i] * self.list_of_points[i][0]\\n            y += basis_function[i] * self.list_of_points[i][1]\\n        return (x, y)\\n\\n    def plot_curve(self, step_size: float = 0.01):\\n        \\\"\\\"\\\"\\n        Plots the Bezier curve using matplotlib plotting capabilities.\\n            step_size: defines the step(s) at which to evaluate the Bezier curve.\\n            The smaller the step size, the finer the curve produced.\\n        \\\"\\\"\\\"\\n        from matplotlib import pyplot as plt  # type: ignore\\n\\n        to_plot_x: list[float] = []  # x coordinates of points to plot\\n        to_plot_y: list[float] = []  # y coordinates of points to plot\\n\\n        t = 0.0\\n        while t <= 1:\\n            value = self.bezier_curve_function(t)\\n            to_plot_x.append(value[0])\\n            to_plot_y.append(value[1])\\n            t += step_size\\n\\n        x = [i[0] for i in self.list_of_points]\\n        y = [i[1] for i in self.list_of_points]\\n\\n        plt.plot(\\n            to_plot_x,\\n            to_plot_y,\\n            color=\\\"blue\\\",\\n            label=\\\"Curve of Degree \\\" + str(self.degree),\\n        )\\n        plt.scatter(x, y, color=\\\"red\\\", label=\\\"Control Points\\\")\\n        plt.legend()\\n        plt.show()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    BezierCurve([(1, 2), (3, 5)]).plot_curve()  # degree 1\\n    BezierCurve([(0, 0), (5, 5), (5, 0)]).plot_curve()  # degree 2\\n    BezierCurve([(0, 0), (5, 5), (5, 0), (2.5, -2.5)]).plot_curve()  # degree 3\\n\"",
    "vector3 for 2d rendering": "\"\\\"\\\"\\\"\\nrender 3d points for 2d surfaces.\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\nimport math\\n\\n__version__ = \\\"2020.9.26\\\"\\n__author__ = \\\"xcodz-dot, cclaus, dhruvmanila\\\"\\n\\n\\ndef convert_to_2d(\\n    x: float, y: float, z: float, scale: float, distance: float\\n) -> tuple[float, float]:\\n    \\\"\\\"\\\"\\n    Converts 3d point to a 2d drawable point\\n\\n    >>> convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0)\\n    (7.6923076923076925, 15.384615384615385)\\n\\n    >>> convert_to_2d(1, 2, 3, 10, 10)\\n    (7.6923076923076925, 15.384615384615385)\\n\\n    >>> convert_to_2d(\\\"1\\\", 2, 3, 10, 10)  # '1' is str\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: Input values must either be float or int: ['1', 2, 3, 10, 10]\\n    \\\"\\\"\\\"\\n    if not all(isinstance(val, (float, int)) for val in locals().values()):\\n        raise TypeError(\\n            \\\"Input values must either be float or int: \\\" f\\\"{list(locals().values())}\\\"\\n        )\\n    projected_x = ((x * distance) / (z + distance)) * scale\\n    projected_y = ((y * distance) / (z + distance)) * scale\\n    return projected_x, projected_y\\n\\n\\ndef rotate(\\n    x: float, y: float, z: float, axis: str, angle: float\\n) -> tuple[float, float, float]:\\n    \\\"\\\"\\\"\\n    rotate a point around a certain axis with a certain angle\\n    angle can be any integer between 1, 360 and axis can be any one of\\n    'x', 'y', 'z'\\n\\n    >>> rotate(1.0, 2.0, 3.0, 'y', 90.0)\\n    (3.130524675073759, 2.0, 0.4470070007889556)\\n\\n    >>> rotate(1, 2, 3, \\\"z\\\", 180)\\n    (0.999736015495891, -2.0001319704760485, 3)\\n\\n    >>> rotate('1', 2, 3, \\\"z\\\", 90.0)  # '1' is str\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: Input values except axis must either be float or int: ['1', 2, 3, 90.0]\\n\\n    >>> rotate(1, 2, 3, \\\"n\\\", 90)  # 'n' is not a valid axis\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: not a valid axis, choose one of 'x', 'y', 'z'\\n\\n    >>> rotate(1, 2, 3, \\\"x\\\", -90)\\n    (1, -2.5049096187183877, -2.5933429780983657)\\n\\n    >>> rotate(1, 2, 3, \\\"x\\\", 450)  # 450 wrap around to 90\\n    (1, 3.5776792428178217, -0.44744970165427644)\\n    \\\"\\\"\\\"\\n    if not isinstance(axis, str):\\n        raise TypeError(\\\"Axis must be a str\\\")\\n    input_variables = locals()\\n    del input_variables[\\\"axis\\\"]\\n    if not all(isinstance(val, (float, int)) for val in input_variables.values()):\\n        raise TypeError(\\n            \\\"Input values except axis must either be float or int: \\\"\\n            f\\\"{list(input_variables.values())}\\\"\\n        )\\n    angle = (angle % 360) / 450 * 180 / math.pi\\n    if axis == \\\"z\\\":\\n        new_x = x * math.cos(angle) - y * math.sin(angle)\\n        new_y = y * math.cos(angle) + x * math.sin(angle)\\n        new_z = z\\n    elif axis == \\\"x\\\":\\n        new_y = y * math.cos(angle) - z * math.sin(angle)\\n        new_z = z * math.cos(angle) + y * math.sin(angle)\\n        new_x = x\\n    elif axis == \\\"y\\\":\\n        new_x = x * math.cos(angle) - z * math.sin(angle)\\n        new_z = z * math.cos(angle) + x * math.sin(angle)\\n        new_y = y\\n    else:\\n        raise ValueError(\\\"not a valid axis, choose one of 'x', 'y', 'z'\\\")\\n\\n    return new_x, new_y, new_z\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    print(f\\\"{convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0) = }\\\")\\n    print(f\\\"{rotate(1.0, 2.0, 3.0, 'y', 90.0) = }\\\")\\n\"",
    "articulation points": "\"# Finding Articulation Points in Undirected Graph\\ndef computeAP(l):  # noqa: E741\\n    n = len(l)\\n    outEdgeCount = 0\\n    low = [0] * n\\n    visited = [False] * n\\n    isArt = [False] * n\\n\\n    def dfs(root, at, parent, outEdgeCount):\\n        if parent == root:\\n            outEdgeCount += 1\\n        visited[at] = True\\n        low[at] = at\\n\\n        for to in l[at]:\\n            if to == parent:\\n                pass\\n            elif not visited[to]:\\n                outEdgeCount = dfs(root, to, at, outEdgeCount)\\n                low[at] = min(low[at], low[to])\\n\\n                # AP found via bridge\\n                if at < low[to]:\\n                    isArt[at] = True\\n                # AP found via cycle\\n                if at == low[to]:\\n                    isArt[at] = True\\n            else:\\n                low[at] = min(low[at], to)\\n        return outEdgeCount\\n\\n    for i in range(n):\\n        if not visited[i]:\\n            outEdgeCount = 0\\n            outEdgeCount = dfs(i, i, -1, outEdgeCount)\\n            isArt[i] = outEdgeCount > 1\\n\\n    for x in range(len(isArt)):\\n        if isArt[x] is True:\\n            print(x)\\n\\n\\n# Adjacency list of graph\\ndata = {\\n    0: [1, 2],\\n    1: [0, 2],\\n    2: [0, 1, 3, 5],\\n    3: [2, 4],\\n    4: [3],\\n    5: [2, 6, 8],\\n    6: [5, 7],\\n    7: [6, 8],\\n    8: [5, 7],\\n}\\ncomputeAP(data)\\n\"",
    "a star": "\"from __future__ import annotations\\n\\nDIRECTIONS = [\\n    [-1, 0],  # left\\n    [0, -1],  # down\\n    [1, 0],  # right\\n    [0, 1],  # up\\n]\\n\\n\\n# function to search the path\\ndef search(\\n    grid: list[list[int]],\\n    init: list[int],\\n    goal: list[int],\\n    cost: int,\\n    heuristic: list[list[int]],\\n) -> tuple[list[list[int]], list[list[int]]]:\\n\\n    closed = [\\n        [0 for col in range(len(grid[0]))] for row in range(len(grid))\\n    ]  # the reference grid\\n    closed[init[0]][init[1]] = 1\\n    action = [\\n        [0 for col in range(len(grid[0]))] for row in range(len(grid))\\n    ]  # the action grid\\n\\n    x = init[0]\\n    y = init[1]\\n    g = 0\\n    f = g + heuristic[x][y]  # cost from starting cell to destination cell\\n    cell = [[f, g, x, y]]\\n\\n    found = False  # flag that is set when search is complete\\n    resign = False  # flag set if we can't find expand\\n\\n    while not found and not resign:\\n        if len(cell) == 0:\\n            raise ValueError(\\\"Algorithm is unable to find solution\\\")\\n        else:  # to choose the least costliest action so as to move closer to the goal\\n            cell.sort()\\n            cell.reverse()\\n            next = cell.pop()\\n            x = next[2]\\n            y = next[3]\\n            g = next[1]\\n\\n            if x == goal[0] and y == goal[1]:\\n                found = True\\n            else:\\n                for i in range(len(DIRECTIONS)):  # to try out different valid actions\\n                    x2 = x + DIRECTIONS[i][0]\\n                    y2 = y + DIRECTIONS[i][1]\\n                    if x2 >= 0 and x2 < len(grid) and y2 >= 0 and y2 < len(grid[0]):\\n                        if closed[x2][y2] == 0 and grid[x2][y2] == 0:\\n                            g2 = g + cost\\n                            f2 = g2 + heuristic[x2][y2]\\n                            cell.append([f2, g2, x2, y2])\\n                            closed[x2][y2] = 1\\n                            action[x2][y2] = i\\n    invpath = []\\n    x = goal[0]\\n    y = goal[1]\\n    invpath.append([x, y])  # we get the reverse path from here\\n    while x != init[0] or y != init[1]:\\n        x2 = x - DIRECTIONS[action[x][y]][0]\\n        y2 = y - DIRECTIONS[action[x][y]][1]\\n        x = x2\\n        y = y2\\n        invpath.append([x, y])\\n\\n    path = []\\n    for i in range(len(invpath)):\\n        path.append(invpath[len(invpath) - 1 - i])\\n    return path, action\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    grid = [\\n        [0, 1, 0, 0, 0, 0],\\n        [0, 1, 0, 0, 0, 0],  # 0 are free path whereas 1's are obstacles\\n        [0, 1, 0, 0, 0, 0],\\n        [0, 1, 0, 0, 1, 0],\\n        [0, 0, 0, 0, 1, 0],\\n    ]\\n\\n    init = [0, 0]\\n    # all coordinates are given in format [y,x]\\n    goal = [len(grid) - 1, len(grid[0]) - 1]\\n    cost = 1\\n\\n    # the cost map which pushes the path closer to the goal\\n    heuristic = [[0 for row in range(len(grid[0]))] for col in range(len(grid))]\\n    for i in range(len(grid)):\\n        for j in range(len(grid[0])):\\n            heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1])\\n            if grid[i][j] == 1:\\n                # added extra penalty in the heuristic map\\n                heuristic[i][j] = 99\\n\\n    path, action = search(grid, init, goal, cost, heuristic)\\n\\n    print(\\\"ACTION MAP\\\")\\n    for i in range(len(action)):\\n        print(action[i])\\n\\n    for i in range(len(path)):\\n        print(path[i])\\n\"",
    "basic graphs": "\"from collections import deque\\n\\n\\ndef _input(message):\\n    return input(message).strip().split(\\\" \\\")\\n\\n\\ndef initialize_unweighted_directed_graph(\\n    node_count: int, edge_count: int\\n) -> dict[int, list[int]]:\\n    graph: dict[int, list[int]] = {}\\n    for i in range(node_count):\\n        graph[i + 1] = []\\n\\n    for e in range(edge_count):\\n        x, y = (int(i) for i in _input(f\\\"Edge {e + 1}: <node1> <node2> \\\"))\\n        graph[x].append(y)\\n    return graph\\n\\n\\ndef initialize_unweighted_undirected_graph(\\n    node_count: int, edge_count: int\\n) -> dict[int, list[int]]:\\n    graph: dict[int, list[int]] = {}\\n    for i in range(node_count):\\n        graph[i + 1] = []\\n\\n    for e in range(edge_count):\\n        x, y = (int(i) for i in _input(f\\\"Edge {e + 1}: <node1> <node2> \\\"))\\n        graph[x].append(y)\\n        graph[y].append(x)\\n    return graph\\n\\n\\ndef initialize_weighted_undirected_graph(\\n    node_count: int, edge_count: int\\n) -> dict[int, list[tuple[int, int]]]:\\n    graph: dict[int, list[tuple[int, int]]] = {}\\n    for i in range(node_count):\\n        graph[i + 1] = []\\n\\n    for e in range(edge_count):\\n        x, y, w = (int(i) for i in _input(f\\\"Edge {e + 1}: <node1> <node2> <weight> \\\"))\\n        graph[x].append((y, w))\\n        graph[y].append((x, w))\\n    return graph\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    n, m = (int(i) for i in _input(\\\"Number of nodes and edges: \\\"))\\n\\n    graph_choice = int(\\n        _input(\\n            \\\"Press 1 or 2 or 3 \\\\n\\\"\\n            \\\"1. Unweighted directed \\\\n\\\"\\n            \\\"2. Unweighted undirected \\\\n\\\"\\n            \\\"3. Weighted undirected \\\\n\\\"\\n        )[0]\\n    )\\n\\n    g = {\\n        1: initialize_unweighted_directed_graph,\\n        2: initialize_unweighted_undirected_graph,\\n        3: initialize_weighted_undirected_graph,\\n    }[graph_choice](n, m)\\n\\n\\n\\\"\\\"\\\"\\n--------------------------------------------------------------------------------\\n    Depth First Search.\\n        Args :  G - Dictionary of edges\\n                s - Starting Node\\n        Vars :  vis - Set of visited nodes\\n                S - Traversal Stack\\n--------------------------------------------------------------------------------\\n\\\"\\\"\\\"\\n\\n\\ndef dfs(G, s):\\n    vis, S = {s}, [s]\\n    print(s)\\n    while S:\\n        flag = 0\\n        for i in G[S[-1]]:\\n            if i not in vis:\\n                S.append(i)\\n                vis.add(i)\\n                flag = 1\\n                print(i)\\n                break\\n        if not flag:\\n            S.pop()\\n\\n\\n\\\"\\\"\\\"\\n--------------------------------------------------------------------------------\\n    Breadth First Search.\\n        Args :  G - Dictionary of edges\\n                s - Starting Node\\n        Vars :  vis - Set of visited nodes\\n                Q - Traversal Stack\\n--------------------------------------------------------------------------------\\n\\\"\\\"\\\"\\n\\n\\ndef bfs(G, s):\\n    vis, Q = {s}, deque([s])\\n    print(s)\\n    while Q:\\n        u = Q.popleft()\\n        for v in G[u]:\\n            if v not in vis:\\n                vis.add(v)\\n                Q.append(v)\\n                print(v)\\n\\n\\n\\\"\\\"\\\"\\n--------------------------------------------------------------------------------\\n    Dijkstra's shortest path Algorithm\\n        Args :  G - Dictionary of edges\\n                s - Starting Node\\n        Vars :  dist - Dictionary storing shortest distance from s to every other node\\n                known - Set of knows nodes\\n                path - Preceding node in path\\n--------------------------------------------------------------------------------\\n\\\"\\\"\\\"\\n\\n\\ndef dijk(G, s):\\n    dist, known, path = {s: 0}, set(), {s: 0}\\n    while True:\\n        if len(known) == len(G) - 1:\\n            break\\n        mini = 100000\\n        for i in dist:\\n            if i not in known and dist[i] < mini:\\n                mini = dist[i]\\n                u = i\\n        known.add(u)\\n        for v in G[u]:\\n            if v[0] not in known:\\n                if dist[u] + v[1] < dist.get(v[0], 100000):\\n                    dist[v[0]] = dist[u] + v[1]\\n                    path[v[0]] = u\\n    for i in dist:\\n        if i != s:\\n            print(dist[i])\\n\\n\\n\\\"\\\"\\\"\\n--------------------------------------------------------------------------------\\n    Topological Sort\\n--------------------------------------------------------------------------------\\n\\\"\\\"\\\"\\n\\n\\ndef topo(G, ind=None, Q=None):\\n    if Q is None:\\n        Q = [1]\\n    if ind is None:\\n        ind = [0] * (len(G) + 1)  # SInce oth Index is ignored\\n        for u in G:\\n            for v in G[u]:\\n                ind[v] += 1\\n        Q = deque()\\n        for i in G:\\n            if ind[i] == 0:\\n                Q.append(i)\\n    if len(Q) == 0:\\n        return\\n    v = Q.popleft()\\n    print(v)\\n    for w in G[v]:\\n        ind[w] -= 1\\n        if ind[w] == 0:\\n            Q.append(w)\\n    topo(G, ind, Q)\\n\\n\\n\\\"\\\"\\\"\\n--------------------------------------------------------------------------------\\n    Reading an Adjacency matrix\\n--------------------------------------------------------------------------------\\n\\\"\\\"\\\"\\n\\n\\ndef adjm():\\n    n = input().strip()\\n    a = []\\n    for i in range(n):\\n        a.append(map(int, input().strip().split()))\\n    return a, n\\n\\n\\n\\\"\\\"\\\"\\n--------------------------------------------------------------------------------\\n    Floyd Warshall's algorithm\\n        Args :  G - Dictionary of edges\\n                s - Starting Node\\n        Vars :  dist - Dictionary storing shortest distance from s to every other node\\n                known - Set of knows nodes\\n                path - Preceding node in path\\n\\n--------------------------------------------------------------------------------\\n\\\"\\\"\\\"\\n\\n\\ndef floy(A_and_n):\\n    (A, n) = A_and_n\\n    dist = list(A)\\n    path = [[0] * n for i in range(n)]\\n    for k in range(n):\\n        for i in range(n):\\n            for j in range(n):\\n                if dist[i][j] > dist[i][k] + dist[k][j]:\\n                    dist[i][j] = dist[i][k] + dist[k][j]\\n                    path[i][k] = k\\n    print(dist)\\n\\n\\n\\\"\\\"\\\"\\n--------------------------------------------------------------------------------\\n    Prim's MST Algorithm\\n        Args :  G - Dictionary of edges\\n                s - Starting Node\\n        Vars :  dist - Dictionary storing shortest distance from s to nearest node\\n                known - Set of knows nodes\\n                path - Preceding node in path\\n--------------------------------------------------------------------------------\\n\\\"\\\"\\\"\\n\\n\\ndef prim(G, s):\\n    dist, known, path = {s: 0}, set(), {s: 0}\\n    while True:\\n        if len(known) == len(G) - 1:\\n            break\\n        mini = 100000\\n        for i in dist:\\n            if i not in known and dist[i] < mini:\\n                mini = dist[i]\\n                u = i\\n        known.add(u)\\n        for v in G[u]:\\n            if v[0] not in known:\\n                if v[1] < dist.get(v[0], 100000):\\n                    dist[v[0]] = v[1]\\n                    path[v[0]] = u\\n    return dist\\n\\n\\n\\\"\\\"\\\"\\n--------------------------------------------------------------------------------\\n    Accepting Edge list\\n        Vars :  n - Number of nodes\\n                m - Number of edges\\n        Returns : l - Edge list\\n                n - Number of Nodes\\n--------------------------------------------------------------------------------\\n\\\"\\\"\\\"\\n\\n\\ndef edglist():\\n    n, m = map(int, input().split(\\\" \\\"))\\n    edges = []\\n    for i in range(m):\\n        edges.append(map(int, input().split(\\\" \\\")))\\n    return edges, n\\n\\n\\n\\\"\\\"\\\"\\n--------------------------------------------------------------------------------\\n    Kruskal's MST Algorithm\\n        Args :  E - Edge list\\n                n - Number of Nodes\\n        Vars :  s - Set of all nodes as unique disjoint sets (initially)\\n--------------------------------------------------------------------------------\\n\\\"\\\"\\\"\\n\\n\\ndef krusk(E_and_n):\\n    # Sort edges on the basis of distance\\n    (E, n) = E_and_n\\n    E.sort(reverse=True, key=lambda x: x[2])\\n    s = [{i} for i in range(1, n + 1)]\\n    while True:\\n        if len(s) == 1:\\n            break\\n        print(s)\\n        x = E.pop()\\n        for i in range(len(s)):\\n            if x[0] in s[i]:\\n                break\\n        for j in range(len(s)):\\n            if x[1] in s[j]:\\n                if i == j:\\n                    break\\n                s[j].update(s[i])\\n                s.pop(i)\\n                break\\n\\n\\n# find the isolated node in the graph\\ndef find_isolated_nodes(graph):\\n    isolated = []\\n    for node in graph:\\n        if not graph[node]:\\n            isolated.append(node)\\n    return isolated\\n\"",
    "bellman ford": "\"from __future__ import annotations\\n\\n\\ndef print_distance(distance: list[float], src):\\n    print(f\\\"Vertex\\\\tShortest Distance from vertex {src}\\\")\\n    for i, d in enumerate(distance):\\n        print(f\\\"{i}\\\\t\\\\t{d}\\\")\\n\\n\\ndef check_negative_cycle(\\n    graph: list[dict[str, int]], distance: list[float], edge_count: int\\n):\\n    for j in range(edge_count):\\n        u, v, w = (graph[j][k] for k in [\\\"src\\\", \\\"dst\\\", \\\"weight\\\"])\\n        if distance[u] != float(\\\"inf\\\") and distance[u] + w < distance[v]:\\n            return True\\n    return False\\n\\n\\ndef bellman_ford(\\n    graph: list[dict[str, int]], vertex_count: int, edge_count: int, src: int\\n) -> list[float]:\\n    \\\"\\\"\\\"\\n    Returns shortest paths from a vertex src to all\\n    other vertices.\\n    >>> edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]\\n    >>> g = [{\\\"src\\\": s, \\\"dst\\\": d, \\\"weight\\\": w} for s, d, w in edges]\\n    >>> bellman_ford(g, 4, 4, 0)\\n    [0.0, -2.0, 8.0, 5.0]\\n    >>> g = [{\\\"src\\\": s, \\\"dst\\\": d, \\\"weight\\\": w} for s, d, w in edges + [(1, 3, 5)]]\\n    >>> bellman_ford(g, 4, 5, 0)\\n    Traceback (most recent call last):\\n     ...\\n    Exception: Negative cycle found\\n    \\\"\\\"\\\"\\n    distance = [float(\\\"inf\\\")] * vertex_count\\n    distance[src] = 0.0\\n\\n    for i in range(vertex_count - 1):\\n        for j in range(edge_count):\\n            u, v, w = (graph[j][k] for k in [\\\"src\\\", \\\"dst\\\", \\\"weight\\\"])\\n\\n            if distance[u] != float(\\\"inf\\\") and distance[u] + w < distance[v]:\\n                distance[v] = distance[u] + w\\n\\n    negative_cycle_exists = check_negative_cycle(graph, distance, edge_count)\\n    if negative_cycle_exists:\\n        raise Exception(\\\"Negative cycle found\\\")\\n\\n    return distance\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    V = int(input(\\\"Enter number of vertices: \\\").strip())\\n    E = int(input(\\\"Enter number of edges: \\\").strip())\\n\\n    graph: list[dict[str, int]] = [dict() for j in range(E)]\\n\\n    for i in range(E):\\n        print(\\\"Edge \\\", i + 1)\\n        src, dest, weight = (\\n            int(x)\\n            for x in input(\\\"Enter source, destination, weight: \\\").strip().split(\\\" \\\")\\n        )\\n        graph[i] = {\\\"src\\\": src, \\\"dst\\\": dest, \\\"weight\\\": weight}\\n\\n    source = int(input(\\\"\\\\nEnter shortest path source:\\\").strip())\\n    shortest_distance = bellman_ford(graph, V, E, source)\\n    print_distance(shortest_distance, 0)\\n\"",
    "bfs shortest path": "\"\\\"\\\"\\\"Breadth-first search shortest path implementations.\\n    doctest:\\n    python -m doctest -v bfs_shortest_path.py\\n    Manual test:\\n    python bfs_shortest_path.py\\n\\\"\\\"\\\"\\ndemo_graph = {\\n    \\\"A\\\": [\\\"B\\\", \\\"C\\\", \\\"E\\\"],\\n    \\\"B\\\": [\\\"A\\\", \\\"D\\\", \\\"E\\\"],\\n    \\\"C\\\": [\\\"A\\\", \\\"F\\\", \\\"G\\\"],\\n    \\\"D\\\": [\\\"B\\\"],\\n    \\\"E\\\": [\\\"A\\\", \\\"B\\\", \\\"D\\\"],\\n    \\\"F\\\": [\\\"C\\\"],\\n    \\\"G\\\": [\\\"C\\\"],\\n}\\n\\n\\ndef bfs_shortest_path(graph: dict, start, goal) -> list[str]:\\n    \\\"\\\"\\\"Find shortest path between `start` and `goal` nodes.\\n    Args:\\n        graph (dict): node/list of neighboring nodes key/value pairs.\\n        start: start node.\\n        goal: target node.\\n    Returns:\\n        Shortest path between `start` and `goal` nodes as a string of nodes.\\n        'Not found' string if no path found.\\n    Example:\\n        >>> bfs_shortest_path(demo_graph, \\\"G\\\", \\\"D\\\")\\n        ['G', 'C', 'A', 'B', 'D']\\n        >>> bfs_shortest_path(demo_graph, \\\"G\\\", \\\"G\\\")\\n        ['G']\\n        >>> bfs_shortest_path(demo_graph, \\\"G\\\", \\\"Unknown\\\")\\n        []\\n    \\\"\\\"\\\"\\n    # keep track of explored nodes\\n    explored = set()\\n    # keep track of all the paths to be checked\\n    queue = [[start]]\\n\\n    # return path if start is goal\\n    if start == goal:\\n        return [start]\\n\\n    # keeps looping until all possible paths have been checked\\n    while queue:\\n        # pop the first path from the queue\\n        path = queue.pop(0)\\n        # get the last node from the path\\n        node = path[-1]\\n        if node not in explored:\\n            neighbours = graph[node]\\n            # go through all neighbour nodes, construct a new path and\\n            # push it into the queue\\n            for neighbour in neighbours:\\n                new_path = list(path)\\n                new_path.append(neighbour)\\n                queue.append(new_path)\\n                # return path if neighbour is goal\\n                if neighbour == goal:\\n                    return new_path\\n\\n            # mark node as explored\\n            explored.add(node)\\n\\n    # in case there's no path between the 2 nodes\\n    return []\\n\\n\\ndef bfs_shortest_path_distance(graph: dict, start, target) -> int:\\n    \\\"\\\"\\\"Find shortest path distance between `start` and `target` nodes.\\n    Args:\\n        graph: node/list of neighboring nodes key/value pairs.\\n        start: node to start search from.\\n        target: node to search for.\\n    Returns:\\n        Number of edges in shortest path between `start` and `target` nodes.\\n        -1 if no path exists.\\n    Example:\\n        >>> bfs_shortest_path_distance(demo_graph, \\\"G\\\", \\\"D\\\")\\n        4\\n        >>> bfs_shortest_path_distance(demo_graph, \\\"A\\\", \\\"A\\\")\\n        0\\n        >>> bfs_shortest_path_distance(demo_graph, \\\"A\\\", \\\"Unknown\\\")\\n        -1\\n    \\\"\\\"\\\"\\n    if not graph or start not in graph or target not in graph:\\n        return -1\\n    if start == target:\\n        return 0\\n    queue = [start]\\n    visited = set(start)\\n    # Keep tab on distances from `start` node.\\n    dist = {start: 0, target: -1}\\n    while queue:\\n        node = queue.pop(0)\\n        if node == target:\\n            dist[target] = (\\n                dist[node] if dist[target] == -1 else min(dist[target], dist[node])\\n            )\\n        for adjacent in graph[node]:\\n            if adjacent not in visited:\\n                visited.add(adjacent)\\n                queue.append(adjacent)\\n                dist[adjacent] = dist[node] + 1\\n    return dist[target]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(bfs_shortest_path(demo_graph, \\\"G\\\", \\\"D\\\"))  # returns ['G', 'C', 'A', 'B', 'D']\\n    print(bfs_shortest_path_distance(demo_graph, \\\"G\\\", \\\"D\\\"))  # returns 4\\n\"",
    "bfs zero one shortest path": "\"\\\"\\\"\\\"\\nFinding the shortest path in 0-1-graph in O(E + V) which is faster than dijkstra.\\n0-1-graph is the weighted graph with the weights equal to 0 or 1.\\nLink: https://codeforces.com/blog/entry/22276\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom collections import deque\\nfrom collections.abc import Iterator\\nfrom dataclasses import dataclass\\n\\n\\n@dataclass\\nclass Edge:\\n    \\\"\\\"\\\"Weighted directed graph edge.\\\"\\\"\\\"\\n\\n    destination_vertex: int\\n    weight: int\\n\\n\\nclass AdjacencyList:\\n    \\\"\\\"\\\"Graph adjacency list.\\\"\\\"\\\"\\n\\n    def __init__(self, size: int):\\n        self._graph: list[list[Edge]] = [[] for _ in range(size)]\\n        self._size = size\\n\\n    def __getitem__(self, vertex: int) -> Iterator[Edge]:\\n        \\\"\\\"\\\"Get all the vertices adjacent to the given one.\\\"\\\"\\\"\\n        return iter(self._graph[vertex])\\n\\n    @property\\n    def size(self):\\n        return self._size\\n\\n    def add_edge(self, from_vertex: int, to_vertex: int, weight: int):\\n        \\\"\\\"\\\"\\n        >>> g = AdjacencyList(2)\\n        >>> g.add_edge(0, 1, 0)\\n        >>> g.add_edge(1, 0, 1)\\n        >>> list(g[0])\\n        [Edge(destination_vertex=1, weight=0)]\\n        >>> list(g[1])\\n        [Edge(destination_vertex=0, weight=1)]\\n        >>> g.add_edge(0, 1, 2)\\n        Traceback (most recent call last):\\n            ...\\n        ValueError: Edge weight must be either 0 or 1.\\n        >>> g.add_edge(0, 2, 1)\\n        Traceback (most recent call last):\\n            ...\\n        ValueError: Vertex indexes must be in [0; size).\\n        \\\"\\\"\\\"\\n        if weight not in (0, 1):\\n            raise ValueError(\\\"Edge weight must be either 0 or 1.\\\")\\n\\n        if to_vertex < 0 or to_vertex >= self.size:\\n            raise ValueError(\\\"Vertex indexes must be in [0; size).\\\")\\n\\n        self._graph[from_vertex].append(Edge(to_vertex, weight))\\n\\n    def get_shortest_path(self, start_vertex: int, finish_vertex: int) -> int | None:\\n        \\\"\\\"\\\"\\n        Return the shortest distance from start_vertex to finish_vertex in 0-1-graph.\\n              1                  1         1\\n         0--------->3        6--------7>------->8\\n         |          ^        ^        ^         |1\\n         |          |        |        |0        v\\n        0|          |0      1|        9-------->10\\n         |          |        |        ^    1\\n         v          |        |        |0\\n         1--------->2<-------4------->5\\n              0         1        1\\n        >>> g = AdjacencyList(11)\\n        >>> g.add_edge(0, 1, 0)\\n        >>> g.add_edge(0, 3, 1)\\n        >>> g.add_edge(1, 2, 0)\\n        >>> g.add_edge(2, 3, 0)\\n        >>> g.add_edge(4, 2, 1)\\n        >>> g.add_edge(4, 5, 1)\\n        >>> g.add_edge(4, 6, 1)\\n        >>> g.add_edge(5, 9, 0)\\n        >>> g.add_edge(6, 7, 1)\\n        >>> g.add_edge(7, 8, 1)\\n        >>> g.add_edge(8, 10, 1)\\n        >>> g.add_edge(9, 7, 0)\\n        >>> g.add_edge(9, 10, 1)\\n        >>> g.add_edge(1, 2, 2)\\n        Traceback (most recent call last):\\n            ...\\n        ValueError: Edge weight must be either 0 or 1.\\n        >>> g.get_shortest_path(0, 3)\\n        0\\n        >>> g.get_shortest_path(0, 4)\\n        Traceback (most recent call last):\\n            ...\\n        ValueError: No path from start_vertex to finish_vertex.\\n        >>> g.get_shortest_path(4, 10)\\n        2\\n        >>> g.get_shortest_path(4, 8)\\n        2\\n        >>> g.get_shortest_path(0, 1)\\n        0\\n        >>> g.get_shortest_path(1, 0)\\n        Traceback (most recent call last):\\n            ...\\n        ValueError: No path from start_vertex to finish_vertex.\\n        \\\"\\\"\\\"\\n        queue = deque([start_vertex])\\n        distances: list[int | None] = [None] * self.size\\n        distances[start_vertex] = 0\\n\\n        while queue:\\n            current_vertex = queue.popleft()\\n            current_distance = distances[current_vertex]\\n            if current_distance is None:\\n                continue\\n\\n            for edge in self[current_vertex]:\\n                new_distance = current_distance + edge.weight\\n                dest_vertex_distance = distances[edge.destination_vertex]\\n                if (\\n                    isinstance(dest_vertex_distance, int)\\n                    and new_distance >= dest_vertex_distance\\n                ):\\n                    continue\\n                distances[edge.destination_vertex] = new_distance\\n                if edge.weight == 0:\\n                    queue.appendleft(edge.destination_vertex)\\n                else:\\n                    queue.append(edge.destination_vertex)\\n\\n        if distances[finish_vertex] is None:\\n            raise ValueError(\\\"No path from start_vertex to finish_vertex.\\\")\\n\\n        return distances[finish_vertex]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "bidirectional a star": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Bidirectional_search\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport time\\nfrom math import sqrt\\n\\n# 1 for manhattan, 0 for euclidean\\nHEURISTIC = 0\\n\\ngrid = [\\n    [0, 0, 0, 0, 0, 0, 0],\\n    [0, 1, 0, 0, 0, 0, 0],  # 0 are free path whereas 1's are obstacles\\n    [0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 1, 0, 0, 0, 0],\\n    [1, 0, 1, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 1, 0, 0],\\n]\\n\\ndelta = [[-1, 0], [0, -1], [1, 0], [0, 1]]  # up, left, down, right\\n\\nTPosition = tuple[int, int]\\n\\n\\nclass Node:\\n    \\\"\\\"\\\"\\n    >>> k = Node(0, 0, 4, 3, 0, None)\\n    >>> k.calculate_heuristic()\\n    5.0\\n    >>> n = Node(1, 4, 3, 4, 2, None)\\n    >>> n.calculate_heuristic()\\n    2.0\\n    >>> l = [k, n]\\n    >>> n == l[0]\\n    False\\n    >>> l.sort()\\n    >>> n == l[0]\\n    True\\n    \\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        pos_x: int,\\n        pos_y: int,\\n        goal_x: int,\\n        goal_y: int,\\n        g_cost: int,\\n        parent: Node | None,\\n    ) -> None:\\n        self.pos_x = pos_x\\n        self.pos_y = pos_y\\n        self.pos = (pos_y, pos_x)\\n        self.goal_x = goal_x\\n        self.goal_y = goal_y\\n        self.g_cost = g_cost\\n        self.parent = parent\\n        self.h_cost = self.calculate_heuristic()\\n        self.f_cost = self.g_cost + self.h_cost\\n\\n    def calculate_heuristic(self) -> float:\\n        \\\"\\\"\\\"\\n        Heuristic for the A*\\n        \\\"\\\"\\\"\\n        dy = self.pos_x - self.goal_x\\n        dx = self.pos_y - self.goal_y\\n        if HEURISTIC == 1:\\n            return abs(dx) + abs(dy)\\n        else:\\n            return sqrt(dy ** 2 + dx ** 2)\\n\\n    def __lt__(self, other: Node) -> bool:\\n        return self.f_cost < other.f_cost\\n\\n\\nclass AStar:\\n    \\\"\\\"\\\"\\n    >>> astar = AStar((0, 0), (len(grid) - 1, len(grid[0]) - 1))\\n    >>> (astar.start.pos_y + delta[3][0], astar.start.pos_x + delta[3][1])\\n    (0, 1)\\n    >>> [x.pos for x in astar.get_successors(astar.start)]\\n    [(1, 0), (0, 1)]\\n    >>> (astar.start.pos_y + delta[2][0], astar.start.pos_x + delta[2][1])\\n    (1, 0)\\n    >>> astar.retrace_path(astar.start)\\n    [(0, 0)]\\n    >>> astar.search()  # doctest: +NORMALIZE_WHITESPACE\\n    [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3),\\n     (4, 3), (4, 4), (5, 4), (5, 5), (6, 5), (6, 6)]\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, start: TPosition, goal: TPosition):\\n        self.start = Node(start[1], start[0], goal[1], goal[0], 0, None)\\n        self.target = Node(goal[1], goal[0], goal[1], goal[0], 99999, None)\\n\\n        self.open_nodes = [self.start]\\n        self.closed_nodes: list[Node] = []\\n\\n        self.reached = False\\n\\n    def search(self) -> list[TPosition]:\\n        while self.open_nodes:\\n            # Open Nodes are sorted using __lt__\\n            self.open_nodes.sort()\\n            current_node = self.open_nodes.pop(0)\\n\\n            if current_node.pos == self.target.pos:\\n                return self.retrace_path(current_node)\\n\\n            self.closed_nodes.append(current_node)\\n            successors = self.get_successors(current_node)\\n\\n            for child_node in successors:\\n                if child_node in self.closed_nodes:\\n                    continue\\n\\n                if child_node not in self.open_nodes:\\n                    self.open_nodes.append(child_node)\\n                else:\\n                    # retrieve the best current path\\n                    better_node = self.open_nodes.pop(self.open_nodes.index(child_node))\\n\\n                    if child_node.g_cost < better_node.g_cost:\\n                        self.open_nodes.append(child_node)\\n                    else:\\n                        self.open_nodes.append(better_node)\\n\\n        return [self.start.pos]\\n\\n    def get_successors(self, parent: Node) -> list[Node]:\\n        \\\"\\\"\\\"\\n        Returns a list of successors (both in the grid and free spaces)\\n        \\\"\\\"\\\"\\n        successors = []\\n        for action in delta:\\n            pos_x = parent.pos_x + action[1]\\n            pos_y = parent.pos_y + action[0]\\n            if not (0 <= pos_x <= len(grid[0]) - 1 and 0 <= pos_y <= len(grid) - 1):\\n                continue\\n\\n            if grid[pos_y][pos_x] != 0:\\n                continue\\n\\n            successors.append(\\n                Node(\\n                    pos_x,\\n                    pos_y,\\n                    self.target.pos_y,\\n                    self.target.pos_x,\\n                    parent.g_cost + 1,\\n                    parent,\\n                )\\n            )\\n        return successors\\n\\n    def retrace_path(self, node: Node | None) -> list[TPosition]:\\n        \\\"\\\"\\\"\\n        Retrace the path from parents to parents until start node\\n        \\\"\\\"\\\"\\n        current_node = node\\n        path = []\\n        while current_node is not None:\\n            path.append((current_node.pos_y, current_node.pos_x))\\n            current_node = current_node.parent\\n        path.reverse()\\n        return path\\n\\n\\nclass BidirectionalAStar:\\n    \\\"\\\"\\\"\\n    >>> bd_astar = BidirectionalAStar((0, 0), (len(grid) - 1, len(grid[0]) - 1))\\n    >>> bd_astar.fwd_astar.start.pos == bd_astar.bwd_astar.target.pos\\n    True\\n    >>> bd_astar.retrace_bidirectional_path(bd_astar.fwd_astar.start,\\n    ...                                     bd_astar.bwd_astar.start)\\n    [(0, 0)]\\n    >>> bd_astar.search()  # doctest: +NORMALIZE_WHITESPACE\\n    [(0, 0), (0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (2, 4),\\n     (2, 5), (3, 5), (4, 5), (5, 5), (5, 6), (6, 6)]\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, start: TPosition, goal: TPosition) -> None:\\n        self.fwd_astar = AStar(start, goal)\\n        self.bwd_astar = AStar(goal, start)\\n        self.reached = False\\n\\n    def search(self) -> list[TPosition]:\\n        while self.fwd_astar.open_nodes or self.bwd_astar.open_nodes:\\n            self.fwd_astar.open_nodes.sort()\\n            self.bwd_astar.open_nodes.sort()\\n            current_fwd_node = self.fwd_astar.open_nodes.pop(0)\\n            current_bwd_node = self.bwd_astar.open_nodes.pop(0)\\n\\n            if current_bwd_node.pos == current_fwd_node.pos:\\n                return self.retrace_bidirectional_path(\\n                    current_fwd_node, current_bwd_node\\n                )\\n\\n            self.fwd_astar.closed_nodes.append(current_fwd_node)\\n            self.bwd_astar.closed_nodes.append(current_bwd_node)\\n\\n            self.fwd_astar.target = current_bwd_node\\n            self.bwd_astar.target = current_fwd_node\\n\\n            successors = {\\n                self.fwd_astar: self.fwd_astar.get_successors(current_fwd_node),\\n                self.bwd_astar: self.bwd_astar.get_successors(current_bwd_node),\\n            }\\n\\n            for astar in [self.fwd_astar, self.bwd_astar]:\\n                for child_node in successors[astar]:\\n                    if child_node in astar.closed_nodes:\\n                        continue\\n\\n                    if child_node not in astar.open_nodes:\\n                        astar.open_nodes.append(child_node)\\n                    else:\\n                        # retrieve the best current path\\n                        better_node = astar.open_nodes.pop(\\n                            astar.open_nodes.index(child_node)\\n                        )\\n\\n                        if child_node.g_cost < better_node.g_cost:\\n                            astar.open_nodes.append(child_node)\\n                        else:\\n                            astar.open_nodes.append(better_node)\\n\\n        return [self.fwd_astar.start.pos]\\n\\n    def retrace_bidirectional_path(\\n        self, fwd_node: Node, bwd_node: Node\\n    ) -> list[TPosition]:\\n        fwd_path = self.fwd_astar.retrace_path(fwd_node)\\n        bwd_path = self.bwd_astar.retrace_path(bwd_node)\\n        bwd_path.pop()\\n        bwd_path.reverse()\\n        path = fwd_path + bwd_path\\n        return path\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # all coordinates are given in format [y,x]\\n    init = (0, 0)\\n    goal = (len(grid) - 1, len(grid[0]) - 1)\\n    for elem in grid:\\n        print(elem)\\n\\n    start_time = time.time()\\n    a_star = AStar(init, goal)\\n    path = a_star.search()\\n    end_time = time.time() - start_time\\n    print(f\\\"AStar execution time = {end_time:f} seconds\\\")\\n\\n    bd_start_time = time.time()\\n    bidir_astar = BidirectionalAStar(init, goal)\\n    bd_end_time = time.time() - bd_start_time\\n    print(f\\\"BidirectionalAStar execution time = {bd_end_time:f} seconds\\\")\\n\"",
    "bidirectional breadth first search": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Bidirectional_search\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport time\\n\\nPath = list[tuple[int, int]]\\n\\ngrid = [\\n    [0, 0, 0, 0, 0, 0, 0],\\n    [0, 1, 0, 0, 0, 0, 0],  # 0 are free path whereas 1's are obstacles\\n    [0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 1, 0, 0, 0, 0],\\n    [1, 0, 1, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 1, 0, 0],\\n]\\n\\ndelta = [[-1, 0], [0, -1], [1, 0], [0, 1]]  # up, left, down, right\\n\\n\\nclass Node:\\n    def __init__(\\n        self, pos_x: int, pos_y: int, goal_x: int, goal_y: int, parent: Node | None\\n    ):\\n        self.pos_x = pos_x\\n        self.pos_y = pos_y\\n        self.pos = (pos_y, pos_x)\\n        self.goal_x = goal_x\\n        self.goal_y = goal_y\\n        self.parent = parent\\n\\n\\nclass BreadthFirstSearch:\\n    \\\"\\\"\\\"\\n    # Comment out slow pytests...\\n    # 9.15s call     graphs/bidirectional_breadth_first_search.py:: \\\\\\n    #                graphs.bidirectional_breadth_first_search.BreadthFirstSearch\\n    # >>> bfs = BreadthFirstSearch((0, 0), (len(grid) - 1, len(grid[0]) - 1))\\n    # >>> (bfs.start.pos_y + delta[3][0], bfs.start.pos_x + delta[3][1])\\n    (0, 1)\\n    # >>> [x.pos for x in bfs.get_successors(bfs.start)]\\n    [(1, 0), (0, 1)]\\n    # >>> (bfs.start.pos_y + delta[2][0], bfs.start.pos_x + delta[2][1])\\n    (1, 0)\\n    # >>> bfs.retrace_path(bfs.start)\\n    [(0, 0)]\\n    # >>> bfs.search()  # doctest: +NORMALIZE_WHITESPACE\\n    [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (4, 1),\\n     (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (6, 5), (6, 6)]\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, start: tuple[int, int], goal: tuple[int, int]):\\n        self.start = Node(start[1], start[0], goal[1], goal[0], None)\\n        self.target = Node(goal[1], goal[0], goal[1], goal[0], None)\\n\\n        self.node_queue = [self.start]\\n        self.reached = False\\n\\n    def search(self) -> Path | None:\\n        while self.node_queue:\\n            current_node = self.node_queue.pop(0)\\n\\n            if current_node.pos == self.target.pos:\\n                self.reached = True\\n                return self.retrace_path(current_node)\\n\\n            successors = self.get_successors(current_node)\\n\\n            for node in successors:\\n                self.node_queue.append(node)\\n\\n        if not self.reached:\\n            return [self.start.pos]\\n        return None\\n\\n    def get_successors(self, parent: Node) -> list[Node]:\\n        \\\"\\\"\\\"\\n        Returns a list of successors (both in the grid and free spaces)\\n        \\\"\\\"\\\"\\n        successors = []\\n        for action in delta:\\n            pos_x = parent.pos_x + action[1]\\n            pos_y = parent.pos_y + action[0]\\n            if not (0 <= pos_x <= len(grid[0]) - 1 and 0 <= pos_y <= len(grid) - 1):\\n                continue\\n\\n            if grid[pos_y][pos_x] != 0:\\n                continue\\n\\n            successors.append(\\n                Node(pos_x, pos_y, self.target.pos_y, self.target.pos_x, parent)\\n            )\\n        return successors\\n\\n    def retrace_path(self, node: Node | None) -> Path:\\n        \\\"\\\"\\\"\\n        Retrace the path from parents to parents until start node\\n        \\\"\\\"\\\"\\n        current_node = node\\n        path = []\\n        while current_node is not None:\\n            path.append((current_node.pos_y, current_node.pos_x))\\n            current_node = current_node.parent\\n        path.reverse()\\n        return path\\n\\n\\nclass BidirectionalBreadthFirstSearch:\\n    \\\"\\\"\\\"\\n    >>> bd_bfs = BidirectionalBreadthFirstSearch((0, 0), (len(grid) - 1,\\n    ...                                                   len(grid[0]) - 1))\\n    >>> bd_bfs.fwd_bfs.start.pos == bd_bfs.bwd_bfs.target.pos\\n    True\\n    >>> bd_bfs.retrace_bidirectional_path(bd_bfs.fwd_bfs.start,\\n    ...                                     bd_bfs.bwd_bfs.start)\\n    [(0, 0)]\\n    >>> bd_bfs.search()  # doctest: +NORMALIZE_WHITESPACE\\n    [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3),\\n     (2, 4), (3, 4), (3, 5), (3, 6), (4, 6), (5, 6), (6, 6)]\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, start, goal):\\n        self.fwd_bfs = BreadthFirstSearch(start, goal)\\n        self.bwd_bfs = BreadthFirstSearch(goal, start)\\n        self.reached = False\\n\\n    def search(self) -> Path | None:\\n        while self.fwd_bfs.node_queue or self.bwd_bfs.node_queue:\\n            current_fwd_node = self.fwd_bfs.node_queue.pop(0)\\n            current_bwd_node = self.bwd_bfs.node_queue.pop(0)\\n\\n            if current_bwd_node.pos == current_fwd_node.pos:\\n                self.reached = True\\n                return self.retrace_bidirectional_path(\\n                    current_fwd_node, current_bwd_node\\n                )\\n\\n            self.fwd_bfs.target = current_bwd_node\\n            self.bwd_bfs.target = current_fwd_node\\n\\n            successors = {\\n                self.fwd_bfs: self.fwd_bfs.get_successors(current_fwd_node),\\n                self.bwd_bfs: self.bwd_bfs.get_successors(current_bwd_node),\\n            }\\n\\n            for bfs in [self.fwd_bfs, self.bwd_bfs]:\\n                for node in successors[bfs]:\\n                    bfs.node_queue.append(node)\\n\\n        if not self.reached:\\n            return [self.fwd_bfs.start.pos]\\n        return None\\n\\n    def retrace_bidirectional_path(self, fwd_node: Node, bwd_node: Node) -> Path:\\n        fwd_path = self.fwd_bfs.retrace_path(fwd_node)\\n        bwd_path = self.bwd_bfs.retrace_path(bwd_node)\\n        bwd_path.pop()\\n        bwd_path.reverse()\\n        path = fwd_path + bwd_path\\n        return path\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # all coordinates are given in format [y,x]\\n    import doctest\\n\\n    doctest.testmod()\\n    init = (0, 0)\\n    goal = (len(grid) - 1, len(grid[0]) - 1)\\n    for elem in grid:\\n        print(elem)\\n\\n    start_bfs_time = time.time()\\n    bfs = BreadthFirstSearch(init, goal)\\n    path = bfs.search()\\n    bfs_time = time.time() - start_bfs_time\\n\\n    print(\\\"Unidirectional BFS computation time : \\\", bfs_time)\\n\\n    start_bd_bfs_time = time.time()\\n    bd_bfs = BidirectionalBreadthFirstSearch(init, goal)\\n    bd_path = bd_bfs.search()\\n    bd_bfs_time = time.time() - start_bd_bfs_time\\n\\n    print(\\\"Bidirectional BFS computation time : \\\", bd_bfs_time)\\n\"",
    "boruvka": "\"\\\"\\\"\\\"Borůvka's algorithm.\\n\\n    Determines the minimum spanning tree (MST) of a graph using the Borůvka's algorithm.\\n    Borůvka's algorithm is a greedy algorithm for finding a minimum spanning tree in a\\n    connected graph, or a minimum spanning forest if a graph that is not connected.\\n\\n    The time complexity of this algorithm is O(ELogV), where E represents the number\\n    of edges, while V represents the number of nodes.\\n    O(number_of_edges Log number_of_nodes)\\n\\n    The space complexity of this algorithm is O(V + E), since we have to keep a couple\\n    of lists whose sizes are equal to the number of nodes, as well as keep all the\\n    edges of a graph inside of the data structure itself.\\n\\n    Borůvka's algorithm gives us pretty much the same result as other MST Algorithms -\\n    they all find the minimum spanning tree, and the time complexity is approximately\\n    the same.\\n\\n    One advantage that Borůvka's algorithm has compared to the alternatives is that it\\n    doesn't need to presort the edges or maintain a priority queue in order to find the\\n    minimum spanning tree.\\n    Even though that doesn't help its complexity, since it still passes the edges logE\\n    times, it is a bit simpler to code.\\n\\n    Details: https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom typing import Any\\n\\n\\nclass Graph:\\n    def __init__(self, num_of_nodes: int) -> None:\\n        \\\"\\\"\\\"\\n        Arguments:\\n            num_of_nodes - the number of nodes in the graph\\n        Attributes:\\n            m_num_of_nodes - the number of nodes in the graph.\\n            m_edges - the list of edges.\\n            m_component - the dictionary which stores the index of the component which\\n            a node belongs to.\\n        \\\"\\\"\\\"\\n\\n        self.m_num_of_nodes = num_of_nodes\\n        self.m_edges: list[list[int]] = []\\n        self.m_component: dict[int, int] = {}\\n\\n    def add_edge(self, u_node: int, v_node: int, weight: int) -> None:\\n        \\\"\\\"\\\"Adds an edge in the format [first, second, edge weight] to graph.\\\"\\\"\\\"\\n\\n        self.m_edges.append([u_node, v_node, weight])\\n\\n    def find_component(self, u_node: int) -> int:\\n        \\\"\\\"\\\"Propagates a new component throughout a given component.\\\"\\\"\\\"\\n\\n        if self.m_component[u_node] == u_node:\\n            return u_node\\n        return self.find_component(self.m_component[u_node])\\n\\n    def set_component(self, u_node: int) -> None:\\n        \\\"\\\"\\\"Finds the component index of a given node\\\"\\\"\\\"\\n\\n        if self.m_component[u_node] != u_node:\\n            for k in self.m_component:\\n                self.m_component[k] = self.find_component(k)\\n\\n    def union(self, component_size: list[int], u_node: int, v_node: int) -> None:\\n        \\\"\\\"\\\"Union finds the roots of components for two nodes, compares the components\\n        in terms of size, and attaches the smaller one to the larger one to form\\n        single component\\\"\\\"\\\"\\n\\n        if component_size[u_node] <= component_size[v_node]:\\n            self.m_component[u_node] = v_node\\n            component_size[v_node] += component_size[u_node]\\n            self.set_component(u_node)\\n\\n        elif component_size[u_node] >= component_size[v_node]:\\n            self.m_component[v_node] = self.find_component(u_node)\\n            component_size[u_node] += component_size[v_node]\\n            self.set_component(v_node)\\n\\n    def boruvka(self) -> None:\\n        \\\"\\\"\\\"Performs Borůvka's algorithm to find MST.\\\"\\\"\\\"\\n\\n        # Initialize additional lists required to algorithm.\\n        component_size = []\\n        mst_weight = 0\\n\\n        minimum_weight_edge: list[Any] = [-1] * self.m_num_of_nodes\\n\\n        # A list of components (initialized to all of the nodes)\\n        for node in range(self.m_num_of_nodes):\\n            self.m_component.update({node: node})\\n            component_size.append(1)\\n\\n        num_of_components = self.m_num_of_nodes\\n\\n        while num_of_components > 1:\\n            for edge in self.m_edges:\\n                u, v, w = edge\\n\\n                u_component = self.m_component[u]\\n                v_component = self.m_component[v]\\n\\n                if u_component != v_component:\\n                    \\\"\\\"\\\"If the current minimum weight edge of component u doesn't\\n                    exist (is -1), or if it's greater than the edge we're\\n                    observing right now, we will assign the value of the edge\\n                    we're observing to it.\\n\\n                    If the current minimum weight edge of component v doesn't\\n                    exist (is -1), or if it's greater than the edge we're\\n                    observing right now, we will assign the value of the edge\\n                    we're observing to it\\\"\\\"\\\"\\n\\n                    for component in (u_component, v_component):\\n                        if (\\n                            minimum_weight_edge[component] == -1\\n                            or minimum_weight_edge[component][2] > w\\n                        ):\\n                            minimum_weight_edge[component] = [u, v, w]\\n\\n            for edge in minimum_weight_edge:\\n                if isinstance(edge, list):\\n                    u, v, w = edge\\n\\n                    u_component = self.m_component[u]\\n                    v_component = self.m_component[v]\\n\\n                    if u_component != v_component:\\n                        mst_weight += w\\n                        self.union(component_size, u_component, v_component)\\n                        print(f\\\"Added edge [{u} - {v}]\\\\nAdded weight: {w}\\\\n\\\")\\n                        num_of_components -= 1\\n\\n            minimum_weight_edge = [-1] * self.m_num_of_nodes\\n        print(f\\\"The total weight of the minimal spanning tree is: {mst_weight}\\\")\\n\\n\\ndef test_vector() -> None:\\n    \\\"\\\"\\\"\\n    >>> g = Graph(8)\\n    >>> for u_v_w in ((0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4),\\n    ...    (3, 4, 8), (4, 5, 10), (4, 6, 6), (4, 7, 5), (5, 7, 15), (6, 7, 4)):\\n    ...        g.add_edge(*u_v_w)\\n    >>> g.boruvka()\\n    Added edge [0 - 3]\\n    Added weight: 5\\n    <BLANKLINE>\\n    Added edge [0 - 1]\\n    Added weight: 10\\n    <BLANKLINE>\\n    Added edge [2 - 3]\\n    Added weight: 4\\n    <BLANKLINE>\\n    Added edge [4 - 7]\\n    Added weight: 5\\n    <BLANKLINE>\\n    Added edge [4 - 5]\\n    Added weight: 10\\n    <BLANKLINE>\\n    Added edge [6 - 7]\\n    Added weight: 4\\n    <BLANKLINE>\\n    Added edge [3 - 4]\\n    Added weight: 8\\n    <BLANKLINE>\\n    The total weight of the minimal spanning tree is: 46\\n    \\\"\\\"\\\"\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "breadth first search": "\"#!/usr/bin/python\\n\\n\\\"\\\"\\\" Author: OMKAR PATHAK \\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom queue import Queue\\n\\n\\nclass Graph:\\n    def __init__(self) -> None:\\n        self.vertices: dict[int, list[int]] = {}\\n\\n    def print_graph(self) -> None:\\n        \\\"\\\"\\\"\\n        prints adjacency list representation of graaph\\n        >>> g = Graph()\\n        >>> g.print_graph()\\n        >>> g.add_edge(0, 1)\\n        >>> g.print_graph()\\n        0  :  1\\n        \\\"\\\"\\\"\\n        for i in self.vertices:\\n            print(i, \\\" : \\\", \\\" -> \\\".join([str(j) for j in self.vertices[i]]))\\n\\n    def add_edge(self, from_vertex: int, to_vertex: int) -> None:\\n        \\\"\\\"\\\"\\n        adding the edge between two vertices\\n        >>> g = Graph()\\n        >>> g.print_graph()\\n        >>> g.add_edge(0, 1)\\n        >>> g.print_graph()\\n        0  :  1\\n        \\\"\\\"\\\"\\n        if from_vertex in self.vertices:\\n            self.vertices[from_vertex].append(to_vertex)\\n        else:\\n            self.vertices[from_vertex] = [to_vertex]\\n\\n    def bfs(self, start_vertex: int) -> set[int]:\\n        \\\"\\\"\\\"\\n        >>> g = Graph()\\n        >>> g.add_edge(0, 1)\\n        >>> g.add_edge(0, 1)\\n        >>> g.add_edge(0, 2)\\n        >>> g.add_edge(1, 2)\\n        >>> g.add_edge(2, 0)\\n        >>> g.add_edge(2, 3)\\n        >>> g.add_edge(3, 3)\\n        >>> sorted(g.bfs(2))\\n        [0, 1, 2, 3]\\n        \\\"\\\"\\\"\\n        # initialize set for storing already visited vertices\\n        visited = set()\\n\\n        # create a first in first out queue to store all the vertices for BFS\\n        queue: Queue = Queue()\\n\\n        # mark the source node as visited and enqueue it\\n        visited.add(start_vertex)\\n        queue.put(start_vertex)\\n\\n        while not queue.empty():\\n            vertex = queue.get()\\n\\n            # loop through all adjacent vertex and enqueue it if not yet visited\\n            for adjacent_vertex in self.vertices[vertex]:\\n                if adjacent_vertex not in visited:\\n                    queue.put(adjacent_vertex)\\n                    visited.add(adjacent_vertex)\\n        return visited\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod(verbose=True)\\n\\n    g = Graph()\\n    g.add_edge(0, 1)\\n    g.add_edge(0, 2)\\n    g.add_edge(1, 2)\\n    g.add_edge(2, 0)\\n    g.add_edge(2, 3)\\n    g.add_edge(3, 3)\\n\\n    g.print_graph()\\n    # 0  :  1 -> 2\\n    # 1  :  2\\n    # 2  :  0 -> 3\\n    # 3  :  3\\n\\n    assert sorted(g.bfs(2)) == [0, 1, 2, 3]\\n\"",
    "breadth first search 2": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Breadth-first_search\\npseudo-code:\\nbreadth_first_search(graph G, start vertex s):\\n// all nodes initially unexplored\\nmark s as explored\\nlet Q = queue data structure, initialized with s\\nwhile Q is non-empty:\\n    remove the first node of Q, call it v\\n    for each edge(v, w):  // for w in graph[v]\\n        if w unexplored:\\n            mark w as explored\\n            add w to Q (at the end)\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom queue import Queue\\n\\nG = {\\n    \\\"A\\\": [\\\"B\\\", \\\"C\\\"],\\n    \\\"B\\\": [\\\"A\\\", \\\"D\\\", \\\"E\\\"],\\n    \\\"C\\\": [\\\"A\\\", \\\"F\\\"],\\n    \\\"D\\\": [\\\"B\\\"],\\n    \\\"E\\\": [\\\"B\\\", \\\"F\\\"],\\n    \\\"F\\\": [\\\"C\\\", \\\"E\\\"],\\n}\\n\\n\\ndef breadth_first_search(graph: dict, start: str) -> set[str]:\\n    \\\"\\\"\\\"\\n    >>> ''.join(sorted(breadth_first_search(G, 'A')))\\n    'ABCDEF'\\n    \\\"\\\"\\\"\\n    explored = {start}\\n    queue: Queue = Queue()\\n    queue.put(start)\\n    while not queue.empty():\\n        v = queue.get()\\n        for w in graph[v]:\\n            if w not in explored:\\n                explored.add(w)\\n                queue.put(w)\\n    return explored\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    print(breadth_first_search(G, \\\"A\\\"))\\n\"",
    "breadth first search shortest path": "\"\\\"\\\"\\\"Breath First Search (BFS) can be used when finding the shortest path\\nfrom a given source node to a target node in an unweighted graph.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\ngraph = {\\n    \\\"A\\\": [\\\"B\\\", \\\"C\\\", \\\"E\\\"],\\n    \\\"B\\\": [\\\"A\\\", \\\"D\\\", \\\"E\\\"],\\n    \\\"C\\\": [\\\"A\\\", \\\"F\\\", \\\"G\\\"],\\n    \\\"D\\\": [\\\"B\\\"],\\n    \\\"E\\\": [\\\"A\\\", \\\"B\\\", \\\"D\\\"],\\n    \\\"F\\\": [\\\"C\\\"],\\n    \\\"G\\\": [\\\"C\\\"],\\n}\\n\\n\\nclass Graph:\\n    def __init__(self, graph: dict[str, list[str]], source_vertex: str) -> None:\\n        \\\"\\\"\\\"\\n        Graph is implemented as dictionary of adjacency lists. Also,\\n        Source vertex have to be defined upon initialization.\\n        \\\"\\\"\\\"\\n        self.graph = graph\\n        # mapping node to its parent in resulting breadth first tree\\n        self.parent: dict[str, str | None] = {}\\n        self.source_vertex = source_vertex\\n\\n    def breath_first_search(self) -> None:\\n        \\\"\\\"\\\"\\n        This function is a helper for running breath first search on this graph.\\n        >>> g = Graph(graph, \\\"G\\\")\\n        >>> g.breath_first_search()\\n        >>> g.parent\\n        {'G': None, 'C': 'G', 'A': 'C', 'F': 'C', 'B': 'A', 'E': 'A', 'D': 'B'}\\n        \\\"\\\"\\\"\\n        visited = {self.source_vertex}\\n        self.parent[self.source_vertex] = None\\n        queue = [self.source_vertex]  # first in first out queue\\n\\n        while queue:\\n            vertex = queue.pop(0)\\n            for adjacent_vertex in self.graph[vertex]:\\n                if adjacent_vertex not in visited:\\n                    visited.add(adjacent_vertex)\\n                    self.parent[adjacent_vertex] = vertex\\n                    queue.append(adjacent_vertex)\\n\\n    def shortest_path(self, target_vertex: str) -> str:\\n        \\\"\\\"\\\"\\n        This shortest path function returns a string, describing the result:\\n        1.) No path is found. The string is a human readable message to indicate this.\\n        2.) The shortest path is found. The string is in the form\\n            `v1(->v2->v3->...->vn)`, where v1 is the source vertex and vn is the target\\n            vertex, if it exists separately.\\n\\n        >>> g = Graph(graph, \\\"G\\\")\\n        >>> g.breath_first_search()\\n\\n        Case 1 - No path is found.\\n        >>> g.shortest_path(\\\"Foo\\\")\\n        'No path from vertex:G to vertex:Foo'\\n\\n        Case 2 - The path is found.\\n        >>> g.shortest_path(\\\"D\\\")\\n        'G->C->A->B->D'\\n        >>> g.shortest_path(\\\"G\\\")\\n        'G'\\n        \\\"\\\"\\\"\\n        if target_vertex == self.source_vertex:\\n            return self.source_vertex\\n\\n        target_vertex_parent = self.parent.get(target_vertex)\\n        if target_vertex_parent is None:\\n            return f\\\"No path from vertex:{self.source_vertex} to vertex:{target_vertex}\\\"\\n\\n        return self.shortest_path(target_vertex_parent) + f\\\"->{target_vertex}\\\"\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    g = Graph(graph, \\\"G\\\")\\n    g.breath_first_search()\\n    print(g.shortest_path(\\\"D\\\"))\\n    print(g.shortest_path(\\\"G\\\"))\\n    print(g.shortest_path(\\\"Foo\\\"))\\n\"",
    "check bipartite graph bfs": "\"# Check whether Graph is Bipartite or Not using BFS\\n\\n\\n# A Bipartite Graph is a graph whose vertices can be divided into two independent sets,\\n# U and V such that every edge (u, v) either connects a vertex from U to V or a vertex\\n# from V to U. In other words, for every edge (u, v), either u belongs to U and v to V,\\n# or u belongs to V and v to U. We can also say that there is no edge that connects\\n# vertices of same set.\\nfrom queue import Queue\\n\\n\\ndef checkBipartite(graph):\\n    queue = Queue()\\n    visited = [False] * len(graph)\\n    color = [-1] * len(graph)\\n\\n    def bfs():\\n        while not queue.empty():\\n            u = queue.get()\\n            visited[u] = True\\n\\n            for neighbour in graph[u]:\\n\\n                if neighbour == u:\\n                    return False\\n\\n                if color[neighbour] == -1:\\n                    color[neighbour] = 1 - color[u]\\n                    queue.put(neighbour)\\n\\n                elif color[neighbour] == color[u]:\\n                    return False\\n\\n        return True\\n\\n    for i in range(len(graph)):\\n        if not visited[i]:\\n            queue.put(i)\\n            color[i] = 0\\n            if bfs() is False:\\n                return False\\n\\n    return True\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # Adjacency List of graph\\n    print(checkBipartite({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}))\\n\"",
    "check bipartite graph dfs": "\"# Check whether Graph is Bipartite or Not using DFS\\n\\n\\n# A Bipartite Graph is a graph whose vertices can be divided into two independent sets,\\n# U and V such that every edge (u, v) either connects a vertex from U to V or a vertex\\n# from V to U. In other words, for every edge (u, v), either u belongs to U and v to V,\\n# or u belongs to V and v to U. We can also say that there is no edge that connects\\n# vertices of same set.\\ndef check_bipartite_dfs(graph):\\n    visited = [False] * len(graph)\\n    color = [-1] * len(graph)\\n\\n    def dfs(v, c):\\n        visited[v] = True\\n        color[v] = c\\n        for u in graph[v]:\\n            if not visited[u]:\\n                dfs(u, 1 - c)\\n\\n    for i in range(len(graph)):\\n        if not visited[i]:\\n            dfs(i, 0)\\n\\n    for i in range(len(graph)):\\n        for j in graph[i]:\\n            if color[i] == color[j]:\\n                return False\\n\\n    return True\\n\\n\\n# Adjacency list of graph\\ngraph = {0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: []}\\nprint(check_bipartite_dfs(graph))\\n\"",
    "check cycle": "\"\\\"\\\"\\\"\\nProgram to check if a cycle is present in a given graph\\n\\\"\\\"\\\"\\n\\n\\ndef check_cycle(graph: dict) -> bool:\\n    \\\"\\\"\\\"\\n    Returns True if graph is cyclic else False\\n    >>> check_cycle(graph={0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]})\\n    False\\n    >>> check_cycle(graph={0:[1, 2], 1:[2], 2:[0, 3], 3:[3]})\\n    True\\n    \\\"\\\"\\\"\\n    # Keep track of visited nodes\\n    visited: set[int] = set()\\n    # To detect a back edge, keep track of vertices currently in the recursion stack\\n    rec_stk: set[int] = set()\\n    for node in graph:\\n        if node not in visited:\\n            if depth_first_search(graph, node, visited, rec_stk):\\n                return True\\n    return False\\n\\n\\ndef depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:\\n    \\\"\\\"\\\"\\n    Recur for all neighbours.\\n    If any neighbour is visited and in rec_stk then graph is cyclic.\\n    >>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}\\n    >>> vertex, visited, rec_stk = 0, set(), set()\\n    >>> depth_first_search(graph, vertex, visited, rec_stk)\\n    False\\n    \\\"\\\"\\\"\\n    # Mark current node as visited and add to recursion stack\\n    visited.add(vertex)\\n    rec_stk.add(vertex)\\n\\n    for node in graph[vertex]:\\n        if node not in visited:\\n            if depth_first_search(graph, node, visited, rec_stk):\\n                return True\\n        elif node in rec_stk:\\n            return True\\n\\n    # The node needs to be removed from recursion stack before function ends\\n    rec_stk.remove(vertex)\\n    return False\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "connected components": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Component_(graph_theory)\\n\\nFinding connected components in graph\\n\\n\\\"\\\"\\\"\\n\\ntest_graph_1 = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1], 4: [5, 6], 5: [4, 6], 6: [4, 5]}\\n\\ntest_graph_2 = {0: [1, 2, 3], 1: [0, 3], 2: [0], 3: [0, 1], 4: [], 5: []}\\n\\n\\ndef dfs(graph: dict, vert: int, visited: list) -> list:\\n    \\\"\\\"\\\"\\n    Use depth first search to find all vertices\\n    being in the same component as initial vertex\\n    >>> dfs(test_graph_1, 0, 5 * [False])\\n    [0, 1, 3, 2]\\n    >>> dfs(test_graph_2, 0, 6 * [False])\\n    [0, 1, 3, 2]\\n    \\\"\\\"\\\"\\n\\n    visited[vert] = True\\n    connected_verts = []\\n\\n    for neighbour in graph[vert]:\\n        if not visited[neighbour]:\\n            connected_verts += dfs(graph, neighbour, visited)\\n\\n    return [vert] + connected_verts\\n\\n\\ndef connected_components(graph: dict) -> list:\\n    \\\"\\\"\\\"\\n    This function takes graph as a parameter\\n    and then returns the list of connected components\\n    >>> connected_components(test_graph_1)\\n    [[0, 1, 3, 2], [4, 5, 6]]\\n    >>> connected_components(test_graph_2)\\n    [[0, 1, 3, 2], [4], [5]]\\n    \\\"\\\"\\\"\\n\\n    graph_size = len(graph)\\n    visited = graph_size * [False]\\n    components_list = []\\n\\n    for i in range(graph_size):\\n        if not visited[i]:\\n            i_connected = dfs(graph, i, visited)\\n            components_list.append(i_connected)\\n\\n    return components_list\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "depth first search": "\"\\\"\\\"\\\"Non recursive implementation of a DFS algorithm.\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef depth_first_search(graph: dict, start: str) -> set[str]:\\n    \\\"\\\"\\\"Depth First Search on Graph\\n    :param graph: directed graph in dictionary format\\n    :param start: starting vertex as a string\\n    :returns: the trace of the search\\n    >>> input_G = { \\\"A\\\": [\\\"B\\\", \\\"C\\\", \\\"D\\\"], \\\"B\\\": [\\\"A\\\", \\\"D\\\", \\\"E\\\"],\\n    ... \\\"C\\\": [\\\"A\\\", \\\"F\\\"], \\\"D\\\": [\\\"B\\\", \\\"D\\\"], \\\"E\\\": [\\\"B\\\", \\\"F\\\"],\\n    ... \\\"F\\\": [\\\"C\\\", \\\"E\\\", \\\"G\\\"], \\\"G\\\": [\\\"F\\\"] }\\n    >>> output_G = list({'A', 'B', 'C', 'D', 'E', 'F', 'G'})\\n    >>> all(x in output_G for x in list(depth_first_search(input_G, \\\"A\\\")))\\n    True\\n    >>> all(x in output_G for x in list(depth_first_search(input_G, \\\"G\\\")))\\n    True\\n    \\\"\\\"\\\"\\n    explored, stack = set(start), [start]\\n\\n    while stack:\\n        v = stack.pop()\\n        explored.add(v)\\n        # Differences from BFS:\\n        # 1) pop last element instead of first one\\n        # 2) add adjacent elements to stack without exploring them\\n        for adj in reversed(graph[v]):\\n            if adj not in explored:\\n                stack.append(adj)\\n    return explored\\n\\n\\nG = {\\n    \\\"A\\\": [\\\"B\\\", \\\"C\\\", \\\"D\\\"],\\n    \\\"B\\\": [\\\"A\\\", \\\"D\\\", \\\"E\\\"],\\n    \\\"C\\\": [\\\"A\\\", \\\"F\\\"],\\n    \\\"D\\\": [\\\"B\\\", \\\"D\\\"],\\n    \\\"E\\\": [\\\"B\\\", \\\"F\\\"],\\n    \\\"F\\\": [\\\"C\\\", \\\"E\\\", \\\"G\\\"],\\n    \\\"G\\\": [\\\"F\\\"],\\n}\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    print(depth_first_search(G, \\\"A\\\"))\\n\"",
    "depth first search 2": "\"#!/usr/bin/python\\n\\n\\\"\\\"\\\" Author: OMKAR PATHAK \\\"\\\"\\\"\\n\\n\\nclass Graph:\\n    def __init__(self):\\n        self.vertex = {}\\n\\n    # for printing the Graph vertices\\n    def print_graph(self) -> None:\\n        print(self.vertex)\\n        for i in self.vertex:\\n            print(i, \\\" -> \\\", \\\" -> \\\".join([str(j) for j in self.vertex[i]]))\\n\\n    # for adding the edge between two vertices\\n    def add_edge(self, from_vertex: int, to_vertex: int) -> None:\\n        # check if vertex is already present,\\n        if from_vertex in self.vertex:\\n            self.vertex[from_vertex].append(to_vertex)\\n        else:\\n            # else make a new vertex\\n            self.vertex[from_vertex] = [to_vertex]\\n\\n    def dfs(self) -> None:\\n        # visited array for storing already visited nodes\\n        visited = [False] * len(self.vertex)\\n\\n        # call the recursive helper function\\n        for i in range(len(self.vertex)):\\n            if not visited[i]:\\n                self.dfs_recursive(i, visited)\\n\\n    def dfs_recursive(self, start_vertex: int, visited: list) -> None:\\n        # mark start vertex as visited\\n        visited[start_vertex] = True\\n\\n        print(start_vertex, end=\\\" \\\")\\n\\n        # Recur for all the vertices that are adjacent to this node\\n        for i in self.vertex:\\n            if not visited[i]:\\n                self.dfs_recursive(i, visited)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    g = Graph()\\n    g.add_edge(0, 1)\\n    g.add_edge(0, 2)\\n    g.add_edge(1, 2)\\n    g.add_edge(2, 0)\\n    g.add_edge(2, 3)\\n    g.add_edge(3, 3)\\n\\n    g.print_graph()\\n    print(\\\"DFS:\\\")\\n    g.dfs()\\n\\n    # OUTPUT:\\n    # 0  ->  1 -> 2\\n    # 1  ->  2\\n    # 2  ->  0 -> 3\\n    # 3  ->  3\\n    # DFS:\\n    #  0 1 2 3\\n\"",
    "dijkstra": "\"\\\"\\\"\\\"\\npseudo-code\\n\\nDIJKSTRA(graph G, start vertex s, destination vertex d):\\n\\n//all nodes initially unexplored\\n\\n1 -  let H = min heap data structure, initialized with 0 and s [here 0 indicates\\n     the distance from start vertex s]\\n2 -  while H is non-empty:\\n3 -    remove the first node and cost of H, call it U and cost\\n4 -    if U has been previously explored:\\n5 -      go to the while loop, line 2 //Once a node is explored there is no need\\n         to make it again\\n6 -    mark U as explored\\n7 -    if U is d:\\n8 -      return cost // total cost from start to destination vertex\\n9 -    for each edge(U, V): c=cost of edge(U,V) // for V in graph[U]\\n10 -     if V explored:\\n11 -       go to next V in line 9\\n12 -     total_cost = cost + c\\n13 -     add (total_cost,V) to H\\n\\nYou can think at cost as a distance where Dijkstra finds the shortest distance\\nbetween vertices s and v in a graph G. The use of a min heap as H guarantees\\nthat if a vertex has already been explored there will be no other path with\\nshortest distance, that happens because heapq.heappop will always return the\\nnext vertex with the shortest distance, considering that the heap stores not\\nonly the distance between previous vertex and current vertex but the entire\\ndistance between each vertex that makes up the path from start vertex to target\\nvertex.\\n\\\"\\\"\\\"\\nimport heapq\\n\\n\\ndef dijkstra(graph, start, end):\\n    \\\"\\\"\\\"Return the cost of the shortest path between vertices start and end.\\n\\n    >>> dijkstra(G, \\\"E\\\", \\\"C\\\")\\n    6\\n    >>> dijkstra(G2, \\\"E\\\", \\\"F\\\")\\n    3\\n    >>> dijkstra(G3, \\\"E\\\", \\\"F\\\")\\n    3\\n    \\\"\\\"\\\"\\n\\n    heap = [(0, start)]  # cost from start node,end node\\n    visited = set()\\n    while heap:\\n        (cost, u) = heapq.heappop(heap)\\n        if u in visited:\\n            continue\\n        visited.add(u)\\n        if u == end:\\n            return cost\\n        for v, c in graph[u]:\\n            if v in visited:\\n                continue\\n            next = cost + c\\n            heapq.heappush(heap, (next, v))\\n    return -1\\n\\n\\nG = {\\n    \\\"A\\\": [[\\\"B\\\", 2], [\\\"C\\\", 5]],\\n    \\\"B\\\": [[\\\"A\\\", 2], [\\\"D\\\", 3], [\\\"E\\\", 1], [\\\"F\\\", 1]],\\n    \\\"C\\\": [[\\\"A\\\", 5], [\\\"F\\\", 3]],\\n    \\\"D\\\": [[\\\"B\\\", 3]],\\n    \\\"E\\\": [[\\\"B\\\", 4], [\\\"F\\\", 3]],\\n    \\\"F\\\": [[\\\"C\\\", 3], [\\\"E\\\", 3]],\\n}\\n\\nr\\\"\\\"\\\"\\nLayout of G2:\\n\\nE -- 1 --> B -- 1 --> C -- 1 --> D -- 1 --> F\\n \\\\                                         /\\\\\\n  \\\\                                        ||\\n    ----------------- 3 --------------------\\n\\\"\\\"\\\"\\nG2 = {\\n    \\\"B\\\": [[\\\"C\\\", 1]],\\n    \\\"C\\\": [[\\\"D\\\", 1]],\\n    \\\"D\\\": [[\\\"F\\\", 1]],\\n    \\\"E\\\": [[\\\"B\\\", 1], [\\\"F\\\", 3]],\\n    \\\"F\\\": [],\\n}\\n\\nr\\\"\\\"\\\"\\nLayout of G3:\\n\\nE -- 1 --> B -- 1 --> C -- 1 --> D -- 1 --> F\\n \\\\                                         /\\\\\\n  \\\\                                        ||\\n    -------- 2 ---------> G ------- 1 ------\\n\\\"\\\"\\\"\\nG3 = {\\n    \\\"B\\\": [[\\\"C\\\", 1]],\\n    \\\"C\\\": [[\\\"D\\\", 1]],\\n    \\\"D\\\": [[\\\"F\\\", 1]],\\n    \\\"E\\\": [[\\\"B\\\", 1], [\\\"G\\\", 2]],\\n    \\\"F\\\": [],\\n    \\\"G\\\": [[\\\"F\\\", 1]],\\n}\\n\\nshortDistance = dijkstra(G, \\\"E\\\", \\\"C\\\")\\nprint(shortDistance)  # E -- 3 --> F -- 3 --> C == 6\\n\\nshortDistance = dijkstra(G2, \\\"E\\\", \\\"F\\\")\\nprint(shortDistance)  # E -- 3 --> F == 3\\n\\nshortDistance = dijkstra(G3, \\\"E\\\", \\\"F\\\")\\nprint(shortDistance)  # E -- 2 --> G -- 1 --> F == 3\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "dijkstra 2": "\"def printDist(dist, V):\\n    print(\\\"\\\\nVertex Distance\\\")\\n    for i in range(V):\\n        if dist[i] != float(\\\"inf\\\"):\\n            print(i, \\\"\\\\t\\\", int(dist[i]), end=\\\"\\\\t\\\")\\n        else:\\n            print(i, \\\"\\\\t\\\", \\\"INF\\\", end=\\\"\\\\t\\\")\\n        print()\\n\\n\\ndef minDist(mdist, vset, V):\\n    minVal = float(\\\"inf\\\")\\n    minInd = -1\\n    for i in range(V):\\n        if (not vset[i]) and mdist[i] < minVal:\\n            minInd = i\\n            minVal = mdist[i]\\n    return minInd\\n\\n\\ndef Dijkstra(graph, V, src):\\n    mdist = [float(\\\"inf\\\") for i in range(V)]\\n    vset = [False for i in range(V)]\\n    mdist[src] = 0.0\\n\\n    for i in range(V - 1):\\n        u = minDist(mdist, vset, V)\\n        vset[u] = True\\n\\n        for v in range(V):\\n            if (\\n                (not vset[v])\\n                and graph[u][v] != float(\\\"inf\\\")\\n                and mdist[u] + graph[u][v] < mdist[v]\\n            ):\\n                mdist[v] = mdist[u] + graph[u][v]\\n\\n    printDist(mdist, V)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    V = int(input(\\\"Enter number of vertices: \\\").strip())\\n    E = int(input(\\\"Enter number of edges: \\\").strip())\\n\\n    graph = [[float(\\\"inf\\\") for i in range(V)] for j in range(V)]\\n\\n    for i in range(V):\\n        graph[i][i] = 0.0\\n\\n    for i in range(E):\\n        print(\\\"\\\\nEdge \\\", i + 1)\\n        src = int(input(\\\"Enter source:\\\").strip())\\n        dst = int(input(\\\"Enter destination:\\\").strip())\\n        weight = float(input(\\\"Enter weight:\\\").strip())\\n        graph[src][dst] = weight\\n\\n    gsrc = int(input(\\\"\\\\nEnter shortest path source:\\\").strip())\\n    Dijkstra(graph, V, gsrc)\\n\"",
    "dijkstra algorithm": "\"# Title: Dijkstra's Algorithm for finding single source shortest path from scratch\\n# Author: Shubham Malik\\n# References: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\\n\\nimport math\\nimport sys\\n\\n# For storing the vertex set to retrieve node with the lowest distance\\n\\n\\nclass PriorityQueue:\\n    # Based on Min Heap\\n    def __init__(self):\\n        self.cur_size = 0\\n        self.array = []\\n        self.pos = {}  # To store the pos of node in array\\n\\n    def isEmpty(self):\\n        return self.cur_size == 0\\n\\n    def min_heapify(self, idx):\\n        lc = self.left(idx)\\n        rc = self.right(idx)\\n        if lc < self.cur_size and self.array(lc)[0] < self.array(idx)[0]:\\n            smallest = lc\\n        else:\\n            smallest = idx\\n        if rc < self.cur_size and self.array(rc)[0] < self.array(smallest)[0]:\\n            smallest = rc\\n        if smallest != idx:\\n            self.swap(idx, smallest)\\n            self.min_heapify(smallest)\\n\\n    def insert(self, tup):\\n        # Inserts a node into the Priority Queue\\n        self.pos[tup[1]] = self.cur_size\\n        self.cur_size += 1\\n        self.array.append((sys.maxsize, tup[1]))\\n        self.decrease_key((sys.maxsize, tup[1]), tup[0])\\n\\n    def extract_min(self):\\n        # Removes and returns the min element at top of priority queue\\n        min_node = self.array[0][1]\\n        self.array[0] = self.array[self.cur_size - 1]\\n        self.cur_size -= 1\\n        self.min_heapify(1)\\n        del self.pos[min_node]\\n        return min_node\\n\\n    def left(self, i):\\n        # returns the index of left child\\n        return 2 * i + 1\\n\\n    def right(self, i):\\n        # returns the index of right child\\n        return 2 * i + 2\\n\\n    def par(self, i):\\n        # returns the index of parent\\n        return math.floor(i / 2)\\n\\n    def swap(self, i, j):\\n        # swaps array elements at indices i and j\\n        # update the pos{}\\n        self.pos[self.array[i][1]] = j\\n        self.pos[self.array[j][1]] = i\\n        temp = self.array[i]\\n        self.array[i] = self.array[j]\\n        self.array[j] = temp\\n\\n    def decrease_key(self, tup, new_d):\\n        idx = self.pos[tup[1]]\\n        # assuming the new_d is atmost old_d\\n        self.array[idx] = (new_d, tup[1])\\n        while idx > 0 and self.array[self.par(idx)][0] > self.array[idx][0]:\\n            self.swap(idx, self.par(idx))\\n            idx = self.par(idx)\\n\\n\\nclass Graph:\\n    def __init__(self, num):\\n        self.adjList = {}  # To store graph: u -> (v,w)\\n        self.num_nodes = num  # Number of nodes in graph\\n        # To store the distance from source vertex\\n        self.dist = [0] * self.num_nodes\\n        self.par = [-1] * self.num_nodes  # To store the path\\n\\n    def add_edge(self, u, v, w):\\n        #  Edge going from node u to v and v to u with weight w\\n        # u (w)-> v, v (w) -> u\\n        # Check if u already in graph\\n        if u in self.adjList.keys():\\n            self.adjList[u].append((v, w))\\n        else:\\n            self.adjList[u] = [(v, w)]\\n\\n        # Assuming undirected graph\\n        if v in self.adjList.keys():\\n            self.adjList[v].append((u, w))\\n        else:\\n            self.adjList[v] = [(u, w)]\\n\\n    def show_graph(self):\\n        # u -> v(w)\\n        for u in self.adjList:\\n            print(u, \\\"->\\\", \\\" -> \\\".join(str(f\\\"{v}({w})\\\") for v, w in self.adjList[u]))\\n\\n    def dijkstra(self, src):\\n        # Flush old junk values in par[]\\n        self.par = [-1] * self.num_nodes\\n        # src is the source node\\n        self.dist[src] = 0\\n        Q = PriorityQueue()\\n        Q.insert((0, src))  # (dist from src, node)\\n        for u in self.adjList.keys():\\n            if u != src:\\n                self.dist[u] = sys.maxsize  # Infinity\\n                self.par[u] = -1\\n\\n        while not Q.isEmpty():\\n            u = Q.extract_min()  # Returns node with the min dist from source\\n            # Update the distance of all the neighbours of u and\\n            # if their prev dist was INFINITY then push them in Q\\n            for v, w in self.adjList[u]:\\n                new_dist = self.dist[u] + w\\n                if self.dist[v] > new_dist:\\n                    if self.dist[v] == sys.maxsize:\\n                        Q.insert((new_dist, v))\\n                    else:\\n                        Q.decrease_key((self.dist[v], v), new_dist)\\n                    self.dist[v] = new_dist\\n                    self.par[v] = u\\n\\n        # Show the shortest distances from src\\n        self.show_distances(src)\\n\\n    def show_distances(self, src):\\n        print(f\\\"Distance from node: {src}\\\")\\n        for u in range(self.num_nodes):\\n            print(f\\\"Node {u} has distance: {self.dist[u]}\\\")\\n\\n    def show_path(self, src, dest):\\n        # To show the shortest path from src to dest\\n        # WARNING: Use it *after* calling dijkstra\\n        path = []\\n        cost = 0\\n        temp = dest\\n        # Backtracking from dest to src\\n        while self.par[temp] != -1:\\n            path.append(temp)\\n            if temp != src:\\n                for v, w in self.adjList[temp]:\\n                    if v == self.par[temp]:\\n                        cost += w\\n                        break\\n            temp = self.par[temp]\\n        path.append(src)\\n        path.reverse()\\n\\n        print(f\\\"----Path to reach {dest} from {src}----\\\")\\n        for u in path:\\n            print(f\\\"{u}\\\", end=\\\" \\\")\\n            if u != dest:\\n                print(\\\"-> \\\", end=\\\"\\\")\\n\\n        print(\\\"\\\\nTotal cost of path: \\\", cost)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    graph = Graph(9)\\n    graph.add_edge(0, 1, 4)\\n    graph.add_edge(0, 7, 8)\\n    graph.add_edge(1, 2, 8)\\n    graph.add_edge(1, 7, 11)\\n    graph.add_edge(2, 3, 7)\\n    graph.add_edge(2, 8, 2)\\n    graph.add_edge(2, 5, 4)\\n    graph.add_edge(3, 4, 9)\\n    graph.add_edge(3, 5, 14)\\n    graph.add_edge(4, 5, 10)\\n    graph.add_edge(5, 6, 2)\\n    graph.add_edge(6, 7, 1)\\n    graph.add_edge(6, 8, 6)\\n    graph.add_edge(7, 8, 7)\\n    graph.show_graph()\\n    graph.dijkstra(0)\\n    graph.show_path(0, 4)\\n\\n# OUTPUT\\n# 0 -> 1(4) -> 7(8)\\n# 1 -> 0(4) -> 2(8) -> 7(11)\\n# 7 -> 0(8) -> 1(11) -> 6(1) -> 8(7)\\n# 2 -> 1(8) -> 3(7) -> 8(2) -> 5(4)\\n# 3 -> 2(7) -> 4(9) -> 5(14)\\n# 8 -> 2(2) -> 6(6) -> 7(7)\\n# 5 -> 2(4) -> 3(14) -> 4(10) -> 6(2)\\n# 4 -> 3(9) -> 5(10)\\n# 6 -> 5(2) -> 7(1) -> 8(6)\\n# Distance from node: 0\\n# Node 0 has distance: 0\\n# Node 1 has distance: 4\\n# Node 2 has distance: 12\\n# Node 3 has distance: 19\\n# Node 4 has distance: 21\\n# Node 5 has distance: 11\\n# Node 6 has distance: 9\\n# Node 7 has distance: 8\\n# Node 8 has distance: 14\\n# ----Path to reach 4 from 0----\\n# 0 -> 7 -> 6 -> 5 -> 4\\n# Total cost of path:  21\\n\"",
    "dinic": "\"INF = float(\\\"inf\\\")\\n\\n\\nclass Dinic:\\n    def __init__(self, n):\\n        self.lvl = [0] * n\\n        self.ptr = [0] * n\\n        self.q = [0] * n\\n        self.adj = [[] for _ in range(n)]\\n\\n    \\\"\\\"\\\"\\n    Here we will add our edges containing with the following parameters:\\n    vertex closest to source, vertex closest to sink and flow capacity\\n    through that edge ...\\n    \\\"\\\"\\\"\\n\\n    def add_edge(self, a, b, c, rcap=0):\\n        self.adj[a].append([b, len(self.adj[b]), c, 0])\\n        self.adj[b].append([a, len(self.adj[a]) - 1, rcap, 0])\\n\\n    # This is a sample depth first search to be used at max_flow\\n    def depth_first_search(self, vertex, sink, flow):\\n        if vertex == sink or not flow:\\n            return flow\\n\\n        for i in range(self.ptr[vertex], len(self.adj[vertex])):\\n            e = self.adj[vertex][i]\\n            if self.lvl[e[0]] == self.lvl[vertex] + 1:\\n                p = self.depth_first_search(e[0], sink, min(flow, e[2] - e[3]))\\n                if p:\\n                    self.adj[vertex][i][3] += p\\n                    self.adj[e[0]][e[1]][3] -= p\\n                    return p\\n            self.ptr[vertex] = self.ptr[vertex] + 1\\n        return 0\\n\\n    # Here we calculate the flow that reaches the sink\\n    def max_flow(self, source, sink):\\n        flow, self.q[0] = 0, source\\n        for l in range(31):  # noqa: E741  l = 30 maybe faster for random data\\n            while True:\\n                self.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)\\n                qi, qe, self.lvl[source] = 0, 1, 1\\n                while qi < qe and not self.lvl[sink]:\\n                    v = self.q[qi]\\n                    qi += 1\\n                    for e in self.adj[v]:\\n                        if not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):\\n                            self.q[qe] = e[0]\\n                            qe += 1\\n                            self.lvl[e[0]] = self.lvl[v] + 1\\n\\n                p = self.depth_first_search(source, sink, INF)\\n                while p:\\n                    flow += p\\n                    p = self.depth_first_search(source, sink, INF)\\n\\n                if not self.lvl[sink]:\\n                    break\\n\\n        return flow\\n\\n\\n# Example to use\\n\\n\\\"\\\"\\\"\\nWill be a bipartite graph, than it has the vertices near the source(4)\\nand the vertices near the sink(4)\\n\\\"\\\"\\\"\\n# Here we make a graphs with 10 vertex(source and sink includes)\\ngraph = Dinic(10)\\nsource = 0\\nsink = 9\\n\\\"\\\"\\\"\\nNow we add the vertices next to the font in the font with 1 capacity in this edge\\n(source -> source vertices)\\n\\\"\\\"\\\"\\nfor vertex in range(1, 5):\\n    graph.add_edge(source, vertex, 1)\\n\\\"\\\"\\\"\\nWe will do the same thing for the vertices near the sink, but from vertex to sink\\n(sink vertices -> sink)\\n\\\"\\\"\\\"\\nfor vertex in range(5, 9):\\n    graph.add_edge(vertex, sink, 1)\\n\\\"\\\"\\\"\\nFinally we add the verices near the sink to the vertices near the source.\\n(source vertices -> sink vertices)\\n\\\"\\\"\\\"\\nfor vertex in range(1, 5):\\n    graph.add_edge(vertex, vertex + 4, 1)\\n\\n# Now we can know that is the maximum flow(source -> sink)\\nprint(graph.max_flow(source, sink))\\n\"",
    "directed and undirected (weighted) graph": "\"from collections import deque\\nfrom math import floor\\nfrom random import random\\nfrom time import time\\n\\n# the default weight is 1 if not assigned but all the implementation is weighted\\n\\n\\nclass DirectedGraph:\\n    def __init__(self):\\n        self.graph = {}\\n\\n    # adding vertices and edges\\n    # adding the weight is optional\\n    # handles repetition\\n    def add_pair(self, u, v, w=1):\\n        if self.graph.get(u):\\n            if self.graph[u].count([w, v]) == 0:\\n                self.graph[u].append([w, v])\\n        else:\\n            self.graph[u] = [[w, v]]\\n        if not self.graph.get(v):\\n            self.graph[v] = []\\n\\n    def all_nodes(self):\\n        return list(self.graph)\\n\\n    # handles if the input does not exist\\n    def remove_pair(self, u, v):\\n        if self.graph.get(u):\\n            for _ in self.graph[u]:\\n                if _[1] == v:\\n                    self.graph[u].remove(_)\\n\\n    # if no destination is meant the default value is -1\\n    def dfs(self, s=-2, d=-1):\\n        if s == d:\\n            return []\\n        stack = []\\n        visited = []\\n        if s == -2:\\n            s = list(self.graph)[0]\\n        stack.append(s)\\n        visited.append(s)\\n        ss = s\\n\\n        while True:\\n            # check if there is any non isolated nodes\\n            if len(self.graph[s]) != 0:\\n                ss = s\\n                for node in self.graph[s]:\\n                    if visited.count(node[1]) < 1:\\n                        if node[1] == d:\\n                            visited.append(d)\\n                            return visited\\n                        else:\\n                            stack.append(node[1])\\n                            visited.append(node[1])\\n                            ss = node[1]\\n                            break\\n\\n            # check if all the children are visited\\n            if s == ss:\\n                stack.pop()\\n                if len(stack) != 0:\\n                    s = stack[len(stack) - 1]\\n            else:\\n                s = ss\\n\\n            # check if se have reached the starting point\\n            if len(stack) == 0:\\n                return visited\\n\\n    # c is the count of nodes you want and if you leave it or pass -1 to the function\\n    # the count will be random from 10 to 10000\\n    def fill_graph_randomly(self, c=-1):\\n        if c == -1:\\n            c = floor(random() * 10000) + 10\\n        for i in range(c):\\n            # every vertex has max 100 edges\\n            for _ in range(floor(random() * 102) + 1):\\n                n = floor(random() * c) + 1\\n                if n != i:\\n                    self.add_pair(i, n, 1)\\n\\n    def bfs(self, s=-2):\\n        d = deque()\\n        visited = []\\n        if s == -2:\\n            s = list(self.graph)[0]\\n        d.append(s)\\n        visited.append(s)\\n        while d:\\n            s = d.popleft()\\n            if len(self.graph[s]) != 0:\\n                for node in self.graph[s]:\\n                    if visited.count(node[1]) < 1:\\n                        d.append(node[1])\\n                        visited.append(node[1])\\n        return visited\\n\\n    def in_degree(self, u):\\n        count = 0\\n        for x in self.graph:\\n            for y in self.graph[x]:\\n                if y[1] == u:\\n                    count += 1\\n        return count\\n\\n    def out_degree(self, u):\\n        return len(self.graph[u])\\n\\n    def topological_sort(self, s=-2):\\n        stack = []\\n        visited = []\\n        if s == -2:\\n            s = list(self.graph)[0]\\n        stack.append(s)\\n        visited.append(s)\\n        ss = s\\n        sorted_nodes = []\\n\\n        while True:\\n            # check if there is any non isolated nodes\\n            if len(self.graph[s]) != 0:\\n                ss = s\\n                for node in self.graph[s]:\\n                    if visited.count(node[1]) < 1:\\n                        stack.append(node[1])\\n                        visited.append(node[1])\\n                        ss = node[1]\\n                        break\\n\\n            # check if all the children are visited\\n            if s == ss:\\n                sorted_nodes.append(stack.pop())\\n                if len(stack) != 0:\\n                    s = stack[len(stack) - 1]\\n            else:\\n                s = ss\\n\\n            # check if se have reached the starting point\\n            if len(stack) == 0:\\n                return sorted_nodes\\n\\n    def cycle_nodes(self):\\n        stack = []\\n        visited = []\\n        s = list(self.graph)[0]\\n        stack.append(s)\\n        visited.append(s)\\n        parent = -2\\n        indirect_parents = []\\n        ss = s\\n        on_the_way_back = False\\n        anticipating_nodes = set()\\n\\n        while True:\\n            # check if there is any non isolated nodes\\n            if len(self.graph[s]) != 0:\\n                ss = s\\n                for node in self.graph[s]:\\n                    if (\\n                        visited.count(node[1]) > 0\\n                        and node[1] != parent\\n                        and indirect_parents.count(node[1]) > 0\\n                        and not on_the_way_back\\n                    ):\\n                        len_stack = len(stack) - 1\\n                        while True and len_stack >= 0:\\n                            if stack[len_stack] == node[1]:\\n                                anticipating_nodes.add(node[1])\\n                                break\\n                            else:\\n                                anticipating_nodes.add(stack[len_stack])\\n                                len_stack -= 1\\n                    if visited.count(node[1]) < 1:\\n                        stack.append(node[1])\\n                        visited.append(node[1])\\n                        ss = node[1]\\n                        break\\n\\n            # check if all the children are visited\\n            if s == ss:\\n                stack.pop()\\n                on_the_way_back = True\\n                if len(stack) != 0:\\n                    s = stack[len(stack) - 1]\\n            else:\\n                on_the_way_back = False\\n                indirect_parents.append(parent)\\n                parent = s\\n                s = ss\\n\\n            # check if se have reached the starting point\\n            if len(stack) == 0:\\n                return list(anticipating_nodes)\\n\\n    def has_cycle(self):\\n        stack = []\\n        visited = []\\n        s = list(self.graph)[0]\\n        stack.append(s)\\n        visited.append(s)\\n        parent = -2\\n        indirect_parents = []\\n        ss = s\\n        on_the_way_back = False\\n        anticipating_nodes = set()\\n\\n        while True:\\n            # check if there is any non isolated nodes\\n            if len(self.graph[s]) != 0:\\n                ss = s\\n                for node in self.graph[s]:\\n                    if (\\n                        visited.count(node[1]) > 0\\n                        and node[1] != parent\\n                        and indirect_parents.count(node[1]) > 0\\n                        and not on_the_way_back\\n                    ):\\n                        len_stack_minus_one = len(stack) - 1\\n                        while True and len_stack_minus_one >= 0:\\n                            if stack[len_stack_minus_one] == node[1]:\\n                                anticipating_nodes.add(node[1])\\n                                break\\n                            else:\\n                                return True\\n                                # TODO:The following code is unreachable.\\n                                anticipating_nodes.add(stack[len_stack_minus_one])\\n                                len_stack_minus_one -= 1\\n                    if visited.count(node[1]) < 1:\\n                        stack.append(node[1])\\n                        visited.append(node[1])\\n                        ss = node[1]\\n                        break\\n\\n            # check if all the children are visited\\n            if s == ss:\\n                stack.pop()\\n                on_the_way_back = True\\n                if len(stack) != 0:\\n                    s = stack[len(stack) - 1]\\n            else:\\n                on_the_way_back = False\\n                indirect_parents.append(parent)\\n                parent = s\\n                s = ss\\n\\n            # check if se have reached the starting point\\n            if len(stack) == 0:\\n                return False\\n\\n    def dfs_time(self, s=-2, e=-1):\\n        begin = time()\\n        self.dfs(s, e)\\n        end = time()\\n        return end - begin\\n\\n    def bfs_time(self, s=-2):\\n        begin = time()\\n        self.bfs(s)\\n        end = time()\\n        return end - begin\\n\\n\\nclass Graph:\\n    def __init__(self):\\n        self.graph = {}\\n\\n    # adding vertices and edges\\n    # adding the weight is optional\\n    # handles repetition\\n    def add_pair(self, u, v, w=1):\\n        # check if the u exists\\n        if self.graph.get(u):\\n            # if there already is a edge\\n            if self.graph[u].count([w, v]) == 0:\\n                self.graph[u].append([w, v])\\n        else:\\n            # if u does not exist\\n            self.graph[u] = [[w, v]]\\n        # add the other way\\n        if self.graph.get(v):\\n            # if there already is a edge\\n            if self.graph[v].count([w, u]) == 0:\\n                self.graph[v].append([w, u])\\n        else:\\n            # if u does not exist\\n            self.graph[v] = [[w, u]]\\n\\n    # handles if the input does not exist\\n    def remove_pair(self, u, v):\\n        if self.graph.get(u):\\n            for _ in self.graph[u]:\\n                if _[1] == v:\\n                    self.graph[u].remove(_)\\n        # the other way round\\n        if self.graph.get(v):\\n            for _ in self.graph[v]:\\n                if _[1] == u:\\n                    self.graph[v].remove(_)\\n\\n    # if no destination is meant the default value is -1\\n    def dfs(self, s=-2, d=-1):\\n        if s == d:\\n            return []\\n        stack = []\\n        visited = []\\n        if s == -2:\\n            s = list(self.graph)[0]\\n        stack.append(s)\\n        visited.append(s)\\n        ss = s\\n\\n        while True:\\n            # check if there is any non isolated nodes\\n            if len(self.graph[s]) != 0:\\n                ss = s\\n                for node in self.graph[s]:\\n                    if visited.count(node[1]) < 1:\\n                        if node[1] == d:\\n                            visited.append(d)\\n                            return visited\\n                        else:\\n                            stack.append(node[1])\\n                            visited.append(node[1])\\n                            ss = node[1]\\n                            break\\n\\n            # check if all the children are visited\\n            if s == ss:\\n                stack.pop()\\n                if len(stack) != 0:\\n                    s = stack[len(stack) - 1]\\n            else:\\n                s = ss\\n\\n            # check if se have reached the starting point\\n            if len(stack) == 0:\\n                return visited\\n\\n    # c is the count of nodes you want and if you leave it or pass -1 to the function\\n    # the count will be random from 10 to 10000\\n    def fill_graph_randomly(self, c=-1):\\n        if c == -1:\\n            c = floor(random() * 10000) + 10\\n        for i in range(c):\\n            # every vertex has max 100 edges\\n            for _ in range(floor(random() * 102) + 1):\\n                n = floor(random() * c) + 1\\n                if n != i:\\n                    self.add_pair(i, n, 1)\\n\\n    def bfs(self, s=-2):\\n        d = deque()\\n        visited = []\\n        if s == -2:\\n            s = list(self.graph)[0]\\n        d.append(s)\\n        visited.append(s)\\n        while d:\\n            s = d.popleft()\\n            if len(self.graph[s]) != 0:\\n                for node in self.graph[s]:\\n                    if visited.count(node[1]) < 1:\\n                        d.append(node[1])\\n                        visited.append(node[1])\\n        return visited\\n\\n    def degree(self, u):\\n        return len(self.graph[u])\\n\\n    def cycle_nodes(self):\\n        stack = []\\n        visited = []\\n        s = list(self.graph)[0]\\n        stack.append(s)\\n        visited.append(s)\\n        parent = -2\\n        indirect_parents = []\\n        ss = s\\n        on_the_way_back = False\\n        anticipating_nodes = set()\\n\\n        while True:\\n            # check if there is any non isolated nodes\\n            if len(self.graph[s]) != 0:\\n                ss = s\\n                for node in self.graph[s]:\\n                    if (\\n                        visited.count(node[1]) > 0\\n                        and node[1] != parent\\n                        and indirect_parents.count(node[1]) > 0\\n                        and not on_the_way_back\\n                    ):\\n                        len_stack = len(stack) - 1\\n                        while True and len_stack >= 0:\\n                            if stack[len_stack] == node[1]:\\n                                anticipating_nodes.add(node[1])\\n                                break\\n                            else:\\n                                anticipating_nodes.add(stack[len_stack])\\n                                len_stack -= 1\\n                    if visited.count(node[1]) < 1:\\n                        stack.append(node[1])\\n                        visited.append(node[1])\\n                        ss = node[1]\\n                        break\\n\\n            # check if all the children are visited\\n            if s == ss:\\n                stack.pop()\\n                on_the_way_back = True\\n                if len(stack) != 0:\\n                    s = stack[len(stack) - 1]\\n            else:\\n                on_the_way_back = False\\n                indirect_parents.append(parent)\\n                parent = s\\n                s = ss\\n\\n            # check if se have reached the starting point\\n            if len(stack) == 0:\\n                return list(anticipating_nodes)\\n\\n    def has_cycle(self):\\n        stack = []\\n        visited = []\\n        s = list(self.graph)[0]\\n        stack.append(s)\\n        visited.append(s)\\n        parent = -2\\n        indirect_parents = []\\n        ss = s\\n        on_the_way_back = False\\n        anticipating_nodes = set()\\n\\n        while True:\\n            # check if there is any non isolated nodes\\n            if len(self.graph[s]) != 0:\\n                ss = s\\n                for node in self.graph[s]:\\n                    if (\\n                        visited.count(node[1]) > 0\\n                        and node[1] != parent\\n                        and indirect_parents.count(node[1]) > 0\\n                        and not on_the_way_back\\n                    ):\\n                        len_stack_minus_one = len(stack) - 1\\n                        while True and len_stack_minus_one >= 0:\\n                            if stack[len_stack_minus_one] == node[1]:\\n                                anticipating_nodes.add(node[1])\\n                                break\\n                            else:\\n                                return True\\n                                # TODO: the following code is unreachable\\n                                # is this meant to be called in the else ?\\n                                anticipating_nodes.add(stack[len_stack_minus_one])\\n                                len_stack_minus_one -= 1\\n                    if visited.count(node[1]) < 1:\\n                        stack.append(node[1])\\n                        visited.append(node[1])\\n                        ss = node[1]\\n                        break\\n\\n            # check if all the children are visited\\n            if s == ss:\\n                stack.pop()\\n                on_the_way_back = True\\n                if len(stack) != 0:\\n                    s = stack[len(stack) - 1]\\n            else:\\n                on_the_way_back = False\\n                indirect_parents.append(parent)\\n                parent = s\\n                s = ss\\n\\n            # check if se have reached the starting point\\n            if len(stack) == 0:\\n                return False\\n\\n    def all_nodes(self):\\n        return list(self.graph)\\n\\n    def dfs_time(self, s=-2, e=-1):\\n        begin = time()\\n        self.dfs(s, e)\\n        end = time()\\n        return end - begin\\n\\n    def bfs_time(self, s=-2):\\n        begin = time()\\n        self.bfs(s)\\n        end = time()\\n        return end - begin\\n\"",
    "edmonds karp multiple source and sink": "\"class FlowNetwork:\\n    def __init__(self, graph, sources, sinks):\\n        self.sourceIndex = None\\n        self.sinkIndex = None\\n        self.graph = graph\\n\\n        self._normalizeGraph(sources, sinks)\\n        self.verticesCount = len(graph)\\n        self.maximumFlowAlgorithm = None\\n\\n    # make only one source and one sink\\n    def _normalizeGraph(self, sources, sinks):\\n        if sources is int:\\n            sources = [sources]\\n        if sinks is int:\\n            sinks = [sinks]\\n\\n        if len(sources) == 0 or len(sinks) == 0:\\n            return\\n\\n        self.sourceIndex = sources[0]\\n        self.sinkIndex = sinks[0]\\n\\n        # make fake vertex if there are more\\n        # than one source or sink\\n        if len(sources) > 1 or len(sinks) > 1:\\n            maxInputFlow = 0\\n            for i in sources:\\n                maxInputFlow += sum(self.graph[i])\\n\\n            size = len(self.graph) + 1\\n            for room in self.graph:\\n                room.insert(0, 0)\\n            self.graph.insert(0, [0] * size)\\n            for i in sources:\\n                self.graph[0][i + 1] = maxInputFlow\\n            self.sourceIndex = 0\\n\\n            size = len(self.graph) + 1\\n            for room in self.graph:\\n                room.append(0)\\n            self.graph.append([0] * size)\\n            for i in sinks:\\n                self.graph[i + 1][size - 1] = maxInputFlow\\n            self.sinkIndex = size - 1\\n\\n    def findMaximumFlow(self):\\n        if self.maximumFlowAlgorithm is None:\\n            raise Exception(\\\"You need to set maximum flow algorithm before.\\\")\\n        if self.sourceIndex is None or self.sinkIndex is None:\\n            return 0\\n\\n        self.maximumFlowAlgorithm.execute()\\n        return self.maximumFlowAlgorithm.getMaximumFlow()\\n\\n    def setMaximumFlowAlgorithm(self, Algorithm):\\n        self.maximumFlowAlgorithm = Algorithm(self)\\n\\n\\nclass FlowNetworkAlgorithmExecutor:\\n    def __init__(self, flowNetwork):\\n        self.flowNetwork = flowNetwork\\n        self.verticesCount = flowNetwork.verticesCount\\n        self.sourceIndex = flowNetwork.sourceIndex\\n        self.sinkIndex = flowNetwork.sinkIndex\\n        # it's just a reference, so you shouldn't change\\n        # it in your algorithms, use deep copy before doing that\\n        self.graph = flowNetwork.graph\\n        self.executed = False\\n\\n    def execute(self):\\n        if not self.executed:\\n            self._algorithm()\\n            self.executed = True\\n\\n    # You should override it\\n    def _algorithm(self):\\n        pass\\n\\n\\nclass MaximumFlowAlgorithmExecutor(FlowNetworkAlgorithmExecutor):\\n    def __init__(self, flowNetwork):\\n        super().__init__(flowNetwork)\\n        # use this to save your result\\n        self.maximumFlow = -1\\n\\n    def getMaximumFlow(self):\\n        if not self.executed:\\n            raise Exception(\\\"You should execute algorithm before using its result!\\\")\\n\\n        return self.maximumFlow\\n\\n\\nclass PushRelabelExecutor(MaximumFlowAlgorithmExecutor):\\n    def __init__(self, flowNetwork):\\n        super().__init__(flowNetwork)\\n\\n        self.preflow = [[0] * self.verticesCount for i in range(self.verticesCount)]\\n\\n        self.heights = [0] * self.verticesCount\\n        self.excesses = [0] * self.verticesCount\\n\\n    def _algorithm(self):\\n        self.heights[self.sourceIndex] = self.verticesCount\\n\\n        # push some substance to graph\\n        for nextVertexIndex, bandwidth in enumerate(self.graph[self.sourceIndex]):\\n            self.preflow[self.sourceIndex][nextVertexIndex] += bandwidth\\n            self.preflow[nextVertexIndex][self.sourceIndex] -= bandwidth\\n            self.excesses[nextVertexIndex] += bandwidth\\n\\n        # Relabel-to-front selection rule\\n        verticesList = [\\n            i\\n            for i in range(self.verticesCount)\\n            if i != self.sourceIndex and i != self.sinkIndex\\n        ]\\n\\n        # move through list\\n        i = 0\\n        while i < len(verticesList):\\n            vertexIndex = verticesList[i]\\n            previousHeight = self.heights[vertexIndex]\\n            self.processVertex(vertexIndex)\\n            if self.heights[vertexIndex] > previousHeight:\\n                # if it was relabeled, swap elements\\n                # and start from 0 index\\n                verticesList.insert(0, verticesList.pop(i))\\n                i = 0\\n            else:\\n                i += 1\\n\\n        self.maximumFlow = sum(self.preflow[self.sourceIndex])\\n\\n    def processVertex(self, vertexIndex):\\n        while self.excesses[vertexIndex] > 0:\\n            for neighbourIndex in range(self.verticesCount):\\n                # if it's neighbour and current vertex is higher\\n                if (\\n                    self.graph[vertexIndex][neighbourIndex]\\n                    - self.preflow[vertexIndex][neighbourIndex]\\n                    > 0\\n                    and self.heights[vertexIndex] > self.heights[neighbourIndex]\\n                ):\\n                    self.push(vertexIndex, neighbourIndex)\\n\\n            self.relabel(vertexIndex)\\n\\n    def push(self, fromIndex, toIndex):\\n        preflowDelta = min(\\n            self.excesses[fromIndex],\\n            self.graph[fromIndex][toIndex] - self.preflow[fromIndex][toIndex],\\n        )\\n        self.preflow[fromIndex][toIndex] += preflowDelta\\n        self.preflow[toIndex][fromIndex] -= preflowDelta\\n        self.excesses[fromIndex] -= preflowDelta\\n        self.excesses[toIndex] += preflowDelta\\n\\n    def relabel(self, vertexIndex):\\n        minHeight = None\\n        for toIndex in range(self.verticesCount):\\n            if (\\n                self.graph[vertexIndex][toIndex] - self.preflow[vertexIndex][toIndex]\\n                > 0\\n            ):\\n                if minHeight is None or self.heights[toIndex] < minHeight:\\n                    minHeight = self.heights[toIndex]\\n\\n        if minHeight is not None:\\n            self.heights[vertexIndex] = minHeight + 1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    entrances = [0]\\n    exits = [3]\\n    # graph = [\\n    #     [0, 0, 4, 6, 0, 0],\\n    #     [0, 0, 5, 2, 0, 0],\\n    #     [0, 0, 0, 0, 4, 4],\\n    #     [0, 0, 0, 0, 6, 6],\\n    #     [0, 0, 0, 0, 0, 0],\\n    #     [0, 0, 0, 0, 0, 0],\\n    # ]\\n    graph = [[0, 7, 0, 0], [0, 0, 6, 0], [0, 0, 0, 8], [9, 0, 0, 0]]\\n\\n    # prepare our network\\n    flowNetwork = FlowNetwork(graph, entrances, exits)\\n    # set algorithm\\n    flowNetwork.setMaximumFlowAlgorithm(PushRelabelExecutor)\\n    # and calculate\\n    maximumFlow = flowNetwork.findMaximumFlow()\\n\\n    print(f\\\"maximum flow is {maximumFlow}\\\")\\n\"",
    "eulerian path and circuit for undirected graph": "\"# Eulerian Path is a path in graph that visits every edge exactly once.\\n# Eulerian Circuit is an Eulerian Path which starts and ends on the same\\n# vertex.\\n# time complexity is O(V+E)\\n# space complexity is O(VE)\\n\\n\\n# using dfs for finding eulerian path traversal\\ndef dfs(u, graph, visited_edge, path=None):\\n    path = (path or []) + [u]\\n    for v in graph[u]:\\n        if visited_edge[u][v] is False:\\n            visited_edge[u][v], visited_edge[v][u] = True, True\\n            path = dfs(v, graph, visited_edge, path)\\n    return path\\n\\n\\n# for checking in graph has euler path or circuit\\ndef check_circuit_or_path(graph, max_node):\\n    odd_degree_nodes = 0\\n    odd_node = -1\\n    for i in range(max_node):\\n        if i not in graph.keys():\\n            continue\\n        if len(graph[i]) % 2 == 1:\\n            odd_degree_nodes += 1\\n            odd_node = i\\n    if odd_degree_nodes == 0:\\n        return 1, odd_node\\n    if odd_degree_nodes == 2:\\n        return 2, odd_node\\n    return 3, odd_node\\n\\n\\ndef check_euler(graph, max_node):\\n    visited_edge = [[False for _ in range(max_node + 1)] for _ in range(max_node + 1)]\\n    check, odd_node = check_circuit_or_path(graph, max_node)\\n    if check == 3:\\n        print(\\\"graph is not Eulerian\\\")\\n        print(\\\"no path\\\")\\n        return\\n    start_node = 1\\n    if check == 2:\\n        start_node = odd_node\\n        print(\\\"graph has a Euler path\\\")\\n    if check == 1:\\n        print(\\\"graph has a Euler cycle\\\")\\n    path = dfs(start_node, graph, visited_edge)\\n    print(path)\\n\\n\\ndef main():\\n    G1 = {1: [2, 3, 4], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [4]}\\n    G2 = {1: [2, 3, 4, 5], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [1, 4]}\\n    G3 = {1: [2, 3, 4], 2: [1, 3, 4], 3: [1, 2], 4: [1, 2, 5], 5: [4]}\\n    G4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}\\n    G5 = {\\n        1: [],\\n        2: []\\n        # all degree is zero\\n    }\\n    max_node = 10\\n    check_euler(G1, max_node)\\n    check_euler(G2, max_node)\\n    check_euler(G3, max_node)\\n    check_euler(G4, max_node)\\n    check_euler(G5, max_node)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "even tree": "\"\\\"\\\"\\\"\\nYou are given a tree(a simple connected graph with no cycles). The tree has N\\nnodes numbered from 1 to N and is rooted at node 1.\\n\\nFind the maximum number of edges you can remove from the tree to get a forest\\nsuch that each connected component of the forest contains an even number of\\nnodes.\\n\\nConstraints\\n2 <= 2 <= 100\\n\\nNote: The tree input will be such that it can always be decomposed into\\ncomponents containing an even number of nodes.\\n\\\"\\\"\\\"\\n# pylint: disable=invalid-name\\nfrom collections import defaultdict\\n\\n\\ndef dfs(start: int) -> int:\\n    \\\"\\\"\\\"DFS traversal\\\"\\\"\\\"\\n    # pylint: disable=redefined-outer-name\\n    ret = 1\\n    visited[start] = True\\n    for v in tree[start]:\\n        if v not in visited:\\n            ret += dfs(v)\\n    if ret % 2 == 0:\\n        cuts.append(start)\\n    return ret\\n\\n\\ndef even_tree():\\n    \\\"\\\"\\\"\\n    2 1\\n    3 1\\n    4 3\\n    5 2\\n    6 1\\n    7 2\\n    8 6\\n    9 8\\n    10 8\\n    On removing edges (1,3) and (1,6), we can get the desired result 2.\\n    \\\"\\\"\\\"\\n    dfs(1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    n, m = 10, 9\\n    tree = defaultdict(list)\\n    visited: dict[int, bool] = {}\\n    cuts: list[int] = []\\n    count = 0\\n    edges = [(2, 1), (3, 1), (4, 3), (5, 2), (6, 1), (7, 2), (8, 6), (9, 8), (10, 8)]\\n    for u, v in edges:\\n        tree[u].append(v)\\n        tree[v].append(u)\\n    even_tree()\\n    print(len(cuts) - 1)\\n\"",
    "finding bridges": "\"\\\"\\\"\\\"\\nAn edge is a bridge if, after removing it count of connected components in graph will\\nbe increased by one. Bridges represent vulnerabilities in a connected network and are\\nuseful for designing reliable networks. For example, in a wired computer network, an\\narticulation point indicates the critical computers and a bridge indicates the critical\\nwires or connections.\\n\\nFor more details, refer this article:\\nhttps://www.geeksforgeeks.org/bridge-in-a-graph/\\n\\\"\\\"\\\"\\n\\n\\ndef __get_demo_graph(index):\\n    return [\\n        {\\n            0: [1, 2],\\n            1: [0, 2],\\n            2: [0, 1, 3, 5],\\n            3: [2, 4],\\n            4: [3],\\n            5: [2, 6, 8],\\n            6: [5, 7],\\n            7: [6, 8],\\n            8: [5, 7],\\n        },\\n        {\\n            0: [6],\\n            1: [9],\\n            2: [4, 5],\\n            3: [4],\\n            4: [2, 3],\\n            5: [2],\\n            6: [0, 7],\\n            7: [6],\\n            8: [],\\n            9: [1],\\n        },\\n        {\\n            0: [4],\\n            1: [6],\\n            2: [],\\n            3: [5, 6, 7],\\n            4: [0, 6],\\n            5: [3, 8, 9],\\n            6: [1, 3, 4, 7],\\n            7: [3, 6, 8, 9],\\n            8: [5, 7],\\n            9: [5, 7],\\n        },\\n        {\\n            0: [1, 3],\\n            1: [0, 2, 4],\\n            2: [1, 3, 4],\\n            3: [0, 2, 4],\\n            4: [1, 2, 3],\\n        },\\n    ][index]\\n\\n\\ndef compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:\\n    \\\"\\\"\\\"\\n    Return the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi\\n    >>> compute_bridges(__get_demo_graph(0))\\n    [(3, 4), (2, 3), (2, 5)]\\n    >>> compute_bridges(__get_demo_graph(1))\\n    [(6, 7), (0, 6), (1, 9), (3, 4), (2, 4), (2, 5)]\\n    >>> compute_bridges(__get_demo_graph(2))\\n    [(1, 6), (4, 6), (0, 4)]\\n    >>> compute_bridges(__get_demo_graph(3))\\n    []\\n    >>> compute_bridges({})\\n    []\\n    \\\"\\\"\\\"\\n\\n    id = 0\\n    n = len(graph)  # No of vertices in graph\\n    low = [0] * n\\n    visited = [False] * n\\n\\n    def dfs(at, parent, bridges, id):\\n        visited[at] = True\\n        low[at] = id\\n        id += 1\\n        for to in graph[at]:\\n            if to == parent:\\n                pass\\n            elif not visited[to]:\\n                dfs(to, at, bridges, id)\\n                low[at] = min(low[at], low[to])\\n                if id <= low[to]:\\n                    bridges.append((at, to) if at < to else (to, at))\\n            else:\\n                # This edge is a back edge and cannot be a bridge\\n                low[at] = min(low[at], low[to])\\n\\n    bridges: list[tuple[int, int]] = []\\n    for i in range(n):\\n        if not visited[i]:\\n            dfs(i, -1, bridges, id)\\n    return bridges\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "frequent pattern graph miner": "\"\\\"\\\"\\\"\\r\\nFP-GraphMiner - A Fast Frequent Pattern Mining Algorithm for Network Graphs\\r\\n\\r\\nA novel Frequent Pattern Graph Mining algorithm, FP-GraphMiner, that compactly\\r\\nrepresents a set of network graphs as a Frequent Pattern Graph (or FP-Graph).\\r\\nThis graph can be used to efficiently mine frequent subgraphs including maximal\\r\\nfrequent subgraphs and maximum common subgraphs.\\r\\n\\r\\nURL: https://www.researchgate.net/publication/235255851\\r\\n\\\"\\\"\\\"\\r\\n# fmt: off\\r\\nedge_array = [\\r\\n    ['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12', 'cd-e2', 'ce-e4',\\r\\n     'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3', 'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3'],\\r\\n    ['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'cd-e2', 'de-e1', 'df-e8',\\r\\n     'ef-e3', 'eg-e2', 'fg-e6'],\\r\\n    ['ab-e1', 'ac-e3', 'bc-e4', 'bd-e2', 'de-e1', 'df-e8', 'dg-e5', 'ef-e3', 'eg-e2',\\r\\n     'eh-e12', 'fg-e6', 'fh-e10', 'gh-e6'],\\r\\n    ['ab-e1', 'ac-e3', 'bc-e4', 'bd-e2', 'bh-e12', 'cd-e2', 'df-e8', 'dh-e10'],\\r\\n    ['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'cd-e2', 'ce-e4', 'de-e1', 'df-e8',\\r\\n     'dg-e5', 'ef-e3', 'eg-e2', 'fg-e6']\\r\\n]\\r\\n# fmt: on\\r\\n\\r\\n\\r\\ndef get_distinct_edge(edge_array):\\r\\n    \\\"\\\"\\\"\\r\\n    Return Distinct edges from edge array of multiple graphs\\r\\n    >>> sorted(get_distinct_edge(edge_array))\\r\\n    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\\r\\n    \\\"\\\"\\\"\\r\\n    distinct_edge = set()\\r\\n    for row in edge_array:\\r\\n        for item in row:\\r\\n            distinct_edge.add(item[0])\\r\\n    return list(distinct_edge)\\r\\n\\r\\n\\r\\ndef get_bitcode(edge_array, distinct_edge):\\r\\n    \\\"\\\"\\\"\\r\\n    Return bitcode of distinct_edge\\r\\n    \\\"\\\"\\\"\\r\\n    bitcode = [\\\"0\\\"] * len(edge_array)\\r\\n    for i, row in enumerate(edge_array):\\r\\n        for item in row:\\r\\n            if distinct_edge in item[0]:\\r\\n                bitcode[i] = \\\"1\\\"\\r\\n                break\\r\\n    return \\\"\\\".join(bitcode)\\r\\n\\r\\n\\r\\ndef get_frequency_table(edge_array):\\r\\n    \\\"\\\"\\\"\\r\\n    Returns Frequency Table\\r\\n    \\\"\\\"\\\"\\r\\n    distinct_edge = get_distinct_edge(edge_array)\\r\\n    frequency_table = dict()\\r\\n\\r\\n    for item in distinct_edge:\\r\\n        bit = get_bitcode(edge_array, item)\\r\\n        # print('bit',bit)\\r\\n        # bt=''.join(bit)\\r\\n        s = bit.count(\\\"1\\\")\\r\\n        frequency_table[item] = [s, bit]\\r\\n    # Store [Distinct edge, WT(Bitcode), Bitcode] in descending order\\r\\n    sorted_frequency_table = [\\r\\n        [k, v[0], v[1]]\\r\\n        for k, v in sorted(frequency_table.items(), key=lambda v: v[1][0], reverse=True)\\r\\n    ]\\r\\n    return sorted_frequency_table\\r\\n\\r\\n\\r\\ndef get_nodes(frequency_table):\\r\\n    \\\"\\\"\\\"\\r\\n    Returns nodes\\r\\n    format nodes={bitcode:edges that represent the bitcode}\\r\\n    >>> get_nodes([['ab', 5, '11111'], ['ac', 5, '11111'], ['df', 5, '11111'],\\r\\n    ...            ['bd', 5, '11111'], ['bc', 5, '11111']])\\r\\n    {'11111': ['ab', 'ac', 'df', 'bd', 'bc']}\\r\\n    \\\"\\\"\\\"\\r\\n    nodes = {}\\r\\n    for i, item in enumerate(frequency_table):\\r\\n        nodes.setdefault(item[2], []).append(item[0])\\r\\n    return nodes\\r\\n\\r\\n\\r\\ndef get_cluster(nodes):\\r\\n    \\\"\\\"\\\"\\r\\n    Returns cluster\\r\\n    format cluster:{WT(bitcode):nodes with same WT}\\r\\n    \\\"\\\"\\\"\\r\\n    cluster = {}\\r\\n    for key, value in nodes.items():\\r\\n        cluster.setdefault(key.count(\\\"1\\\"), {})[key] = value\\r\\n    return cluster\\r\\n\\r\\n\\r\\ndef get_support(cluster):\\r\\n    \\\"\\\"\\\"\\r\\n    Returns support\\r\\n    >>> get_support({5: {'11111': ['ab', 'ac', 'df', 'bd', 'bc']},\\r\\n    ...              4: {'11101': ['ef', 'eg', 'de', 'fg'], '11011': ['cd']},\\r\\n    ...              3: {'11001': ['ad'], '10101': ['dg']},\\r\\n    ...              2: {'10010': ['dh', 'bh'], '11000': ['be'], '10100': ['gh'],\\r\\n    ...                  '10001': ['ce']},\\r\\n    ...              1: {'00100': ['fh', 'eh'], '10000': ['hi']}})\\r\\n    [100.0, 80.0, 60.0, 40.0, 20.0]\\r\\n    \\\"\\\"\\\"\\r\\n    return [i * 100 / len(cluster) for i in cluster]\\r\\n\\r\\n\\r\\ndef print_all() -> None:\\r\\n    print(\\\"\\\\nNodes\\\\n\\\")\\r\\n    for key, value in nodes.items():\\r\\n        print(key, value)\\r\\n    print(\\\"\\\\nSupport\\\\n\\\")\\r\\n    print(support)\\r\\n    print(\\\"\\\\n Cluster \\\\n\\\")\\r\\n    for key, value in sorted(cluster.items(), reverse=True):\\r\\n        print(key, value)\\r\\n    print(\\\"\\\\n Graph\\\\n\\\")\\r\\n    for key, value in graph.items():\\r\\n        print(key, value)\\r\\n    print(\\\"\\\\n Edge List of Frequent subgraphs \\\\n\\\")\\r\\n    for edge_list in freq_subgraph_edge_list:\\r\\n        print(edge_list)\\r\\n\\r\\n\\r\\ndef create_edge(nodes, graph, cluster, c1):\\r\\n    \\\"\\\"\\\"\\r\\n    create edge between the nodes\\r\\n    \\\"\\\"\\\"\\r\\n    for i in cluster[c1].keys():\\r\\n        count = 0\\r\\n        c2 = c1 + 1\\r\\n        while c2 < max(cluster.keys()):\\r\\n            for j in cluster[c2].keys():\\r\\n                \\\"\\\"\\\"\\r\\n                creates edge only if the condition satisfies\\r\\n                \\\"\\\"\\\"\\r\\n                if int(i, 2) & int(j, 2) == int(i, 2):\\r\\n                    if tuple(nodes[i]) in graph:\\r\\n                        graph[tuple(nodes[i])].append(nodes[j])\\r\\n                    else:\\r\\n                        graph[tuple(nodes[i])] = [nodes[j]]\\r\\n                    count += 1\\r\\n            if count == 0:\\r\\n                c2 = c2 + 1\\r\\n            else:\\r\\n                break\\r\\n\\r\\n\\r\\ndef construct_graph(cluster, nodes):\\r\\n    X = cluster[max(cluster.keys())]\\r\\n    cluster[max(cluster.keys()) + 1] = \\\"Header\\\"\\r\\n    graph = {}\\r\\n    for i in X:\\r\\n        if tuple([\\\"Header\\\"]) in graph:\\r\\n            graph[tuple([\\\"Header\\\"])].append(X[i])\\r\\n        else:\\r\\n            graph[tuple([\\\"Header\\\"])] = [X[i]]\\r\\n    for i in X:\\r\\n        graph[tuple(X[i])] = [[\\\"Header\\\"]]\\r\\n    i = 1\\r\\n    while i < max(cluster) - 1:\\r\\n        create_edge(nodes, graph, cluster, i)\\r\\n        i = i + 1\\r\\n    return graph\\r\\n\\r\\n\\r\\ndef myDFS(graph, start, end, path=None):\\r\\n    \\\"\\\"\\\"\\r\\n    find different DFS walk from given node to Header node\\r\\n    \\\"\\\"\\\"\\r\\n    path = (path or []) + [start]\\r\\n    if start == end:\\r\\n        paths.append(path)\\r\\n    for node in graph[start]:\\r\\n        if tuple(node) not in path:\\r\\n            myDFS(graph, tuple(node), end, path)\\r\\n\\r\\n\\r\\ndef find_freq_subgraph_given_support(s, cluster, graph):\\r\\n    \\\"\\\"\\\"\\r\\n    find edges of multiple frequent subgraphs\\r\\n    \\\"\\\"\\\"\\r\\n    k = int(s / 100 * (len(cluster) - 1))\\r\\n    for i in cluster[k].keys():\\r\\n        myDFS(graph, tuple(cluster[k][i]), tuple([\\\"Header\\\"]))\\r\\n\\r\\n\\r\\ndef freq_subgraphs_edge_list(paths):\\r\\n    \\\"\\\"\\\"\\r\\n    returns Edge list for frequent subgraphs\\r\\n    \\\"\\\"\\\"\\r\\n    freq_sub_EL = []\\r\\n    for edges in paths:\\r\\n        EL = []\\r\\n        for j in range(len(edges) - 1):\\r\\n            temp = list(edges[j])\\r\\n            for e in temp:\\r\\n                edge = (e[0], e[1])\\r\\n                EL.append(edge)\\r\\n        freq_sub_EL.append(EL)\\r\\n    return freq_sub_EL\\r\\n\\r\\n\\r\\ndef preprocess(edge_array):\\r\\n    \\\"\\\"\\\"\\r\\n    Preprocess the edge array\\r\\n    >>> preprocess([['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12',\\r\\n    ...              'cd-e2', 'ce-e4', 'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3',\\r\\n    ...              'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3']])\\r\\n\\r\\n    \\\"\\\"\\\"\\r\\n    for i in range(len(edge_array)):\\r\\n        for j in range(len(edge_array[i])):\\r\\n            t = edge_array[i][j].split(\\\"-\\\")\\r\\n            edge_array[i][j] = t\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    preprocess(edge_array)\\r\\n    frequency_table = get_frequency_table(edge_array)\\r\\n    nodes = get_nodes(frequency_table)\\r\\n    cluster = get_cluster(nodes)\\r\\n    support = get_support(cluster)\\r\\n    graph = construct_graph(cluster, nodes)\\r\\n    find_freq_subgraph_given_support(60, cluster, graph)\\r\\n    paths: list = []\\r\\n    freq_subgraph_edge_list = freq_subgraphs_edge_list(paths)\\r\\n    print_all()\\r\\n\"",
    "gale shapley bigraph": "\"from __future__ import annotations\\n\\n\\ndef stable_matching(\\n    donor_pref: list[list[int]], recipient_pref: list[list[int]]\\n) -> list[int]:\\n    \\\"\\\"\\\"\\n    Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects\\n    prefer each other over their partner.  The function accepts the preferences of\\n    oegan donors and recipients (where both are assigned numbers from 0 to n-1) and\\n    returns a list where the index position corresponds to the donor and value at the\\n    index is the organ recipient.\\n\\n    To better understand the algorithm, see also:\\n    https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).\\n    https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).\\n\\n    >>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]\\n    >>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]\\n    >>> print(stable_matching(donor_pref, recipient_pref))\\n    [1, 2, 3, 0]\\n    \\\"\\\"\\\"\\n    assert len(donor_pref) == len(recipient_pref)\\n\\n    n = len(donor_pref)\\n    unmatched_donors = list(range(n))\\n    donor_record = [-1] * n  # who the donor has donated to\\n    rec_record = [-1] * n  # who the recipient has received from\\n    num_donations = [0] * n\\n\\n    while unmatched_donors:\\n        donor = unmatched_donors[0]\\n        donor_preference = donor_pref[donor]\\n        recipient = donor_preference[num_donations[donor]]\\n        num_donations[donor] += 1\\n        rec_preference = recipient_pref[recipient]\\n        prev_donor = rec_record[recipient]\\n\\n        if prev_donor != -1:\\n            if rec_preference.index(prev_donor) > rec_preference.index(donor):\\n                rec_record[recipient] = donor\\n                donor_record[donor] = recipient\\n                unmatched_donors.append(prev_donor)\\n                unmatched_donors.remove(donor)\\n        else:\\n            rec_record[recipient] = donor\\n            donor_record[donor] = recipient\\n            unmatched_donors.remove(donor)\\n    return donor_record\\n\"",
    "graphs floyd warshall": "\"# floyd_warshall.py\\n\\\"\\\"\\\"\\n    The problem is to find the shortest distance between all pairs of vertices in a\\n    weighted directed graph that can have negative edge weights.\\n\\\"\\\"\\\"\\n\\n\\ndef _print_dist(dist, v):\\n    print(\\\"\\\\nThe shortest path matrix using Floyd Warshall algorithm\\\\n\\\")\\n    for i in range(v):\\n        for j in range(v):\\n            if dist[i][j] != float(\\\"inf\\\"):\\n                print(int(dist[i][j]), end=\\\"\\\\t\\\")\\n            else:\\n                print(\\\"INF\\\", end=\\\"\\\\t\\\")\\n        print()\\n\\n\\ndef floyd_warshall(graph, v):\\n    \\\"\\\"\\\"\\n    :param graph: 2D array calculated from weight[edge[i, j]]\\n    :type graph: List[List[float]]\\n    :param v: number of vertices\\n    :type v: int\\n    :return: shortest distance between all vertex pairs\\n    distance[u][v] will contain the shortest distance from vertex u to v.\\n\\n    1. For all edges from v to n, distance[i][j] = weight(edge(i, j)).\\n    3. The algorithm then performs distance[i][j] = min(distance[i][j], distance[i][k] +\\n        distance[k][j]) for each possible pair i, j of vertices.\\n    4. The above is repeated for each vertex k in the graph.\\n    5. Whenever distance[i][j] is given a new minimum value, next vertex[i][j] is\\n        updated to the next vertex[i][k].\\n    \\\"\\\"\\\"\\n\\n    dist = [[float(\\\"inf\\\") for _ in range(v)] for _ in range(v)]\\n\\n    for i in range(v):\\n        for j in range(v):\\n            dist[i][j] = graph[i][j]\\n\\n            # check vertex k against all other vertices (i, j)\\n    for k in range(v):\\n        # looping through rows of graph array\\n        for i in range(v):\\n            # looping through columns of graph array\\n            for j in range(v):\\n                if (\\n                    dist[i][k] != float(\\\"inf\\\")\\n                    and dist[k][j] != float(\\\"inf\\\")\\n                    and dist[i][k] + dist[k][j] < dist[i][j]\\n                ):\\n                    dist[i][j] = dist[i][k] + dist[k][j]\\n\\n    _print_dist(dist, v)\\n    return dist, v\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    v = int(input(\\\"Enter number of vertices: \\\"))\\n    e = int(input(\\\"Enter number of edges: \\\"))\\n\\n    graph = [[float(\\\"inf\\\") for i in range(v)] for j in range(v)]\\n\\n    for i in range(v):\\n        graph[i][i] = 0.0\\n\\n        # src and dst are indices that must be within the array size graph[e][v]\\n        # failure to follow this will result in an error\\n    for i in range(e):\\n        print(\\\"\\\\nEdge \\\", i + 1)\\n        src = int(input(\\\"Enter source:\\\"))\\n        dst = int(input(\\\"Enter destination:\\\"))\\n        weight = float(input(\\\"Enter weight:\\\"))\\n        graph[src][dst] = weight\\n\\n    floyd_warshall(graph, v)\\n\\n    # Example Input\\n    # Enter number of vertices: 3\\n    # Enter number of edges: 2\\n\\n    # # generated graph from vertex and edge inputs\\n    # [[inf, inf, inf], [inf, inf, inf], [inf, inf, inf]]\\n    # [[0.0, inf, inf], [inf, 0.0, inf], [inf, inf, 0.0]]\\n\\n    # specify source, destination and weight for edge #1\\n    # Edge  1\\n    # Enter source:1\\n    # Enter destination:2\\n    # Enter weight:2\\n\\n    # specify source, destination and weight for edge #2\\n    # Edge  2\\n    # Enter source:2\\n    # Enter destination:1\\n    # Enter weight:1\\n\\n    # # Expected Output from the vertice, edge and src, dst, weight inputs!!\\n    # 0\\t\\tINF\\tINF\\n    # INF\\t0\\t2\\n    # INF\\t1\\t0\\n\"",
    "graph list": "\"#!/usr/bin/env python3\\n\\n# Author: OMKAR PATHAK, Nwachukwu Chidiebere\\n\\n# Use a Python dictionary to construct the graph.\\nfrom __future__ import annotations\\n\\nfrom pprint import pformat\\nfrom typing import Generic, TypeVar\\n\\nT = TypeVar(\\\"T\\\")\\n\\n\\nclass GraphAdjacencyList(Generic[T]):\\n    \\\"\\\"\\\"\\n    Adjacency List type Graph Data Structure that accounts for directed and undirected\\n    Graphs.  Initialize graph object indicating whether it's directed or undirected.\\n\\n    Directed graph example:\\n    >>> d_graph = GraphAdjacencyList()\\n    >>> d_graph\\n    {}\\n    >>> d_graph.add_edge(0, 1)\\n    {0: [1], 1: []}\\n    >>> d_graph.add_edge(1, 2).add_edge(1, 4).add_edge(1, 5)\\n    {0: [1], 1: [2, 4, 5], 2: [], 4: [], 5: []}\\n    >>> d_graph.add_edge(2, 0).add_edge(2, 6).add_edge(2, 7)\\n    {0: [1], 1: [2, 4, 5], 2: [0, 6, 7], 4: [], 5: [], 6: [], 7: []}\\n    >>> print(d_graph)\\n    {0: [1], 1: [2, 4, 5], 2: [0, 6, 7], 4: [], 5: [], 6: [], 7: []}\\n    >>> print(repr(d_graph))\\n    {0: [1], 1: [2, 4, 5], 2: [0, 6, 7], 4: [], 5: [], 6: [], 7: []}\\n\\n    Undirected graph example:\\n    >>> u_graph = GraphAdjacencyList(directed=False)\\n    >>> u_graph.add_edge(0, 1)\\n    {0: [1], 1: [0]}\\n    >>> u_graph.add_edge(1, 2).add_edge(1, 4).add_edge(1, 5)\\n    {0: [1], 1: [0, 2, 4, 5], 2: [1], 4: [1], 5: [1]}\\n    >>> u_graph.add_edge(2, 0).add_edge(2, 6).add_edge(2, 7)\\n    {0: [1, 2], 1: [0, 2, 4, 5], 2: [1, 0, 6, 7], 4: [1], 5: [1], 6: [2], 7: [2]}\\n    >>> u_graph.add_edge(4, 5)\\n    {0: [1, 2],\\n     1: [0, 2, 4, 5],\\n     2: [1, 0, 6, 7],\\n     4: [1, 5],\\n     5: [1, 4],\\n     6: [2],\\n     7: [2]}\\n    >>> print(u_graph)\\n    {0: [1, 2],\\n     1: [0, 2, 4, 5],\\n     2: [1, 0, 6, 7],\\n     4: [1, 5],\\n     5: [1, 4],\\n     6: [2],\\n     7: [2]}\\n    >>> print(repr(u_graph))\\n    {0: [1, 2],\\n     1: [0, 2, 4, 5],\\n     2: [1, 0, 6, 7],\\n     4: [1, 5],\\n     5: [1, 4],\\n     6: [2],\\n     7: [2]}\\n     >>> char_graph = GraphAdjacencyList(directed=False)\\n     >>> char_graph.add_edge('a', 'b')\\n     {'a': ['b'], 'b': ['a']}\\n     >>> char_graph.add_edge('b', 'c').add_edge('b', 'e').add_edge('b', 'f')\\n     {'a': ['b'], 'b': ['a', 'c', 'e', 'f'], 'c': ['b'], 'e': ['b'], 'f': ['b']}\\n     >>> print(char_graph)\\n     {'a': ['b'], 'b': ['a', 'c', 'e', 'f'], 'c': ['b'], 'e': ['b'], 'f': ['b']}\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, directed: bool = True) -> None:\\n        \\\"\\\"\\\"\\n        Parameters:\\n        directed: (bool) Indicates if graph is directed or undirected. Default is True.\\n        \\\"\\\"\\\"\\n\\n        self.adj_list: dict[T, list[T]] = {}  # dictionary of lists\\n        self.directed = directed\\n\\n    def add_edge(\\n        self, source_vertex: T, destination_vertex: T\\n    ) -> GraphAdjacencyList[T]:\\n        \\\"\\\"\\\"\\n        Connects vertices together. Creates and Edge from source vertex to destination\\n        vertex.\\n        Vertices will be created if not found in graph\\n        \\\"\\\"\\\"\\n\\n        if not self.directed:  # For undirected graphs\\n            # if both source vertex and destination vertex are both present in the\\n            # adjacency list, add destination vertex to source vertex list of adjacent\\n            # vertices and add source vertex to destination vertex list of adjacent\\n            # vertices.\\n            if source_vertex in self.adj_list and destination_vertex in self.adj_list:\\n                self.adj_list[source_vertex].append(destination_vertex)\\n                self.adj_list[destination_vertex].append(source_vertex)\\n            # if only source vertex is present in adjacency list, add destination vertex\\n            # to source vertex list of adjacent vertices, then create a new vertex with\\n            # destination vertex as key and assign a list containing the source vertex\\n            # as it's first adjacent vertex.\\n            elif source_vertex in self.adj_list:\\n                self.adj_list[source_vertex].append(destination_vertex)\\n                self.adj_list[destination_vertex] = [source_vertex]\\n            # if only destination vertex is present in adjacency list, add source vertex\\n            # to destination vertex list of adjacent vertices, then create a new vertex\\n            # with source vertex as key and assign a list containing the source vertex\\n            # as it's first adjacent vertex.\\n            elif destination_vertex in self.adj_list:\\n                self.adj_list[destination_vertex].append(source_vertex)\\n                self.adj_list[source_vertex] = [destination_vertex]\\n            # if both source vertex and destination vertex are not present in adjacency\\n            # list, create a new vertex with source vertex as key and assign a list\\n            # containing the destination vertex as it's first adjacent vertex also\\n            # create a new vertex with destination vertex as key and assign a list\\n            # containing the source vertex as it's first adjacent vertex.\\n            else:\\n                self.adj_list[source_vertex] = [destination_vertex]\\n                self.adj_list[destination_vertex] = [source_vertex]\\n        else:  # For directed graphs\\n            # if both source vertex and destination vertex are present in adjacency\\n            # list, add destination vertex to source vertex list of adjacent vertices.\\n            if source_vertex in self.adj_list and destination_vertex in self.adj_list:\\n                self.adj_list[source_vertex].append(destination_vertex)\\n            # if only source vertex is present in adjacency list, add destination\\n            # vertex to source vertex list of adjacent vertices and create a new vertex\\n            # with destination vertex as key, which has no adjacent vertex\\n            elif source_vertex in self.adj_list:\\n                self.adj_list[source_vertex].append(destination_vertex)\\n                self.adj_list[destination_vertex] = []\\n            # if only destination vertex is present in adjacency list, create a new\\n            # vertex with source vertex as key and assign a list containing destination\\n            # vertex as first adjacent vertex\\n            elif destination_vertex in self.adj_list:\\n                self.adj_list[source_vertex] = [destination_vertex]\\n            # if both source vertex and destination vertex are not present in adjacency\\n            # list, create a new vertex with source vertex as key and a list containing\\n            # destination vertex as it's first adjacent vertex. Then create a new vertex\\n            # with destination vertex as key, which has no adjacent vertex\\n            else:\\n                self.adj_list[source_vertex] = [destination_vertex]\\n                self.adj_list[destination_vertex] = []\\n\\n        return self\\n\\n    def __repr__(self) -> str:\\n        return pformat(self.adj_list)\\n\"",
    "graph matrix": "\"class Graph:\\n    def __init__(self, vertex):\\n        self.vertex = vertex\\n        self.graph = [[0] * vertex for i in range(vertex)]\\n\\n    def add_edge(self, u, v):\\n        self.graph[u - 1][v - 1] = 1\\n        self.graph[v - 1][u - 1] = 1\\n\\n    def show(self):\\n\\n        for i in self.graph:\\n            for j in i:\\n                print(j, end=\\\" \\\")\\n            print(\\\" \\\")\\n\\n\\ng = Graph(100)\\n\\ng.add_edge(1, 4)\\ng.add_edge(4, 2)\\ng.add_edge(4, 5)\\ng.add_edge(2, 5)\\ng.add_edge(5, 3)\\ng.show()\\n\"",
    "greedy best first": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Best-first_search#Greedy_BFS\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\nPath = list[tuple[int, int]]\\n\\ngrid = [\\n    [0, 0, 0, 0, 0, 0, 0],\\n    [0, 1, 0, 0, 0, 0, 0],  # 0 are free path whereas 1's are obstacles\\n    [0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 1, 0, 0, 0, 0],\\n    [1, 0, 1, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 0, 0, 1, 0, 0],\\n]\\n\\ndelta = ([-1, 0], [0, -1], [1, 0], [0, 1])  # up, left, down, right\\n\\n\\nclass Node:\\n    \\\"\\\"\\\"\\n    >>> k = Node(0, 0, 4, 5, 0, None)\\n    >>> k.calculate_heuristic()\\n    9\\n    >>> n = Node(1, 4, 3, 4, 2, None)\\n    >>> n.calculate_heuristic()\\n    2\\n    >>> l = [k, n]\\n    >>> n == l[0]\\n    False\\n    >>> l.sort()\\n    >>> n == l[0]\\n    True\\n    \\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        pos_x: int,\\n        pos_y: int,\\n        goal_x: int,\\n        goal_y: int,\\n        g_cost: float,\\n        parent: Node | None,\\n    ):\\n        self.pos_x = pos_x\\n        self.pos_y = pos_y\\n        self.pos = (pos_y, pos_x)\\n        self.goal_x = goal_x\\n        self.goal_y = goal_y\\n        self.g_cost = g_cost\\n        self.parent = parent\\n        self.f_cost = self.calculate_heuristic()\\n\\n    def calculate_heuristic(self) -> float:\\n        \\\"\\\"\\\"\\n        The heuristic here is the Manhattan Distance\\n        Could elaborate to offer more than one choice\\n        \\\"\\\"\\\"\\n        dy = abs(self.pos_x - self.goal_x)\\n        dx = abs(self.pos_y - self.goal_y)\\n        return dx + dy\\n\\n    def __lt__(self, other) -> bool:\\n        return self.f_cost < other.f_cost\\n\\n\\nclass GreedyBestFirst:\\n    \\\"\\\"\\\"\\n    >>> gbf = GreedyBestFirst((0, 0), (len(grid) - 1, len(grid[0]) - 1))\\n    >>> [x.pos for x in gbf.get_successors(gbf.start)]\\n    [(1, 0), (0, 1)]\\n    >>> (gbf.start.pos_y + delta[3][0], gbf.start.pos_x + delta[3][1])\\n    (0, 1)\\n    >>> (gbf.start.pos_y + delta[2][0], gbf.start.pos_x + delta[2][1])\\n    (1, 0)\\n    >>> gbf.retrace_path(gbf.start)\\n    [(0, 0)]\\n    >>> gbf.search()  # doctest: +NORMALIZE_WHITESPACE\\n    [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (4, 1), (5, 1), (6, 1),\\n     (6, 2), (6, 3), (5, 3), (5, 4), (5, 5), (6, 5), (6, 6)]\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, start: tuple[int, int], goal: tuple[int, int]):\\n        self.start = Node(start[1], start[0], goal[1], goal[0], 0, None)\\n        self.target = Node(goal[1], goal[0], goal[1], goal[0], 99999, None)\\n\\n        self.open_nodes = [self.start]\\n        self.closed_nodes: list[Node] = []\\n\\n        self.reached = False\\n\\n    def search(self) -> Path | None:\\n        \\\"\\\"\\\"\\n        Search for the path,\\n        if a path is not found, only the starting position is returned\\n        \\\"\\\"\\\"\\n        while self.open_nodes:\\n            # Open Nodes are sorted using __lt__\\n            self.open_nodes.sort()\\n            current_node = self.open_nodes.pop(0)\\n\\n            if current_node.pos == self.target.pos:\\n                self.reached = True\\n                return self.retrace_path(current_node)\\n\\n            self.closed_nodes.append(current_node)\\n            successors = self.get_successors(current_node)\\n\\n            for child_node in successors:\\n                if child_node in self.closed_nodes:\\n                    continue\\n\\n                if child_node not in self.open_nodes:\\n                    self.open_nodes.append(child_node)\\n                else:\\n                    # retrieve the best current path\\n                    better_node = self.open_nodes.pop(self.open_nodes.index(child_node))\\n\\n                    if child_node.g_cost < better_node.g_cost:\\n                        self.open_nodes.append(child_node)\\n                    else:\\n                        self.open_nodes.append(better_node)\\n\\n        if not self.reached:\\n            return [self.start.pos]\\n        return None\\n\\n    def get_successors(self, parent: Node) -> list[Node]:\\n        \\\"\\\"\\\"\\n        Returns a list of successors (both in the grid and free spaces)\\n        \\\"\\\"\\\"\\n        successors = []\\n        for action in delta:\\n            pos_x = parent.pos_x + action[1]\\n            pos_y = parent.pos_y + action[0]\\n\\n            if not (0 <= pos_x <= len(grid[0]) - 1 and 0 <= pos_y <= len(grid) - 1):\\n                continue\\n\\n            if grid[pos_y][pos_x] != 0:\\n                continue\\n\\n            successors.append(\\n                Node(\\n                    pos_x,\\n                    pos_y,\\n                    self.target.pos_y,\\n                    self.target.pos_x,\\n                    parent.g_cost + 1,\\n                    parent,\\n                )\\n            )\\n        return successors\\n\\n    def retrace_path(self, node: Node | None) -> Path:\\n        \\\"\\\"\\\"\\n        Retrace the path from parents to parents until start node\\n        \\\"\\\"\\\"\\n        current_node = node\\n        path = []\\n        while current_node is not None:\\n            path.append((current_node.pos_y, current_node.pos_x))\\n            current_node = current_node.parent\\n        path.reverse()\\n        return path\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    init = (0, 0)\\n    goal = (len(grid) - 1, len(grid[0]) - 1)\\n    for elem in grid:\\n        print(elem)\\n\\n    print(\\\"------\\\")\\n\\n    greedy_bf = GreedyBestFirst(init, goal)\\n    path = greedy_bf.search()\\n    if path:\\n        for pos_x, pos_y in path:\\n            grid[pos_x][pos_y] = 2\\n\\n        for elem in grid:\\n            print(elem)\\n\"",
    "greedy min vertex cover": "\"\\\"\\\"\\\"\\n* Author: Manuel Di Lullo (https://github.com/manueldilullo)\\n* Description: Approximization algorithm for minimum vertex cover problem.\\n               Greedy Approach. Uses graphs represented with an adjacency list\\nURL: https://mathworld.wolfram.com/MinimumVertexCover.html\\nURL: https://cs.stackexchange.com/questions/129017/greedy-algorithm-for-vertex-cover\\n\\\"\\\"\\\"\\n\\nimport heapq\\n\\n\\ndef greedy_min_vertex_cover(graph: dict) -> set[int]:\\n    \\\"\\\"\\\"\\n    Greedy APX Algorithm for min Vertex Cover\\n    @input: graph (graph stored in an adjacency list where each vertex\\n            is represented with an integer)\\n    @example:\\n    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\\n    >>> greedy_min_vertex_cover(graph)\\n    {0, 1, 2, 4}\\n    \\\"\\\"\\\"\\n    # queue used to store nodes and their rank\\n    queue: list[list] = []\\n\\n    # for each node and his adjacency list add them and the rank of the node to queue\\n    # using heapq module the queue will be filled like a Priority Queue\\n    # heapq works with a min priority queue, so I used -1*len(v) to build it\\n    for key, value in graph.items():\\n        # O(log(n))\\n        heapq.heappush(queue, [-1 * len(value), (key, value)])\\n\\n    # chosen_vertices = set of chosen vertices\\n    chosen_vertices = set()\\n\\n    # while queue isn't empty and there are still edges\\n    #   (queue[0][0] is the rank of the node with max rank)\\n    while queue and queue[0][0] != 0:\\n        # extract vertex with max rank from queue and add it to chosen_vertices\\n        argmax = heapq.heappop(queue)[1][0]\\n        chosen_vertices.add(argmax)\\n\\n        # Remove all arcs adjacent to argmax\\n        for elem in queue:\\n            # if v haven't adjacent node, skip\\n            if elem[0] == 0:\\n                continue\\n            # if argmax is reachable from elem\\n            # remove argmax from elem's adjacent list and update his rank\\n            if argmax in elem[1][1]:\\n                index = elem[1][1].index(argmax)\\n                del elem[1][1][index]\\n                elem[0] += 1\\n        # re-order the queue\\n        heapq.heapify(queue)\\n    return chosen_vertices\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\\n    print(f\\\"Minimum vertex cover:\\\\n{greedy_min_vertex_cover(graph)}\\\")\\n\"",
    "g topological sort": "\"# Author: Phyllipe Bezerra (https://github.com/pmba)\\n\\nclothes = {\\n    0: \\\"underwear\\\",\\n    1: \\\"pants\\\",\\n    2: \\\"belt\\\",\\n    3: \\\"suit\\\",\\n    4: \\\"shoe\\\",\\n    5: \\\"socks\\\",\\n    6: \\\"shirt\\\",\\n    7: \\\"tie\\\",\\n    8: \\\"watch\\\",\\n}\\n\\ngraph = [[1, 4], [2, 4], [3], [], [], [4], [2, 7], [3], []]\\n\\nvisited = [0 for x in range(len(graph))]\\nstack = []\\n\\n\\ndef print_stack(stack, clothes):\\n    order = 1\\n    while stack:\\n        current_clothing = stack.pop()\\n        print(order, clothes[current_clothing])\\n        order += 1\\n\\n\\ndef depth_first_search(u, visited, graph):\\n    visited[u] = 1\\n    for v in graph[u]:\\n        if not visited[v]:\\n            depth_first_search(v, visited, graph)\\n\\n    stack.append(u)\\n\\n\\ndef topological_sort(graph, visited):\\n    for v in range(len(graph)):\\n        if not visited[v]:\\n            depth_first_search(v, visited, graph)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    topological_sort(graph, visited)\\n    print(stack)\\n    print_stack(stack, clothes)\\n\"",
    "kahns algorithm long": "\"# Finding longest distance in Directed Acyclic Graph using KahnsAlgorithm\\ndef longestDistance(graph):\\n    indegree = [0] * len(graph)\\n    queue = []\\n    longDist = [1] * len(graph)\\n\\n    for key, values in graph.items():\\n        for i in values:\\n            indegree[i] += 1\\n\\n    for i in range(len(indegree)):\\n        if indegree[i] == 0:\\n            queue.append(i)\\n\\n    while queue:\\n        vertex = queue.pop(0)\\n        for x in graph[vertex]:\\n            indegree[x] -= 1\\n\\n            if longDist[vertex] + 1 > longDist[x]:\\n                longDist[x] = longDist[vertex] + 1\\n\\n            if indegree[x] == 0:\\n                queue.append(x)\\n\\n    print(max(longDist))\\n\\n\\n# Adjacency list of Graph\\ngraph = {0: [2, 3, 4], 1: [2, 7], 2: [5], 3: [5, 7], 4: [7], 5: [6], 6: [7], 7: []}\\nlongestDistance(graph)\\n\"",
    "kahns algorithm topo": "\"def topologicalSort(graph):\\n    \\\"\\\"\\\"\\n    Kahn's Algorithm is used to find Topological ordering of Directed Acyclic Graph\\n    using BFS\\n    \\\"\\\"\\\"\\n    indegree = [0] * len(graph)\\n    queue = []\\n    topo = []\\n    cnt = 0\\n\\n    for key, values in graph.items():\\n        for i in values:\\n            indegree[i] += 1\\n\\n    for i in range(len(indegree)):\\n        if indegree[i] == 0:\\n            queue.append(i)\\n\\n    while queue:\\n        vertex = queue.pop(0)\\n        cnt += 1\\n        topo.append(vertex)\\n        for x in graph[vertex]:\\n            indegree[x] -= 1\\n            if indegree[x] == 0:\\n                queue.append(x)\\n\\n    if cnt != len(graph):\\n        print(\\\"Cycle exists\\\")\\n    else:\\n        print(topo)\\n\\n\\n# Adjacency List of Graph\\ngraph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}\\ntopologicalSort(graph)\\n\"",
    "karger": "\"\\\"\\\"\\\"\\nAn implementation of Karger's Algorithm for partitioning a graph.\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\nimport random\\n\\n# Adjacency list representation of this graph:\\n# https://en.wikipedia.org/wiki/File:Single_run_of_Karger%E2%80%99s_Mincut_algorithm.svg\\nTEST_GRAPH = {\\n    \\\"1\\\": [\\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\"],\\n    \\\"2\\\": [\\\"1\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\"],\\n    \\\"3\\\": [\\\"1\\\", \\\"2\\\", \\\"4\\\", \\\"5\\\", \\\"10\\\"],\\n    \\\"4\\\": [\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"5\\\", \\\"6\\\"],\\n    \\\"5\\\": [\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"7\\\"],\\n    \\\"6\\\": [\\\"7\\\", \\\"8\\\", \\\"9\\\", \\\"10\\\", \\\"4\\\"],\\n    \\\"7\\\": [\\\"6\\\", \\\"8\\\", \\\"9\\\", \\\"10\\\", \\\"5\\\"],\\n    \\\"8\\\": [\\\"6\\\", \\\"7\\\", \\\"9\\\", \\\"10\\\"],\\n    \\\"9\\\": [\\\"6\\\", \\\"7\\\", \\\"8\\\", \\\"10\\\"],\\n    \\\"10\\\": [\\\"6\\\", \\\"7\\\", \\\"8\\\", \\\"9\\\", \\\"3\\\"],\\n}\\n\\n\\ndef partition_graph(graph: dict[str, list[str]]) -> set[tuple[str, str]]:\\n    \\\"\\\"\\\"\\n    Partitions a graph using Karger's Algorithm. Implemented from\\n    pseudocode found here:\\n    https://en.wikipedia.org/wiki/Karger%27s_algorithm.\\n    This function involves random choices, meaning it will not give\\n    consistent outputs.\\n\\n    Args:\\n        graph: A dictionary containing adacency lists for the graph.\\n            Nodes must be strings.\\n\\n    Returns:\\n        The cutset of the cut found by Karger's Algorithm.\\n\\n    >>> graph = {'0':['1'], '1':['0']}\\n    >>> partition_graph(graph)\\n    {('0', '1')}\\n    \\\"\\\"\\\"\\n    # Dict that maps contracted nodes to a list of all the nodes it \\\"contains.\\\"\\n    contracted_nodes = {node: {node} for node in graph}\\n\\n    graph_copy = {node: graph[node][:] for node in graph}\\n\\n    while len(graph_copy) > 2:\\n\\n        # Choose a random edge.\\n        u = random.choice(list(graph_copy.keys()))\\n        v = random.choice(graph_copy[u])\\n\\n        # Contract edge (u, v) to new node uv\\n        uv = u + v\\n        uv_neighbors = list(set(graph_copy[u] + graph_copy[v]))\\n        uv_neighbors.remove(u)\\n        uv_neighbors.remove(v)\\n        graph_copy[uv] = uv_neighbors\\n        for neighbor in uv_neighbors:\\n            graph_copy[neighbor].append(uv)\\n\\n        contracted_nodes[uv] = set(contracted_nodes[u].union(contracted_nodes[v]))\\n\\n        # Remove nodes u and v.\\n        del graph_copy[u]\\n        del graph_copy[v]\\n        for neighbor in uv_neighbors:\\n            if u in graph_copy[neighbor]:\\n                graph_copy[neighbor].remove(u)\\n            if v in graph_copy[neighbor]:\\n                graph_copy[neighbor].remove(v)\\n\\n    # Find cutset.\\n    groups = [contracted_nodes[node] for node in graph_copy]\\n    return {\\n        (node, neighbor)\\n        for node in groups[0]\\n        for neighbor in graph[node]\\n        if neighbor in groups[1]\\n    }\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(partition_graph(TEST_GRAPH))\\n\"",
    "markov chain": "\"from __future__ import annotations\\n\\nfrom collections import Counter\\nfrom random import random\\n\\n\\nclass MarkovChainGraphUndirectedUnweighted:\\n    \\\"\\\"\\\"\\n    Undirected Unweighted Graph for running Markov Chain Algorithm\\n    \\\"\\\"\\\"\\n\\n    def __init__(self):\\n        self.connections = {}\\n\\n    def add_node(self, node: str) -> None:\\n        self.connections[node] = {}\\n\\n    def add_transition_probability(\\n        self, node1: str, node2: str, probability: float\\n    ) -> None:\\n        if node1 not in self.connections:\\n            self.add_node(node1)\\n        if node2 not in self.connections:\\n            self.add_node(node2)\\n        self.connections[node1][node2] = probability\\n\\n    def get_nodes(self) -> list[str]:\\n        return list(self.connections)\\n\\n    def transition(self, node: str) -> str:\\n        current_probability = 0\\n        random_value = random()\\n\\n        for dest in self.connections[node]:\\n            current_probability += self.connections[node][dest]\\n            if current_probability > random_value:\\n                return dest\\n        return \\\"\\\"\\n\\n\\ndef get_transitions(\\n    start: str, transitions: list[tuple[str, str, float]], steps: int\\n) -> dict[str, int]:\\n    \\\"\\\"\\\"\\n    Running Markov Chain algorithm and calculating the number of times each node is\\n    visited\\n\\n    >>> transitions = [\\n    ... ('a', 'a', 0.9),\\n    ... ('a', 'b', 0.075),\\n    ... ('a', 'c', 0.025),\\n    ... ('b', 'a', 0.15),\\n    ... ('b', 'b', 0.8),\\n    ... ('b', 'c', 0.05),\\n    ... ('c', 'a', 0.25),\\n    ... ('c', 'b', 0.25),\\n    ... ('c', 'c', 0.5)\\n    ... ]\\n\\n    >>> result = get_transitions('a', transitions, 5000)\\n\\n    >>> result['a'] > result['b'] > result['c']\\n    True\\n    \\\"\\\"\\\"\\n\\n    graph = MarkovChainGraphUndirectedUnweighted()\\n\\n    for node1, node2, probability in transitions:\\n        graph.add_transition_probability(node1, node2, probability)\\n\\n    visited = Counter(graph.get_nodes())\\n    node = start\\n\\n    for _ in range(steps):\\n        node = graph.transition(node)\\n        visited[node] += 1\\n\\n    return visited\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "matching min vertex cover": "\"\\\"\\\"\\\"\\n* Author: Manuel Di Lullo (https://github.com/manueldilullo)\\n* Description: Approximization algorithm for minimum vertex cover problem.\\n               Matching Approach. Uses graphs represented with an adjacency list\\n\\nURL: https://mathworld.wolfram.com/MinimumVertexCover.html\\nURL: https://www.princeton.edu/~aaa/Public/Teaching/ORF523/ORF523_Lec6.pdf\\n\\\"\\\"\\\"\\n\\n\\ndef matching_min_vertex_cover(graph: dict) -> set:\\n    \\\"\\\"\\\"\\n    APX Algorithm for min Vertex Cover using Matching Approach\\n    @input: graph (graph stored in an adjacency list where each vertex\\n            is represented as an integer)\\n    @example:\\n    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\\n    >>> matching_min_vertex_cover(graph)\\n    {0, 1, 2, 4}\\n    \\\"\\\"\\\"\\n    # chosen_vertices = set of chosen vertices\\n    chosen_vertices = set()\\n    # edges = list of graph's edges\\n    edges = get_edges(graph)\\n\\n    # While there are still elements in edges list, take an arbitrary edge\\n    # (from_node, to_node) and add his extremity to chosen_vertices and then\\n    # remove all arcs adjacent to the from_node and to_node\\n    while edges:\\n        from_node, to_node = edges.pop()\\n        chosen_vertices.add(from_node)\\n        chosen_vertices.add(to_node)\\n        for edge in edges.copy():\\n            if from_node in edge or to_node in edge:\\n                edges.discard(edge)\\n    return chosen_vertices\\n\\n\\ndef get_edges(graph: dict) -> set:\\n    \\\"\\\"\\\"\\n    Return a set of couples that represents all of the edges.\\n    @input: graph (graph stored in an adjacency list where each vertex is\\n            represented as an integer)\\n    @example:\\n    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3], 3: [0, 1, 2]}\\n    >>> get_edges(graph)\\n    {(0, 1), (3, 1), (0, 3), (2, 0), (3, 0), (2, 3), (1, 0), (3, 2), (1, 3)}\\n    \\\"\\\"\\\"\\n    edges = set()\\n    for from_node, to_nodes in graph.items():\\n        for to_node in to_nodes:\\n            edges.add((from_node, to_node))\\n    return edges\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    # graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\\n    # print(f\\\"Matching vertex cover:\\\\n{matching_min_vertex_cover(graph)}\\\")\\n\"",
    "minimum spanning tree boruvka": "\"class Graph:\\r\\n    \\\"\\\"\\\"\\r\\n    Data structure to store graphs (based on adjacency lists)\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def __init__(self):\\r\\n\\r\\n        self.num_vertices = 0\\r\\n        self.num_edges = 0\\r\\n        self.adjacency = {}\\r\\n\\r\\n    def add_vertex(self, vertex):\\r\\n        \\\"\\\"\\\"\\r\\n        Adds a vertex to the graph\\r\\n\\r\\n        \\\"\\\"\\\"\\r\\n        if vertex not in self.adjacency:\\r\\n            self.adjacency[vertex] = {}\\r\\n            self.num_vertices += 1\\r\\n\\r\\n    def add_edge(self, head, tail, weight):\\r\\n        \\\"\\\"\\\"\\r\\n        Adds an edge to the graph\\r\\n\\r\\n        \\\"\\\"\\\"\\r\\n\\r\\n        self.add_vertex(head)\\r\\n        self.add_vertex(tail)\\r\\n\\r\\n        if head == tail:\\r\\n            return\\r\\n\\r\\n        self.adjacency[head][tail] = weight\\r\\n        self.adjacency[tail][head] = weight\\r\\n\\r\\n    def distinct_weight(self):\\r\\n        \\\"\\\"\\\"\\r\\n        For Boruvks's algorithm the weights should be distinct\\r\\n        Converts the weights to be distinct\\r\\n\\r\\n        \\\"\\\"\\\"\\r\\n        edges = self.get_edges()\\r\\n        for edge in edges:\\r\\n            head, tail, weight = edge\\r\\n            edges.remove((tail, head, weight))\\r\\n        for i in range(len(edges)):\\r\\n            edges[i] = list(edges[i])\\r\\n\\r\\n        edges.sort(key=lambda e: e[2])\\r\\n        for i in range(len(edges) - 1):\\r\\n            if edges[i][2] >= edges[i + 1][2]:\\r\\n                edges[i + 1][2] = edges[i][2] + 1\\r\\n        for edge in edges:\\r\\n            head, tail, weight = edge\\r\\n            self.adjacency[head][tail] = weight\\r\\n            self.adjacency[tail][head] = weight\\r\\n\\r\\n    def __str__(self):\\r\\n        \\\"\\\"\\\"\\r\\n        Returns string representation of the graph\\r\\n        \\\"\\\"\\\"\\r\\n        string = \\\"\\\"\\r\\n        for tail in self.adjacency:\\r\\n            for head in self.adjacency[tail]:\\r\\n                weight = self.adjacency[head][tail]\\r\\n                string += \\\"%d -> %d == %d\\\\n\\\" % (head, tail, weight)\\r\\n        return string.rstrip(\\\"\\\\n\\\")\\r\\n\\r\\n    def get_edges(self):\\r\\n        \\\"\\\"\\\"\\r\\n        Returna all edges in the graph\\r\\n        \\\"\\\"\\\"\\r\\n        output = []\\r\\n        for tail in self.adjacency:\\r\\n            for head in self.adjacency[tail]:\\r\\n                output.append((tail, head, self.adjacency[head][tail]))\\r\\n        return output\\r\\n\\r\\n    def get_vertices(self):\\r\\n        \\\"\\\"\\\"\\r\\n        Returns all vertices in the graph\\r\\n        \\\"\\\"\\\"\\r\\n        return self.adjacency.keys()\\r\\n\\r\\n    @staticmethod\\r\\n    def build(vertices=None, edges=None):\\r\\n        \\\"\\\"\\\"\\r\\n        Builds a graph from the given set of vertices and edges\\r\\n\\r\\n        \\\"\\\"\\\"\\r\\n        g = Graph()\\r\\n        if vertices is None:\\r\\n            vertices = []\\r\\n        if edges is None:\\r\\n            edge = []\\r\\n        for vertex in vertices:\\r\\n            g.add_vertex(vertex)\\r\\n        for edge in edges:\\r\\n            g.add_edge(*edge)\\r\\n        return g\\r\\n\\r\\n    class UnionFind:\\r\\n        \\\"\\\"\\\"\\r\\n        Disjoint set Union and Find for Boruvka's algorithm\\r\\n        \\\"\\\"\\\"\\r\\n\\r\\n        def __init__(self):\\r\\n            self.parent = {}\\r\\n            self.rank = {}\\r\\n\\r\\n        def __len__(self):\\r\\n            return len(self.parent)\\r\\n\\r\\n        def make_set(self, item):\\r\\n            if item in self.parent:\\r\\n                return self.find(item)\\r\\n\\r\\n            self.parent[item] = item\\r\\n            self.rank[item] = 0\\r\\n            return item\\r\\n\\r\\n        def find(self, item):\\r\\n            if item not in self.parent:\\r\\n                return self.make_set(item)\\r\\n            if item != self.parent[item]:\\r\\n                self.parent[item] = self.find(self.parent[item])\\r\\n            return self.parent[item]\\r\\n\\r\\n        def union(self, item1, item2):\\r\\n            root1 = self.find(item1)\\r\\n            root2 = self.find(item2)\\r\\n\\r\\n            if root1 == root2:\\r\\n                return root1\\r\\n\\r\\n            if self.rank[root1] > self.rank[root2]:\\r\\n                self.parent[root2] = root1\\r\\n                return root1\\r\\n\\r\\n            if self.rank[root1] < self.rank[root2]:\\r\\n                self.parent[root1] = root2\\r\\n                return root2\\r\\n\\r\\n            if self.rank[root1] == self.rank[root2]:\\r\\n                self.rank[root1] += 1\\r\\n                self.parent[root2] = root1\\r\\n                return root1\\r\\n\\r\\n    @staticmethod\\r\\n    def boruvka_mst(graph):\\r\\n        \\\"\\\"\\\"\\r\\n        Implementation of Boruvka's algorithm\\r\\n        >>> g = Graph()\\r\\n        >>> g = Graph.build([0, 1, 2, 3], [[0, 1, 1], [0, 2, 1],[2, 3, 1]])\\r\\n        >>> g.distinct_weight()\\r\\n        >>> bg = Graph.boruvka_mst(g)\\r\\n        >>> print(bg)\\r\\n        1 -> 0 == 1\\r\\n        2 -> 0 == 2\\r\\n        0 -> 1 == 1\\r\\n        0 -> 2 == 2\\r\\n        3 -> 2 == 3\\r\\n        2 -> 3 == 3\\r\\n        \\\"\\\"\\\"\\r\\n        num_components = graph.num_vertices\\r\\n\\r\\n        union_find = Graph.UnionFind()\\r\\n        mst_edges = []\\r\\n        while num_components > 1:\\r\\n            cheap_edge = {}\\r\\n            for vertex in graph.get_vertices():\\r\\n                cheap_edge[vertex] = -1\\r\\n\\r\\n            edges = graph.get_edges()\\r\\n            for edge in edges:\\r\\n                head, tail, weight = edge\\r\\n                edges.remove((tail, head, weight))\\r\\n            for edge in edges:\\r\\n                head, tail, weight = edge\\r\\n                set1 = union_find.find(head)\\r\\n                set2 = union_find.find(tail)\\r\\n                if set1 != set2:\\r\\n                    if cheap_edge[set1] == -1 or cheap_edge[set1][2] > weight:\\r\\n                        cheap_edge[set1] = [head, tail, weight]\\r\\n\\r\\n                    if cheap_edge[set2] == -1 or cheap_edge[set2][2] > weight:\\r\\n                        cheap_edge[set2] = [head, tail, weight]\\r\\n            for vertex in cheap_edge:\\r\\n                if cheap_edge[vertex] != -1:\\r\\n                    head, tail, weight = cheap_edge[vertex]\\r\\n                    if union_find.find(head) != union_find.find(tail):\\r\\n                        union_find.union(head, tail)\\r\\n                        mst_edges.append(cheap_edge[vertex])\\r\\n                        num_components = num_components - 1\\r\\n        mst = Graph.build(edges=mst_edges)\\r\\n        return mst\\r\\n\"",
    "minimum spanning tree kruskal": "\"def kruskal(\\n    num_nodes: int, edges: list[tuple[int, int, int]]\\n) -> list[tuple[int, int, int]]:\\n    \\\"\\\"\\\"\\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1)])\\n    [(2, 3, 1), (0, 1, 3), (1, 2, 5)]\\n\\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2)])\\n    [(2, 3, 1), (0, 2, 1), (0, 1, 3)]\\n\\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2),\\n    ... (2, 1, 1)])\\n    [(2, 3, 1), (0, 2, 1), (2, 1, 1)]\\n    \\\"\\\"\\\"\\n    edges = sorted(edges, key=lambda edge: edge[2])\\n\\n    parent = list(range(num_nodes))\\n\\n    def find_parent(i):\\n        if i != parent[i]:\\n            parent[i] = find_parent(parent[i])\\n        return parent[i]\\n\\n    minimum_spanning_tree_cost = 0\\n    minimum_spanning_tree = []\\n\\n    for edge in edges:\\n        parent_a = find_parent(edge[0])\\n        parent_b = find_parent(edge[1])\\n        if parent_a != parent_b:\\n            minimum_spanning_tree_cost += edge[2]\\n            minimum_spanning_tree.append(edge)\\n            parent[parent_a] = parent_b\\n\\n    return minimum_spanning_tree\\n\\n\\nif __name__ == \\\"__main__\\\":  # pragma: no cover\\n    num_nodes, num_edges = list(map(int, input().strip().split()))\\n    edges = []\\n\\n    for _ in range(num_edges):\\n        node1, node2, cost = (int(x) for x in input().strip().split())\\n        edges.append((node1, node2, cost))\\n\\n    kruskal(num_nodes, edges)\\n\"",
    "minimum spanning tree kruskal2": "\"from __future__ import annotations\\n\\nfrom typing import Generic, TypeVar\\n\\nT = TypeVar(\\\"T\\\")\\n\\n\\nclass DisjointSetTreeNode(Generic[T]):\\n    # Disjoint Set Node to store the parent and rank\\n    def __init__(self, data: T) -> None:\\n        self.data = data\\n        self.parent = self\\n        self.rank = 0\\n\\n\\nclass DisjointSetTree(Generic[T]):\\n    # Disjoint Set DataStructure\\n    def __init__(self) -> None:\\n        # map from node name to the node object\\n        self.map: dict[T, DisjointSetTreeNode[T]] = {}\\n\\n    def make_set(self, data: T) -> None:\\n        # create a new set with x as its member\\n        self.map[data] = DisjointSetTreeNode(data)\\n\\n    def find_set(self, data: T) -> DisjointSetTreeNode[T]:\\n        # find the set x belongs to (with path-compression)\\n        elem_ref = self.map[data]\\n        if elem_ref != elem_ref.parent:\\n            elem_ref.parent = self.find_set(elem_ref.parent.data)\\n        return elem_ref.parent\\n\\n    def link(\\n        self, node1: DisjointSetTreeNode[T], node2: DisjointSetTreeNode[T]\\n    ) -> None:\\n        # helper function for union operation\\n        if node1.rank > node2.rank:\\n            node2.parent = node1\\n        else:\\n            node1.parent = node2\\n            if node1.rank == node2.rank:\\n                node2.rank += 1\\n\\n    def union(self, data1: T, data2: T) -> None:\\n        # merge 2 disjoint sets\\n        self.link(self.find_set(data1), self.find_set(data2))\\n\\n\\nclass GraphUndirectedWeighted(Generic[T]):\\n    def __init__(self) -> None:\\n        # connections: map from the node to the neighbouring nodes (with weights)\\n        self.connections: dict[T, dict[T, int]] = {}\\n\\n    def add_node(self, node: T) -> None:\\n        # add a node ONLY if its not present in the graph\\n        if node not in self.connections:\\n            self.connections[node] = {}\\n\\n    def add_edge(self, node1: T, node2: T, weight: int) -> None:\\n        # add an edge with the given weight\\n        self.add_node(node1)\\n        self.add_node(node2)\\n        self.connections[node1][node2] = weight\\n        self.connections[node2][node1] = weight\\n\\n    def kruskal(self) -> GraphUndirectedWeighted[T]:\\n        # Kruskal's Algorithm to generate a Minimum Spanning Tree (MST) of a graph\\n        \\\"\\\"\\\"\\n        Details: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\\n\\n        Example:\\n        >>> g1 = GraphUndirectedWeighted[int]()\\n        >>> g1.add_edge(1, 2, 1)\\n        >>> g1.add_edge(2, 3, 2)\\n        >>> g1.add_edge(3, 4, 1)\\n        >>> g1.add_edge(3, 5, 100) # Removed in MST\\n        >>> g1.add_edge(4, 5, 5)\\n        >>> assert 5 in g1.connections[3]\\n        >>> mst = g1.kruskal()\\n        >>> assert 5 not in mst.connections[3]\\n\\n        >>> g2 = GraphUndirectedWeighted[str]()\\n        >>> g2.add_edge('A', 'B', 1)\\n        >>> g2.add_edge('B', 'C', 2)\\n        >>> g2.add_edge('C', 'D', 1)\\n        >>> g2.add_edge('C', 'E', 100) # Removed in MST\\n        >>> g2.add_edge('D', 'E', 5)\\n        >>> assert 'E' in g2.connections[\\\"C\\\"]\\n        >>> mst = g2.kruskal()\\n        >>> assert 'E' not in mst.connections['C']\\n        \\\"\\\"\\\"\\n\\n        # getting the edges in ascending order of weights\\n        edges = []\\n        seen = set()\\n        for start in self.connections:\\n            for end in self.connections[start]:\\n                if (start, end) not in seen:\\n                    seen.add((end, start))\\n                    edges.append((start, end, self.connections[start][end]))\\n        edges.sort(key=lambda x: x[2])\\n\\n        # creating the disjoint set\\n        disjoint_set = DisjointSetTree[T]()\\n        for node in self.connections:\\n            disjoint_set.make_set(node)\\n\\n        # MST generation\\n        num_edges = 0\\n        index = 0\\n        graph = GraphUndirectedWeighted[T]()\\n        while num_edges < len(self.connections) - 1:\\n            u, v, w = edges[index]\\n            index += 1\\n            parent_u = disjoint_set.find_set(u)\\n            parent_v = disjoint_set.find_set(v)\\n            if parent_u != parent_v:\\n                num_edges += 1\\n                graph.add_edge(u, v, w)\\n                disjoint_set.union(u, v)\\n        return graph\\n\"",
    "minimum spanning tree prims": "\"import sys\\nfrom collections import defaultdict\\n\\n\\ndef PrimsAlgorithm(l):  # noqa: E741\\n\\n    nodePosition = []\\n\\n    def get_position(vertex):\\n        return nodePosition[vertex]\\n\\n    def set_position(vertex, pos):\\n        nodePosition[vertex] = pos\\n\\n    def top_to_bottom(heap, start, size, positions):\\n        if start > size // 2 - 1:\\n            return\\n        else:\\n            if 2 * start + 2 >= size:\\n                m = 2 * start + 1\\n            else:\\n                if heap[2 * start + 1] < heap[2 * start + 2]:\\n                    m = 2 * start + 1\\n                else:\\n                    m = 2 * start + 2\\n            if heap[m] < heap[start]:\\n                temp, temp1 = heap[m], positions[m]\\n                heap[m], positions[m] = heap[start], positions[start]\\n                heap[start], positions[start] = temp, temp1\\n\\n                temp = get_position(positions[m])\\n                set_position(positions[m], get_position(positions[start]))\\n                set_position(positions[start], temp)\\n\\n                top_to_bottom(heap, m, size, positions)\\n\\n    # Update function if value of any node in min-heap decreases\\n    def bottom_to_top(val, index, heap, position):\\n        temp = position[index]\\n\\n        while index != 0:\\n            if index % 2 == 0:\\n                parent = int((index - 2) / 2)\\n            else:\\n                parent = int((index - 1) / 2)\\n\\n            if val < heap[parent]:\\n                heap[index] = heap[parent]\\n                position[index] = position[parent]\\n                set_position(position[parent], index)\\n            else:\\n                heap[index] = val\\n                position[index] = temp\\n                set_position(temp, index)\\n                break\\n            index = parent\\n        else:\\n            heap[0] = val\\n            position[0] = temp\\n            set_position(temp, 0)\\n\\n    def heapify(heap, positions):\\n        start = len(heap) // 2 - 1\\n        for i in range(start, -1, -1):\\n            top_to_bottom(heap, i, len(heap), positions)\\n\\n    def deleteMinimum(heap, positions):\\n        temp = positions[0]\\n        heap[0] = sys.maxsize\\n        top_to_bottom(heap, 0, len(heap), positions)\\n        return temp\\n\\n    visited = [0 for i in range(len(l))]\\n    Nbr_TV = [-1 for i in range(len(l))]  # Neighboring Tree Vertex of selected vertex\\n    # Minimum Distance of explored vertex with neighboring vertex of partial tree\\n    # formed in graph\\n    Distance_TV = []  # Heap of Distance of vertices from their neighboring vertex\\n    Positions = []\\n\\n    for x in range(len(l)):\\n        p = sys.maxsize\\n        Distance_TV.append(p)\\n        Positions.append(x)\\n        nodePosition.append(x)\\n\\n    TreeEdges = []\\n    visited[0] = 1\\n    Distance_TV[0] = sys.maxsize\\n    for x in l[0]:\\n        Nbr_TV[x[0]] = 0\\n        Distance_TV[x[0]] = x[1]\\n    heapify(Distance_TV, Positions)\\n\\n    for i in range(1, len(l)):\\n        vertex = deleteMinimum(Distance_TV, Positions)\\n        if visited[vertex] == 0:\\n            TreeEdges.append((Nbr_TV[vertex], vertex))\\n            visited[vertex] = 1\\n            for v in l[vertex]:\\n                if visited[v[0]] == 0 and v[1] < Distance_TV[get_position(v[0])]:\\n                    Distance_TV[get_position(v[0])] = v[1]\\n                    bottom_to_top(v[1], get_position(v[0]), Distance_TV, Positions)\\n                    Nbr_TV[v[0]] = vertex\\n    return TreeEdges\\n\\n\\nif __name__ == \\\"__main__\\\":  # pragma: no cover\\n    # < --------- Prims Algorithm --------- >\\n    n = int(input(\\\"Enter number of vertices: \\\").strip())\\n    e = int(input(\\\"Enter number of edges: \\\").strip())\\n    adjlist = defaultdict(list)\\n    for x in range(e):\\n        l = [int(x) for x in input().strip().split()]  # noqa: E741\\n        adjlist[l[0]].append([l[1], l[2]])\\n        adjlist[l[1]].append([l[0], l[2]])\\n    print(PrimsAlgorithm(adjlist))\\n\"",
    "minimum spanning tree prims2": "\"\\\"\\\"\\\"\\nPrim's (also known as Jarník's) algorithm is a greedy algorithm that finds a minimum\\nspanning tree for a weighted undirected graph. This means it finds a subset of the\\nedges that forms a tree that includes every vertex, where the total weight of all the\\nedges in the tree is minimized. The algorithm operates by building this tree one vertex\\nat a time, from an arbitrary starting vertex, at each step adding the cheapest possible\\nconnection from the tree to another vertex.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom sys import maxsize\\nfrom typing import Generic, TypeVar\\n\\nT = TypeVar(\\\"T\\\")\\n\\n\\ndef get_parent_position(position: int) -> int:\\n    \\\"\\\"\\\"\\n    heap helper function get the position of the parent of the current node\\n\\n    >>> get_parent_position(1)\\n    0\\n    >>> get_parent_position(2)\\n    0\\n    \\\"\\\"\\\"\\n    return (position - 1) // 2\\n\\n\\ndef get_child_left_position(position: int) -> int:\\n    \\\"\\\"\\\"\\n    heap helper function get the position of the left child of the current node\\n\\n    >>> get_child_left_position(0)\\n    1\\n    \\\"\\\"\\\"\\n    return (2 * position) + 1\\n\\n\\ndef get_child_right_position(position: int) -> int:\\n    \\\"\\\"\\\"\\n    heap helper function get the position of the right child of the current node\\n\\n    >>> get_child_right_position(0)\\n    2\\n    \\\"\\\"\\\"\\n    return (2 * position) + 2\\n\\n\\nclass MinPriorityQueue(Generic[T]):\\n    \\\"\\\"\\\"\\n    Minimum Priority Queue Class\\n\\n    Functions:\\n    is_empty: function to check if the priority queue is empty\\n    push: function to add an element with given priority to the queue\\n    extract_min: function to remove and return the element with lowest weight (highest\\n                 priority)\\n    update_key: function to update the weight of the given key\\n    _bubble_up: helper function to place a node at the proper position (upward\\n                movement)\\n    _bubble_down: helper function to place a node at the proper position (downward\\n                movement)\\n    _swap_nodes: helper function to swap the nodes at the given positions\\n\\n    >>> queue = MinPriorityQueue()\\n\\n    >>> queue.push(1, 1000)\\n    >>> queue.push(2, 100)\\n    >>> queue.push(3, 4000)\\n    >>> queue.push(4, 3000)\\n\\n    >>> print(queue.extract_min())\\n    2\\n\\n    >>> queue.update_key(4, 50)\\n\\n    >>> print(queue.extract_min())\\n    4\\n    >>> print(queue.extract_min())\\n    1\\n    >>> print(queue.extract_min())\\n    3\\n    \\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.heap: list[tuple[T, int]] = []\\n        self.position_map: dict[T, int] = {}\\n        self.elements: int = 0\\n\\n    def __len__(self) -> int:\\n        return self.elements\\n\\n    def __repr__(self) -> str:\\n        return str(self.heap)\\n\\n    def is_empty(self) -> bool:\\n        # Check if the priority queue is empty\\n        return self.elements == 0\\n\\n    def push(self, elem: T, weight: int) -> None:\\n        # Add an element with given priority to the queue\\n        self.heap.append((elem, weight))\\n        self.position_map[elem] = self.elements\\n        self.elements += 1\\n        self._bubble_up(elem)\\n\\n    def extract_min(self) -> T:\\n        # Remove and return the element with lowest weight (highest priority)\\n        if self.elements > 1:\\n            self._swap_nodes(0, self.elements - 1)\\n        elem, _ = self.heap.pop()\\n        del self.position_map[elem]\\n        self.elements -= 1\\n        if self.elements > 0:\\n            bubble_down_elem, _ = self.heap[0]\\n            self._bubble_down(bubble_down_elem)\\n        return elem\\n\\n    def update_key(self, elem: T, weight: int) -> None:\\n        # Update the weight of the given key\\n        position = self.position_map[elem]\\n        self.heap[position] = (elem, weight)\\n        if position > 0:\\n            parent_position = get_parent_position(position)\\n            _, parent_weight = self.heap[parent_position]\\n            if parent_weight > weight:\\n                self._bubble_up(elem)\\n            else:\\n                self._bubble_down(elem)\\n        else:\\n            self._bubble_down(elem)\\n\\n    def _bubble_up(self, elem: T) -> None:\\n        # Place a node at the proper position (upward movement) [to be used internally\\n        # only]\\n        curr_pos = self.position_map[elem]\\n        if curr_pos == 0:\\n            return\\n        parent_position = get_parent_position(curr_pos)\\n        _, weight = self.heap[curr_pos]\\n        _, parent_weight = self.heap[parent_position]\\n        if parent_weight > weight:\\n            self._swap_nodes(parent_position, curr_pos)\\n            return self._bubble_up(elem)\\n        return\\n\\n    def _bubble_down(self, elem: T) -> None:\\n        # Place a node at the proper position (downward movement) [to be used\\n        # internally only]\\n        curr_pos = self.position_map[elem]\\n        _, weight = self.heap[curr_pos]\\n        child_left_position = get_child_left_position(curr_pos)\\n        child_right_position = get_child_right_position(curr_pos)\\n        if child_left_position < self.elements and child_right_position < self.elements:\\n            _, child_left_weight = self.heap[child_left_position]\\n            _, child_right_weight = self.heap[child_right_position]\\n            if child_right_weight < child_left_weight:\\n                if child_right_weight < weight:\\n                    self._swap_nodes(child_right_position, curr_pos)\\n                    return self._bubble_down(elem)\\n        if child_left_position < self.elements:\\n            _, child_left_weight = self.heap[child_left_position]\\n            if child_left_weight < weight:\\n                self._swap_nodes(child_left_position, curr_pos)\\n                return self._bubble_down(elem)\\n        else:\\n            return\\n        if child_right_position < self.elements:\\n            _, child_right_weight = self.heap[child_right_position]\\n            if child_right_weight < weight:\\n                self._swap_nodes(child_right_position, curr_pos)\\n                return self._bubble_down(elem)\\n        else:\\n            return\\n\\n    def _swap_nodes(self, node1_pos: int, node2_pos: int) -> None:\\n        # Swap the nodes at the given positions\\n        node1_elem = self.heap[node1_pos][0]\\n        node2_elem = self.heap[node2_pos][0]\\n        self.heap[node1_pos], self.heap[node2_pos] = (\\n            self.heap[node2_pos],\\n            self.heap[node1_pos],\\n        )\\n        self.position_map[node1_elem] = node2_pos\\n        self.position_map[node2_elem] = node1_pos\\n\\n\\nclass GraphUndirectedWeighted(Generic[T]):\\n    \\\"\\\"\\\"\\n    Graph Undirected Weighted Class\\n\\n    Functions:\\n    add_node: function to add a node in the graph\\n    add_edge: function to add an edge between 2 nodes in the graph\\n    \\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.connections: dict[T, dict[T, int]] = {}\\n        self.nodes: int = 0\\n\\n    def __repr__(self) -> str:\\n        return str(self.connections)\\n\\n    def __len__(self) -> int:\\n        return self.nodes\\n\\n    def add_node(self, node: T) -> None:\\n        # Add a node in the graph if it is not in the graph\\n        if node not in self.connections:\\n            self.connections[node] = {}\\n            self.nodes += 1\\n\\n    def add_edge(self, node1: T, node2: T, weight: int) -> None:\\n        # Add an edge between 2 nodes in the graph\\n        self.add_node(node1)\\n        self.add_node(node2)\\n        self.connections[node1][node2] = weight\\n        self.connections[node2][node1] = weight\\n\\n\\ndef prims_algo(\\n    graph: GraphUndirectedWeighted[T],\\n) -> tuple[dict[T, int], dict[T, T | None]]:\\n    \\\"\\\"\\\"\\n    >>> graph = GraphUndirectedWeighted()\\n\\n    >>> graph.add_edge(\\\"a\\\", \\\"b\\\", 3)\\n    >>> graph.add_edge(\\\"b\\\", \\\"c\\\", 10)\\n    >>> graph.add_edge(\\\"c\\\", \\\"d\\\", 5)\\n    >>> graph.add_edge(\\\"a\\\", \\\"c\\\", 15)\\n    >>> graph.add_edge(\\\"b\\\", \\\"d\\\", 100)\\n\\n    >>> dist, parent = prims_algo(graph)\\n\\n    >>> abs(dist[\\\"a\\\"] - dist[\\\"b\\\"])\\n    3\\n    >>> abs(dist[\\\"d\\\"] - dist[\\\"b\\\"])\\n    15\\n    >>> abs(dist[\\\"a\\\"] - dist[\\\"c\\\"])\\n    13\\n    \\\"\\\"\\\"\\n    # prim's algorithm for minimum spanning tree\\n    dist: dict[T, int] = {node: maxsize for node in graph.connections}\\n    parent: dict[T, T | None] = {node: None for node in graph.connections}\\n\\n    priority_queue: MinPriorityQueue[T] = MinPriorityQueue()\\n    for node, weight in dist.items():\\n        priority_queue.push(node, weight)\\n\\n    if priority_queue.is_empty():\\n        return dist, parent\\n\\n    # initialization\\n    node = priority_queue.extract_min()\\n    dist[node] = 0\\n    for neighbour in graph.connections[node]:\\n        if dist[neighbour] > dist[node] + graph.connections[node][neighbour]:\\n            dist[neighbour] = dist[node] + graph.connections[node][neighbour]\\n            priority_queue.update_key(neighbour, dist[neighbour])\\n            parent[neighbour] = node\\n\\n    # running prim's algorithm\\n    while not priority_queue.is_empty():\\n        node = priority_queue.extract_min()\\n        for neighbour in graph.connections[node]:\\n            if dist[neighbour] > dist[node] + graph.connections[node][neighbour]:\\n                dist[neighbour] = dist[node] + graph.connections[node][neighbour]\\n                priority_queue.update_key(neighbour, dist[neighbour])\\n                parent[neighbour] = node\\n    return dist, parent\\n\"",
    "multi heuristic astar": "\"import heapq\\n\\nimport numpy as np\\n\\nTPos = tuple[int, int]\\n\\n\\nclass PriorityQueue:\\n    def __init__(self):\\n        self.elements = []\\n        self.set = set()\\n\\n    def minkey(self):\\n        if not self.empty():\\n            return self.elements[0][0]\\n        else:\\n            return float(\\\"inf\\\")\\n\\n    def empty(self):\\n        return len(self.elements) == 0\\n\\n    def put(self, item, priority):\\n        if item not in self.set:\\n            heapq.heappush(self.elements, (priority, item))\\n            self.set.add(item)\\n        else:\\n            # update\\n            # print(\\\"update\\\", item)\\n            temp = []\\n            (pri, x) = heapq.heappop(self.elements)\\n            while x != item:\\n                temp.append((pri, x))\\n                (pri, x) = heapq.heappop(self.elements)\\n            temp.append((priority, item))\\n            for (pro, xxx) in temp:\\n                heapq.heappush(self.elements, (pro, xxx))\\n\\n    def remove_element(self, item):\\n        if item in self.set:\\n            self.set.remove(item)\\n            temp = []\\n            (pro, x) = heapq.heappop(self.elements)\\n            while x != item:\\n                temp.append((pro, x))\\n                (pro, x) = heapq.heappop(self.elements)\\n            for (prito, yyy) in temp:\\n                heapq.heappush(self.elements, (prito, yyy))\\n\\n    def top_show(self):\\n        return self.elements[0][1]\\n\\n    def get(self):\\n        (priority, item) = heapq.heappop(self.elements)\\n        self.set.remove(item)\\n        return (priority, item)\\n\\n\\ndef consistent_heuristic(P: TPos, goal: TPos):\\n    # euclidean distance\\n    a = np.array(P)\\n    b = np.array(goal)\\n    return np.linalg.norm(a - b)\\n\\n\\ndef heuristic_2(P: TPos, goal: TPos):\\n    # integer division by time variable\\n    return consistent_heuristic(P, goal) // t\\n\\n\\ndef heuristic_1(P: TPos, goal: TPos):\\n    # manhattan distance\\n    return abs(P[0] - goal[0]) + abs(P[1] - goal[1])\\n\\n\\ndef key(start: TPos, i: int, goal: TPos, g_function: dict[TPos, float]):\\n    ans = g_function[start] + W1 * heuristics[i](start, goal)\\n    return ans\\n\\n\\ndef do_something(back_pointer, goal, start):\\n    grid = np.chararray((n, n))\\n    for i in range(n):\\n        for j in range(n):\\n            grid[i][j] = \\\"*\\\"\\n\\n    for i in range(n):\\n        for j in range(n):\\n            if (j, (n - 1) - i) in blocks:\\n                grid[i][j] = \\\"#\\\"\\n\\n    grid[0][(n - 1)] = \\\"-\\\"\\n    x = back_pointer[goal]\\n    while x != start:\\n        (x_c, y_c) = x\\n        # print(x)\\n        grid[(n - 1) - y_c][x_c] = \\\"-\\\"\\n        x = back_pointer[x]\\n    grid[(n - 1)][0] = \\\"-\\\"\\n\\n    for i in range(n):\\n        for j in range(n):\\n            if (i, j) == (0, n - 1):\\n                print(grid[i][j], end=\\\" \\\")\\n                print(\\\"<-- End position\\\", end=\\\" \\\")\\n            else:\\n                print(grid[i][j], end=\\\" \\\")\\n        print()\\n    print(\\\"^\\\")\\n    print(\\\"Start position\\\")\\n    print()\\n    print(\\\"# is an obstacle\\\")\\n    print(\\\"- is the path taken by algorithm\\\")\\n    print(\\\"PATH TAKEN BY THE ALGORITHM IS:-\\\")\\n    x = back_pointer[goal]\\n    while x != start:\\n        print(x, end=\\\" \\\")\\n        x = back_pointer[x]\\n    print(x)\\n    quit()\\n\\n\\ndef valid(p: TPos):\\n    if p[0] < 0 or p[0] > n - 1:\\n        return False\\n    if p[1] < 0 or p[1] > n - 1:\\n        return False\\n    return True\\n\\n\\ndef expand_state(\\n    s,\\n    j,\\n    visited,\\n    g_function,\\n    close_list_anchor,\\n    close_list_inad,\\n    open_list,\\n    back_pointer,\\n):\\n    for itera in range(n_heuristic):\\n        open_list[itera].remove_element(s)\\n    # print(\\\"s\\\", s)\\n    # print(\\\"j\\\", j)\\n    (x, y) = s\\n    left = (x - 1, y)\\n    right = (x + 1, y)\\n    up = (x, y + 1)\\n    down = (x, y - 1)\\n\\n    for neighbours in [left, right, up, down]:\\n        if neighbours not in blocks:\\n            if valid(neighbours) and neighbours not in visited:\\n                # print(\\\"neighbour\\\", neighbours)\\n                visited.add(neighbours)\\n                back_pointer[neighbours] = -1\\n                g_function[neighbours] = float(\\\"inf\\\")\\n\\n            if valid(neighbours) and g_function[neighbours] > g_function[s] + 1:\\n                g_function[neighbours] = g_function[s] + 1\\n                back_pointer[neighbours] = s\\n                if neighbours not in close_list_anchor:\\n                    open_list[0].put(neighbours, key(neighbours, 0, goal, g_function))\\n                    if neighbours not in close_list_inad:\\n                        for var in range(1, n_heuristic):\\n                            if key(neighbours, var, goal, g_function) <= W2 * key(\\n                                neighbours, 0, goal, g_function\\n                            ):\\n                                open_list[j].put(\\n                                    neighbours, key(neighbours, var, goal, g_function)\\n                                )\\n\\n\\ndef make_common_ground():\\n    some_list = []\\n    for x in range(1, 5):\\n        for y in range(1, 6):\\n            some_list.append((x, y))\\n\\n    for x in range(15, 20):\\n        some_list.append((x, 17))\\n\\n    for x in range(10, 19):\\n        for y in range(1, 15):\\n            some_list.append((x, y))\\n\\n    # L block\\n    for x in range(1, 4):\\n        for y in range(12, 19):\\n            some_list.append((x, y))\\n    for x in range(3, 13):\\n        for y in range(16, 19):\\n            some_list.append((x, y))\\n    return some_list\\n\\n\\nheuristics = {0: consistent_heuristic, 1: heuristic_1, 2: heuristic_2}\\n\\nblocks_blk = [\\n    (0, 1),\\n    (1, 1),\\n    (2, 1),\\n    (3, 1),\\n    (4, 1),\\n    (5, 1),\\n    (6, 1),\\n    (7, 1),\\n    (8, 1),\\n    (9, 1),\\n    (10, 1),\\n    (11, 1),\\n    (12, 1),\\n    (13, 1),\\n    (14, 1),\\n    (15, 1),\\n    (16, 1),\\n    (17, 1),\\n    (18, 1),\\n    (19, 1),\\n]\\nblocks_all = make_common_ground()\\n\\n\\nblocks = blocks_blk\\n# hyper parameters\\nW1 = 1\\nW2 = 1\\nn = 20\\nn_heuristic = 3  # one consistent and two other inconsistent\\n\\n# start and end destination\\nstart = (0, 0)\\ngoal = (n - 1, n - 1)\\n\\nt = 1\\n\\n\\ndef multi_a_star(start: TPos, goal: TPos, n_heuristic: int):\\n    g_function = {start: 0, goal: float(\\\"inf\\\")}\\n    back_pointer = {start: -1, goal: -1}\\n    open_list = []\\n    visited = set()\\n\\n    for i in range(n_heuristic):\\n        open_list.append(PriorityQueue())\\n        open_list[i].put(start, key(start, i, goal, g_function))\\n\\n    close_list_anchor: list[int] = []\\n    close_list_inad: list[int] = []\\n    while open_list[0].minkey() < float(\\\"inf\\\"):\\n        for i in range(1, n_heuristic):\\n            # print(open_list[0].minkey(), open_list[i].minkey())\\n            if open_list[i].minkey() <= W2 * open_list[0].minkey():\\n                global t\\n                t += 1\\n                if g_function[goal] <= open_list[i].minkey():\\n                    if g_function[goal] < float(\\\"inf\\\"):\\n                        do_something(back_pointer, goal, start)\\n                else:\\n                    _, get_s = open_list[i].top_show()\\n                    visited.add(get_s)\\n                    expand_state(\\n                        get_s,\\n                        i,\\n                        visited,\\n                        g_function,\\n                        close_list_anchor,\\n                        close_list_inad,\\n                        open_list,\\n                        back_pointer,\\n                    )\\n                    close_list_inad.append(get_s)\\n            else:\\n                if g_function[goal] <= open_list[0].minkey():\\n                    if g_function[goal] < float(\\\"inf\\\"):\\n                        do_something(back_pointer, goal, start)\\n                else:\\n                    get_s = open_list[0].top_show()\\n                    visited.add(get_s)\\n                    expand_state(\\n                        get_s,\\n                        0,\\n                        visited,\\n                        g_function,\\n                        close_list_anchor,\\n                        close_list_inad,\\n                        open_list,\\n                        back_pointer,\\n                    )\\n                    close_list_anchor.append(get_s)\\n    print(\\\"No path found to goal\\\")\\n    print()\\n    for i in range(n - 1, -1, -1):\\n        for j in range(n):\\n            if (j, i) in blocks:\\n                print(\\\"#\\\", end=\\\" \\\")\\n            elif (j, i) in back_pointer:\\n                if (j, i) == (n - 1, n - 1):\\n                    print(\\\"*\\\", end=\\\" \\\")\\n                else:\\n                    print(\\\"-\\\", end=\\\" \\\")\\n            else:\\n                print(\\\"*\\\", end=\\\" \\\")\\n            if (j, i) == (n - 1, n - 1):\\n                print(\\\"<-- End position\\\", end=\\\" \\\")\\n        print()\\n    print(\\\"^\\\")\\n    print(\\\"Start position\\\")\\n    print()\\n    print(\\\"# is an obstacle\\\")\\n    print(\\\"- is the path taken by algorithm\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    multi_a_star(start, goal, n_heuristic)\\n\"",
    "page rank": "\"\\\"\\\"\\\"\\nAuthor: https://github.com/bhushan-borole\\n\\\"\\\"\\\"\\n\\\"\\\"\\\"\\nThe input graph for the algorithm is:\\n\\n  A B C\\nA 0 1 1\\nB 0 0 1\\nC 1 0 0\\n\\n\\\"\\\"\\\"\\n\\ngraph = [[0, 1, 1], [0, 0, 1], [1, 0, 0]]\\n\\n\\nclass Node:\\n    def __init__(self, name):\\n        self.name = name\\n        self.inbound = []\\n        self.outbound = []\\n\\n    def add_inbound(self, node):\\n        self.inbound.append(node)\\n\\n    def add_outbound(self, node):\\n        self.outbound.append(node)\\n\\n    def __repr__(self):\\n        return f\\\"Node {self.name}: Inbound: {self.inbound} ; Outbound: {self.outbound}\\\"\\n\\n\\ndef page_rank(nodes, limit=3, d=0.85):\\n    ranks = {}\\n    for node in nodes:\\n        ranks[node.name] = 1\\n\\n    outbounds = {}\\n    for node in nodes:\\n        outbounds[node.name] = len(node.outbound)\\n\\n    for i in range(limit):\\n        print(f\\\"======= Iteration {i + 1} =======\\\")\\n        for j, node in enumerate(nodes):\\n            ranks[node.name] = (1 - d) + d * sum(\\n                ranks[ib] / outbounds[ib] for ib in node.inbound\\n            )\\n        print(ranks)\\n\\n\\ndef main():\\n    names = list(input(\\\"Enter Names of the Nodes: \\\").split())\\n\\n    nodes = [Node(name) for name in names]\\n\\n    for ri, row in enumerate(graph):\\n        for ci, col in enumerate(row):\\n            if col == 1:\\n                nodes[ci].add_inbound(names[ri])\\n                nodes[ri].add_outbound(names[ci])\\n\\n    print(\\\"======= Nodes =======\\\")\\n    for node in nodes:\\n        print(node)\\n\\n    page_rank(nodes)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "prim": "\"\\\"\\\"\\\"Prim's Algorithm.\\n\\n    Determines the minimum spanning tree(MST) of a graph using the Prim's Algorithm.\\n\\n    Details: https://en.wikipedia.org/wiki/Prim%27s_algorithm\\n\\\"\\\"\\\"\\n\\nimport heapq as hq\\nimport math\\nfrom typing import Iterator\\n\\n\\nclass Vertex:\\n    \\\"\\\"\\\"Class Vertex.\\\"\\\"\\\"\\n\\n    def __init__(self, id):\\n        \\\"\\\"\\\"\\n        Arguments:\\n            id - input an id to identify the vertex\\n        Attributes:\\n            neighbors - a list of the vertices it is linked to\\n            edges     - a dict to store the edges's weight\\n        \\\"\\\"\\\"\\n        self.id = str(id)\\n        self.key = None\\n        self.pi = None\\n        self.neighbors = []\\n        self.edges = {}  # {vertex:distance}\\n\\n    def __lt__(self, other):\\n        \\\"\\\"\\\"Comparison rule to < operator.\\\"\\\"\\\"\\n        return self.key < other.key\\n\\n    def __repr__(self):\\n        \\\"\\\"\\\"Return the vertex id.\\\"\\\"\\\"\\n        return self.id\\n\\n    def add_neighbor(self, vertex):\\n        \\\"\\\"\\\"Add a pointer to a vertex at neighbor's list.\\\"\\\"\\\"\\n        self.neighbors.append(vertex)\\n\\n    def add_edge(self, vertex, weight):\\n        \\\"\\\"\\\"Destination vertex and weight.\\\"\\\"\\\"\\n        self.edges[vertex.id] = weight\\n\\n\\ndef connect(graph, a, b, edge):\\n    # add the neighbors:\\n    graph[a - 1].add_neighbor(graph[b - 1])\\n    graph[b - 1].add_neighbor(graph[a - 1])\\n    # add the edges:\\n    graph[a - 1].add_edge(graph[b - 1], edge)\\n    graph[b - 1].add_edge(graph[a - 1], edge)\\n\\n\\ndef prim(graph: list, root: Vertex) -> list:\\n    \\\"\\\"\\\"Prim's Algorithm.\\n\\n    Runtime:\\n        O(mn) with `m` edges and `n` vertices\\n\\n    Return:\\n        List with the edges of a Minimum Spanning Tree\\n\\n    Usage:\\n        prim(graph, graph[0])\\n    \\\"\\\"\\\"\\n    a = []\\n    for u in graph:\\n        u.key = math.inf\\n        u.pi = None\\n    root.key = 0\\n    q = graph[:]\\n    while q:\\n        u = min(q)\\n        q.remove(u)\\n        for v in u.neighbors:\\n            if (v in q) and (u.edges[v.id] < v.key):\\n                v.pi = u\\n                v.key = u.edges[v.id]\\n    for i in range(1, len(graph)):\\n        a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))\\n    return a\\n\\n\\ndef prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:\\n    \\\"\\\"\\\"Prim's Algorithm with min heap.\\n\\n    Runtime:\\n        O((m + n)log n) with `m` edges and `n` vertices\\n\\n    Yield:\\n        Edges of a Minimum Spanning Tree\\n\\n    Usage:\\n        prim(graph, graph[0])\\n    \\\"\\\"\\\"\\n    for u in graph:\\n        u.key = math.inf\\n        u.pi = None\\n    root.key = 0\\n\\n    h = list(graph)\\n    hq.heapify(h)\\n\\n    while h:\\n        u = hq.heappop(h)\\n        for v in u.neighbors:\\n            if (v in h) and (u.edges[v.id] < v.key):\\n                v.pi = u\\n                v.key = u.edges[v.id]\\n                hq.heapify(h)\\n\\n    for i in range(1, len(graph)):\\n        yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)\\n\\n\\ndef test_vector() -> None:\\n    \\\"\\\"\\\"\\n    # Creates a list to store x vertices.\\n    >>> x = 5\\n    >>> G = [Vertex(n) for n in range(x)]\\n\\n    >>> connect(G, 1, 2, 15)\\n    >>> connect(G, 1, 3, 12)\\n    >>> connect(G, 2, 4, 13)\\n    >>> connect(G, 2, 5, 5)\\n    >>> connect(G, 3, 2, 6)\\n    >>> connect(G, 3, 4, 6)\\n    >>> connect(G, 0, 0, 0)  # Generate the minimum spanning tree:\\n    >>> G_heap = G[:]\\n    >>> MST = prim(G, G[0])\\n    >>> MST_heap = prim_heap(G, G[0])\\n    >>> for i in MST:\\n    ...     print(i)\\n    (2, 3)\\n    (3, 1)\\n    (4, 3)\\n    (5, 2)\\n    >>> for i in MST_heap:\\n    ...     print(i)\\n    (2, 3)\\n    (3, 1)\\n    (4, 3)\\n    (5, 2)\\n    \\\"\\\"\\\"\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "random graph generator": "\"\\\"\\\"\\\"\\n* Author: Manuel Di Lullo (https://github.com/manueldilullo)\\n* Description: Random graphs generator.\\n               Uses graphs represented with an adjacency list.\\n\\nURL: https://en.wikipedia.org/wiki/Random_graph\\n\\\"\\\"\\\"\\n\\nimport random\\n\\n\\ndef random_graph(\\n    vertices_number: int, probability: float, directed: bool = False\\n) -> dict:\\n    \\\"\\\"\\\"\\n    Generate a random graph\\n    @input: vertices_number (number of vertices),\\n            probability (probability that a generic edge (u,v) exists),\\n            directed (if True: graph will be a directed graph,\\n                      otherwise it will be an undirected graph)\\n    @examples:\\n    >>> random.seed(1)\\n    >>> random_graph(4, 0.5)\\n    {0: [1], 1: [0, 2, 3], 2: [1, 3], 3: [1, 2]}\\n    >>> random.seed(1)\\n    >>> random_graph(4, 0.5, True)\\n    {0: [1], 1: [2, 3], 2: [3], 3: []}\\n    \\\"\\\"\\\"\\n    graph: dict = {i: [] for i in range(vertices_number)}\\n\\n    # if probability is greater or equal than 1, then generate a complete graph\\n    if probability >= 1:\\n        return complete_graph(vertices_number)\\n    # if probability is lower or equal than 0, then return a graph without edges\\n    if probability <= 0:\\n        return graph\\n\\n    # for each couple of nodes, add an edge from u to v\\n    # if the number randomly generated is greater than probability probability\\n    for i in range(vertices_number):\\n        for j in range(i + 1, vertices_number):\\n            if random.random() < probability:\\n                graph[i].append(j)\\n                if not directed:\\n                    # if the graph is undirected, add an edge in from j to i, either\\n                    graph[j].append(i)\\n    return graph\\n\\n\\ndef complete_graph(vertices_number: int) -> dict:\\n    \\\"\\\"\\\"\\n    Generate a complete graph with vertices_number vertices.\\n    @input: vertices_number (number of vertices),\\n            directed (False if the graph is undirected, True otherwise)\\n    @example:\\n    >>> print(complete_graph(3))\\n    {0: [1, 2], 1: [0, 2], 2: [0, 1]}\\n    \\\"\\\"\\\"\\n    return {\\n        i: [j for j in range(vertices_number) if i != j] for i in range(vertices_number)\\n    }\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "scc kosaraju": "\"from __future__ import annotations\\n\\n\\ndef dfs(u):\\n    global graph, reversedGraph, scc, component, visit, stack\\n    if visit[u]:\\n        return\\n    visit[u] = True\\n    for v in graph[u]:\\n        dfs(v)\\n    stack.append(u)\\n\\n\\ndef dfs2(u):\\n    global graph, reversedGraph, scc, component, visit, stack\\n    if visit[u]:\\n        return\\n    visit[u] = True\\n    component.append(u)\\n    for v in reversedGraph[u]:\\n        dfs2(v)\\n\\n\\ndef kosaraju():\\n    global graph, reversedGraph, scc, component, visit, stack\\n    for i in range(n):\\n        dfs(i)\\n    visit = [False] * n\\n    for i in stack[::-1]:\\n        if visit[i]:\\n            continue\\n        component = []\\n        dfs2(i)\\n        scc.append(component)\\n    return scc\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # n - no of nodes, m - no of edges\\n    n, m = list(map(int, input().strip().split()))\\n\\n    graph: list[list[int]] = [[] for i in range(n)]  # graph\\n    reversedGraph: list[list[int]] = [[] for i in range(n)]  # reversed graph\\n    # input graph data (edges)\\n    for i in range(m):\\n        u, v = list(map(int, input().strip().split()))\\n        graph[u].append(v)\\n        reversedGraph[v].append(u)\\n\\n    stack: list[int] = []\\n    visit: list[bool] = [False] * n\\n    scc: list[int] = []\\n    component: list[int] = []\\n    print(kosaraju())\\n\"",
    "strongly connected components": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Strongly_connected_component\\n\\nFinding strongly connected components in directed graph\\n\\n\\\"\\\"\\\"\\n\\ntest_graph_1 = {0: [2, 3], 1: [0], 2: [1], 3: [4], 4: []}\\n\\ntest_graph_2 = {0: [1, 2, 3], 1: [2], 2: [0], 3: [4], 4: [5], 5: [3]}\\n\\n\\ndef topology_sort(\\n    graph: dict[int, list[int]], vert: int, visited: list[bool]\\n) -> list[int]:\\n    \\\"\\\"\\\"\\n    Use depth first search to sort graph\\n    At this time graph is the same as input\\n    >>> topology_sort(test_graph_1, 0, 5 * [False])\\n    [1, 2, 4, 3, 0]\\n    >>> topology_sort(test_graph_2, 0, 6 * [False])\\n    [2, 1, 5, 4, 3, 0]\\n    \\\"\\\"\\\"\\n\\n    visited[vert] = True\\n    order = []\\n\\n    for neighbour in graph[vert]:\\n        if not visited[neighbour]:\\n            order += topology_sort(graph, neighbour, visited)\\n\\n    order.append(vert)\\n\\n    return order\\n\\n\\ndef find_components(\\n    reversed_graph: dict[int, list[int]], vert: int, visited: list[bool]\\n) -> list[int]:\\n    \\\"\\\"\\\"\\n    Use depth first search to find strongliy connected\\n    vertices. Now graph is reversed\\n    >>> find_components({0: [1], 1: [2], 2: [0]}, 0, 5 * [False])\\n    [0, 1, 2]\\n    >>> find_components({0: [2], 1: [0], 2: [0, 1]}, 0, 6 * [False])\\n    [0, 2, 1]\\n    \\\"\\\"\\\"\\n\\n    visited[vert] = True\\n    component = [vert]\\n\\n    for neighbour in reversed_graph[vert]:\\n        if not visited[neighbour]:\\n            component += find_components(reversed_graph, neighbour, visited)\\n\\n    return component\\n\\n\\ndef strongly_connected_components(graph: dict[int, list[int]]) -> list[list[int]]:\\n    \\\"\\\"\\\"\\n    This function takes graph as a parameter\\n    and then returns the list of strongly connected components\\n    >>> strongly_connected_components(test_graph_1)\\n    [[0, 1, 2], [3], [4]]\\n    >>> strongly_connected_components(test_graph_2)\\n    [[0, 2, 1], [3, 5, 4]]\\n    \\\"\\\"\\\"\\n\\n    visited = len(graph) * [False]\\n    reversed_graph: dict[int, list[int]] = {vert: [] for vert in range(len(graph))}\\n\\n    for vert, neighbours in graph.items():\\n        for neighbour in neighbours:\\n            reversed_graph[neighbour].append(vert)\\n\\n    order = []\\n    for i, was_visited in enumerate(visited):\\n        if not was_visited:\\n            order += topology_sort(graph, i, visited)\\n\\n    components_list = []\\n    visited = len(graph) * [False]\\n\\n    for i in range(len(graph)):\\n        vert = order[len(graph) - i - 1]\\n        if not visited[vert]:\\n            component = find_components(reversed_graph, vert, visited)\\n            components_list.append(component)\\n\\n    return components_list\\n\"",
    "tarjans scc": "\"from collections import deque\\n\\n\\ndef tarjan(g):\\n    \\\"\\\"\\\"\\n    Tarjan's algo for finding strongly connected components in a directed graph\\n\\n    Uses two main attributes of each node to track reachability, the index of that node\\n    within a component(index), and the lowest index reachable from that node(lowlink).\\n\\n    We then perform a dfs of the each component making sure to update these parameters\\n    for each node and saving the nodes we visit on the way.\\n\\n    If ever we find that the lowest reachable node from a current node is equal to the\\n    index of the current node then it must be the root of a strongly connected\\n    component and so we save it and it's equireachable vertices as a strongly\\n    connected component.\\n\\n    Complexity: strong_connect() is called at most once for each node and has a\\n    complexity of O(|E|) as it is DFS.\\n    Therefore this has complexity O(|V| + |E|) for a graph G = (V, E)\\n    \\\"\\\"\\\"\\n\\n    n = len(g)\\n    stack = deque()\\n    on_stack = [False for _ in range(n)]\\n    index_of = [-1 for _ in range(n)]\\n    lowlink_of = index_of[:]\\n\\n    def strong_connect(v, index, components):\\n        index_of[v] = index  # the number when this node is seen\\n        lowlink_of[v] = index  # lowest rank node reachable from here\\n        index += 1\\n        stack.append(v)\\n        on_stack[v] = True\\n\\n        for w in g[v]:\\n            if index_of[w] == -1:\\n                index = strong_connect(w, index, components)\\n                lowlink_of[v] = (\\n                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]\\n                )\\n            elif on_stack[w]:\\n                lowlink_of[v] = (\\n                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]\\n                )\\n\\n        if lowlink_of[v] == index_of[v]:\\n            component = []\\n            w = stack.pop()\\n            on_stack[w] = False\\n            component.append(w)\\n            while w != v:\\n                w = stack.pop()\\n                on_stack[w] = False\\n                component.append(w)\\n            components.append(component)\\n        return index\\n\\n    components = []\\n    for v in range(n):\\n        if index_of[v] == -1:\\n            strong_connect(v, 0, components)\\n\\n    return components\\n\\n\\ndef create_graph(n, edges):\\n    g = [[] for _ in range(n)]\\n    for u, v in edges:\\n        g[u].append(v)\\n    return g\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # Test\\n    n_vertices = 7\\n    source = [0, 0, 1, 2, 3, 3, 4, 4, 6]\\n    target = [1, 3, 2, 0, 1, 4, 5, 6, 5]\\n    edges = [(u, v) for u, v in zip(source, target)]\\n    g = create_graph(n_vertices, edges)\\n\\n    assert [[5], [6], [4], [3, 2, 1, 0]] == tarjan(g)\\n\"",
    "optimal merge pattern": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the greedy-merge-sort algorithm\\nreference: https://www.geeksforgeeks.org/optimal-file-merge-patterns/\\n\\nFor doctests run following command:\\npython3 -m doctest -v greedy_merge_sort.py\\n\\nObjective\\nMerge a set of sorted files of different length into a single sorted file.\\nWe need to find an optimal solution, where the resultant file\\nwill be generated in minimum time.\\n\\nApproach\\nIf the number of sorted files are given, there are many ways\\nto merge them into a single sorted file.\\nThis merge can be performed pair wise.\\nTo merge a m-record file and a n-record file requires possibly m+n record moves\\nthe optimal choice being,\\nmerge the two smallest files together at each step (greedy approach).\\n\\\"\\\"\\\"\\n\\n\\ndef optimal_merge_pattern(files: list) -> float:\\n    \\\"\\\"\\\"Function to merge all the files with optimum cost\\n\\n    Args:\\n        files [list]: A list of sizes of different files to be merged\\n\\n    Returns:\\n        optimal_merge_cost [int]: Optimal cost to merge all those files\\n\\n    Examples:\\n    >>> optimal_merge_pattern([2, 3, 4])\\n    14\\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\\n    205\\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\\n    96\\n    \\\"\\\"\\\"\\n    optimal_merge_cost = 0\\n    while len(files) > 1:\\n        temp = 0\\n        # Consider two files with minimum cost to be merged\\n        for i in range(2):\\n            min_index = files.index(min(files))\\n            temp += files[min_index]\\n            files.pop(min_index)\\n        files.append(temp)\\n        optimal_merge_cost += temp\\n    return optimal_merge_cost\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "adler32": "\"\\\"\\\"\\\"\\n    Adler-32 is a checksum algorithm which was invented by Mark Adler in 1995.\\n    Compared to a cyclic redundancy check of the same length, it trades reliability for\\n    speed (preferring the latter).\\n    Adler-32 is more reliable than Fletcher-16, and slightly less reliable than\\n    Fletcher-32.[2]\\n\\n    source: https://en.wikipedia.org/wiki/Adler-32\\n\\\"\\\"\\\"\\n\\n\\ndef adler32(plain_text: str) -> int:\\n    \\\"\\\"\\\"\\n    Function implements adler-32 hash.\\n    Iterates and evaluates a new value for each character\\n\\n    >>> adler32('Algorithms')\\n    363791387\\n\\n    >>> adler32('go adler em all')\\n    708642122\\n    \\\"\\\"\\\"\\n    MOD_ADLER = 65521\\n    a = 1\\n    b = 0\\n    for plain_chr in plain_text:\\n        a = (a + ord(plain_chr)) % MOD_ADLER\\n        b = (b + a) % MOD_ADLER\\n    return (b << 16) | a\\n\"",
    "chaos machine": "\"\\\"\\\"\\\"example of simple chaos machine\\\"\\\"\\\"\\n\\n# Chaos Machine (K, t, m)\\nK = [0.33, 0.44, 0.55, 0.44, 0.33]\\nt = 3\\nm = 5\\n\\n# Buffer Space (with Parameters Space)\\nbuffer_space: list[float] = []\\nparams_space: list[float] = []\\n\\n# Machine Time\\nmachine_time = 0\\n\\n\\ndef push(seed):\\n    global buffer_space, params_space, machine_time, K, m, t\\n\\n    # Choosing Dynamical Systems (All)\\n    for key, value in enumerate(buffer_space):\\n        # Evolution Parameter\\n        e = float(seed / value)\\n\\n        # Control Theory: Orbit Change\\n        value = (buffer_space[(key + 1) % m] + e) % 1\\n\\n        # Control Theory: Trajectory Change\\n        r = (params_space[key] + e) % 1 + 3\\n\\n        # Modification (Transition Function) - Jumps\\n        buffer_space[key] = round(float(r * value * (1 - value)), 10)\\n        params_space[key] = r  # Saving to Parameters Space\\n\\n    # Logistic Map\\n    assert max(buffer_space) < 1\\n    assert max(params_space) < 4\\n\\n    # Machine Time\\n    machine_time += 1\\n\\n\\ndef pull():\\n    global buffer_space, params_space, machine_time, K, m, t\\n\\n    # PRNG (Xorshift by George Marsaglia)\\n    def xorshift(X, Y):\\n        X ^= Y >> 13\\n        Y ^= X << 17\\n        X ^= Y >> 5\\n        return X\\n\\n    # Choosing Dynamical Systems (Increment)\\n    key = machine_time % m\\n\\n    # Evolution (Time Length)\\n    for i in range(0, t):\\n        # Variables (Position + Parameters)\\n        r = params_space[key]\\n        value = buffer_space[key]\\n\\n        # Modification (Transition Function) - Flow\\n        buffer_space[key] = round(float(r * value * (1 - value)), 10)\\n        params_space[key] = (machine_time * 0.01 + r * 1.01) % 1 + 3\\n\\n    # Choosing Chaotic Data\\n    X = int(buffer_space[(key + 2) % m] * (10 ** 10))\\n    Y = int(buffer_space[(key - 2) % m] * (10 ** 10))\\n\\n    # Machine Time\\n    machine_time += 1\\n\\n    return xorshift(X, Y) % 0xFFFFFFFF\\n\\n\\ndef reset():\\n    global buffer_space, params_space, machine_time, K, m, t\\n\\n    buffer_space = K\\n    params_space = [0] * m\\n    machine_time = 0\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # Initialization\\n    reset()\\n\\n    # Pushing Data (Input)\\n    import random\\n\\n    message = random.sample(range(0xFFFFFFFF), 100)\\n    for chunk in message:\\n        push(chunk)\\n\\n    # for controlling\\n    inp = \\\"\\\"\\n\\n    # Pulling Data (Output)\\n    while inp in (\\\"e\\\", \\\"E\\\"):\\n        print(\\\"%s\\\" % format(pull(), \\\"#04x\\\"))\\n        print(buffer_space)\\n        print(params_space)\\n        inp = input(\\\"(e)exit? \\\").strip()\\n\"",
    "djb2": "\"\\\"\\\"\\\"\\nThis algorithm (k=33) was first reported by Dan Bernstein many years ago in comp.lang.c\\nAnother version of this algorithm (now favored by Bernstein) uses xor:\\n    hash(i) = hash(i - 1) * 33 ^ str[i];\\n\\n    First Magic constant 33:\\n    It has never been adequately explained.\\n    It's magic because it works better than many other constants, prime or not.\\n\\n    Second Magic Constant 5381:\\n\\n    1. odd number\\n    2. prime number\\n    3. deficient number\\n    4. 001/010/100/000/101 b\\n\\n    source: http://www.cse.yorku.ca/~oz/hash.html\\n\\\"\\\"\\\"\\n\\n\\ndef djb2(s: str) -> int:\\n    \\\"\\\"\\\"\\n    Implementation of djb2 hash algorithm that\\n    is popular because of it's magic constants.\\n\\n    >>> djb2('Algorithms')\\n    3782405311\\n\\n    >>> djb2('scramble bits')\\n    1609059040\\n    \\\"\\\"\\\"\\n    hash = 5381\\n    for x in s:\\n        hash = ((hash << 5) + hash) + ord(x)\\n    return hash & 0xFFFFFFFF\\n\"",
    "enigma machine": "\"alphabets = [chr(i) for i in range(32, 126)]\\ngear_one = [i for i in range(len(alphabets))]\\ngear_two = [i for i in range(len(alphabets))]\\ngear_three = [i for i in range(len(alphabets))]\\nreflector = [i for i in reversed(range(len(alphabets)))]\\ncode = []\\ngear_one_pos = gear_two_pos = gear_three_pos = 0\\n\\n\\ndef rotator():\\n    global gear_one_pos\\n    global gear_two_pos\\n    global gear_three_pos\\n    i = gear_one[0]\\n    gear_one.append(i)\\n    del gear_one[0]\\n    gear_one_pos += 1\\n    if gear_one_pos % int(len(alphabets)) == 0:\\n        i = gear_two[0]\\n        gear_two.append(i)\\n        del gear_two[0]\\n        gear_two_pos += 1\\n        if gear_two_pos % int(len(alphabets)) == 0:\\n            i = gear_three[0]\\n            gear_three.append(i)\\n            del gear_three[0]\\n            gear_three_pos += 1\\n\\n\\ndef engine(input_character):\\n    target = alphabets.index(input_character)\\n    target = gear_one[target]\\n    target = gear_two[target]\\n    target = gear_three[target]\\n    target = reflector[target]\\n    target = gear_three.index(target)\\n    target = gear_two.index(target)\\n    target = gear_one.index(target)\\n    code.append(alphabets[target])\\n    rotator()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    decode = list(input(\\\"Type your message:\\\\n\\\"))\\n    while True:\\n        try:\\n            token = int(input(\\\"Please set token:(must be only digits)\\\\n\\\"))\\n            break\\n        except Exception as error:\\n            print(error)\\n    for i in range(token):\\n        rotator()\\n    for j in decode:\\n        engine(j)\\n    print(\\\"\\\\n\\\" + \\\"\\\".join(code))\\n    print(\\n        f\\\"\\\\nYour Token is {token} please write it down.\\\\nIf you want to decode \\\"\\n        f\\\"this message again you should input same digits as token!\\\"\\n    )\\n\"",
    "hamming code": "\"# Author: João Gustavo A. Amorim & Gabriel Kunz\\n# Author email: joaogustavoamorim@gmail.com and gabriel-kunz@uergs.edu.br\\n# Coding date:  apr 2019\\n# Black: True\\n\\n\\\"\\\"\\\"\\n    * This code implement the Hamming code:\\n        https://en.wikipedia.org/wiki/Hamming_code - In telecommunication,\\n    Hamming codes are a family of linear error-correcting codes. Hamming\\n    codes can detect up to two-bit errors or correct one-bit errors\\n    without detection of uncorrected errors. By contrast, the simple\\n    parity code cannot correct errors, and can detect only an odd number\\n    of bits in error. Hamming codes are perfect codes, that is, they\\n    achieve the highest possible rate for codes with their block length\\n    and minimum distance of three.\\n\\n    * the implemented code consists of:\\n        * a function responsible for encoding the message (emitterConverter)\\n            * return the encoded message\\n        * a function responsible for decoding the message (receptorConverter)\\n            * return the decoded message and a ack of data integrity\\n\\n    * how to use:\\n            to be used you must declare how many parity bits (sizePari)\\n        you want to include in the message.\\n            it is desired (for test purposes) to select a bit to be set\\n        as an error. This serves to check whether the code is working correctly.\\n            Lastly, the variable of the message/word that must be desired to be\\n        encoded (text).\\n\\n    * how this work:\\n            declaration of variables (sizePari, be, text)\\n\\n            converts the message/word (text) to binary using the\\n        text_to_bits function\\n            encodes the message using the rules of hamming encoding\\n            decodes the message using the rules of hamming encoding\\n            print the original message, the encoded message and the\\n        decoded message\\n\\n            forces an error in the coded text variable\\n            decodes the message that was forced the error\\n            print the original message, the encoded message, the bit changed\\n        message and the decoded message\\n\\\"\\\"\\\"\\n\\n# Imports\\nimport numpy as np\\n\\n\\n# Functions of binary conversion--------------------------------------\\ndef text_to_bits(text, encoding=\\\"utf-8\\\", errors=\\\"surrogatepass\\\"):\\n    \\\"\\\"\\\"\\n    >>> text_to_bits(\\\"msg\\\")\\n    '011011010111001101100111'\\n    \\\"\\\"\\\"\\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \\\"big\\\"))[2:]\\n    return bits.zfill(8 * ((len(bits) + 7) // 8))\\n\\n\\ndef text_from_bits(bits, encoding=\\\"utf-8\\\", errors=\\\"surrogatepass\\\"):\\n    \\\"\\\"\\\"\\n    >>> text_from_bits('011011010111001101100111')\\n    'msg'\\n    \\\"\\\"\\\"\\n    n = int(bits, 2)\\n    return n.to_bytes((n.bit_length() + 7) // 8, \\\"big\\\").decode(encoding, errors) or \\\"\\\\0\\\"\\n\\n\\n# Functions of hamming code-------------------------------------------\\ndef emitterConverter(sizePar, data):\\n    \\\"\\\"\\\"\\n    :param sizePar: how many parity bits the message must have\\n    :param data:  information bits\\n    :return: message to be transmitted by unreliable medium\\n            - bits of information merged with parity bits\\n\\n    >>> emitterConverter(4, \\\"101010111111\\\")\\n    ['1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1']\\n    \\\"\\\"\\\"\\n    if sizePar + len(data) <= 2 ** sizePar - (len(data) - 1):\\n        print(\\\"ERROR - size of parity don't match with size of data\\\")\\n        exit(0)\\n\\n    dataOut = []\\n    parity = []\\n    binPos = [bin(x)[2:] for x in range(1, sizePar + len(data) + 1)]\\n\\n    # sorted information data for the size of the output data\\n    dataOrd = []\\n    # data position template + parity\\n    dataOutGab = []\\n    # parity bit counter\\n    qtdBP = 0\\n    # counter position of data bits\\n    contData = 0\\n\\n    for x in range(1, sizePar + len(data) + 1):\\n        # Performs a template of bit positions - who should be given,\\n        # and who should be parity\\n        if qtdBP < sizePar:\\n            if (np.log(x) / np.log(2)).is_integer():\\n                dataOutGab.append(\\\"P\\\")\\n                qtdBP = qtdBP + 1\\n            else:\\n                dataOutGab.append(\\\"D\\\")\\n        else:\\n            dataOutGab.append(\\\"D\\\")\\n\\n        # Sorts the data to the new output size\\n        if dataOutGab[-1] == \\\"D\\\":\\n            dataOrd.append(data[contData])\\n            contData += 1\\n        else:\\n            dataOrd.append(None)\\n\\n    # Calculates parity\\n    qtdBP = 0  # parity bit counter\\n    for bp in range(1, sizePar + 1):\\n        # Bit counter one for a given parity\\n        contBO = 0\\n        # counter to control the loop reading\\n        contLoop = 0\\n        for x in dataOrd:\\n            if x is not None:\\n                try:\\n                    aux = (binPos[contLoop])[-1 * (bp)]\\n                except IndexError:\\n                    aux = \\\"0\\\"\\n                if aux == \\\"1\\\":\\n                    if x == \\\"1\\\":\\n                        contBO += 1\\n            contLoop += 1\\n        parity.append(contBO % 2)\\n\\n        qtdBP += 1\\n\\n    # Mount the message\\n    ContBP = 0  # parity bit counter\\n    for x in range(0, sizePar + len(data)):\\n        if dataOrd[x] is None:\\n            dataOut.append(str(parity[ContBP]))\\n            ContBP += 1\\n        else:\\n            dataOut.append(dataOrd[x])\\n\\n    return dataOut\\n\\n\\ndef receptorConverter(sizePar, data):\\n    \\\"\\\"\\\"\\n    >>> receptorConverter(4, \\\"1111010010111111\\\")\\n    (['1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1'], True)\\n    \\\"\\\"\\\"\\n    # data position template + parity\\n    dataOutGab = []\\n    # Parity bit counter\\n    qtdBP = 0\\n    # Counter p data bit reading\\n    contData = 0\\n    # list of parity received\\n    parityReceived = []\\n    dataOutput = []\\n\\n    for x in range(1, len(data) + 1):\\n        # Performs a template of bit positions - who should be given,\\n        #  and who should be parity\\n        if qtdBP < sizePar and (np.log(x) / np.log(2)).is_integer():\\n            dataOutGab.append(\\\"P\\\")\\n            qtdBP = qtdBP + 1\\n        else:\\n            dataOutGab.append(\\\"D\\\")\\n\\n        # Sorts the data to the new output size\\n        if dataOutGab[-1] == \\\"D\\\":\\n            dataOutput.append(data[contData])\\n        else:\\n            parityReceived.append(data[contData])\\n        contData += 1\\n\\n    # -----------calculates the parity with the data\\n    dataOut = []\\n    parity = []\\n    binPos = [bin(x)[2:] for x in range(1, sizePar + len(dataOutput) + 1)]\\n\\n    #  sorted information data for the size of the output data\\n    dataOrd = []\\n    # Data position feedback + parity\\n    dataOutGab = []\\n    # Parity bit counter\\n    qtdBP = 0\\n    # Counter p data bit reading\\n    contData = 0\\n\\n    for x in range(1, sizePar + len(dataOutput) + 1):\\n        # Performs a template position of bits - who should be given,\\n        # and who should be parity\\n        if qtdBP < sizePar and (np.log(x) / np.log(2)).is_integer():\\n            dataOutGab.append(\\\"P\\\")\\n            qtdBP = qtdBP + 1\\n        else:\\n            dataOutGab.append(\\\"D\\\")\\n\\n        # Sorts the data to the new output size\\n        if dataOutGab[-1] == \\\"D\\\":\\n            dataOrd.append(dataOutput[contData])\\n            contData += 1\\n        else:\\n            dataOrd.append(None)\\n\\n    # Calculates parity\\n    qtdBP = 0  # parity bit counter\\n    for bp in range(1, sizePar + 1):\\n        # Bit counter one for a certain parity\\n        contBO = 0\\n        # Counter to control loop reading\\n        contLoop = 0\\n        for x in dataOrd:\\n            if x is not None:\\n                try:\\n                    aux = (binPos[contLoop])[-1 * (bp)]\\n                except IndexError:\\n                    aux = \\\"0\\\"\\n                if aux == \\\"1\\\" and x == \\\"1\\\":\\n                    contBO += 1\\n            contLoop += 1\\n        parity.append(str(contBO % 2))\\n\\n        qtdBP += 1\\n\\n    # Mount the message\\n    ContBP = 0  # Parity bit counter\\n    for x in range(0, sizePar + len(dataOutput)):\\n        if dataOrd[x] is None:\\n            dataOut.append(str(parity[ContBP]))\\n            ContBP += 1\\n        else:\\n            dataOut.append(dataOrd[x])\\n\\n    ack = parityReceived == parity\\n    return dataOutput, ack\\n\\n\\n# ---------------------------------------------------------------------\\n\\\"\\\"\\\"\\n# Example how to use\\n\\n# number of parity bits\\nsizePari = 4\\n\\n# location of the bit that will be forced an error\\nbe = 2\\n\\n# Message/word to be encoded and decoded with hamming\\n# text = input(\\\"Enter the word to be read: \\\")\\ntext = \\\"Message01\\\"\\n\\n# Convert the message to binary\\nbinaryText = text_to_bits(text)\\n\\n# Prints the binary of the string\\nprint(\\\"Text input in binary is '\\\" + binaryText + \\\"'\\\")\\n\\n# total transmitted bits\\ntotalBits = len(binaryText) + sizePari\\nprint(\\\"Size of data is \\\" + str(totalBits))\\n\\nprint(\\\"\\\\n --Message exchange--\\\")\\nprint(\\\"Data to send ------------> \\\" + binaryText)\\ndataOut = emitterConverter(sizePari, binaryText)\\nprint(\\\"Data converted ----------> \\\" + \\\"\\\".join(dataOut))\\ndataReceiv, ack = receptorConverter(sizePari, dataOut)\\nprint(\\n    \\\"Data receive ------------> \\\"\\n    + \\\"\\\".join(dataReceiv)\\n    + \\\"\\\\t\\\\t -- Data integrity: \\\"\\n    + str(ack)\\n)\\n\\n\\nprint(\\\"\\\\n --Force error--\\\")\\nprint(\\\"Data to send ------------> \\\" + binaryText)\\ndataOut = emitterConverter(sizePari, binaryText)\\nprint(\\\"Data converted ----------> \\\" + \\\"\\\".join(dataOut))\\n\\n# forces error\\ndataOut[-be] = \\\"1\\\" * (dataOut[-be] == \\\"0\\\") + \\\"0\\\" * (dataOut[-be] == \\\"1\\\")\\nprint(\\\"Data after transmission -> \\\" + \\\"\\\".join(dataOut))\\ndataReceiv, ack = receptorConverter(sizePari, dataOut)\\nprint(\\n    \\\"Data receive ------------> \\\"\\n    + \\\"\\\".join(dataReceiv)\\n    + \\\"\\\\t\\\\t -- Data integrity: \\\"\\n    + str(ack)\\n)\\n\\\"\\\"\\\"\\n\"",
    "luhn": "\"\\\"\\\"\\\" Luhn Algorithm \\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef is_luhn(string: str) -> bool:\\n    \\\"\\\"\\\"\\n    Perform Luhn validation on an input string\\n    Algorithm:\\n    * Double every other digit starting from 2nd last digit.\\n    * Subtract 9 if number is greater than 9.\\n    * Sum the numbers\\n    *\\n    >>> test_cases = (79927398710, 79927398711, 79927398712, 79927398713,\\n    ...     79927398714, 79927398715, 79927398716, 79927398717, 79927398718,\\n    ...     79927398719)\\n    >>> [is_luhn(str(test_case)) for test_case in test_cases]\\n    [False, False, False, True, False, False, False, False, False, False]\\n    \\\"\\\"\\\"\\n    check_digit: int\\n    _vector: list[str] = list(string)\\n    __vector, check_digit = _vector[:-1], int(_vector[-1])\\n    vector: list[int] = [int(digit) for digit in __vector]\\n\\n    vector.reverse()\\n    for i, digit in enumerate(vector):\\n        if i & 1 == 0:\\n            doubled: int = digit * 2\\n            if doubled > 9:\\n                doubled -= 9\\n            check_digit += doubled\\n        else:\\n            check_digit += digit\\n\\n    return check_digit % 10 == 0\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    assert is_luhn(\\\"79927398713\\\")\\n    assert not is_luhn(\\\"79927398714\\\")\\n\"",
    "md5": "\"import math\\n\\n\\ndef rearrange(bitString32):\\n    \\\"\\\"\\\"[summary]\\n    Regroups the given binary string.\\n\\n    Arguments:\\n        bitString32 {[string]} -- [32 bit binary]\\n\\n    Raises:\\n    ValueError -- [if the given string not are 32 bit binary string]\\n\\n    Returns:\\n        [string] -- [32 bit binary string]\\n    >>> rearrange('1234567890abcdfghijklmnopqrstuvw')\\n    'pqrstuvwhijklmno90abcdfg12345678'\\n    \\\"\\\"\\\"\\n\\n    if len(bitString32) != 32:\\n        raise ValueError(\\\"Need length 32\\\")\\n    newString = \\\"\\\"\\n    for i in [3, 2, 1, 0]:\\n        newString += bitString32[8 * i : 8 * i + 8]\\n    return newString\\n\\n\\ndef reformatHex(i):\\n    \\\"\\\"\\\"[summary]\\n    Converts the given integer into 8-digit hex number.\\n\\n    Arguments:\\n            i {[int]} -- [integer]\\n    >>> reformatHex(666)\\n    '9a020000'\\n    \\\"\\\"\\\"\\n\\n    hexrep = format(i, \\\"08x\\\")\\n    thing = \\\"\\\"\\n    for i in [3, 2, 1, 0]:\\n        thing += hexrep[2 * i : 2 * i + 2]\\n    return thing\\n\\n\\ndef pad(bitString):\\n    \\\"\\\"\\\"[summary]\\n    Fills up the binary string to a 512 bit binary string\\n\\n    Arguments:\\n            bitString {[string]} -- [binary string]\\n\\n    Returns:\\n            [string] -- [binary string]\\n    \\\"\\\"\\\"\\n    startLength = len(bitString)\\n    bitString += \\\"1\\\"\\n    while len(bitString) % 512 != 448:\\n        bitString += \\\"0\\\"\\n    lastPart = format(startLength, \\\"064b\\\")\\n    bitString += rearrange(lastPart[32:]) + rearrange(lastPart[:32])\\n    return bitString\\n\\n\\ndef getBlock(bitString):\\n    \\\"\\\"\\\"[summary]\\n    Iterator:\\n            Returns by each call a list of length 16 with the 32 bit\\n            integer blocks.\\n\\n    Arguments:\\n            bitString {[string]} -- [binary string >= 512]\\n    \\\"\\\"\\\"\\n\\n    currPos = 0\\n    while currPos < len(bitString):\\n        currPart = bitString[currPos : currPos + 512]\\n        mySplits = []\\n        for i in range(16):\\n            mySplits.append(int(rearrange(currPart[32 * i : 32 * i + 32]), 2))\\n        yield mySplits\\n        currPos += 512\\n\\n\\ndef not32(i):\\n    \\\"\\\"\\\"\\n    >>> not32(34)\\n    4294967261\\n    \\\"\\\"\\\"\\n    i_str = format(i, \\\"032b\\\")\\n    new_str = \\\"\\\"\\n    for c in i_str:\\n        new_str += \\\"1\\\" if c == \\\"0\\\" else \\\"0\\\"\\n    return int(new_str, 2)\\n\\n\\ndef sum32(a, b):\\n    return (a + b) % 2 ** 32\\n\\n\\ndef leftrot32(i, s):\\n    return (i << s) ^ (i >> (32 - s))\\n\\n\\ndef md5me(testString):\\n    \\\"\\\"\\\"[summary]\\n    Returns a 32-bit hash code of the string 'testString'\\n\\n    Arguments:\\n            testString {[string]} -- [message]\\n    \\\"\\\"\\\"\\n\\n    bs = \\\"\\\"\\n    for i in testString:\\n        bs += format(ord(i), \\\"08b\\\")\\n    bs = pad(bs)\\n\\n    tvals = [int(2 ** 32 * abs(math.sin(i + 1))) for i in range(64)]\\n\\n    a0 = 0x67452301\\n    b0 = 0xEFCDAB89\\n    c0 = 0x98BADCFE\\n    d0 = 0x10325476\\n\\n    s = [\\n        7,\\n        12,\\n        17,\\n        22,\\n        7,\\n        12,\\n        17,\\n        22,\\n        7,\\n        12,\\n        17,\\n        22,\\n        7,\\n        12,\\n        17,\\n        22,\\n        5,\\n        9,\\n        14,\\n        20,\\n        5,\\n        9,\\n        14,\\n        20,\\n        5,\\n        9,\\n        14,\\n        20,\\n        5,\\n        9,\\n        14,\\n        20,\\n        4,\\n        11,\\n        16,\\n        23,\\n        4,\\n        11,\\n        16,\\n        23,\\n        4,\\n        11,\\n        16,\\n        23,\\n        4,\\n        11,\\n        16,\\n        23,\\n        6,\\n        10,\\n        15,\\n        21,\\n        6,\\n        10,\\n        15,\\n        21,\\n        6,\\n        10,\\n        15,\\n        21,\\n        6,\\n        10,\\n        15,\\n        21,\\n    ]\\n\\n    for m in getBlock(bs):\\n        A = a0\\n        B = b0\\n        C = c0\\n        D = d0\\n        for i in range(64):\\n            if i <= 15:\\n                # f = (B & C) | (not32(B) & D)\\n                f = D ^ (B & (C ^ D))\\n                g = i\\n            elif i <= 31:\\n                # f = (D & B) | (not32(D) & C)\\n                f = C ^ (D & (B ^ C))\\n                g = (5 * i + 1) % 16\\n            elif i <= 47:\\n                f = B ^ C ^ D\\n                g = (3 * i + 5) % 16\\n            else:\\n                f = C ^ (B | not32(D))\\n                g = (7 * i) % 16\\n            dtemp = D\\n            D = C\\n            C = B\\n            B = sum32(B, leftrot32((A + f + tvals[i] + m[g]) % 2 ** 32, s[i]))\\n            A = dtemp\\n        a0 = sum32(a0, A)\\n        b0 = sum32(b0, B)\\n        c0 = sum32(c0, C)\\n        d0 = sum32(d0, D)\\n\\n    digest = reformatHex(a0) + reformatHex(b0) + reformatHex(c0) + reformatHex(d0)\\n    return digest\\n\\n\\ndef test():\\n    assert md5me(\\\"\\\") == \\\"d41d8cd98f00b204e9800998ecf8427e\\\"\\n    assert (\\n        md5me(\\\"The quick brown fox jumps over the lazy dog\\\")\\n        == \\\"9e107d9d372bb6826bd81d3542a419d6\\\"\\n    )\\n    print(\\\"Success.\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    test()\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "sdbm": "\"\\\"\\\"\\\"\\n    This algorithm was created for sdbm (a public-domain reimplementation of ndbm)\\n    database library.\\n    It was found to do well in scrambling bits, causing better distribution of the keys\\n    and fewer splits.\\n    It also happens to be a good general hashing function with good distribution.\\n    The actual function (pseudo code) is:\\n        for i in i..len(str):\\n            hash(i) = hash(i - 1) * 65599 + str[i];\\n\\n    What is included below is the faster version used in gawk. [there is even a faster,\\n    duff-device version]\\n    The magic constant 65599 was picked out of thin air while experimenting with\\n    different constants.\\n    It turns out to be a prime.\\n    This is one of the algorithms used in berkeley db (see sleepycat) and elsewhere.\\n\\n    source: http://www.cse.yorku.ca/~oz/hash.html\\n\\\"\\\"\\\"\\n\\n\\ndef sdbm(plain_text: str) -> int:\\n    \\\"\\\"\\\"\\n    Function implements sdbm hash, easy to use, great for bits scrambling.\\n    iterates over each character in the given string and applies function to each of\\n    them.\\n\\n    >>> sdbm('Algorithms')\\n    1462174910723540325254304520539387479031000036\\n\\n    >>> sdbm('scramble bits')\\n    730247649148944819640658295400555317318720608290373040936089\\n    \\\"\\\"\\\"\\n    hash = 0\\n    for plain_chr in plain_text:\\n        hash = ord(plain_chr) + (hash << 6) + (hash << 16) - hash\\n    return hash\\n\"",
    "sha1": "\"\\\"\\\"\\\"\\nDemonstrates implementation of SHA1 Hash function in a Python class and gives utilities\\nto find hash of string or hash of text from a file.\\nUsage: python sha1.py --string \\\"Hello World!!\\\"\\n       python sha1.py --file \\\"hello_world.txt\\\"\\n       When run without any arguments, it prints the hash of the string \\\"Hello World!!\\n       Welcome to Cryptography\\\"\\nAlso contains a Test class to verify that the generated Hash is same as that\\nreturned by the hashlib library\\n\\nSHA1 hash or SHA1 sum of a string is a cryptographic function which means it is easy\\nto calculate forwards but extremely difficult to calculate backwards. What this means\\nis, you can easily calculate the hash of  a string, but it is extremely difficult to\\nknow the original string if you have its hash. This property is useful to communicate\\nsecurely, send encrypted messages and is very useful in payment systems, blockchain\\nand cryptocurrency etc.\\nThe Algorithm as described in the reference:\\nFirst we start with a message. The message is padded and the length of the message\\nis added to the end. It is then split into blocks of 512 bits or 64 bytes. The blocks\\nare then processed one at a time. Each block must be expanded and compressed.\\nThe value after each compression is added to a 160bit buffer called the current hash\\nstate. After the last block is processed the current hash state is returned as\\nthe final hash.\\nReference: https://deadhacker.com/2006/02/21/sha-1-illustrated/\\n\\\"\\\"\\\"\\nimport argparse\\nimport hashlib  # hashlib is only used inside the Test class\\nimport struct\\nimport unittest\\n\\n\\nclass SHA1Hash:\\n    \\\"\\\"\\\"\\n    Class to contain the entire pipeline for SHA1 Hashing Algorithm\\n    >>> SHA1Hash(bytes('Allan', 'utf-8')).final_hash()\\n    '872af2d8ac3d8695387e7c804bf0e02c18df9e6e'\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, data):\\n        \\\"\\\"\\\"\\n        Inititates the variables data and h. h is a list of 5 8-digit Hexadecimal\\n        numbers corresponding to\\n        (1732584193, 4023233417, 2562383102, 271733878, 3285377520)\\n        respectively. We will start with this as a message digest. 0x is how you write\\n        Hexadecimal numbers in Python\\n        \\\"\\\"\\\"\\n        self.data = data\\n        self.h = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]\\n\\n    @staticmethod\\n    def rotate(n, b):\\n        \\\"\\\"\\\"\\n        Static method to be used inside other methods. Left rotates n by b.\\n        >>> SHA1Hash('').rotate(12,2)\\n        48\\n        \\\"\\\"\\\"\\n        return ((n << b) | (n >> (32 - b))) & 0xFFFFFFFF\\n\\n    def padding(self):\\n        \\\"\\\"\\\"\\n        Pads the input message with zeros so that padded_data has 64 bytes or 512 bits\\n        \\\"\\\"\\\"\\n        padding = b\\\"\\\\x80\\\" + b\\\"\\\\x00\\\" * (63 - (len(self.data) + 8) % 64)\\n        padded_data = self.data + padding + struct.pack(\\\">Q\\\", 8 * len(self.data))\\n        return padded_data\\n\\n    def split_blocks(self):\\n        \\\"\\\"\\\"\\n        Returns a list of bytestrings each of length 64\\n        \\\"\\\"\\\"\\n        return [\\n            self.padded_data[i : i + 64] for i in range(0, len(self.padded_data), 64)\\n        ]\\n\\n    # @staticmethod\\n    def expand_block(self, block):\\n        \\\"\\\"\\\"\\n        Takes a bytestring-block of length 64, unpacks it to a list of integers and\\n        returns a list of 80 integers after some bit operations\\n        \\\"\\\"\\\"\\n        w = list(struct.unpack(\\\">16L\\\", block)) + [0] * 64\\n        for i in range(16, 80):\\n            w[i] = self.rotate((w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]), 1)\\n        return w\\n\\n    def final_hash(self):\\n        \\\"\\\"\\\"\\n        Calls all the other methods to process the input. Pads the data, then splits\\n        into blocks and then does a series of operations for each block (including\\n        expansion).\\n        For each block, the variable h that was initialized is copied to a,b,c,d,e\\n        and these 5 variables a,b,c,d,e undergo several changes. After all the blocks\\n        are processed, these 5 variables are pairwise added to h ie a to h[0], b to h[1]\\n        and so on.  This h becomes our final hash which is returned.\\n        \\\"\\\"\\\"\\n        self.padded_data = self.padding()\\n        self.blocks = self.split_blocks()\\n        for block in self.blocks:\\n            expanded_block = self.expand_block(block)\\n            a, b, c, d, e = self.h\\n            for i in range(0, 80):\\n                if 0 <= i < 20:\\n                    f = (b & c) | ((~b) & d)\\n                    k = 0x5A827999\\n                elif 20 <= i < 40:\\n                    f = b ^ c ^ d\\n                    k = 0x6ED9EBA1\\n                elif 40 <= i < 60:\\n                    f = (b & c) | (b & d) | (c & d)\\n                    k = 0x8F1BBCDC\\n                elif 60 <= i < 80:\\n                    f = b ^ c ^ d\\n                    k = 0xCA62C1D6\\n                a, b, c, d, e = (\\n                    self.rotate(a, 5) + f + e + k + expanded_block[i] & 0xFFFFFFFF,\\n                    a,\\n                    self.rotate(b, 30),\\n                    c,\\n                    d,\\n                )\\n            self.h = (\\n                self.h[0] + a & 0xFFFFFFFF,\\n                self.h[1] + b & 0xFFFFFFFF,\\n                self.h[2] + c & 0xFFFFFFFF,\\n                self.h[3] + d & 0xFFFFFFFF,\\n                self.h[4] + e & 0xFFFFFFFF,\\n            )\\n        return \\\"%08x%08x%08x%08x%08x\\\" % tuple(self.h)\\n\\n\\nclass SHA1HashTest(unittest.TestCase):\\n    \\\"\\\"\\\"\\n    Test class for the SHA1Hash class. Inherits the TestCase class from unittest\\n    \\\"\\\"\\\"\\n\\n    def testMatchHashes(self):\\n        msg = bytes(\\\"Test String\\\", \\\"utf-8\\\")\\n        self.assertEqual(SHA1Hash(msg).final_hash(), hashlib.sha1(msg).hexdigest())\\n\\n\\ndef main():\\n    \\\"\\\"\\\"\\n    Provides option 'string' or 'file' to take input and prints the calculated SHA1\\n    hash.  unittest.main() has been commented because we probably don't want to run\\n    the test each time.\\n    \\\"\\\"\\\"\\n    # unittest.main()\\n    parser = argparse.ArgumentParser(description=\\\"Process some strings or files\\\")\\n    parser.add_argument(\\n        \\\"--string\\\",\\n        dest=\\\"input_string\\\",\\n        default=\\\"Hello World!! Welcome to Cryptography\\\",\\n        help=\\\"Hash the string\\\",\\n    )\\n    parser.add_argument(\\\"--file\\\", dest=\\\"input_file\\\", help=\\\"Hash contents of a file\\\")\\n    args = parser.parse_args()\\n    input_string = args.input_string\\n    # In any case hash input should be a bytestring\\n    if args.input_file:\\n        with open(args.input_file, \\\"rb\\\") as f:\\n            hash_input = f.read()\\n    else:\\n        hash_input = bytes(input_string, \\\"utf-8\\\")\\n    print(SHA1Hash(hash_input).final_hash())\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "sha256": "\"# Author: M. Yathurshan\\r\\n# Black Formatter: True\\r\\n\\r\\n\\\"\\\"\\\"\\r\\nImplementation of SHA256 Hash function in a Python class and provides utilities\\r\\nto find hash of string or hash of text from a file.\\r\\n\\r\\nUsage: python sha256.py --string \\\"Hello World!!\\\"\\r\\n       python sha256.py --file \\\"hello_world.txt\\\"\\r\\n       When run without any arguments,\\r\\n       it prints the hash of the string \\\"Hello World!! Welcome to Cryptography\\\"\\r\\n\\r\\nReferences:\\r\\nhttps://qvault.io/cryptography/how-sha-2-works-step-by-step-sha-256/\\r\\nhttps://en.wikipedia.org/wiki/SHA-2\\r\\n\\\"\\\"\\\"\\r\\n\\r\\nimport argparse\\r\\nimport struct\\r\\nimport unittest\\r\\n\\r\\n\\r\\nclass SHA256:\\r\\n    \\\"\\\"\\\"\\r\\n    Class to contain the entire pipeline for SHA1 Hashing Algorithm\\r\\n\\r\\n    >>> SHA256(b'Python').hash\\r\\n    '18885f27b5af9012df19e496460f9294d5ab76128824c6f993787004f6d9a7db'\\r\\n\\r\\n    >>> SHA256(b'hello world').hash\\r\\n    'b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9'\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def __init__(self, data: bytes) -> None:\\r\\n        self.data = data\\r\\n\\r\\n        # Initialize hash values\\r\\n        self.hashes = [\\r\\n            0x6A09E667,\\r\\n            0xBB67AE85,\\r\\n            0x3C6EF372,\\r\\n            0xA54FF53A,\\r\\n            0x510E527F,\\r\\n            0x9B05688C,\\r\\n            0x1F83D9AB,\\r\\n            0x5BE0CD19,\\r\\n        ]\\r\\n\\r\\n        # Initialize round constants\\r\\n        self.round_constants = [\\r\\n            0x428A2F98,\\r\\n            0x71374491,\\r\\n            0xB5C0FBCF,\\r\\n            0xE9B5DBA5,\\r\\n            0x3956C25B,\\r\\n            0x59F111F1,\\r\\n            0x923F82A4,\\r\\n            0xAB1C5ED5,\\r\\n            0xD807AA98,\\r\\n            0x12835B01,\\r\\n            0x243185BE,\\r\\n            0x550C7DC3,\\r\\n            0x72BE5D74,\\r\\n            0x80DEB1FE,\\r\\n            0x9BDC06A7,\\r\\n            0xC19BF174,\\r\\n            0xE49B69C1,\\r\\n            0xEFBE4786,\\r\\n            0x0FC19DC6,\\r\\n            0x240CA1CC,\\r\\n            0x2DE92C6F,\\r\\n            0x4A7484AA,\\r\\n            0x5CB0A9DC,\\r\\n            0x76F988DA,\\r\\n            0x983E5152,\\r\\n            0xA831C66D,\\r\\n            0xB00327C8,\\r\\n            0xBF597FC7,\\r\\n            0xC6E00BF3,\\r\\n            0xD5A79147,\\r\\n            0x06CA6351,\\r\\n            0x14292967,\\r\\n            0x27B70A85,\\r\\n            0x2E1B2138,\\r\\n            0x4D2C6DFC,\\r\\n            0x53380D13,\\r\\n            0x650A7354,\\r\\n            0x766A0ABB,\\r\\n            0x81C2C92E,\\r\\n            0x92722C85,\\r\\n            0xA2BFE8A1,\\r\\n            0xA81A664B,\\r\\n            0xC24B8B70,\\r\\n            0xC76C51A3,\\r\\n            0xD192E819,\\r\\n            0xD6990624,\\r\\n            0xF40E3585,\\r\\n            0x106AA070,\\r\\n            0x19A4C116,\\r\\n            0x1E376C08,\\r\\n            0x2748774C,\\r\\n            0x34B0BCB5,\\r\\n            0x391C0CB3,\\r\\n            0x4ED8AA4A,\\r\\n            0x5B9CCA4F,\\r\\n            0x682E6FF3,\\r\\n            0x748F82EE,\\r\\n            0x78A5636F,\\r\\n            0x84C87814,\\r\\n            0x8CC70208,\\r\\n            0x90BEFFFA,\\r\\n            0xA4506CEB,\\r\\n            0xBEF9A3F7,\\r\\n            0xC67178F2,\\r\\n        ]\\r\\n\\r\\n        self.preprocessed_data = self.preprocessing(self.data)\\r\\n        self.final_hash()\\r\\n\\r\\n    @staticmethod\\r\\n    def preprocessing(data: bytes) -> bytes:\\r\\n        padding = b\\\"\\\\x80\\\" + (b\\\"\\\\x00\\\" * (63 - (len(data) + 8) % 64))\\r\\n        big_endian_integer = struct.pack(\\\">Q\\\", (len(data) * 8))\\r\\n        return data + padding + big_endian_integer\\r\\n\\r\\n    def final_hash(self) -> None:\\r\\n        # Convert into blocks of 64 bytes\\r\\n        self.blocks = [\\r\\n            self.preprocessed_data[x : x + 64]\\r\\n            for x in range(0, len(self.preprocessed_data), 64)\\r\\n        ]\\r\\n\\r\\n        for block in self.blocks:\\r\\n            # Convert the given block into a list of 4 byte integers\\r\\n            words = list(struct.unpack(\\\">16L\\\", block))\\r\\n            # add 48 0-ed integers\\r\\n            words += [0] * 48\\r\\n\\r\\n            a, b, c, d, e, f, g, h = self.hashes\\r\\n\\r\\n            for index in range(0, 64):\\r\\n                if index > 15:\\r\\n                    # modify the zero-ed indexes at the end of the array\\r\\n                    s0 = (\\r\\n                        self.ror(words[index - 15], 7)\\r\\n                        ^ self.ror(words[index - 15], 18)\\r\\n                        ^ (words[index - 15] >> 3)\\r\\n                    )\\r\\n                    s1 = (\\r\\n                        self.ror(words[index - 2], 17)\\r\\n                        ^ self.ror(words[index - 2], 19)\\r\\n                        ^ (words[index - 2] >> 10)\\r\\n                    )\\r\\n\\r\\n                    words[index] = (\\r\\n                        words[index - 16] + s0 + words[index - 7] + s1\\r\\n                    ) % 0x100000000\\r\\n\\r\\n                # Compression\\r\\n                S1 = self.ror(e, 6) ^ self.ror(e, 11) ^ self.ror(e, 25)\\r\\n                ch = (e & f) ^ ((~e & (0xFFFFFFFF)) & g)\\r\\n                temp1 = (\\r\\n                    h + S1 + ch + self.round_constants[index] + words[index]\\r\\n                ) % 0x100000000\\r\\n                S0 = self.ror(a, 2) ^ self.ror(a, 13) ^ self.ror(a, 22)\\r\\n                maj = (a & b) ^ (a & c) ^ (b & c)\\r\\n                temp2 = (S0 + maj) % 0x100000000\\r\\n\\r\\n                h, g, f, e, d, c, b, a = (\\r\\n                    g,\\r\\n                    f,\\r\\n                    e,\\r\\n                    ((d + temp1) % 0x100000000),\\r\\n                    c,\\r\\n                    b,\\r\\n                    a,\\r\\n                    ((temp1 + temp2) % 0x100000000),\\r\\n                )\\r\\n\\r\\n            mutated_hash_values = [a, b, c, d, e, f, g, h]\\r\\n\\r\\n            # Modify final values\\r\\n            self.hashes = [\\r\\n                ((element + mutated_hash_values[index]) % 0x100000000)\\r\\n                for index, element in enumerate(self.hashes)\\r\\n            ]\\r\\n\\r\\n        self.hash = \\\"\\\".join([hex(value)[2:].zfill(8) for value in self.hashes])\\r\\n\\r\\n    def ror(self, value: int, rotations: int) -> int:\\r\\n        \\\"\\\"\\\"\\r\\n        Right rotate a given unsigned number by a certain amount of rotations\\r\\n        \\\"\\\"\\\"\\r\\n        return 0xFFFFFFFF & (value << (32 - rotations)) | (value >> rotations)\\r\\n\\r\\n\\r\\nclass SHA256HashTest(unittest.TestCase):\\r\\n    \\\"\\\"\\\"\\r\\n    Test class for the SHA256 class. Inherits the TestCase class from unittest\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def test_match_hashes(self) -> None:\\r\\n        import hashlib\\r\\n\\r\\n        msg = bytes(\\\"Test String\\\", \\\"utf-8\\\")\\r\\n        self.assertEqual(SHA256(msg).hash, hashlib.sha256(msg).hexdigest())\\r\\n\\r\\n\\r\\ndef main() -> None:\\r\\n    \\\"\\\"\\\"\\r\\n    Provides option 'string' or 'file' to take input\\r\\n    and prints the calculated SHA-256 hash\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    # unittest.main()\\r\\n\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\\r\\n    parser = argparse.ArgumentParser()\\r\\n    parser.add_argument(\\r\\n        \\\"-s\\\",\\r\\n        \\\"--string\\\",\\r\\n        dest=\\\"input_string\\\",\\r\\n        default=\\\"Hello World!! Welcome to Cryptography\\\",\\r\\n        help=\\\"Hash the string\\\",\\r\\n    )\\r\\n    parser.add_argument(\\r\\n        \\\"-f\\\", \\\"--file\\\", dest=\\\"input_file\\\", help=\\\"Hash contents of a file\\\"\\r\\n    )\\r\\n\\r\\n    args = parser.parse_args()\\r\\n\\r\\n    input_string = args.input_string\\r\\n\\r\\n    # hash input should be a bytestring\\r\\n    if args.input_file:\\r\\n        with open(args.input_file, \\\"rb\\\") as f:\\r\\n            hash_input = f.read()\\r\\n    else:\\r\\n        hash_input = bytes(input_string, \\\"utf-8\\\")\\r\\n\\r\\n    print(SHA256(hash_input).hash)\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    main()\\r\\n\"",
    "greedy knapsack": "\"# To get an insight into Greedy Algorithm through the Knapsack problem\\n\\n\\n\\\"\\\"\\\"\\nA shopkeeper has bags of wheat that each have different weights and different profits.\\neg.\\nprofit 5 8 7 1 12 3 4\\nweight 2 7 1 6  4 2 5\\nmax_weight 100\\n\\nConstraints:\\nmax_weight > 0\\nprofit[i] >= 0\\nweight[i] >= 0\\nCalculate the maximum profit that the shopkeeper can make given maxmum weight that can\\nbe carried.\\n\\\"\\\"\\\"\\n\\n\\ndef calc_profit(profit: list, weight: list, max_weight: int) -> int:\\n    \\\"\\\"\\\"\\n    Function description is as follows-\\n    :param profit: Take a list of profits\\n    :param weight: Take a list of weight if bags corresponding to the profits\\n    :param max_weight: Maximum weight that could be carried\\n    :return: Maximum expected gain\\n\\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\\n    6\\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\\n    27\\n    \\\"\\\"\\\"\\n    if len(profit) != len(weight):\\n        raise ValueError(\\\"The length of profit and weight must be same.\\\")\\n    if max_weight <= 0:\\n        raise ValueError(\\\"max_weight must greater than zero.\\\")\\n    if any(p < 0 for p in profit):\\n        raise ValueError(\\\"Profit can not be negative.\\\")\\n    if any(w < 0 for w in weight):\\n        raise ValueError(\\\"Weight can not be negative.\\\")\\n\\n    # List created to store profit gained for the 1kg in case of each weight\\n    # respectively.  Calculate and append profit/weight for each element.\\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\\n\\n    # Creating a copy of the list and sorting profit/weight in ascending order\\n    sorted_profit_by_weight = sorted(profit_by_weight)\\n\\n    # declaring useful variables\\n    length = len(sorted_profit_by_weight)\\n    limit = 0\\n    gain = 0\\n    i = 0\\n\\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\\n    while limit <= max_weight and i < length:\\n        # flag value for encountered greatest element in sorted_profit_by_weight\\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\\n        \\\"\\\"\\\"\\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\\n        This will give the index of the first encountered element which is same as of\\n        biggest_profit_by_weight.  There may be one or more values same as that of\\n        biggest_profit_by_weight but index always encounter the very first element\\n        only.  To curb this alter the values in profit_by_weight once they are used\\n        here it is done to -1 because neither profit nor weight can be in negative.\\n        \\\"\\\"\\\"\\n        index = profit_by_weight.index(biggest_profit_by_weight)\\n        profit_by_weight[index] = -1\\n\\n        # check if the weight encountered is less than the total weight\\n        # encountered before.\\n        if max_weight - limit >= weight[index]:\\n            limit += weight[index]\\n            # Adding profit gained for the given weight 1 ===\\n            # weight[index]/weight[index]\\n            gain += 1 * profit[index]\\n        else:\\n            # Since the weight encountered is greater than limit, therefore take the\\n            # required number of remaining kgs and calculate profit for it.\\n            # weight remaining / weight[index]\\n            gain += (max_weight - limit) / weight[index] * profit[index]\\n            break\\n        i += 1\\n    return gain\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\n        \\\"Input profits, weights, and then max_weight (all positive ints) separated by \\\"\\n        \\\"spaces.\\\"\\n    )\\n\\n    profit = [int(x) for x in input(\\\"Input profits separated by spaces: \\\").split()]\\n    weight = [int(x) for x in input(\\\"Input weights separated by spaces: \\\").split()]\\n    max_weight = int(input(\\\"Max weight allowed: \\\"))\\n\\n    # Function Call\\n    calc_profit(profit, weight, max_weight)\\n\"",
    "astar": "\"\\\"\\\"\\\"\\nThe A* algorithm combines features of uniform-cost search and pure\\nheuristic search to efficiently compute optimal solutions.\\nA* algorithm is a best-first search algorithm in which the cost\\nassociated with a node is f(n) = g(n) + h(n),\\nwhere g(n) is the cost of the path from the initial state to node n and\\nh(n) is the heuristic estimate or the cost or a path\\nfrom node n to a goal.A* algorithm introduces a heuristic into a\\nregular graph-searching algorithm,\\nessentially planning ahead at each step so a more optimal decision\\nis made.A* also known as the algorithm with brains\\n\\\"\\\"\\\"\\nimport numpy as np\\n\\n\\nclass Cell:\\n    \\\"\\\"\\\"\\n    Class cell represents a cell in the world which have the property\\n    position : The position of the represented by  tupleof x and y\\n    coordinates initially set to (0,0)\\n    parent : This contains the parent cell object which we visited\\n    before arrinving this cell\\n    g,h,f : The parameters for constructing the heuristic function\\n    which can be any function. for simplicity used line\\n    distance\\n    \\\"\\\"\\\"\\n\\n    def __init__(self):\\n        self.position = (0, 0)\\n        self.parent = None\\n\\n        self.g = 0\\n        self.h = 0\\n        self.f = 0\\n\\n    \\\"\\\"\\\"\\n    overrides equals method because otherwise cell assign will give\\n    wrong results\\n    \\\"\\\"\\\"\\n\\n    def __eq__(self, cell):\\n        return self.position == cell.position\\n\\n    def showcell(self):\\n        print(self.position)\\n\\n\\nclass Gridworld:\\n    \\\"\\\"\\\"\\n    Gridworld class represents the  external world here a grid M*M\\n    matrix\\n    world_size: create a numpy array with the given world_size default is 5\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, world_size=(5, 5)):\\n        self.w = np.zeros(world_size)\\n        self.world_x_limit = world_size[0]\\n        self.world_y_limit = world_size[1]\\n\\n    def show(self):\\n        print(self.w)\\n\\n    def get_neigbours(self, cell):\\n        \\\"\\\"\\\"\\n        Return the neighbours of cell\\n        \\\"\\\"\\\"\\n        neughbour_cord = [\\n            (-1, -1),\\n            (-1, 0),\\n            (-1, 1),\\n            (0, -1),\\n            (0, 1),\\n            (1, -1),\\n            (1, 0),\\n            (1, 1),\\n        ]\\n        current_x = cell.position[0]\\n        current_y = cell.position[1]\\n        neighbours = []\\n        for n in neughbour_cord:\\n            x = current_x + n[0]\\n            y = current_y + n[1]\\n            if 0 <= x < self.world_x_limit and 0 <= y < self.world_y_limit:\\n                c = Cell()\\n                c.position = (x, y)\\n                c.parent = cell\\n                neighbours.append(c)\\n        return neighbours\\n\\n\\ndef astar(world, start, goal):\\n    \\\"\\\"\\\"\\n    Implementation of a start algorithm\\n    world : Object of the world object\\n    start : Object of the cell as  start position\\n    stop  : Object of the cell as goal position\\n\\n    >>> p = Gridworld()\\n    >>> start = Cell()\\n    >>> start.position = (0,0)\\n    >>> goal = Cell()\\n    >>> goal.position = (4,4)\\n    >>> astar(p, start, goal)\\n    [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\\n    \\\"\\\"\\\"\\n    _open = []\\n    _closed = []\\n    _open.append(start)\\n\\n    while _open:\\n        min_f = np.argmin([n.f for n in _open])\\n        current = _open[min_f]\\n        _closed.append(_open.pop(min_f))\\n        if current == goal:\\n            break\\n        for n in world.get_neigbours(current):\\n            for c in _closed:\\n                if c == n:\\n                    continue\\n            n.g = current.g + 1\\n            x1, y1 = n.position\\n            x2, y2 = goal.position\\n            n.h = (y2 - y1) ** 2 + (x2 - x1) ** 2\\n            n.f = n.h + n.g\\n\\n            for c in _open:\\n                if c == n and c.f < n.f:\\n                    continue\\n            _open.append(n)\\n    path = []\\n    while current.parent is not None:\\n        path.append(current.position)\\n        current = current.parent\\n    path.append(current.position)\\n    return path[::-1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    world = Gridworld()\\n    #   stat position and Goal\\n    start = Cell()\\n    start.position = (0, 0)\\n    goal = Cell()\\n    goal.position = (4, 4)\\n    print(f\\\"path from {start.position} to {goal.position}\\\")\\n    s = astar(world, start, goal)\\n    #   Just for visual reasons\\n    for i in s:\\n        world.w[i] = 1\\n    print(world.w)\\n\"",
    "data transformations": "\"\\\"\\\"\\\"\\nNormalization Wikipedia: https://en.wikipedia.org/wiki/Normalization\\nNormalization is the process of converting numerical data to a standard range of values.\\nThis range is typically between [0, 1] or [-1, 1]. The equation for normalization is\\nx_norm = (x - x_min)/(x_max - x_min) where x_norm is the normalized value, x is the\\nvalue, x_min is the minimum value within the column or list of data, and x_max is the\\nmaximum value within the column or list of data. Normalization is used to speed up the\\ntraining of data and put all of the data on a similar scale. This is useful because\\nvariance in the range of values of a dataset can heavily impact optimization\\n(particularly Gradient Descent).\\n\\nStandardization Wikipedia: https://en.wikipedia.org/wiki/Standardization\\nStandardization is the process of converting numerical data to a normally distributed\\nrange of values. This range will have a mean of 0 and standard deviation of 1. This is\\nalso known as z-score normalization. The equation for standardization is\\nx_std = (x - mu)/(sigma) where mu is the mean of the column or list of values and sigma\\nis the standard deviation of the column or list of values.\\n\\nChoosing between Normalization & Standardization is more of an art of a science, but it\\nis often recommended to run experiments with both to see which performs better.\\nAdditionally, a few rules of thumb are:\\n    1. gaussian (normal) distributions work better with standardization\\n    2. non-gaussian (non-normal) distributions work better with normalization\\n    3. If a column or list of values has extreme values / outliers, use standardization\\n\\\"\\\"\\\"\\nfrom statistics import mean, stdev\\n\\n\\ndef normalization(data: list, ndigits: int = 3) -> list:\\n    \\\"\\\"\\\"\\n    Returns a normalized list of values\\n    @params: data, a list of values to normalize\\n    @returns: a list of normalized values (rounded to ndigits decimal places)\\n    @examples:\\n    >>> normalization([2, 7, 10, 20, 30, 50])\\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\\n    >>> normalization([5, 10, 15, 20, 25])\\n    [0.0, 0.25, 0.5, 0.75, 1.0]\\n    \\\"\\\"\\\"\\n    # variables for calculation\\n    x_min = min(data)\\n    x_max = max(data)\\n    # normalize data\\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]\\n\\n\\ndef standardization(data: list, ndigits: int = 3) -> list:\\n    \\\"\\\"\\\"\\n    Returns a standardized list of values\\n    @params: data, a list of values to standardize\\n    @returns: a list of standardized values (rounded to ndigits decimal places)\\n    @examples:\\n    >>> standardization([2, 7, 10, 20, 30, 50])\\n    [-0.999, -0.719, -0.551, 0.009, 0.57, 1.69]\\n    >>> standardization([5, 10, 15, 20, 25])\\n    [-1.265, -0.632, 0.0, 0.632, 1.265]\\n    \\\"\\\"\\\"\\n    # variables for calculation\\n    mu = mean(data)\\n    sigma = stdev(data)\\n    # standardize data\\n    return [round((x - mu) / (sigma), ndigits) for x in data]\\n\"",
    "decision tree": "\"\\\"\\\"\\\"\\nImplementation of a basic regression decision tree.\\nInput data set: The input data set must be 1-dimensional with continuous labels.\\nOutput: The decision tree maps a real number input to a real number output.\\n\\\"\\\"\\\"\\nimport numpy as np\\n\\n\\nclass Decision_Tree:\\n    def __init__(self, depth=5, min_leaf_size=5):\\n        self.depth = depth\\n        self.decision_boundary = 0\\n        self.left = None\\n        self.right = None\\n        self.min_leaf_size = min_leaf_size\\n        self.prediction = None\\n\\n    def mean_squared_error(self, labels, prediction):\\n        \\\"\\\"\\\"\\n        mean_squared_error:\\n        @param labels: a one dimensional numpy array\\n        @param prediction: a floating point value\\n        return value: mean_squared_error calculates the error if prediction is used to\\n            estimate the labels\\n        >>> tester = Decision_Tree()\\n        >>> test_labels = np.array([1,2,3,4,5,6,7,8,9,10])\\n        >>> test_prediction = np.float(6)\\n        >>> tester.mean_squared_error(test_labels, test_prediction) == (\\n        ...     Test_Decision_Tree.helper_mean_squared_error_test(test_labels,\\n        ...         test_prediction))\\n        True\\n        >>> test_labels = np.array([1,2,3])\\n        >>> test_prediction = np.float(2)\\n        >>> tester.mean_squared_error(test_labels, test_prediction) == (\\n        ...     Test_Decision_Tree.helper_mean_squared_error_test(test_labels,\\n        ...         test_prediction))\\n        True\\n        \\\"\\\"\\\"\\n        if labels.ndim != 1:\\n            print(\\\"Error: Input labels must be one dimensional\\\")\\n\\n        return np.mean((labels - prediction) ** 2)\\n\\n    def train(self, X, y):\\n        \\\"\\\"\\\"\\n        train:\\n        @param X: a one dimensional numpy array\\n        @param y: a one dimensional numpy array.\\n        The contents of y are the labels for the corresponding X values\\n\\n        train does not have a return value\\n        \\\"\\\"\\\"\\n\\n        \\\"\\\"\\\"\\n        this section is to check that the inputs conform to our dimensionality\\n        constraints\\n        \\\"\\\"\\\"\\n        if X.ndim != 1:\\n            print(\\\"Error: Input data set must be one dimensional\\\")\\n            return\\n        if len(X) != len(y):\\n            print(\\\"Error: X and y have different lengths\\\")\\n            return\\n        if y.ndim != 1:\\n            print(\\\"Error: Data set labels must be one dimensional\\\")\\n            return\\n\\n        if len(X) < 2 * self.min_leaf_size:\\n            self.prediction = np.mean(y)\\n            return\\n\\n        if self.depth == 1:\\n            self.prediction = np.mean(y)\\n            return\\n\\n        best_split = 0\\n        min_error = self.mean_squared_error(X, np.mean(y)) * 2\\n\\n        \\\"\\\"\\\"\\n        loop over all possible splits for the decision tree. find the best split.\\n        if no split exists that is less than 2 * error for the entire array\\n        then the data set is not split and the average for the entire array is used as\\n        the predictor\\n        \\\"\\\"\\\"\\n        for i in range(len(X)):\\n            if len(X[:i]) < self.min_leaf_size:\\n                continue\\n            elif len(X[i:]) < self.min_leaf_size:\\n                continue\\n            else:\\n                error_left = self.mean_squared_error(X[:i], np.mean(y[:i]))\\n                error_right = self.mean_squared_error(X[i:], np.mean(y[i:]))\\n                error = error_left + error_right\\n                if error < min_error:\\n                    best_split = i\\n                    min_error = error\\n\\n        if best_split != 0:\\n            left_X = X[:best_split]\\n            left_y = y[:best_split]\\n            right_X = X[best_split:]\\n            right_y = y[best_split:]\\n\\n            self.decision_boundary = X[best_split]\\n            self.left = Decision_Tree(\\n                depth=self.depth - 1, min_leaf_size=self.min_leaf_size\\n            )\\n            self.right = Decision_Tree(\\n                depth=self.depth - 1, min_leaf_size=self.min_leaf_size\\n            )\\n            self.left.train(left_X, left_y)\\n            self.right.train(right_X, right_y)\\n        else:\\n            self.prediction = np.mean(y)\\n\\n        return\\n\\n    def predict(self, x):\\n        \\\"\\\"\\\"\\n        predict:\\n        @param x: a floating point value to predict the label of\\n        the prediction function works by recursively calling the predict function\\n        of the appropriate subtrees based on the tree's decision boundary\\n        \\\"\\\"\\\"\\n        if self.prediction is not None:\\n            return self.prediction\\n        elif self.left or self.right is not None:\\n            if x >= self.decision_boundary:\\n                return self.right.predict(x)\\n            else:\\n                return self.left.predict(x)\\n        else:\\n            print(\\\"Error: Decision tree not yet trained\\\")\\n            return None\\n\\n\\nclass Test_Decision_Tree:\\n    \\\"\\\"\\\"Decision Tres test class\\\"\\\"\\\"\\n\\n    @staticmethod\\n    def helper_mean_squared_error_test(labels, prediction):\\n        \\\"\\\"\\\"\\n        helper_mean_squared_error_test:\\n        @param labels: a one dimensional numpy array\\n        @param prediction: a floating point value\\n        return value: helper_mean_squared_error_test calculates the mean squared error\\n        \\\"\\\"\\\"\\n        squared_error_sum = np.float(0)\\n        for label in labels:\\n            squared_error_sum += (label - prediction) ** 2\\n\\n        return np.float(squared_error_sum / labels.size)\\n\\n\\ndef main():\\n    \\\"\\\"\\\"\\n    In this demonstration we're generating a sample data set from the sin function in\\n    numpy.  We then train a decision tree on the data set and use the decision tree to\\n    predict the label of 10 different test values. Then the mean squared error over\\n    this test is displayed.\\n    \\\"\\\"\\\"\\n    X = np.arange(-1.0, 1.0, 0.005)\\n    y = np.sin(X)\\n\\n    tree = Decision_Tree(depth=10, min_leaf_size=10)\\n    tree.train(X, y)\\n\\n    test_cases = (np.random.rand(10) * 2) - 1\\n    predictions = np.array([tree.predict(x) for x in test_cases])\\n    avg_error = np.mean((predictions - test_cases) ** 2)\\n\\n    print(\\\"Test values: \\\" + str(test_cases))\\n    print(\\\"Predictions: \\\" + str(predictions))\\n    print(\\\"Average error: \\\" + str(avg_error))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n    import doctest\\n\\n    doctest.testmod(name=\\\"mean_squarred_error\\\", verbose=True)\\n\"",
    "gaussian naive bayes": "\"# Gaussian Naive Bayes Example\\nfrom matplotlib import pyplot as plt\\nfrom sklearn.datasets import load_iris\\nfrom sklearn.metrics import plot_confusion_matrix\\nfrom sklearn.model_selection import train_test_split\\nfrom sklearn.naive_bayes import GaussianNB\\n\\n\\ndef main():\\n\\n    \\\"\\\"\\\"\\n    Gaussian Naive Bayes Example using sklearn function.\\n    Iris type dataset is used to demonstrate algorithm.\\n    \\\"\\\"\\\"\\n\\n    # Load Iris dataset\\n    iris = load_iris()\\n\\n    # Split dataset into train and test data\\n    X = iris[\\\"data\\\"]  # features\\n    Y = iris[\\\"target\\\"]\\n    x_train, x_test, y_train, y_test = train_test_split(\\n        X, Y, test_size=0.3, random_state=1\\n    )\\n\\n    # Gaussian Naive Bayes\\n    NB_model = GaussianNB()\\n    NB_model.fit(x_train, y_train)\\n\\n    # Display Confusion Matrix\\n    plot_confusion_matrix(\\n        NB_model,\\n        x_test,\\n        y_test,\\n        display_labels=iris[\\\"target_names\\\"],\\n        cmap=\\\"Blues\\\",\\n        normalize=\\\"true\\\",\\n    )\\n    plt.title(\\\"Normalized Confusion Matrix - IRIS Dataset\\\")\\n    plt.show()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "gradient boosting regressor": "\"\\\"\\\"\\\"Implementation of GradientBoostingRegressor in sklearn using the\\n   boston dataset which is very popular for regression problem to\\n   predict house price.\\n\\\"\\\"\\\"\\n\\nimport matplotlib.pyplot as plt\\nimport pandas as pd\\nfrom sklearn.datasets import load_boston\\nfrom sklearn.ensemble import GradientBoostingRegressor\\nfrom sklearn.metrics import mean_squared_error, r2_score\\nfrom sklearn.model_selection import train_test_split\\n\\n\\ndef main():\\n\\n    # loading the dataset from the sklearn\\n    df = load_boston()\\n    print(df.keys())\\n    # now let construct a data frame\\n    df_boston = pd.DataFrame(df.data, columns=df.feature_names)\\n    # let add the target to the dataframe\\n    df_boston[\\\"Price\\\"] = df.target\\n    # print the first five rows using the head function\\n    print(df_boston.head())\\n    # Summary statistics\\n    print(df_boston.describe().T)\\n    # Feature selection\\n\\n    X = df_boston.iloc[:, :-1]\\n    y = df_boston.iloc[:, -1]  # target variable\\n    # split the data with 75% train and 25% test sets.\\n    X_train, X_test, y_train, y_test = train_test_split(\\n        X, y, random_state=0, test_size=0.25\\n    )\\n\\n    model = GradientBoostingRegressor(\\n        n_estimators=500, max_depth=5, min_samples_split=4, learning_rate=0.01\\n    )\\n    # training the model\\n    model.fit(X_train, y_train)\\n    # to see how good the model fit the data\\n    training_score = model.score(X_train, y_train).round(3)\\n    test_score = model.score(X_test, y_test).round(3)\\n    print(\\\"Training score of GradientBoosting is :\\\", training_score)\\n    print(\\\"The test score of GradientBoosting is :\\\", test_score)\\n    # Let us evaluation the model by finding the errors\\n    y_pred = model.predict(X_test)\\n\\n    # The mean squared error\\n    print(\\\"Mean squared error: %.2f\\\" % mean_squared_error(y_test, y_pred))\\n    # Explained variance score: 1 is perfect prediction\\n    print(\\\"Test Variance score: %.2f\\\" % r2_score(y_test, y_pred))\\n\\n    # So let's run the model against the test data\\n    fig, ax = plt.subplots()\\n    ax.scatter(y_test, y_pred, edgecolors=(0, 0, 0))\\n    ax.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], \\\"k--\\\", lw=4)\\n    ax.set_xlabel(\\\"Actual\\\")\\n    ax.set_ylabel(\\\"Predicted\\\")\\n    ax.set_title(\\\"Truth vs Predicted\\\")\\n    # this show function will display the plotting\\n    plt.show()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "gradient descent": "\"\\\"\\\"\\\"\\nImplementation of gradient descent algorithm for minimizing cost of a linear hypothesis\\nfunction.\\n\\\"\\\"\\\"\\nimport numpy\\n\\n# List of input, output pairs\\ntrain_data = (\\n    ((5, 2, 3), 15),\\n    ((6, 5, 9), 25),\\n    ((11, 12, 13), 41),\\n    ((1, 1, 1), 8),\\n    ((11, 12, 13), 41),\\n)\\ntest_data = (((515, 22, 13), 555), ((61, 35, 49), 150))\\nparameter_vector = [2, 4, 1, 5]\\nm = len(train_data)\\nLEARNING_RATE = 0.009\\n\\n\\ndef _error(example_no, data_set=\\\"train\\\"):\\n    \\\"\\\"\\\"\\n    :param data_set: train data or test data\\n    :param example_no: example number whose error has to be checked\\n    :return: error in example pointed by example number.\\n    \\\"\\\"\\\"\\n    return calculate_hypothesis_value(example_no, data_set) - output(\\n        example_no, data_set\\n    )\\n\\n\\ndef _hypothesis_value(data_input_tuple):\\n    \\\"\\\"\\\"\\n    Calculates hypothesis function value for a given input\\n    :param data_input_tuple: Input tuple of a particular example\\n    :return: Value of hypothesis function at that point.\\n    Note that there is an 'biased input' whose value is fixed as 1.\\n    It is not explicitly mentioned in input data.. But, ML hypothesis functions use it.\\n    So, we have to take care of it separately. Line 36 takes care of it.\\n    \\\"\\\"\\\"\\n    hyp_val = 0\\n    for i in range(len(parameter_vector) - 1):\\n        hyp_val += data_input_tuple[i] * parameter_vector[i + 1]\\n    hyp_val += parameter_vector[0]\\n    return hyp_val\\n\\n\\ndef output(example_no, data_set):\\n    \\\"\\\"\\\"\\n    :param data_set: test data or train data\\n    :param example_no: example whose output is to be fetched\\n    :return: output for that example\\n    \\\"\\\"\\\"\\n    if data_set == \\\"train\\\":\\n        return train_data[example_no][1]\\n    elif data_set == \\\"test\\\":\\n        return test_data[example_no][1]\\n\\n\\ndef calculate_hypothesis_value(example_no, data_set):\\n    \\\"\\\"\\\"\\n    Calculates hypothesis value for a given example\\n    :param data_set: test data or train_data\\n    :param example_no: example whose hypothesis value is to be calculated\\n    :return: hypothesis value for that example\\n    \\\"\\\"\\\"\\n    if data_set == \\\"train\\\":\\n        return _hypothesis_value(train_data[example_no][0])\\n    elif data_set == \\\"test\\\":\\n        return _hypothesis_value(test_data[example_no][0])\\n\\n\\ndef summation_of_cost_derivative(index, end=m):\\n    \\\"\\\"\\\"\\n    Calculates the sum of cost function derivative\\n    :param index: index wrt derivative is being calculated\\n    :param end: value where summation ends, default is m, number of examples\\n    :return: Returns the summation of cost derivative\\n    Note: If index is -1, this means we are calculating summation wrt to biased\\n        parameter.\\n    \\\"\\\"\\\"\\n    summation_value = 0\\n    for i in range(end):\\n        if index == -1:\\n            summation_value += _error(i)\\n        else:\\n            summation_value += _error(i) * train_data[i][0][index]\\n    return summation_value\\n\\n\\ndef get_cost_derivative(index):\\n    \\\"\\\"\\\"\\n    :param index: index of the parameter vector wrt to derivative is to be calculated\\n    :return: derivative wrt to that index\\n    Note: If index is -1, this means we are calculating summation wrt to biased\\n        parameter.\\n    \\\"\\\"\\\"\\n    cost_derivative_value = summation_of_cost_derivative(index, m) / m\\n    return cost_derivative_value\\n\\n\\ndef run_gradient_descent():\\n    global parameter_vector\\n    # Tune these values to set a tolerance value for predicted output\\n    absolute_error_limit = 0.000002\\n    relative_error_limit = 0\\n    j = 0\\n    while True:\\n        j += 1\\n        temp_parameter_vector = [0, 0, 0, 0]\\n        for i in range(0, len(parameter_vector)):\\n            cost_derivative = get_cost_derivative(i - 1)\\n            temp_parameter_vector[i] = (\\n                parameter_vector[i] - LEARNING_RATE * cost_derivative\\n            )\\n        if numpy.allclose(\\n            parameter_vector,\\n            temp_parameter_vector,\\n            atol=absolute_error_limit,\\n            rtol=relative_error_limit,\\n        ):\\n            break\\n        parameter_vector = temp_parameter_vector\\n    print((\\\"Number of iterations:\\\", j))\\n\\n\\ndef test_gradient_descent():\\n    for i in range(len(test_data)):\\n        print((\\\"Actual output value:\\\", output(i, \\\"test\\\")))\\n        print((\\\"Hypothesis output:\\\", calculate_hypothesis_value(i, \\\"test\\\")))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    run_gradient_descent()\\n    print(\\\"\\\\nTesting gradient descent for a linear hypothesis function.\\\\n\\\")\\n    test_gradient_descent()\\n\"",
    "knn sklearn": "\"from sklearn.datasets import load_iris\\nfrom sklearn.model_selection import train_test_split\\nfrom sklearn.neighbors import KNeighborsClassifier\\n\\n# Load iris file\\niris = load_iris()\\niris.keys()\\n\\n\\nprint(f\\\"Target names: \\\\n {iris.target_names} \\\")\\nprint(f\\\"\\\\n Features: \\\\n {iris.feature_names}\\\")\\n\\n# Train set e Test set\\nX_train, X_test, y_train, y_test = train_test_split(\\n    iris[\\\"data\\\"], iris[\\\"target\\\"], random_state=4\\n)\\n\\n# KNN\\n\\nknn = KNeighborsClassifier(n_neighbors=1)\\nknn.fit(X_train, y_train)\\n\\n# new array to test\\nX_new = [[1, 2, 1, 4], [2, 3, 4, 5]]\\n\\nprediction = knn.predict(X_new)\\n\\nprint(\\n    f\\\"\\\\nNew array: \\\\n {X_new}\\\\n\\\\nTarget Names Prediction: \\\\n\\\"\\n    f\\\" {iris['target_names'][prediction]}\\\"\\n)\\n\"",
    "k means clust": "\"\\\"\\\"\\\"README, Author - Anurag Kumar(mailto:anuragkumarak95@gmail.com)\\nRequirements:\\n  - sklearn\\n  - numpy\\n  - matplotlib\\nPython:\\n  - 3.5\\nInputs:\\n  - X , a 2D numpy array of features.\\n  - k , number of clusters to create.\\n  - initial_centroids , initial centroid values generated by utility function(mentioned\\n    in usage).\\n  - maxiter , maximum number of iterations to process.\\n  - heterogeneity , empty list that will be filled with hetrogeneity values if passed\\n    to kmeans func.\\nUsage:\\n  1. define 'k' value, 'X' features array and 'hetrogeneity' empty list\\n  2. create initial_centroids,\\n        initial_centroids = get_initial_centroids(\\n            X,\\n            k,\\n            seed=0 # seed value for initial centroid generation,\\n                   # None for randomness(default=None)\\n            )\\n  3. find centroids and clusters using kmeans function.\\n        centroids, cluster_assignment = kmeans(\\n            X,\\n            k,\\n            initial_centroids,\\n            maxiter=400,\\n            record_heterogeneity=heterogeneity,\\n            verbose=True # whether to print logs in console or not.(default=False)\\n            )\\n  4. Plot the loss function, hetrogeneity values for every iteration saved in\\n     hetrogeneity list.\\n        plot_heterogeneity(\\n            heterogeneity,\\n            k\\n        )\\n  5. Transfers Dataframe into excel format it must have feature called\\n      'Clust' with k means clustering numbers in it.\\n\\\"\\\"\\\"\\nimport warnings\\n\\nimport numpy as np\\nimport pandas as pd\\nfrom matplotlib import pyplot as plt\\nfrom sklearn.metrics import pairwise_distances\\n\\nwarnings.filterwarnings(\\\"ignore\\\")\\n\\nTAG = \\\"K-MEANS-CLUST/ \\\"\\n\\n\\ndef get_initial_centroids(data, k, seed=None):\\n    \\\"\\\"\\\"Randomly choose k data points as initial centroids\\\"\\\"\\\"\\n    if seed is not None:  # useful for obtaining consistent results\\n        np.random.seed(seed)\\n    n = data.shape[0]  # number of data points\\n\\n    # Pick K indices from range [0, N).\\n    rand_indices = np.random.randint(0, n, k)\\n\\n    # Keep centroids as dense format, as many entries will be nonzero due to averaging.\\n    # As long as at least one document in a cluster contains a word,\\n    # it will carry a nonzero weight in the TF-IDF vector of the centroid.\\n    centroids = data[rand_indices, :]\\n\\n    return centroids\\n\\n\\ndef centroid_pairwise_dist(X, centroids):\\n    return pairwise_distances(X, centroids, metric=\\\"euclidean\\\")\\n\\n\\ndef assign_clusters(data, centroids):\\n\\n    # Compute distances between each data point and the set of centroids:\\n    # Fill in the blank (RHS only)\\n    distances_from_centroids = centroid_pairwise_dist(data, centroids)\\n\\n    # Compute cluster assignments for each data point:\\n    # Fill in the blank (RHS only)\\n    cluster_assignment = np.argmin(distances_from_centroids, axis=1)\\n\\n    return cluster_assignment\\n\\n\\ndef revise_centroids(data, k, cluster_assignment):\\n    new_centroids = []\\n    for i in range(k):\\n        # Select all data points that belong to cluster i. Fill in the blank (RHS only)\\n        member_data_points = data[cluster_assignment == i]\\n        # Compute the mean of the data points. Fill in the blank (RHS only)\\n        centroid = member_data_points.mean(axis=0)\\n        new_centroids.append(centroid)\\n    new_centroids = np.array(new_centroids)\\n\\n    return new_centroids\\n\\n\\ndef compute_heterogeneity(data, k, centroids, cluster_assignment):\\n\\n    heterogeneity = 0.0\\n    for i in range(k):\\n\\n        # Select all data points that belong to cluster i. Fill in the blank (RHS only)\\n        member_data_points = data[cluster_assignment == i, :]\\n\\n        if member_data_points.shape[0] > 0:  # check if i-th cluster is non-empty\\n            # Compute distances from centroid to data points (RHS only)\\n            distances = pairwise_distances(\\n                member_data_points, [centroids[i]], metric=\\\"euclidean\\\"\\n            )\\n            squared_distances = distances ** 2\\n            heterogeneity += np.sum(squared_distances)\\n\\n    return heterogeneity\\n\\n\\ndef plot_heterogeneity(heterogeneity, k):\\n    plt.figure(figsize=(7, 4))\\n    plt.plot(heterogeneity, linewidth=4)\\n    plt.xlabel(\\\"# Iterations\\\")\\n    plt.ylabel(\\\"Heterogeneity\\\")\\n    plt.title(f\\\"Heterogeneity of clustering over time, K={k:d}\\\")\\n    plt.rcParams.update({\\\"font.size\\\": 16})\\n    plt.show()\\n\\n\\ndef kmeans(\\n    data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False\\n):\\n    \\\"\\\"\\\"This function runs k-means on given data and initial set of centroids.\\n    maxiter: maximum number of iterations to run.(default=500)\\n    record_heterogeneity: (optional) a list, to store the history of heterogeneity\\n                          as function of iterations\\n                          if None, do not store the history.\\n    verbose: if True, print how many data points changed their cluster labels in\\n                          each iteration\\\"\\\"\\\"\\n    centroids = initial_centroids[:]\\n    prev_cluster_assignment = None\\n\\n    for itr in range(maxiter):\\n        if verbose:\\n            print(itr, end=\\\"\\\")\\n\\n        # 1. Make cluster assignments using nearest centroids\\n        cluster_assignment = assign_clusters(data, centroids)\\n\\n        # 2. Compute a new centroid for each of the k clusters, averaging all data\\n        #    points assigned to that cluster.\\n        centroids = revise_centroids(data, k, cluster_assignment)\\n\\n        # Check for convergence: if none of the assignments changed, stop\\n        if (\\n            prev_cluster_assignment is not None\\n            and (prev_cluster_assignment == cluster_assignment).all()\\n        ):\\n            break\\n\\n        # Print number of new assignments\\n        if prev_cluster_assignment is not None:\\n            num_changed = np.sum(prev_cluster_assignment != cluster_assignment)\\n            if verbose:\\n                print(\\n                    \\\"    {:5d} elements changed their cluster assignment.\\\".format(\\n                        num_changed\\n                    )\\n                )\\n\\n        # Record heterogeneity convergence metric\\n        if record_heterogeneity is not None:\\n            # YOUR CODE HERE\\n            score = compute_heterogeneity(data, k, centroids, cluster_assignment)\\n            record_heterogeneity.append(score)\\n\\n        prev_cluster_assignment = cluster_assignment[:]\\n\\n    return centroids, cluster_assignment\\n\\n\\n# Mock test below\\nif False:  # change to true to run this test case.\\n    from sklearn import datasets as ds\\n\\n    dataset = ds.load_iris()\\n    k = 3\\n    heterogeneity = []\\n    initial_centroids = get_initial_centroids(dataset[\\\"data\\\"], k, seed=0)\\n    centroids, cluster_assignment = kmeans(\\n        dataset[\\\"data\\\"],\\n        k,\\n        initial_centroids,\\n        maxiter=400,\\n        record_heterogeneity=heterogeneity,\\n        verbose=True,\\n    )\\n    plot_heterogeneity(heterogeneity, k)\\n\\n\\ndef ReportGenerator(\\n    df: pd.DataFrame, ClusteringVariables: np.ndarray, FillMissingReport=None\\n) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Function generates easy-erading clustering report. It takes 2 arguments as an input:\\n        DataFrame - dataframe with predicted cluester column;\\n        FillMissingReport - dictionary of rules how we are going to fill missing\\n        values of for final report generate (not included in modeling);\\n    in order to run the function following libraries must be imported:\\n        import pandas as pd\\n        import numpy as np\\n    >>> data = pd.DataFrame()\\n    >>> data['numbers'] = [1, 2, 3]\\n    >>> data['col1'] = [0.5, 2.5, 4.5]\\n    >>> data['col2'] = [100, 200, 300]\\n    >>> data['col3'] = [10, 20, 30]\\n    >>> data['Cluster'] = [1, 1, 2]\\n    >>> ReportGenerator(data, ['col1', 'col2'], 0)\\n               Features               Type   Mark           1           2\\n    0    # of Customers        ClusterSize  False    2.000000    1.000000\\n    1    % of Customers  ClusterProportion  False    0.666667    0.333333\\n    2              col1    mean_with_zeros   True    1.500000    4.500000\\n    3              col2    mean_with_zeros   True  150.000000  300.000000\\n    4           numbers    mean_with_zeros  False    1.500000    3.000000\\n    ..              ...                ...    ...         ...         ...\\n    99            dummy                 5%  False    1.000000    1.000000\\n    100           dummy                95%  False    1.000000    1.000000\\n    101           dummy              stdev  False    0.000000         NaN\\n    102           dummy               mode  False    1.000000    1.000000\\n    103           dummy             median  False    1.000000    1.000000\\n    <BLANKLINE>\\n    [104 rows x 5 columns]\\n    \\\"\\\"\\\"\\n    # Fill missing values with given rules\\n    if FillMissingReport:\\n        df.fillna(value=FillMissingReport, inplace=True)\\n    df[\\\"dummy\\\"] = 1\\n    numeric_cols = df.select_dtypes(np.number).columns\\n    report = (\\n        df.groupby([\\\"Cluster\\\"])[  # construct report dataframe\\n            numeric_cols\\n        ]  # group by cluster number\\n        .agg(\\n            [\\n                (\\\"sum\\\", np.sum),\\n                (\\\"mean_with_zeros\\\", lambda x: np.mean(np.nan_to_num(x))),\\n                (\\\"mean_without_zeros\\\", lambda x: x.replace(0, np.NaN).mean()),\\n                (\\n                    \\\"mean_25-75\\\",\\n                    lambda x: np.mean(\\n                        np.nan_to_num(\\n                            sorted(x)[\\n                                round(len(x) * 25 / 100) : round(len(x) * 75 / 100)\\n                            ]\\n                        )\\n                    ),\\n                ),\\n                (\\\"mean_with_na\\\", np.mean),\\n                (\\\"min\\\", lambda x: x.min()),\\n                (\\\"5%\\\", lambda x: x.quantile(0.05)),\\n                (\\\"25%\\\", lambda x: x.quantile(0.25)),\\n                (\\\"50%\\\", lambda x: x.quantile(0.50)),\\n                (\\\"75%\\\", lambda x: x.quantile(0.75)),\\n                (\\\"95%\\\", lambda x: x.quantile(0.95)),\\n                (\\\"max\\\", lambda x: x.max()),\\n                (\\\"count\\\", lambda x: x.count()),\\n                (\\\"stdev\\\", lambda x: x.std()),\\n                (\\\"mode\\\", lambda x: x.mode()[0]),\\n                (\\\"median\\\", lambda x: x.median()),\\n                (\\\"# > 0\\\", lambda x: (x > 0).sum()),\\n            ]\\n        )\\n        .T.reset_index()\\n        .rename(index=str, columns={\\\"level_0\\\": \\\"Features\\\", \\\"level_1\\\": \\\"Type\\\"})\\n    )  # rename columns\\n    # calculate the size of cluster(count of clientID's)\\n    clustersize = report[\\n        (report[\\\"Features\\\"] == \\\"dummy\\\") & (report[\\\"Type\\\"] == \\\"count\\\")\\n    ].copy()  # avoid SettingWithCopyWarning\\n    clustersize.Type = (\\n        \\\"ClusterSize\\\"  # rename created cluster df to match report column names\\n    )\\n    clustersize.Features = \\\"# of Customers\\\"\\n    clusterproportion = pd.DataFrame(\\n        clustersize.iloc[:, 2:].values\\n        / clustersize.iloc[:, 2:].values.sum()  # calculating the proportion of cluster\\n    )\\n    clusterproportion[\\n        \\\"Type\\\"\\n    ] = \\\"% of Customers\\\"  # rename created cluster df to match report column names\\n    clusterproportion[\\\"Features\\\"] = \\\"ClusterProportion\\\"\\n    cols = clusterproportion.columns.tolist()\\n    cols = cols[-2:] + cols[:-2]\\n    clusterproportion = clusterproportion[cols]  # rearrange columns to match report\\n    clusterproportion.columns = report.columns\\n    a = pd.DataFrame(\\n        abs(\\n            report[report[\\\"Type\\\"] == \\\"count\\\"].iloc[:, 2:].values\\n            - clustersize.iloc[:, 2:].values\\n        )\\n    )  # generating df with count of nan values\\n    a[\\\"Features\\\"] = 0\\n    a[\\\"Type\\\"] = \\\"# of nan\\\"\\n    a.Features = report[\\n        report[\\\"Type\\\"] == \\\"count\\\"\\n    ].Features.tolist()  # filling values in order to match report\\n    cols = a.columns.tolist()\\n    cols = cols[-2:] + cols[:-2]\\n    a = a[cols]  # rearrange columns to match report\\n    a.columns = report.columns  # rename columns to match report\\n    report = report.drop(\\n        report[report.Type == \\\"count\\\"].index\\n    )  # drop count values except cluster size\\n    report = pd.concat(\\n        [report, a, clustersize, clusterproportion], axis=0\\n    )  # concat report with clustert size and nan values\\n    report[\\\"Mark\\\"] = report[\\\"Features\\\"].isin(ClusteringVariables)\\n    cols = report.columns.tolist()\\n    cols = cols[0:2] + cols[-1:] + cols[2:-1]\\n    report = report[cols]\\n    sorter1 = {\\n        \\\"ClusterSize\\\": 9,\\n        \\\"ClusterProportion\\\": 8,\\n        \\\"mean_with_zeros\\\": 7,\\n        \\\"mean_with_na\\\": 6,\\n        \\\"max\\\": 5,\\n        \\\"50%\\\": 4,\\n        \\\"min\\\": 3,\\n        \\\"25%\\\": 2,\\n        \\\"75%\\\": 1,\\n        \\\"# of nan\\\": 0,\\n        \\\"# > 0\\\": -1,\\n        \\\"sum_with_na\\\": -2,\\n    }\\n    report = (\\n        report.assign(\\n            Sorter1=lambda x: x.Type.map(sorter1),\\n            Sorter2=lambda x: list(reversed(range(len(x)))),\\n        )\\n        .sort_values([\\\"Sorter1\\\", \\\"Mark\\\", \\\"Sorter2\\\"], ascending=False)\\n        .drop([\\\"Sorter1\\\", \\\"Sorter2\\\"], axis=1)\\n    )\\n    report.columns.name = \\\"\\\"\\n    report = report.reset_index()\\n    report.drop(columns=[\\\"index\\\"], inplace=True)\\n    return report\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "k nearest neighbours": "\"from collections import Counter\\n\\nimport numpy as np\\nfrom sklearn import datasets\\nfrom sklearn.model_selection import train_test_split\\n\\ndata = datasets.load_iris()\\n\\nX = np.array(data[\\\"data\\\"])\\ny = np.array(data[\\\"target\\\"])\\nclasses = data[\\\"target_names\\\"]\\n\\nX_train, X_test, y_train, y_test = train_test_split(X, y)\\n\\n\\ndef euclidean_distance(a, b):\\n    \\\"\\\"\\\"\\n    Gives the euclidean distance between two points\\n    >>> euclidean_distance([0, 0], [3, 4])\\n    5.0\\n    >>> euclidean_distance([1, 2, 3], [1, 8, 11])\\n    10.0\\n    \\\"\\\"\\\"\\n    return np.linalg.norm(np.array(a) - np.array(b))\\n\\n\\ndef classifier(train_data, train_target, classes, point, k=5):\\n    \\\"\\\"\\\"\\n    Classifies the point using the KNN algorithm\\n    k closest points are found (ranked in ascending order of euclidean distance)\\n    Params:\\n    :train_data: Set of points that are classified into two or more classes\\n    :train_target: List of classes in the order of train_data points\\n    :classes: Labels of the classes\\n    :point: The data point that needs to be classified\\n\\n    >>> X_train = [[0, 0], [1, 0], [0, 1], [0.5, 0.5], [3, 3], [2, 3], [3, 2]]\\n    >>> y_train = [0, 0, 0, 0, 1, 1, 1]\\n    >>> classes = ['A','B']; point = [1.2,1.2]\\n    >>> classifier(X_train, y_train, classes,point)\\n    'A'\\n    \\\"\\\"\\\"\\n    data = zip(train_data, train_target)\\n    # List of distances of all points from the point to be classified\\n    distances = []\\n    for data_point in data:\\n        distance = euclidean_distance(data_point[0], point)\\n        distances.append((distance, data_point[1]))\\n    # Choosing 'k' points with the least distances.\\n    votes = [i[1] for i in sorted(distances)[:k]]\\n    # Most commonly occurring class among them\\n    # is the class into which the point is classified\\n    result = Counter(votes).most_common(1)[0][0]\\n    return classes[result]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(classifier(X_train, y_train, classes, [4.4, 3.1, 1.3, 1.4]))\\n\"",
    "linear discriminant analysis": "\"\\\"\\\"\\\"\\n    Linear Discriminant Analysis\\n\\n\\n\\n    Assumptions About Data :\\n        1. The input variables has a gaussian distribution.\\n        2. The variance calculated for each input variables by class grouping is the\\n           same.\\n        3. The mix of classes in your training set is representative of the problem.\\n\\n\\n    Learning The Model :\\n        The LDA model requires the estimation of statistics from the training data :\\n            1. Mean of each input value for each class.\\n            2. Probability of an instance belong to each class.\\n            3. Covariance for the input data for each class\\n\\n        Calculate the class means :\\n            mean(x) = 1/n ( for i = 1 to i = n --> sum(xi))\\n\\n        Calculate the class probabilities :\\n            P(y = 0) = count(y = 0) / (count(y = 0) + count(y = 1))\\n            P(y = 1) = count(y = 1) / (count(y = 0) + count(y = 1))\\n\\n        Calculate the variance :\\n            We can calculate the variance for dataset in two steps :\\n                1. Calculate the squared difference for each input variable from the\\n                   group mean.\\n                2. Calculate the mean of the squared difference.\\n                ------------------------------------------------\\n                Squared_Difference = (x - mean(k)) ** 2\\n                Variance = (1 / (count(x) - count(classes))) *\\n                    (for i = 1 to i = n --> sum(Squared_Difference(xi)))\\n\\n    Making Predictions :\\n        discriminant(x) = x * (mean / variance) -\\n            ((mean ** 2) / (2 * variance)) + Ln(probability)\\n        ---------------------------------------------------------------------------\\n        After calculating the discriminant value for each class, the class with the\\n        largest discriminant value is taken as the prediction.\\n\\n    Author: @EverLookNeverSee\\n\\\"\\\"\\\"\\nfrom math import log\\nfrom os import name, system\\nfrom random import gauss, seed\\nfrom typing import Callable, TypeVar\\n\\n\\n# Make a training dataset drawn from a gaussian distribution\\ndef gaussian_distribution(mean: float, std_dev: float, instance_count: int) -> list:\\n    \\\"\\\"\\\"\\n    Generate gaussian distribution instances based-on given mean and standard deviation\\n    :param mean: mean value of class\\n    :param std_dev: value of standard deviation entered by usr or default value of it\\n    :param instance_count: instance number of class\\n    :return: a list containing generated values based-on given mean, std_dev and\\n        instance_count\\n\\n    >>> gaussian_distribution(5.0, 1.0, 20) # doctest: +NORMALIZE_WHITESPACE\\n    [6.288184753155463, 6.4494456086997705, 5.066335808938262, 4.235456349028368,\\n     3.9078267848958586, 5.031334516831717, 3.977896829989127, 3.56317055489747,\\n      5.199311976483754, 5.133374604658605, 5.546468300338232, 4.086029056264687,\\n       5.005005283626573, 4.935258239627312, 3.494170998739258, 5.537997178661033,\\n        5.320711100998849, 7.3891120432406865, 5.202969177309964, 4.855297691835079]\\n    \\\"\\\"\\\"\\n    seed(1)\\n    return [gauss(mean, std_dev) for _ in range(instance_count)]\\n\\n\\n# Make corresponding Y flags to detecting classes\\ndef y_generator(class_count: int, instance_count: list) -> list:\\n    \\\"\\\"\\\"\\n    Generate y values for corresponding classes\\n    :param class_count: Number of classes(data groupings) in dataset\\n    :param instance_count: number of instances in class\\n    :return: corresponding values for data groupings in dataset\\n\\n    >>> y_generator(1, [10])\\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n    >>> y_generator(2, [5, 10])\\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\\n    \\\"\\\"\\\"\\n\\n    return [k for k in range(class_count) for _ in range(instance_count[k])]\\n\\n\\n# Calculate the class means\\ndef calculate_mean(instance_count: int, items: list) -> float:\\n    \\\"\\\"\\\"\\n    Calculate given class mean\\n    :param instance_count: Number of instances in class\\n    :param items: items that related to specific class(data grouping)\\n    :return: calculated actual mean of considered class\\n\\n    >>> items = gaussian_distribution(5.0, 1.0, 20)\\n    >>> calculate_mean(len(items), items)\\n    5.011267842911003\\n    \\\"\\\"\\\"\\n    # the sum of all items divided by number of instances\\n    return sum(items) / instance_count\\n\\n\\n# Calculate the class probabilities\\ndef calculate_probabilities(instance_count: int, total_count: int) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the probability that a given instance will belong to which class\\n    :param instance_count: number of instances in class\\n    :param total_count: the number of all instances\\n    :return: value of probability for considered class\\n\\n    >>> calculate_probabilities(20, 60)\\n    0.3333333333333333\\n    >>> calculate_probabilities(30, 100)\\n    0.3\\n    \\\"\\\"\\\"\\n    # number of instances in specific class divided by number of all instances\\n    return instance_count / total_count\\n\\n\\n# Calculate the variance\\ndef calculate_variance(items: list, means: list, total_count: int) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the variance\\n    :param items: a list containing all items(gaussian distribution of all classes)\\n    :param means: a list containing real mean values of each class\\n    :param total_count: the number of all instances\\n    :return: calculated variance for considered dataset\\n\\n    >>> items = gaussian_distribution(5.0, 1.0, 20)\\n    >>> means = [5.011267842911003]\\n    >>> total_count = 20\\n    >>> calculate_variance([items], means, total_count)\\n    0.9618530973487491\\n    \\\"\\\"\\\"\\n    squared_diff = []  # An empty list to store all squared differences\\n    # iterate over number of elements in items\\n    for i in range(len(items)):\\n        # for loop iterates over number of elements in inner layer of items\\n        for j in range(len(items[i])):\\n            # appending squared differences to 'squared_diff' list\\n            squared_diff.append((items[i][j] - means[i]) ** 2)\\n\\n    # one divided by (the number of all instances - number of classes) multiplied by\\n    # sum of all squared differences\\n    n_classes = len(means)  # Number of classes in dataset\\n    return 1 / (total_count - n_classes) * sum(squared_diff)\\n\\n\\n# Making predictions\\ndef predict_y_values(\\n    x_items: list, means: list, variance: float, probabilities: list\\n) -> list:\\n    \\\"\\\"\\\"This function predicts new indexes(groups for our data)\\n    :param x_items: a list containing all items(gaussian distribution of all classes)\\n    :param means: a list containing real mean values of each class\\n    :param variance: calculated value of variance by calculate_variance function\\n    :param probabilities: a list containing all probabilities of classes\\n    :return: a list containing predicted Y values\\n\\n    >>> x_items = [[6.288184753155463, 6.4494456086997705, 5.066335808938262,\\n    ...                4.235456349028368, 3.9078267848958586, 5.031334516831717,\\n    ...                3.977896829989127, 3.56317055489747, 5.199311976483754,\\n    ...                5.133374604658605, 5.546468300338232, 4.086029056264687,\\n    ...                5.005005283626573, 4.935258239627312, 3.494170998739258,\\n    ...                5.537997178661033, 5.320711100998849, 7.3891120432406865,\\n    ...                5.202969177309964, 4.855297691835079], [11.288184753155463,\\n    ...                11.44944560869977, 10.066335808938263, 9.235456349028368,\\n    ...                8.907826784895859, 10.031334516831716, 8.977896829989128,\\n    ...                8.56317055489747, 10.199311976483754, 10.133374604658606,\\n    ...                10.546468300338232, 9.086029056264687, 10.005005283626572,\\n    ...                9.935258239627313, 8.494170998739259, 10.537997178661033,\\n    ...                10.320711100998848, 12.389112043240686, 10.202969177309964,\\n    ...                9.85529769183508], [16.288184753155463, 16.449445608699772,\\n    ...                15.066335808938263, 14.235456349028368, 13.907826784895859,\\n    ...                15.031334516831716, 13.977896829989128, 13.56317055489747,\\n    ...                15.199311976483754, 15.133374604658606, 15.546468300338232,\\n    ...                14.086029056264687, 15.005005283626572, 14.935258239627313,\\n    ...                13.494170998739259, 15.537997178661033, 15.320711100998848,\\n    ...                17.389112043240686, 15.202969177309964, 14.85529769183508]]\\n\\n    >>> means = [5.011267842911003, 10.011267842911003, 15.011267842911002]\\n    >>> variance = 0.9618530973487494\\n    >>> probabilities = [0.3333333333333333, 0.3333333333333333, 0.3333333333333333]\\n    >>> predict_y_values(x_items, means, variance,\\n    ...                  probabilities)  # doctest: +NORMALIZE_WHITESPACE\\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\\n    2, 2, 2, 2, 2, 2, 2, 2, 2]\\n\\n    \\\"\\\"\\\"\\n    # An empty list to store generated discriminant values of all items in dataset for\\n    # each class\\n    results = []\\n    # for loop iterates over number of elements in list\\n    for i in range(len(x_items)):\\n        # for loop iterates over number of inner items of each element\\n        for j in range(len(x_items[i])):\\n            temp = []  # to store all discriminant values of each item as a list\\n            # for loop iterates over number of classes we have in our dataset\\n            for k in range(len(x_items)):\\n                # appending values of discriminants for each class to 'temp' list\\n                temp.append(\\n                    x_items[i][j] * (means[k] / variance)\\n                    - (means[k] ** 2 / (2 * variance))\\n                    + log(probabilities[k])\\n                )\\n            # appending discriminant values of each item to 'results' list\\n            results.append(temp)\\n\\n    return [result.index(max(result)) for result in results]\\n\\n\\n# Calculating Accuracy\\ndef accuracy(actual_y: list, predicted_y: list) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the value of accuracy based-on predictions\\n    :param actual_y:a list containing initial Y values generated by 'y_generator'\\n        function\\n    :param predicted_y: a list containing predicted Y values generated by\\n        'predict_y_values' function\\n    :return: percentage of accuracy\\n\\n    >>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\\n    ... 1, 1 ,1 ,1 ,1 ,1 ,1]\\n    >>> predicted_y = [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0,\\n    ... 0, 0, 1, 1, 1, 0, 1, 1, 1]\\n    >>> accuracy(actual_y, predicted_y)\\n    50.0\\n\\n    >>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\\n    ... 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\\n    >>> predicted_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,\\n    ... 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\\n    >>> accuracy(actual_y, predicted_y)\\n    100.0\\n    \\\"\\\"\\\"\\n    # iterate over one element of each list at a time (zip mode)\\n    # prediction is correct if actual Y value equals to predicted Y value\\n    correct = sum(1 for i, j in zip(actual_y, predicted_y) if i == j)\\n    # percentage of accuracy equals to number of correct predictions divided by number\\n    # of all data and multiplied by 100\\n    return (correct / len(actual_y)) * 100\\n\\n\\nnum = TypeVar(\\\"num\\\")\\n\\n\\ndef valid_input(\\n    input_type: Callable[[object], num],  # Usually float or int\\n    input_msg: str,\\n    err_msg: str,\\n    condition: Callable[[num], bool] = lambda x: True,\\n    default: str = None,\\n) -> num:\\n    \\\"\\\"\\\"\\n    Ask for user value and validate that it fulfill a condition.\\n\\n    :input_type: user input expected type of value\\n    :input_msg: message to show user in the screen\\n    :err_msg: message to show in the screen in case of error\\n    :condition: function that represents the condition that user input is valid.\\n    :default: Default value in case the user does not type anything\\n    :return: user's input\\n    \\\"\\\"\\\"\\n    while True:\\n        try:\\n            user_input = input_type(input(input_msg).strip() or default)\\n            if condition(user_input):\\n                return user_input\\n            else:\\n                print(f\\\"{user_input}: {err_msg}\\\")\\n                continue\\n        except ValueError:\\n            print(\\n                f\\\"{user_input}: Incorrect input type, expected {input_type.__name__!r}\\\"\\n            )\\n\\n\\n# Main Function\\ndef main():\\n    \\\"\\\"\\\"This function starts execution phase\\\"\\\"\\\"\\n    while True:\\n        print(\\\" Linear Discriminant Analysis \\\".center(50, \\\"*\\\"))\\n        print(\\\"*\\\" * 50, \\\"\\\\n\\\")\\n        print(\\\"First of all we should specify the number of classes that\\\")\\n        print(\\\"we want to generate as training dataset\\\")\\n        # Trying to get number of classes\\n        n_classes = valid_input(\\n            input_type=int,\\n            condition=lambda x: x > 0,\\n            input_msg=\\\"Enter the number of classes (Data Groupings): \\\",\\n            err_msg=\\\"Number of classes should be positive!\\\",\\n        )\\n\\n        print(\\\"-\\\" * 100)\\n\\n        # Trying to get the value of standard deviation\\n        std_dev = valid_input(\\n            input_type=float,\\n            condition=lambda x: x >= 0,\\n            input_msg=(\\n                \\\"Enter the value of standard deviation\\\"\\n                \\\"(Default value is 1.0 for all classes): \\\"\\n            ),\\n            err_msg=\\\"Standard deviation should not be negative!\\\",\\n            default=\\\"1.0\\\",\\n        )\\n\\n        print(\\\"-\\\" * 100)\\n\\n        # Trying to get number of instances in classes and theirs means to generate\\n        # dataset\\n        counts = []  # An empty list to store instance counts of classes in dataset\\n        for i in range(n_classes):\\n            user_count = valid_input(\\n                input_type=int,\\n                condition=lambda x: x > 0,\\n                input_msg=(f\\\"Enter The number of instances for class_{i+1}: \\\"),\\n                err_msg=\\\"Number of instances should be positive!\\\",\\n            )\\n            counts.append(user_count)\\n        print(\\\"-\\\" * 100)\\n\\n        # An empty list to store values of user-entered means of classes\\n        user_means = []\\n        for a in range(n_classes):\\n            user_mean = valid_input(\\n                input_type=float,\\n                input_msg=(f\\\"Enter the value of mean for class_{a+1}: \\\"),\\n                err_msg=\\\"This is an invalid value.\\\",\\n            )\\n            user_means.append(user_mean)\\n        print(\\\"-\\\" * 100)\\n\\n        print(\\\"Standard deviation: \\\", std_dev)\\n        # print out the number of instances in classes in separated line\\n        for i, count in enumerate(counts, 1):\\n            print(f\\\"Number of instances in class_{i} is: {count}\\\")\\n        print(\\\"-\\\" * 100)\\n\\n        # print out mean values of classes separated line\\n        for i, user_mean in enumerate(user_means, 1):\\n            print(f\\\"Mean of class_{i} is: {user_mean}\\\")\\n        print(\\\"-\\\" * 100)\\n\\n        # Generating training dataset drawn from gaussian distribution\\n        x = [\\n            gaussian_distribution(user_means[j], std_dev, counts[j])\\n            for j in range(n_classes)\\n        ]\\n        print(\\\"Generated Normal Distribution: \\\\n\\\", x)\\n        print(\\\"-\\\" * 100)\\n\\n        # Generating Ys to detecting corresponding classes\\n        y = y_generator(n_classes, counts)\\n        print(\\\"Generated Corresponding Ys: \\\\n\\\", y)\\n        print(\\\"-\\\" * 100)\\n\\n        # Calculating the value of actual mean for each class\\n        actual_means = [calculate_mean(counts[k], x[k]) for k in range(n_classes)]\\n        # for loop iterates over number of elements in 'actual_means' list and print\\n        # out them in separated line\\n        for i, actual_mean in enumerate(actual_means, 1):\\n            print(f\\\"Actual(Real) mean of class_{i} is: {actual_mean}\\\")\\n        print(\\\"-\\\" * 100)\\n\\n        # Calculating the value of probabilities for each class\\n        probabilities = [\\n            calculate_probabilities(counts[i], sum(counts)) for i in range(n_classes)\\n        ]\\n\\n        # for loop iterates over number of elements in 'probabilities' list and print\\n        # out them in separated line\\n        for i, probability in enumerate(probabilities, 1):\\n            print(f\\\"Probability of class_{i} is: {probability}\\\")\\n        print(\\\"-\\\" * 100)\\n\\n        # Calculating the values of variance for each class\\n        variance = calculate_variance(x, actual_means, sum(counts))\\n        print(\\\"Variance: \\\", variance)\\n        print(\\\"-\\\" * 100)\\n\\n        # Predicting Y values\\n        # storing predicted Y values in 'pre_indexes' variable\\n        pre_indexes = predict_y_values(x, actual_means, variance, probabilities)\\n        print(\\\"-\\\" * 100)\\n\\n        # Calculating Accuracy of the model\\n        print(f\\\"Accuracy: {accuracy(y, pre_indexes)}\\\")\\n        print(\\\"-\\\" * 100)\\n        print(\\\" DONE \\\".center(100, \\\"+\\\"))\\n\\n        if input(\\\"Press any key to restart or 'q' for quit: \\\").strip().lower() == \\\"q\\\":\\n            print(\\\"\\\\n\\\" + \\\"GoodBye!\\\".center(100, \\\"-\\\") + \\\"\\\\n\\\")\\n            break\\n        system(\\\"cls\\\" if name == \\\"nt\\\" else \\\"clear\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "linear regression": "\"\\\"\\\"\\\"\\nLinear regression is the most basic type of regression commonly used for\\npredictive analysis. The idea is pretty simple: we have a dataset and we have\\nfeatures associated with it. Features should be chosen very cautiously\\nas they determine how much our model will be able to make future predictions.\\nWe try to set the weight of these features, over many iterations, so that they best\\nfit our dataset. In this particular code, I had used a CSGO dataset (ADR vs\\nRating). We try to best fit a line through dataset and estimate the parameters.\\n\\\"\\\"\\\"\\nimport numpy as np\\nimport requests\\n\\n\\ndef collect_dataset():\\n    \\\"\\\"\\\"Collect dataset of CSGO\\n    The dataset contains ADR vs Rating of a Player\\n    :return : dataset obtained from the link, as matrix\\n    \\\"\\\"\\\"\\n    response = requests.get(\\n        \\\"https://raw.githubusercontent.com/yashLadha/\\\"\\n        + \\\"The_Math_of_Intelligence/master/Week1/ADRvs\\\"\\n        + \\\"Rating.csv\\\"\\n    )\\n    lines = response.text.splitlines()\\n    data = []\\n    for item in lines:\\n        item = item.split(\\\",\\\")\\n        data.append(item)\\n    data.pop(0)  # This is for removing the labels from the list\\n    dataset = np.matrix(data)\\n    return dataset\\n\\n\\ndef run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta):\\n    \\\"\\\"\\\"Run steep gradient descent and updates the Feature vector accordingly_\\n    :param data_x   : contains the dataset\\n    :param data_y   : contains the output associated with each data-entry\\n    :param len_data : length of the data_\\n    :param alpha    : Learning rate of the model\\n    :param theta    : Feature vector (weight's for our model)\\n    ;param return    : Updated Feature's, using\\n                       curr_features - alpha_ * gradient(w.r.t. feature)\\n    \\\"\\\"\\\"\\n    n = len_data\\n\\n    prod = np.dot(theta, data_x.transpose())\\n    prod -= data_y.transpose()\\n    sum_grad = np.dot(prod, data_x)\\n    theta = theta - (alpha / n) * sum_grad\\n    return theta\\n\\n\\ndef sum_of_square_error(data_x, data_y, len_data, theta):\\n    \\\"\\\"\\\"Return sum of square error for error calculation\\n    :param data_x    : contains our dataset\\n    :param data_y    : contains the output (result vector)\\n    :param len_data  : len of the dataset\\n    :param theta     : contains the feature vector\\n    :return          : sum of square error computed from given feature's\\n    \\\"\\\"\\\"\\n    prod = np.dot(theta, data_x.transpose())\\n    prod -= data_y.transpose()\\n    sum_elem = np.sum(np.square(prod))\\n    error = sum_elem / (2 * len_data)\\n    return error\\n\\n\\ndef run_linear_regression(data_x, data_y):\\n    \\\"\\\"\\\"Implement Linear regression over the dataset\\n    :param data_x  : contains our dataset\\n    :param data_y  : contains the output (result vector)\\n    :return        : feature for line of best fit (Feature vector)\\n    \\\"\\\"\\\"\\n    iterations = 100000\\n    alpha = 0.0001550\\n\\n    no_features = data_x.shape[1]\\n    len_data = data_x.shape[0] - 1\\n\\n    theta = np.zeros((1, no_features))\\n\\n    for i in range(0, iterations):\\n        theta = run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)\\n        error = sum_of_square_error(data_x, data_y, len_data, theta)\\n        print(\\\"At Iteration %d - Error is %.5f \\\" % (i + 1, error))\\n\\n    return theta\\n\\n\\ndef main():\\n    \\\"\\\"\\\"Driver function\\\"\\\"\\\"\\n    data = collect_dataset()\\n\\n    len_data = data.shape[0]\\n    data_x = np.c_[np.ones(len_data), data[:, :-1]].astype(float)\\n    data_y = data[:, -1].astype(float)\\n\\n    theta = run_linear_regression(data_x, data_y)\\n    len_result = theta.shape[1]\\n    print(\\\"Resultant Feature vector : \\\")\\n    for i in range(0, len_result):\\n        print(\\\"%.5f\\\" % (theta[0, i]))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "logistic regression": "\"#!/usr/bin/python\\n\\n# Logistic Regression from scratch\\n\\n# In[62]:\\n\\n# In[63]:\\n\\n# importing all the required libraries\\n\\n\\\"\\\"\\\"\\nImplementing logistic regression for classification problem\\nHelpful resources:\\nCoursera ML course\\nhttps://medium.com/@martinpella/logistic-regression-from-scratch-in-python-124c5636b8ac\\n\\\"\\\"\\\"\\nimport numpy as np\\nfrom matplotlib import pyplot as plt\\nfrom sklearn import datasets\\n\\n# get_ipython().run_line_magic('matplotlib', 'inline')\\n\\n\\n# In[67]:\\n\\n# sigmoid function or logistic function is used as a hypothesis function in\\n# classification problems\\n\\n\\ndef sigmoid_function(z):\\n    return 1 / (1 + np.exp(-z))\\n\\n\\ndef cost_function(h, y):\\n    return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()\\n\\n\\ndef log_likelihood(X, Y, weights):\\n    scores = np.dot(X, weights)\\n    return np.sum(Y * scores - np.log(1 + np.exp(scores)))\\n\\n\\n# here alpha is the learning rate, X is the feature matrix,y is the target matrix\\ndef logistic_reg(alpha, X, y, max_iterations=70000):\\n    theta = np.zeros(X.shape[1])\\n\\n    for iterations in range(max_iterations):\\n        z = np.dot(X, theta)\\n        h = sigmoid_function(z)\\n        gradient = np.dot(X.T, h - y) / y.size\\n        theta = theta - alpha * gradient  # updating the weights\\n        z = np.dot(X, theta)\\n        h = sigmoid_function(z)\\n        J = cost_function(h, y)\\n        if iterations % 100 == 0:\\n            print(f\\\"loss: {J} \\\\t\\\")  # printing the loss after every 100 iterations\\n    return theta\\n\\n\\n# In[68]:\\n\\nif __name__ == \\\"__main__\\\":\\n    iris = datasets.load_iris()\\n    X = iris.data[:, :2]\\n    y = (iris.target != 0) * 1\\n\\n    alpha = 0.1\\n    theta = logistic_reg(alpha, X, y, max_iterations=70000)\\n    print(\\\"theta: \\\", theta)  # printing the theta i.e our weights vector\\n\\n    def predict_prob(X):\\n        return sigmoid_function(\\n            np.dot(X, theta)\\n        )  # predicting the value of probability from the logistic regression algorithm\\n\\n    plt.figure(figsize=(10, 6))\\n    plt.scatter(X[y == 0][:, 0], X[y == 0][:, 1], color=\\\"b\\\", label=\\\"0\\\")\\n    plt.scatter(X[y == 1][:, 0], X[y == 1][:, 1], color=\\\"r\\\", label=\\\"1\\\")\\n    (x1_min, x1_max) = (X[:, 0].min(), X[:, 0].max())\\n    (x2_min, x2_max) = (X[:, 1].min(), X[:, 1].max())\\n    (xx1, xx2) = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))\\n    grid = np.c_[xx1.ravel(), xx2.ravel()]\\n    probs = predict_prob(grid).reshape(xx1.shape)\\n    plt.contour(xx1, xx2, probs, [0.5], linewidths=1, colors=\\\"black\\\")\\n\\n    plt.legend()\\n    plt.show()\\n\"",
    "multilayer perceptron classifier": "\"from sklearn.neural_network import MLPClassifier\\r\\n\\r\\nX = [[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 1.0]]\\r\\ny = [0, 1, 0, 0]\\r\\n\\r\\n\\r\\nclf = MLPClassifier(\\r\\n    solver=\\\"lbfgs\\\", alpha=1e-5, hidden_layer_sizes=(5, 2), random_state=1\\r\\n)\\r\\n\\r\\nclf.fit(X, y)\\r\\n\\r\\n\\r\\ntest = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0]]\\r\\nY = clf.predict(test)\\r\\n\\r\\n\\r\\ndef wrapper(Y):\\r\\n    \\\"\\\"\\\"\\r\\n    >>> wrapper(Y)\\r\\n    [0, 0, 1]\\r\\n    \\\"\\\"\\\"\\r\\n    return list(Y)\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "polymonial regression": "\"import pandas as pd\\nfrom matplotlib import pyplot as plt\\nfrom sklearn.linear_model import LinearRegression\\n\\n# Splitting the dataset into the Training set and Test set\\nfrom sklearn.model_selection import train_test_split\\n\\n# Fitting Polynomial Regression to the dataset\\nfrom sklearn.preprocessing import PolynomialFeatures\\n\\n# Importing the dataset\\ndataset = pd.read_csv(\\n    \\\"https://s3.us-west-2.amazonaws.com/public.gamelab.fun/dataset/\\\"\\n    \\\"position_salaries.csv\\\"\\n)\\nX = dataset.iloc[:, 1:2].values\\ny = dataset.iloc[:, 2].values\\n\\n\\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)\\n\\n\\npoly_reg = PolynomialFeatures(degree=4)\\nX_poly = poly_reg.fit_transform(X)\\npol_reg = LinearRegression()\\npol_reg.fit(X_poly, y)\\n\\n\\n# Visualizing the Polymonial Regression results\\ndef viz_polymonial():\\n    plt.scatter(X, y, color=\\\"red\\\")\\n    plt.plot(X, pol_reg.predict(poly_reg.fit_transform(X)), color=\\\"blue\\\")\\n    plt.title(\\\"Truth or Bluff (Linear Regression)\\\")\\n    plt.xlabel(\\\"Position level\\\")\\n    plt.ylabel(\\\"Salary\\\")\\n    plt.show()\\n    return\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    viz_polymonial()\\n\\n    # Predicting a new result with Polymonial Regression\\n    pol_reg.predict(poly_reg.fit_transform([[5.5]]))\\n    # output should be 132148.43750003\\n\"",
    "random forest classifier": "\"# Random Forest Classifier Example\\nfrom matplotlib import pyplot as plt\\nfrom sklearn.datasets import load_iris\\nfrom sklearn.ensemble import RandomForestClassifier\\nfrom sklearn.metrics import plot_confusion_matrix\\nfrom sklearn.model_selection import train_test_split\\n\\n\\ndef main():\\n\\n    \\\"\\\"\\\"\\n    Random Forest Classifier Example using sklearn function.\\n    Iris type dataset is used to demonstrate algorithm.\\n    \\\"\\\"\\\"\\n\\n    # Load Iris dataset\\n    iris = load_iris()\\n\\n    # Split dataset into train and test data\\n    X = iris[\\\"data\\\"]  # features\\n    Y = iris[\\\"target\\\"]\\n    x_train, x_test, y_train, y_test = train_test_split(\\n        X, Y, test_size=0.3, random_state=1\\n    )\\n\\n    # Random Forest Classifier\\n    rand_for = RandomForestClassifier(random_state=42, n_estimators=100)\\n    rand_for.fit(x_train, y_train)\\n\\n    # Display Confusion Matrix of Classifier\\n    plot_confusion_matrix(\\n        rand_for,\\n        x_test,\\n        y_test,\\n        display_labels=iris[\\\"target_names\\\"],\\n        cmap=\\\"Blues\\\",\\n        normalize=\\\"true\\\",\\n    )\\n    plt.title(\\\"Normalized Confusion Matrix - IRIS Dataset\\\")\\n    plt.show()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "random forest regressor": "\"# Random Forest Regressor Example\\nfrom sklearn.datasets import load_boston\\nfrom sklearn.ensemble import RandomForestRegressor\\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error\\nfrom sklearn.model_selection import train_test_split\\n\\n\\ndef main():\\n\\n    \\\"\\\"\\\"\\n    Random Forest Regressor Example using sklearn function.\\n    Boston house price dataset is used to demonstrate the algorithm.\\n    \\\"\\\"\\\"\\n\\n    # Load Boston house price dataset\\n    boston = load_boston()\\n    print(boston.keys())\\n\\n    # Split dataset into train and test data\\n    X = boston[\\\"data\\\"]  # features\\n    Y = boston[\\\"target\\\"]\\n    x_train, x_test, y_train, y_test = train_test_split(\\n        X, Y, test_size=0.3, random_state=1\\n    )\\n\\n    # Random Forest Regressor\\n    rand_for = RandomForestRegressor(random_state=42, n_estimators=300)\\n    rand_for.fit(x_train, y_train)\\n\\n    # Predict target for test data\\n    predictions = rand_for.predict(x_test)\\n    predictions = predictions.reshape(len(predictions), 1)\\n\\n    # Error printing\\n    print(f\\\"Mean Absolute Error:\\\\t {mean_absolute_error(y_test, predictions)}\\\")\\n    print(f\\\"Mean Square Error  :\\\\t {mean_squared_error(y_test, predictions)}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "scoring functions": "\"import numpy as np\\n\\n\\\"\\\"\\\" Here I implemented the scoring functions.\\n    MAE, MSE, RMSE, RMSLE are included.\\n\\n    Those are used for calculating differences between\\n    predicted values and actual values.\\n\\n    Metrics are slightly differentiated. Sometimes squared, rooted,\\n    even log is used.\\n\\n    Using log and roots can be perceived as tools for penalizing big\\n    errors. However, using appropriate metrics depends on the situations,\\n    and types of data\\n\\\"\\\"\\\"\\n\\n\\n# Mean Absolute Error\\ndef mae(predict, actual):\\n    \\\"\\\"\\\"\\n    Examples(rounded for precision):\\n    >>> actual = [1,2,3];predict = [1,4,3]\\n    >>> np.around(mae(predict,actual),decimals = 2)\\n    0.67\\n\\n    >>> actual = [1,1,1];predict = [1,1,1]\\n    >>> mae(predict,actual)\\n    0.0\\n    \\\"\\\"\\\"\\n    predict = np.array(predict)\\n    actual = np.array(actual)\\n\\n    difference = abs(predict - actual)\\n    score = difference.mean()\\n\\n    return score\\n\\n\\n# Mean Squared Error\\ndef mse(predict, actual):\\n    \\\"\\\"\\\"\\n    Examples(rounded for precision):\\n    >>> actual = [1,2,3];predict = [1,4,3]\\n    >>> np.around(mse(predict,actual),decimals = 2)\\n    1.33\\n\\n    >>> actual = [1,1,1];predict = [1,1,1]\\n    >>> mse(predict,actual)\\n    0.0\\n    \\\"\\\"\\\"\\n    predict = np.array(predict)\\n    actual = np.array(actual)\\n\\n    difference = predict - actual\\n    square_diff = np.square(difference)\\n\\n    score = square_diff.mean()\\n    return score\\n\\n\\n# Root Mean Squared Error\\ndef rmse(predict, actual):\\n    \\\"\\\"\\\"\\n    Examples(rounded for precision):\\n    >>> actual = [1,2,3];predict = [1,4,3]\\n    >>> np.around(rmse(predict,actual),decimals = 2)\\n    1.15\\n\\n    >>> actual = [1,1,1];predict = [1,1,1]\\n    >>> rmse(predict,actual)\\n    0.0\\n    \\\"\\\"\\\"\\n    predict = np.array(predict)\\n    actual = np.array(actual)\\n\\n    difference = predict - actual\\n    square_diff = np.square(difference)\\n    mean_square_diff = square_diff.mean()\\n    score = np.sqrt(mean_square_diff)\\n    return score\\n\\n\\n# Root Mean Square Logarithmic Error\\ndef rmsle(predict, actual):\\n    \\\"\\\"\\\"\\n    Examples(rounded for precision):\\n    >>> actual = [10,10,30];predict = [10,2,30]\\n    >>> np.around(rmsle(predict,actual),decimals = 2)\\n    0.75\\n\\n    >>> actual = [1,1,1];predict = [1,1,1]\\n    >>> rmsle(predict,actual)\\n    0.0\\n    \\\"\\\"\\\"\\n    predict = np.array(predict)\\n    actual = np.array(actual)\\n\\n    log_predict = np.log(predict + 1)\\n    log_actual = np.log(actual + 1)\\n\\n    difference = log_predict - log_actual\\n    square_diff = np.square(difference)\\n    mean_square_diff = square_diff.mean()\\n\\n    score = np.sqrt(mean_square_diff)\\n\\n    return score\\n\\n\\n# Mean Bias Deviation\\ndef mbd(predict, actual):\\n    \\\"\\\"\\\"\\n    This value is Negative, if the model underpredicts,\\n    positive, if it overpredicts.\\n\\n    Example(rounded for precision):\\n\\n    Here the model overpredicts\\n    >>> actual = [1,2,3];predict = [2,3,4]\\n    >>> np.around(mbd(predict,actual),decimals = 2)\\n    50.0\\n\\n    Here the model underpredicts\\n    >>> actual = [1,2,3];predict = [0,1,1]\\n    >>> np.around(mbd(predict,actual),decimals = 2)\\n    -66.67\\n    \\\"\\\"\\\"\\n    predict = np.array(predict)\\n    actual = np.array(actual)\\n\\n    difference = predict - actual\\n    numerator = np.sum(difference) / len(predict)\\n    denumerator = np.sum(actual) / len(predict)\\n    # print(numerator, denumerator)\\n    score = float(numerator) / denumerator * 100\\n\\n    return score\\n\\n\\ndef manual_accuracy(predict, actual):\\n    return np.mean(np.array(actual) == np.array(predict))\\n\"",
    "sequential minimum optimization": "\"\\\"\\\"\\\"\\r\\n    Implementation of sequential minimal optimization (SMO) for support vector machines\\r\\n    (SVM).\\r\\n\\r\\n    Sequential minimal optimization (SMO) is an algorithm for solving the quadratic\\r\\n    programming (QP) problem that arises during the training of support vector\\r\\n    machines.\\r\\n    It was invented by John Platt in 1998.\\r\\n\\r\\nInput:\\r\\n    0: type: numpy.ndarray.\\r\\n    1: first column of ndarray must be tags of samples, must be 1 or -1.\\r\\n    2: rows of ndarray represent samples.\\r\\n\\r\\nUsage:\\r\\n    Command:\\r\\n        python3 sequential_minimum_optimization.py\\r\\n    Code:\\r\\n        from sequential_minimum_optimization import SmoSVM, Kernel\\r\\n\\r\\n        kernel = Kernel(kernel='poly', degree=3., coef0=1., gamma=0.5)\\r\\n        init_alphas = np.zeros(train.shape[0])\\r\\n        SVM = SmoSVM(train=train, alpha_list=init_alphas, kernel_func=kernel, cost=0.4,\\r\\n                     b=0.0, tolerance=0.001)\\r\\n        SVM.fit()\\r\\n        predict = SVM.predict(test_samples)\\r\\n\\r\\nReference:\\r\\n    https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/smo-book.pdf\\r\\n    https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-98-14.pdf\\r\\n    http://web.cs.iastate.edu/~honavar/smo-svm.pdf\\r\\n\\\"\\\"\\\"\\r\\n\\r\\n\\r\\nimport os\\r\\nimport sys\\r\\nimport urllib.request\\r\\n\\r\\nimport numpy as np\\r\\nimport pandas as pd\\r\\nfrom matplotlib import pyplot as plt\\r\\nfrom sklearn.datasets import make_blobs, make_circles\\r\\nfrom sklearn.preprocessing import StandardScaler\\r\\n\\r\\nCANCER_DATASET_URL = (\\r\\n    \\\"http://archive.ics.uci.edu/ml/machine-learning-databases/\\\"\\r\\n    \\\"breast-cancer-wisconsin/wdbc.data\\\"\\r\\n)\\r\\n\\r\\n\\r\\nclass SmoSVM:\\r\\n    def __init__(\\r\\n        self,\\r\\n        train,\\r\\n        kernel_func,\\r\\n        alpha_list=None,\\r\\n        cost=0.4,\\r\\n        b=0.0,\\r\\n        tolerance=0.001,\\r\\n        auto_norm=True,\\r\\n    ):\\r\\n        self._init = True\\r\\n        self._auto_norm = auto_norm\\r\\n        self._c = np.float64(cost)\\r\\n        self._b = np.float64(b)\\r\\n        self._tol = np.float64(tolerance) if tolerance > 0.0001 else np.float64(0.001)\\r\\n\\r\\n        self.tags = train[:, 0]\\r\\n        self.samples = self._norm(train[:, 1:]) if self._auto_norm else train[:, 1:]\\r\\n        self.alphas = alpha_list if alpha_list is not None else np.zeros(train.shape[0])\\r\\n        self.Kernel = kernel_func\\r\\n\\r\\n        self._eps = 0.001\\r\\n        self._all_samples = list(range(self.length))\\r\\n        self._K_matrix = self._calculate_k_matrix()\\r\\n        self._error = np.zeros(self.length)\\r\\n        self._unbound = []\\r\\n\\r\\n        self.choose_alpha = self._choose_alphas()\\r\\n\\r\\n    # Calculate alphas using SMO algorithm\\r\\n    def fit(self):\\r\\n        K = self._k\\r\\n        state = None\\r\\n        while True:\\r\\n\\r\\n            # 1: Find alpha1, alpha2\\r\\n            try:\\r\\n                i1, i2 = self.choose_alpha.send(state)\\r\\n                state = None\\r\\n            except StopIteration:\\r\\n                print(\\\"Optimization done!\\\\nEvery sample satisfy the KKT condition!\\\")\\r\\n                break\\r\\n\\r\\n            # 2: calculate new alpha2 and new alpha1\\r\\n            y1, y2 = self.tags[i1], self.tags[i2]\\r\\n            a1, a2 = self.alphas[i1].copy(), self.alphas[i2].copy()\\r\\n            e1, e2 = self._e(i1), self._e(i2)\\r\\n            args = (i1, i2, a1, a2, e1, e2, y1, y2)\\r\\n            a1_new, a2_new = self._get_new_alpha(*args)\\r\\n            if not a1_new and not a2_new:\\r\\n                state = False\\r\\n                continue\\r\\n            self.alphas[i1], self.alphas[i2] = a1_new, a2_new\\r\\n\\r\\n            # 3: update threshold(b)\\r\\n            b1_new = np.float64(\\r\\n                -e1\\r\\n                - y1 * K(i1, i1) * (a1_new - a1)\\r\\n                - y2 * K(i2, i1) * (a2_new - a2)\\r\\n                + self._b\\r\\n            )\\r\\n            b2_new = np.float64(\\r\\n                -e2\\r\\n                - y2 * K(i2, i2) * (a2_new - a2)\\r\\n                - y1 * K(i1, i2) * (a1_new - a1)\\r\\n                + self._b\\r\\n            )\\r\\n            if 0.0 < a1_new < self._c:\\r\\n                b = b1_new\\r\\n            if 0.0 < a2_new < self._c:\\r\\n                b = b2_new\\r\\n            if not (np.float64(0) < a2_new < self._c) and not (\\r\\n                np.float64(0) < a1_new < self._c\\r\\n            ):\\r\\n                b = (b1_new + b2_new) / 2.0\\r\\n            b_old = self._b\\r\\n            self._b = b\\r\\n\\r\\n            # 4:  update error value,here we only calculate those non-bound samples'\\r\\n            #     error\\r\\n            self._unbound = [i for i in self._all_samples if self._is_unbound(i)]\\r\\n            for s in self.unbound:\\r\\n                if s == i1 or s == i2:\\r\\n                    continue\\r\\n                self._error[s] += (\\r\\n                    y1 * (a1_new - a1) * K(i1, s)\\r\\n                    + y2 * (a2_new - a2) * K(i2, s)\\r\\n                    + (self._b - b_old)\\r\\n                )\\r\\n\\r\\n            # if i1 or i2 is non-bound,update there error value to zero\\r\\n            if self._is_unbound(i1):\\r\\n                self._error[i1] = 0\\r\\n            if self._is_unbound(i2):\\r\\n                self._error[i2] = 0\\r\\n\\r\\n    # Predict test samles\\r\\n    def predict(self, test_samples, classify=True):\\r\\n\\r\\n        if test_samples.shape[1] > self.samples.shape[1]:\\r\\n            raise ValueError(\\r\\n                \\\"Test samples' feature length does not equal to that of train samples\\\"\\r\\n            )\\r\\n\\r\\n        if self._auto_norm:\\r\\n            test_samples = self._norm(test_samples)\\r\\n\\r\\n        results = []\\r\\n        for test_sample in test_samples:\\r\\n            result = self._predict(test_sample)\\r\\n            if classify:\\r\\n                results.append(1 if result > 0 else -1)\\r\\n            else:\\r\\n                results.append(result)\\r\\n        return np.array(results)\\r\\n\\r\\n    # Check if alpha violate KKT condition\\r\\n    def _check_obey_kkt(self, index):\\r\\n        alphas = self.alphas\\r\\n        tol = self._tol\\r\\n        r = self._e(index) * self.tags[index]\\r\\n        c = self._c\\r\\n\\r\\n        return (r < -tol and alphas[index] < c) or (r > tol and alphas[index] > 0.0)\\r\\n\\r\\n    # Get value calculated from kernel function\\r\\n    def _k(self, i1, i2):\\r\\n        # for test samples,use Kernel function\\r\\n        if isinstance(i2, np.ndarray):\\r\\n            return self.Kernel(self.samples[i1], i2)\\r\\n        # for train samples,Kernel values have been saved in matrix\\r\\n        else:\\r\\n            return self._K_matrix[i1, i2]\\r\\n\\r\\n    # Get sample's error\\r\\n    def _e(self, index):\\r\\n        \\\"\\\"\\\"\\r\\n        Two cases:\\r\\n            1:Sample[index] is non-bound,Fetch error from list: _error\\r\\n            2:sample[index] is bound,Use predicted value deduct true value: g(xi) - yi\\r\\n\\r\\n        \\\"\\\"\\\"\\r\\n        # get from error data\\r\\n        if self._is_unbound(index):\\r\\n            return self._error[index]\\r\\n        # get by g(xi) - yi\\r\\n        else:\\r\\n            gx = np.dot(self.alphas * self.tags, self._K_matrix[:, index]) + self._b\\r\\n            yi = self.tags[index]\\r\\n            return gx - yi\\r\\n\\r\\n    # Calculate Kernel matrix of all possible i1,i2 ,saving time\\r\\n    def _calculate_k_matrix(self):\\r\\n        k_matrix = np.zeros([self.length, self.length])\\r\\n        for i in self._all_samples:\\r\\n            for j in self._all_samples:\\r\\n                k_matrix[i, j] = np.float64(\\r\\n                    self.Kernel(self.samples[i, :], self.samples[j, :])\\r\\n                )\\r\\n        return k_matrix\\r\\n\\r\\n    # Predict test sample's tag\\r\\n    def _predict(self, sample):\\r\\n        k = self._k\\r\\n        predicted_value = (\\r\\n            np.sum(\\r\\n                [\\r\\n                    self.alphas[i1] * self.tags[i1] * k(i1, sample)\\r\\n                    for i1 in self._all_samples\\r\\n                ]\\r\\n            )\\r\\n            + self._b\\r\\n        )\\r\\n        return predicted_value\\r\\n\\r\\n    # Choose alpha1 and alpha2\\r\\n    def _choose_alphas(self):\\r\\n        locis = yield from self._choose_a1()\\r\\n        if not locis:\\r\\n            return\\r\\n        return locis\\r\\n\\r\\n    def _choose_a1(self):\\r\\n        \\\"\\\"\\\"\\r\\n        Choose first alpha ;steps:\\r\\n           1:First loop over all sample\\r\\n           2:Second loop over all non-bound samples till all non-bound samples does not\\r\\n               voilate kkt condition.\\r\\n           3:Repeat this two process endlessly,till all samples does not voilate kkt\\r\\n               condition samples after first loop.\\r\\n        \\\"\\\"\\\"\\r\\n        while True:\\r\\n            all_not_obey = True\\r\\n            # all sample\\r\\n            print(\\\"scanning all sample!\\\")\\r\\n            for i1 in [i for i in self._all_samples if self._check_obey_kkt(i)]:\\r\\n                all_not_obey = False\\r\\n                yield from self._choose_a2(i1)\\r\\n\\r\\n            # non-bound sample\\r\\n            print(\\\"scanning non-bound sample!\\\")\\r\\n            while True:\\r\\n                not_obey = True\\r\\n                for i1 in [\\r\\n                    i\\r\\n                    for i in self._all_samples\\r\\n                    if self._check_obey_kkt(i) and self._is_unbound(i)\\r\\n                ]:\\r\\n                    not_obey = False\\r\\n                    yield from self._choose_a2(i1)\\r\\n                if not_obey:\\r\\n                    print(\\\"all non-bound samples fit the KKT condition!\\\")\\r\\n                    break\\r\\n            if all_not_obey:\\r\\n                print(\\\"all samples fit the KKT condition! Optimization done!\\\")\\r\\n                break\\r\\n        return False\\r\\n\\r\\n    def _choose_a2(self, i1):\\r\\n        \\\"\\\"\\\"\\r\\n        Choose the second alpha by using heuristic algorithm ;steps:\\r\\n           1: Choose alpha2 which gets the maximum step size (|E1 - E2|).\\r\\n           2: Start in a random point,loop over all non-bound samples till alpha1 and\\r\\n               alpha2 are optimized.\\r\\n           3: Start in a random point,loop over all samples till alpha1 and alpha2 are\\r\\n               optimized.\\r\\n        \\\"\\\"\\\"\\r\\n        self._unbound = [i for i in self._all_samples if self._is_unbound(i)]\\r\\n\\r\\n        if len(self.unbound) > 0:\\r\\n            tmp_error = self._error.copy().tolist()\\r\\n            tmp_error_dict = {\\r\\n                index: value\\r\\n                for index, value in enumerate(tmp_error)\\r\\n                if self._is_unbound(index)\\r\\n            }\\r\\n            if self._e(i1) >= 0:\\r\\n                i2 = min(tmp_error_dict, key=lambda index: tmp_error_dict[index])\\r\\n            else:\\r\\n                i2 = max(tmp_error_dict, key=lambda index: tmp_error_dict[index])\\r\\n            cmd = yield i1, i2\\r\\n            if cmd is None:\\r\\n                return\\r\\n\\r\\n        for i2 in np.roll(self.unbound, np.random.choice(self.length)):\\r\\n            cmd = yield i1, i2\\r\\n            if cmd is None:\\r\\n                return\\r\\n\\r\\n        for i2 in np.roll(self._all_samples, np.random.choice(self.length)):\\r\\n            cmd = yield i1, i2\\r\\n            if cmd is None:\\r\\n                return\\r\\n\\r\\n    # Get the new alpha2 and new alpha1\\r\\n    def _get_new_alpha(self, i1, i2, a1, a2, e1, e2, y1, y2):\\r\\n        K = self._k\\r\\n        if i1 == i2:\\r\\n            return None, None\\r\\n\\r\\n        # calculate L and H  which bound the new alpha2\\r\\n        s = y1 * y2\\r\\n        if s == -1:\\r\\n            L, H = max(0.0, a2 - a1), min(self._c, self._c + a2 - a1)\\r\\n        else:\\r\\n            L, H = max(0.0, a2 + a1 - self._c), min(self._c, a2 + a1)\\r\\n        if L == H:\\r\\n            return None, None\\r\\n\\r\\n        # calculate eta\\r\\n        k11 = K(i1, i1)\\r\\n        k22 = K(i2, i2)\\r\\n        k12 = K(i1, i2)\\r\\n        eta = k11 + k22 - 2.0 * k12\\r\\n\\r\\n        # select the new alpha2 which could get the minimal objectives\\r\\n        if eta > 0.0:\\r\\n            a2_new_unc = a2 + (y2 * (e1 - e2)) / eta\\r\\n            # a2_new has a boundary\\r\\n            if a2_new_unc >= H:\\r\\n                a2_new = H\\r\\n            elif a2_new_unc <= L:\\r\\n                a2_new = L\\r\\n            else:\\r\\n                a2_new = a2_new_unc\\r\\n        else:\\r\\n            b = self._b\\r\\n            l1 = a1 + s * (a2 - L)\\r\\n            h1 = a1 + s * (a2 - H)\\r\\n\\r\\n            # way 1\\r\\n            f1 = y1 * (e1 + b) - a1 * K(i1, i1) - s * a2 * K(i1, i2)\\r\\n            f2 = y2 * (e2 + b) - a2 * K(i2, i2) - s * a1 * K(i1, i2)\\r\\n            ol = (\\r\\n                l1 * f1\\r\\n                + L * f2\\r\\n                + 1 / 2 * l1 ** 2 * K(i1, i1)\\r\\n                + 1 / 2 * L ** 2 * K(i2, i2)\\r\\n                + s * L * l1 * K(i1, i2)\\r\\n            )\\r\\n            oh = (\\r\\n                h1 * f1\\r\\n                + H * f2\\r\\n                + 1 / 2 * h1 ** 2 * K(i1, i1)\\r\\n                + 1 / 2 * H ** 2 * K(i2, i2)\\r\\n                + s * H * h1 * K(i1, i2)\\r\\n            )\\r\\n            \\\"\\\"\\\"\\r\\n            # way 2\\r\\n            Use objective function check which alpha2 new could get the minimal\\r\\n            objectives\\r\\n            \\\"\\\"\\\"\\r\\n            if ol < (oh - self._eps):\\r\\n                a2_new = L\\r\\n            elif ol > oh + self._eps:\\r\\n                a2_new = H\\r\\n            else:\\r\\n                a2_new = a2\\r\\n\\r\\n        # a1_new has a boundary too\\r\\n        a1_new = a1 + s * (a2 - a2_new)\\r\\n        if a1_new < 0:\\r\\n            a2_new += s * a1_new\\r\\n            a1_new = 0\\r\\n        if a1_new > self._c:\\r\\n            a2_new += s * (a1_new - self._c)\\r\\n            a1_new = self._c\\r\\n\\r\\n        return a1_new, a2_new\\r\\n\\r\\n    # Normalise data using min_max way\\r\\n    def _norm(self, data):\\r\\n        if self._init:\\r\\n            self._min = np.min(data, axis=0)\\r\\n            self._max = np.max(data, axis=0)\\r\\n            self._init = False\\r\\n            return (data - self._min) / (self._max - self._min)\\r\\n        else:\\r\\n            return (data - self._min) / (self._max - self._min)\\r\\n\\r\\n    def _is_unbound(self, index):\\r\\n        if 0.0 < self.alphas[index] < self._c:\\r\\n            return True\\r\\n        else:\\r\\n            return False\\r\\n\\r\\n    def _is_support(self, index):\\r\\n        if self.alphas[index] > 0:\\r\\n            return True\\r\\n        else:\\r\\n            return False\\r\\n\\r\\n    @property\\r\\n    def unbound(self):\\r\\n        return self._unbound\\r\\n\\r\\n    @property\\r\\n    def support(self):\\r\\n        return [i for i in range(self.length) if self._is_support(i)]\\r\\n\\r\\n    @property\\r\\n    def length(self):\\r\\n        return self.samples.shape[0]\\r\\n\\r\\n\\r\\nclass Kernel:\\r\\n    def __init__(self, kernel, degree=1.0, coef0=0.0, gamma=1.0):\\r\\n        self.degree = np.float64(degree)\\r\\n        self.coef0 = np.float64(coef0)\\r\\n        self.gamma = np.float64(gamma)\\r\\n        self._kernel_name = kernel\\r\\n        self._kernel = self._get_kernel(kernel_name=kernel)\\r\\n        self._check()\\r\\n\\r\\n    def _polynomial(self, v1, v2):\\r\\n        return (self.gamma * np.inner(v1, v2) + self.coef0) ** self.degree\\r\\n\\r\\n    def _linear(self, v1, v2):\\r\\n        return np.inner(v1, v2) + self.coef0\\r\\n\\r\\n    def _rbf(self, v1, v2):\\r\\n        return np.exp(-1 * (self.gamma * np.linalg.norm(v1 - v2) ** 2))\\r\\n\\r\\n    def _check(self):\\r\\n        if self._kernel == self._rbf:\\r\\n            if self.gamma < 0:\\r\\n                raise ValueError(\\\"gamma value must greater than 0\\\")\\r\\n\\r\\n    def _get_kernel(self, kernel_name):\\r\\n        maps = {\\\"linear\\\": self._linear, \\\"poly\\\": self._polynomial, \\\"rbf\\\": self._rbf}\\r\\n        return maps[kernel_name]\\r\\n\\r\\n    def __call__(self, v1, v2):\\r\\n        return self._kernel(v1, v2)\\r\\n\\r\\n    def __repr__(self):\\r\\n        return self._kernel_name\\r\\n\\r\\n\\r\\ndef count_time(func):\\r\\n    def call_func(*args, **kwargs):\\r\\n        import time\\r\\n\\r\\n        start_time = time.time()\\r\\n        func(*args, **kwargs)\\r\\n        end_time = time.time()\\r\\n        print(f\\\"smo algorithm cost {end_time - start_time} seconds\\\")\\r\\n\\r\\n    return call_func\\r\\n\\r\\n\\r\\n@count_time\\r\\ndef test_cancel_data():\\r\\n    print(\\\"Hello!\\\\nStart test svm by smo algorithm!\\\")\\r\\n    # 0: download dataset and load into pandas' dataframe\\r\\n    if not os.path.exists(r\\\"cancel_data.csv\\\"):\\r\\n        request = urllib.request.Request(\\r\\n            CANCER_DATASET_URL,\\r\\n            headers={\\\"User-Agent\\\": \\\"Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)\\\"},\\r\\n        )\\r\\n        response = urllib.request.urlopen(request)\\r\\n        content = response.read().decode(\\\"utf-8\\\")\\r\\n        with open(r\\\"cancel_data.csv\\\", \\\"w\\\") as f:\\r\\n            f.write(content)\\r\\n\\r\\n    data = pd.read_csv(r\\\"cancel_data.csv\\\", header=None)\\r\\n\\r\\n    # 1: pre-processing data\\r\\n    del data[data.columns.tolist()[0]]\\r\\n    data = data.dropna(axis=0)\\r\\n    data = data.replace({\\\"M\\\": np.float64(1), \\\"B\\\": np.float64(-1)})\\r\\n    samples = np.array(data)[:, :]\\r\\n\\r\\n    # 2: dividing data into train_data data and test_data data\\r\\n    train_data, test_data = samples[:328, :], samples[328:, :]\\r\\n    test_tags, test_samples = test_data[:, 0], test_data[:, 1:]\\r\\n\\r\\n    # 3: choose kernel function,and set initial alphas to zero(optional)\\r\\n    mykernel = Kernel(kernel=\\\"rbf\\\", degree=5, coef0=1, gamma=0.5)\\r\\n    al = np.zeros(train_data.shape[0])\\r\\n\\r\\n    # 4: calculating best alphas using SMO algorithm and predict test_data samples\\r\\n    mysvm = SmoSVM(\\r\\n        train=train_data,\\r\\n        kernel_func=mykernel,\\r\\n        alpha_list=al,\\r\\n        cost=0.4,\\r\\n        b=0.0,\\r\\n        tolerance=0.001,\\r\\n    )\\r\\n    mysvm.fit()\\r\\n    predict = mysvm.predict(test_samples)\\r\\n\\r\\n    # 5: check accuracy\\r\\n    score = 0\\r\\n    test_num = test_tags.shape[0]\\r\\n    for i in range(test_tags.shape[0]):\\r\\n        if test_tags[i] == predict[i]:\\r\\n            score += 1\\r\\n    print(f\\\"\\\\nall: {test_num}\\\\nright: {score}\\\\nfalse: {test_num - score}\\\")\\r\\n    print(f\\\"Rough Accuracy: {score / test_tags.shape[0]}\\\")\\r\\n\\r\\n\\r\\ndef test_demonstration():\\r\\n    # change stdout\\r\\n    print(\\\"\\\\nStart plot,please wait!!!\\\")\\r\\n    sys.stdout = open(os.devnull, \\\"w\\\")\\r\\n\\r\\n    ax1 = plt.subplot2grid((2, 2), (0, 0))\\r\\n    ax2 = plt.subplot2grid((2, 2), (0, 1))\\r\\n    ax3 = plt.subplot2grid((2, 2), (1, 0))\\r\\n    ax4 = plt.subplot2grid((2, 2), (1, 1))\\r\\n    ax1.set_title(\\\"linear svm,cost:0.1\\\")\\r\\n    test_linear_kernel(ax1, cost=0.1)\\r\\n    ax2.set_title(\\\"linear svm,cost:500\\\")\\r\\n    test_linear_kernel(ax2, cost=500)\\r\\n    ax3.set_title(\\\"rbf kernel svm,cost:0.1\\\")\\r\\n    test_rbf_kernel(ax3, cost=0.1)\\r\\n    ax4.set_title(\\\"rbf kernel svm,cost:500\\\")\\r\\n    test_rbf_kernel(ax4, cost=500)\\r\\n\\r\\n    sys.stdout = sys.__stdout__\\r\\n    print(\\\"Plot done!!!\\\")\\r\\n\\r\\n\\r\\ndef test_linear_kernel(ax, cost):\\r\\n    train_x, train_y = make_blobs(\\r\\n        n_samples=500, centers=2, n_features=2, random_state=1\\r\\n    )\\r\\n    train_y[train_y == 0] = -1\\r\\n    scaler = StandardScaler()\\r\\n    train_x_scaled = scaler.fit_transform(train_x, train_y)\\r\\n    train_data = np.hstack((train_y.reshape(500, 1), train_x_scaled))\\r\\n    mykernel = Kernel(kernel=\\\"linear\\\", degree=5, coef0=1, gamma=0.5)\\r\\n    mysvm = SmoSVM(\\r\\n        train=train_data,\\r\\n        kernel_func=mykernel,\\r\\n        cost=cost,\\r\\n        tolerance=0.001,\\r\\n        auto_norm=False,\\r\\n    )\\r\\n    mysvm.fit()\\r\\n    plot_partition_boundary(mysvm, train_data, ax=ax)\\r\\n\\r\\n\\r\\ndef test_rbf_kernel(ax, cost):\\r\\n    train_x, train_y = make_circles(\\r\\n        n_samples=500, noise=0.1, factor=0.1, random_state=1\\r\\n    )\\r\\n    train_y[train_y == 0] = -1\\r\\n    scaler = StandardScaler()\\r\\n    train_x_scaled = scaler.fit_transform(train_x, train_y)\\r\\n    train_data = np.hstack((train_y.reshape(500, 1), train_x_scaled))\\r\\n    mykernel = Kernel(kernel=\\\"rbf\\\", degree=5, coef0=1, gamma=0.5)\\r\\n    mysvm = SmoSVM(\\r\\n        train=train_data,\\r\\n        kernel_func=mykernel,\\r\\n        cost=cost,\\r\\n        tolerance=0.001,\\r\\n        auto_norm=False,\\r\\n    )\\r\\n    mysvm.fit()\\r\\n    plot_partition_boundary(mysvm, train_data, ax=ax)\\r\\n\\r\\n\\r\\ndef plot_partition_boundary(\\r\\n    model, train_data, ax, resolution=100, colors=(\\\"b\\\", \\\"k\\\", \\\"r\\\")\\r\\n):\\r\\n    \\\"\\\"\\\"\\r\\n    We can not get the optimum w of our kernel svm model which is different from linear\\r\\n    svm.  For this reason, we generate randomly distributed points with high desity and\\r\\n    prediced values of these points are calculated by using our tained model. Then we\\r\\n    could use this prediced values to draw contour map.\\r\\n    And this contour map can represent svm's partition boundary.\\r\\n    \\\"\\\"\\\"\\r\\n    train_data_x = train_data[:, 1]\\r\\n    train_data_y = train_data[:, 2]\\r\\n    train_data_tags = train_data[:, 0]\\r\\n    xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)\\r\\n    yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)\\r\\n    test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(\\r\\n        resolution * resolution, 2\\r\\n    )\\r\\n\\r\\n    test_tags = model.predict(test_samples, classify=False)\\r\\n    grid = test_tags.reshape((len(xrange), len(yrange)))\\r\\n\\r\\n    # Plot contour map which represents the partition boundary\\r\\n    ax.contour(\\r\\n        xrange,\\r\\n        yrange,\\r\\n        np.mat(grid).T,\\r\\n        levels=(-1, 0, 1),\\r\\n        linestyles=(\\\"--\\\", \\\"-\\\", \\\"--\\\"),\\r\\n        linewidths=(1, 1, 1),\\r\\n        colors=colors,\\r\\n    )\\r\\n    # Plot all train samples\\r\\n    ax.scatter(\\r\\n        train_data_x,\\r\\n        train_data_y,\\r\\n        c=train_data_tags,\\r\\n        cmap=plt.cm.Dark2,\\r\\n        lw=0,\\r\\n        alpha=0.5,\\r\\n    )\\r\\n\\r\\n    # Plot support vectors\\r\\n    support = model.support\\r\\n    ax.scatter(\\r\\n        train_data_x[support],\\r\\n        train_data_y[support],\\r\\n        c=train_data_tags[support],\\r\\n        cmap=plt.cm.Dark2,\\r\\n    )\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    test_cancel_data()\\r\\n    test_demonstration()\\r\\n    plt.show()\\r\\n\"",
    "similarity search": "\"\\\"\\\"\\\"\\nSimilarity Search : https://en.wikipedia.org/wiki/Similarity_search\\nSimilarity search is a search algorithm for finding the nearest vector from\\nvectors, used in natural language processing.\\nIn this algorithm, it calculates distance with euclidean distance and\\nreturns a list containing two data for each vector:\\n    1. the nearest vector\\n    2. distance between the vector and the nearest vector (float)\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport math\\n\\nimport numpy as np\\n\\n\\ndef euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:\\n    \\\"\\\"\\\"\\n    Calculates euclidean distance between two data.\\n    :param input_a: ndarray of first vector.\\n    :param input_b: ndarray of second vector.\\n    :return: Euclidean distance of input_a and input_b. By using math.sqrt(),\\n             result will be float.\\n\\n    >>> euclidean(np.array([0]), np.array([1]))\\n    1.0\\n    >>> euclidean(np.array([0, 1]), np.array([1, 1]))\\n    1.0\\n    >>> euclidean(np.array([0, 0, 0]), np.array([0, 0, 1]))\\n    1.0\\n    \\\"\\\"\\\"\\n    return math.sqrt(sum(pow(a - b, 2) for a, b in zip(input_a, input_b)))\\n\\n\\ndef similarity_search(\\n    dataset: np.ndarray, value_array: np.ndarray\\n) -> list[list[list[float] | float]]:\\n    \\\"\\\"\\\"\\n    :param dataset: Set containing the vectors. Should be ndarray.\\n    :param value_array: vector/vectors we want to know the nearest vector from dataset.\\n    :return: Result will be a list containing\\n            1. the nearest vector\\n            2. distance from the vector\\n\\n    >>> dataset = np.array([[0], [1], [2]])\\n    >>> value_array = np.array([[0]])\\n    >>> similarity_search(dataset, value_array)\\n    [[[0], 0.0]]\\n\\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\\n    >>> value_array = np.array([[0, 1]])\\n    >>> similarity_search(dataset, value_array)\\n    [[[0, 0], 1.0]]\\n\\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\\n    >>> value_array = np.array([[0, 0, 1]])\\n    >>> similarity_search(dataset, value_array)\\n    [[[0, 0, 0], 1.0]]\\n\\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\\n    >>> similarity_search(dataset, value_array)\\n    [[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]\\n\\n    These are the errors that might occur:\\n\\n    1. If dimensions are different.\\n    For example, dataset has 2d array and value_array has 1d array:\\n    >>> dataset = np.array([[1]])\\n    >>> value_array = np.array([1])\\n    >>> similarity_search(dataset, value_array)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Wrong input data's dimensions... dataset : 2, value_array : 1\\n\\n    2. If data's shapes are different.\\n    For example, dataset has shape of (3, 2) and value_array has (2, 3).\\n    We are expecting same shapes of two arrays, so it is wrong.\\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\\n    >>> similarity_search(dataset, value_array)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Wrong input data's shape... dataset : 2, value_array : 3\\n\\n    3. If data types are different.\\n    When trying to compare, we are expecting same types so they should be same.\\n    If not, it'll come up with errors.\\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32)\\n    >>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32)\\n    >>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE\\n    Traceback (most recent call last):\\n    ...\\n    TypeError: Input data have different datatype...\\n    dataset : float32, value_array : int32\\n    \\\"\\\"\\\"\\n\\n    if dataset.ndim != value_array.ndim:\\n        raise ValueError(\\n            f\\\"Wrong input data's dimensions... dataset : {dataset.ndim}, \\\"\\n            f\\\"value_array : {value_array.ndim}\\\"\\n        )\\n\\n    try:\\n        if dataset.shape[1] != value_array.shape[1]:\\n            raise ValueError(\\n                f\\\"Wrong input data's shape... dataset : {dataset.shape[1]}, \\\"\\n                f\\\"value_array : {value_array.shape[1]}\\\"\\n            )\\n    except IndexError:\\n        if dataset.ndim != value_array.ndim:\\n            raise TypeError(\\\"Wrong shape\\\")\\n\\n    if dataset.dtype != value_array.dtype:\\n        raise TypeError(\\n            f\\\"Input data have different datatype... dataset : {dataset.dtype}, \\\"\\n            f\\\"value_array : {value_array.dtype}\\\"\\n        )\\n\\n    answer = []\\n\\n    for value in value_array:\\n        dist = euclidean(value, dataset[0])\\n        vector = dataset[0].tolist()\\n\\n        for dataset_value in dataset[1:]:\\n            temp_dist = euclidean(value, dataset_value)\\n\\n            if dist > temp_dist:\\n                dist = temp_dist\\n                vector = dataset_value.tolist()\\n\\n        answer.append([vector, dist])\\n\\n    return answer\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "support vector machines": "\"from sklearn import svm\\nfrom sklearn.datasets import load_iris\\nfrom sklearn.model_selection import train_test_split\\n\\n\\n# different functions implementing different types of SVM's\\ndef NuSVC(train_x, train_y):\\n    svc_NuSVC = svm.NuSVC()\\n    svc_NuSVC.fit(train_x, train_y)\\n    return svc_NuSVC\\n\\n\\ndef Linearsvc(train_x, train_y):\\n    svc_linear = svm.LinearSVC(tol=10e-2)\\n    svc_linear.fit(train_x, train_y)\\n    return svc_linear\\n\\n\\ndef SVC(train_x, train_y):\\n    # svm.SVC(C=1.0, kernel='rbf', degree=3, gamma=0.0, coef0=0.0, shrinking=True,\\n    # probability=False,tol=0.001, cache_size=200, class_weight=None, verbose=False,\\n    # max_iter=1000, random_state=None)\\n    # various parameters like \\\"kernel\\\",\\\"gamma\\\",\\\"C\\\" can effectively tuned for a given\\n    # machine learning model.\\n    SVC = svm.SVC(gamma=\\\"auto\\\")\\n    SVC.fit(train_x, train_y)\\n    return SVC\\n\\n\\ndef test(X_new):\\n    \\\"\\\"\\\"\\n    3 test cases to be passed\\n    an array containing the sepal length (cm), sepal width (cm), petal length (cm),\\n    petal width (cm) based on which  the target name will be predicted\\n    >>> test([1,2,1,4])\\n    'virginica'\\n    >>> test([5, 2, 4, 1])\\n    'versicolor'\\n    >>> test([6,3,4,1])\\n    'versicolor'\\n    \\\"\\\"\\\"\\n    iris = load_iris()\\n    # splitting the dataset to test and train\\n    train_x, test_x, train_y, test_y = train_test_split(\\n        iris[\\\"data\\\"], iris[\\\"target\\\"], random_state=4\\n    )\\n    # any of the 3 types of SVM can be used\\n    # current_model=SVC(train_x, train_y)\\n    # current_model=NuSVC(train_x, train_y)\\n    current_model = Linearsvc(train_x, train_y)\\n    prediction = current_model.predict([X_new])\\n    return iris[\\\"target_names\\\"][prediction][0]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "word frequency functions": "\"import string\\nfrom math import log10\\n\\n\\\"\\\"\\\"\\n    tf-idf Wikipedia: https://en.wikipedia.org/wiki/Tf%E2%80%93idf\\n    tf-idf and other word frequency algorithms are often used\\n    as a weighting factor in information retrieval and text\\n    mining. 83% of text-based recommender systems use\\n    tf-idf for term weighting. In Layman's terms, tf-idf\\n    is a statistic intended to reflect how important a word\\n    is to a document in a corpus (a collection of documents)\\n\\n\\n    Here I've implemented several word frequency algorithms\\n    that are commonly used in information retrieval: Term Frequency,\\n    Document Frequency, and TF-IDF (Term-Frequency*Inverse-Document-Frequency)\\n    are included.\\n\\n    Term Frequency is a statistical function that\\n    returns a number representing how frequently\\n    an expression occurs in a document. This\\n    indicates how significant a particular term is in\\n    a given document.\\n\\n    Document Frequency is a statistical function that returns\\n    an integer representing the number of documents in a\\n    corpus that a term occurs in (where the max number returned\\n    would be the number of documents in the corpus).\\n\\n    Inverse Document Frequency is mathematically written as\\n    log10(N/df), where N is the number of documents in your\\n    corpus and df is the Document Frequency. If df is 0, a\\n    ZeroDivisionError will be thrown.\\n\\n    Term-Frequency*Inverse-Document-Frequency is a measure\\n    of the originality of a term. It is mathematically written\\n    as tf*log10(N/df). It compares the number of times\\n    a term appears in a document with the number of documents\\n    the term appears in. If df is 0, a ZeroDivisionError will be thrown.\\n\\\"\\\"\\\"\\n\\n\\ndef term_frequency(term: str, document: str) -> int:\\n    \\\"\\\"\\\"\\n    Return the number of times a term occurs within\\n    a given document.\\n    @params: term, the term to search a document for, and document,\\n            the document to search within\\n    @returns: an integer representing the number of times a term is\\n            found within the document\\n\\n    @examples:\\n    >>> term_frequency(\\\"to\\\", \\\"To be, or not to be\\\")\\n    2\\n    \\\"\\\"\\\"\\n    # strip all punctuation and newlines and replace it with ''\\n    document_without_punctuation = document.translate(\\n        str.maketrans(\\\"\\\", \\\"\\\", string.punctuation)\\n    ).replace(\\\"\\\\n\\\", \\\"\\\")\\n    tokenize_document = document_without_punctuation.split(\\\" \\\")  # word tokenization\\n    return len([word for word in tokenize_document if word.lower() == term.lower()])\\n\\n\\ndef document_frequency(term: str, corpus: str) -> tuple[int, int]:\\n    \\\"\\\"\\\"\\n    Calculate the number of documents in a corpus that contain a\\n    given term\\n    @params : term, the term to search each document for, and corpus, a collection of\\n             documents. Each document should be separated by a newline.\\n    @returns : the number of documents in the corpus that contain the term you are\\n               searching for and the number of documents in the corpus\\n    @examples :\\n    >>> document_frequency(\\\"first\\\", \\\"This is the first document in the corpus.\\\\\\\\nThIs\\\\\\nis the second document in the corpus.\\\\\\\\nTHIS is \\\\\\nthe third document in the corpus.\\\")\\n    (1, 3)\\n    \\\"\\\"\\\"\\n    corpus_without_punctuation = corpus.lower().translate(\\n        str.maketrans(\\\"\\\", \\\"\\\", string.punctuation)\\n    )  # strip all punctuation and replace it with ''\\n    docs = corpus_without_punctuation.split(\\\"\\\\n\\\")\\n    term = term.lower()\\n    return (len([doc for doc in docs if term in doc]), len(docs))\\n\\n\\ndef inverse_document_frequency(df: int, N: int, smoothing=False) -> float:\\n    \\\"\\\"\\\"\\n    Return an integer denoting the importance\\n    of a word. This measure of importance is\\n    calculated by log10(N/df), where N is the\\n    number of documents and df is\\n    the Document Frequency.\\n    @params : df, the Document Frequency, N,\\n    the number of documents in the corpus and\\n    smoothing, if True return the idf-smooth\\n    @returns : log10(N/df) or 1+log10(N/1+df)\\n    @examples :\\n    >>> inverse_document_frequency(3, 0)\\n    Traceback (most recent call last):\\n     ...\\n    ValueError: log10(0) is undefined.\\n    >>> inverse_document_frequency(1, 3)\\n    0.477\\n    >>> inverse_document_frequency(0, 3)\\n    Traceback (most recent call last):\\n     ...\\n    ZeroDivisionError: df must be > 0\\n    >>> inverse_document_frequency(0, 3,True)\\n    1.477\\n    \\\"\\\"\\\"\\n    if smoothing:\\n        if N == 0:\\n            raise ValueError(\\\"log10(0) is undefined.\\\")\\n        return round(1 + log10(N / (1 + df)), 3)\\n\\n    if df == 0:\\n        raise ZeroDivisionError(\\\"df must be > 0\\\")\\n    elif N == 0:\\n        raise ValueError(\\\"log10(0) is undefined.\\\")\\n    return round(log10(N / df), 3)\\n\\n\\ndef tf_idf(tf: int, idf: int) -> float:\\n    \\\"\\\"\\\"\\n    Combine the term frequency\\n    and inverse document frequency functions to\\n    calculate the originality of a term. This\\n    'originality' is calculated by multiplying\\n    the term frequency and the inverse document\\n    frequency : tf-idf = TF * IDF\\n    @params : tf, the term frequency, and idf, the inverse document\\n    frequency\\n    @examples :\\n    >>> tf_idf(2, 0.477)\\n    0.954\\n    \\\"\\\"\\\"\\n    return round(tf * idf, 3)\\n\"",
    "3n plus 1": "\"from __future__ import annotations\\n\\n\\ndef n31(a: int) -> tuple[list[int], int]:\\n    \\\"\\\"\\\"\\n    Returns the Collatz sequence and its length of any positive integer.\\n    >>> n31(4)\\n    ([4, 2, 1], 3)\\n    \\\"\\\"\\\"\\n\\n    if not isinstance(a, int):\\n        raise TypeError(f\\\"Must be int, not {type(a).__name__}\\\")\\n    if a < 1:\\n        raise ValueError(f\\\"Given integer must be greater than 1, not {a}\\\")\\n\\n    path = [a]\\n    while a != 1:\\n        if a % 2 == 0:\\n            a = a // 2\\n        else:\\n            a = 3 * a + 1\\n        path += [a]\\n    return path, len(path)\\n\\n\\ndef test_n31():\\n    \\\"\\\"\\\"\\n    >>> test_n31()\\n    \\\"\\\"\\\"\\n    assert n31(4) == ([4, 2, 1], 3)\\n    assert n31(11) == ([11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 15)\\n    assert n31(31) == (\\n        [\\n            31,\\n            94,\\n            47,\\n            142,\\n            71,\\n            214,\\n            107,\\n            322,\\n            161,\\n            484,\\n            242,\\n            121,\\n            364,\\n            182,\\n            91,\\n            274,\\n            137,\\n            412,\\n            206,\\n            103,\\n            310,\\n            155,\\n            466,\\n            233,\\n            700,\\n            350,\\n            175,\\n            526,\\n            263,\\n            790,\\n            395,\\n            1186,\\n            593,\\n            1780,\\n            890,\\n            445,\\n            1336,\\n            668,\\n            334,\\n            167,\\n            502,\\n            251,\\n            754,\\n            377,\\n            1132,\\n            566,\\n            283,\\n            850,\\n            425,\\n            1276,\\n            638,\\n            319,\\n            958,\\n            479,\\n            1438,\\n            719,\\n            2158,\\n            1079,\\n            3238,\\n            1619,\\n            4858,\\n            2429,\\n            7288,\\n            3644,\\n            1822,\\n            911,\\n            2734,\\n            1367,\\n            4102,\\n            2051,\\n            6154,\\n            3077,\\n            9232,\\n            4616,\\n            2308,\\n            1154,\\n            577,\\n            1732,\\n            866,\\n            433,\\n            1300,\\n            650,\\n            325,\\n            976,\\n            488,\\n            244,\\n            122,\\n            61,\\n            184,\\n            92,\\n            46,\\n            23,\\n            70,\\n            35,\\n            106,\\n            53,\\n            160,\\n            80,\\n            40,\\n            20,\\n            10,\\n            5,\\n            16,\\n            8,\\n            4,\\n            2,\\n            1,\\n        ],\\n        107,\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    num = 4\\n    path, length = n31(num)\\n    print(f\\\"The Collatz sequence of {num} took {length} steps. \\\\nPath: {path}\\\")\\n\"",
    "abs": "\"\\\"\\\"\\\"Absolute Value.\\\"\\\"\\\"\\n\\n\\ndef abs_val(num):\\n    \\\"\\\"\\\"\\n    Find the absolute value of a number.\\n\\n    >>> abs_val(-5.1)\\n    5.1\\n    >>> abs_val(-5) == abs_val(5)\\n    True\\n    >>> abs_val(0)\\n    0\\n    \\\"\\\"\\\"\\n    return -num if num < 0 else num\\n\\n\\ndef test_abs_val():\\n    \\\"\\\"\\\"\\n    >>> test_abs_val()\\n    \\\"\\\"\\\"\\n    assert 0 == abs_val(0)\\n    assert 34 == abs_val(34)\\n    assert 100000000000 == abs_val(-100000000000)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(abs_val(-34))  # --> 34\\n\"",
    "abs max": "\"from __future__ import annotations\\n\\n\\ndef abs_max(x: list[int]) -> int:\\n    \\\"\\\"\\\"\\n    >>> abs_max([0,5,1,11])\\n    11\\n    >>> abs_max([3,-10,-2])\\n    -10\\n    >>> abs_max([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: abs_max() arg is an empty sequence\\n    \\\"\\\"\\\"\\n    if len(x) == 0:\\n        raise ValueError(\\\"abs_max() arg is an empty sequence\\\")\\n    j = x[0]\\n    for i in x:\\n        if abs(i) > abs(j):\\n            j = i\\n    return j\\n\\n\\ndef abs_max_sort(x: list[int]) -> int:\\n    \\\"\\\"\\\"\\n    >>> abs_max_sort([0,5,1,11])\\n    11\\n    >>> abs_max_sort([3,-10,-2])\\n    -10\\n    >>> abs_max_sort([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: abs_max_sort() arg is an empty sequence\\n    \\\"\\\"\\\"\\n    if len(x) == 0:\\n        raise ValueError(\\\"abs_max_sort() arg is an empty sequence\\\")\\n    return sorted(x, key=abs)[-1]\\n\\n\\ndef main():\\n    a = [1, 2, -11]\\n    assert abs_max(a) == -11\\n    assert abs_max_sort(a) == -11\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod(verbose=True)\\n    main()\\n\"",
    "abs min": "\"from __future__ import annotations\\n\\nfrom .abs import abs_val\\n\\n\\ndef abs_min(x: list[int]) -> int:\\n    \\\"\\\"\\\"\\n    >>> abs_min([0,5,1,11])\\n    0\\n    >>> abs_min([3,-10,-2])\\n    -2\\n    >>> abs_min([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: abs_min() arg is an empty sequence\\n    \\\"\\\"\\\"\\n    if len(x) == 0:\\n        raise ValueError(\\\"abs_min() arg is an empty sequence\\\")\\n    j = x[0]\\n    for i in x:\\n        if abs_val(i) < abs_val(j):\\n            j = i\\n    return j\\n\\n\\ndef main():\\n    a = [-3, -1, 2, -11]\\n    print(abs_min(a))  # = -1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod(verbose=True)\\n    main()\\n\"",
    "add": "\"\\\"\\\"\\\"\\nJust to check\\n\\\"\\\"\\\"\\n\\n\\ndef add(a, b):\\n    \\\"\\\"\\\"\\n    >>> add(2, 2)\\n    4\\n    >>> add(2, -2)\\n    0\\n    \\\"\\\"\\\"\\n    return a + b\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    a = 5\\n    b = 6\\n    print(f\\\"The sum of {a} + {b} is {add(a, b)}\\\")\\n\"",
    "aliquot sum": "\"def aliquot_sum(input_num: int) -> int:\\n    \\\"\\\"\\\"\\n    Finds the aliquot sum of an input integer, where the\\n    aliquot sum of a number n is defined as the sum of all\\n    natural numbers less than n that divide n evenly. For\\n    example, the aliquot sum of 15 is 1 + 3 + 5 = 9. This is\\n    a simple O(n) implementation.\\n    @param input_num: a positive integer whose aliquot sum is to be found\\n    @return: the aliquot sum of input_num, if input_num is positive.\\n    Otherwise, raise a ValueError\\n    Wikipedia Explanation: https://en.wikipedia.org/wiki/Aliquot_sum\\n\\n    >>> aliquot_sum(15)\\n    9\\n    >>> aliquot_sum(6)\\n    6\\n    >>> aliquot_sum(-1)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Input must be positive\\n    >>> aliquot_sum(0)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Input must be positive\\n    >>> aliquot_sum(1.6)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Input must be an integer\\n    >>> aliquot_sum(12)\\n    16\\n    >>> aliquot_sum(1)\\n    0\\n    >>> aliquot_sum(19)\\n    1\\n    \\\"\\\"\\\"\\n    if not isinstance(input_num, int):\\n        raise ValueError(\\\"Input must be an integer\\\")\\n    if input_num <= 0:\\n        raise ValueError(\\\"Input must be positive\\\")\\n    return sum(\\n        divisor for divisor in range(1, input_num // 2 + 1) if input_num % divisor == 0\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "allocation number": "\"\\\"\\\"\\\"\\nIn a multi-threaded download, this algorithm could be used to provide\\neach worker thread with a block of non-overlapping bytes to download.\\nFor example:\\n    for i in allocation_list:\\n        requests.get(url,headers={'Range':f'bytes={i}'})\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef allocation_num(number_of_bytes: int, partitions: int) -> list[str]:\\n    \\\"\\\"\\\"\\n    Divide a number of bytes into x partitions.\\n    :param number_of_bytes: the total of bytes.\\n    :param partitions: the number of partition need to be allocated.\\n    :return: list of bytes to be assigned to each worker thread\\n\\n    >>> allocation_num(16647, 4)\\n    ['1-4161', '4162-8322', '8323-12483', '12484-16647']\\n    >>> allocation_num(50000, 5)\\n    ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']\\n    >>> allocation_num(888, 999)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: partitions can not > number_of_bytes!\\n    >>> allocation_num(888, -4)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: partitions must be a positive number!\\n    \\\"\\\"\\\"\\n    if partitions <= 0:\\n        raise ValueError(\\\"partitions must be a positive number!\\\")\\n    if partitions > number_of_bytes:\\n        raise ValueError(\\\"partitions can not > number_of_bytes!\\\")\\n    bytes_per_partition = number_of_bytes // partitions\\n    allocation_list = []\\n    for i in range(partitions):\\n        start_bytes = i * bytes_per_partition + 1\\n        end_bytes = (\\n            number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition\\n        )\\n        allocation_list.append(f\\\"{start_bytes}-{end_bytes}\\\")\\n    return allocation_list\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "area": "\"\\\"\\\"\\\"\\r\\nFind the area of various geometric shapes\\r\\n\\\"\\\"\\\"\\r\\nfrom math import pi, sqrt\\r\\n\\r\\n\\r\\ndef surface_area_cube(side_length: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the Surface Area of a Cube.\\r\\n\\r\\n    >>> surface_area_cube(1)\\r\\n    6\\r\\n    >>> surface_area_cube(3)\\r\\n    54\\r\\n    >>> surface_area_cube(-1)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: surface_area_cube() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if side_length < 0:\\r\\n        raise ValueError(\\\"surface_area_cube() only accepts non-negative values\\\")\\r\\n    return 6 * side_length ** 2\\r\\n\\r\\n\\r\\ndef surface_area_sphere(radius: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the Surface Area of a Sphere.\\r\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Sphere\\r\\n    Formula: 4 * pi * r^2\\r\\n\\r\\n    >>> surface_area_sphere(5)\\r\\n    314.1592653589793\\r\\n    >>> surface_area_sphere(1)\\r\\n    12.566370614359172\\r\\n    >>> surface_area_sphere(-1)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: surface_area_sphere() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if radius < 0:\\r\\n        raise ValueError(\\\"surface_area_sphere() only accepts non-negative values\\\")\\r\\n    return 4 * pi * radius ** 2\\r\\n\\r\\n\\r\\ndef surface_area_hemisphere(radius: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the Surface Area of a Hemisphere.\\r\\n    Formula: 3 * pi * r^2\\r\\n\\r\\n    >>> surface_area_hemisphere(5)\\r\\n    235.61944901923448\\r\\n    >>> surface_area_hemisphere(1)\\r\\n    9.42477796076938\\r\\n    >>> surface_area_hemisphere(0)\\r\\n    0.0\\r\\n    >>> surface_area_hemisphere(1.1)\\r\\n    11.40398133253095\\r\\n    >>> surface_area_hemisphere(-1)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: surface_area_hemisphere() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if radius < 0:\\r\\n        raise ValueError(\\\"surface_area_hemisphere() only accepts non-negative values\\\")\\r\\n    return 3 * pi * radius ** 2\\r\\n\\r\\n\\r\\ndef surface_area_cone(radius: float, height: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the Surface Area of a Cone.\\r\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cone\\r\\n    Formula: pi * r * (r + (h ** 2 + r ** 2) ** 0.5)\\r\\n\\r\\n    >>> surface_area_cone(10, 24)\\r\\n    1130.9733552923256\\r\\n    >>> surface_area_cone(6, 8)\\r\\n    301.59289474462014\\r\\n    >>> surface_area_cone(-1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: surface_area_cone() only accepts non-negative values\\r\\n    >>> surface_area_cone(1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: surface_area_cone() only accepts non-negative values\\r\\n    >>> surface_area_cone(-1, 2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: surface_area_cone() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if radius < 0 or height < 0:\\r\\n        raise ValueError(\\\"surface_area_cone() only accepts non-negative values\\\")\\r\\n    return pi * radius * (radius + (height ** 2 + radius ** 2) ** 0.5)\\r\\n\\r\\n\\r\\ndef surface_area_cylinder(radius: float, height: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the Surface Area of a Cylinder.\\r\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder\\r\\n    Formula: 2 * pi * r * (h + r)\\r\\n\\r\\n    >>> surface_area_cylinder(7, 10)\\r\\n    747.6990515543707\\r\\n    >>> surface_area_cylinder(6, 8)\\r\\n    527.7875658030853\\r\\n    >>> surface_area_cylinder(-1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: surface_area_cylinder() only accepts non-negative values\\r\\n    >>> surface_area_cylinder(1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: surface_area_cylinder() only accepts non-negative values\\r\\n    >>> surface_area_cylinder(-1, 2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: surface_area_cylinder() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if radius < 0 or height < 0:\\r\\n        raise ValueError(\\\"surface_area_cylinder() only accepts non-negative values\\\")\\r\\n    return 2 * pi * radius * (height + radius)\\r\\n\\r\\n\\r\\ndef area_rectangle(length: float, width: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the area of a rectangle.\\r\\n\\r\\n    >>> area_rectangle(10, 20)\\r\\n    200\\r\\n    >>> area_rectangle(-1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_rectangle() only accepts non-negative values\\r\\n    >>> area_rectangle(1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_rectangle() only accepts non-negative values\\r\\n    >>> area_rectangle(-1, 2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_rectangle() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if length < 0 or width < 0:\\r\\n        raise ValueError(\\\"area_rectangle() only accepts non-negative values\\\")\\r\\n    return length * width\\r\\n\\r\\n\\r\\ndef area_square(side_length: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the area of a square.\\r\\n\\r\\n    >>> area_square(10)\\r\\n    100\\r\\n    >>> area_square(-1)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_square() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if side_length < 0:\\r\\n        raise ValueError(\\\"area_square() only accepts non-negative values\\\")\\r\\n    return side_length ** 2\\r\\n\\r\\n\\r\\ndef area_triangle(base: float, height: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the area of a triangle given the base and height.\\r\\n\\r\\n    >>> area_triangle(10, 10)\\r\\n    50.0\\r\\n    >>> area_triangle(-1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_triangle() only accepts non-negative values\\r\\n    >>> area_triangle(1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_triangle() only accepts non-negative values\\r\\n    >>> area_triangle(-1, 2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_triangle() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if base < 0 or height < 0:\\r\\n        raise ValueError(\\\"area_triangle() only accepts non-negative values\\\")\\r\\n    return (base * height) / 2\\r\\n\\r\\n\\r\\ndef area_triangle_three_sides(side1: float, side2: float, side3: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate area of triangle when the length of 3 sides are known.\\r\\n\\r\\n    This function uses Heron's formula: https://en.wikipedia.org/wiki/Heron%27s_formula\\r\\n\\r\\n    >>> area_triangle_three_sides(5, 12, 13)\\r\\n    30.0\\r\\n    >>> area_triangle_three_sides(10, 11, 12)\\r\\n    51.521233486786784\\r\\n    >>> area_triangle_three_sides(-1, -2, -1)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_triangle_three_sides() only accepts non-negative values\\r\\n    >>> area_triangle_three_sides(1, -2, 1)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_triangle_three_sides() only accepts non-negative values\\r\\n    >>> area_triangle_three_sides(2, 4, 7)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Given three sides do not form a triangle\\r\\n    >>> area_triangle_three_sides(2, 7, 4)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Given three sides do not form a triangle\\r\\n    >>> area_triangle_three_sides(7, 2, 4)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Given three sides do not form a triangle\\r\\n    \\\"\\\"\\\"\\r\\n    if side1 < 0 or side2 < 0 or side3 < 0:\\r\\n        raise ValueError(\\\"area_triangle_three_sides() only accepts non-negative values\\\")\\r\\n    elif side1 + side2 < side3 or side1 + side3 < side2 or side2 + side3 < side1:\\r\\n        raise ValueError(\\\"Given three sides do not form a triangle\\\")\\r\\n    semi_perimeter = (side1 + side2 + side3) / 2\\r\\n    area = sqrt(\\r\\n        semi_perimeter\\r\\n        * (semi_perimeter - side1)\\r\\n        * (semi_perimeter - side2)\\r\\n        * (semi_perimeter - side3)\\r\\n    )\\r\\n    return area\\r\\n\\r\\n\\r\\ndef area_parallelogram(base: float, height: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the area of a parallelogram.\\r\\n\\r\\n    >>> area_parallelogram(10, 20)\\r\\n    200\\r\\n    >>> area_parallelogram(-1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_parallelogram() only accepts non-negative values\\r\\n    >>> area_parallelogram(1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_parallelogram() only accepts non-negative values\\r\\n    >>> area_parallelogram(-1, 2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_parallelogram() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if base < 0 or height < 0:\\r\\n        raise ValueError(\\\"area_parallelogram() only accepts non-negative values\\\")\\r\\n    return base * height\\r\\n\\r\\n\\r\\ndef area_trapezium(base1: float, base2: float, height: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the area of a trapezium.\\r\\n\\r\\n    >>> area_trapezium(10, 20, 30)\\r\\n    450.0\\r\\n    >>> area_trapezium(-1, -2, -3)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_trapezium() only accepts non-negative values\\r\\n    >>> area_trapezium(-1, 2, 3)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_trapezium() only accepts non-negative values\\r\\n    >>> area_trapezium(1, -2, 3)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_trapezium() only accepts non-negative values\\r\\n    >>> area_trapezium(1, 2, -3)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_trapezium() only accepts non-negative values\\r\\n    >>> area_trapezium(-1, -2, 3)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_trapezium() only accepts non-negative values\\r\\n    >>> area_trapezium(1, -2, -3)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_trapezium() only accepts non-negative values\\r\\n    >>> area_trapezium(-1, 2, -3)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_trapezium() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if base1 < 0 or base2 < 0 or height < 0:\\r\\n        raise ValueError(\\\"area_trapezium() only accepts non-negative values\\\")\\r\\n    return 1 / 2 * (base1 + base2) * height\\r\\n\\r\\n\\r\\ndef area_circle(radius: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the area of a circle.\\r\\n\\r\\n    >>> area_circle(20)\\r\\n    1256.6370614359173\\r\\n    >>> area_circle(-1)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_circle() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if radius < 0:\\r\\n        raise ValueError(\\\"area_circle() only accepts non-negative values\\\")\\r\\n    return pi * radius ** 2\\r\\n\\r\\n\\r\\ndef area_ellipse(radius_x: float, radius_y: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the area of a ellipse.\\r\\n\\r\\n    >>> area_ellipse(10, 10)\\r\\n    314.1592653589793\\r\\n    >>> area_ellipse(10, 20)\\r\\n    628.3185307179587\\r\\n    >>> area_ellipse(-10, 20)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_ellipse() only accepts non-negative values\\r\\n    >>> area_ellipse(10, -20)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_ellipse() only accepts non-negative values\\r\\n    >>> area_ellipse(-10, -20)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_ellipse() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if radius_x < 0 or radius_y < 0:\\r\\n        raise ValueError(\\\"area_ellipse() only accepts non-negative values\\\")\\r\\n    return pi * radius_x * radius_y\\r\\n\\r\\n\\r\\ndef area_rhombus(diagonal_1: float, diagonal_2: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the area of a rhombus.\\r\\n\\r\\n    >>> area_rhombus(10, 20)\\r\\n    100.0\\r\\n    >>> area_rhombus(-1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_rhombus() only accepts non-negative values\\r\\n    >>> area_rhombus(1, -2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_rhombus() only accepts non-negative values\\r\\n    >>> area_rhombus(-1, 2)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: area_rhombus() only accepts non-negative values\\r\\n    \\\"\\\"\\\"\\r\\n    if diagonal_1 < 0 or diagonal_2 < 0:\\r\\n        raise ValueError(\\\"area_rhombus() only accepts non-negative values\\\")\\r\\n    return 1 / 2 * diagonal_1 * diagonal_2\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod(verbose=True)  # verbose so we can see methods missing tests\\r\\n\\r\\n    print(\\\"[DEMO] Areas of various geometric shapes: \\\\n\\\")\\r\\n    print(f\\\"Rectangle: {area_rectangle(10, 20) = }\\\")\\r\\n    print(f\\\"Square: {area_square(10) = }\\\")\\r\\n    print(f\\\"Triangle: {area_triangle(10, 10) = }\\\")\\r\\n    print(f\\\"Triangle: {area_triangle_three_sides(5, 12, 13) = }\\\")\\r\\n    print(f\\\"Parallelogram: {area_parallelogram(10, 20) = }\\\")\\r\\n    print(f\\\"Rhombus: {area_rhombus(10, 20) = }\\\")\\r\\n    print(f\\\"Trapezium: {area_trapezium(10, 20, 30) = }\\\")\\r\\n    print(f\\\"Circle: {area_circle(20) = }\\\")\\r\\n    print(\\\"\\\\nSurface Areas of various geometric shapes: \\\\n\\\")\\r\\n    print(f\\\"Cube: {surface_area_cube(20) = }\\\")\\r\\n    print(f\\\"Sphere: {surface_area_sphere(20) = }\\\")\\r\\n    print(f\\\"Hemisphere: {surface_area_hemisphere(20) = }\\\")\\r\\n    print(f\\\"Cone: {surface_area_cone(10, 20) = }\\\")\\r\\n    print(f\\\"Cylinder: {surface_area_cylinder(10, 20) = }\\\")\\r\\n\"",
    "area under curve": "\"\\\"\\\"\\\"\\nApproximates the area under the curve using the trapezoidal rule\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom typing import Callable\\n\\n\\ndef trapezoidal_area(\\n    fnc: Callable[[int | float], int | float],\\n    x_start: int | float,\\n    x_end: int | float,\\n    steps: int = 100,\\n) -> float:\\n    \\\"\\\"\\\"\\n    Treats curve as a collection of linear lines and sums the area of the\\n    trapezium shape they form\\n    :param fnc: a function which defines a curve\\n    :param x_start: left end point to indicate the start of line segment\\n    :param x_end: right end point to indicate end of line segment\\n    :param steps: an accuracy gauge; more steps increases the accuracy\\n    :return: a float representing the length of the curve\\n\\n    >>> def f(x):\\n    ...    return 5\\n    >>> f\\\"{trapezoidal_area(f, 12.0, 14.0, 1000):.3f}\\\"\\n    '10.000'\\n    >>> def f(x):\\n    ...    return 9*x**2\\n    >>> f\\\"{trapezoidal_area(f, -4.0, 0, 10000):.4f}\\\"\\n    '192.0000'\\n    >>> f\\\"{trapezoidal_area(f, -4.0, 4.0, 10000):.4f}\\\"\\n    '384.0000'\\n    \\\"\\\"\\\"\\n    x1 = x_start\\n    fx1 = fnc(x_start)\\n    area = 0.0\\n    for i in range(steps):\\n        # Approximates small segments of curve as linear and solve\\n        # for trapezoidal area\\n        x2 = (x_end - x_start) / steps + x1\\n        fx2 = fnc(x2)\\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\\n        # Increment step\\n        x1 = x2\\n        fx1 = fx2\\n    return area\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    def f(x):\\n        return x ** 3 + x ** 2\\n\\n    print(\\\"f(x) = x^3 + x^2\\\")\\n    print(\\\"The area between the curve, x = -5, x = 5 and the x axis is:\\\")\\n    i = 10\\n    while i <= 100000:\\n        print(f\\\"with {i} steps: {trapezoidal_area(f, -5, 5, i)}\\\")\\n        i *= 10\\n\"",
    "armstrong numbers": "\"\\\"\\\"\\\"\\r\\nAn Armstrong number is equal to the sum of its own digits each raised to the\\r\\npower of the number of digits.\\r\\n\\r\\nFor example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370.\\r\\n\\r\\nArmstrong numbers are also called Narcissistic numbers and Pluperfect numbers.\\r\\n\\r\\nOn-Line Encyclopedia of Integer Sequences entry: https://oeis.org/A005188\\r\\n\\\"\\\"\\\"\\r\\nPASSING = (1, 153, 370, 371, 1634, 24678051, 115132219018763992565095597973971522401)\\r\\nFAILING: tuple = (-153, -1, 0, 1.2, 200, \\\"A\\\", [], {}, None)\\r\\n\\r\\n\\r\\ndef armstrong_number(n: int) -> bool:\\r\\n    \\\"\\\"\\\"\\r\\n    Return True if n is an Armstrong number or False if it is not.\\r\\n\\r\\n    >>> all(armstrong_number(n) for n in PASSING)\\r\\n    True\\r\\n    >>> any(armstrong_number(n) for n in FAILING)\\r\\n    False\\r\\n    \\\"\\\"\\\"\\r\\n    if not isinstance(n, int) or n < 1:\\r\\n        return False\\r\\n\\r\\n    # Initialization of sum and number of digits.\\r\\n    sum = 0\\r\\n    number_of_digits = 0\\r\\n    temp = n\\r\\n    # Calculation of digits of the number\\r\\n    while temp > 0:\\r\\n        number_of_digits += 1\\r\\n        temp //= 10\\r\\n    # Dividing number into separate digits and find Armstrong number\\r\\n    temp = n\\r\\n    while temp > 0:\\r\\n        rem = temp % 10\\r\\n        sum += rem ** number_of_digits\\r\\n        temp //= 10\\r\\n    return n == sum\\r\\n\\r\\n\\r\\ndef pluperfect_number(n: int) -> bool:\\r\\n    \\\"\\\"\\\"Return True if n is a pluperfect number or False if it is not\\r\\n\\r\\n    >>> all(armstrong_number(n) for n in PASSING)\\r\\n    True\\r\\n    >>> any(armstrong_number(n) for n in FAILING)\\r\\n    False\\r\\n    \\\"\\\"\\\"\\r\\n    if not isinstance(n, int) or n < 1:\\r\\n        return False\\r\\n\\r\\n    # Init a \\\"histogram\\\" of the digits\\r\\n    digit_histogram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\r\\n    digit_total = 0\\r\\n    sum = 0\\r\\n    temp = n\\r\\n    while temp > 0:\\r\\n        temp, rem = divmod(temp, 10)\\r\\n        digit_histogram[rem] += 1\\r\\n        digit_total += 1\\r\\n\\r\\n    for (cnt, i) in zip(digit_histogram, range(len(digit_histogram))):\\r\\n        sum += cnt * i ** digit_total\\r\\n\\r\\n    return n == sum\\r\\n\\r\\n\\r\\ndef narcissistic_number(n: int) -> bool:\\r\\n    \\\"\\\"\\\"Return True if n is a narcissistic number or False if it is not.\\r\\n\\r\\n    >>> all(armstrong_number(n) for n in PASSING)\\r\\n    True\\r\\n    >>> any(armstrong_number(n) for n in FAILING)\\r\\n    False\\r\\n    \\\"\\\"\\\"\\r\\n    if not isinstance(n, int) or n < 1:\\r\\n        return False\\r\\n    expo = len(str(n))  # the power that all digits will be raised to\\r\\n    # check if sum of each digit multiplied expo times is equal to number\\r\\n    return n == sum(int(i) ** expo for i in str(n))\\r\\n\\r\\n\\r\\ndef main():\\r\\n    \\\"\\\"\\\"\\r\\n    Request that user input an integer and tell them if it is Armstrong number.\\r\\n    \\\"\\\"\\\"\\r\\n    num = int(input(\\\"Enter an integer to see if it is an Armstrong number: \\\").strip())\\r\\n    print(f\\\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\\\")\\r\\n    print(f\\\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\\\")\\r\\n    print(f\\\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\\\")\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n    main()\\r\\n\"",
    "average mean": "\"from __future__ import annotations\\n\\n\\ndef mean(nums: list) -> float:\\n    \\\"\\\"\\\"\\n    Find mean of a list of numbers.\\n    Wiki: https://en.wikipedia.org/wiki/Mean\\n\\n    >>> mean([3, 6, 9, 12, 15, 18, 21])\\n    12.0\\n    >>> mean([5, 10, 15, 20, 25, 30, 35])\\n    20.0\\n    >>> mean([1, 2, 3, 4, 5, 6, 7, 8])\\n    4.5\\n    >>> mean([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: List is empty\\n    \\\"\\\"\\\"\\n    if not nums:\\n        raise ValueError(\\\"List is empty\\\")\\n    return sum(nums) / len(nums)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "average median": "\"from __future__ import annotations\\n\\n\\ndef median(nums: list) -> int | float:\\n    \\\"\\\"\\\"\\n    Find median of a list of numbers.\\n    Wiki: https://en.wikipedia.org/wiki/Median\\n\\n    >>> median([0])\\n    0\\n    >>> median([4, 1, 3, 2])\\n    2.5\\n    >>> median([2, 70, 6, 50, 20, 8, 4])\\n    8\\n\\n    Args:\\n        nums: List of nums\\n\\n    Returns:\\n        Median.\\n    \\\"\\\"\\\"\\n    sorted_list = sorted(nums)\\n    length = len(sorted_list)\\n    mid_index = length >> 1\\n    return (\\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\\n        if length % 2 == 0\\n        else sorted_list[mid_index]\\n    )\\n\\n\\ndef main():\\n    import doctest\\n\\n    doctest.testmod()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "average mode": "\"from typing import Any\\r\\n\\r\\n\\r\\ndef mode(input_list: list) -> list[Any]:\\r\\n    \\\"\\\"\\\"This function returns the mode(Mode as in the measures of\\r\\n    central tendency) of the input data.\\r\\n\\r\\n    The input list may contain any Datastructure or any Datatype.\\r\\n\\r\\n    >>> mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])\\r\\n    [2]\\r\\n    >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])\\r\\n    [2]\\r\\n    >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])\\r\\n    [2, 4]\\r\\n    >>> mode([\\\"x\\\", \\\"y\\\", \\\"y\\\", \\\"z\\\"])\\r\\n    ['y']\\r\\n    >>> mode([\\\"x\\\", \\\"x\\\" , \\\"y\\\", \\\"y\\\", \\\"z\\\"])\\r\\n    ['x', 'y']\\r\\n    \\\"\\\"\\\"\\r\\n    if not input_list:\\r\\n        return []\\r\\n    result = [input_list.count(value) for value in input_list]\\r\\n    y = max(result)  # Gets the maximum count in the input list.\\r\\n    # Gets values of modes\\r\\n    return sorted({input_list[i] for i, value in enumerate(result) if value == y})\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "bailey borwein plouffe": "\"def bailey_borwein_plouffe(digit_position: int, precision: int = 1000) -> str:\\n    \\\"\\\"\\\"\\n    Implement a popular pi-digit-extraction algorithm known as the\\n    Bailey-Borwein-Plouffe (BBP) formula to calculate the nth hex digit of pi.\\n    Wikipedia page:\\n    https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula\\n    @param digit_position: a positive integer representing the position of the digit to\\n    extract.\\n    The digit immediately after the decimal point is located at position 1.\\n    @param precision: number of terms in the second summation to calculate.\\n    A higher number reduces the chance of an error but increases the runtime.\\n    @return: a hexadecimal digit representing the digit at the nth position\\n    in pi's decimal expansion.\\n\\n    >>> \\\"\\\".join(bailey_borwein_plouffe(i) for i in range(1, 11))\\n    '243f6a8885'\\n    >>> bailey_borwein_plouffe(5, 10000)\\n    '6'\\n    >>> bailey_borwein_plouffe(-10)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Digit position must be a positive integer\\n    >>> bailey_borwein_plouffe(0)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Digit position must be a positive integer\\n    >>> bailey_borwein_plouffe(1.7)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Digit position must be a positive integer\\n    >>> bailey_borwein_plouffe(2, -10)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Precision must be a nonnegative integer\\n    >>> bailey_borwein_plouffe(2, 1.6)\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: Precision must be a nonnegative integer\\n    \\\"\\\"\\\"\\n    if (not isinstance(digit_position, int)) or (digit_position <= 0):\\n        raise ValueError(\\\"Digit position must be a positive integer\\\")\\n    elif (not isinstance(precision, int)) or (precision < 0):\\n        raise ValueError(\\\"Precision must be a nonnegative integer\\\")\\n\\n    # compute an approximation of (16 ** (n - 1)) * pi whose fractional part is mostly\\n    # accurate\\n    sum_result = (\\n        4 * _subsum(digit_position, 1, precision)\\n        - 2 * _subsum(digit_position, 4, precision)\\n        - _subsum(digit_position, 5, precision)\\n        - _subsum(digit_position, 6, precision)\\n    )\\n\\n    # return the first hex digit of the fractional part of the result\\n    return hex(int((sum_result % 1) * 16))[2:]\\n\\n\\ndef _subsum(\\n    digit_pos_to_extract: int, denominator_addend: int, precision: int\\n) -> float:\\n    # only care about first digit of fractional part; don't need decimal\\n    \\\"\\\"\\\"\\n    Private helper function to implement the summation\\n    functionality.\\n    @param digit_pos_to_extract: digit position to extract\\n    @param denominator_addend: added to denominator of fractions in the formula\\n    @param precision: same as precision in main function\\n    @return: floating-point number whose integer part is not important\\n    \\\"\\\"\\\"\\n    sum = 0.0\\n    for sum_index in range(digit_pos_to_extract + precision):\\n        denominator = 8 * sum_index + denominator_addend\\n        if sum_index < digit_pos_to_extract:\\n            # if the exponential term is an integer and we mod it by the denominator\\n            # before dividing, only the integer part of the sum will change;\\n            # the fractional part will not\\n            exponential_term = pow(\\n                16, digit_pos_to_extract - 1 - sum_index, denominator\\n            )\\n        else:\\n            exponential_term = pow(16, digit_pos_to_extract - 1 - sum_index)\\n        sum += exponential_term / denominator\\n    return sum\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "basic maths": "\"\\\"\\\"\\\"Implementation of Basic Math in Python.\\\"\\\"\\\"\\r\\nimport math\\r\\n\\r\\n\\r\\ndef prime_factors(n: int) -> list:\\r\\n    \\\"\\\"\\\"Find Prime Factors.\\r\\n    >>> prime_factors(100)\\r\\n    [2, 2, 5, 5]\\r\\n    >>> prime_factors(0)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Only positive integers have prime factors\\r\\n    >>> prime_factors(-10)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Only positive integers have prime factors\\r\\n    \\\"\\\"\\\"\\r\\n    if n <= 0:\\r\\n        raise ValueError(\\\"Only positive integers have prime factors\\\")\\r\\n    pf = []\\r\\n    while n % 2 == 0:\\r\\n        pf.append(2)\\r\\n        n = int(n / 2)\\r\\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\\r\\n        while n % i == 0:\\r\\n            pf.append(i)\\r\\n            n = int(n / i)\\r\\n    if n > 2:\\r\\n        pf.append(n)\\r\\n    return pf\\r\\n\\r\\n\\r\\ndef number_of_divisors(n: int) -> int:\\r\\n    \\\"\\\"\\\"Calculate Number of Divisors of an Integer.\\r\\n    >>> number_of_divisors(100)\\r\\n    9\\r\\n    >>> number_of_divisors(0)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Only positive numbers are accepted\\r\\n    >>> number_of_divisors(-10)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Only positive numbers are accepted\\r\\n    \\\"\\\"\\\"\\r\\n    if n <= 0:\\r\\n        raise ValueError(\\\"Only positive numbers are accepted\\\")\\r\\n    div = 1\\r\\n    temp = 1\\r\\n    while n % 2 == 0:\\r\\n        temp += 1\\r\\n        n = int(n / 2)\\r\\n    div *= temp\\r\\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\\r\\n        temp = 1\\r\\n        while n % i == 0:\\r\\n            temp += 1\\r\\n            n = int(n / i)\\r\\n        div *= temp\\r\\n    return div\\r\\n\\r\\n\\r\\ndef sum_of_divisors(n: int) -> int:\\r\\n    \\\"\\\"\\\"Calculate Sum of Divisors.\\r\\n    >>> sum_of_divisors(100)\\r\\n    217\\r\\n    >>> sum_of_divisors(0)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Only positive numbers are accepted\\r\\n    >>> sum_of_divisors(-10)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    ValueError: Only positive numbers are accepted\\r\\n    \\\"\\\"\\\"\\r\\n    if n <= 0:\\r\\n        raise ValueError(\\\"Only positive numbers are accepted\\\")\\r\\n    s = 1\\r\\n    temp = 1\\r\\n    while n % 2 == 0:\\r\\n        temp += 1\\r\\n        n = int(n / 2)\\r\\n    if temp > 1:\\r\\n        s *= (2 ** temp - 1) / (2 - 1)\\r\\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\\r\\n        temp = 1\\r\\n        while n % i == 0:\\r\\n            temp += 1\\r\\n            n = int(n / i)\\r\\n        if temp > 1:\\r\\n            s *= (i ** temp - 1) / (i - 1)\\r\\n    return int(s)\\r\\n\\r\\n\\r\\ndef euler_phi(n: int) -> int:\\r\\n    \\\"\\\"\\\"Calculate Euler's Phi Function.\\r\\n    >>> euler_phi(100)\\r\\n    40\\r\\n    \\\"\\\"\\\"\\r\\n    s = n\\r\\n    for x in set(prime_factors(n)):\\r\\n        s *= (x - 1) / x\\r\\n    return int(s)\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "binary exponentiation": "\"\\\"\\\"\\\"Binary Exponentiation.\\\"\\\"\\\"\\n\\n# Author : Junth Basnet\\n# Time Complexity : O(logn)\\n\\n\\ndef binary_exponentiation(a, n):\\n\\n    if n == 0:\\n        return 1\\n\\n    elif n % 2 == 1:\\n        return binary_exponentiation(a, n - 1) * a\\n\\n    else:\\n        b = binary_exponentiation(a, n / 2)\\n        return b * b\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    try:\\n        BASE = int(input(\\\"Enter Base : \\\").strip())\\n        POWER = int(input(\\\"Enter Power : \\\").strip())\\n    except ValueError:\\n        print(\\\"Invalid literal for integer\\\")\\n\\n    RESULT = binary_exponentiation(BASE, POWER)\\n    print(f\\\"{BASE}^({POWER}) : {RESULT}\\\")\\n\"",
    "binary exponentiation 2": "\"\\\"\\\"\\\"\\n* Binary Exponentiation with Multiplication\\n* This is a method to find a*b in a time complexity of O(log b)\\n* This is one of the most commonly used methods of finding result of multiplication.\\n* Also useful in cases where solution to (a*b)%c is required,\\n* where a,b,c can be numbers over the computers calculation limits.\\n* Done using iteration, can also be done using recursion\\n\\n* @author chinmoy159\\n* @version 1.0 dated 10/08/2017\\n\\\"\\\"\\\"\\n\\n\\ndef b_expo(a, b):\\n    res = 0\\n    while b > 0:\\n        if b & 1:\\n            res += a\\n\\n        a += a\\n        b >>= 1\\n\\n    return res\\n\\n\\ndef b_expo_mod(a, b, c):\\n    res = 0\\n    while b > 0:\\n        if b & 1:\\n            res = ((res % c) + (a % c)) % c\\n\\n        a += a\\n        b >>= 1\\n\\n    return res\\n\\n\\n\\\"\\\"\\\"\\n* Wondering how this method works !\\n* It's pretty simple.\\n* Let's say you need to calculate a ^ b\\n* RULE 1 : a * b = (a+a) * (b/2) ---- example : 4 * 4 = (4+4) * (4/2) = 8 * 2\\n* RULE 2 : IF b is ODD, then ---- a * b = a + (a * (b - 1)) :: where (b - 1) is even.\\n* Once b is even, repeat the process to get a * b\\n* Repeat the process till b = 1 OR b = 0, because a*1 = a AND a*0 = 0\\n*\\n* As far as the modulo is concerned,\\n* the fact : (a+b) % c = ((a%c) + (b%c)) % c\\n* Now apply RULE 1 OR 2, whichever is required.\\n\\\"\\\"\\\"\\n\"",
    "binary exponentiation 3": "\"\\\"\\\"\\\"\\n* Binary Exponentiation for Powers\\n* This is a method to find a^b in a time complexity of O(log b)\\n* This is one of the most commonly used methods of finding powers.\\n* Also useful in cases where solution to (a^b)%c is required,\\n* where a,b,c can be numbers over the computers calculation limits.\\n* Done using iteration, can also be done using recursion\\n\\n* @author chinmoy159\\n* @version 1.0 dated 10/08/2017\\n\\\"\\\"\\\"\\n\\n\\ndef b_expo(a, b):\\n    res = 1\\n    while b > 0:\\n        if b & 1:\\n            res *= a\\n\\n        a *= a\\n        b >>= 1\\n\\n    return res\\n\\n\\ndef b_expo_mod(a, b, c):\\n    res = 1\\n    while b > 0:\\n        if b & 1:\\n            res = ((res % c) * (a % c)) % c\\n\\n        a *= a\\n        b >>= 1\\n\\n    return res\\n\\n\\n\\\"\\\"\\\"\\n* Wondering how this method works !\\n* It's pretty simple.\\n* Let's say you need to calculate a ^ b\\n* RULE 1 : a ^ b = (a*a) ^ (b/2) ---- example : 4 ^ 4 = (4*4) ^ (4/2) = 16 ^ 2\\n* RULE 2 : IF b is ODD, then ---- a ^ b = a * (a ^ (b - 1)) :: where (b - 1) is even.\\n* Once b is even, repeat the process to get a ^ b\\n* Repeat the process till b = 1 OR b = 0, because a^1 = a AND a^0 = 1\\n*\\n* As far as the modulo is concerned,\\n* the fact : (a*b) % c = ((a%c) * (b%c)) % c\\n* Now apply RULE 1 OR 2 whichever is required.\\n\\\"\\\"\\\"\\n\"",
    "binary exp mod": "\"def bin_exp_mod(a, n, b):\\n    \\\"\\\"\\\"\\n    >>> bin_exp_mod(3, 4, 5)\\n    1\\n    >>> bin_exp_mod(7, 13, 10)\\n    7\\n    \\\"\\\"\\\"\\n    # mod b\\n    assert not (b == 0), \\\"This cannot accept modulo that is == 0\\\"\\n    if n == 0:\\n        return 1\\n\\n    if n % 2 == 1:\\n        return (bin_exp_mod(a, n - 1, b) * a) % b\\n\\n    r = bin_exp_mod(a, n / 2, b)\\n    return (r * r) % b\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    try:\\n        BASE = int(input(\\\"Enter Base : \\\").strip())\\n        POWER = int(input(\\\"Enter Power : \\\").strip())\\n        MODULO = int(input(\\\"Enter Modulo : \\\").strip())\\n    except ValueError:\\n        print(\\\"Invalid literal for integer\\\")\\n\\n    print(bin_exp_mod(BASE, POWER, MODULO))\\n\"",
    "binomial coefficient": "\"def binomial_coefficient(n, r):\\n    \\\"\\\"\\\"\\n    Find binomial coefficient using pascals triangle.\\n\\n    >>> binomial_coefficient(10, 5)\\n    252\\n    \\\"\\\"\\\"\\n    C = [0 for i in range(r + 1)]\\n    # nc0 = 1\\n    C[0] = 1\\n    for i in range(1, n + 1):\\n        # to compute current row from previous row.\\n        j = min(i, r)\\n        while j > 0:\\n            C[j] += C[j - 1]\\n            j -= 1\\n    return C[r]\\n\\n\\nprint(binomial_coefficient(n=10, r=5))\\n\"",
    "binomial distribution": "\"\\\"\\\"\\\"For more information about the Binomial Distribution -\\r\\n    https://en.wikipedia.org/wiki/Binomial_distribution\\\"\\\"\\\"\\r\\nfrom math import factorial\\r\\n\\r\\n\\r\\ndef binomial_distribution(successes: int, trials: int, prob: float) -> float:\\r\\n    \\\"\\\"\\\"\\r\\n    Return probability of k successes out of n tries, with p probability for one\\r\\n    success\\r\\n\\r\\n    The function uses the factorial function in order to calculate the binomial\\r\\n    coefficient\\r\\n\\r\\n    >>> binomial_distribution(3, 5, 0.7)\\r\\n    0.30870000000000003\\r\\n    >>> binomial_distribution (2, 4, 0.5)\\r\\n    0.375\\r\\n    \\\"\\\"\\\"\\r\\n    if successes > trials:\\r\\n        raise ValueError(\\\"\\\"\\\"successes must be lower or equal to trials\\\"\\\"\\\")\\r\\n    if trials < 0 or successes < 0:\\r\\n        raise ValueError(\\\"the function is defined for non-negative integers\\\")\\r\\n    if not isinstance(successes, int) or not isinstance(trials, int):\\r\\n        raise ValueError(\\\"the function is defined for non-negative integers\\\")\\r\\n    if not 0 < prob < 1:\\r\\n        raise ValueError(\\\"prob has to be in range of 1 - 0\\\")\\r\\n    probability = (prob ** successes) * ((1 - prob) ** (trials - successes))\\r\\n    # Calculate the binomial coefficient: n! / k!(n-k)!\\r\\n    coefficient = float(factorial(trials))\\r\\n    coefficient /= factorial(successes) * factorial(trials - successes)\\r\\n    return probability * coefficient\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    from doctest import testmod\\r\\n\\r\\n    testmod()\\r\\n    print(\\\"Probability of 2 successes out of 4 trails\\\")\\r\\n    print(\\\"with probability of 0.75 is:\\\", end=\\\" \\\")\\r\\n    print(binomial_distribution(2, 4, 0.75))\\r\\n\"",
    "ceil": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Floor_and_ceiling_functions\\n\\\"\\\"\\\"\\n\\n\\ndef ceil(x) -> int:\\n    \\\"\\\"\\\"\\n    Return the ceiling of x as an Integral.\\n\\n    :param x: the number\\n    :return: the smallest integer >= x.\\n\\n    >>> import math\\n    >>> all(ceil(n) == math.ceil(n) for n\\n    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\\n    True\\n    \\\"\\\"\\\"\\n    return int(x) if x - int(x) <= 0 else int(x) + 1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "check polygon": "\"from __future__ import annotations\\n\\n\\ndef check_polygon(nums: list[float]) -> bool:\\n    \\\"\\\"\\\"\\n    Takes list of possible side lengths and determines whether a\\n    two-dimensional polygon with such side lengths can exist.\\n\\n    Returns a boolean value for the < comparison\\n    of the largest side length with sum of the rest.\\n    Wiki: https://en.wikipedia.org/wiki/Triangle_inequality\\n\\n    >>> check_polygon([6, 10, 5])\\n    True\\n    >>> check_polygon([3, 7, 13, 2])\\n    False\\n    >>> check_polygon([1, 4.3, 5.2, 12.2])\\n    False\\n    >>> nums = [3, 7, 13, 2]\\n    >>> _ = check_polygon(nums) #   Run function, do not show answer in output\\n    >>> nums #  Check numbers are not reordered\\n    [3, 7, 13, 2]\\n    >>> check_polygon([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Monogons and Digons are not polygons in the Euclidean space\\n    >>> check_polygon([-2, 5, 6])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: All values must be greater than 0\\n    \\\"\\\"\\\"\\n    if len(nums) < 2:\\n        raise ValueError(\\\"Monogons and Digons are not polygons in the Euclidean space\\\")\\n    if any(i <= 0 for i in nums):\\n        raise ValueError(\\\"All values must be greater than 0\\\")\\n    copy_nums = nums.copy()\\n    copy_nums.sort()\\n    return copy_nums[-1] < sum(copy_nums[:-1])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "chudnovsky algorithm": "\"from decimal import Decimal, getcontext\\nfrom math import ceil, factorial\\n\\n\\ndef pi(precision: int) -> str:\\n    \\\"\\\"\\\"\\n    The Chudnovsky algorithm is a fast method for calculating the digits of PI,\\n    based on Ramanujan’s PI formulae.\\n\\n    https://en.wikipedia.org/wiki/Chudnovsky_algorithm\\n\\n    PI = constant_term / ((multinomial_term * linear_term) / exponential_term)\\n        where constant_term = 426880 * sqrt(10005)\\n\\n    The linear_term and the exponential_term can be defined iteratively as follows:\\n        L_k+1 = L_k + 545140134            where L_0 = 13591409\\n        X_k+1 = X_k * -262537412640768000  where X_0 = 1\\n\\n    The multinomial_term is defined as follows:\\n        6k! / ((3k)! * (k!) ^ 3)\\n            where k is the k_th iteration.\\n\\n    This algorithm correctly calculates around 14 digits of PI per iteration\\n\\n    >>> pi(10)\\n    '3.14159265'\\n    >>> pi(100)\\n    '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706'\\n    >>> pi('hello')\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: Undefined for non-integers\\n    >>> pi(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Undefined for non-natural numbers\\n    \\\"\\\"\\\"\\n\\n    if not isinstance(precision, int):\\n        raise TypeError(\\\"Undefined for non-integers\\\")\\n    elif precision < 1:\\n        raise ValueError(\\\"Undefined for non-natural numbers\\\")\\n\\n    getcontext().prec = precision\\n    num_iterations = ceil(precision / 14)\\n    constant_term = 426880 * Decimal(10005).sqrt()\\n    exponential_term = 1\\n    linear_term = 13591409\\n    partial_sum = Decimal(linear_term)\\n    for k in range(1, num_iterations):\\n        multinomial_term = factorial(6 * k) // (factorial(3 * k) * factorial(k) ** 3)\\n        linear_term += 545140134\\n        exponential_term *= -262537412640768000\\n        partial_sum += Decimal(multinomial_term * linear_term) / exponential_term\\n    return str(constant_term / partial_sum)[:-1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    n = 50\\n    print(f\\\"The first {n} digits of pi is: {pi(n)}\\\")\\n\"",
    "collatz sequence": "\"from __future__ import annotations\\n\\n\\ndef collatz_sequence(n: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    Collatz conjecture: start with any positive integer n. The next term is\\n    obtained as follows:\\n        If n term is even, the next term is: n / 2 .\\n        If n is odd, the next term is: 3 * n + 1.\\n\\n    The conjecture states the sequence will always reach 1 for any starting value n.\\n    Example:\\n    >>> collatz_sequence(2.1)\\n    Traceback (most recent call last):\\n        ...\\n    Exception: Sequence only defined for natural numbers\\n    >>> collatz_sequence(0)\\n    Traceback (most recent call last):\\n        ...\\n    Exception: Sequence only defined for natural numbers\\n    >>> collatz_sequence(43)  # doctest: +NORMALIZE_WHITESPACE\\n    [43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7,\\n     22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]\\n    \\\"\\\"\\\"\\n\\n    if not isinstance(n, int) or n < 1:\\n        raise Exception(\\\"Sequence only defined for natural numbers\\\")\\n\\n    sequence = [n]\\n    while n != 1:\\n        n = 3 * n + 1 if n & 1 else n // 2\\n        sequence.append(n)\\n    return sequence\\n\\n\\ndef main():\\n    n = 43\\n    sequence = collatz_sequence(n)\\n    print(sequence)\\n    print(f\\\"collatz sequence from {n} took {len(sequence)} steps.\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "combinations": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Combination\\n\\\"\\\"\\\"\\nfrom math import factorial\\n\\n\\ndef combinations(n: int, k: int) -> int:\\n    \\\"\\\"\\\"\\n    Returns the number of different combinations of k length which can\\n    be made from n values, where n >= k.\\n\\n    Examples:\\n    >>> combinations(10,5)\\n    252\\n\\n    >>> combinations(6,3)\\n    20\\n\\n    >>> combinations(20,5)\\n    15504\\n\\n    >>> combinations(52, 5)\\n    2598960\\n\\n    >>> combinations(0, 0)\\n    1\\n\\n    >>> combinations(-4, -5)\\n    ...\\n    Traceback (most recent call last):\\n    ValueError: Please enter positive integers for n and k where n >= k\\n    \\\"\\\"\\\"\\n\\n    # If either of the conditions are true, the function is being asked\\n    # to calculate a factorial of a negative number, which is not possible\\n    if n < k or k < 0:\\n        raise ValueError(\\\"Please enter positive integers for n and k where n >= k\\\")\\n    return int(factorial(n) / ((factorial(k)) * (factorial(n - k))))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    print(\\n        \\\"\\\\nThe number of five-card hands possible from a standard\\\",\\n        f\\\"fifty-two card deck is: {combinations(52, 5)}\\\",\\n    )\\n\\n    print(\\n        \\\"\\\\nIf a class of 40 students must be arranged into groups of\\\",\\n        f\\\"4 for group projects, there are {combinations(40, 4)} ways\\\",\\n        \\\"to arrange them.\\\\n\\\",\\n    )\\n\\n    print(\\n        \\\"If 10 teams are competing in a Formula One race, there\\\",\\n        f\\\"are {combinations(10, 3)} ways that first, second and\\\",\\n        \\\"third place can be awarded.\\\\n\\\",\\n    )\\n\"",
    "decimal isolate": "\"\\\"\\\"\\\"\\nIsolate the Decimal part of a Number\\nhttps://stackoverflow.com/questions/3886402/how-to-get-numbers-after-decimal-point\\n\\\"\\\"\\\"\\n\\n\\ndef decimal_isolate(number, digitAmount):\\n\\n    \\\"\\\"\\\"\\n    Isolates the decimal part of a number.\\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\\n    >>> decimal_isolate(1.53, 0)\\n    0.53\\n    >>> decimal_isolate(35.345, 1)\\n    0.3\\n    >>> decimal_isolate(35.345, 2)\\n    0.34\\n    >>> decimal_isolate(35.345, 3)\\n    0.345\\n    >>> decimal_isolate(-14.789, 3)\\n    -0.789\\n    >>> decimal_isolate(0, 2)\\n    0\\n    >>> decimal_isolate(-14.123, 1)\\n    -0.1\\n    >>> decimal_isolate(-14.123, 2)\\n    -0.12\\n    >>> decimal_isolate(-14.123, 3)\\n    -0.123\\n    \\\"\\\"\\\"\\n    if digitAmount > 0:\\n        return round(number - int(number), digitAmount)\\n    return number - int(number)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(decimal_isolate(1.53, 0))\\n    print(decimal_isolate(35.345, 1))\\n    print(decimal_isolate(35.345, 2))\\n    print(decimal_isolate(35.345, 3))\\n    print(decimal_isolate(-14.789, 3))\\n    print(decimal_isolate(0, 2))\\n    print(decimal_isolate(-14.123, 1))\\n    print(decimal_isolate(-14.123, 2))\\n    print(decimal_isolate(-14.123, 3))\\n\"",
    "double factorial iterative": "\"def double_factorial(num: int) -> int:\\n    \\\"\\\"\\\"\\n    Compute double factorial using iterative method.\\n\\n    To learn about the theory behind this algorithm:\\n    https://en.wikipedia.org/wiki/Double_factorial\\n\\n    >>> import math\\n    >>> all(double_factorial(i) == math.prod(range(i, 0, -2)) for i in range(20))\\n    True\\n    >>> double_factorial(0.1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: double_factorial() only accepts integral values\\n    >>> double_factorial(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: double_factorial() not defined for negative values\\n    \\\"\\\"\\\"\\n    if not isinstance(num, int):\\n        raise ValueError(\\\"double_factorial() only accepts integral values\\\")\\n    if num < 0:\\n        raise ValueError(\\\"double_factorial() not defined for negative values\\\")\\n    value = 1\\n    for i in range(num, 0, -2):\\n        value *= i\\n    return value\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "double factorial recursive": "\"def double_factorial(n: int) -> int:\\n    \\\"\\\"\\\"\\n    Compute double factorial using recursive method.\\n    Recursion can be costly for large numbers.\\n\\n    To learn about the theory behind this algorithm:\\n    https://en.wikipedia.org/wiki/Double_factorial\\n\\n    >>> import math\\n    >>> all(double_factorial(i) == math.prod(range(i, 0, -2)) for i in range(20))\\n    True\\n    >>> double_factorial(0.1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: double_factorial() only accepts integral values\\n    >>> double_factorial(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: double_factorial() not defined for negative values\\n    \\\"\\\"\\\"\\n    if not isinstance(n, int):\\n        raise ValueError(\\\"double_factorial() only accepts integral values\\\")\\n    if n < 0:\\n        raise ValueError(\\\"double_factorial() not defined for negative values\\\")\\n    return 1 if n <= 1 else n * double_factorial(n - 2)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "entropy": "\"#!/usr/bin/env python3\\n\\n\\\"\\\"\\\"\\nImplementation of entropy of information\\nhttps://en.wikipedia.org/wiki/Entropy_(information_theory)\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport math\\nfrom collections import Counter\\nfrom string import ascii_lowercase\\n\\n\\ndef calculate_prob(text: str) -> None:\\n    \\\"\\\"\\\"\\n    This method takes path and two dict as argument\\n    and than calculates entropy of them.\\n    :param dict:\\n    :param dict:\\n    :return: Prints\\n    1) Entropy of information based on 1 alphabet\\n    2) Entropy of information based on couples of 2 alphabet\\n    3) print Entropy of H(X n∣Xn−1)\\n\\n    Text from random books. Also, random quotes.\\n    >>> text = (\\\"Behind Winston’s back the voice \\\"\\n    ...         \\\"from the telescreen was still \\\"\\n    ...         \\\"babbling and the overfulfilment\\\")\\n    >>> calculate_prob(text)\\n    4.0\\n    6.0\\n    2.0\\n\\n    >>> text = (\\\"The Ministry of Truth—Minitrue, in Newspeak [Newspeak was the official\\\"\\n    ...         \\\"face in elegant lettering, the three\\\")\\n    >>> calculate_prob(text)\\n    4.0\\n    5.0\\n    1.0\\n    >>> text = (\\\"Had repulsive dashwoods suspicion sincerity but advantage now him. \\\"\\n    ...         \\\"Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. \\\"\\n    ...         \\\"You greatest jointure saw horrible. He private he on be imagine \\\"\\n    ...         \\\"suppose. Fertile beloved evident through no service elderly is. Blind \\\"\\n    ...         \\\"there if every no so at. Own neglected you preferred way sincerity \\\"\\n    ...         \\\"delivered his attempted. To of message cottage windows do besides \\\"\\n    ...         \\\"against uncivil.  Delightful unreserved impossible few estimating \\\"\\n    ...         \\\"men favourable see entreaties. She propriety immediate was improving. \\\"\\n    ...         \\\"He or entrance humoured likewise moderate. Much nor game son say \\\"\\n    ...         \\\"feel. Fat make met can must form into gate. Me we offending prevailed \\\"\\n    ...         \\\"discovery.\\\")\\n    >>> calculate_prob(text)\\n    4.0\\n    7.0\\n    3.0\\n    \\\"\\\"\\\"\\n    single_char_strings, two_char_strings = analyze_text(text)\\n    my_alphas = list(\\\" \\\" + ascii_lowercase)\\n    # what is our total sum of probabilities.\\n    all_sum = sum(single_char_strings.values())\\n\\n    # one length string\\n    my_fir_sum = 0\\n    # for each alpha we go in our dict and if it is in it we calculate entropy\\n    for ch in my_alphas:\\n        if ch in single_char_strings:\\n            my_str = single_char_strings[ch]\\n            prob = my_str / all_sum\\n            my_fir_sum += prob * math.log2(prob)  # entropy formula.\\n\\n    # print entropy\\n    print(f\\\"{round(-1 * my_fir_sum):.1f}\\\")\\n\\n    # two len string\\n    all_sum = sum(two_char_strings.values())\\n    my_sec_sum = 0\\n    # for each alpha (two in size) calculate entropy.\\n    for ch0 in my_alphas:\\n        for ch1 in my_alphas:\\n            sequence = ch0 + ch1\\n            if sequence in two_char_strings:\\n                my_str = two_char_strings[sequence]\\n                prob = int(my_str) / all_sum\\n                my_sec_sum += prob * math.log2(prob)\\n\\n    # print second entropy\\n    print(f\\\"{round(-1 * my_sec_sum):.1f}\\\")\\n\\n    # print the difference between them\\n    print(f\\\"{round((-1 * my_sec_sum) - (-1 * my_fir_sum)):.1f}\\\")\\n\\n\\ndef analyze_text(text: str) -> tuple[dict, dict]:\\n    \\\"\\\"\\\"\\n    Convert text input into two dicts of counts.\\n    The first dictionary stores the frequency of single character strings.\\n    The second dictionary stores the frequency of two character strings.\\n    \\\"\\\"\\\"\\n    single_char_strings = Counter()  # type: ignore\\n    two_char_strings = Counter()  # type: ignore\\n    single_char_strings[text[-1]] += 1\\n\\n    # first case when we have space at start.\\n    two_char_strings[\\\" \\\" + text[0]] += 1\\n    for i in range(0, len(text) - 1):\\n        single_char_strings[text[i]] += 1\\n        two_char_strings[text[i : i + 2]] += 1\\n    return single_char_strings, two_char_strings\\n\\n\\ndef main():\\n    import doctest\\n\\n    doctest.testmod()\\n    # text = (\\n    #     \\\"Had repulsive dashwoods suspicion sincerity but advantage now him. Remark \\\"\\n    #     \\\"easily garret nor nay. Civil those mrs enjoy shy fat merry. You greatest \\\"\\n    #     \\\"jointure saw horrible. He private he on be imagine suppose. Fertile \\\"\\n    #     \\\"beloved evident through no service elderly is. Blind there if every no so \\\"\\n    #     \\\"at. Own neglected you preferred way sincerity delivered his attempted. To \\\"\\n    #     \\\"of message cottage windows do besides against uncivil.  Delightful \\\"\\n    #     \\\"unreserved impossible few estimating men favourable see entreaties. She \\\"\\n    #     \\\"propriety immediate was improving. He or entrance humoured likewise \\\"\\n    #     \\\"moderate. Much nor game son say feel. Fat make met can must form into \\\"\\n    #     \\\"gate. Me we offending prevailed discovery. \\\"\\n    # )\\n\\n    # calculate_prob(text)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "euclidean distance": "\"from __future__ import annotations\\n\\nfrom typing import Iterable, Union\\n\\nimport numpy as np\\n\\nVector = Union[Iterable[float], Iterable[int], np.ndarray]\\nVectorOut = Union[np.float64, int, float]\\n\\n\\ndef euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:\\n    \\\"\\\"\\\"\\n    Calculate the distance between the two endpoints of two vectors.\\n    A vector is defined as a list, tuple, or numpy 1D array.\\n    >>> euclidean_distance((0, 0), (2, 2))\\n    2.8284271247461903\\n    >>> euclidean_distance(np.array([0, 0, 0]), np.array([2, 2, 2]))\\n    3.4641016151377544\\n    >>> euclidean_distance(np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8]))\\n    8.0\\n    >>> euclidean_distance([1, 2, 3, 4], [5, 6, 7, 8])\\n    8.0\\n    \\\"\\\"\\\"\\n    return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))\\n\\n\\ndef euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:\\n    \\\"\\\"\\\"\\n    Calculate the distance between the two endpoints of two vectors without numpy.\\n    A vector is defined as a list, tuple, or numpy 1D array.\\n    >>> euclidean_distance_no_np((0, 0), (2, 2))\\n    2.8284271247461903\\n    >>> euclidean_distance_no_np([1, 2, 3, 4], [5, 6, 7, 8])\\n    8.0\\n    \\\"\\\"\\\"\\n    return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    def benchmark() -> None:\\n        \\\"\\\"\\\"\\n        Benchmarks\\n        \\\"\\\"\\\"\\n        from timeit import timeit\\n\\n        print(\\\"Without Numpy\\\")\\n        print(\\n            timeit(\\n                \\\"euclidean_distance_no_np([1, 2, 3], [4, 5, 6])\\\",\\n                number=10000,\\n                globals=globals(),\\n            )\\n        )\\n        print(\\\"With Numpy\\\")\\n        print(\\n            timeit(\\n                \\\"euclidean_distance([1, 2, 3], [4, 5, 6])\\\",\\n                number=10000,\\n                globals=globals(),\\n            )\\n        )\\n\\n    benchmark()\\n\"",
    "euclidean gcd": "\"\\\"\\\"\\\" https://en.wikipedia.org/wiki/Euclidean_algorithm \\\"\\\"\\\"\\n\\n\\ndef euclidean_gcd(a: int, b: int) -> int:\\n    \\\"\\\"\\\"\\n    Examples:\\n    >>> euclidean_gcd(3, 5)\\n    1\\n\\n    >>> euclidean_gcd(6, 3)\\n    3\\n    \\\"\\\"\\\"\\n    while b:\\n        a, b = b, a % b\\n    return a\\n\\n\\ndef euclidean_gcd_recursive(a: int, b: int) -> int:\\n    \\\"\\\"\\\"\\n    Recursive method for euclicedan gcd algorithm\\n\\n    Examples:\\n    >>> euclidean_gcd_recursive(3, 5)\\n    1\\n\\n    >>> euclidean_gcd_recursive(6, 3)\\n    3\\n    \\\"\\\"\\\"\\n    return a if b == 0 else euclidean_gcd_recursive(b, a % b)\\n\\n\\ndef main():\\n    print(f\\\"euclidean_gcd(3, 5) = {euclidean_gcd(3, 5)}\\\")\\n    print(f\\\"euclidean_gcd(5, 3) = {euclidean_gcd(5, 3)}\\\")\\n    print(f\\\"euclidean_gcd(1, 3) = {euclidean_gcd(1, 3)}\\\")\\n    print(f\\\"euclidean_gcd(3, 6) = {euclidean_gcd(3, 6)}\\\")\\n    print(f\\\"euclidean_gcd(6, 3) = {euclidean_gcd(6, 3)}\\\")\\n\\n    print(f\\\"euclidean_gcd_recursive(3, 5) = {euclidean_gcd_recursive(3, 5)}\\\")\\n    print(f\\\"euclidean_gcd_recursive(5, 3) = {euclidean_gcd_recursive(5, 3)}\\\")\\n    print(f\\\"euclidean_gcd_recursive(1, 3) = {euclidean_gcd_recursive(1, 3)}\\\")\\n    print(f\\\"euclidean_gcd_recursive(3, 6) = {euclidean_gcd_recursive(3, 6)}\\\")\\n    print(f\\\"euclidean_gcd_recursive(6, 3) = {euclidean_gcd_recursive(6, 3)}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "eulers totient": "\"# Eulers Totient function finds the number of relative primes of a number n from 1 to n\\ndef totient(n: int) -> list:\\n    is_prime = [True for i in range(n + 1)]\\n    totients = [i - 1 for i in range(n + 1)]\\n    primes = []\\n    for i in range(2, n + 1):\\n        if is_prime[i]:\\n            primes.append(i)\\n        for j in range(0, len(primes)):\\n            if i * primes[j] >= n:\\n                break\\n            is_prime[i * primes[j]] = False\\n\\n            if i % primes[j] == 0:\\n                totients[i * primes[j]] = totients[i] * primes[j]\\n                break\\n\\n            totients[i * primes[j]] = totients[i] * (primes[j] - 1)\\n\\n    return totients\\n\\n\\ndef test_totient() -> None:\\n    \\\"\\\"\\\"\\n    >>> n = 10\\n    >>> totient_calculation = totient(n)\\n    >>> for i in range(1, n):\\n    ...     print(f\\\"{i} has {totient_calculation[i]} relative primes.\\\")\\n    1 has 0 relative primes.\\n    2 has 1 relative primes.\\n    3 has 2 relative primes.\\n    4 has 2 relative primes.\\n    5 has 4 relative primes.\\n    6 has 2 relative primes.\\n    7 has 6 relative primes.\\n    8 has 4 relative primes.\\n    9 has 6 relative primes.\\n    \\\"\\\"\\\"\\n    pass\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "euler method": "\"from typing import Callable\\n\\nimport numpy as np\\n\\n\\ndef explicit_euler(\\n    ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float\\n) -> np.ndarray:\\n    \\\"\\\"\\\"Calculate numeric solution at each step to an ODE using Euler's Method\\n\\n    For reference to Euler's method refer to https://en.wikipedia.org/wiki/Euler_method.\\n\\n    Args:\\n        ode_func (Callable):  The ordinary differential equation\\n            as a function of x and y.\\n        y0 (float): The initial value for y.\\n        x0 (float): The initial value for x.\\n        step_size (float): The increment value for x.\\n        x_end (float): The final value of x to be calculated.\\n\\n    Returns:\\n        np.ndarray: Solution of y for every step in x.\\n\\n    >>> # the exact solution is math.exp(x)\\n    >>> def f(x, y):\\n    ...     return y\\n    >>> y0 = 1\\n    >>> y = explicit_euler(f, y0, 0.0, 0.01, 5)\\n    >>> y[-1]\\n    144.77277243257308\\n    \\\"\\\"\\\"\\n    N = int(np.ceil((x_end - x0) / step_size))\\n    y = np.zeros((N + 1,))\\n    y[0] = y0\\n    x = x0\\n\\n    for k in range(N):\\n        y[k + 1] = y[k] + step_size * ode_func(x, y[k])\\n        x += step_size\\n\\n    return y\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "euler modified": "\"from typing import Callable\\n\\nimport numpy as np\\n\\n\\ndef euler_modified(\\n    ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float\\n) -> np.array:\\n    \\\"\\\"\\\"\\n    Calculate solution at each step to an ODE using Euler's Modified Method\\n    The Euler Method is straightforward to implement, but can't give accurate solutions.\\n    So, some changes were proposed to improve accuracy.\\n\\n    https://en.wikipedia.org/wiki/Euler_method\\n\\n    Arguments:\\n    ode_func -- The ode as a function of x and y\\n    y0 -- the initial value for y\\n    x0 -- the initial value for x\\n    stepsize -- the increment value for x\\n    x_end -- the end value for x\\n\\n    >>> # the exact solution is math.exp(x)\\n    >>> def f1(x, y):\\n    ...     return -2*x*(y**2)\\n    >>> y = euler_modified(f1, 1.0, 0.0, 0.2, 1.0)\\n    >>> y[-1]\\n    0.503338255442106\\n    >>> import math\\n    >>> def f2(x, y):\\n    ...     return -2*y + (x**3)*math.exp(-2*x)\\n    >>> y = euler_modified(f2, 1.0, 0.0, 0.1, 0.3)\\n    >>> y[-1]\\n    0.5525976431951775\\n    \\\"\\\"\\\"\\n    N = int(np.ceil((x_end - x0) / step_size))\\n    y = np.zeros((N + 1,))\\n    y[0] = y0\\n    x = x0\\n\\n    for k in range(N):\\n        y_get = y[k] + step_size * ode_func(x, y[k])\\n        y[k + 1] = y[k] + (\\n            (step_size / 2) * (ode_func(x, y[k]) + ode_func(x + step_size, y_get))\\n        )\\n        x += step_size\\n\\n    return y\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "extended euclidean algorithm": "\"\\\"\\\"\\\"\\nExtended Euclidean Algorithm.\\n\\nFinds 2 numbers a and b such that it satisfies\\nthe equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\\n\\nhttps://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\\n\\\"\\\"\\\"\\n\\n# @Author: S. Sharma <silentcat>\\n# @Date:   2019-02-25T12:08:53-06:00\\n# @Email:  silentcat@protonmail.com\\n# @Last modified by:   pikulet\\n# @Last modified time: 2020-10-02\\nfrom __future__ import annotations\\n\\nimport sys\\n\\n\\ndef extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\\n    \\\"\\\"\\\"\\n    Extended Euclidean Algorithm.\\n\\n    Finds 2 numbers a and b such that it satisfies\\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\\n\\n    >>> extended_euclidean_algorithm(1, 24)\\n    (1, 0)\\n\\n    >>> extended_euclidean_algorithm(8, 14)\\n    (2, -1)\\n\\n    >>> extended_euclidean_algorithm(240, 46)\\n    (-9, 47)\\n\\n    >>> extended_euclidean_algorithm(1, -4)\\n    (1, 0)\\n\\n    >>> extended_euclidean_algorithm(-2, -4)\\n    (-1, 0)\\n\\n    >>> extended_euclidean_algorithm(0, -4)\\n    (0, -1)\\n\\n    >>> extended_euclidean_algorithm(2, 0)\\n    (1, 0)\\n\\n    \\\"\\\"\\\"\\n    # base cases\\n    if abs(a) == 1:\\n        return a, 0\\n    elif abs(b) == 1:\\n        return 0, b\\n\\n    old_remainder, remainder = a, b\\n    old_coeff_a, coeff_a = 1, 0\\n    old_coeff_b, coeff_b = 0, 1\\n\\n    while remainder != 0:\\n        quotient = old_remainder // remainder\\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\\n\\n    # sign correction for negative numbers\\n    if a < 0:\\n        old_coeff_a = -old_coeff_a\\n    if b < 0:\\n        old_coeff_b = -old_coeff_b\\n\\n    return old_coeff_a, old_coeff_b\\n\\n\\ndef main():\\n    \\\"\\\"\\\"Call Extended Euclidean Algorithm.\\\"\\\"\\\"\\n    if len(sys.argv) < 3:\\n        print(\\\"2 integer arguments required\\\")\\n        exit(1)\\n    a = int(sys.argv[1])\\n    b = int(sys.argv[2])\\n    print(extended_euclidean_algorithm(a, b))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "factorial iterative": "\"\\\"\\\"\\\"Factorial of a positive integer -- https://en.wikipedia.org/wiki/Factorial\\n\\\"\\\"\\\"\\n\\n\\ndef factorial(number: int) -> int:\\n    \\\"\\\"\\\"\\n    Calculate the factorial of specified number (n!).\\n\\n    >>> import math\\n    >>> all(factorial(i) == math.factorial(i) for i in range(20))\\n    True\\n    >>> factorial(0.1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: factorial() only accepts integral values\\n    >>> factorial(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: factorial() not defined for negative values\\n    >>> factorial(1)\\n    1\\n    >>> factorial(6)\\n    720\\n    >>> factorial(0)\\n    1\\n    \\\"\\\"\\\"\\n    if number != int(number):\\n        raise ValueError(\\\"factorial() only accepts integral values\\\")\\n    if number < 0:\\n        raise ValueError(\\\"factorial() not defined for negative values\\\")\\n    value = 1\\n    for i in range(1, number + 1):\\n        value *= i\\n    return value\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    n = int(input(\\\"Enter a positive integer: \\\").strip() or 0)\\n    print(f\\\"factorial{n} is {factorial(n)}\\\")\\n\"",
    "factorial recursive": "\"def factorial(n: int) -> int:\\n    \\\"\\\"\\\"\\n    Calculate the factorial of a positive integer\\n    https://en.wikipedia.org/wiki/Factorial\\n\\n    >>> import math\\n    >>> all(factorial(i) == math.factorial(i) for i in range(20))\\n    True\\n    >>> factorial(0.1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: factorial() only accepts integral values\\n    >>> factorial(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: factorial() not defined for negative values\\n    \\\"\\\"\\\"\\n    if not isinstance(n, int):\\n        raise ValueError(\\\"factorial() only accepts integral values\\\")\\n    if n < 0:\\n        raise ValueError(\\\"factorial() not defined for negative values\\\")\\n    return 1 if n == 0 or n == 1 else n * factorial(n - 1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "factors": "\"def factors_of_a_number(num: int) -> list:\\n    \\\"\\\"\\\"\\n    >>> factors_of_a_number(1)\\n    [1]\\n    >>> factors_of_a_number(5)\\n    [1, 5]\\n    >>> factors_of_a_number(24)\\n    [1, 2, 3, 4, 6, 8, 12, 24]\\n    >>> factors_of_a_number(-24)\\n    []\\n    \\\"\\\"\\\"\\n    return [i for i in range(1, num + 1) if num % i == 0]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    num = int(input(\\\"Enter a number to find its factors: \\\"))\\n    factors = factors_of_a_number(num)\\n    print(f\\\"{num} has {len(factors)} factors: {', '.join(str(f) for f in factors)}\\\")\\n\"",
    "fermat little theorem": "\"# Python program to show the usage of Fermat's little theorem in a division\\n# According to Fermat's little theorem, (a / b) mod p always equals\\n# a * (b ^ (p - 2)) mod p\\n# Here we assume that p is a prime number, b divides a, and p doesn't divide b\\n# Wikipedia reference: https://en.wikipedia.org/wiki/Fermat%27s_little_theorem\\n\\n\\ndef binary_exponentiation(a, n, mod):\\n\\n    if n == 0:\\n        return 1\\n\\n    elif n % 2 == 1:\\n        return (binary_exponentiation(a, n - 1, mod) * a) % mod\\n\\n    else:\\n        b = binary_exponentiation(a, n / 2, mod)\\n        return (b * b) % mod\\n\\n\\n# a prime number\\np = 701\\n\\na = 1000000000\\nb = 10\\n\\n# using binary exponentiation function, O(log(p)):\\nprint((a / b) % p == (a * binary_exponentiation(b, p - 2, p)) % p)\\n\\n# using Python operators:\\nprint((a / b) % p == (a * b ** (p - 2)) % p)\\n\"",
    "find max": "\"from __future__ import annotations\\n\\n\\ndef find_max(nums: list[int | float]) -> int | float:\\n    \\\"\\\"\\\"\\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\\n    ...     find_max(nums) == max(nums)\\n    True\\n    True\\n    True\\n    True\\n    >>> find_max([2, 4, 9, 7, 19, 94, 5])\\n    94\\n    >>> find_max([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: find_max() arg is an empty sequence\\n    \\\"\\\"\\\"\\n    if len(nums) == 0:\\n        raise ValueError(\\\"find_max() arg is an empty sequence\\\")\\n    max_num = nums[0]\\n    for x in nums:\\n        if x > max_num:\\n            max_num = x\\n    return max_num\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod(verbose=True)\\n\"",
    "find max recursion": "\"from __future__ import annotations\\n\\n\\n# Divide and Conquer algorithm\\ndef find_max(nums: list[int | float], left: int, right: int) -> int | float:\\n    \\\"\\\"\\\"\\n    find max value in list\\n    :param nums: contains elements\\n    :param left: index of first element\\n    :param right: index of last element\\n    :return: max in nums\\n\\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\\n    ...     find_max(nums, 0, len(nums) - 1) == max(nums)\\n    True\\n    True\\n    True\\n    True\\n    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\\n    >>> find_max(nums, 0, len(nums) - 1) == max(nums)\\n    True\\n    >>> find_max([], 0, 0)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: find_max() arg is an empty sequence\\n    >>> find_max(nums, 0, len(nums)) == max(nums)\\n    Traceback (most recent call last):\\n        ...\\n    IndexError: list index out of range\\n    >>> find_max(nums, -len(nums), -1) == max(nums)\\n    True\\n    >>> find_max(nums, -len(nums) - 1, -1) == max(nums)\\n    Traceback (most recent call last):\\n        ...\\n    IndexError: list index out of range\\n    \\\"\\\"\\\"\\n    if len(nums) == 0:\\n        raise ValueError(\\\"find_max() arg is an empty sequence\\\")\\n    if (\\n        left >= len(nums)\\n        or left < -len(nums)\\n        or right >= len(nums)\\n        or right < -len(nums)\\n    ):\\n        raise IndexError(\\\"list index out of range\\\")\\n    if left == right:\\n        return nums[left]\\n    mid = (left + right) >> 1  # the middle\\n    left_max = find_max(nums, left, mid)  # find max in range[left, mid]\\n    right_max = find_max(nums, mid + 1, right)  # find max in range[mid + 1, right]\\n\\n    return left_max if left_max >= right_max else right_max\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod(verbose=True)\\n\"",
    "find min": "\"from __future__ import annotations\\n\\n\\ndef find_min(nums: list[int | float]) -> int | float:\\n    \\\"\\\"\\\"\\n    Find Minimum Number in a List\\n    :param nums: contains elements\\n    :return: min number in list\\n\\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\\n    ...     find_min(nums) == min(nums)\\n    True\\n    True\\n    True\\n    True\\n    >>> find_min([0, 1, 2, 3, 4, 5, -3, 24, -56])\\n    -56\\n    >>> find_min([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: find_min() arg is an empty sequence\\n    \\\"\\\"\\\"\\n    if len(nums) == 0:\\n        raise ValueError(\\\"find_min() arg is an empty sequence\\\")\\n    min_num = nums[0]\\n    for num in nums:\\n        if min_num > num:\\n            min_num = num\\n    return min_num\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod(verbose=True)\\n\"",
    "find min recursion": "\"from __future__ import annotations\\n\\n\\n# Divide and Conquer algorithm\\ndef find_min(nums: list[int | float], left: int, right: int) -> int | float:\\n    \\\"\\\"\\\"\\n    find min value in list\\n    :param nums: contains elements\\n    :param left: index of first element\\n    :param right: index of last element\\n    :return: min in nums\\n\\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\\n    ...     find_min(nums, 0, len(nums) - 1) == min(nums)\\n    True\\n    True\\n    True\\n    True\\n    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\\n    >>> find_min(nums, 0, len(nums) - 1) == min(nums)\\n    True\\n    >>> find_min([], 0, 0)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: find_min() arg is an empty sequence\\n    >>> find_min(nums, 0, len(nums)) == min(nums)\\n    Traceback (most recent call last):\\n        ...\\n    IndexError: list index out of range\\n    >>> find_min(nums, -len(nums), -1) == min(nums)\\n    True\\n    >>> find_min(nums, -len(nums) - 1, -1) == min(nums)\\n    Traceback (most recent call last):\\n        ...\\n    IndexError: list index out of range\\n    \\\"\\\"\\\"\\n    if len(nums) == 0:\\n        raise ValueError(\\\"find_min() arg is an empty sequence\\\")\\n    if (\\n        left >= len(nums)\\n        or left < -len(nums)\\n        or right >= len(nums)\\n        or right < -len(nums)\\n    ):\\n        raise IndexError(\\\"list index out of range\\\")\\n    if left == right:\\n        return nums[left]\\n    mid = (left + right) >> 1  # the middle\\n    left_min = find_min(nums, left, mid)  # find min in range[left, mid]\\n    right_min = find_min(nums, mid + 1, right)  # find min in range[mid + 1, right]\\n\\n    return left_min if left_min <= right_min else right_min\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod(verbose=True)\\n\"",
    "floor": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Floor_and_ceiling_functions\\n\\\"\\\"\\\"\\n\\n\\ndef floor(x) -> int:\\n    \\\"\\\"\\\"\\n    Return the floor of x as an Integral.\\n    :param x: the number\\n    :return: the largest integer <= x.\\n    >>> import math\\n    >>> all(floor(n) == math.floor(n) for n\\n    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\\n    True\\n    \\\"\\\"\\\"\\n    return int(x) if x - int(x) >= 0 else int(x) - 1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "gamma": "\"import math\\n\\nfrom numpy import inf\\nfrom scipy.integrate import quad\\n\\n\\ndef gamma(num: float) -> float:\\n    \\\"\\\"\\\"\\n    https://en.wikipedia.org/wiki/Gamma_function\\n    In mathematics, the gamma function is one commonly\\n    used extension of the factorial function to complex numbers.\\n    The gamma function is defined for all complex numbers except the non-positive\\n    integers\\n\\n\\n    >>> gamma(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: math domain error\\n\\n\\n\\n    >>> gamma(0)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: math domain error\\n\\n\\n    >>> gamma(9)\\n    40320.0\\n\\n    >>> from math import gamma as math_gamma\\n    >>> all(.99999999 < gamma(i) / math_gamma(i) <= 1.000000001\\n    ...     for i in range(1, 50))\\n    True\\n\\n\\n    >>> from math import gamma as math_gamma\\n    >>> gamma(-1)/math_gamma(-1) <= 1.000000001\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: math domain error\\n\\n\\n    >>> from math import gamma as math_gamma\\n    >>> gamma(3.3) - math_gamma(3.3) <= 0.00000001\\n    True\\n    \\\"\\\"\\\"\\n\\n    if num <= 0:\\n        raise ValueError(\\\"math domain error\\\")\\n\\n    return quad(integrand, 0, inf, args=(num))[0]\\n\\n\\ndef integrand(x: float, z: float) -> float:\\n    return math.pow(x, z - 1) * math.exp(-x)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "gamma recursive": "\"\\\"\\\"\\\"\\nGamma function is a very useful tool in math and physics.\\nIt helps calculating complex integral in a convenient way.\\nfor more info: https://en.wikipedia.org/wiki/Gamma_function\\nPython's Standard Library math.gamma() function overflows around gamma(171.624).\\n\\\"\\\"\\\"\\nfrom math import pi, sqrt\\n\\n\\ndef gamma(num: float) -> float:\\n    \\\"\\\"\\\"\\n    Calculates the value of Gamma function of num\\n    where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).\\n    Implemented using recursion\\n    Examples:\\n    >>> from math import isclose, gamma as math_gamma\\n    >>> gamma(0.5)\\n    1.7724538509055159\\n    >>> gamma(2)\\n    1.0\\n    >>> gamma(3.5)\\n    3.3233509704478426\\n    >>> gamma(171.5)\\n    9.483367566824795e+307\\n    >>> all(isclose(gamma(num), math_gamma(num)) for num in (0.5, 2, 3.5, 171.5))\\n    True\\n    >>> gamma(0)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: math domain error\\n    >>> gamma(-1.1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: math domain error\\n    >>> gamma(-4)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: math domain error\\n    >>> gamma(172)\\n    Traceback (most recent call last):\\n        ...\\n    OverflowError: math range error\\n    >>> gamma(1.1)\\n    Traceback (most recent call last):\\n        ...\\n    NotImplementedError: num must be an integer or a half-integer\\n    \\\"\\\"\\\"\\n    if num <= 0:\\n        raise ValueError(\\\"math domain error\\\")\\n    if num > 171.5:\\n        raise OverflowError(\\\"math range error\\\")\\n    elif num - int(num) not in (0, 0.5):\\n        raise NotImplementedError(\\\"num must be an integer or a half-integer\\\")\\n    elif num == 0.5:\\n        return sqrt(pi)\\n    else:\\n        return 1.0 if num == 1 else (num - 1) * gamma(num - 1)\\n\\n\\ndef test_gamma() -> None:\\n    \\\"\\\"\\\"\\n    >>> test_gamma()\\n    \\\"\\\"\\\"\\n    assert gamma(0.5) == sqrt(pi)\\n    assert gamma(1) == 1.0\\n    assert gamma(2) == 1.0\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n    num = 1.0\\n    while num:\\n        num = float(input(\\\"Gamma of: \\\"))\\n        print(f\\\"gamma({num}) = {gamma(num)}\\\")\\n        print(\\\"\\\\nEnter 0 to exit...\\\")\\n\"",
    "gaussian": "\"\\\"\\\"\\\"\\nReference: https://en.wikipedia.org/wiki/Gaussian_function\\n\\\"\\\"\\\"\\nfrom numpy import exp, pi, sqrt\\n\\n\\ndef gaussian(x, mu: float = 0.0, sigma: float = 1.0) -> int:\\n    \\\"\\\"\\\"\\n    >>> gaussian(1)\\n    0.24197072451914337\\n\\n    >>> gaussian(24)\\n    3.342714441794458e-126\\n\\n    >>> gaussian(1, 4, 2)\\n    0.06475879783294587\\n\\n    >>> gaussian(1, 5, 3)\\n    0.05467002489199788\\n\\n    Supports NumPy Arrays\\n    Use numpy.meshgrid with this to generate gaussian blur on images.\\n    >>> import numpy as np\\n    >>> x = np.arange(15)\\n    >>> gaussian(x)\\n    array([3.98942280e-01, 2.41970725e-01, 5.39909665e-02, 4.43184841e-03,\\n           1.33830226e-04, 1.48671951e-06, 6.07588285e-09, 9.13472041e-12,\\n           5.05227108e-15, 1.02797736e-18, 7.69459863e-23, 2.11881925e-27,\\n           2.14638374e-32, 7.99882776e-38, 1.09660656e-43])\\n\\n    >>> gaussian(15)\\n    5.530709549844416e-50\\n\\n    >>> gaussian([1,2, 'string'])\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: unsupported operand type(s) for -: 'list' and 'float'\\n\\n    >>> gaussian('hello world')\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: unsupported operand type(s) for -: 'str' and 'float'\\n\\n    >>> gaussian(10**234) # doctest: +IGNORE_EXCEPTION_DETAIL\\n    Traceback (most recent call last):\\n        ...\\n    OverflowError: (34, 'Result too large')\\n\\n    >>> gaussian(10**-326)\\n    0.3989422804014327\\n\\n    >>> gaussian(2523, mu=234234, sigma=3425)\\n    0.0\\n    \\\"\\\"\\\"\\n    return 1 / sqrt(2 * pi * sigma ** 2) * exp(-((x - mu) ** 2) / (2 * sigma ** 2))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "greatest common divisor": "\"\\\"\\\"\\\"\\nGreatest Common Divisor.\\n\\nWikipedia reference: https://en.wikipedia.org/wiki/Greatest_common_divisor\\n\\ngcd(a, b) = gcd(a, -b) = gcd(-a, b) = gcd(-a, -b) by definition of divisibility\\n\\\"\\\"\\\"\\n\\n\\ndef greatest_common_divisor(a: int, b: int) -> int:\\n    \\\"\\\"\\\"\\n    Calculate Greatest Common Divisor (GCD).\\n    >>> greatest_common_divisor(24, 40)\\n    8\\n    >>> greatest_common_divisor(1, 1)\\n    1\\n    >>> greatest_common_divisor(1, 800)\\n    1\\n    >>> greatest_common_divisor(11, 37)\\n    1\\n    >>> greatest_common_divisor(3, 5)\\n    1\\n    >>> greatest_common_divisor(16, 4)\\n    4\\n    >>> greatest_common_divisor(-3, 9)\\n    3\\n    >>> greatest_common_divisor(9, -3)\\n    3\\n    >>> greatest_common_divisor(3, -9)\\n    3\\n    >>> greatest_common_divisor(-3, -9)\\n    3\\n    \\\"\\\"\\\"\\n    return abs(b) if a == 0 else greatest_common_divisor(b % a, a)\\n\\n\\ndef gcd_by_iterative(x: int, y: int) -> int:\\n    \\\"\\\"\\\"\\n    Below method is more memory efficient because it does not create additional\\n    stack frames for recursive functions calls (as done in the above method).\\n    >>> gcd_by_iterative(24, 40)\\n    8\\n    >>> greatest_common_divisor(24, 40) == gcd_by_iterative(24, 40)\\n    True\\n    >>> gcd_by_iterative(-3, -9)\\n    3\\n    >>> gcd_by_iterative(3, -9)\\n    3\\n    >>> gcd_by_iterative(1, -800)\\n    1\\n    >>> gcd_by_iterative(11, 37)\\n    1\\n    \\\"\\\"\\\"\\n    while y:  # --> when y=0 then loop will terminate and return x as final GCD.\\n        x, y = y, x % y\\n    return abs(x)\\n\\n\\ndef main():\\n    \\\"\\\"\\\"\\n    Call Greatest Common Divisor function.\\n    \\\"\\\"\\\"\\n    try:\\n        nums = input(\\\"Enter two integers separated by comma (,): \\\").split(\\\",\\\")\\n        num_1 = int(nums[0])\\n        num_2 = int(nums[1])\\n        print(\\n            f\\\"greatest_common_divisor({num_1}, {num_2}) = \\\"\\n            f\\\"{greatest_common_divisor(num_1, num_2)}\\\"\\n        )\\n        print(f\\\"By iterative gcd({num_1}, {num_2}) = {gcd_by_iterative(num_1, num_2)}\\\")\\n    except (IndexError, UnboundLocalError, ValueError):\\n        print(\\\"Wrong input\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "greedy coin change": "\"\\\"\\\"\\\"\\nTest cases:\\nDo you want to enter your denominations ? (Y/N) :N\\nEnter the change you want to make in Indian Currency: 987\\nFollowing is minimal  change for 987 :\\n500 100 100 100 100 50 20 10 5 2\\n\\nDo you want to enter your denominations ? (Y/N) :Y\\nEnter number of denomination:10\\n1\\n5\\n10\\n20\\n50\\n100\\n200\\n500\\n1000\\n2000\\nEnter the change you want to make: 18745\\nFollowing is minimal  change for 18745 :\\n2000 2000 2000 2000 2000 2000 2000 2000 2000 500 200 20 20 5\\n\\nDo you want to enter your denominations ? (Y/N) :N\\nEnter the change you want to make: 0\\nThe total value cannot be zero or negative.\\nDo you want to enter your denominations ? (Y/N) :N\\nEnter the change you want to make: -98\\nThe total value cannot be zero or negative.\\n\\nDo you want to enter your denominations ? (Y/N) :Y\\nEnter number of denomination:5\\n1\\n5\\n100\\n500\\n1000\\nEnter the change you want to make: 456\\nFollowing is minimal   change for 456 :\\n100 100 100 100 5 5 5 5 5 5 5 5 5 5 5 1\\n\\\"\\\"\\\"\\n\\n\\ndef find_minimum_change(denominations: list[int], value: str) -> list[int]:\\n    \\\"\\\"\\\"\\n    Find the minimum change from the given denominations and value\\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\\n    []\\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\\n    []\\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\\n    \\\"\\\"\\\"\\n    total_value = int(value)\\n\\n    # Initialize Result\\n    answer = []\\n\\n    # Traverse through all denomination\\n    for denomination in reversed(denominations):\\n\\n        # Find denominations\\n        while int(total_value) >= int(denomination):\\n            total_value -= int(denomination)\\n            answer.append(denomination)  # Append the \\\"answers\\\" array\\n\\n    return answer\\n\\n\\n# Driver Code\\nif __name__ == \\\"__main__\\\":\\n\\n    denominations = list()\\n    value = \\\"0\\\"\\n\\n    if (\\n        input(\\\"Do you want to enter your denominations ? (yY/n): \\\").strip().lower()\\n        == \\\"y\\\"\\n    ):\\n        n = int(input(\\\"Enter the number of denominations you want to add: \\\").strip())\\n\\n        for i in range(0, n):\\n            denominations.append(int(input(f\\\"Denomination {i}: \\\").strip()))\\n        value = input(\\\"Enter the change you want to make in Indian Currency: \\\").strip()\\n    else:\\n        # All denominations of Indian Currency if user does not enter\\n        denominations = [1, 2, 5, 10, 20, 50, 100, 500, 2000]\\n        value = input(\\\"Enter the change you want to make: \\\").strip()\\n\\n    if int(value) == 0 or int(value) < 0:\\n        print(\\\"The total value cannot be zero or negative.\\\")\\n\\n    else:\\n        print(f\\\"Following is minimal change for {value}: \\\")\\n        answer = find_minimum_change(denominations, value)\\n        # Print result\\n        for i in range(len(answer)):\\n            print(answer[i], end=\\\" \\\")\\n\"",
    "hardy ramanujanalgo": "\"# This theorem states that the number of prime factors of n\\n# will be approximately log(log(n)) for most natural numbers n\\n\\nimport math\\n\\n\\ndef exactPrimeFactorCount(n):\\n    \\\"\\\"\\\"\\n    >>> exactPrimeFactorCount(51242183)\\n    3\\n    \\\"\\\"\\\"\\n    count = 0\\n    if n % 2 == 0:\\n        count += 1\\n        while n % 2 == 0:\\n            n = int(n / 2)\\n    # the n input value must be odd so that\\n    # we can skip one element (ie i += 2)\\n\\n    i = 3\\n\\n    while i <= int(math.sqrt(n)):\\n        if n % i == 0:\\n            count += 1\\n            while n % i == 0:\\n                n = int(n / i)\\n        i = i + 2\\n\\n    # this condition checks the prime\\n    # number n is greater than 2\\n\\n    if n > 2:\\n        count += 1\\n    return count\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    n = 51242183\\n    print(f\\\"The number of distinct prime factors is/are {exactPrimeFactorCount(n)}\\\")\\n    print(f\\\"The value of log(log(n)) is {math.log(math.log(n)):.4f}\\\")\\n\\n    \\\"\\\"\\\"\\n    The number of distinct prime factors is/are 3\\n    The value of log(log(n)) is 2.8765\\n    \\\"\\\"\\\"\\n\"",
    "integration by simpson approx": "\"\\\"\\\"\\\"\\nAuthor : Syed Faizan ( 3rd Year IIIT Pune )\\nGithub : faizan2700\\n\\nPurpose : You have one function f(x) which takes float integer and returns\\nfloat you have to integrate the function in limits a to b.\\nThe approximation proposed by Thomas Simpsons in 1743 is one way to calculate\\nintegration.\\n\\n( read article : https://cp-algorithms.com/num_methods/simpson-integration.html )\\n\\nsimpson_integration() takes function,lower_limit=a,upper_limit=b,precision and\\nreturns the integration of function in given limit.\\n\\\"\\\"\\\"\\n\\n# constants\\n# the more the number of steps the more accurate\\nN_STEPS = 1000\\n\\n\\ndef f(x: float) -> float:\\n    return x * x\\n\\n\\n\\\"\\\"\\\"\\nSummary of Simpson Approximation :\\n\\nBy simpsons integration :\\n1. integration of fxdx with limit a to b is =\\n    f(x0) + 4 * f(x1) + 2 * f(x2) + 4 * f(x3) + 2 * f(x4)..... + f(xn)\\nwhere x0 = a\\nxi = a + i * h\\nxn = b\\n\\\"\\\"\\\"\\n\\n\\ndef simpson_integration(function, a: float, b: float, precision: int = 4) -> float:\\n\\n    \\\"\\\"\\\"\\n    Args:\\n        function : the function which's integration is desired\\n        a : the lower limit of integration\\n        b : upper limit of integraion\\n        precision : precision of the result,error required default is 4\\n\\n    Returns:\\n        result : the value of the approximated integration of function in range a to b\\n\\n    Raises:\\n        AssertionError: function is not callable\\n        AssertionError: a is not float or integer\\n        AssertionError: function should return float or integer\\n        AssertionError: b is not float or integer\\n        AssertionError: precision is not positive integer\\n\\n    >>> simpson_integration(lambda x : x*x,1,2,3)\\n    2.333\\n\\n    >>> simpson_integration(lambda x : x*x,'wrong_input',2,3)\\n    Traceback (most recent call last):\\n        ...\\n    AssertionError: a should be float or integer your input : wrong_input\\n\\n    >>> simpson_integration(lambda x : x*x,1,'wrong_input',3)\\n    Traceback (most recent call last):\\n        ...\\n    AssertionError: b should be float or integer your input : wrong_input\\n\\n    >>> simpson_integration(lambda x : x*x,1,2,'wrong_input')\\n    Traceback (most recent call last):\\n        ...\\n    AssertionError: precision should be positive integer your input : wrong_input\\n    >>> simpson_integration('wrong_input',2,3,4)\\n    Traceback (most recent call last):\\n        ...\\n    AssertionError: the function(object) passed should be callable your input : ...\\n\\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,1)\\n    -2.8\\n\\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,0)\\n    Traceback (most recent call last):\\n        ...\\n    AssertionError: precision should be positive integer your input : 0\\n\\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,-1)\\n    Traceback (most recent call last):\\n        ...\\n    AssertionError: precision should be positive integer your input : -1\\n\\n    \\\"\\\"\\\"\\n    assert callable(\\n        function\\n    ), f\\\"the function(object) passed should be callable your input : {function}\\\"\\n    assert isinstance(a, float) or isinstance(\\n        a, int\\n    ), f\\\"a should be float or integer your input : {a}\\\"\\n    assert isinstance(function(a), float) or isinstance(function(a), int), (\\n        \\\"the function should return integer or float return type of your function, \\\"\\n        f\\\"{type(a)}\\\"\\n    )\\n    assert isinstance(b, float) or isinstance(\\n        b, int\\n    ), f\\\"b should be float or integer your input : {b}\\\"\\n    assert (\\n        isinstance(precision, int) and precision > 0\\n    ), f\\\"precision should be positive integer your input : {precision}\\\"\\n\\n    # just applying the formula of simpson for approximate integraion written in\\n    # mentioned article in first comment of this file and above this function\\n\\n    h = (b - a) / N_STEPS\\n    result = function(a) + function(b)\\n\\n    for i in range(1, N_STEPS):\\n        a1 = a + h * i\\n        result += function(a1) * (4 if i % 2 else 2)\\n\\n    result *= h / 3\\n    return round(result, precision)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "is ip v4 address valid": "\"\\\"\\\"\\\"\\nIs IP v4 address valid?\\nA valid IP address must be four octets in the form of A.B.C.D,\\nwhere A,B,C and D are numbers from 0-254\\nfor example: 192.168.23.1, 172.254.254.254 are valid IP address\\n             192.168.255.0, 255.192.3.121 are invalid IP address\\n\\\"\\\"\\\"\\n\\n\\ndef is_ip_v4_address_valid(ip_v4_address: str) -> bool:\\n    \\\"\\\"\\\"\\n    print \\\"Valid IP address\\\" If IP is valid.\\n    or\\n    print \\\"Invalid IP address\\\" If IP is invalid.\\n\\n    >>> is_ip_v4_address_valid(\\\"192.168.0.23\\\")\\n    True\\n\\n    >>> is_ip_v4_address_valid(\\\"192.255.15.8\\\")\\n    False\\n\\n    >>> is_ip_v4_address_valid(\\\"172.100.0.8\\\")\\n    True\\n\\n    >>> is_ip_v4_address_valid(\\\"254.255.0.255\\\")\\n    False\\n\\n    >>> is_ip_v4_address_valid(\\\"1.2.33333333.4\\\")\\n    False\\n\\n    >>> is_ip_v4_address_valid(\\\"1.2.-3.4\\\")\\n    False\\n\\n    >>> is_ip_v4_address_valid(\\\"1.2.3\\\")\\n    False\\n\\n    >>> is_ip_v4_address_valid(\\\"1.2.3.4.5\\\")\\n    False\\n\\n    >>> is_ip_v4_address_valid(\\\"1.2.A.4\\\")\\n    False\\n\\n    >>> is_ip_v4_address_valid(\\\"0.0.0.0\\\")\\n    True\\n\\n    >>> is_ip_v4_address_valid(\\\"1.2.3.\\\")\\n    False\\n    \\\"\\\"\\\"\\n    octets = [int(i) for i in ip_v4_address.split(\\\".\\\") if i.isdigit()]\\n    return len(octets) == 4 and all(0 <= int(octet) <= 254 for octet in octets)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    ip = input().strip()\\n    valid_or_invalid = \\\"valid\\\" if is_ip_v4_address_valid(ip) else \\\"invalid\\\"\\n    print(f\\\"{ip} is a {valid_or_invalid} IP v4 address.\\\")\\n\"",
    "is square free": "\"\\\"\\\"\\\"\\r\\nReferences: wikipedia:square free number\\r\\npython/black : True\\r\\nflake8 : True\\r\\n\\\"\\\"\\\"\\r\\nfrom __future__ import annotations\\r\\n\\r\\n\\r\\ndef is_square_free(factors: list[int]) -> bool:\\r\\n    \\\"\\\"\\\"\\r\\n    # doctest: +NORMALIZE_WHITESPACE\\r\\n    This functions takes a list of prime factors as input.\\r\\n    returns True if the factors are square free.\\r\\n    >>> is_square_free([1, 1, 2, 3, 4])\\r\\n    False\\r\\n\\r\\n    These are wrong but should return some value\\r\\n    it simply checks for repition in the numbers.\\r\\n    >>> is_square_free([1, 3, 4, 'sd', 0.0])\\r\\n    True\\r\\n\\r\\n    >>> is_square_free([1, 0.5, 2, 0.0])\\r\\n    True\\r\\n    >>> is_square_free([1, 2, 2, 5])\\r\\n    False\\r\\n    >>> is_square_free('asd')\\r\\n    True\\r\\n    >>> is_square_free(24)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    TypeError: 'int' object is not iterable\\r\\n    \\\"\\\"\\\"\\r\\n    return len(set(factors)) == len(factors)\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "jaccard similarity": "\"\\\"\\\"\\\"\\nThe Jaccard similarity coefficient is a commonly used indicator of the\\nsimilarity between two sets. Let U be a set and A and B be subsets of U,\\nthen the Jaccard index/similarity is defined to be the ratio of the number\\nof elements of their intersection and the number of elements of their union.\\n\\nInspired from Wikipedia and\\nthe book Mining of Massive Datasets [MMDS 2nd Edition, Chapter 3]\\n\\nhttps://en.wikipedia.org/wiki/Jaccard_index\\nhttps://mmds.org\\n\\nJaccard similarity is widely used with MinHashing.\\n\\\"\\\"\\\"\\n\\n\\ndef jaccard_similariy(setA, setB, alternativeUnion=False):\\n    \\\"\\\"\\\"\\n    Finds the jaccard similarity between two sets.\\n    Essentially, its intersection over union.\\n\\n    The alternative way to calculate this is to take union as sum of the\\n    number of items in the two sets. This will lead to jaccard similarity\\n    of a set with itself be 1/2 instead of 1. [MMDS 2nd Edition, Page 77]\\n\\n    Parameters:\\n        :setA (set,list,tuple): A non-empty set/list\\n        :setB (set,list,tuple): A non-empty set/list\\n        :alternativeUnion (boolean): If True, use sum of number of\\n        items as union\\n\\n    Output:\\n        (float) The jaccard similarity between the two sets.\\n\\n    Examples:\\n    >>> setA = {'a', 'b', 'c', 'd', 'e'}\\n    >>> setB = {'c', 'd', 'e', 'f', 'h', 'i'}\\n    >>> jaccard_similariy(setA,setB)\\n    0.375\\n\\n    >>> jaccard_similariy(setA,setA)\\n    1.0\\n\\n    >>> jaccard_similariy(setA,setA,True)\\n    0.5\\n\\n    >>> setA = ['a', 'b', 'c', 'd', 'e']\\n    >>> setB = ('c', 'd', 'e', 'f', 'h', 'i')\\n    >>> jaccard_similariy(setA,setB)\\n    0.375\\n    \\\"\\\"\\\"\\n\\n    if isinstance(setA, set) and isinstance(setB, set):\\n\\n        intersection = len(setA.intersection(setB))\\n\\n        if alternativeUnion:\\n            union = len(setA) + len(setB)\\n        else:\\n            union = len(setA.union(setB))\\n\\n        return intersection / union\\n\\n    if isinstance(setA, (list, tuple)) and isinstance(setB, (list, tuple)):\\n\\n        intersection = [element for element in setA if element in setB]\\n\\n        if alternativeUnion:\\n            union = len(setA) + len(setB)\\n        else:\\n            union = setA + [element for element in setB if element not in setA]\\n\\n        return len(intersection) / len(union)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    setA = {\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\"}\\n    setB = {\\\"c\\\", \\\"d\\\", \\\"e\\\", \\\"f\\\", \\\"h\\\", \\\"i\\\"}\\n    print(jaccard_similariy(setA, setB))\\n\"",
    "kadanes": "\"\\\"\\\"\\\"\\r\\nKadane's algorithm to get maximum subarray sum\\r\\nhttps://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d\\r\\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem\\r\\n\\\"\\\"\\\"\\r\\ntest_data: tuple = ([-2, -8, -9], [2, 8, 9], [-1, 0, 1], [0, 0], [])\\r\\n\\r\\n\\r\\ndef negative_exist(arr: list) -> int:\\r\\n    \\\"\\\"\\\"\\r\\n    >>> negative_exist([-2,-8,-9])\\r\\n    -2\\r\\n    >>> [negative_exist(arr) for arr in test_data]\\r\\n    [-2, 0, 0, 0, 0]\\r\\n    \\\"\\\"\\\"\\r\\n    arr = arr or [0]\\r\\n    max = arr[0]\\r\\n    for i in arr:\\r\\n        if i >= 0:\\r\\n            return 0\\r\\n        elif max <= i:\\r\\n            max = i\\r\\n    return max\\r\\n\\r\\n\\r\\ndef kadanes(arr: list) -> int:\\r\\n    \\\"\\\"\\\"\\r\\n    If negative_exist() returns 0 than this function will execute\\r\\n    else it will return the value return by negative_exist function\\r\\n\\r\\n    For example: arr = [2, 3, -9, 8, -2]\\r\\n        Initially we set value of max_sum to 0 and max_till_element to 0 than when\\r\\n        max_sum is less than max_till particular element it will assign that value to\\r\\n        max_sum and when value of max_till_sum is less than 0 it will assign 0 to i\\r\\n        and after that whole process, return the max_sum\\r\\n    So the output for above arr is 8\\r\\n\\r\\n    >>> kadanes([2, 3, -9, 8, -2])\\r\\n    8\\r\\n    >>> [kadanes(arr) for arr in test_data]\\r\\n    [-2, 19, 1, 0, 0]\\r\\n    \\\"\\\"\\\"\\r\\n    max_sum = negative_exist(arr)\\r\\n    if max_sum < 0:\\r\\n        return max_sum\\r\\n\\r\\n    max_sum = 0\\r\\n    max_till_element = 0\\r\\n\\r\\n    for i in arr:\\r\\n        max_till_element += i\\r\\n        if max_sum <= max_till_element:\\r\\n            max_sum = max_till_element\\r\\n        if max_till_element < 0:\\r\\n            max_till_element = 0\\r\\n    return max_sum\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    try:\\r\\n        print(\\\"Enter integer values sepatated by spaces\\\")\\r\\n        arr = [int(x) for x in input().split()]\\r\\n        print(f\\\"Maximum subarray sum of {arr} is {kadanes(arr)}\\\")\\r\\n    except ValueError:\\r\\n        print(\\\"Please enter integer values.\\\")\\r\\n\"",
    "karatsuba": "\"\\\"\\\"\\\" Multiply two numbers using Karatsuba algorithm \\\"\\\"\\\"\\n\\n\\ndef karatsuba(a, b):\\n    \\\"\\\"\\\"\\n    >>> karatsuba(15463, 23489) == 15463 * 23489\\n    True\\n    >>> karatsuba(3, 9) == 3 * 9\\n    True\\n    \\\"\\\"\\\"\\n    if len(str(a)) == 1 or len(str(b)) == 1:\\n        return a * b\\n    else:\\n        m1 = max(len(str(a)), len(str(b)))\\n        m2 = m1 // 2\\n\\n        a1, a2 = divmod(a, 10 ** m2)\\n        b1, b2 = divmod(b, 10 ** m2)\\n\\n        x = karatsuba(a2, b2)\\n        y = karatsuba((a1 + a2), (b1 + b2))\\n        z = karatsuba(a1, b1)\\n\\n        return (z * 10 ** (2 * m2)) + ((y - z - x) * 10 ** (m2)) + (x)\\n\\n\\ndef main():\\n    print(karatsuba(15463, 23489))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "krishnamurthy number": "\"\\\"\\\"\\\"\\n == Krishnamurthy Number ==\\nIt is also known as Peterson Number\\nA Krishnamurthy Number is a number whose sum of the\\nfactorial of the digits equals to the original\\nnumber itself.\\n\\nFor example: 145 = 1! + 4! + 5!\\n    So, 145 is a Krishnamurthy Number\\n\\\"\\\"\\\"\\n\\n\\ndef factorial(digit: int) -> int:\\n    \\\"\\\"\\\"\\n    >>> factorial(3)\\n    6\\n    >>> factorial(0)\\n    1\\n    >>> factorial(5)\\n    120\\n    \\\"\\\"\\\"\\n\\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))\\n\\n\\ndef krishnamurthy(number: int) -> bool:\\n    \\\"\\\"\\\"\\n    >>> krishnamurthy(145)\\n    True\\n    >>> krishnamurthy(240)\\n    False\\n    >>> krishnamurthy(1)\\n    True\\n    \\\"\\\"\\\"\\n\\n    factSum = 0\\n    duplicate = number\\n    while duplicate > 0:\\n        duplicate, digit = divmod(duplicate, 10)\\n        factSum += factorial(digit)\\n    return factSum == number\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"Program to check whether a number is a Krisnamurthy Number or not.\\\")\\n    number = int(input(\\\"Enter number: \\\").strip())\\n    print(\\n        f\\\"{number} is {'' if krishnamurthy(number) else 'not '}a Krishnamurthy Number.\\\"\\n    )\\n\"",
    "kth lexicographic permutation": "\"def kthPermutation(k, n):\\r\\n    \\\"\\\"\\\"\\r\\n    Finds k'th lexicographic permutation (in increasing order) of\\r\\n    0,1,2,...n-1 in O(n^2) time.\\r\\n\\r\\n    Examples:\\r\\n    First permutation is always 0,1,2,...n\\r\\n    >>> kthPermutation(0,5)\\r\\n    [0, 1, 2, 3, 4]\\r\\n\\r\\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\\r\\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\\r\\n    [1,2,3,0], [1,3,0,2]\\r\\n    >>> kthPermutation(10,4)\\r\\n    [1, 3, 0, 2]\\r\\n    \\\"\\\"\\\"\\r\\n    # Factorails from 1! to (n-1)!\\r\\n    factorials = [1]\\r\\n    for i in range(2, n):\\r\\n        factorials.append(factorials[-1] * i)\\r\\n    assert 0 <= k < factorials[-1] * n, \\\"k out of bounds\\\"\\r\\n\\r\\n    permutation = []\\r\\n    elements = list(range(n))\\r\\n\\r\\n    # Find permutation\\r\\n    while factorials:\\r\\n        factorial = factorials.pop()\\r\\n        number, k = divmod(k, factorial)\\r\\n        permutation.append(elements[number])\\r\\n        elements.remove(elements[number])\\r\\n    permutation.append(elements[0])\\r\\n\\r\\n    return permutation\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "largest of very large numbers": "\"# Author: Abhijeeth S\\n\\nimport math\\n\\n\\ndef res(x, y):\\n    if 0 not in (x, y):\\n        # We use the relation x^y = y*log10(x), where 10 is the base.\\n        return y * math.log10(x)\\n    else:\\n        if x == 0:  # 0 raised to any number is 0\\n            return 0\\n        elif y == 0:\\n            return 1  # any number raised to 0 is 1\\n\\n\\nif __name__ == \\\"__main__\\\":  # Main function\\n    # Read two numbers from input and typecast them to int using map function.\\n    # Here x is the base and y is the power.\\n    prompt = \\\"Enter the base and the power separated by a comma: \\\"\\n    x1, y1 = map(int, input(prompt).split(\\\",\\\"))\\n    x2, y2 = map(int, input(prompt).split(\\\",\\\"))\\n\\n    # We find the log of each number, using the function res(), which takes two\\n    # arguments.\\n    res1 = res(x1, y1)\\n    res2 = res(x2, y2)\\n\\n    # We check for the largest number\\n    if res1 > res2:\\n        print(\\\"Largest number is\\\", x1, \\\"^\\\", y1)\\n    elif res2 > res1:\\n        print(\\\"Largest number is\\\", x2, \\\"^\\\", y2)\\n    else:\\n        print(\\\"Both are equal\\\")\\n\"",
    "largest subarray sum": "\"from sys import maxsize\\n\\n\\ndef max_sub_array_sum(a: list, size: int = 0):\\n    \\\"\\\"\\\"\\n    >>> max_sub_array_sum([-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7])\\n    -3\\n    \\\"\\\"\\\"\\n    size = size or len(a)\\n    max_so_far = -maxsize - 1\\n    max_ending_here = 0\\n    for i in range(0, size):\\n        max_ending_here = max_ending_here + a[i]\\n        if max_so_far < max_ending_here:\\n            max_so_far = max_ending_here\\n        if max_ending_here < 0:\\n            max_ending_here = 0\\n    return max_so_far\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    a = [-13, -3, -25, -20, 1, -16, -23, -12, -5, -22, -15, -4, -7]\\n    print((\\\"Maximum contiguous sum is\\\", max_sub_array_sum(a, len(a))))\\n\"",
    "least common multiple": "\"import unittest\\nfrom timeit import timeit\\n\\n\\ndef least_common_multiple_slow(first_num: int, second_num: int) -> int:\\n    \\\"\\\"\\\"\\n    Find the least common multiple of two numbers.\\n\\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\\n\\n    >>> least_common_multiple_slow(5, 2)\\n    10\\n    >>> least_common_multiple_slow(12, 76)\\n    228\\n    \\\"\\\"\\\"\\n    max_num = first_num if first_num >= second_num else second_num\\n    common_mult = max_num\\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\\n        common_mult += max_num\\n    return common_mult\\n\\n\\ndef greatest_common_divisor(a: int, b: int) -> int:\\n    \\\"\\\"\\\"\\n    Calculate Greatest Common Divisor (GCD).\\n    see greatest_common_divisor.py\\n    >>> greatest_common_divisor(24, 40)\\n    8\\n    >>> greatest_common_divisor(1, 1)\\n    1\\n    >>> greatest_common_divisor(1, 800)\\n    1\\n    >>> greatest_common_divisor(11, 37)\\n    1\\n    >>> greatest_common_divisor(3, 5)\\n    1\\n    >>> greatest_common_divisor(16, 4)\\n    4\\n    \\\"\\\"\\\"\\n    return b if a == 0 else greatest_common_divisor(b % a, a)\\n\\n\\ndef least_common_multiple_fast(first_num: int, second_num: int) -> int:\\n    \\\"\\\"\\\"\\n    Find the least common multiple of two numbers.\\n    https://en.wikipedia.org/wiki/Least_common_multiple#Using_the_greatest_common_divisor\\n    >>> least_common_multiple_fast(5,2)\\n    10\\n    >>> least_common_multiple_fast(12,76)\\n    228\\n    \\\"\\\"\\\"\\n    return first_num // greatest_common_divisor(first_num, second_num) * second_num\\n\\n\\ndef benchmark():\\n    setup = (\\n        \\\"from __main__ import least_common_multiple_slow, least_common_multiple_fast\\\"\\n    )\\n    print(\\n        \\\"least_common_multiple_slow():\\\",\\n        timeit(\\\"least_common_multiple_slow(1000, 999)\\\", setup=setup),\\n    )\\n    print(\\n        \\\"least_common_multiple_fast():\\\",\\n        timeit(\\\"least_common_multiple_fast(1000, 999)\\\", setup=setup),\\n    )\\n\\n\\nclass TestLeastCommonMultiple(unittest.TestCase):\\n\\n    test_inputs = [\\n        (10, 20),\\n        (13, 15),\\n        (4, 31),\\n        (10, 42),\\n        (43, 34),\\n        (5, 12),\\n        (12, 25),\\n        (10, 25),\\n        (6, 9),\\n    ]\\n    expected_results = [20, 195, 124, 210, 1462, 60, 300, 50, 18]\\n\\n    def test_lcm_function(self):\\n        for i, (first_num, second_num) in enumerate(self.test_inputs):\\n            slow_result = least_common_multiple_slow(first_num, second_num)\\n            fast_result = least_common_multiple_fast(first_num, second_num)\\n            with self.subTest(i=i):\\n                self.assertEqual(slow_result, self.expected_results[i])\\n                self.assertEqual(fast_result, self.expected_results[i])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    benchmark()\\n    unittest.main()\\n\"",
    "line length": "\"from __future__ import annotations\\n\\nimport math\\nfrom typing import Callable\\n\\n\\ndef line_length(\\n    fnc: Callable[[int | float], int | float],\\n    x_start: int | float,\\n    x_end: int | float,\\n    steps: int = 100,\\n) -> float:\\n\\n    \\\"\\\"\\\"\\n    Approximates the arc length of a line segment by treating the curve as a\\n    sequence of linear lines and summing their lengths\\n    :param fnc: a function which defines a curve\\n    :param x_start: left end point to indicate the start of line segment\\n    :param x_end: right end point to indicate end of line segment\\n    :param steps: an accuracy gauge; more steps increases accuracy\\n    :return: a float representing the length of the curve\\n\\n    >>> def f(x):\\n    ...    return x\\n    >>> f\\\"{line_length(f, 0, 1, 10):.6f}\\\"\\n    '1.414214'\\n\\n    >>> def f(x):\\n    ...    return 1\\n    >>> f\\\"{line_length(f, -5.5, 4.5):.6f}\\\"\\n    '10.000000'\\n\\n    >>> def f(x):\\n    ...    return math.sin(5 * x) + math.cos(10 * x) + x * x/10\\n    >>> f\\\"{line_length(f, 0.0, 10.0, 10000):.6f}\\\"\\n    '69.534930'\\n    \\\"\\\"\\\"\\n\\n    x1 = x_start\\n    fx1 = fnc(x_start)\\n    length = 0.0\\n\\n    for i in range(steps):\\n\\n        # Approximates curve as a sequence of linear lines and sums their length\\n        x2 = (x_end - x_start) / steps + x1\\n        fx2 = fnc(x2)\\n        length += math.hypot(x2 - x1, fx2 - fx1)\\n\\n        # Increment step\\n        x1 = x2\\n        fx1 = fx2\\n\\n    return length\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    def f(x):\\n        return math.sin(10 * x)\\n\\n    print(\\\"f(x) = sin(10 * x)\\\")\\n    print(\\\"The length of the curve from x = -10 to x = 10 is:\\\")\\n    i = 10\\n    while i <= 100000:\\n        print(f\\\"With {i} steps: {line_length(f, -10, 10, i)}\\\")\\n        i *= 10\\n\"",
    "lucas lehmer primality test": "\"\\\"\\\"\\\"\\n        In mathematics, the Lucas–Lehmer test (LLT) is a primality test for Mersenne\\n        numbers.  https://en.wikipedia.org/wiki/Lucas%E2%80%93Lehmer_primality_test\\n\\n        A Mersenne number is a number that is one less than a power of two.\\n        That is M_p = 2^p - 1\\n        https://en.wikipedia.org/wiki/Mersenne_prime\\n\\n        The Lucas–Lehmer test is the primality test used by the\\n        Great Internet Mersenne Prime Search (GIMPS) to locate large primes.\\n\\\"\\\"\\\"\\n\\n\\n# Primality test 2^p - 1\\n# Return true if 2^p - 1 is prime\\ndef lucas_lehmer_test(p: int) -> bool:\\n    \\\"\\\"\\\"\\n    >>> lucas_lehmer_test(p=7)\\n    True\\n\\n    >>> lucas_lehmer_test(p=11)\\n    False\\n\\n    # M_11 = 2^11 - 1 = 2047 = 23 * 89\\n    \\\"\\\"\\\"\\n\\n    if p < 2:\\n        raise ValueError(\\\"p should not be less than 2!\\\")\\n    elif p == 2:\\n        return True\\n\\n    s = 4\\n    M = (1 << p) - 1\\n    for i in range(p - 2):\\n        s = ((s * s) - 2) % M\\n    return s == 0\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(lucas_lehmer_test(7))\\n    print(lucas_lehmer_test(11))\\n\"",
    "lucas series": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Lucas_number\\n\\\"\\\"\\\"\\n\\n\\ndef recursive_lucas_number(n_th_number: int) -> int:\\n    \\\"\\\"\\\"\\n    Returns the nth lucas number\\n    >>> recursive_lucas_number(1)\\n    1\\n    >>> recursive_lucas_number(20)\\n    15127\\n    >>> recursive_lucas_number(0)\\n    2\\n    >>> recursive_lucas_number(25)\\n    167761\\n    >>> recursive_lucas_number(-1.5)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: recursive_lucas_number accepts only integer arguments.\\n    \\\"\\\"\\\"\\n    if not isinstance(n_th_number, int):\\n        raise TypeError(\\\"recursive_lucas_number accepts only integer arguments.\\\")\\n    if n_th_number == 0:\\n        return 2\\n    if n_th_number == 1:\\n        return 1\\n\\n    return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(\\n        n_th_number - 2\\n    )\\n\\n\\ndef dynamic_lucas_number(n_th_number: int) -> int:\\n    \\\"\\\"\\\"\\n    Returns the nth lucas number\\n    >>> dynamic_lucas_number(1)\\n    1\\n    >>> dynamic_lucas_number(20)\\n    15127\\n    >>> dynamic_lucas_number(0)\\n    2\\n    >>> dynamic_lucas_number(25)\\n    167761\\n    >>> dynamic_lucas_number(-1.5)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: dynamic_lucas_number accepts only integer arguments.\\n    \\\"\\\"\\\"\\n    if not isinstance(n_th_number, int):\\n        raise TypeError(\\\"dynamic_lucas_number accepts only integer arguments.\\\")\\n    a, b = 2, 1\\n    for i in range(n_th_number):\\n        a, b = b, a + b\\n    return a\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n    n = int(input(\\\"Enter the number of terms in lucas series:\\\\n\\\").strip())\\n    print(\\\"Using recursive function to calculate lucas series:\\\")\\n    print(\\\" \\\".join(str(recursive_lucas_number(i)) for i in range(n)))\\n    print(\\\"\\\\nUsing dynamic function to calculate lucas series:\\\")\\n    print(\\\" \\\".join(str(dynamic_lucas_number(i)) for i in range(n)))\\n\"",
    "matrix exponentiation": "\"\\\"\\\"\\\"Matrix Exponentiation\\\"\\\"\\\"\\n\\nimport timeit\\n\\n\\\"\\\"\\\"\\nMatrix Exponentiation is a technique to solve linear recurrences in logarithmic time.\\nYou read more about it here:\\nhttp://zobayer.blogspot.com/2010/11/matrix-exponentiation.html\\nhttps://www.hackerearth.com/practice/notes/matrix-exponentiation-1/\\n\\\"\\\"\\\"\\n\\n\\nclass Matrix:\\n    def __init__(self, arg):\\n        if isinstance(arg, list):  # Initializes a matrix identical to the one provided.\\n            self.t = arg\\n            self.n = len(arg)\\n        else:  # Initializes a square matrix of the given size and set values to zero.\\n            self.n = arg\\n            self.t = [[0 for _ in range(self.n)] for _ in range(self.n)]\\n\\n    def __mul__(self, b):\\n        matrix = Matrix(self.n)\\n        for i in range(self.n):\\n            for j in range(self.n):\\n                for k in range(self.n):\\n                    matrix.t[i][j] += self.t[i][k] * b.t[k][j]\\n        return matrix\\n\\n\\ndef modular_exponentiation(a, b):\\n    matrix = Matrix([[1, 0], [0, 1]])\\n    while b > 0:\\n        if b & 1:\\n            matrix *= a\\n        a *= a\\n        b >>= 1\\n    return matrix\\n\\n\\ndef fibonacci_with_matrix_exponentiation(n, f1, f2):\\n    # Trivial Cases\\n    if n == 1:\\n        return f1\\n    elif n == 2:\\n        return f2\\n    matrix = Matrix([[1, 1], [1, 0]])\\n    matrix = modular_exponentiation(matrix, n - 2)\\n    return f2 * matrix.t[0][0] + f1 * matrix.t[0][1]\\n\\n\\ndef simple_fibonacci(n, f1, f2):\\n    # Trivial Cases\\n    if n == 1:\\n        return f1\\n    elif n == 2:\\n        return f2\\n\\n    fn_1 = f1\\n    fn_2 = f2\\n    n -= 2\\n\\n    while n > 0:\\n        fn_1, fn_2 = fn_1 + fn_2, fn_1\\n        n -= 1\\n\\n    return fn_1\\n\\n\\ndef matrix_exponentiation_time():\\n    setup = \\\"\\\"\\\"\\nfrom random import randint\\nfrom __main__ import fibonacci_with_matrix_exponentiation\\n\\\"\\\"\\\"\\n    code = \\\"fibonacci_with_matrix_exponentiation(randint(1,70000), 1, 1)\\\"\\n    exec_time = timeit.timeit(setup=setup, stmt=code, number=100)\\n    print(\\\"With matrix exponentiation the average execution time is \\\", exec_time / 100)\\n    return exec_time\\n\\n\\ndef simple_fibonacci_time():\\n    setup = \\\"\\\"\\\"\\nfrom random import randint\\nfrom __main__ import simple_fibonacci\\n\\\"\\\"\\\"\\n    code = \\\"simple_fibonacci(randint(1,70000), 1, 1)\\\"\\n    exec_time = timeit.timeit(setup=setup, stmt=code, number=100)\\n    print(\\n        \\\"Without matrix exponentiation the average execution time is \\\", exec_time / 100\\n    )\\n    return exec_time\\n\\n\\ndef main():\\n    matrix_exponentiation_time()\\n    simple_fibonacci_time()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "max sum sliding window": "\"\\\"\\\"\\\"\\nGiven an array of integer elements and an integer 'k', we are required to find the\\nmaximum sum of 'k' consecutive elements in the array.\\n\\nInstead of using a nested for loop, in a Brute force approach we will use a technique\\ncalled 'Window sliding technique' where the nested loops can be converted to a single\\nloop to reduce time complexity.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef max_sum_in_array(array: list[int], k: int) -> int:\\n    \\\"\\\"\\\"\\n    Returns the maximum sum of k consecutive elements\\n    >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]\\n    >>> k = 4\\n    >>> max_sum_in_array(arr, k)\\n    24\\n    >>> k = 10\\n    >>> max_sum_in_array(arr,k)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Invalid Input\\n    >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]\\n    >>> k = 4\\n    >>> max_sum_in_array(arr, k)\\n    27\\n    \\\"\\\"\\\"\\n    if len(array) < k or k < 0:\\n        raise ValueError(\\\"Invalid Input\\\")\\n    max_sum = current_sum = sum(array[:k])\\n    for i in range(len(array) - k):\\n        current_sum = current_sum - array[i] + array[i + k]\\n        max_sum = max(max_sum, current_sum)\\n    return max_sum\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n    from random import randint\\n\\n    testmod()\\n    array = [randint(-1000, 1000) for i in range(100)]\\n    k = randint(0, 110)\\n    print(f\\\"The maximum sum of {k} consecutive elements is {max_sum_in_array(array,k)}\\\")\\n\"",
    "median of two arrays": "\"from __future__ import annotations\\n\\n\\ndef median_of_two_arrays(nums1: list[float], nums2: list[float]) -> float:\\n    \\\"\\\"\\\"\\n    >>> median_of_two_arrays([1, 2], [3])\\n    2\\n    >>> median_of_two_arrays([0, -1.1], [2.5, 1])\\n    0.5\\n    >>> median_of_two_arrays([], [2.5, 1])\\n    1.75\\n    >>> median_of_two_arrays([], [0])\\n    0\\n    >>> median_of_two_arrays([], [])\\n    Traceback (most recent call last):\\n      ...\\n    IndexError: list index out of range\\n    \\\"\\\"\\\"\\n    all_numbers = sorted(nums1 + nums2)\\n    div, mod = divmod(len(all_numbers), 2)\\n    if mod == 1:\\n        return all_numbers[div]\\n    else:\\n        return (all_numbers[div] + all_numbers[div - 1]) / 2\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    array_1 = [float(x) for x in input(\\\"Enter the elements of first array: \\\").split()]\\n    array_2 = [float(x) for x in input(\\\"Enter the elements of second array: \\\").split()]\\n    print(f\\\"The median of two arrays is: {median_of_two_arrays(array_1, array_2)}\\\")\\n\"",
    "miller rabin": "\"import random\\n\\nfrom .binary_exp_mod import bin_exp_mod\\n\\n\\n# This is a probabilistic check to test primality, useful for big numbers!\\n# if it's a prime, it will return true\\n# if it's not a prime, the chance of it returning true is at most 1/4**prec\\ndef is_prime(n, prec=1000):\\n    \\\"\\\"\\\"\\n    >>> from .prime_check import prime_check\\n    >>> # all(is_prime(i) == prime_check(i) for i in range(1000))  # 3.45s\\n    >>> all(is_prime(i) == prime_check(i) for i in range(256))\\n    True\\n    \\\"\\\"\\\"\\n    if n < 2:\\n        return False\\n\\n    if n % 2 == 0:\\n        return n == 2\\n\\n    # this means n is odd\\n    d = n - 1\\n    exp = 0\\n    while d % 2 == 0:\\n        d /= 2\\n        exp += 1\\n\\n    # n - 1=d*(2**exp)\\n    count = 0\\n    while count < prec:\\n        a = random.randint(2, n - 1)\\n        b = bin_exp_mod(a, d, n)\\n        if b != 1:\\n            flag = True\\n            for i in range(exp):\\n                if b == n - 1:\\n                    flag = False\\n                    break\\n                b = b * b\\n                b %= n\\n            if flag:\\n                return False\\n            count += 1\\n    return True\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    n = abs(int(input(\\\"Enter bound : \\\").strip()))\\n    print(\\\"Here's the list of primes:\\\")\\n    print(\\\", \\\".join(str(i) for i in range(n + 1) if is_prime(i)))\\n\"",
    "mobius function": "\"\\\"\\\"\\\"\\r\\nReferences: https://en.wikipedia.org/wiki/M%C3%B6bius_function\\r\\nReferences: wikipedia:square free number\\r\\npython/black : True\\r\\nflake8 : True\\r\\n\\\"\\\"\\\"\\r\\n\\r\\nfrom maths.is_square_free import is_square_free\\r\\nfrom maths.prime_factors import prime_factors\\r\\n\\r\\n\\r\\ndef mobius(n: int) -> int:\\r\\n    \\\"\\\"\\\"\\r\\n    Mobius function\\r\\n    >>> mobius(24)\\r\\n    0\\r\\n    >>> mobius(-1)\\r\\n    1\\r\\n    >>> mobius('asd')\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    TypeError: '<=' not supported between instances of 'int' and 'str'\\r\\n    >>> mobius(10**400)\\r\\n    0\\r\\n    >>> mobius(10**-400)\\r\\n    1\\r\\n    >>> mobius(-1424)\\r\\n    1\\r\\n    >>> mobius([1, '2', 2.0])\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    TypeError: '<=' not supported between instances of 'int' and 'list'\\r\\n    \\\"\\\"\\\"\\r\\n    factors = prime_factors(n)\\r\\n    if is_square_free(factors):\\r\\n        return -1 if len(factors) % 2 else 1\\r\\n    return 0\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "modular exponential": "\"\\\"\\\"\\\"\\n    Modular Exponential.\\n    Modular exponentiation is a type of exponentiation performed over a modulus.\\n    For more explanation, please check\\n    https://en.wikipedia.org/wiki/Modular_exponentiation\\n\\\"\\\"\\\"\\n\\n\\\"\\\"\\\"Calculate Modular Exponential.\\\"\\\"\\\"\\n\\n\\ndef modular_exponential(base: int, power: int, mod: int):\\n    \\\"\\\"\\\"\\n    >>> modular_exponential(5, 0, 10)\\n    1\\n    >>> modular_exponential(2, 8, 7)\\n    4\\n    >>> modular_exponential(3, -2, 9)\\n    -1\\n    \\\"\\\"\\\"\\n\\n    if power < 0:\\n        return -1\\n    base %= mod\\n    result = 1\\n\\n    while power > 0:\\n        if power & 1:\\n            result = (result * base) % mod\\n        power = power >> 1\\n        base = (base * base) % mod\\n\\n    return result\\n\\n\\ndef main():\\n    \\\"\\\"\\\"Call Modular Exponential Function.\\\"\\\"\\\"\\n    print(modular_exponential(3, 200, 13))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    main()\\n\"",
    "monte carlo": "\"\\\"\\\"\\\"\\n@author: MatteoRaso\\n\\\"\\\"\\\"\\nfrom math import pi, sqrt\\nfrom random import uniform\\nfrom statistics import mean\\nfrom typing import Callable\\n\\n\\ndef pi_estimator(iterations: int):\\n    \\\"\\\"\\\"\\n    An implementation of the Monte Carlo method used to find pi.\\n    1. Draw a 2x2 square centred at (0,0).\\n    2. Inscribe a circle within the square.\\n    3. For each iteration, place a dot anywhere in the square.\\n       a. Record the number of dots within the circle.\\n    4. After all the dots are placed, divide the dots in the circle by the total.\\n    5. Multiply this value by 4 to get your estimate of pi.\\n    6. Print the estimated and numpy value of pi\\n    \\\"\\\"\\\"\\n    # A local function to see if a dot lands in the circle.\\n    def is_in_circle(x: float, y: float) -> bool:\\n        distance_from_centre = sqrt((x ** 2) + (y ** 2))\\n        # Our circle has a radius of 1, so a distance\\n        # greater than 1 would land outside the circle.\\n        return distance_from_centre <= 1\\n\\n    # The proportion of guesses that landed in the circle\\n    proportion = mean(\\n        int(is_in_circle(uniform(-1.0, 1.0), uniform(-1.0, 1.0)))\\n        for _ in range(iterations)\\n    )\\n    # The ratio of the area for circle to square is pi/4.\\n    pi_estimate = proportion * 4\\n    print(f\\\"The estimated value of pi is {pi_estimate}\\\")\\n    print(f\\\"The numpy value of pi is {pi}\\\")\\n    print(f\\\"The total error is {abs(pi - pi_estimate)}\\\")\\n\\n\\ndef area_under_curve_estimator(\\n    iterations: int,\\n    function_to_integrate: Callable[[float], float],\\n    min_value: float = 0.0,\\n    max_value: float = 1.0,\\n) -> float:\\n    \\\"\\\"\\\"\\n    An implementation of the Monte Carlo method to find area under\\n       a single variable non-negative real-valued continuous function,\\n       say f(x), where x lies within a continuous bounded interval,\\n       say [min_value, max_value], where min_value and max_value are\\n       finite numbers\\n    1. Let x be a uniformly distributed random variable between min_value to\\n       max_value\\n    2. Expected value of f(x) =\\n       (integrate f(x) from min_value to max_value)/(max_value - min_value)\\n    3. Finding expected value of f(x):\\n        a. Repeatedly draw x from uniform distribution\\n        b. Evaluate f(x) at each of the drawn x values\\n        c. Expected value = average of the function evaluations\\n    4. Estimated value of integral = Expected value * (max_value - min_value)\\n    5. Returns estimated value\\n    \\\"\\\"\\\"\\n\\n    return mean(\\n        function_to_integrate(uniform(min_value, max_value)) for _ in range(iterations)\\n    ) * (max_value - min_value)\\n\\n\\ndef area_under_line_estimator_check(\\n    iterations: int, min_value: float = 0.0, max_value: float = 1.0\\n) -> None:\\n    \\\"\\\"\\\"\\n    Checks estimation error for area_under_curve_estimator function\\n    for f(x) = x where x lies within min_value to max_value\\n    1. Calls \\\"area_under_curve_estimator\\\" function\\n    2. Compares with the expected value\\n    3. Prints estimated, expected and error value\\n    \\\"\\\"\\\"\\n\\n    def identity_function(x: float) -> float:\\n        \\\"\\\"\\\"\\n        Represents identity function\\n        >>> [function_to_integrate(x) for x in [-2.0, -1.0, 0.0, 1.0, 2.0]]\\n        [-2.0, -1.0, 0.0, 1.0, 2.0]\\n        \\\"\\\"\\\"\\n        return x\\n\\n    estimated_value = area_under_curve_estimator(\\n        iterations, identity_function, min_value, max_value\\n    )\\n    expected_value = (max_value * max_value - min_value * min_value) / 2\\n\\n    print(\\\"******************\\\")\\n    print(f\\\"Estimating area under y=x where x varies from {min_value} to {max_value}\\\")\\n    print(f\\\"Estimated value is {estimated_value}\\\")\\n    print(f\\\"Expected value is {expected_value}\\\")\\n    print(f\\\"Total error is {abs(estimated_value - expected_value)}\\\")\\n    print(\\\"******************\\\")\\n\\n\\ndef pi_estimator_using_area_under_curve(iterations: int) -> None:\\n    \\\"\\\"\\\"\\n    Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi\\n    \\\"\\\"\\\"\\n\\n    def function_to_integrate(x: float) -> float:\\n        \\\"\\\"\\\"\\n        Represents semi-circle with radius 2\\n        >>> [function_to_integrate(x) for x in [-2.0, 0.0, 2.0]]\\n        [0.0, 2.0, 0.0]\\n        \\\"\\\"\\\"\\n        return sqrt(4.0 - x * x)\\n\\n    estimated_value = area_under_curve_estimator(\\n        iterations, function_to_integrate, 0.0, 2.0\\n    )\\n\\n    print(\\\"******************\\\")\\n    print(\\\"Estimating pi using area_under_curve_estimator\\\")\\n    print(f\\\"Estimated value is {estimated_value}\\\")\\n    print(f\\\"Expected value is {pi}\\\")\\n    print(f\\\"Total error is {abs(estimated_value - pi)}\\\")\\n    print(\\\"******************\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "monte carlo dice": "\"from __future__ import annotations\\n\\nimport random\\n\\n\\nclass Dice:\\n    NUM_SIDES = 6\\n\\n    def __init__(self):\\n        \\\"\\\"\\\"Initialize a six sided dice\\\"\\\"\\\"\\n        self.sides = list(range(1, Dice.NUM_SIDES + 1))\\n\\n    def roll(self):\\n        return random.choice(self.sides)\\n\\n    def _str_(self):\\n        return \\\"Fair Dice\\\"\\n\\n\\ndef throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:\\n    \\\"\\\"\\\"\\n    Return probability list of all possible sums when throwing dice.\\n\\n    >>> random.seed(0)\\n    >>> throw_dice(10, 1)\\n    [10.0, 0.0, 30.0, 50.0, 10.0, 0.0]\\n    >>> throw_dice(100, 1)\\n    [19.0, 17.0, 17.0, 11.0, 23.0, 13.0]\\n    >>> throw_dice(1000, 1)\\n    [18.8, 15.5, 16.3, 17.6, 14.2, 17.6]\\n    >>> throw_dice(10000, 1)\\n    [16.35, 16.89, 16.93, 16.6, 16.52, 16.71]\\n    >>> throw_dice(10000, 2)\\n    [2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]\\n    \\\"\\\"\\\"\\n    dices = [Dice() for i in range(num_dice)]\\n    count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)\\n    for i in range(num_throws):\\n        count_of_sum[sum(dice.roll() for dice in dices)] += 1\\n    probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]\\n    return probability[num_dice:]  # remove probability of sums that never appear\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "nevilles method": "\"\\\"\\\"\\\"\\n    Python program to show how to interpolate and evaluate a polynomial\\n    using Neville's method.\\n    Neville’s method evaluates a polynomial that passes through a\\n    given set of x and y points for a particular x value (x0) using the\\n    Newton polynomial form.\\n    Reference:\\n        https://rpubs.com/aaronsc32/nevilles-method-polynomial-interpolation\\n\\\"\\\"\\\"\\n\\n\\ndef neville_interpolate(x_points: list, y_points: list, x0: int) -> list:\\n    \\\"\\\"\\\"\\n       Interpolate and evaluate a polynomial using Neville's method.\\n       Arguments:\\n           x_points, y_points: Iterables of x and corresponding y points through\\n            which the polynomial passes.\\n           x0: The value of x to evaluate the polynomial for.\\n       Return Value: A list of the approximated value and the Neville iterations\\n           table respectively.\\n    >>> import pprint\\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 5)[0]\\n    10.0\\n    >>> pprint.pprint(neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[1])\\n    [[0, 6, 0, 0, 0],\\n     [0, 7, 0, 0, 0],\\n     [0, 8, 104.0, 0, 0],\\n     [0, 9, 104.0, 104.0, 0],\\n     [0, 11, 104.0, 104.0, 104.0]]\\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[0]\\n    104.0\\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), '')\\n    Traceback (most recent call last):\\n      File \\\"<stdin>\\\", line 1, in <module>\\n      ...\\n    TypeError: unsupported operand type(s) for -: 'str' and 'int'\\n    \\\"\\\"\\\"\\n    n = len(x_points)\\n    q = [[0] * n for i in range(n)]\\n    for i in range(n):\\n        q[i][1] = y_points[i]\\n\\n    for i in range(2, n):\\n        for j in range(i, n):\\n            q[j][i] = (\\n                (x0 - x_points[j - i + 1]) * q[j][i - 1]\\n                - (x0 - x_points[j]) * q[j - 1][i - 1]\\n            ) / (x_points[j] - x_points[j - i + 1])\\n\\n    return [q[n - 1][n - 1], q]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "number of digits": "\"import math\\nfrom timeit import timeit\\n\\n\\ndef num_digits(n: int) -> int:\\n    \\\"\\\"\\\"\\n    Find the number of digits in a number.\\n\\n    >>> num_digits(12345)\\n    5\\n    >>> num_digits(123)\\n    3\\n    >>> num_digits(0)\\n    1\\n    >>> num_digits(-1)\\n    1\\n    >>> num_digits(-123456)\\n    6\\n    \\\"\\\"\\\"\\n    digits = 0\\n    n = abs(n)\\n    while True:\\n        n = n // 10\\n        digits += 1\\n        if n == 0:\\n            break\\n    return digits\\n\\n\\ndef num_digits_fast(n: int) -> int:\\n    \\\"\\\"\\\"\\n    Find the number of digits in a number.\\n    abs() is used as logarithm for negative numbers is not defined.\\n\\n    >>> num_digits_fast(12345)\\n    5\\n    >>> num_digits_fast(123)\\n    3\\n    >>> num_digits_fast(0)\\n    1\\n    >>> num_digits_fast(-1)\\n    1\\n    >>> num_digits_fast(-123456)\\n    6\\n    \\\"\\\"\\\"\\n    return 1 if n == 0 else math.floor(math.log(abs(n), 10) + 1)\\n\\n\\ndef num_digits_faster(n: int) -> int:\\n    \\\"\\\"\\\"\\n    Find the number of digits in a number.\\n    abs() is used for negative numbers\\n\\n    >>> num_digits_faster(12345)\\n    5\\n    >>> num_digits_faster(123)\\n    3\\n    >>> num_digits_faster(0)\\n    1\\n    >>> num_digits_faster(-1)\\n    1\\n    >>> num_digits_faster(-123456)\\n    6\\n    \\\"\\\"\\\"\\n    return len(str(abs(n)))\\n\\n\\ndef benchmark() -> None:\\n    \\\"\\\"\\\"\\n    Benchmark code for comparing 3 functions,\\n    with 3 different length int values.\\n    \\\"\\\"\\\"\\n    print(\\\"\\\\nFor small_num = \\\", small_num, \\\":\\\")\\n    print(\\n        \\\"> num_digits()\\\",\\n        \\\"\\\\t\\\\tans =\\\",\\n        num_digits(small_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.num_digits(z.small_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> num_digits_fast()\\\",\\n        \\\"\\\\tans =\\\",\\n        num_digits_fast(small_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.num_digits_fast(z.small_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> num_digits_faster()\\\",\\n        \\\"\\\\tans =\\\",\\n        num_digits_faster(small_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.num_digits_faster(z.small_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n\\n    print(\\\"\\\\nFor medium_num = \\\", medium_num, \\\":\\\")\\n    print(\\n        \\\"> num_digits()\\\",\\n        \\\"\\\\t\\\\tans =\\\",\\n        num_digits(medium_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.num_digits(z.medium_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> num_digits_fast()\\\",\\n        \\\"\\\\tans =\\\",\\n        num_digits_fast(medium_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.num_digits_fast(z.medium_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> num_digits_faster()\\\",\\n        \\\"\\\\tans =\\\",\\n        num_digits_faster(medium_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.num_digits_faster(z.medium_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n\\n    print(\\\"\\\\nFor large_num = \\\", large_num, \\\":\\\")\\n    print(\\n        \\\"> num_digits()\\\",\\n        \\\"\\\\t\\\\tans =\\\",\\n        num_digits(large_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.num_digits(z.large_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> num_digits_fast()\\\",\\n        \\\"\\\\tans =\\\",\\n        num_digits_fast(large_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.num_digits_fast(z.large_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> num_digits_faster()\\\",\\n        \\\"\\\\tans =\\\",\\n        num_digits_faster(large_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.num_digits_faster(z.large_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    small_num = 262144\\n    medium_num = 1125899906842624\\n    large_num = 1267650600228229401496703205376\\n    benchmark()\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "numerical integration": "\"\\\"\\\"\\\"\\nApproximates the area under the curve using the trapezoidal rule\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom typing import Callable\\n\\n\\ndef trapezoidal_area(\\n    fnc: Callable[[int | float], int | float],\\n    x_start: int | float,\\n    x_end: int | float,\\n    steps: int = 100,\\n) -> float:\\n\\n    \\\"\\\"\\\"\\n    Treats curve as a collection of linear lines and sums the area of the\\n    trapezium shape they form\\n    :param fnc: a function which defines a curve\\n    :param x_start: left end point to indicate the start of line segment\\n    :param x_end: right end point to indicate end of line segment\\n    :param steps: an accuracy gauge; more steps increases the accuracy\\n    :return: a float representing the length of the curve\\n\\n    >>> def f(x):\\n    ...    return 5\\n    >>> '%.3f' % trapezoidal_area(f, 12.0, 14.0, 1000)\\n    '10.000'\\n\\n    >>> def f(x):\\n    ...    return 9*x**2\\n    >>> '%.4f' % trapezoidal_area(f, -4.0, 0, 10000)\\n    '192.0000'\\n\\n    >>> '%.4f' % trapezoidal_area(f, -4.0, 4.0, 10000)\\n    '384.0000'\\n    \\\"\\\"\\\"\\n    x1 = x_start\\n    fx1 = fnc(x_start)\\n    area = 0.0\\n\\n    for i in range(steps):\\n\\n        # Approximates small segments of curve as linear and solve\\n        # for trapezoidal area\\n        x2 = (x_end - x_start) / steps + x1\\n        fx2 = fnc(x2)\\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\\n\\n        # Increment step\\n        x1 = x2\\n        fx1 = fx2\\n    return area\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    def f(x):\\n        return x ** 3\\n\\n    print(\\\"f(x) = x^3\\\")\\n    print(\\\"The area between the curve, x = -10, x = 10 and the x axis is:\\\")\\n    i = 10\\n    while i <= 100000:\\n        area = trapezoidal_area(f, -5, 5, i)\\n        print(f\\\"with {i} steps: {area}\\\")\\n        i *= 10\\n\"",
    "perfect cube": "\"def perfect_cube(n: int) -> bool:\\n    \\\"\\\"\\\"\\n    Check if a number is a perfect cube or not.\\n\\n    >>> perfect_cube(27)\\n    True\\n    >>> perfect_cube(4)\\n    False\\n    \\\"\\\"\\\"\\n    val = n ** (1 / 3)\\n    return (val * val * val) == n\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(perfect_cube(27))\\n    print(perfect_cube(4))\\n\"",
    "perfect number": "\"\\\"\\\"\\\"\\n== Perfect Number ==\\nIn number theory, a perfect number is a positive integer that is equal to the sum of\\nits positive divisors, excluding the number itself.\\nFor example: 6 ==> divisors[1, 2, 3, 6]\\n    Excluding 6, the sum(divisors) is 1 + 2 + 3 = 6\\n    So, 6 is a Perfect Number\\n\\nOther examples of Perfect Numbers: 28, 486, ...\\n\\nhttps://en.wikipedia.org/wiki/Perfect_number\\n\\\"\\\"\\\"\\n\\n\\ndef perfect(number: int) -> bool:\\n    \\\"\\\"\\\"\\n    >>> perfect(27)\\n    False\\n    >>> perfect(28)\\n    True\\n    >>> perfect(29)\\n    False\\n\\n    Start from 1 because dividing by 0 will raise ZeroDivisionError.\\n    A number at most can be divisible by the half of the number except the number\\n    itself.  For example, 6 is at most can be divisible by 3 except by 6 itself.\\n    \\\"\\\"\\\"\\n    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"Program to check whether a number is a Perfect number or not...\\\")\\n    number = int(input(\\\"Enter number: \\\").strip())\\n    print(f\\\"{number} is {'' if perfect(number) else 'not '}a Perfect Number.\\\")\\n\"",
    "perfect square": "\"import math\\n\\n\\ndef perfect_square(num: int) -> bool:\\n    \\\"\\\"\\\"\\n    Check if a number is perfect square number or not\\n    :param num: the number to be checked\\n    :return: True if number is square number, otherwise False\\n\\n    >>> perfect_square(9)\\n    True\\n    >>> perfect_square(16)\\n    True\\n    >>> perfect_square(1)\\n    True\\n    >>> perfect_square(0)\\n    True\\n    >>> perfect_square(10)\\n    False\\n    \\\"\\\"\\\"\\n    return math.sqrt(num) * math.sqrt(num) == num\\n\\n\\ndef perfect_square_binary_search(n: int) -> bool:\\n    \\\"\\\"\\\"\\n    Check if a number is perfect square using binary search.\\n    Time complexity : O(Log(n))\\n    Space complexity: O(1)\\n\\n    >>> perfect_square_binary_search(9)\\n    True\\n    >>> perfect_square_binary_search(16)\\n    True\\n    >>> perfect_square_binary_search(1)\\n    True\\n    >>> perfect_square_binary_search(0)\\n    True\\n    >>> perfect_square_binary_search(10)\\n    False\\n    >>> perfect_square_binary_search(-1)\\n    False\\n    >>> perfect_square_binary_search(1.1)\\n    False\\n    >>> perfect_square_binary_search(\\\"a\\\")\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: '<=' not supported between instances of 'int' and 'str'\\n    >>> perfect_square_binary_search(None)\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: '<=' not supported between instances of 'int' and 'NoneType'\\n    >>> perfect_square_binary_search([])\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: '<=' not supported between instances of 'int' and 'list'\\n    \\\"\\\"\\\"\\n    left = 0\\n    right = n\\n    while left <= right:\\n        mid = (left + right) // 2\\n        if mid ** 2 == n:\\n            return True\\n        elif mid ** 2 > n:\\n            right = mid - 1\\n        else:\\n            left = mid + 1\\n    return False\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "persistence": "\"def multiplicative_persistence(num: int) -> int:\\n    \\\"\\\"\\\"\\n    Return the persistence of a given number.\\n\\n    https://en.wikipedia.org/wiki/Persistence_of_a_number\\n\\n    >>> multiplicative_persistence(217)\\n    2\\n    >>> multiplicative_persistence(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: multiplicative_persistence() does not accept negative values\\n    >>> multiplicative_persistence(\\\"long number\\\")\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: multiplicative_persistence() only accepts integral values\\n    \\\"\\\"\\\"\\n\\n    if not isinstance(num, int):\\n        raise ValueError(\\\"multiplicative_persistence() only accepts integral values\\\")\\n    if num < 0:\\n        raise ValueError(\\\"multiplicative_persistence() does not accept negative values\\\")\\n\\n    steps = 0\\n    num_string = str(num)\\n\\n    while len(num_string) != 1:\\n        numbers = [int(i) for i in num_string]\\n\\n        total = 1\\n        for i in range(0, len(numbers)):\\n            total *= numbers[i]\\n\\n        num_string = str(total)\\n\\n        steps += 1\\n    return steps\\n\\n\\ndef additive_persistence(num: int) -> int:\\n    \\\"\\\"\\\"\\n    Return the persistence of a given number.\\n\\n    https://en.wikipedia.org/wiki/Persistence_of_a_number\\n\\n    >>> additive_persistence(199)\\n    3\\n    >>> additive_persistence(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: additive_persistence() does not accept negative values\\n    >>> additive_persistence(\\\"long number\\\")\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: additive_persistence() only accepts integral values\\n    \\\"\\\"\\\"\\n\\n    if not isinstance(num, int):\\n        raise ValueError(\\\"additive_persistence() only accepts integral values\\\")\\n    if num < 0:\\n        raise ValueError(\\\"additive_persistence() does not accept negative values\\\")\\n\\n    steps = 0\\n    num_string = str(num)\\n\\n    while len(num_string) != 1:\\n        numbers = [int(i) for i in num_string]\\n\\n        total = 0\\n        for i in range(0, len(numbers)):\\n            total += numbers[i]\\n\\n        num_string = str(total)\\n\\n        steps += 1\\n    return steps\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "pi monte carlo estimation": "\"import random\\n\\n\\nclass Point:\\n    def __init__(self, x: float, y: float) -> None:\\n        self.x = x\\n        self.y = y\\n\\n    def is_in_unit_circle(self) -> bool:\\n        \\\"\\\"\\\"\\n        True, if the point lies in the unit circle\\n        False, otherwise\\n        \\\"\\\"\\\"\\n        return (self.x ** 2 + self.y ** 2) <= 1\\n\\n    @classmethod\\n    def random_unit_square(cls):\\n        \\\"\\\"\\\"\\n        Generates a point randomly drawn from the unit square [0, 1) x [0, 1).\\n        \\\"\\\"\\\"\\n        return cls(x=random.random(), y=random.random())\\n\\n\\ndef estimate_pi(number_of_simulations: int) -> float:\\n    \\\"\\\"\\\"\\n    Generates an estimate of the mathematical constant PI.\\n    See https://en.wikipedia.org/wiki/Monte_Carlo_method#Overview\\n\\n    The estimate is generated by Monte Carlo simulations. Let U be uniformly drawn from\\n    the unit square [0, 1) x [0, 1). The probability that U lies in the unit circle is:\\n\\n        P[U in unit circle] = 1/4 PI\\n\\n    and therefore\\n\\n        PI = 4 * P[U in unit circle]\\n\\n    We can get an estimate of the probability P[U in unit circle].\\n    See https://en.wikipedia.org/wiki/Empirical_probability by:\\n\\n        1. Draw a point uniformly from the unit square.\\n        2. Repeat the first step n times and count the number of points in the unit\\n            circle, which is called m.\\n        3. An estimate of P[U in unit circle] is m/n\\n    \\\"\\\"\\\"\\n    if number_of_simulations < 1:\\n        raise ValueError(\\\"At least one simulation is necessary to estimate PI.\\\")\\n\\n    number_in_unit_circle = 0\\n    for simulation_index in range(number_of_simulations):\\n        random_point = Point.random_unit_square()\\n\\n        if random_point.is_in_unit_circle():\\n            number_in_unit_circle += 1\\n\\n    return 4 * number_in_unit_circle / number_of_simulations\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # import doctest\\n\\n    # doctest.testmod()\\n    from math import pi\\n\\n    prompt = \\\"Please enter the desired number of Monte Carlo simulations: \\\"\\n    my_pi = estimate_pi(int(input(prompt).strip()))\\n    print(f\\\"An estimate of PI is {my_pi} with an error of {abs(my_pi - pi)}\\\")\\n\"",
    "pollard rho": "\"from __future__ import annotations\\n\\nfrom math import gcd\\n\\n\\ndef pollard_rho(\\n    num: int,\\n    seed: int = 2,\\n    step: int = 1,\\n    attempts: int = 3,\\n) -> int | None:\\n    \\\"\\\"\\\"\\n    Use Pollard's Rho algorithm to return a nontrivial factor of ``num``.\\n    The returned factor may be composite and require further factorization.\\n    If the algorithm will return None if it fails to find a factor within\\n    the specified number of attempts or within the specified number of steps.\\n    If ``num`` is prime, this algorithm is guaranteed to return None.\\n    https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\\n\\n    >>> pollard_rho(18446744073709551617)\\n    274177\\n    >>> pollard_rho(97546105601219326301)\\n    9876543191\\n    >>> pollard_rho(100)\\n    2\\n    >>> pollard_rho(17)\\n    >>> pollard_rho(17**3)\\n    17\\n    >>> pollard_rho(17**3, attempts=1)\\n    >>> pollard_rho(3*5*7)\\n    21\\n    >>> pollard_rho(1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The input value cannot be less than 2\\n    \\\"\\\"\\\"\\n    # A value less than 2 can cause an infinite loop in the algorithm.\\n    if num < 2:\\n        raise ValueError(\\\"The input value cannot be less than 2\\\")\\n\\n    # Because of the relationship between ``f(f(x))`` and ``f(x)``, this\\n    # algorithm struggles to find factors that are divisible by two.\\n    # As a workaround, we specifically check for two and even inputs.\\n    #   See: https://math.stackexchange.com/a/2856214/165820\\n    if num > 2 and num % 2 == 0:\\n        return 2\\n\\n    # Pollard's Rho algorithm requires a function that returns pseudorandom\\n    # values between 0 <= X < ``num``.  It doesn't need to be random in the\\n    # sense that the output value is cryptographically secure or difficult\\n    # to calculate, it only needs to be random in the sense that all output\\n    # values should be equally likely to appear.\\n    # For this reason, Pollard suggested using ``f(x) = (x**2 - 1) % num``\\n    # However, the success of Pollard's algorithm isn't guaranteed and is\\n    # determined in part by the initial seed and the chosen random function.\\n    # To make retries easier, we will instead use ``f(x) = (x**2 + C) % num``\\n    # where ``C`` is a value that we can modify between each attempt.\\n    def rand_fn(value: int, step: int, modulus: int) -> int:\\n        \\\"\\\"\\\"\\n        Returns a pseudorandom value modulo ``modulus`` based on the\\n        input ``value`` and attempt-specific ``step`` size.\\n\\n        >>> rand_fn(0, 0, 0)\\n        Traceback (most recent call last):\\n            ...\\n        ZeroDivisionError: integer division or modulo by zero\\n        >>> rand_fn(1, 2, 3)\\n        0\\n        >>> rand_fn(0, 10, 7)\\n        3\\n        >>> rand_fn(1234, 1, 17)\\n        16\\n        \\\"\\\"\\\"\\n        return (pow(value, 2) + step) % modulus\\n\\n    for attempt in range(attempts):\\n        # These track the position within the cycle detection logic.\\n        tortoise = seed\\n        hare = seed\\n\\n        while True:\\n            # At each iteration, the tortoise moves one step and the hare moves two.\\n            tortoise = rand_fn(tortoise, step, num)\\n            hare = rand_fn(hare, step, num)\\n            hare = rand_fn(hare, step, num)\\n\\n            # At some point both the tortoise and the hare will enter a cycle whose\\n            # length ``p`` is a divisor of ``num``.  Once in that cycle, at some point\\n            # the tortoise and hare will end up on the same value modulo ``p``.\\n            # We can detect when this happens because the position difference between\\n            # the tortoise and the hare will share a common divisor with ``num``.\\n            divisor = gcd(hare - tortoise, num)\\n\\n            if divisor == 1:\\n                # No common divisor yet, just keep searching.\\n                continue\\n            else:\\n                # We found a common divisor!\\n                if divisor == num:\\n                    # Unfortunately, the divisor is ``num`` itself and is useless.\\n                    break\\n                else:\\n                    # The divisor is a nontrivial factor of ``num``!\\n                    return divisor\\n\\n        # If we made it here, then this attempt failed.\\n        # We need to pick a new starting seed for the tortoise and hare\\n        # in addition to a new step value for the random function.\\n        # To keep this example implementation deterministic, the\\n        # new values will be generated based on currently available\\n        # values instead of using something like ``random.randint``.\\n\\n        # We can use the hare's position as the new seed.\\n        # This is actually what Richard Brent's the \\\"optimized\\\" variant does.\\n        seed = hare\\n\\n        # The new step value for the random function can just be incremented.\\n        # At first the results will be similar to what the old function would\\n        # have produced, but the value will quickly diverge after a bit.\\n        step += 1\\n\\n    # We haven't found a divisor within the requested number of attempts.\\n    # We were unlucky or ``num`` itself is actually prime.\\n    return None\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import argparse\\n\\n    parser = argparse.ArgumentParser()\\n    parser.add_argument(\\n        \\\"num\\\",\\n        type=int,\\n        help=\\\"The value to find a divisor of\\\",\\n    )\\n    parser.add_argument(\\n        \\\"--attempts\\\",\\n        type=int,\\n        default=3,\\n        help=\\\"The number of attempts before giving up\\\",\\n    )\\n    args = parser.parse_args()\\n\\n    divisor = pollard_rho(args.num, attempts=args.attempts)\\n    if divisor is None:\\n        print(f\\\"{args.num} is probably prime\\\")\\n    else:\\n        quotient = args.num // divisor\\n        print(f\\\"{args.num} = {divisor} * {quotient}\\\")\\n\"",
    "polynomial evaluation": "\"from typing import Sequence\\n\\n\\ndef evaluate_poly(poly: Sequence[float], x: float) -> float:\\n    \\\"\\\"\\\"Evaluate a polynomial f(x) at specified point x and return the value.\\n\\n    Arguments:\\n    poly -- the coefficients of a polynomial as an iterable in order of\\n            ascending degree\\n    x -- the point at which to evaluate the polynomial\\n\\n    >>> evaluate_poly((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)\\n    79800.0\\n    \\\"\\\"\\\"\\n    return sum(c * (x ** i) for i, c in enumerate(poly))\\n\\n\\ndef horner(poly: Sequence[float], x: float) -> float:\\n    \\\"\\\"\\\"Evaluate a polynomial at specified point using Horner's method.\\n\\n    In terms of computational complexity, Horner's method is an efficient method\\n    of evaluating a polynomial. It avoids the use of expensive exponentiation,\\n    and instead uses only multiplication and addition to evaluate the polynomial\\n    in O(n), where n is the degree of the polynomial.\\n\\n    https://en.wikipedia.org/wiki/Horner's_method\\n\\n    Arguments:\\n    poly -- the coefficients of a polynomial as an iterable in order of\\n            ascending degree\\n    x -- the point at which to evaluate the polynomial\\n\\n    >>> horner((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)\\n    79800.0\\n    \\\"\\\"\\\"\\n    result = 0.0\\n    for coeff in reversed(poly):\\n        result = result * x + coeff\\n    return result\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    \\\"\\\"\\\"\\n    Example:\\n    >>> poly = (0.0, 0.0, 5.0, 9.3, 7.0)  # f(x) = 7.0x^4 + 9.3x^3 + 5.0x^2\\n    >>> x = -13.0\\n    >>> # f(-13) = 7.0(-13)^4 + 9.3(-13)^3 + 5.0(-13)^2 = 180339.9\\n    >>> print(evaluate_poly(poly, x))\\n    180339.9\\n    \\\"\\\"\\\"\\n    poly = (0.0, 0.0, 5.0, 9.3, 7.0)\\n    x = 10.0\\n    print(evaluate_poly(poly, x))\\n    print(horner(poly, x))\\n\"",
    "power using recursion": "\"\\\"\\\"\\\"\\n== Raise base to the power of exponent using recursion ==\\n    Input -->\\n        Enter the base: 3\\n        Enter the exponent: 4\\n    Output  -->\\n        3 to the power of 4 is 81\\n    Input -->\\n        Enter the base: 2\\n        Enter the exponent: 0\\n    Output -->\\n        2 to the power of 0 is 1\\n\\\"\\\"\\\"\\n\\n\\ndef power(base: int, exponent: int) -> float:\\n    \\\"\\\"\\\"\\n    power(3, 4)\\n    81\\n    >>> power(2, 0)\\n    1\\n    >>> all(power(base, exponent) == pow(base, exponent)\\n    ...     for base in range(-10, 10) for exponent in range(10))\\n    True\\n    \\\"\\\"\\\"\\n    return base * power(base, (exponent - 1)) if exponent else 1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"Raise base to the power of exponent using recursion...\\\")\\n    base = int(input(\\\"Enter the base: \\\").strip())\\n    exponent = int(input(\\\"Enter the exponent: \\\").strip())\\n    result = power(base, abs(exponent))\\n    if exponent < 0:  # power() does not properly deal w/ negative exponents\\n        result = 1 / result\\n    print(f\\\"{base} to the power of {exponent} is {result}\\\")\\n\"",
    "primelib": "\"\\\"\\\"\\\"\\nCreated on Thu Oct  5 16:44:23 2017\\n\\n@author: Christian Bender\\n\\nThis Python library contains some useful functions to deal with\\nprime numbers and whole numbers.\\n\\nOverview:\\n\\nisPrime(number)\\nsieveEr(N)\\ngetPrimeNumbers(N)\\nprimeFactorization(number)\\ngreatestPrimeFactor(number)\\nsmallestPrimeFactor(number)\\ngetPrime(n)\\ngetPrimesBetween(pNumber1, pNumber2)\\n\\n----\\n\\nisEven(number)\\nisOdd(number)\\ngcd(number1, number2)  // greatest common divisor\\nkgV(number1, number2)  // least common multiple\\ngetDivisors(number)    // all divisors of 'number' inclusive 1, number\\nisPerfectNumber(number)\\n\\nNEW-FUNCTIONS\\n\\nsimplifyFraction(numerator, denominator)\\nfactorial (n) // n!\\nfib (n) // calculate the n-th fibonacci term.\\n\\n-----\\n\\ngoldbach(number)  // Goldbach's assumption\\n\\n\\\"\\\"\\\"\\n\\nfrom math import sqrt\\n\\n\\ndef isPrime(number):\\n    \\\"\\\"\\\"\\n    input: positive integer 'number'\\n    returns true if 'number' is prime otherwise false.\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(number, int) and (\\n        number >= 0\\n    ), \\\"'number' must been an int and positive\\\"\\n\\n    status = True\\n\\n    # 0 and 1 are none primes.\\n    if number <= 1:\\n        status = False\\n\\n    for divisor in range(2, int(round(sqrt(number))) + 1):\\n\\n        # if 'number' divisible by 'divisor' then sets 'status'\\n        # of false and break up the loop.\\n        if number % divisor == 0:\\n            status = False\\n            break\\n\\n    # precondition\\n    assert isinstance(status, bool), \\\"'status' must been from type bool\\\"\\n\\n    return status\\n\\n\\n# ------------------------------------------\\n\\n\\ndef sieveEr(N):\\n    \\\"\\\"\\\"\\n    input: positive integer 'N' > 2\\n    returns a list of prime numbers from 2 up to N.\\n\\n    This function implements the algorithm called\\n    sieve of erathostenes.\\n\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(N, int) and (N > 2), \\\"'N' must been an int and > 2\\\"\\n\\n    # beginList: contains all natural numbers from 2 up to N\\n    beginList = [x for x in range(2, N + 1)]\\n\\n    ans = []  # this list will be returns.\\n\\n    # actual sieve of erathostenes\\n    for i in range(len(beginList)):\\n\\n        for j in range(i + 1, len(beginList)):\\n\\n            if (beginList[i] != 0) and (beginList[j] % beginList[i] == 0):\\n                beginList[j] = 0\\n\\n    # filters actual prime numbers.\\n    ans = [x for x in beginList if x != 0]\\n\\n    # precondition\\n    assert isinstance(ans, list), \\\"'ans' must been from type list\\\"\\n\\n    return ans\\n\\n\\n# --------------------------------\\n\\n\\ndef getPrimeNumbers(N):\\n    \\\"\\\"\\\"\\n    input: positive integer 'N' > 2\\n    returns a list of prime numbers from 2 up to N (inclusive)\\n    This function is more efficient as function 'sieveEr(...)'\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(N, int) and (N > 2), \\\"'N' must been an int and > 2\\\"\\n\\n    ans = []\\n\\n    # iterates over all numbers between 2 up to N+1\\n    # if a number is prime then appends to list 'ans'\\n    for number in range(2, N + 1):\\n\\n        if isPrime(number):\\n\\n            ans.append(number)\\n\\n    # precondition\\n    assert isinstance(ans, list), \\\"'ans' must been from type list\\\"\\n\\n    return ans\\n\\n\\n# -----------------------------------------\\n\\n\\ndef primeFactorization(number):\\n    \\\"\\\"\\\"\\n    input: positive integer 'number'\\n    returns a list of the prime number factors of 'number'\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(number, int) and number >= 0, \\\"'number' must been an int and >= 0\\\"\\n\\n    ans = []  # this list will be returns of the function.\\n\\n    # potential prime number factors.\\n\\n    factor = 2\\n\\n    quotient = number\\n\\n    if number == 0 or number == 1:\\n\\n        ans.append(number)\\n\\n    # if 'number' not prime then builds the prime factorization of 'number'\\n    elif not isPrime(number):\\n\\n        while quotient != 1:\\n\\n            if isPrime(factor) and (quotient % factor == 0):\\n                ans.append(factor)\\n                quotient /= factor\\n            else:\\n                factor += 1\\n\\n    else:\\n        ans.append(number)\\n\\n    # precondition\\n    assert isinstance(ans, list), \\\"'ans' must been from type list\\\"\\n\\n    return ans\\n\\n\\n# -----------------------------------------\\n\\n\\ndef greatestPrimeFactor(number):\\n    \\\"\\\"\\\"\\n    input: positive integer 'number' >= 0\\n    returns the greatest prime number factor of 'number'\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(number, int) and (\\n        number >= 0\\n    ), \\\"'number' bust been an int and >= 0\\\"\\n\\n    ans = 0\\n\\n    # prime factorization of 'number'\\n    primeFactors = primeFactorization(number)\\n\\n    ans = max(primeFactors)\\n\\n    # precondition\\n    assert isinstance(ans, int), \\\"'ans' must been from type int\\\"\\n\\n    return ans\\n\\n\\n# ----------------------------------------------\\n\\n\\ndef smallestPrimeFactor(number):\\n    \\\"\\\"\\\"\\n    input: integer 'number' >= 0\\n    returns the smallest prime number factor of 'number'\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(number, int) and (\\n        number >= 0\\n    ), \\\"'number' bust been an int and >= 0\\\"\\n\\n    ans = 0\\n\\n    # prime factorization of 'number'\\n    primeFactors = primeFactorization(number)\\n\\n    ans = min(primeFactors)\\n\\n    # precondition\\n    assert isinstance(ans, int), \\\"'ans' must been from type int\\\"\\n\\n    return ans\\n\\n\\n# ----------------------\\n\\n\\ndef isEven(number):\\n    \\\"\\\"\\\"\\n    input: integer 'number'\\n    returns true if 'number' is even, otherwise false.\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(number, int), \\\"'number' must been an int\\\"\\n    assert isinstance(number % 2 == 0, bool), \\\"compare bust been from type bool\\\"\\n\\n    return number % 2 == 0\\n\\n\\n# ------------------------\\n\\n\\ndef isOdd(number):\\n    \\\"\\\"\\\"\\n    input: integer 'number'\\n    returns true if 'number' is odd, otherwise false.\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(number, int), \\\"'number' must been an int\\\"\\n    assert isinstance(number % 2 != 0, bool), \\\"compare bust been from type bool\\\"\\n\\n    return number % 2 != 0\\n\\n\\n# ------------------------\\n\\n\\ndef goldbach(number):\\n    \\\"\\\"\\\"\\n    Goldbach's assumption\\n    input: a even positive integer 'number' > 2\\n    returns a list of two prime numbers whose sum is equal to 'number'\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert (\\n        isinstance(number, int) and (number > 2) and isEven(number)\\n    ), \\\"'number' must been an int, even and > 2\\\"\\n\\n    ans = []  # this list will returned\\n\\n    # creates a list of prime numbers between 2 up to 'number'\\n    primeNumbers = getPrimeNumbers(number)\\n    lenPN = len(primeNumbers)\\n\\n    # run variable for while-loops.\\n    i = 0\\n    j = None\\n\\n    # exit variable. for break up the loops\\n    loop = True\\n\\n    while i < lenPN and loop:\\n\\n        j = i + 1\\n\\n        while j < lenPN and loop:\\n\\n            if primeNumbers[i] + primeNumbers[j] == number:\\n                loop = False\\n                ans.append(primeNumbers[i])\\n                ans.append(primeNumbers[j])\\n\\n            j += 1\\n\\n        i += 1\\n\\n    # precondition\\n    assert (\\n        isinstance(ans, list)\\n        and (len(ans) == 2)\\n        and (ans[0] + ans[1] == number)\\n        and isPrime(ans[0])\\n        and isPrime(ans[1])\\n    ), \\\"'ans' must contains two primes. And sum of elements must been eq 'number'\\\"\\n\\n    return ans\\n\\n\\n# ----------------------------------------------\\n\\n\\ndef gcd(number1, number2):\\n    \\\"\\\"\\\"\\n    Greatest common divisor\\n    input: two positive integer 'number1' and 'number2'\\n    returns the greatest common divisor of 'number1' and 'number2'\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert (\\n        isinstance(number1, int)\\n        and isinstance(number2, int)\\n        and (number1 >= 0)\\n        and (number2 >= 0)\\n    ), \\\"'number1' and 'number2' must been positive integer.\\\"\\n\\n    rest = 0\\n\\n    while number2 != 0:\\n\\n        rest = number1 % number2\\n        number1 = number2\\n        number2 = rest\\n\\n    # precondition\\n    assert isinstance(number1, int) and (\\n        number1 >= 0\\n    ), \\\"'number' must been from type int and positive\\\"\\n\\n    return number1\\n\\n\\n# ----------------------------------------------------\\n\\n\\ndef kgV(number1, number2):\\n    \\\"\\\"\\\"\\n    Least common multiple\\n    input: two positive integer 'number1' and 'number2'\\n    returns the least common multiple of 'number1' and 'number2'\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert (\\n        isinstance(number1, int)\\n        and isinstance(number2, int)\\n        and (number1 >= 1)\\n        and (number2 >= 1)\\n    ), \\\"'number1' and 'number2' must been positive integer.\\\"\\n\\n    ans = 1  # actual answer that will be return.\\n\\n    # for kgV (x,1)\\n    if number1 > 1 and number2 > 1:\\n\\n        # builds the prime factorization of 'number1' and 'number2'\\n        primeFac1 = primeFactorization(number1)\\n        primeFac2 = primeFactorization(number2)\\n\\n    elif number1 == 1 or number2 == 1:\\n\\n        primeFac1 = []\\n        primeFac2 = []\\n        ans = max(number1, number2)\\n\\n    count1 = 0\\n    count2 = 0\\n\\n    done = []  # captured numbers int both 'primeFac1' and 'primeFac2'\\n\\n    # iterates through primeFac1\\n    for n in primeFac1:\\n\\n        if n not in done:\\n\\n            if n in primeFac2:\\n\\n                count1 = primeFac1.count(n)\\n                count2 = primeFac2.count(n)\\n\\n                for i in range(max(count1, count2)):\\n                    ans *= n\\n\\n            else:\\n\\n                count1 = primeFac1.count(n)\\n\\n                for i in range(count1):\\n                    ans *= n\\n\\n            done.append(n)\\n\\n    # iterates through primeFac2\\n    for n in primeFac2:\\n\\n        if n not in done:\\n\\n            count2 = primeFac2.count(n)\\n\\n            for i in range(count2):\\n                ans *= n\\n\\n            done.append(n)\\n\\n    # precondition\\n    assert isinstance(ans, int) and (\\n        ans >= 0\\n    ), \\\"'ans' must been from type int and positive\\\"\\n\\n    return ans\\n\\n\\n# ----------------------------------\\n\\n\\ndef getPrime(n):\\n    \\\"\\\"\\\"\\n    Gets the n-th prime number.\\n    input: positive integer 'n' >= 0\\n    returns the n-th prime number, beginning at index 0\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(n, int) and (n >= 0), \\\"'number' must been a positive int\\\"\\n\\n    index = 0\\n    ans = 2  # this variable holds the answer\\n\\n    while index < n:\\n\\n        index += 1\\n\\n        ans += 1  # counts to the next number\\n\\n        # if ans not prime then\\n        # runs to the next prime number.\\n        while not isPrime(ans):\\n            ans += 1\\n\\n    # precondition\\n    assert isinstance(ans, int) and isPrime(\\n        ans\\n    ), \\\"'ans' must been a prime number and from type int\\\"\\n\\n    return ans\\n\\n\\n# ---------------------------------------------------\\n\\n\\ndef getPrimesBetween(pNumber1, pNumber2):\\n    \\\"\\\"\\\"\\n    input: prime numbers 'pNumber1' and 'pNumber2'\\n            pNumber1 < pNumber2\\n    returns a list of all prime numbers between 'pNumber1' (exclusive)\\n            and 'pNumber2' (exclusive)\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert (\\n        isPrime(pNumber1) and isPrime(pNumber2) and (pNumber1 < pNumber2)\\n    ), \\\"The arguments must been prime numbers and 'pNumber1' < 'pNumber2'\\\"\\n\\n    number = pNumber1 + 1  # jump to the next number\\n\\n    ans = []  # this list will be returns.\\n\\n    # if number is not prime then\\n    # fetch the next prime number.\\n    while not isPrime(number):\\n        number += 1\\n\\n    while number < pNumber2:\\n\\n        ans.append(number)\\n\\n        number += 1\\n\\n        # fetch the next prime number.\\n        while not isPrime(number):\\n            number += 1\\n\\n    # precondition\\n    assert (\\n        isinstance(ans, list) and ans[0] != pNumber1 and ans[len(ans) - 1] != pNumber2\\n    ), \\\"'ans' must been a list without the arguments\\\"\\n\\n    # 'ans' contains not 'pNumber1' and 'pNumber2' !\\n    return ans\\n\\n\\n# ----------------------------------------------------\\n\\n\\ndef getDivisors(n):\\n    \\\"\\\"\\\"\\n    input: positive integer 'n' >= 1\\n    returns all divisors of n (inclusive 1 and 'n')\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(n, int) and (n >= 1), \\\"'n' must been int and >= 1\\\"\\n\\n    ans = []  # will be returned.\\n\\n    for divisor in range(1, n + 1):\\n\\n        if n % divisor == 0:\\n            ans.append(divisor)\\n\\n    # precondition\\n    assert ans[0] == 1 and ans[len(ans) - 1] == n, \\\"Error in function getDivisiors(...)\\\"\\n\\n    return ans\\n\\n\\n# ----------------------------------------------------\\n\\n\\ndef isPerfectNumber(number):\\n    \\\"\\\"\\\"\\n    input: positive integer 'number' > 1\\n    returns true if 'number' is a perfect number otherwise false.\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(number, int) and (\\n        number > 1\\n    ), \\\"'number' must been an int and >= 1\\\"\\n\\n    divisors = getDivisors(number)\\n\\n    # precondition\\n    assert (\\n        isinstance(divisors, list)\\n        and (divisors[0] == 1)\\n        and (divisors[len(divisors) - 1] == number)\\n    ), \\\"Error in help-function getDivisiors(...)\\\"\\n\\n    # summed all divisors up to 'number' (exclusive), hence [:-1]\\n    return sum(divisors[:-1]) == number\\n\\n\\n# ------------------------------------------------------------\\n\\n\\ndef simplifyFraction(numerator, denominator):\\n    \\\"\\\"\\\"\\n    input: two integer 'numerator' and 'denominator'\\n    assumes: 'denominator' != 0\\n    returns: a tuple with simplify numerator and denominator.\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert (\\n        isinstance(numerator, int)\\n        and isinstance(denominator, int)\\n        and (denominator != 0)\\n    ), \\\"The arguments must been from type int and 'denominator' != 0\\\"\\n\\n    # build the greatest common divisor of numerator and denominator.\\n    gcdOfFraction = gcd(abs(numerator), abs(denominator))\\n\\n    # precondition\\n    assert (\\n        isinstance(gcdOfFraction, int)\\n        and (numerator % gcdOfFraction == 0)\\n        and (denominator % gcdOfFraction == 0)\\n    ), \\\"Error in function gcd(...,...)\\\"\\n\\n    return (numerator // gcdOfFraction, denominator // gcdOfFraction)\\n\\n\\n# -----------------------------------------------------------------\\n\\n\\ndef factorial(n):\\n    \\\"\\\"\\\"\\n    input: positive integer 'n'\\n    returns the factorial of 'n' (n!)\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(n, int) and (n >= 0), \\\"'n' must been a int and >= 0\\\"\\n\\n    ans = 1  # this will be return.\\n\\n    for factor in range(1, n + 1):\\n        ans *= factor\\n\\n    return ans\\n\\n\\n# -------------------------------------------------------------------\\n\\n\\ndef fib(n):\\n    \\\"\\\"\\\"\\n    input: positive integer 'n'\\n    returns the n-th fibonacci term , indexing by 0\\n    \\\"\\\"\\\"\\n\\n    # precondition\\n    assert isinstance(n, int) and (n >= 0), \\\"'n' must been an int and >= 0\\\"\\n\\n    tmp = 0\\n    fib1 = 1\\n    ans = 1  # this will be return\\n\\n    for i in range(n - 1):\\n\\n        tmp = ans\\n        ans += fib1\\n        fib1 = tmp\\n\\n    return ans\\n\"",
    "prime check": "\"\\\"\\\"\\\"Prime Check.\\\"\\\"\\\"\\n\\nimport math\\nimport unittest\\n\\n\\ndef prime_check(number: int) -> bool:\\n    \\\"\\\"\\\"Checks to see if a number is a prime in O(sqrt(n)).\\n\\n    A number is prime if it has exactly two factors: 1 and itself.\\n\\n    >>> prime_check(0)\\n    False\\n    >>> prime_check(1)\\n    False\\n    >>> prime_check(2)\\n    True\\n    >>> prime_check(3)\\n    True\\n    >>> prime_check(27)\\n    False\\n    >>> prime_check(87)\\n    False\\n    >>> prime_check(563)\\n    True\\n    >>> prime_check(2999)\\n    True\\n    >>> prime_check(67483)\\n    False\\n    \\\"\\\"\\\"\\n\\n    if 1 < number < 4:\\n        # 2 and 3 are primes\\n        return True\\n    elif number < 2 or not number % 2:\\n        # Negatives, 0, 1 and all even numbers are not primes\\n        return False\\n\\n    odd_numbers = range(3, int(math.sqrt(number) + 1), 2)\\n    return not any(not number % i for i in odd_numbers)\\n\\n\\nclass Test(unittest.TestCase):\\n    def test_primes(self):\\n        self.assertTrue(prime_check(2))\\n        self.assertTrue(prime_check(3))\\n        self.assertTrue(prime_check(5))\\n        self.assertTrue(prime_check(7))\\n        self.assertTrue(prime_check(11))\\n        self.assertTrue(prime_check(13))\\n        self.assertTrue(prime_check(17))\\n        self.assertTrue(prime_check(19))\\n        self.assertTrue(prime_check(23))\\n        self.assertTrue(prime_check(29))\\n\\n    def test_not_primes(self):\\n        self.assertFalse(\\n            prime_check(-19),\\n            \\\"Negative numbers are excluded by definition of prime numbers.\\\",\\n        )\\n        self.assertFalse(\\n            prime_check(0),\\n            \\\"Zero doesn't have any positive factors, primes must have exactly two.\\\",\\n        )\\n        self.assertFalse(\\n            prime_check(1),\\n            \\\"One only has 1 positive factor, primes must have exactly two.\\\",\\n        )\\n        self.assertFalse(prime_check(2 * 2))\\n        self.assertFalse(prime_check(2 * 3))\\n        self.assertFalse(prime_check(3 * 3))\\n        self.assertFalse(prime_check(3 * 5))\\n        self.assertFalse(prime_check(3 * 5 * 7))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    unittest.main()\\n\"",
    "prime factors": "\"\\\"\\\"\\\"\\npython/black : True\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef prime_factors(n: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    Returns prime factors of n as a list.\\n\\n    >>> prime_factors(0)\\n    []\\n    >>> prime_factors(100)\\n    [2, 2, 5, 5]\\n    >>> prime_factors(2560)\\n    [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]\\n    >>> prime_factors(10**-2)\\n    []\\n    >>> prime_factors(0.02)\\n    []\\n    >>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE\\n    >>> x == [2]*241 + [5]*241\\n    True\\n    >>> prime_factors(10**-354)\\n    []\\n    >>> prime_factors('hello')\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: '<=' not supported between instances of 'int' and 'str'\\n    >>> prime_factors([1,2,'hello'])\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: '<=' not supported between instances of 'int' and 'list'\\n\\n    \\\"\\\"\\\"\\n    i = 2\\n    factors = []\\n    while i * i <= n:\\n        if n % i:\\n            i += 1\\n        else:\\n            n //= i\\n            factors.append(i)\\n    if n > 1:\\n        factors.append(n)\\n    return factors\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "prime numbers": "\"import math\\nfrom typing import Generator\\n\\n\\ndef slow_primes(max: int) -> Generator[int, None, None]:\\n    \\\"\\\"\\\"\\n    Return a list of all primes numbers up to max.\\n    >>> list(slow_primes(0))\\n    []\\n    >>> list(slow_primes(-1))\\n    []\\n    >>> list(slow_primes(-10))\\n    []\\n    >>> list(slow_primes(25))\\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\\n    >>> list(slow_primes(11))\\n    [2, 3, 5, 7, 11]\\n    >>> list(slow_primes(33))\\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\\n    >>> list(slow_primes(10000))[-1]\\n    9973\\n    \\\"\\\"\\\"\\n    numbers: Generator = (i for i in range(1, (max + 1)))\\n    for i in (n for n in numbers if n > 1):\\n        for j in range(2, i):\\n            if (i % j) == 0:\\n                break\\n        else:\\n            yield i\\n\\n\\ndef primes(max: int) -> Generator[int, None, None]:\\n    \\\"\\\"\\\"\\n    Return a list of all primes numbers up to max.\\n    >>> list(primes(0))\\n    []\\n    >>> list(primes(-1))\\n    []\\n    >>> list(primes(-10))\\n    []\\n    >>> list(primes(25))\\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\\n    >>> list(primes(11))\\n    [2, 3, 5, 7, 11]\\n    >>> list(primes(33))\\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\\n    >>> list(primes(10000))[-1]\\n    9973\\n    \\\"\\\"\\\"\\n    numbers: Generator = (i for i in range(1, (max + 1)))\\n    for i in (n for n in numbers if n > 1):\\n        # only need to check for factors up to sqrt(i)\\n        bound = int(math.sqrt(i)) + 1\\n        for j in range(2, bound):\\n            if (i % j) == 0:\\n                break\\n        else:\\n            yield i\\n\\n\\ndef fast_primes(max: int) -> Generator[int, None, None]:\\n    \\\"\\\"\\\"\\n    Return a list of all primes numbers up to max.\\n    >>> list(fast_primes(0))\\n    []\\n    >>> list(fast_primes(-1))\\n    []\\n    >>> list(fast_primes(-10))\\n    []\\n    >>> list(fast_primes(25))\\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\\n    >>> list(fast_primes(11))\\n    [2, 3, 5, 7, 11]\\n    >>> list(fast_primes(33))\\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\\n    >>> list(fast_primes(10000))[-1]\\n    9973\\n    \\\"\\\"\\\"\\n    numbers: Generator = (i for i in range(1, (max + 1), 2))\\n    # It's useless to test even numbers as they will not be prime\\n    if max > 2:\\n        yield 2  # Because 2 will not be tested, it's necessary to yield it now\\n    for i in (n for n in numbers if n > 1):\\n        bound = int(math.sqrt(i)) + 1\\n        for j in range(3, bound, 2):\\n            # As we removed the even numbers, we don't need them now\\n            if (i % j) == 0:\\n                break\\n        else:\\n            yield i\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    number = int(input(\\\"Calculate primes up to:\\\\n>> \\\").strip())\\n    for ret in primes(number):\\n        print(ret)\\n\\n    # Let's benchmark them side-by-side...\\n    from timeit import timeit\\n\\n    print(\\n        timeit(\\n            \\\"slow_primes(1_000_000_000_000)\\\",\\n            setup=\\\"from __main__ import slow_primes\\\",\\n            number=1_000_000,\\n        )\\n    )\\n    print(\\n        timeit(\\n            \\\"primes(1_000_000_000_000)\\\",\\n            setup=\\\"from __main__ import primes\\\",\\n            number=1_000_000,\\n        )\\n    )\\n    print(\\n        timeit(\\n            \\\"fast_primes(1_000_000_000_000)\\\",\\n            setup=\\\"from __main__ import fast_primes\\\",\\n            number=1_000_000,\\n        )\\n    )\\n\"",
    "prime sieve eratosthenes": "\"# flake8: noqa\\n\\n\\\"\\\"\\\"\\nSieve of Eratosthenes\\n\\nInput : n =10\\nOutput: 2 3 5 7\\n\\nInput : n = 20\\nOutput: 2 3 5 7 11 13 17 19\\n\\nyou can read in detail about this at\\nhttps://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\\n\\\"\\\"\\\"\\n\\n\\ndef prime_sieve_eratosthenes(num):\\n    \\\"\\\"\\\"\\n    print the prime numbers up to n\\n\\n    >>> prime_sieve_eratosthenes(10)\\n    2,3,5,7,\\n    >>> prime_sieve_eratosthenes(20)\\n    2,3,5,7,11,13,17,19,\\n    \\\"\\\"\\\"\\n\\n    primes = [True for i in range(num + 1)]\\n    p = 2\\n\\n    while p * p <= num:\\n        if primes[p]:\\n            for i in range(p * p, num + 1, p):\\n                primes[i] = False\\n        p += 1\\n\\n    for prime in range(2, num + 1):\\n        if primes[prime]:\\n            print(prime, end=\\\",\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    num = int(input())\\n\\n    prime_sieve_eratosthenes(num)\\n\"",
    "proth number": "\"\\\"\\\"\\\"\\nCalculate the nth Proth number\\nSource:\\n    https://handwiki.org/wiki/Proth_number\\n\\\"\\\"\\\"\\n\\nimport math\\n\\n\\ndef proth(number: int) -> int:\\n    \\\"\\\"\\\"\\n    :param number: nth number to calculate in the sequence\\n    :return: the nth number in Proth number\\n    Note: indexing starts at 1 i.e. proth(1) gives the first Proth number of 3\\n    >>> proth(6)\\n    25\\n    >>> proth(0)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Input value of [number=0] must be > 0\\n    >>> proth(-1)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Input value of [number=-1] must be > 0\\n    >>> proth(6.0)\\n    Traceback (most recent call last):\\n    ...\\n    TypeError: Input value of [number=6.0] must be an integer\\n    \\\"\\\"\\\"\\n\\n    if not isinstance(number, int):\\n        raise TypeError(f\\\"Input value of [number={number}] must be an integer\\\")\\n\\n    if number < 1:\\n        raise ValueError(f\\\"Input value of [number={number}] must be > 0\\\")\\n    elif number == 1:\\n        return 3\\n    elif number == 2:\\n        return 5\\n    else:\\n        \\\"\\\"\\\"\\n        +1 for binary starting at 0 i.e. 2^0, 2^1, etc.\\n        +1 to start the sequence at the 3rd Proth number\\n        Hence, we have a +2 in the below statement\\n        \\\"\\\"\\\"\\n        block_index = int(math.log(number // 3, 2)) + 2\\n\\n        proth_list = [3, 5]\\n        proth_index = 2\\n        increment = 3\\n        for block in range(1, block_index):\\n            for move in range(increment):\\n                proth_list.append(2 ** (block + 1) + proth_list[proth_index - 1])\\n                proth_index += 1\\n            increment *= 2\\n\\n    return proth_list[number - 1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    for number in range(11):\\n        value = 0\\n        try:\\n            value = proth(number)\\n        except ValueError:\\n            print(f\\\"ValueError: there is no {number}th Proth number\\\")\\n            continue\\n\\n        print(f\\\"The {number}th Proth number: {value}\\\")\\n\"",
    "pythagoras": "\"\\\"\\\"\\\"Uses Pythagoras theorem to calculate the distance between two points in space.\\\"\\\"\\\"\\n\\nimport math\\n\\n\\nclass Point:\\n    def __init__(self, x, y, z):\\n        self.x = x\\n        self.y = y\\n        self.z = z\\n\\n    def __repr__(self) -> str:\\n        return f\\\"Point({self.x}, {self.y}, {self.z})\\\"\\n\\n\\ndef distance(a: Point, b: Point) -> float:\\n    return math.sqrt(abs((b.x - a.x) ** 2 + (b.y - a.y) ** 2 + (b.z - a.z) ** 2))\\n\\n\\ndef test_distance() -> None:\\n    \\\"\\\"\\\"\\n    >>> point1 = Point(2, -1, 7)\\n    >>> point2 = Point(1, -3, 5)\\n    >>> print(f\\\"Distance from {point1} to {point2} is {distance(point1, point2)}\\\")\\n    Distance from Point(2, -1, 7) to Point(1, -3, 5) is 3.0\\n    \\\"\\\"\\\"\\n    pass\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "qr decomposition": "\"import numpy as np\\n\\n\\ndef qr_householder(A):\\n    \\\"\\\"\\\"Return a QR-decomposition of the matrix A using Householder reflection.\\n\\n    The QR-decomposition decomposes the matrix A of shape (m, n) into an\\n    orthogonal matrix Q of shape (m, m) and an upper triangular matrix R of\\n    shape (m, n).  Note that the matrix A does not have to be square.  This\\n    method of decomposing A uses the Householder reflection, which is\\n    numerically stable and of complexity O(n^3).\\n\\n    https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections\\n\\n    Arguments:\\n    A -- a numpy.ndarray of shape (m, n)\\n\\n    Note: several optimizations can be made for numeric efficiency, but this is\\n    intended to demonstrate how it would be represented in a mathematics\\n    textbook.  In cases where efficiency is particularly important, an optimized\\n    version from BLAS should be used.\\n\\n    >>> A = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]], dtype=float)\\n    >>> Q, R = qr_householder(A)\\n\\n    >>> # check that the decomposition is correct\\n    >>> np.allclose(Q@R, A)\\n    True\\n\\n    >>> # check that Q is orthogonal\\n    >>> np.allclose(Q@Q.T, np.eye(A.shape[0]))\\n    True\\n    >>> np.allclose(Q.T@Q, np.eye(A.shape[0]))\\n    True\\n\\n    >>> # check that R is upper triangular\\n    >>> np.allclose(np.triu(R), R)\\n    True\\n    \\\"\\\"\\\"\\n    m, n = A.shape\\n    t = min(m, n)\\n    Q = np.eye(m)\\n    R = A.copy()\\n\\n    for k in range(t - 1):\\n        # select a column of modified matrix A':\\n        x = R[k:, [k]]\\n        # construct first basis vector\\n        e1 = np.zeros_like(x)\\n        e1[0] = 1.0\\n        # determine scaling factor\\n        alpha = np.linalg.norm(x)\\n        # construct vector v for Householder reflection\\n        v = x + np.sign(x[0]) * alpha * e1\\n        v /= np.linalg.norm(v)\\n\\n        # construct the Householder matrix\\n        Q_k = np.eye(m - k) - 2.0 * v @ v.T\\n        # pad with ones and zeros as necessary\\n        Q_k = np.block([[np.eye(k), np.zeros((k, m - k))], [np.zeros((m - k, k)), Q_k]])\\n\\n        Q = Q @ Q_k.T\\n        R = Q_k @ R\\n\\n    return Q, R\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "quadratic equations complex numbers": "\"from __future__ import annotations\\n\\nfrom cmath import sqrt\\n\\n\\ndef quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:\\n    \\\"\\\"\\\"\\n    Given the numerical coefficients a, b and c,\\n    calculates the roots for any quadratic equation of the form ax^2 + bx + c\\n\\n    >>> quadratic_roots(a=1, b=3, c=-4)\\n    (1.0, -4.0)\\n    >>> quadratic_roots(5, 6, 1)\\n    (-0.2, -1.0)\\n    >>> quadratic_roots(1, -6, 25)\\n    ((3+4j), (3-4j))\\n    \\\"\\\"\\\"\\n\\n    if a == 0:\\n        raise ValueError(\\\"Coefficient 'a' must not be zero.\\\")\\n    delta = b * b - 4 * a * c\\n\\n    root_1 = (-b + sqrt(delta)) / (2 * a)\\n    root_2 = (-b - sqrt(delta)) / (2 * a)\\n\\n    return (\\n        root_1.real if not root_1.imag else root_1,\\n        root_2.real if not root_2.imag else root_2,\\n    )\\n\\n\\ndef main():\\n    solution1, solution2 = quadratic_roots(a=5, b=6, c=1)\\n    print(f\\\"The solutions are: {solution1} and {solution2}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "radians": "\"from math import pi\\n\\n\\ndef radians(degree: float) -> float:\\n    \\\"\\\"\\\"\\n    Coverts the given angle from degrees to radians\\n    https://en.wikipedia.org/wiki/Radian\\n\\n    >>> radians(180)\\n    3.141592653589793\\n    >>> radians(92)\\n    1.6057029118347832\\n    >>> radians(274)\\n    4.782202150464463\\n    >>> radians(109.82)\\n    1.9167205845401725\\n\\n    >>> from math import radians as math_radians\\n    >>> all(abs(radians(i)-math_radians(i)) <= 0.00000001  for i in range(-2, 361))\\n    True\\n    \\\"\\\"\\\"\\n\\n    return degree / (180 / pi)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "radix2 fft": "\"\\\"\\\"\\\"\\r\\nFast Polynomial Multiplication using radix-2 fast Fourier Transform.\\r\\n\\\"\\\"\\\"\\r\\n\\r\\nimport mpmath  # for roots of unity\\r\\nimport numpy as np\\r\\n\\r\\n\\r\\nclass FFT:\\r\\n    \\\"\\\"\\\"\\r\\n    Fast Polynomial Multiplication using radix-2 fast Fourier Transform.\\r\\n\\r\\n    Reference:\\r\\n    https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm#The_radix-2_DIT_case\\r\\n\\r\\n    For polynomials of degree m and n the algorithms has complexity\\r\\n    O(n*logn + m*logm)\\r\\n\\r\\n    The main part of the algorithm is split in two parts:\\r\\n        1) __DFT: We compute the discrete fourier transform (DFT) of A and B using a\\r\\n        bottom-up dynamic approach -\\r\\n        2) __multiply: Once we obtain the DFT of A*B, we can similarly\\r\\n        invert it to obtain A*B\\r\\n\\r\\n    The class FFT takes two polynomials A and B with complex coefficients as arguments;\\r\\n    The two polynomials should be represented as a sequence of coefficients starting\\r\\n    from the free term. Thus, for instance x + 2*x^3 could be represented as\\r\\n    [0,1,0,2] or (0,1,0,2). The constructor adds some zeros at the end so that the\\r\\n    polynomials have the same length which is a power of 2 at least the length of\\r\\n    their product.\\r\\n\\r\\n    Example:\\r\\n\\r\\n    Create two polynomials as sequences\\r\\n    >>> A = [0, 1, 0, 2]  # x+2x^3\\r\\n    >>> B = (2, 3, 4, 0)  # 2+3x+4x^2\\r\\n\\r\\n    Create an FFT object with them\\r\\n    >>> x = FFT(A, B)\\r\\n\\r\\n    Print product\\r\\n    >>> print(x.product)  # 2x + 3x^2 + 8x^3 + 4x^4 + 6x^5\\r\\n    [(-0+0j), (2+0j), (3+0j), (8+0j), (6+0j), (8+0j)]\\r\\n\\r\\n    __str__ test\\r\\n    >>> print(x)\\r\\n    A = 0*x^0 + 1*x^1 + 2*x^0 + 3*x^2\\r\\n    B = 0*x^2 + 1*x^3 + 2*x^4\\r\\n    A*B = 0*x^(-0+0j) + 1*x^(2+0j) + 2*x^(3+0j) + 3*x^(8+0j) + 4*x^(6+0j) + 5*x^(8+0j)\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def __init__(self, polyA=None, polyB=None):\\r\\n        # Input as list\\r\\n        self.polyA = list(polyA or [0])[:]\\r\\n        self.polyB = list(polyB or [0])[:]\\r\\n\\r\\n        # Remove leading zero coefficients\\r\\n        while self.polyA[-1] == 0:\\r\\n            self.polyA.pop()\\r\\n        self.len_A = len(self.polyA)\\r\\n\\r\\n        while self.polyB[-1] == 0:\\r\\n            self.polyB.pop()\\r\\n        self.len_B = len(self.polyB)\\r\\n\\r\\n        # Add 0 to make lengths equal a power of 2\\r\\n        self.C_max_length = int(\\r\\n            2 ** np.ceil(np.log2(len(self.polyA) + len(self.polyB) - 1))\\r\\n        )\\r\\n\\r\\n        while len(self.polyA) < self.C_max_length:\\r\\n            self.polyA.append(0)\\r\\n        while len(self.polyB) < self.C_max_length:\\r\\n            self.polyB.append(0)\\r\\n        # A complex root used for the fourier transform\\r\\n        self.root = complex(mpmath.root(x=1, n=self.C_max_length, k=1))\\r\\n\\r\\n        # The product\\r\\n        self.product = self.__multiply()\\r\\n\\r\\n    # Discrete fourier transform of A and B\\r\\n    def __DFT(self, which):\\r\\n        if which == \\\"A\\\":\\r\\n            dft = [[x] for x in self.polyA]\\r\\n        else:\\r\\n            dft = [[x] for x in self.polyB]\\r\\n        # Corner case\\r\\n        if len(dft) <= 1:\\r\\n            return dft[0]\\r\\n        #\\r\\n        next_ncol = self.C_max_length // 2\\r\\n        while next_ncol > 0:\\r\\n            new_dft = [[] for i in range(next_ncol)]\\r\\n            root = self.root ** next_ncol\\r\\n\\r\\n            # First half of next step\\r\\n            current_root = 1\\r\\n            for j in range(self.C_max_length // (next_ncol * 2)):\\r\\n                for i in range(next_ncol):\\r\\n                    new_dft[i].append(dft[i][j] + current_root * dft[i + next_ncol][j])\\r\\n                current_root *= root\\r\\n            # Second half of next step\\r\\n            current_root = 1\\r\\n            for j in range(self.C_max_length // (next_ncol * 2)):\\r\\n                for i in range(next_ncol):\\r\\n                    new_dft[i].append(dft[i][j] - current_root * dft[i + next_ncol][j])\\r\\n                current_root *= root\\r\\n            # Update\\r\\n            dft = new_dft\\r\\n            next_ncol = next_ncol // 2\\r\\n        return dft[0]\\r\\n\\r\\n    # multiply the DFTs of  A and B and find A*B\\r\\n    def __multiply(self):\\r\\n        dftA = self.__DFT(\\\"A\\\")\\r\\n        dftB = self.__DFT(\\\"B\\\")\\r\\n        inverseC = [[dftA[i] * dftB[i] for i in range(self.C_max_length)]]\\r\\n        del dftA\\r\\n        del dftB\\r\\n\\r\\n        # Corner Case\\r\\n        if len(inverseC[0]) <= 1:\\r\\n            return inverseC[0]\\r\\n        # Inverse DFT\\r\\n        next_ncol = 2\\r\\n        while next_ncol <= self.C_max_length:\\r\\n            new_inverseC = [[] for i in range(next_ncol)]\\r\\n            root = self.root ** (next_ncol // 2)\\r\\n            current_root = 1\\r\\n            # First half of next step\\r\\n            for j in range(self.C_max_length // next_ncol):\\r\\n                for i in range(next_ncol // 2):\\r\\n                    # Even positions\\r\\n                    new_inverseC[i].append(\\r\\n                        (\\r\\n                            inverseC[i][j]\\r\\n                            + inverseC[i][j + self.C_max_length // next_ncol]\\r\\n                        )\\r\\n                        / 2\\r\\n                    )\\r\\n                    # Odd positions\\r\\n                    new_inverseC[i + next_ncol // 2].append(\\r\\n                        (\\r\\n                            inverseC[i][j]\\r\\n                            - inverseC[i][j + self.C_max_length // next_ncol]\\r\\n                        )\\r\\n                        / (2 * current_root)\\r\\n                    )\\r\\n                current_root *= root\\r\\n            # Update\\r\\n            inverseC = new_inverseC\\r\\n            next_ncol *= 2\\r\\n        # Unpack\\r\\n        inverseC = [round(x[0].real, 8) + round(x[0].imag, 8) * 1j for x in inverseC]\\r\\n\\r\\n        # Remove leading 0's\\r\\n        while inverseC[-1] == 0:\\r\\n            inverseC.pop()\\r\\n        return inverseC\\r\\n\\r\\n    # Overwrite __str__ for print(); Shows A, B and A*B\\r\\n    def __str__(self):\\r\\n        A = \\\"A = \\\" + \\\" + \\\".join(\\r\\n            f\\\"{coef}*x^{i}\\\" for coef, i in enumerate(self.polyA[: self.len_A])\\r\\n        )\\r\\n        B = \\\"B = \\\" + \\\" + \\\".join(\\r\\n            f\\\"{coef}*x^{i}\\\" for coef, i in enumerate(self.polyB[: self.len_B])\\r\\n        )\\r\\n        C = \\\"A*B = \\\" + \\\" + \\\".join(\\r\\n            f\\\"{coef}*x^{i}\\\" for coef, i in enumerate(self.product)\\r\\n        )\\r\\n\\r\\n        return \\\"\\\\n\\\".join((A, B, C))\\r\\n\\r\\n\\r\\n# Unit tests\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "relu": "\"\\\"\\\"\\\"\\nThis script demonstrates the implementation of the ReLU function.\\n\\nIt's a kind of activation function defined as the positive part of its argument in the\\ncontext of neural network.\\nThe function takes a vector of K real numbers as input and then argmax(x, 0).\\nAfter through ReLU, the element of the vector always 0 or real number.\\n\\nScript inspired from its corresponding Wikipedia article\\nhttps://en.wikipedia.org/wiki/Rectifier_(neural_networks)\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport numpy as np\\n\\n\\ndef relu(vector: list[float]):\\n    \\\"\\\"\\\"\\n    Implements the relu function\\n\\n    Parameters:\\n        vector (np.array,list,tuple): A  numpy array of shape (1,n)\\n        consisting of real values or a similar list,tuple\\n\\n\\n    Returns:\\n        relu_vec (np.array): The input numpy array, after applying\\n        relu.\\n\\n    >>> vec = np.array([-1, 0, 5])\\n    >>> relu(vec)\\n    array([0, 0, 5])\\n    \\\"\\\"\\\"\\n\\n    # compare two arrays and then return element-wise maxima.\\n    return np.maximum(0, vector)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(np.array(relu([-1, 0, 5])))  # --> [0, 0, 5]\\n\"",
    "runge kutta": "\"import numpy as np\\n\\n\\ndef runge_kutta(f, y0, x0, h, x_end):\\n    \\\"\\\"\\\"\\n    Calculate the numeric solution at each step to the ODE f(x, y) using RK4\\n\\n    https://en.wikipedia.org/wiki/Runge-Kutta_methods\\n\\n    Arguments:\\n    f -- The ode as a function of x and y\\n    y0 -- the initial value for y\\n    x0 -- the initial value for x\\n    h -- the stepsize\\n    x_end -- the end value for x\\n\\n    >>> # the exact solution is math.exp(x)\\n    >>> def f(x, y):\\n    ...     return y\\n    >>> y0 = 1\\n    >>> y = runge_kutta(f, y0, 0.0, 0.01, 5)\\n    >>> y[-1]\\n    148.41315904125113\\n    \\\"\\\"\\\"\\n    N = int(np.ceil((x_end - x0) / h))\\n    y = np.zeros((N + 1,))\\n    y[0] = y0\\n    x = x0\\n\\n    for k in range(N):\\n        k1 = f(x, y[k])\\n        k2 = f(x + 0.5 * h, y[k] + 0.5 * h * k1)\\n        k3 = f(x + 0.5 * h, y[k] + 0.5 * h * k2)\\n        k4 = f(x + h, y[k] + h * k3)\\n        y[k + 1] = y[k] + (1 / 6) * h * (k1 + 2 * k2 + 2 * k3 + k4)\\n        x += h\\n\\n    return y\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "segmented sieve": "\"\\\"\\\"\\\"Segmented Sieve.\\\"\\\"\\\"\\r\\n\\r\\nimport math\\r\\n\\r\\n\\r\\ndef sieve(n):\\r\\n    \\\"\\\"\\\"Segmented Sieve.\\\"\\\"\\\"\\r\\n    in_prime = []\\r\\n    start = 2\\r\\n    end = int(math.sqrt(n))  # Size of every segment\\r\\n    temp = [True] * (end + 1)\\r\\n    prime = []\\r\\n\\r\\n    while start <= end:\\r\\n        if temp[start] is True:\\r\\n            in_prime.append(start)\\r\\n            for i in range(start * start, end + 1, start):\\r\\n                if temp[i] is True:\\r\\n                    temp[i] = False\\r\\n        start += 1\\r\\n    prime += in_prime\\r\\n\\r\\n    low = end + 1\\r\\n    high = low + end - 1\\r\\n    if high > n:\\r\\n        high = n\\r\\n\\r\\n    while low <= n:\\r\\n        temp = [True] * (high - low + 1)\\r\\n        for each in in_prime:\\r\\n\\r\\n            t = math.floor(low / each) * each\\r\\n            if t < low:\\r\\n                t += each\\r\\n\\r\\n            for j in range(t, high + 1, each):\\r\\n                temp[j - low] = False\\r\\n\\r\\n        for j in range(len(temp)):\\r\\n            if temp[j] is True:\\r\\n                prime.append(j + low)\\r\\n\\r\\n        low = high + 1\\r\\n        high = low + end - 1\\r\\n        if high > n:\\r\\n            high = n\\r\\n\\r\\n    return prime\\r\\n\\r\\n\\r\\nprint(sieve(10 ** 6))\\r\\n\"",
    "sieve of eratosthenes": "\"\\\"\\\"\\\"\\r\\nSieve of Eratosthones\\r\\n\\r\\nThe sieve of Eratosthenes is an algorithm used to find prime numbers, less than or\\r\\nequal to a given value.\\r\\nIllustration:\\r\\nhttps://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\\r\\nReference: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\\r\\n\\r\\ndoctest provider: Bruno Simas Hadlich (https://github.com/brunohadlich)\\r\\nAlso thanks to Dmitry (https://github.com/LizardWizzard) for finding the problem\\r\\n\\\"\\\"\\\"\\r\\nfrom __future__ import annotations\\r\\n\\r\\nimport math\\r\\n\\r\\n\\r\\ndef prime_sieve(num: int) -> list[int]:\\r\\n    \\\"\\\"\\\"\\r\\n    Returns a list with all prime numbers up to n.\\r\\n\\r\\n    >>> prime_sieve(50)\\r\\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\\r\\n    >>> prime_sieve(25)\\r\\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\\r\\n    >>> prime_sieve(10)\\r\\n    [2, 3, 5, 7]\\r\\n    >>> prime_sieve(9)\\r\\n    [2, 3, 5, 7]\\r\\n    >>> prime_sieve(2)\\r\\n    [2]\\r\\n    >>> prime_sieve(1)\\r\\n    []\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    if num <= 0:\\r\\n        raise ValueError(f\\\"{num}: Invalid input, please enter a positive integer.\\\")\\r\\n\\r\\n    sieve = [True] * (num + 1)\\r\\n    prime = []\\r\\n    start = 2\\r\\n    end = int(math.sqrt(num))\\r\\n\\r\\n    while start <= end:\\r\\n        # If start is a prime\\r\\n        if sieve[start] is True:\\r\\n            prime.append(start)\\r\\n\\r\\n            # Set multiples of start be False\\r\\n            for i in range(start * start, num + 1, start):\\r\\n                if sieve[i] is True:\\r\\n                    sieve[i] = False\\r\\n\\r\\n        start += 1\\r\\n\\r\\n    for j in range(end + 1, num + 1):\\r\\n        if sieve[j] is True:\\r\\n            prime.append(j)\\r\\n\\r\\n    return prime\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    print(prime_sieve(int(input(\\\"Enter a positive integer: \\\").strip())))\\r\\n\"",
    "sigmoid": "\"\\\"\\\"\\\"\\nThis script demonstrates the implementation of the Sigmoid function.\\n\\nThe function takes a vector of K real numbers as input and then 1 / (1 + exp(-x)).\\nAfter through Sigmoid, the element of the vector mostly 0 between 1. or 1 between -1.\\n\\nScript inspired from its corresponding Wikipedia article\\nhttps://en.wikipedia.org/wiki/Sigmoid_function\\n\\\"\\\"\\\"\\n\\nimport numpy as np\\n\\n\\ndef sigmoid(vector: np.array) -> np.array:\\n    \\\"\\\"\\\"\\n    Implements the sigmoid function\\n\\n    Parameters:\\n        vector (np.array): A  numpy array of shape (1,n)\\n        consisting of real values\\n\\n    Returns:\\n        sigmoid_vec (np.array): The input numpy array, after applying\\n        sigmoid.\\n\\n    Examples:\\n    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))\\n    array([0.26894142, 0.73105858, 0.88079708])\\n\\n    >>> sigmoid(np.array([0.0]))\\n    array([0.5])\\n    \\\"\\\"\\\"\\n    return 1 / (1 + np.exp(-vector))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "simpson rule": "\"\\\"\\\"\\\"\\nNumerical integration or quadrature for a smooth function f with known values at x_i\\n\\nThis method is the classical approach of suming 'Equally Spaced Abscissas'\\n\\nmethod 2:\\n\\\"Simpson Rule\\\"\\n\\n\\\"\\\"\\\"\\n\\n\\ndef method_2(boundary, steps):\\n    # \\\"Simpson Rule\\\"\\n    # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)\\n    h = (boundary[1] - boundary[0]) / steps\\n    a = boundary[0]\\n    b = boundary[1]\\n    x_i = make_points(a, b, h)\\n    y = 0.0\\n    y += (h / 3.0) * f(a)\\n    cnt = 2\\n    for i in x_i:\\n        y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)\\n        cnt += 1\\n    y += (h / 3.0) * f(b)\\n    return y\\n\\n\\ndef make_points(a, b, h):\\n    x = a + h\\n    while x < (b - h):\\n        yield x\\n        x = x + h\\n\\n\\ndef f(x):  # enter your function here\\n    y = (x - 0) * (x - 0)\\n    return y\\n\\n\\ndef main():\\n    a = 0.0  # Lower bound of integration\\n    b = 1.0  # Upper bound of integration\\n    steps = 10.0  # define number of steps or resolution\\n    boundary = [a, b]  # define boundary of integration\\n    y = method_2(boundary, steps)\\n    print(f\\\"y = {y}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "sock merchant": "\"from collections import Counter\\n\\n\\ndef sock_merchant(colors: list[int]) -> int:\\n    \\\"\\\"\\\"\\n    >>> sock_merchant([10, 20, 20, 10, 10, 30, 50, 10, 20])\\n    3\\n    >>> sock_merchant([1, 1, 3, 3])\\n    2\\n    \\\"\\\"\\\"\\n    return sum(socks_by_color // 2 for socks_by_color in Counter(colors).values())\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    colors = [int(x) for x in input(\\\"Enter socks by color :\\\").rstrip().split()]\\n    print(f\\\"sock_merchant({colors}) = {sock_merchant(colors)}\\\")\\n\"",
    "softmax": "\"\\\"\\\"\\\"\\nThis script demonstrates the implementation of the Softmax function.\\n\\nIts a function that takes as input a vector of K real numbers, and normalizes\\nit into a probability distribution consisting of K probabilities proportional\\nto the exponentials of the input numbers. After softmax, the elements of the\\nvector always sum up to 1.\\n\\nScript inspired from its corresponding Wikipedia article\\nhttps://en.wikipedia.org/wiki/Softmax_function\\n\\\"\\\"\\\"\\n\\nimport numpy as np\\n\\n\\ndef softmax(vector):\\n    \\\"\\\"\\\"\\n    Implements the softmax function\\n\\n    Parameters:\\n        vector (np.array,list,tuple): A  numpy array of shape (1,n)\\n        consisting of real values or a similar list,tuple\\n\\n\\n    Returns:\\n        softmax_vec (np.array): The input numpy array  after applying\\n        softmax.\\n\\n    The softmax vector adds up to one. We need to ceil to mitigate for\\n    precision\\n    >>> np.ceil(np.sum(softmax([1,2,3,4])))\\n    1.0\\n\\n    >>> vec = np.array([5,5])\\n    >>> softmax(vec)\\n    array([0.5, 0.5])\\n\\n    >>> softmax([0])\\n    array([1.])\\n    \\\"\\\"\\\"\\n\\n    # Calculate e^x for each x in your vector where e is Euler's\\n    # number (approximately 2.718)\\n    exponentVector = np.exp(vector)\\n\\n    # Add up the all the exponentials\\n    sumOfExponents = np.sum(exponentVector)\\n\\n    # Divide every exponent by the sum of all exponents\\n    softmax_vector = exponentVector / sumOfExponents\\n\\n    return softmax_vector\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(softmax((0,)))\\n\"",
    "square root": "\"import math\\n\\n\\ndef fx(x: float, a: float) -> float:\\n    return math.pow(x, 2) - a\\n\\n\\ndef fx_derivative(x: float) -> float:\\n    return 2 * x\\n\\n\\ndef get_initial_point(a: float) -> float:\\n    start = 2.0\\n\\n    while start <= a:\\n        start = math.pow(start, 2)\\n\\n    return start\\n\\n\\ndef square_root_iterative(\\n    a: float, max_iter: int = 9999, tolerance: float = 0.00000000000001\\n) -> float:\\n    \\\"\\\"\\\"\\n    Square root is aproximated using Newtons method.\\n    https://en.wikipedia.org/wiki/Newton%27s_method\\n\\n    >>> all(abs(square_root_iterative(i)-math.sqrt(i)) <= .00000000000001\\n    ...     for i in range(500))\\n    True\\n\\n    >>> square_root_iterative(-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: math domain error\\n\\n    >>> square_root_iterative(4)\\n    2.0\\n\\n    >>> square_root_iterative(3.2)\\n    1.788854381999832\\n\\n    >>> square_root_iterative(140)\\n    11.832159566199232\\n    \\\"\\\"\\\"\\n\\n    if a < 0:\\n        raise ValueError(\\\"math domain error\\\")\\n\\n    value = get_initial_point(a)\\n\\n    for i in range(max_iter):\\n        prev_value = value\\n        value = value - fx(value, a) / fx_derivative(value)\\n        if abs(prev_value - value) < tolerance:\\n            return value\\n\\n    return value\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "sum of arithmetic series": "\"# DarkCoder\\ndef sum_of_series(first_term, common_diff, num_of_terms):\\n    \\\"\\\"\\\"\\n    Find the sum of n terms in an arithmetic progression.\\n\\n    >>> sum_of_series(1, 1, 10)\\n    55.0\\n    >>> sum_of_series(1, 10, 100)\\n    49600.0\\n    \\\"\\\"\\\"\\n    sum = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\\n    # formula for sum of series\\n    return sum\\n\\n\\ndef main():\\n    print(sum_of_series(1, 1, 10))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "sum of digits": "\"from timeit import timeit\\n\\n\\ndef sum_of_digits(n: int) -> int:\\n    \\\"\\\"\\\"\\n    Find the sum of digits of a number.\\n\\n    >>> sum_of_digits(12345)\\n    15\\n    >>> sum_of_digits(123)\\n    6\\n    >>> sum_of_digits(-123)\\n    6\\n    >>> sum_of_digits(0)\\n    0\\n    \\\"\\\"\\\"\\n    n = -n if n < 0 else n\\n    res = 0\\n    while n > 0:\\n        res += n % 10\\n        n = n // 10\\n    return res\\n\\n\\ndef sum_of_digits_recursion(n: int) -> int:\\n    \\\"\\\"\\\"\\n    Find the sum of digits of a number using recursion\\n\\n    >>> sum_of_digits_recursion(12345)\\n    15\\n    >>> sum_of_digits_recursion(123)\\n    6\\n    >>> sum_of_digits_recursion(-123)\\n    6\\n    >>> sum_of_digits_recursion(0)\\n    0\\n    \\\"\\\"\\\"\\n    n = -n if n < 0 else n\\n    return n if n < 10 else n % 10 + sum_of_digits(n // 10)\\n\\n\\ndef sum_of_digits_compact(n: int) -> int:\\n    \\\"\\\"\\\"\\n    Find the sum of digits of a number\\n\\n    >>> sum_of_digits_compact(12345)\\n    15\\n    >>> sum_of_digits_compact(123)\\n    6\\n    >>> sum_of_digits_compact(-123)\\n    6\\n    >>> sum_of_digits_compact(0)\\n    0\\n    \\\"\\\"\\\"\\n    return sum(int(c) for c in str(abs(n)))\\n\\n\\ndef benchmark() -> None:\\n    \\\"\\\"\\\"\\n    Benchmark code for comparing 3 functions,\\n    with 3 different length int values.\\n    \\\"\\\"\\\"\\n    print(\\\"\\\\nFor small_num = \\\", small_num, \\\":\\\")\\n    print(\\n        \\\"> sum_of_digits()\\\",\\n        \\\"\\\\t\\\\tans =\\\",\\n        sum_of_digits(small_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.sum_of_digits(z.small_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> sum_of_digits_recursion()\\\",\\n        \\\"\\\\tans =\\\",\\n        sum_of_digits_recursion(small_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.sum_of_digits_recursion(z.small_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> sum_of_digits_compact()\\\",\\n        \\\"\\\\tans =\\\",\\n        sum_of_digits_compact(small_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.sum_of_digits_compact(z.small_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n\\n    print(\\\"\\\\nFor medium_num = \\\", medium_num, \\\":\\\")\\n    print(\\n        \\\"> sum_of_digits()\\\",\\n        \\\"\\\\t\\\\tans =\\\",\\n        sum_of_digits(medium_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.sum_of_digits(z.medium_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> sum_of_digits_recursion()\\\",\\n        \\\"\\\\tans =\\\",\\n        sum_of_digits_recursion(medium_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.sum_of_digits_recursion(z.medium_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> sum_of_digits_compact()\\\",\\n        \\\"\\\\tans =\\\",\\n        sum_of_digits_compact(medium_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.sum_of_digits_compact(z.medium_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n\\n    print(\\\"\\\\nFor large_num = \\\", large_num, \\\":\\\")\\n    print(\\n        \\\"> sum_of_digits()\\\",\\n        \\\"\\\\t\\\\tans =\\\",\\n        sum_of_digits(large_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.sum_of_digits(z.large_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> sum_of_digits_recursion()\\\",\\n        \\\"\\\\tans =\\\",\\n        sum_of_digits_recursion(large_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.sum_of_digits_recursion(z.large_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> sum_of_digits_compact()\\\",\\n        \\\"\\\\tans =\\\",\\n        sum_of_digits_compact(large_num),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\\"z.sum_of_digits_compact(z.large_num)\\\", setup=\\\"import __main__ as z\\\"),\\n        \\\"seconds\\\",\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    small_num = 262144\\n    medium_num = 1125899906842624\\n    large_num = 1267650600228229401496703205376\\n    benchmark()\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "sum of geometric progression": "\"def sum_of_geometric_progression(\\r\\n    first_term: int, common_ratio: int, num_of_terms: int\\r\\n) -> float:\\r\\n    \\\"\\\"\\\" \\\"\\r\\n    Return the sum of n terms in a geometric progression.\\r\\n    >>> sum_of_geometric_progression(1, 2, 10)\\r\\n    1023.0\\r\\n    >>> sum_of_geometric_progression(1, 10, 5)\\r\\n    11111.0\\r\\n    >>> sum_of_geometric_progression(0, 2, 10)\\r\\n    0.0\\r\\n    >>> sum_of_geometric_progression(1, 0, 10)\\r\\n    1.0\\r\\n    >>> sum_of_geometric_progression(1, 2, 0)\\r\\n    -0.0\\r\\n    >>> sum_of_geometric_progression(-1, 2, 10)\\r\\n    -1023.0\\r\\n    >>> sum_of_geometric_progression(1, -2, 10)\\r\\n    -341.0\\r\\n    >>> sum_of_geometric_progression(1, 2, -10)\\r\\n    -0.9990234375\\r\\n    \\\"\\\"\\\"\\r\\n    if common_ratio == 1:\\r\\n        # Formula for sum if common ratio is 1\\r\\n        return num_of_terms * first_term\\r\\n\\r\\n    # Formula for finding sum of n terms of a GeometricProgression\\r\\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio ** num_of_terms)\\r\\n\"",
    "sylvester sequence": "\"\\\"\\\"\\\"\\n\\nCalculates the nth number in Sylvester's sequence\\n\\nSource:\\n    https://en.wikipedia.org/wiki/Sylvester%27s_sequence\\n\\n\\\"\\\"\\\"\\n\\n\\ndef sylvester(number: int) -> int:\\n    \\\"\\\"\\\"\\n    :param number: nth number to calculate in the sequence\\n    :return: the nth number in Sylvester's sequence\\n\\n    >>> sylvester(8)\\n    113423713055421844361000443\\n\\n    >>> sylvester(-1)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: The input value of [n=-1] has to be > 0\\n\\n    >>> sylvester(8.0)\\n    Traceback (most recent call last):\\n    ...\\n    AssertionError: The input value of [n=8.0] is not an integer\\n    \\\"\\\"\\\"\\n    assert isinstance(number, int), f\\\"The input value of [n={number}] is not an integer\\\"\\n\\n    if number == 1:\\n        return 2\\n    elif number < 1:\\n        raise ValueError(f\\\"The input value of [n={number}] has to be > 0\\\")\\n    else:\\n        num = sylvester(number - 1)\\n        lower = num - 1\\n        upper = num\\n        return lower * upper + 1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(f\\\"The 8th number in Sylvester's sequence: {sylvester(8)}\\\")\\n\"",
    "test prime check": "\"\\\"\\\"\\\"\\nMinimalist file that allows pytest to find and run the Test unittest.  For details, see:\\nhttp://doc.pytest.org/en/latest/goodpractices.html#conventions-for-python-test-discovery\\n\\\"\\\"\\\"\\n\\nfrom .prime_check import Test\\n\\nTest()\\n\"",
    "trapezoidal rule": "\"\\\"\\\"\\\"\\nNumerical integration or quadrature for a smooth function f with known values at x_i\\n\\nThis method is the classical approach of suming 'Equally Spaced Abscissas'\\n\\nmethod 1:\\n\\\"extended trapezoidal rule\\\"\\n\\n\\\"\\\"\\\"\\n\\n\\ndef method_1(boundary, steps):\\n    # \\\"extended trapezoidal rule\\\"\\n    # int(f) = dx/2 * (f1 + 2f2 + ... + fn)\\n    h = (boundary[1] - boundary[0]) / steps\\n    a = boundary[0]\\n    b = boundary[1]\\n    x_i = make_points(a, b, h)\\n    y = 0.0\\n    y += (h / 2.0) * f(a)\\n    for i in x_i:\\n        # print(i)\\n        y += h * f(i)\\n    y += (h / 2.0) * f(b)\\n    return y\\n\\n\\ndef make_points(a, b, h):\\n    x = a + h\\n    while x < (b - h):\\n        yield x\\n        x = x + h\\n\\n\\ndef f(x):  # enter your function here\\n    y = (x - 0) * (x - 0)\\n    return y\\n\\n\\ndef main():\\n    a = 0.0  # Lower bound of integration\\n    b = 1.0  # Upper bound of integration\\n    steps = 10.0  # define number of steps or resolution\\n    boundary = [a, b]  # define boundary of integration\\n    y = method_1(boundary, steps)\\n    print(f\\\"y = {y}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "triplet sum": "\"\\\"\\\"\\\"\\nGiven an array of integers and another integer target,\\nwe are required to find a triplet from the array such that it's sum is equal to\\nthe target.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom itertools import permutations\\nfrom random import randint\\nfrom timeit import repeat\\n\\n\\ndef make_dataset() -> tuple[list[int], int]:\\n    arr = [randint(-1000, 1000) for i in range(10)]\\n    r = randint(-5000, 5000)\\n    return (arr, r)\\n\\n\\ndataset = make_dataset()\\n\\n\\ndef triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:\\n    \\\"\\\"\\\"\\n    Returns a triplet in the array with sum equal to target,\\n    else (0, 0, 0).\\n    >>> triplet_sum1([13, 29, 7, 23, 5], 35)\\n    (5, 7, 23)\\n    >>> triplet_sum1([37, 9, 19, 50, 44], 65)\\n    (9, 19, 37)\\n    >>> arr = [6, 47, 27, 1, 15]\\n    >>> target = 11\\n    >>> triplet_sum1(arr, target)\\n    (0, 0, 0)\\n    \\\"\\\"\\\"\\n    for triplet in permutations(arr, 3):\\n        if sum(triplet) == target:\\n            return tuple(sorted(triplet))\\n    return (0, 0, 0)\\n\\n\\ndef triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:\\n    \\\"\\\"\\\"\\n    Returns a triplet in the array with sum equal to target,\\n    else (0, 0, 0).\\n    >>> triplet_sum2([13, 29, 7, 23, 5], 35)\\n    (5, 7, 23)\\n    >>> triplet_sum2([37, 9, 19, 50, 44], 65)\\n    (9, 19, 37)\\n    >>> arr = [6, 47, 27, 1, 15]\\n    >>> target = 11\\n    >>> triplet_sum2(arr, target)\\n    (0, 0, 0)\\n    \\\"\\\"\\\"\\n    arr.sort()\\n    n = len(arr)\\n    for i in range(n - 1):\\n        left, right = i + 1, n - 1\\n        while left < right:\\n            if arr[i] + arr[left] + arr[right] == target:\\n                return (arr[i], arr[left], arr[right])\\n            elif arr[i] + arr[left] + arr[right] < target:\\n                left += 1\\n            elif arr[i] + arr[left] + arr[right] > target:\\n                right -= 1\\n    return (0, 0, 0)\\n\\n\\ndef solution_times() -> tuple[float, float]:\\n    setup_code = \\\"\\\"\\\"\\nfrom __main__ import dataset, triplet_sum1, triplet_sum2\\n\\\"\\\"\\\"\\n    test_code1 = \\\"\\\"\\\"\\ntriplet_sum1(*dataset)\\n\\\"\\\"\\\"\\n    test_code2 = \\\"\\\"\\\"\\ntriplet_sum2(*dataset)\\n\\\"\\\"\\\"\\n    times1 = repeat(setup=setup_code, stmt=test_code1, repeat=5, number=10000)\\n    times2 = repeat(setup=setup_code, stmt=test_code2, repeat=5, number=10000)\\n    return (min(times1), min(times2))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n    times = solution_times()\\n    print(f\\\"The time for naive implementation is {times[0]}.\\\")\\n    print(f\\\"The time for optimized implementation is {times[1]}.\\\")\\n\"",
    "two pointer": "\"\\\"\\\"\\\"\\nGiven a sorted array of integers, return indices of the two numbers such\\nthat they add up to a specific target using the two pointers technique.\\n\\nYou may assume that each input would have exactly one solution, and you\\nmay not use the same element twice.\\n\\nThis is an alternative solution of the two-sum problem, which uses a\\nmap to solve the problem. Hence can not solve the issue if there is a\\nconstraint not use the same index twice. [1]\\n\\nExample:\\nGiven nums = [2, 7, 11, 15], target = 9,\\n\\nBecause nums[0] + nums[1] = 2 + 7 = 9,\\nreturn [0, 1].\\n\\n[1]: https://github.com/TheAlgorithms/Python/blob/master/other/two_sum.py\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef two_pointer(nums: list[int], target: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    >>> two_pointer([2, 7, 11, 15], 9)\\n    [0, 1]\\n    >>> two_pointer([2, 7, 11, 15], 17)\\n    [0, 3]\\n    >>> two_pointer([2, 7, 11, 15], 18)\\n    [1, 2]\\n    >>> two_pointer([2, 7, 11, 15], 26)\\n    [2, 3]\\n    >>> two_pointer([1, 3, 3], 6)\\n    [1, 2]\\n    >>> two_pointer([2, 7, 11, 15], 8)\\n    []\\n    >>> two_pointer([3 * i for i in range(10)], 19)\\n    []\\n    >>> two_pointer([1, 2, 3], 6)\\n    []\\n    \\\"\\\"\\\"\\n    i = 0\\n    j = len(nums) - 1\\n\\n    while i < j:\\n\\n        if nums[i] + nums[j] == target:\\n            return [i, j]\\n        elif nums[i] + nums[j] < target:\\n            i = i + 1\\n        else:\\n            j = j - 1\\n\\n    return []\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    print(f\\\"{two_pointer([2, 7, 11, 15], 9) = }\\\")\\n\"",
    "two sum": "\"\\\"\\\"\\\"\\nGiven an array of integers, return indices of the two numbers such that they add up to\\na specific target.\\n\\nYou may assume that each input would have exactly one solution, and you may not use the\\nsame element twice.\\n\\nExample:\\nGiven nums = [2, 7, 11, 15], target = 9,\\n\\nBecause nums[0] + nums[1] = 2 + 7 = 9,\\nreturn [0, 1].\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef two_sum(nums: list[int], target: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    >>> two_sum([2, 7, 11, 15], 9)\\n    [0, 1]\\n    >>> two_sum([15, 2, 11, 7], 13)\\n    [1, 2]\\n    >>> two_sum([2, 7, 11, 15], 17)\\n    [0, 3]\\n    >>> two_sum([7, 15, 11, 2], 18)\\n    [0, 2]\\n    >>> two_sum([2, 7, 11, 15], 26)\\n    [2, 3]\\n    >>> two_sum([2, 7, 11, 15], 8)\\n    []\\n    >>> two_sum([3 * i for i in range(10)], 19)\\n    []\\n    \\\"\\\"\\\"\\n    chk_map: dict[int, int] = {}\\n    for index, val in enumerate(nums):\\n        compl = target - val\\n        if compl in chk_map:\\n            return [chk_map[compl], index]\\n        chk_map[val] = index\\n    return []\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    print(f\\\"{two_sum([2, 7, 11, 15], 9) = }\\\")\\n\"",
    "ugly numbers": "\"\\\"\\\"\\\"\\r\\nUgly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence\\r\\n1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, … shows the first 11 ugly numbers. By convention,\\r\\n1 is included.\\r\\nGiven an integer n, we have to find the nth ugly number.\\r\\n\\r\\nFor more details, refer this article\\r\\nhttps://www.geeksforgeeks.org/ugly-numbers/\\r\\n\\\"\\\"\\\"\\r\\n\\r\\n\\r\\ndef ugly_numbers(n: int) -> int:\\r\\n    \\\"\\\"\\\"\\r\\n    Returns the nth ugly number.\\r\\n    >>> ugly_numbers(100)\\r\\n    1536\\r\\n    >>> ugly_numbers(0)\\r\\n    1\\r\\n    >>> ugly_numbers(20)\\r\\n    36\\r\\n    >>> ugly_numbers(-5)\\r\\n    1\\r\\n    >>> ugly_numbers(-5.5)\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    TypeError: 'float' object cannot be interpreted as an integer\\r\\n    \\\"\\\"\\\"\\r\\n    ugly_nums = [1]\\r\\n\\r\\n    i2, i3, i5 = 0, 0, 0\\r\\n    next_2 = ugly_nums[i2] * 2\\r\\n    next_3 = ugly_nums[i3] * 3\\r\\n    next_5 = ugly_nums[i5] * 5\\r\\n\\r\\n    for i in range(1, n):\\r\\n        next_num = min(next_2, next_3, next_5)\\r\\n        ugly_nums.append(next_num)\\r\\n        if next_num == next_2:\\r\\n            i2 += 1\\r\\n            next_2 = ugly_nums[i2] * 2\\r\\n        if next_num == next_3:\\r\\n            i3 += 1\\r\\n            next_3 = ugly_nums[i3] * 3\\r\\n        if next_num == next_5:\\r\\n            i5 += 1\\r\\n            next_5 = ugly_nums[i5] * 5\\r\\n    return ugly_nums[-1]\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    from doctest import testmod\\r\\n\\r\\n    testmod(verbose=True)\\r\\n    print(f\\\"{ugly_numbers(200) = }\\\")\\r\\n\"",
    "volume": "\"\\\"\\\"\\\"\\nFind Volumes of Various Shapes.\\n\\nWikipedia reference: https://en.wikipedia.org/wiki/Volume\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom math import pi, pow\\n\\n\\ndef vol_cube(side_length: int | float) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the Volume of a Cube.\\n\\n    >>> vol_cube(1)\\n    1.0\\n    >>> vol_cube(3)\\n    27.0\\n    \\\"\\\"\\\"\\n    return pow(side_length, 3)\\n\\n\\ndef vol_spherical_cap(height: float, radius: float) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the Volume of the spherical cap.\\n    :return 1/3 pi * height ^ 2 * (3 * radius - height)\\n\\n    >>> vol_spherical_cap(1, 2)\\n    5.235987755982988\\n    \\\"\\\"\\\"\\n    return 1 / 3 * pi * pow(height, 2) * (3 * radius - height)\\n\\n\\ndef vol_spheres_intersect(\\n    radius_1: float, radius_2: float, centers_distance: float\\n) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the volume of the intersection of two spheres.\\n\\n    The intersection is composed by two spherical caps and therefore its volume is the\\n    sum of the volumes of the spherical caps.  First it calculates the heights (h1, h2)\\n    of the the spherical caps, then the two volumes and it returns the sum.\\n    The height formulas are\\n    h1 = (radius_1 - radius_2 + centers_distance)\\n       * (radius_1 + radius_2 - centers_distance)\\n       / (2 * centers_distance)\\n    h2 = (radius_2 - radius_1 + centers_distance)\\n       * (radius_2 + radius_1 - centers_distance)\\n       / (2 * centers_distance)\\n    if centers_distance is 0 then it returns the volume of the smallers sphere\\n    :return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)\\n\\n    >>> vol_spheres_intersect(2, 2, 1)\\n    21.205750411731103\\n    \\\"\\\"\\\"\\n    if centers_distance == 0:\\n        return vol_sphere(min(radius_1, radius_2))\\n\\n    h1 = (\\n        (radius_1 - radius_2 + centers_distance)\\n        * (radius_1 + radius_2 - centers_distance)\\n        / (2 * centers_distance)\\n    )\\n    h2 = (\\n        (radius_2 - radius_1 + centers_distance)\\n        * (radius_2 + radius_1 - centers_distance)\\n        / (2 * centers_distance)\\n    )\\n\\n    return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)\\n\\n\\ndef vol_cuboid(width: float, height: float, length: float) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the Volume of a Cuboid.\\n    :return multiple of width, length and height\\n\\n    >>> vol_cuboid(1, 1, 1)\\n    1.0\\n    >>> vol_cuboid(1, 2, 3)\\n    6.0\\n    \\\"\\\"\\\"\\n    return float(width * height * length)\\n\\n\\ndef vol_cone(area_of_base: float, height: float) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the Volume of a Cone.\\n\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cone\\n    :return (1/3) * area_of_base * height\\n\\n    >>> vol_cone(10, 3)\\n    10.0\\n    >>> vol_cone(1, 1)\\n    0.3333333333333333\\n    \\\"\\\"\\\"\\n    return area_of_base * height / 3.0\\n\\n\\ndef vol_right_circ_cone(radius: float, height: float) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the Volume of a Right Circular Cone.\\n\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cone\\n    :return (1/3) * pi * radius^2 * height\\n\\n    >>> vol_right_circ_cone(2, 3)\\n    12.566370614359172\\n    \\\"\\\"\\\"\\n    return pi * pow(radius, 2) * height / 3.0\\n\\n\\ndef vol_prism(area_of_base: float, height: float) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the Volume of a Prism.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Prism_(geometry)\\n    :return V = Bh\\n\\n    >>> vol_prism(10, 2)\\n    20.0\\n    >>> vol_prism(11, 1)\\n    11.0\\n    \\\"\\\"\\\"\\n    return float(area_of_base * height)\\n\\n\\ndef vol_pyramid(area_of_base: float, height: float) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the Volume of a Pyramid.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Pyramid_(geometry)\\n    :return  (1/3) * Bh\\n\\n    >>> vol_pyramid(10, 3)\\n    10.0\\n    >>> vol_pyramid(1.5, 3)\\n    1.5\\n    \\\"\\\"\\\"\\n    return area_of_base * height / 3.0\\n\\n\\ndef vol_sphere(radius: float) -> float:\\n    \\\"\\\"\\\"\\n    Calculate the Volume of a Sphere.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Sphere\\n    :return (4/3) * pi * r^3\\n\\n    >>> vol_sphere(5)\\n    523.5987755982989\\n    >>> vol_sphere(1)\\n    4.1887902047863905\\n    \\\"\\\"\\\"\\n    return 4 / 3 * pi * pow(radius, 3)\\n\\n\\ndef vol_hemisphere(radius: float):\\n    \\\"\\\"\\\"Calculate the volume of a hemisphere\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Hemisphere\\n    Other references: https://www.cuemath.com/geometry/hemisphere\\n    :return 2/3 * pi * radius^3\\n\\n    >>> vol_hemisphere(1)\\n    2.0943951023931953\\n\\n    >>> vol_hemisphere(7)\\n    718.3775201208659\\n    \\\"\\\"\\\"\\n    return 2 / 3 * pi * pow(radius, 3)\\n\\n\\ndef vol_circular_cylinder(radius: float, height: float) -> float:\\n    \\\"\\\"\\\"Calculate the Volume of a Circular Cylinder.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder\\n    :return pi * radius^2 * height\\n\\n    >>> vol_circular_cylinder(1, 1)\\n    3.141592653589793\\n    >>> vol_circular_cylinder(4, 3)\\n    150.79644737231007\\n    \\\"\\\"\\\"\\n    return pi * pow(radius, 2) * height\\n\\n\\ndef vol_conical_frustum(height: float, radius_1: float, radius_2: float):\\n    \\\"\\\"\\\"Calculate the Volume of a Conical Frustum.\\n    Wikipedia reference: https://en.wikipedia.org/wiki/Frustum\\n    :return 1/3 * pi * height * (radius_1^2 + radius_top^2 + radius_1 * radius_2)\\n\\n    >>> vol_conical_frustum(45, 7, 28)\\n    48490.482608158454\\n\\n    >>> vol_conical_frustum(1, 1, 2)\\n    7.330382858376184\\n    \\\"\\\"\\\"\\n    return (\\n        1\\n        / 3\\n        * pi\\n        * height\\n        * (pow(radius_1, 2) + pow(radius_2, 2) + radius_1 * radius_2)\\n    )\\n\\n\\ndef main():\\n    \\\"\\\"\\\"Print the Results of Various Volume Calculations.\\\"\\\"\\\"\\n    print(\\\"Volumes:\\\")\\n    print(\\\"Cube: \\\" + str(vol_cube(2)))  # = 8\\n    print(\\\"Cuboid: \\\" + str(vol_cuboid(2, 2, 2)))  # = 8\\n    print(\\\"Cone: \\\" + str(vol_cone(2, 2)))  # ~= 1.33\\n    print(\\\"Right Circular Cone: \\\" + str(vol_right_circ_cone(2, 2)))  # ~= 8.38\\n    print(\\\"Prism: \\\" + str(vol_prism(2, 2)))  # = 4\\n    print(\\\"Pyramid: \\\" + str(vol_pyramid(2, 2)))  # ~= 1.33\\n    print(\\\"Sphere: \\\" + str(vol_sphere(2)))  # ~= 33.5\\n    print(\\\"Hemisphere: \\\" + str(vol_hemisphere(2)))  # ~= 16.75\\n    print(\\\"Circular Cylinder: \\\" + str(vol_circular_cylinder(2, 2)))  # ~= 25.1\\n    print(\\\"Conical Frustum: \\\" + str(vol_conical_frustum(2, 2, 4)))  # ~= 58.6\\n    print(\\\"Spherical cap: \\\" + str(vol_spherical_cap(1, 2)))  # ~= 5.24\\n    print(\\\"Spheres intersetion: \\\" + str(vol_spheres_intersect(2, 2, 1)))  # ~= 21.21\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "zellers congruence": "\"import argparse\\nimport datetime\\n\\n\\ndef zeller(date_input: str) -> str:\\n\\n    \\\"\\\"\\\"\\n    Zellers Congruence Algorithm\\n    Find the day of the week for nearly any Gregorian or Julian calendar date\\n\\n    >>> zeller('01-31-2010')\\n    'Your date 01-31-2010, is a Sunday!'\\n\\n    Validate out of range month\\n    >>> zeller('13-31-2010')\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Month must be between 1 - 12\\n    >>> zeller('.2-31-2010')\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: invalid literal for int() with base 10: '.2'\\n\\n    Validate out of range date:\\n    >>> zeller('01-33-2010')\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Date must be between 1 - 31\\n    >>> zeller('01-.4-2010')\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: invalid literal for int() with base 10: '.4'\\n\\n    Validate second separator:\\n    >>> zeller('01-31*2010')\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Date separator must be '-' or '/'\\n\\n    Validate first separator:\\n    >>> zeller('01^31-2010')\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Date separator must be '-' or '/'\\n\\n    Validate out of range year:\\n    >>> zeller('01-31-8999')\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Year out of range. There has to be some sort of limit...right?\\n\\n    Test null input:\\n    >>> zeller()\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: zeller() missing 1 required positional argument: 'date_input'\\n\\n    Test length of date_input:\\n    >>> zeller('')\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Must be 10 characters long\\n    >>> zeller('01-31-19082939')\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Must be 10 characters long\\\"\\\"\\\"\\n\\n    # Days of the week for response\\n    days = {\\n        \\\"0\\\": \\\"Sunday\\\",\\n        \\\"1\\\": \\\"Monday\\\",\\n        \\\"2\\\": \\\"Tuesday\\\",\\n        \\\"3\\\": \\\"Wednesday\\\",\\n        \\\"4\\\": \\\"Thursday\\\",\\n        \\\"5\\\": \\\"Friday\\\",\\n        \\\"6\\\": \\\"Saturday\\\",\\n    }\\n\\n    convert_datetime_days = {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 0}\\n\\n    # Validate\\n    if not 0 < len(date_input) < 11:\\n        raise ValueError(\\\"Must be 10 characters long\\\")\\n\\n    # Get month\\n    m: int = int(date_input[0] + date_input[1])\\n    # Validate\\n    if not 0 < m < 13:\\n        raise ValueError(\\\"Month must be between 1 - 12\\\")\\n\\n    sep_1: str = date_input[2]\\n    # Validate\\n    if sep_1 not in [\\\"-\\\", \\\"/\\\"]:\\n        raise ValueError(\\\"Date separator must be '-' or '/'\\\")\\n\\n    # Get day\\n    d: int = int(date_input[3] + date_input[4])\\n    # Validate\\n    if not 0 < d < 32:\\n        raise ValueError(\\\"Date must be between 1 - 31\\\")\\n\\n    # Get second separator\\n    sep_2: str = date_input[5]\\n    # Validate\\n    if sep_2 not in [\\\"-\\\", \\\"/\\\"]:\\n        raise ValueError(\\\"Date separator must be '-' or '/'\\\")\\n\\n    # Get year\\n    y: int = int(date_input[6] + date_input[7] + date_input[8] + date_input[9])\\n    # Arbitrary year range\\n    if not 45 < y < 8500:\\n        raise ValueError(\\n            \\\"Year out of range. There has to be some sort of limit...right?\\\"\\n        )\\n\\n    # Get datetime obj for validation\\n    dt_ck = datetime.date(int(y), int(m), int(d))\\n\\n    # Start math\\n    if m <= 2:\\n        y = y - 1\\n        m = m + 12\\n    # maths var\\n    c: int = int(str(y)[:2])\\n    k: int = int(str(y)[2:])\\n    t: int = int(2.6 * m - 5.39)\\n    u: int = int(c / 4)\\n    v: int = int(k / 4)\\n    x: int = int(d + k)\\n    z: int = int(t + u + v + x)\\n    w: int = int(z - (2 * c))\\n    f: int = round(w % 7)\\n    # End math\\n\\n    # Validate math\\n    if f != convert_datetime_days[dt_ck.weekday()]:\\n        raise AssertionError(\\\"The date was evaluated incorrectly. Contact developer.\\\")\\n\\n    # Response\\n    response: str = f\\\"Your date {date_input}, is a {days[str(f)]}!\\\"\\n    return response\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    parser = argparse.ArgumentParser(\\n        description=(\\n            \\\"Find out what day of the week nearly any date is or was. Enter \\\"\\n            \\\"date as a string in the mm-dd-yyyy or mm/dd/yyyy format\\\"\\n        )\\n    )\\n    parser.add_argument(\\n        \\\"date_input\\\", type=str, help=\\\"Date as a string (mm-dd-yyyy or mm/dd/yyyy)\\\"\\n    )\\n    args = parser.parse_args()\\n    zeller(args.date_input)\\n\"",
    "count islands in matrix": "\"# An island in matrix is a group of linked areas, all having the same value.\\n# This code counts number of islands in a given matrix, with including diagonal\\n# connections.\\n\\n\\nclass matrix:  # Public class to implement a graph\\n    def __init__(self, row: int, col: int, graph: list):\\n        self.ROW = row\\n        self.COL = col\\n        self.graph = graph\\n\\n    def is_safe(self, i, j, visited) -> bool:\\n        return (\\n            0 <= i < self.ROW\\n            and 0 <= j < self.COL\\n            and not visited[i][j]\\n            and self.graph[i][j]\\n        )\\n\\n    def diffs(self, i, j, visited):  # Checking all 8 elements surrounding nth element\\n        rowNbr = [-1, -1, -1, 0, 0, 1, 1, 1]  # Coordinate order\\n        colNbr = [-1, 0, 1, -1, 1, -1, 0, 1]\\n        visited[i][j] = True  # Make those cells visited\\n        for k in range(8):\\n            if self.is_safe(i + rowNbr[k], j + colNbr[k], visited):\\n                self.diffs(i + rowNbr[k], j + colNbr[k], visited)\\n\\n    def count_islands(self) -> int:  # And finally, count all islands.\\n        visited = [[False for j in range(self.COL)] for i in range(self.ROW)]\\n        count = 0\\n        for i in range(self.ROW):\\n            for j in range(self.COL):\\n                if visited[i][j] is False and self.graph[i][j] == 1:\\n                    self.diffs(i, j, visited)\\n                    count += 1\\n        return count\\n\"",
    "inverse of matrix": "\"from __future__ import annotations\\r\\n\\r\\nfrom decimal import Decimal\\r\\n\\r\\n\\r\\ndef inverse_of_matrix(matrix: list[list[float]]) -> list[list[float]]:\\r\\n    \\\"\\\"\\\"\\r\\n    A matrix multiplied with its inverse gives the identity matrix.\\r\\n    This function finds the inverse of a 2x2 matrix.\\r\\n    If the determinant of a matrix is 0, its inverse does not exist.\\r\\n\\r\\n    Sources for fixing inaccurate float arithmetic:\\r\\n    https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python\\r\\n    https://docs.python.org/3/library/decimal.html\\r\\n\\r\\n    >>> inverse_of_matrix([[2, 5], [2, 0]])\\r\\n    [[0.0, 0.5], [0.2, -0.2]]\\r\\n    >>> inverse_of_matrix([[2.5, 5], [1, 2]])\\r\\n    Traceback (most recent call last):\\r\\n    ...\\r\\n    ValueError: This matrix has no inverse.\\r\\n    >>> inverse_of_matrix([[12, -16], [-9, 0]])\\r\\n    [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]\\r\\n    >>> inverse_of_matrix([[12, 3], [16, 8]])\\r\\n    [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]\\r\\n    >>> inverse_of_matrix([[10, 5], [3, 2.5]])\\r\\n    [[0.25, -0.5], [-0.3, 1.0]]\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    D = Decimal  # An abbreviation to be conciseness\\r\\n    # Calculate the determinant of the matrix\\r\\n    determinant = D(matrix[0][0]) * D(matrix[1][1]) - D(matrix[1][0]) * D(matrix[0][1])\\r\\n    if determinant == 0:\\r\\n        raise ValueError(\\\"This matrix has no inverse.\\\")\\r\\n    # Creates a copy of the matrix with swapped positions of the elements\\r\\n    swapped_matrix = [[0.0, 0.0], [0.0, 0.0]]\\r\\n    swapped_matrix[0][0], swapped_matrix[1][1] = matrix[1][1], matrix[0][0]\\r\\n    swapped_matrix[1][0], swapped_matrix[0][1] = -matrix[1][0], -matrix[0][1]\\r\\n    # Calculate the inverse of the matrix\\r\\n    return [[float(D(n) / determinant) or 0.0 for n in row] for row in swapped_matrix]\\r\\n\"",
    "matrix class": "\"# An OOP approach to representing and manipulating matrices\\r\\n\\r\\n\\r\\nclass Matrix:\\r\\n    \\\"\\\"\\\"\\r\\n    Matrix object generated from a 2D array where each element is an array representing\\r\\n    a row.\\r\\n    Rows can contain type int or float.\\r\\n    Common operations and information available.\\r\\n    >>> rows = [\\r\\n    ...     [1, 2, 3],\\r\\n    ...     [4, 5, 6],\\r\\n    ...     [7, 8, 9]\\r\\n    ... ]\\r\\n    >>> matrix = Matrix(rows)\\r\\n    >>> print(matrix)\\r\\n    [[1. 2. 3.]\\r\\n     [4. 5. 6.]\\r\\n     [7. 8. 9.]]\\r\\n\\r\\n    Matrix rows and columns are available as 2D arrays\\r\\n    >>> print(matrix.rows)\\r\\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\\r\\n    >>> print(matrix.columns())\\r\\n    [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\\r\\n\\r\\n    Order is returned as a tuple\\r\\n    >>> matrix.order\\r\\n    (3, 3)\\r\\n\\r\\n    Squareness and invertability are represented as bool\\r\\n    >>> matrix.is_square\\r\\n    True\\r\\n    >>> matrix.is_invertable()\\r\\n    False\\r\\n\\r\\n    Identity, Minors, Cofactors and Adjugate are returned as Matrices.  Inverse can be\\r\\n    a Matrix or Nonetype\\r\\n    >>> print(matrix.identity())\\r\\n    [[1. 0. 0.]\\r\\n     [0. 1. 0.]\\r\\n     [0. 0. 1.]]\\r\\n    >>> print(matrix.minors())\\r\\n    [[-3. -6. -3.]\\r\\n     [-6. -12. -6.]\\r\\n     [-3. -6. -3.]]\\r\\n    >>> print(matrix.cofactors())\\r\\n    [[-3. 6. -3.]\\r\\n     [6. -12. 6.]\\r\\n     [-3. 6. -3.]]\\r\\n    >>>  # won't be apparent due to the nature of the cofactor matrix\\r\\n    >>> print(matrix.adjugate())\\r\\n    [[-3. 6. -3.]\\r\\n     [6. -12. 6.]\\r\\n     [-3. 6. -3.]]\\r\\n    >>> print(matrix.inverse())\\r\\n    None\\r\\n\\r\\n    Determinant is an int, float, or Nonetype\\r\\n    >>> matrix.determinant()\\r\\n    0\\r\\n\\r\\n    Negation, scalar multiplication, addition, subtraction, multiplication and\\r\\n    exponentiation are available and all return a Matrix\\r\\n    >>> print(-matrix)\\r\\n    [[-1. -2. -3.]\\r\\n     [-4. -5. -6.]\\r\\n     [-7. -8. -9.]]\\r\\n    >>> matrix2 = matrix * 3\\r\\n    >>> print(matrix2)\\r\\n    [[3. 6. 9.]\\r\\n     [12. 15. 18.]\\r\\n     [21. 24. 27.]]\\r\\n    >>> print(matrix + matrix2)\\r\\n    [[4. 8. 12.]\\r\\n     [16. 20. 24.]\\r\\n     [28. 32. 36.]]\\r\\n    >>> print(matrix - matrix2)\\r\\n    [[-2. -4. -6.]\\r\\n     [-8. -10. -12.]\\r\\n     [-14. -16. -18.]]\\r\\n    >>> print(matrix ** 3)\\r\\n    [[468. 576. 684.]\\r\\n     [1062. 1305. 1548.]\\r\\n     [1656. 2034. 2412.]]\\r\\n\\r\\n    Matrices can also be modified\\r\\n    >>> matrix.add_row([10, 11, 12])\\r\\n    >>> print(matrix)\\r\\n    [[1. 2. 3.]\\r\\n     [4. 5. 6.]\\r\\n     [7. 8. 9.]\\r\\n     [10. 11. 12.]]\\r\\n    >>> matrix2.add_column([8, 16, 32])\\r\\n    >>> print(matrix2)\\r\\n    [[3. 6. 9. 8.]\\r\\n     [12. 15. 18. 16.]\\r\\n     [21. 24. 27. 32.]]\\r\\n    >>> print(matrix *  matrix2)\\r\\n    [[90. 108. 126. 136.]\\r\\n     [198. 243. 288. 304.]\\r\\n     [306. 378. 450. 472.]\\r\\n     [414. 513. 612. 640.]]\\r\\n\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def __init__(self, rows):\\r\\n        error = TypeError(\\r\\n            \\\"Matrices must be formed from a list of zero or more lists containing at \\\"\\r\\n            \\\"least one and the same number of values, each of which must be of type \\\"\\r\\n            \\\"int or float.\\\"\\r\\n        )\\r\\n        if len(rows) != 0:\\r\\n            cols = len(rows[0])\\r\\n            if cols == 0:\\r\\n                raise error\\r\\n            for row in rows:\\r\\n                if len(row) != cols:\\r\\n                    raise error\\r\\n                for value in row:\\r\\n                    if not isinstance(value, (int, float)):\\r\\n                        raise error\\r\\n            self.rows = rows\\r\\n        else:\\r\\n            self.rows = []\\r\\n\\r\\n    # MATRIX INFORMATION\\r\\n    def columns(self):\\r\\n        return [[row[i] for row in self.rows] for i in range(len(self.rows[0]))]\\r\\n\\r\\n    @property\\r\\n    def num_rows(self):\\r\\n        return len(self.rows)\\r\\n\\r\\n    @property\\r\\n    def num_columns(self):\\r\\n        return len(self.rows[0])\\r\\n\\r\\n    @property\\r\\n    def order(self):\\r\\n        return (self.num_rows, self.num_columns)\\r\\n\\r\\n    @property\\r\\n    def is_square(self):\\r\\n        return self.order[0] == self.order[1]\\r\\n\\r\\n    def identity(self):\\r\\n        values = [\\r\\n            [0 if column_num != row_num else 1 for column_num in range(self.num_rows)]\\r\\n            for row_num in range(self.num_rows)\\r\\n        ]\\r\\n        return Matrix(values)\\r\\n\\r\\n    def determinant(self):\\r\\n        if not self.is_square:\\r\\n            return None\\r\\n        if self.order == (0, 0):\\r\\n            return 1\\r\\n        if self.order == (1, 1):\\r\\n            return self.rows[0][0]\\r\\n        if self.order == (2, 2):\\r\\n            return (self.rows[0][0] * self.rows[1][1]) - (\\r\\n                self.rows[0][1] * self.rows[1][0]\\r\\n            )\\r\\n        else:\\r\\n            return sum(\\r\\n                self.rows[0][column] * self.cofactors().rows[0][column]\\r\\n                for column in range(self.num_columns)\\r\\n            )\\r\\n\\r\\n    def is_invertable(self):\\r\\n        return bool(self.determinant())\\r\\n\\r\\n    def get_minor(self, row, column):\\r\\n        values = [\\r\\n            [\\r\\n                self.rows[other_row][other_column]\\r\\n                for other_column in range(self.num_columns)\\r\\n                if other_column != column\\r\\n            ]\\r\\n            for other_row in range(self.num_rows)\\r\\n            if other_row != row\\r\\n        ]\\r\\n        return Matrix(values).determinant()\\r\\n\\r\\n    def get_cofactor(self, row, column):\\r\\n        if (row + column) % 2 == 0:\\r\\n            return self.get_minor(row, column)\\r\\n        return -1 * self.get_minor(row, column)\\r\\n\\r\\n    def minors(self):\\r\\n        return Matrix(\\r\\n            [\\r\\n                [self.get_minor(row, column) for column in range(self.num_columns)]\\r\\n                for row in range(self.num_rows)\\r\\n            ]\\r\\n        )\\r\\n\\r\\n    def cofactors(self):\\r\\n        return Matrix(\\r\\n            [\\r\\n                [\\r\\n                    self.minors().rows[row][column]\\r\\n                    if (row + column) % 2 == 0\\r\\n                    else self.minors().rows[row][column] * -1\\r\\n                    for column in range(self.minors().num_columns)\\r\\n                ]\\r\\n                for row in range(self.minors().num_rows)\\r\\n            ]\\r\\n        )\\r\\n\\r\\n    def adjugate(self):\\r\\n        values = [\\r\\n            [self.cofactors().rows[column][row] for column in range(self.num_columns)]\\r\\n            for row in range(self.num_rows)\\r\\n        ]\\r\\n        return Matrix(values)\\r\\n\\r\\n    def inverse(self):\\r\\n        determinant = self.determinant()\\r\\n        return None if not determinant else self.adjugate() * (1 / determinant)\\r\\n\\r\\n    def __repr__(self):\\r\\n        return str(self.rows)\\r\\n\\r\\n    def __str__(self):\\r\\n        if self.num_rows == 0:\\r\\n            return \\\"[]\\\"\\r\\n        if self.num_rows == 1:\\r\\n            return \\\"[[\\\" + \\\". \\\".join(self.rows[0]) + \\\"]]\\\"\\r\\n        return (\\r\\n            \\\"[\\\"\\r\\n            + \\\"\\\\n \\\".join(\\r\\n                [\\r\\n                    \\\"[\\\" + \\\". \\\".join([str(value) for value in row]) + \\\".]\\\"\\r\\n                    for row in self.rows\\r\\n                ]\\r\\n            )\\r\\n            + \\\"]\\\"\\r\\n        )\\r\\n\\r\\n    # MATRIX MANIPULATION\\r\\n    def add_row(self, row, position=None):\\r\\n        type_error = TypeError(\\\"Row must be a list containing all ints and/or floats\\\")\\r\\n        if not isinstance(row, list):\\r\\n            raise type_error\\r\\n        for value in row:\\r\\n            if not isinstance(value, (int, float)):\\r\\n                raise type_error\\r\\n        if len(row) != self.num_columns:\\r\\n            raise ValueError(\\r\\n                \\\"Row must be equal in length to the other rows in the matrix\\\"\\r\\n            )\\r\\n        if position is None:\\r\\n            self.rows.append(row)\\r\\n        else:\\r\\n            self.rows = self.rows[0:position] + [row] + self.rows[position:]\\r\\n\\r\\n    def add_column(self, column, position=None):\\r\\n        type_error = TypeError(\\r\\n            \\\"Column must be a list containing all ints and/or floats\\\"\\r\\n        )\\r\\n        if not isinstance(column, list):\\r\\n            raise type_error\\r\\n        for value in column:\\r\\n            if not isinstance(value, (int, float)):\\r\\n                raise type_error\\r\\n        if len(column) != self.num_rows:\\r\\n            raise ValueError(\\r\\n                \\\"Column must be equal in length to the other columns in the matrix\\\"\\r\\n            )\\r\\n        if position is None:\\r\\n            self.rows = [self.rows[i] + [column[i]] for i in range(self.num_rows)]\\r\\n        else:\\r\\n            self.rows = [\\r\\n                self.rows[i][0:position] + [column[i]] + self.rows[i][position:]\\r\\n                for i in range(self.num_rows)\\r\\n            ]\\r\\n\\r\\n    # MATRIX OPERATIONS\\r\\n    def __eq__(self, other):\\r\\n        if not isinstance(other, Matrix):\\r\\n            raise TypeError(\\\"A Matrix can only be compared with another Matrix\\\")\\r\\n        return self.rows == other.rows\\r\\n\\r\\n    def __ne__(self, other):\\r\\n        return not self == other\\r\\n\\r\\n    def __neg__(self):\\r\\n        return self * -1\\r\\n\\r\\n    def __add__(self, other):\\r\\n        if self.order != other.order:\\r\\n            raise ValueError(\\\"Addition requires matrices of the same order\\\")\\r\\n        return Matrix(\\r\\n            [\\r\\n                [self.rows[i][j] + other.rows[i][j] for j in range(self.num_columns)]\\r\\n                for i in range(self.num_rows)\\r\\n            ]\\r\\n        )\\r\\n\\r\\n    def __sub__(self, other):\\r\\n        if self.order != other.order:\\r\\n            raise ValueError(\\\"Subtraction requires matrices of the same order\\\")\\r\\n        return Matrix(\\r\\n            [\\r\\n                [self.rows[i][j] - other.rows[i][j] for j in range(self.num_columns)]\\r\\n                for i in range(self.num_rows)\\r\\n            ]\\r\\n        )\\r\\n\\r\\n    def __mul__(self, other):\\r\\n        if isinstance(other, (int, float)):\\r\\n            return Matrix([[element * other for element in row] for row in self.rows])\\r\\n        elif isinstance(other, Matrix):\\r\\n            if self.num_columns != other.num_rows:\\r\\n                raise ValueError(\\r\\n                    \\\"The number of columns in the first matrix must \\\"\\r\\n                    \\\"be equal to the number of rows in the second\\\"\\r\\n                )\\r\\n            return Matrix(\\r\\n                [\\r\\n                    [Matrix.dot_product(row, column) for column in other.columns()]\\r\\n                    for row in self.rows\\r\\n                ]\\r\\n            )\\r\\n        else:\\r\\n            raise TypeError(\\r\\n                \\\"A Matrix can only be multiplied by an int, float, or another matrix\\\"\\r\\n            )\\r\\n\\r\\n    def __pow__(self, other):\\r\\n        if not isinstance(other, int):\\r\\n            raise TypeError(\\\"A Matrix can only be raised to the power of an int\\\")\\r\\n        if not self.is_square:\\r\\n            raise ValueError(\\\"Only square matrices can be raised to a power\\\")\\r\\n        if other == 0:\\r\\n            return self.identity()\\r\\n        if other < 0:\\r\\n            if self.is_invertable:\\r\\n                return self.inverse() ** (-other)\\r\\n            raise ValueError(\\r\\n                \\\"Only invertable matrices can be raised to a negative power\\\"\\r\\n            )\\r\\n        result = self\\r\\n        for i in range(other - 1):\\r\\n            result *= self\\r\\n        return result\\r\\n\\r\\n    @classmethod\\r\\n    def dot_product(cls, row, column):\\r\\n        return sum(row[i] * column[i] for i in range(len(row)))\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "matrix operation": "\"\\\"\\\"\\\"\\nFunctions for 2D matrix operations\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\n\\ndef add(*matrix_s: list[list]) -> list[list]:\\n    \\\"\\\"\\\"\\n    >>> add([[1,2],[3,4]],[[2,3],[4,5]])\\n    [[3, 5], [7, 9]]\\n    >>> add([[1.2,2.4],[3,4]],[[2,3],[4,5]])\\n    [[3.2, 5.4], [7, 9]]\\n    >>> add([[1, 2], [4, 5]], [[3, 7], [3, 4]], [[3, 5], [5, 7]])\\n    [[7, 14], [12, 16]]\\n    >>> add([3], [4, 5])\\n    Traceback (most recent call last):\\n      ...\\n    TypeError: Expected a matrix, got int/list instead\\n    \\\"\\\"\\\"\\n    if all(_check_not_integer(m) for m in matrix_s):\\n        for i in matrix_s[1:]:\\n            _verify_matrix_sizes(matrix_s[0], i)\\n        return [[sum(t) for t in zip(*m)] for m in zip(*matrix_s)]\\n    raise TypeError(\\\"Expected a matrix, got int/list instead\\\")\\n\\n\\ndef subtract(matrix_a: list[list], matrix_b: list[list]) -> list[list]:\\n    \\\"\\\"\\\"\\n    >>> subtract([[1,2],[3,4]],[[2,3],[4,5]])\\n    [[-1, -1], [-1, -1]]\\n    >>> subtract([[1,2.5],[3,4]],[[2,3],[4,5.5]])\\n    [[-1, -0.5], [-1, -1.5]]\\n    >>> subtract([3], [4, 5])\\n    Traceback (most recent call last):\\n      ...\\n    TypeError: Expected a matrix, got int/list instead\\n    \\\"\\\"\\\"\\n    if (\\n        _check_not_integer(matrix_a)\\n        and _check_not_integer(matrix_b)\\n        and _verify_matrix_sizes(matrix_a, matrix_b)\\n    ):\\n        return [[i - j for i, j in zip(*m)] for m in zip(matrix_a, matrix_b)]\\n    raise TypeError(\\\"Expected a matrix, got int/list instead\\\")\\n\\n\\ndef scalar_multiply(matrix: list[list], n: int | float) -> list[list]:\\n    \\\"\\\"\\\"\\n    >>> scalar_multiply([[1,2],[3,4]],5)\\n    [[5, 10], [15, 20]]\\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\\n    [[7.0, 11.5], [15, 20]]\\n    \\\"\\\"\\\"\\n    return [[x * n for x in row] for row in matrix]\\n\\n\\ndef multiply(matrix_a: list[list], matrix_b: list[list]) -> list[list]:\\n    \\\"\\\"\\\"\\n    >>> multiply([[1,2],[3,4]],[[5,5],[7,5]])\\n    [[19, 15], [43, 35]]\\n    >>> multiply([[1,2.5],[3,4.5]],[[5,5],[7,5]])\\n    [[22.5, 17.5], [46.5, 37.5]]\\n    >>> multiply([[1, 2, 3]], [[2], [3], [4]])\\n    [[20]]\\n    \\\"\\\"\\\"\\n    if _check_not_integer(matrix_a) and _check_not_integer(matrix_b):\\n        rows, cols = _verify_matrix_sizes(matrix_a, matrix_b)\\n\\n    if cols[0] != rows[1]:\\n        raise ValueError(\\n            f\\\"Cannot multiply matrix of dimensions ({rows[0]},{cols[0]}) \\\"\\n            f\\\"and ({rows[1]},{cols[1]})\\\"\\n        )\\n    return [\\n        [sum(m * n for m, n in zip(i, j)) for j in zip(*matrix_b)] for i in matrix_a\\n    ]\\n\\n\\ndef identity(n: int) -> list[list]:\\n    \\\"\\\"\\\"\\n    :param n: dimension for nxn matrix\\n    :type n: int\\n    :return: Identity matrix of shape [n, n]\\n    >>> identity(3)\\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\\n    \\\"\\\"\\\"\\n    n = int(n)\\n    return [[int(row == column) for column in range(n)] for row in range(n)]\\n\\n\\ndef transpose(matrix: list[list], return_map: bool = True) -> list[list] | map[list]:\\n    \\\"\\\"\\\"\\n    >>> transpose([[1,2],[3,4]]) # doctest: +ELLIPSIS\\n    <map object at ...\\n    >>> transpose([[1,2],[3,4]], return_map=False)\\n    [[1, 3], [2, 4]]\\n    >>> transpose([1, [2, 3]])\\n    Traceback (most recent call last):\\n      ...\\n    TypeError: Expected a matrix, got int/list instead\\n    \\\"\\\"\\\"\\n    if _check_not_integer(matrix):\\n        if return_map:\\n            return map(list, zip(*matrix))\\n        else:\\n            return list(map(list, zip(*matrix)))\\n    raise TypeError(\\\"Expected a matrix, got int/list instead\\\")\\n\\n\\ndef minor(matrix: list[list], row: int, column: int) -> list[list]:\\n    \\\"\\\"\\\"\\n    >>> minor([[1, 2], [3, 4]], 1, 1)\\n    [[1]]\\n    \\\"\\\"\\\"\\n    minor = matrix[:row] + matrix[row + 1 :]\\n    return [row[:column] + row[column + 1 :] for row in minor]\\n\\n\\ndef determinant(matrix: list[list]) -> int:\\n    \\\"\\\"\\\"\\n    >>> determinant([[1, 2], [3, 4]])\\n    -2\\n    >>> determinant([[1.5, 2.5], [3, 4]])\\n    -1.5\\n    \\\"\\\"\\\"\\n    if len(matrix) == 1:\\n        return matrix[0][0]\\n\\n    return sum(\\n        x * determinant(minor(matrix, 0, i)) * (-1) ** i\\n        for i, x in enumerate(matrix[0])\\n    )\\n\\n\\ndef inverse(matrix: list[list]) -> list[list] | None:\\n    \\\"\\\"\\\"\\n    >>> inverse([[1, 2], [3, 4]])\\n    [[-2.0, 1.0], [1.5, -0.5]]\\n    >>> inverse([[1, 1], [1, 1]])\\n    \\\"\\\"\\\"\\n    # https://stackoverflow.com/questions/20047519/python-doctests-test-for-none\\n    det = determinant(matrix)\\n    if det == 0:\\n        return None\\n\\n    matrix_minor = [\\n        [determinant(minor(matrix, i, j)) for j in range(len(matrix))]\\n        for i in range(len(matrix))\\n    ]\\n\\n    cofactors = [\\n        [x * (-1) ** (row + col) for col, x in enumerate(matrix_minor[row])]\\n        for row in range(len(matrix))\\n    ]\\n    adjugate = list(transpose(cofactors))\\n    return scalar_multiply(adjugate, 1 / det)\\n\\n\\ndef _check_not_integer(matrix: list[list]) -> bool:\\n    return not isinstance(matrix, int) and not isinstance(matrix[0], int)\\n\\n\\ndef _shape(matrix: list[list]) -> tuple[int, int]:\\n    return len(matrix), len(matrix[0])\\n\\n\\ndef _verify_matrix_sizes(\\n    matrix_a: list[list], matrix_b: list[list]\\n) -> tuple[tuple, tuple]:\\n    shape = _shape(matrix_a) + _shape(matrix_b)\\n    if shape[0] != shape[3] or shape[1] != shape[2]:\\n        raise ValueError(\\n            f\\\"operands could not be broadcast together with shape \\\"\\n            f\\\"({shape[0], shape[1]}), ({shape[2], shape[3]})\\\"\\n        )\\n    return (shape[0], shape[2]), (shape[1], shape[3])\\n\\n\\ndef main():\\n    matrix_a = [[12, 10], [3, 9]]\\n    matrix_b = [[3, 4], [7, 4]]\\n    matrix_c = [[11, 12, 13, 14], [21, 22, 23, 24], [31, 32, 33, 34], [41, 42, 43, 44]]\\n    matrix_d = [[3, 0, 2], [2, 0, -2], [0, 1, 1]]\\n    print(f\\\"Add Operation, {add(matrix_a, matrix_b) = } \\\\n\\\")\\n    print(\\n        f\\\"Multiply Operation, {multiply(matrix_a, matrix_b) = } \\\\n\\\",\\n    )\\n    print(f\\\"Identity: {identity(5)}\\\\n\\\")\\n    print(f\\\"Minor of {matrix_c} = {minor(matrix_c, 1, 2)} \\\\n\\\")\\n    print(f\\\"Determinant of {matrix_b} = {determinant(matrix_b)} \\\\n\\\")\\n    print(f\\\"Inverse of {matrix_d} = {inverse(matrix_d)}\\\\n\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "nth fibonacci using matrix exponentiation": "\"\\\"\\\"\\\"\\nImplementation of finding nth fibonacci number using matrix exponentiation.\\nTime Complexity is about O(log(n)*8), where 8 is the complexity of matrix\\nmultiplication of size 2 by 2.\\nAnd on the other hand complexity of bruteforce solution is O(n).\\nAs we know\\n    f[n] = f[n-1] + f[n-1]\\nConverting to matrix,\\n    [f(n),f(n-1)] = [[1,1],[1,0]] * [f(n-1),f(n-2)]\\n->  [f(n),f(n-1)] = [[1,1],[1,0]]^2 * [f(n-2),f(n-3)]\\n    ...\\n    ...\\n->  [f(n),f(n-1)] = [[1,1],[1,0]]^(n-1) * [f(1),f(0)]\\nSo we just need the n times multiplication of the matrix [1,1],[1,0]].\\nWe can decrease the n times multiplication by following the divide and conquer approach.\\n\\\"\\\"\\\"\\n\\n\\ndef multiply(matrix_a, matrix_b):\\n    matrix_c = []\\n    n = len(matrix_a)\\n    for i in range(n):\\n        list_1 = []\\n        for j in range(n):\\n            val = 0\\n            for k in range(n):\\n                val = val + matrix_a[i][k] * matrix_b[k][j]\\n            list_1.append(val)\\n        matrix_c.append(list_1)\\n    return matrix_c\\n\\n\\ndef identity(n):\\n    return [[int(row == column) for column in range(n)] for row in range(n)]\\n\\n\\ndef nth_fibonacci_matrix(n):\\n    \\\"\\\"\\\"\\n    >>> nth_fibonacci_matrix(100)\\n    354224848179261915075\\n    >>> nth_fibonacci_matrix(-100)\\n    -100\\n    \\\"\\\"\\\"\\n    if n <= 1:\\n        return n\\n    res_matrix = identity(2)\\n    fibonacci_matrix = [[1, 1], [1, 0]]\\n    n = n - 1\\n    while n > 0:\\n        if n % 2 == 1:\\n            res_matrix = multiply(res_matrix, fibonacci_matrix)\\n        fibonacci_matrix = multiply(fibonacci_matrix, fibonacci_matrix)\\n        n = int(n / 2)\\n    return res_matrix[0][0]\\n\\n\\ndef nth_fibonacci_bruteforce(n):\\n    \\\"\\\"\\\"\\n    >>> nth_fibonacci_bruteforce(100)\\n    354224848179261915075\\n    >>> nth_fibonacci_bruteforce(-100)\\n    -100\\n    \\\"\\\"\\\"\\n    if n <= 1:\\n        return n\\n    fib0 = 0\\n    fib1 = 1\\n    for i in range(2, n + 1):\\n        fib0, fib1 = fib1, fib0 + fib1\\n    return fib1\\n\\n\\ndef main():\\n    for ordinal in \\\"0th 1st 2nd 3rd 10th 100th 1000th\\\".split():\\n        n = int(\\\"\\\".join(c for c in ordinal if c in \\\"0123456789\\\"))  # 1000th --> 1000\\n        print(\\n            f\\\"{ordinal} fibonacci number using matrix exponentiation is \\\"\\n            f\\\"{nth_fibonacci_matrix(n)} and using bruteforce is \\\"\\n            f\\\"{nth_fibonacci_bruteforce(n)}\\\\n\\\"\\n        )\\n    # from timeit import timeit\\n    # print(timeit(\\\"nth_fibonacci_matrix(1000000)\\\",\\n    #              \\\"from main import nth_fibonacci_matrix\\\", number=5))\\n    # print(timeit(\\\"nth_fibonacci_bruteforce(1000000)\\\",\\n    #              \\\"from main import nth_fibonacci_bruteforce\\\", number=5))\\n    # 2.3342058970001744\\n    # 57.256506615000035\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "rotate matrix": "\"\\\"\\\"\\\"\\nIn this problem, we want to rotate the matrix elements by 90, 180, 270\\n(counterclockwise)\\nDiscussion in stackoverflow:\\nhttps://stackoverflow.com/questions/42519/how-do-you-rotate-a-two-dimensional-array\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\n\\ndef make_matrix(row_size: int = 4) -> list[list]:\\n    \\\"\\\"\\\"\\n    >>> make_matrix()\\n    [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\\n    >>> make_matrix(1)\\n    [[1]]\\n    >>> make_matrix(-2)\\n    [[1, 2], [3, 4]]\\n    >>> make_matrix(3)\\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\\n    >>> make_matrix() == make_matrix(4)\\n    True\\n    \\\"\\\"\\\"\\n    row_size = abs(row_size) or 4\\n    return [[1 + x + y * row_size for x in range(row_size)] for y in range(row_size)]\\n\\n\\ndef rotate_90(matrix: list[list]) -> list[list]:\\n    \\\"\\\"\\\"\\n    >>> rotate_90(make_matrix())\\n    [[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]]\\n    >>> rotate_90(make_matrix()) == transpose(reverse_column(make_matrix()))\\n    True\\n    \\\"\\\"\\\"\\n\\n    return reverse_row(transpose(matrix))\\n    # OR.. transpose(reverse_column(matrix))\\n\\n\\ndef rotate_180(matrix: list[list]) -> list[list]:\\n    \\\"\\\"\\\"\\n    >>> rotate_180(make_matrix())\\n    [[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]]\\n    >>> rotate_180(make_matrix()) == reverse_column(reverse_row(make_matrix()))\\n    True\\n    \\\"\\\"\\\"\\n\\n    return reverse_row(reverse_column(matrix))\\n    # OR.. reverse_column(reverse_row(matrix))\\n\\n\\ndef rotate_270(matrix: list[list]) -> list[list]:\\n    \\\"\\\"\\\"\\n    >>> rotate_270(make_matrix())\\n    [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]\\n    >>> rotate_270(make_matrix()) == transpose(reverse_row(make_matrix()))\\n    True\\n    \\\"\\\"\\\"\\n\\n    return reverse_column(transpose(matrix))\\n    # OR.. transpose(reverse_row(matrix))\\n\\n\\ndef transpose(matrix: list[list]) -> list[list]:\\n    matrix[:] = [list(x) for x in zip(*matrix)]\\n    return matrix\\n\\n\\ndef reverse_row(matrix: list[list]) -> list[list]:\\n    matrix[:] = matrix[::-1]\\n    return matrix\\n\\n\\ndef reverse_column(matrix: list[list]) -> list[list]:\\n    matrix[:] = [x[::-1] for x in matrix]\\n    return matrix\\n\\n\\ndef print_matrix(matrix: list[list]) -> None:\\n    for i in matrix:\\n        print(*i)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    matrix = make_matrix()\\n    print(\\\"\\\\norigin:\\\\n\\\")\\n    print_matrix(matrix)\\n    print(\\\"\\\\nrotate 90 counterclockwise:\\\\n\\\")\\n    print_matrix(rotate_90(matrix))\\n\\n    matrix = make_matrix()\\n    print(\\\"\\\\norigin:\\\\n\\\")\\n    print_matrix(matrix)\\n    print(\\\"\\\\nrotate 180:\\\\n\\\")\\n    print_matrix(rotate_180(matrix))\\n\\n    matrix = make_matrix()\\n    print(\\\"\\\\norigin:\\\\n\\\")\\n    print_matrix(matrix)\\n    print(\\\"\\\\nrotate 270 counterclockwise:\\\\n\\\")\\n    print_matrix(rotate_270(matrix))\\n\"",
    "searching in sorted matrix": "\"from __future__ import annotations\\n\\n\\ndef search_in_a_sorted_matrix(\\n    mat: list[list], m: int, n: int, key: int | float\\n) -> None:\\n    \\\"\\\"\\\"\\n    >>> search_in_a_sorted_matrix(\\n    ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 5)\\n    Key 5 found at row- 1 column- 2\\n    >>> search_in_a_sorted_matrix(\\n    ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 21)\\n    Key 21 not found\\n    >>> search_in_a_sorted_matrix(\\n    ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.1)\\n    Key 2.1 found at row- 1 column- 1\\n    >>> search_in_a_sorted_matrix(\\n    ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.2)\\n    Key 2.2 not found\\n    \\\"\\\"\\\"\\n    i, j = m - 1, 0\\n    while i >= 0 and j < n:\\n        if key == mat[i][j]:\\n            print(f\\\"Key {key} found at row- {i + 1} column- {j + 1}\\\")\\n            return\\n        if key < mat[i][j]:\\n            i -= 1\\n        else:\\n            j += 1\\n    print(f\\\"Key {key} not found\\\")\\n\\n\\ndef main():\\n    mat = [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]]\\n    x = int(input(\\\"Enter the element to be searched:\\\"))\\n    print(mat)\\n    search_in_a_sorted_matrix(mat, len(mat), len(mat[0]), x)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "sherman morrison": "\"class Matrix:\\n    \\\"\\\"\\\"\\n    <class Matrix>\\n    Matrix structure.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, row: int, column: int, default_value: float = 0):\\n        \\\"\\\"\\\"\\n        <method Matrix.__init__>\\n        Initialize matrix with given size and default value.\\n\\n        Example:\\n        >>> a = Matrix(2, 3, 1)\\n        >>> a\\n        Matrix consist of 2 rows and 3 columns\\n        [1, 1, 1]\\n        [1, 1, 1]\\n        \\\"\\\"\\\"\\n\\n        self.row, self.column = row, column\\n        self.array = [[default_value for c in range(column)] for r in range(row)]\\n\\n    def __str__(self):\\n        \\\"\\\"\\\"\\n        <method Matrix.__str__>\\n        Return string representation of this matrix.\\n        \\\"\\\"\\\"\\n\\n        # Prefix\\n        s = \\\"Matrix consist of %d rows and %d columns\\\\n\\\" % (self.row, self.column)\\n\\n        # Make string identifier\\n        max_element_length = 0\\n        for row_vector in self.array:\\n            for obj in row_vector:\\n                max_element_length = max(max_element_length, len(str(obj)))\\n        string_format_identifier = \\\"%%%ds\\\" % (max_element_length,)\\n\\n        # Make string and return\\n        def single_line(row_vector):\\n            nonlocal string_format_identifier\\n            line = \\\"[\\\"\\n            line += \\\", \\\".join(string_format_identifier % (obj,) for obj in row_vector)\\n            line += \\\"]\\\"\\n            return line\\n\\n        s += \\\"\\\\n\\\".join(single_line(row_vector) for row_vector in self.array)\\n        return s\\n\\n    def __repr__(self):\\n        return str(self)\\n\\n    def validateIndices(self, loc: tuple):\\n        \\\"\\\"\\\"\\n        <method Matrix.validateIndices>\\n        Check if given indices are valid to pick element from matrix.\\n\\n        Example:\\n        >>> a = Matrix(2, 6, 0)\\n        >>> a.validateIndices((2, 7))\\n        False\\n        >>> a.validateIndices((0, 0))\\n        True\\n        \\\"\\\"\\\"\\n        if not (isinstance(loc, (list, tuple)) and len(loc) == 2):\\n            return False\\n        elif not (0 <= loc[0] < self.row and 0 <= loc[1] < self.column):\\n            return False\\n        else:\\n            return True\\n\\n    def __getitem__(self, loc: tuple):\\n        \\\"\\\"\\\"\\n        <method Matrix.__getitem__>\\n        Return array[row][column] where loc = (row, column).\\n\\n        Example:\\n        >>> a = Matrix(3, 2, 7)\\n        >>> a[1, 0]\\n        7\\n        \\\"\\\"\\\"\\n        assert self.validateIndices(loc)\\n        return self.array[loc[0]][loc[1]]\\n\\n    def __setitem__(self, loc: tuple, value: float):\\n        \\\"\\\"\\\"\\n        <method Matrix.__setitem__>\\n        Set array[row][column] = value where loc = (row, column).\\n\\n        Example:\\n        >>> a = Matrix(2, 3, 1)\\n        >>> a[1, 2] = 51\\n        >>> a\\n        Matrix consist of 2 rows and 3 columns\\n        [ 1,  1,  1]\\n        [ 1,  1, 51]\\n        \\\"\\\"\\\"\\n        assert self.validateIndices(loc)\\n        self.array[loc[0]][loc[1]] = value\\n\\n    def __add__(self, another):\\n        \\\"\\\"\\\"\\n        <method Matrix.__add__>\\n        Return self + another.\\n\\n        Example:\\n        >>> a = Matrix(2, 1, -4)\\n        >>> b = Matrix(2, 1, 3)\\n        >>> a+b\\n        Matrix consist of 2 rows and 1 columns\\n        [-1]\\n        [-1]\\n        \\\"\\\"\\\"\\n\\n        # Validation\\n        assert isinstance(another, Matrix)\\n        assert self.row == another.row and self.column == another.column\\n\\n        # Add\\n        result = Matrix(self.row, self.column)\\n        for r in range(self.row):\\n            for c in range(self.column):\\n                result[r, c] = self[r, c] + another[r, c]\\n        return result\\n\\n    def __neg__(self):\\n        \\\"\\\"\\\"\\n        <method Matrix.__neg__>\\n        Return -self.\\n\\n        Example:\\n        >>> a = Matrix(2, 2, 3)\\n        >>> a[0, 1] = a[1, 0] = -2\\n        >>> -a\\n        Matrix consist of 2 rows and 2 columns\\n        [-3,  2]\\n        [ 2, -3]\\n        \\\"\\\"\\\"\\n\\n        result = Matrix(self.row, self.column)\\n        for r in range(self.row):\\n            for c in range(self.column):\\n                result[r, c] = -self[r, c]\\n        return result\\n\\n    def __sub__(self, another):\\n        return self + (-another)\\n\\n    def __mul__(self, another):\\n        \\\"\\\"\\\"\\n        <method Matrix.__mul__>\\n        Return self * another.\\n\\n        Example:\\n        >>> a = Matrix(2, 3, 1)\\n        >>> a[0,2] = a[1,2] = 3\\n        >>> a * -2\\n        Matrix consist of 2 rows and 3 columns\\n        [-2, -2, -6]\\n        [-2, -2, -6]\\n        \\\"\\\"\\\"\\n\\n        if isinstance(another, (int, float)):  # Scalar multiplication\\n            result = Matrix(self.row, self.column)\\n            for r in range(self.row):\\n                for c in range(self.column):\\n                    result[r, c] = self[r, c] * another\\n            return result\\n        elif isinstance(another, Matrix):  # Matrix multiplication\\n            assert self.column == another.row\\n            result = Matrix(self.row, another.column)\\n            for r in range(self.row):\\n                for c in range(another.column):\\n                    for i in range(self.column):\\n                        result[r, c] += self[r, i] * another[i, c]\\n            return result\\n        else:\\n            raise TypeError(f\\\"Unsupported type given for another ({type(another)})\\\")\\n\\n    def transpose(self):\\n        \\\"\\\"\\\"\\n        <method Matrix.transpose>\\n        Return self^T.\\n\\n        Example:\\n        >>> a = Matrix(2, 3)\\n        >>> for r in range(2):\\n        ...     for c in range(3):\\n        ...             a[r,c] = r*c\\n        ...\\n        >>> a.transpose()\\n        Matrix consist of 3 rows and 2 columns\\n        [0, 0]\\n        [0, 1]\\n        [0, 2]\\n        \\\"\\\"\\\"\\n\\n        result = Matrix(self.column, self.row)\\n        for r in range(self.row):\\n            for c in range(self.column):\\n                result[c, r] = self[r, c]\\n        return result\\n\\n    def ShermanMorrison(self, u, v):\\n        \\\"\\\"\\\"\\n        <method Matrix.ShermanMorrison>\\n        Apply Sherman-Morrison formula in O(n^2).\\n        To learn this formula, please look this:\\n        https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula\\n        This method returns (A + uv^T)^(-1) where A^(-1) is self. Returns None if it's\\n        impossible to calculate.\\n        Warning: This method doesn't check if self is invertible.\\n            Make sure self is invertible before execute this method.\\n\\n        Example:\\n        >>> ainv = Matrix(3, 3, 0)\\n        >>> for i in range(3): ainv[i,i] = 1\\n        ...\\n        >>> u = Matrix(3, 1, 0)\\n        >>> u[0,0], u[1,0], u[2,0] = 1, 2, -3\\n        >>> v = Matrix(3, 1, 0)\\n        >>> v[0,0], v[1,0], v[2,0] = 4, -2, 5\\n        >>> ainv.ShermanMorrison(u, v)\\n        Matrix consist of 3 rows and 3 columns\\n        [  1.2857142857142856, -0.14285714285714285,   0.3571428571428571]\\n        [  0.5714285714285714,   0.7142857142857143,   0.7142857142857142]\\n        [ -0.8571428571428571,  0.42857142857142855,  -0.0714285714285714]\\n        \\\"\\\"\\\"\\n\\n        # Size validation\\n        assert isinstance(u, Matrix) and isinstance(v, Matrix)\\n        assert self.row == self.column == u.row == v.row  # u, v should be column vector\\n        assert u.column == v.column == 1  # u, v should be column vector\\n\\n        # Calculate\\n        vT = v.transpose()\\n        numerator_factor = (vT * self * u)[0, 0] + 1\\n        if numerator_factor == 0:\\n            return None  # It's not invertable\\n        return self - ((self * u) * (vT * self) * (1.0 / numerator_factor))\\n\\n\\n# Testing\\nif __name__ == \\\"__main__\\\":\\n\\n    def test1():\\n        # a^(-1)\\n        ainv = Matrix(3, 3, 0)\\n        for i in range(3):\\n            ainv[i, i] = 1\\n        print(f\\\"a^(-1) is {ainv}\\\")\\n        # u, v\\n        u = Matrix(3, 1, 0)\\n        u[0, 0], u[1, 0], u[2, 0] = 1, 2, -3\\n        v = Matrix(3, 1, 0)\\n        v[0, 0], v[1, 0], v[2, 0] = 4, -2, 5\\n        print(f\\\"u is {u}\\\")\\n        print(f\\\"v is {v}\\\")\\n        print(\\\"uv^T is %s\\\" % (u * v.transpose()))\\n        # Sherman Morrison\\n        print(f\\\"(a + uv^T)^(-1) is {ainv.ShermanMorrison(u, v)}\\\")\\n\\n    def test2():\\n        import doctest\\n\\n        doctest.testmod()\\n\\n    test2()\\n\"",
    "spiral print": "\"\\\"\\\"\\\"\\nThis program print the matrix in spiral form.\\nThis problem has been solved through recursive way.\\n\\n      Matrix must satisfy below conditions\\n        i) matrix should be only one or two dimensional\\n        ii) number of column of all rows should be equal\\n\\\"\\\"\\\"\\n\\nfrom collections.abc import Iterable\\n\\n\\ndef check_matrix(matrix):\\n    # must be\\n    if matrix and isinstance(matrix, Iterable):\\n        if isinstance(matrix[0], Iterable):\\n            prev_len = 0\\n            for row in matrix:\\n                if prev_len == 0:\\n                    prev_len = len(row)\\n                    result = True\\n                else:\\n                    result = prev_len == len(row)\\n        else:\\n            result = True\\n    else:\\n        result = False\\n\\n    return result\\n\\n\\ndef spiralPrint(a):\\n    if check_matrix(a) and len(a) > 0:\\n        matRow = len(a)\\n        if isinstance(a[0], Iterable):\\n            matCol = len(a[0])\\n        else:\\n            for dat in a:\\n                print(dat),\\n            return\\n\\n        # horizotal printing increasing\\n        for i in range(0, matCol):\\n            print(a[0][i]),\\n        # vertical printing down\\n        for i in range(1, matRow):\\n            print(a[i][matCol - 1]),\\n        # horizotal printing decreasing\\n        if matRow > 1:\\n            for i in range(matCol - 2, -1, -1):\\n                print(a[matRow - 1][i]),\\n        # vertical printing up\\n        for i in range(matRow - 2, 0, -1):\\n            print(a[i][0]),\\n        remainMat = [row[1 : matCol - 1] for row in a[1 : matRow - 1]]\\n        if len(remainMat) > 0:\\n            spiralPrint(remainMat)\\n        else:\\n            return\\n    else:\\n        print(\\\"Not a valid matrix\\\")\\n        return\\n\\n\\n# driver code\\nif __name__ == \\\"__main__\\\":\\n    a = ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12])\\n    spiralPrint(a)\\n\"",
    "ford fulkerson": "\"# Ford-Fulkerson Algorithm for Maximum Flow Problem\\n\\\"\\\"\\\"\\nDescription:\\n    (1) Start with initial flow as 0;\\n    (2) Choose augmenting path from source to sink and add path to flow;\\n\\\"\\\"\\\"\\n\\n\\ndef BFS(graph, s, t, parent):\\n    # Return True if there is node that has not iterated.\\n    visited = [False] * len(graph)\\n    queue = []\\n    queue.append(s)\\n    visited[s] = True\\n\\n    while queue:\\n        u = queue.pop(0)\\n        for ind in range(len(graph[u])):\\n            if visited[ind] is False and graph[u][ind] > 0:\\n                queue.append(ind)\\n                visited[ind] = True\\n                parent[ind] = u\\n\\n    return True if visited[t] else False\\n\\n\\ndef FordFulkerson(graph, source, sink):\\n    # This array is filled by BFS and to store path\\n    parent = [-1] * (len(graph))\\n    max_flow = 0\\n    while BFS(graph, source, sink, parent):\\n        path_flow = float(\\\"Inf\\\")\\n        s = sink\\n\\n        while s != source:\\n            # Find the minimum value in select path\\n            path_flow = min(path_flow, graph[parent[s]][s])\\n            s = parent[s]\\n\\n        max_flow += path_flow\\n        v = sink\\n\\n        while v != source:\\n            u = parent[v]\\n            graph[u][v] -= path_flow\\n            graph[v][u] += path_flow\\n            v = parent[v]\\n    return max_flow\\n\\n\\ngraph = [\\n    [0, 16, 13, 0, 0, 0],\\n    [0, 0, 10, 12, 0, 0],\\n    [0, 4, 0, 0, 14, 0],\\n    [0, 0, 9, 0, 0, 20],\\n    [0, 0, 0, 7, 0, 4],\\n    [0, 0, 0, 0, 0, 0],\\n]\\n\\nsource, sink = 0, 5\\nprint(FordFulkerson(graph, source, sink))\\n\"",
    "minimum cut": "\"# Minimum cut on Ford_Fulkerson algorithm.\\n\\ntest_graph = [\\n    [0, 16, 13, 0, 0, 0],\\n    [0, 0, 10, 12, 0, 0],\\n    [0, 4, 0, 0, 14, 0],\\n    [0, 0, 9, 0, 0, 20],\\n    [0, 0, 0, 7, 0, 4],\\n    [0, 0, 0, 0, 0, 0],\\n]\\n\\n\\ndef BFS(graph, s, t, parent):\\n    # Return True if there is node that has not iterated.\\n    visited = [False] * len(graph)\\n    queue = [s]\\n    visited[s] = True\\n\\n    while queue:\\n        u = queue.pop(0)\\n        for ind in range(len(graph[u])):\\n            if visited[ind] is False and graph[u][ind] > 0:\\n                queue.append(ind)\\n                visited[ind] = True\\n                parent[ind] = u\\n\\n    return True if visited[t] else False\\n\\n\\ndef mincut(graph, source, sink):\\n    \\\"\\\"\\\"This array is filled by BFS and to store path\\n    >>> mincut(test_graph, source=0, sink=5)\\n    [(1, 3), (4, 3), (4, 5)]\\n    \\\"\\\"\\\"\\n    parent = [-1] * (len(graph))\\n    max_flow = 0\\n    res = []\\n    temp = [i[:] for i in graph]  # Record original cut, copy.\\n    while BFS(graph, source, sink, parent):\\n        path_flow = float(\\\"Inf\\\")\\n        s = sink\\n\\n        while s != source:\\n            # Find the minimum value in select path\\n            path_flow = min(path_flow, graph[parent[s]][s])\\n            s = parent[s]\\n\\n        max_flow += path_flow\\n        v = sink\\n\\n        while v != source:\\n            u = parent[v]\\n            graph[u][v] -= path_flow\\n            graph[v][u] += path_flow\\n            v = parent[v]\\n\\n    for i in range(len(graph)):\\n        for j in range(len(graph[0])):\\n            if graph[i][j] == 0 and temp[i][j] > 0:\\n                res.append((i, j))\\n\\n    return res\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(mincut(test_graph, source=0, sink=5))\\n\"",
    "2 hidden layers neural network": "\"\\\"\\\"\\\"\\nReferences:\\n    - http://neuralnetworksanddeeplearning.com/chap2.html (Backpropagation)\\n    - https://en.wikipedia.org/wiki/Sigmoid_function (Sigmoid activation function)\\n    - https://en.wikipedia.org/wiki/Feedforward_neural_network (Feedforward)\\n\\\"\\\"\\\"\\n\\nimport numpy\\n\\n\\nclass TwoHiddenLayerNeuralNetwork:\\n    def __init__(self, input_array: numpy.ndarray, output_array: numpy.ndarray) -> None:\\n        \\\"\\\"\\\"\\n        This function initializes the TwoHiddenLayerNeuralNetwork class with random\\n        weights for every layer and initializes predicted output with zeroes.\\n\\n        input_array : input values for training the neural network (i.e training data) .\\n        output_array : expected output values of the given inputs.\\n        \\\"\\\"\\\"\\n\\n        # Input values provided for training the model.\\n        self.input_array = input_array\\n\\n        # Random initial weights are assigned where first argument is the\\n        # number of nodes in previous layer and second argument is the\\n        # number of nodes in the next layer.\\n\\n        # Random initial weights are assigned.\\n        # self.input_array.shape[1] is used to represent number of nodes in input layer.\\n        # First hidden layer consists of 4 nodes.\\n        self.input_layer_and_first_hidden_layer_weights = numpy.random.rand(\\n            self.input_array.shape[1], 4\\n        )\\n\\n        # Random initial values for the first hidden layer.\\n        # First hidden layer has 4 nodes.\\n        # Second hidden layer has 3 nodes.\\n        self.first_hidden_layer_and_second_hidden_layer_weights = numpy.random.rand(\\n            4, 3\\n        )\\n\\n        # Random initial values for the second hidden layer.\\n        # Second hidden layer has 3 nodes.\\n        # Output layer has 1 node.\\n        self.second_hidden_layer_and_output_layer_weights = numpy.random.rand(3, 1)\\n\\n        # Real output values provided.\\n        self.output_array = output_array\\n\\n        # Predicted output values by the neural network.\\n        # Predicted_output array initially consists of zeroes.\\n        self.predicted_output = numpy.zeros(output_array.shape)\\n\\n    def feedforward(self) -> numpy.ndarray:\\n        \\\"\\\"\\\"\\n        The information moves in only one direction i.e. forward from the input nodes,\\n        through the two hidden nodes and to the output nodes.\\n        There are no cycles or loops in the network.\\n\\n        Return layer_between_second_hidden_layer_and_output\\n            (i.e the last layer of the neural network).\\n\\n        >>> input_val = numpy.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float)\\n        >>> output_val = numpy.array(([0], [0], [0]), dtype=float)\\n        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\\n        >>> res = nn.feedforward()\\n        >>> array_sum = numpy.sum(res)\\n        >>> numpy.isnan(array_sum)\\n        False\\n        \\\"\\\"\\\"\\n        # Layer_between_input_and_first_hidden_layer is the layer connecting the\\n        # input nodes with the first hidden layer nodes.\\n        self.layer_between_input_and_first_hidden_layer = sigmoid(\\n            numpy.dot(self.input_array, self.input_layer_and_first_hidden_layer_weights)\\n        )\\n\\n        # layer_between_first_hidden_layer_and_second_hidden_layer is the layer\\n        # connecting the first hidden set of nodes with the second hidden set of nodes.\\n        self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(\\n            numpy.dot(\\n                self.layer_between_input_and_first_hidden_layer,\\n                self.first_hidden_layer_and_second_hidden_layer_weights,\\n            )\\n        )\\n\\n        # layer_between_second_hidden_layer_and_output is the layer connecting\\n        # second hidden layer with the output node.\\n        self.layer_between_second_hidden_layer_and_output = sigmoid(\\n            numpy.dot(\\n                self.layer_between_first_hidden_layer_and_second_hidden_layer,\\n                self.second_hidden_layer_and_output_layer_weights,\\n            )\\n        )\\n\\n        return self.layer_between_second_hidden_layer_and_output\\n\\n    def back_propagation(self) -> None:\\n        \\\"\\\"\\\"\\n        Function for fine-tuning the weights of the neural net based on the\\n        error rate obtained in the previous epoch (i.e., iteration).\\n        Updation is done using derivative of sogmoid activation function.\\n\\n        >>> input_val = numpy.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float)\\n        >>> output_val = numpy.array(([0], [0], [0]), dtype=float)\\n        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\\n        >>> res = nn.feedforward()\\n        >>> nn.back_propagation()\\n        >>> updated_weights = nn.second_hidden_layer_and_output_layer_weights\\n        >>> (res == updated_weights).all()\\n        False\\n        \\\"\\\"\\\"\\n\\n        updated_second_hidden_layer_and_output_layer_weights = numpy.dot(\\n            self.layer_between_first_hidden_layer_and_second_hidden_layer.T,\\n            2\\n            * (self.output_array - self.predicted_output)\\n            * sigmoid_derivative(self.predicted_output),\\n        )\\n        updated_first_hidden_layer_and_second_hidden_layer_weights = numpy.dot(\\n            self.layer_between_input_and_first_hidden_layer.T,\\n            numpy.dot(\\n                2\\n                * (self.output_array - self.predicted_output)\\n                * sigmoid_derivative(self.predicted_output),\\n                self.second_hidden_layer_and_output_layer_weights.T,\\n            )\\n            * sigmoid_derivative(\\n                self.layer_between_first_hidden_layer_and_second_hidden_layer\\n            ),\\n        )\\n        updated_input_layer_and_first_hidden_layer_weights = numpy.dot(\\n            self.input_array.T,\\n            numpy.dot(\\n                numpy.dot(\\n                    2\\n                    * (self.output_array - self.predicted_output)\\n                    * sigmoid_derivative(self.predicted_output),\\n                    self.second_hidden_layer_and_output_layer_weights.T,\\n                )\\n                * sigmoid_derivative(\\n                    self.layer_between_first_hidden_layer_and_second_hidden_layer\\n                ),\\n                self.first_hidden_layer_and_second_hidden_layer_weights.T,\\n            )\\n            * sigmoid_derivative(self.layer_between_input_and_first_hidden_layer),\\n        )\\n\\n        self.input_layer_and_first_hidden_layer_weights += (\\n            updated_input_layer_and_first_hidden_layer_weights\\n        )\\n        self.first_hidden_layer_and_second_hidden_layer_weights += (\\n            updated_first_hidden_layer_and_second_hidden_layer_weights\\n        )\\n        self.second_hidden_layer_and_output_layer_weights += (\\n            updated_second_hidden_layer_and_output_layer_weights\\n        )\\n\\n    def train(self, output: numpy.ndarray, iterations: int, give_loss: bool) -> None:\\n        \\\"\\\"\\\"\\n        Performs the feedforwarding and back propagation process for the\\n        given number of iterations.\\n        Every iteration will update the weights of neural network.\\n\\n        output : real output values,required for calculating loss.\\n        iterations : number of times the weights are to be updated.\\n        give_loss : boolean value, If True then prints loss for each iteration,\\n                    If False then nothing is printed\\n\\n        >>> input_val = numpy.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float)\\n        >>> output_val = numpy.array(([0], [1], [1]), dtype=float)\\n        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\\n        >>> first_iteration_weights = nn.feedforward()\\n        >>> nn.back_propagation()\\n        >>> updated_weights = nn.second_hidden_layer_and_output_layer_weights\\n        >>> (first_iteration_weights == updated_weights).all()\\n        False\\n        \\\"\\\"\\\"\\n        for iteration in range(1, iterations + 1):\\n            self.output = self.feedforward()\\n            self.back_propagation()\\n            if give_loss:\\n                loss = numpy.mean(numpy.square(output - self.feedforward()))\\n                print(f\\\"Iteration {iteration} Loss: {loss}\\\")\\n\\n    def predict(self, input: numpy.ndarray) -> int:\\n        \\\"\\\"\\\"\\n        Predict's the output for the given input values using\\n        the trained neural network.\\n\\n        The output value given by the model ranges in-between 0 and 1.\\n        The predict function returns 1 if the model value is greater\\n        than the threshold value else returns 0,\\n        as the real output values are in binary.\\n\\n        >>> input_val = numpy.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float)\\n        >>> output_val = numpy.array(([0], [1], [1]), dtype=float)\\n        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\\n        >>> nn.train(output_val, 1000, False)\\n        >>> nn.predict([0,1,0]) in (0, 1)\\n        True\\n        \\\"\\\"\\\"\\n\\n        # Input values for which the predictions are to be made.\\n        self.array = input\\n\\n        self.layer_between_input_and_first_hidden_layer = sigmoid(\\n            numpy.dot(self.array, self.input_layer_and_first_hidden_layer_weights)\\n        )\\n\\n        self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(\\n            numpy.dot(\\n                self.layer_between_input_and_first_hidden_layer,\\n                self.first_hidden_layer_and_second_hidden_layer_weights,\\n            )\\n        )\\n\\n        self.layer_between_second_hidden_layer_and_output = sigmoid(\\n            numpy.dot(\\n                self.layer_between_first_hidden_layer_and_second_hidden_layer,\\n                self.second_hidden_layer_and_output_layer_weights,\\n            )\\n        )\\n\\n        return int(self.layer_between_second_hidden_layer_and_output > 0.6)\\n\\n\\ndef sigmoid(value: numpy.ndarray) -> numpy.ndarray:\\n    \\\"\\\"\\\"\\n    Applies sigmoid activation function.\\n\\n    return normalized values\\n\\n    >>> sigmoid(numpy.array(([1, 0, 2], [1, 0, 0]), dtype=numpy.float64))\\n    array([[0.73105858, 0.5       , 0.88079708],\\n           [0.73105858, 0.5       , 0.5       ]])\\n    \\\"\\\"\\\"\\n    return 1 / (1 + numpy.exp(-value))\\n\\n\\ndef sigmoid_derivative(value: numpy.ndarray) -> numpy.ndarray:\\n    \\\"\\\"\\\"\\n    Provides the derivative value of the sigmoid function.\\n\\n    returns derivative of the sigmoid value\\n\\n    >>> sigmoid_derivative(numpy.array(([1, 0, 2], [1, 0, 0]), dtype=numpy.float64))\\n    array([[ 0.,  0., -2.],\\n           [ 0.,  0.,  0.]])\\n    \\\"\\\"\\\"\\n    return (value) * (1 - (value))\\n\\n\\ndef example() -> int:\\n    \\\"\\\"\\\"\\n    Example for \\\"how to use the neural network class and use the\\n    respected methods for the desired output\\\".\\n    Calls the TwoHiddenLayerNeuralNetwork class and\\n    provides the fixed input output values to the model.\\n    Model is trained for a fixed amount of iterations then the predict method is called.\\n    In this example the output is divided into 2 classes i.e. binary classification,\\n    the two classes are represented by '0' and '1'.\\n\\n    >>> example() in (0, 1)\\n    True\\n    \\\"\\\"\\\"\\n    # Input values.\\n    input = numpy.array(\\n        (\\n            [0, 0, 0],\\n            [0, 0, 1],\\n            [0, 1, 0],\\n            [0, 1, 1],\\n            [1, 0, 0],\\n            [1, 0, 1],\\n            [1, 1, 0],\\n            [1, 1, 1],\\n        ),\\n        dtype=numpy.float64,\\n    )\\n\\n    # True output values for the given input values.\\n    output = numpy.array(([0], [1], [1], [0], [1], [0], [0], [1]), dtype=numpy.float64)\\n\\n    # Calling neural network class.\\n    neural_network = TwoHiddenLayerNeuralNetwork(input_array=input, output_array=output)\\n\\n    # Calling training function.\\n    # Set give_loss to True if you want to see loss in every iteration.\\n    neural_network.train(output=output, iterations=10, give_loss=False)\\n\\n    return neural_network.predict(numpy.array(([1, 1, 1]), dtype=numpy.float64))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    example()\\n\"",
    "back propagation neural network": "\"#!/usr/bin/python\\n\\n\\\"\\\"\\\"\\n\\nA Framework of Back Propagation Neural Network（BP） model\\n\\nEasy to use:\\n    * add many layers as you want ！！！\\n    * clearly see how the loss decreasing\\nEasy to expand:\\n    * more activation functions\\n    * more loss functions\\n    * more optimization method\\n\\nAuthor: Stephen Lee\\nGithub : https://github.com/RiptideBo\\nDate: 2017.11.23\\n\\n\\\"\\\"\\\"\\nimport numpy as np\\nfrom matplotlib import pyplot as plt\\n\\n\\ndef sigmoid(x):\\n    return 1 / (1 + np.exp(-1 * x))\\n\\n\\nclass DenseLayer:\\n    \\\"\\\"\\\"\\n    Layers of BP neural network\\n    \\\"\\\"\\\"\\n\\n    def __init__(\\n        self, units, activation=None, learning_rate=None, is_input_layer=False\\n    ):\\n        \\\"\\\"\\\"\\n        common connected layer of bp network\\n        :param units: numbers of neural units\\n        :param activation: activation function\\n        :param learning_rate: learning rate for paras\\n        :param is_input_layer: whether it is input layer or not\\n        \\\"\\\"\\\"\\n        self.units = units\\n        self.weight = None\\n        self.bias = None\\n        self.activation = activation\\n        if learning_rate is None:\\n            learning_rate = 0.3\\n        self.learn_rate = learning_rate\\n        self.is_input_layer = is_input_layer\\n\\n    def initializer(self, back_units):\\n        self.weight = np.asmatrix(np.random.normal(0, 0.5, (self.units, back_units)))\\n        self.bias = np.asmatrix(np.random.normal(0, 0.5, self.units)).T\\n        if self.activation is None:\\n            self.activation = sigmoid\\n\\n    def cal_gradient(self):\\n        # activation function may be sigmoid or linear\\n        if self.activation == sigmoid:\\n            gradient_mat = np.dot(self.output, (1 - self.output).T)\\n            gradient_activation = np.diag(np.diag(gradient_mat))\\n        else:\\n            gradient_activation = 1\\n        return gradient_activation\\n\\n    def forward_propagation(self, xdata):\\n        self.xdata = xdata\\n        if self.is_input_layer:\\n            # input layer\\n            self.wx_plus_b = xdata\\n            self.output = xdata\\n            return xdata\\n        else:\\n            self.wx_plus_b = np.dot(self.weight, self.xdata) - self.bias\\n            self.output = self.activation(self.wx_plus_b)\\n            return self.output\\n\\n    def back_propagation(self, gradient):\\n        gradient_activation = self.cal_gradient()  # i * i 维\\n        gradient = np.asmatrix(np.dot(gradient.T, gradient_activation))\\n\\n        self._gradient_weight = np.asmatrix(self.xdata)\\n        self._gradient_bias = -1\\n        self._gradient_x = self.weight\\n\\n        self.gradient_weight = np.dot(gradient.T, self._gradient_weight.T)\\n        self.gradient_bias = gradient * self._gradient_bias\\n        self.gradient = np.dot(gradient, self._gradient_x).T\\n        # upgrade: the Negative gradient direction\\n        self.weight = self.weight - self.learn_rate * self.gradient_weight\\n        self.bias = self.bias - self.learn_rate * self.gradient_bias.T\\n        # updates the weights and bias according to learning rate (0.3 if undefined)\\n        return self.gradient\\n\\n\\nclass BPNN:\\n    \\\"\\\"\\\"\\n    Back Propagation Neural Network model\\n    \\\"\\\"\\\"\\n\\n    def __init__(self):\\n        self.layers = []\\n        self.train_mse = []\\n        self.fig_loss = plt.figure()\\n        self.ax_loss = self.fig_loss.add_subplot(1, 1, 1)\\n\\n    def add_layer(self, layer):\\n        self.layers.append(layer)\\n\\n    def build(self):\\n        for i, layer in enumerate(self.layers[:]):\\n            if i < 1:\\n                layer.is_input_layer = True\\n            else:\\n                layer.initializer(self.layers[i - 1].units)\\n\\n    def summary(self):\\n        for i, layer in enumerate(self.layers[:]):\\n            print(\\\"------- layer %d -------\\\" % i)\\n            print(\\\"weight.shape \\\", np.shape(layer.weight))\\n            print(\\\"bias.shape \\\", np.shape(layer.bias))\\n\\n    def train(self, xdata, ydata, train_round, accuracy):\\n        self.train_round = train_round\\n        self.accuracy = accuracy\\n\\n        self.ax_loss.hlines(self.accuracy, 0, self.train_round * 1.1)\\n\\n        x_shape = np.shape(xdata)\\n        for round_i in range(train_round):\\n            all_loss = 0\\n            for row in range(x_shape[0]):\\n                _xdata = np.asmatrix(xdata[row, :]).T\\n                _ydata = np.asmatrix(ydata[row, :]).T\\n\\n                # forward propagation\\n                for layer in self.layers:\\n                    _xdata = layer.forward_propagation(_xdata)\\n\\n                loss, gradient = self.cal_loss(_ydata, _xdata)\\n                all_loss = all_loss + loss\\n\\n                # back propagation: the input_layer does not upgrade\\n                for layer in self.layers[:0:-1]:\\n                    gradient = layer.back_propagation(gradient)\\n\\n            mse = all_loss / x_shape[0]\\n            self.train_mse.append(mse)\\n\\n            self.plot_loss()\\n\\n            if mse < self.accuracy:\\n                print(\\\"----达到精度----\\\")\\n                return mse\\n\\n    def cal_loss(self, ydata, ydata_):\\n        self.loss = np.sum(np.power((ydata - ydata_), 2))\\n        self.loss_gradient = 2 * (ydata_ - ydata)\\n        # vector (shape is the same as _ydata.shape)\\n        return self.loss, self.loss_gradient\\n\\n    def plot_loss(self):\\n        if self.ax_loss.lines:\\n            self.ax_loss.lines.remove(self.ax_loss.lines[0])\\n        self.ax_loss.plot(self.train_mse, \\\"r-\\\")\\n        plt.ion()\\n        plt.xlabel(\\\"step\\\")\\n        plt.ylabel(\\\"loss\\\")\\n        plt.show()\\n        plt.pause(0.1)\\n\\n\\ndef example():\\n    x = np.random.randn(10, 10)\\n    y = np.asarray(\\n        [\\n            [0.8, 0.4],\\n            [0.4, 0.3],\\n            [0.34, 0.45],\\n            [0.67, 0.32],\\n            [0.88, 0.67],\\n            [0.78, 0.77],\\n            [0.55, 0.66],\\n            [0.55, 0.43],\\n            [0.54, 0.1],\\n            [0.1, 0.5],\\n        ]\\n    )\\n    model = BPNN()\\n    for i in (10, 20, 30, 2):\\n        model.add_layer(DenseLayer(i))\\n    model.build()\\n    model.summary()\\n    model.train(xdata=x, ydata=y, train_round=100, accuracy=0.01)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    example()\\n\"",
    "convolution neural network": "\"\\\"\\\"\\\"\\n     - - - - - -- - - - - - - - - - - - - - - - - - - - - - -\\n    Name - - CNN - Convolution Neural Network For Photo Recognizing\\n    Goal - - Recognize Handing Writing Word Photo\\n    Detail：Total 5 layers neural network\\n            * Convolution layer\\n            * Pooling layer\\n            * Input layer layer of BP\\n            * Hidden layer of BP\\n            * Output layer of BP\\n    Author: Stephen Lee\\n    Github: 245885195@qq.com\\n    Date: 2017.9.20\\n    - - - - - -- - - - - - - - - - - - - - - - - - - - - - -\\n\\\"\\\"\\\"\\nimport pickle\\n\\nimport numpy as np\\nfrom matplotlib import pyplot as plt\\n\\n\\nclass CNN:\\n    def __init__(\\n        self, conv1_get, size_p1, bp_num1, bp_num2, bp_num3, rate_w=0.2, rate_t=0.2\\n    ):\\n        \\\"\\\"\\\"\\n        :param conv1_get: [a,c,d]，size, number, step of convolution kernel\\n        :param size_p1: pooling size\\n        :param bp_num1: units number of flatten layer\\n        :param bp_num2: units number of hidden layer\\n        :param bp_num3: units number of output layer\\n        :param rate_w: rate of weight learning\\n        :param rate_t: rate of threshold learning\\n        \\\"\\\"\\\"\\n        self.num_bp1 = bp_num1\\n        self.num_bp2 = bp_num2\\n        self.num_bp3 = bp_num3\\n        self.conv1 = conv1_get[:2]\\n        self.step_conv1 = conv1_get[2]\\n        self.size_pooling1 = size_p1\\n        self.rate_weight = rate_w\\n        self.rate_thre = rate_t\\n        self.w_conv1 = [\\n            np.mat(-1 * np.random.rand(self.conv1[0], self.conv1[0]) + 0.5)\\n            for i in range(self.conv1[1])\\n        ]\\n        self.wkj = np.mat(-1 * np.random.rand(self.num_bp3, self.num_bp2) + 0.5)\\n        self.vji = np.mat(-1 * np.random.rand(self.num_bp2, self.num_bp1) + 0.5)\\n        self.thre_conv1 = -2 * np.random.rand(self.conv1[1]) + 1\\n        self.thre_bp2 = -2 * np.random.rand(self.num_bp2) + 1\\n        self.thre_bp3 = -2 * np.random.rand(self.num_bp3) + 1\\n\\n    def save_model(self, save_path):\\n        # save model dict with pickle\\n        model_dic = {\\n            \\\"num_bp1\\\": self.num_bp1,\\n            \\\"num_bp2\\\": self.num_bp2,\\n            \\\"num_bp3\\\": self.num_bp3,\\n            \\\"conv1\\\": self.conv1,\\n            \\\"step_conv1\\\": self.step_conv1,\\n            \\\"size_pooling1\\\": self.size_pooling1,\\n            \\\"rate_weight\\\": self.rate_weight,\\n            \\\"rate_thre\\\": self.rate_thre,\\n            \\\"w_conv1\\\": self.w_conv1,\\n            \\\"wkj\\\": self.wkj,\\n            \\\"vji\\\": self.vji,\\n            \\\"thre_conv1\\\": self.thre_conv1,\\n            \\\"thre_bp2\\\": self.thre_bp2,\\n            \\\"thre_bp3\\\": self.thre_bp3,\\n        }\\n        with open(save_path, \\\"wb\\\") as f:\\n            pickle.dump(model_dic, f)\\n\\n        print(\\\"Model saved： %s\\\" % save_path)\\n\\n    @classmethod\\n    def ReadModel(cls, model_path):\\n        # read saved model\\n        with open(model_path, \\\"rb\\\") as f:\\n            model_dic = pickle.load(f)\\n\\n        conv_get = model_dic.get(\\\"conv1\\\")\\n        conv_get.append(model_dic.get(\\\"step_conv1\\\"))\\n        size_p1 = model_dic.get(\\\"size_pooling1\\\")\\n        bp1 = model_dic.get(\\\"num_bp1\\\")\\n        bp2 = model_dic.get(\\\"num_bp2\\\")\\n        bp3 = model_dic.get(\\\"num_bp3\\\")\\n        r_w = model_dic.get(\\\"rate_weight\\\")\\n        r_t = model_dic.get(\\\"rate_thre\\\")\\n        # create model instance\\n        conv_ins = CNN(conv_get, size_p1, bp1, bp2, bp3, r_w, r_t)\\n        # modify model parameter\\n        conv_ins.w_conv1 = model_dic.get(\\\"w_conv1\\\")\\n        conv_ins.wkj = model_dic.get(\\\"wkj\\\")\\n        conv_ins.vji = model_dic.get(\\\"vji\\\")\\n        conv_ins.thre_conv1 = model_dic.get(\\\"thre_conv1\\\")\\n        conv_ins.thre_bp2 = model_dic.get(\\\"thre_bp2\\\")\\n        conv_ins.thre_bp3 = model_dic.get(\\\"thre_bp3\\\")\\n        return conv_ins\\n\\n    def sig(self, x):\\n        return 1 / (1 + np.exp(-1 * x))\\n\\n    def do_round(self, x):\\n        return round(x, 3)\\n\\n    def convolute(self, data, convs, w_convs, thre_convs, conv_step):\\n        # convolution process\\n        size_conv = convs[0]\\n        num_conv = convs[1]\\n        size_data = np.shape(data)[0]\\n        # get the data slice of original image data, data_focus\\n        data_focus = []\\n        for i_focus in range(0, size_data - size_conv + 1, conv_step):\\n            for j_focus in range(0, size_data - size_conv + 1, conv_step):\\n                focus = data[\\n                    i_focus : i_focus + size_conv, j_focus : j_focus + size_conv\\n                ]\\n                data_focus.append(focus)\\n        # calculate the feature map of every single kernel, and saved as list of matrix\\n        data_featuremap = []\\n        Size_FeatureMap = int((size_data - size_conv) / conv_step + 1)\\n        for i_map in range(num_conv):\\n            featuremap = []\\n            for i_focus in range(len(data_focus)):\\n                net_focus = (\\n                    np.sum(np.multiply(data_focus[i_focus], w_convs[i_map]))\\n                    - thre_convs[i_map]\\n                )\\n                featuremap.append(self.sig(net_focus))\\n            featuremap = np.asmatrix(featuremap).reshape(\\n                Size_FeatureMap, Size_FeatureMap\\n            )\\n            data_featuremap.append(featuremap)\\n\\n        # expanding the data slice to One dimenssion\\n        focus1_list = []\\n        for each_focus in data_focus:\\n            focus1_list.extend(self.Expand_Mat(each_focus))\\n        focus_list = np.asarray(focus1_list)\\n        return focus_list, data_featuremap\\n\\n    def pooling(self, featuremaps, size_pooling, type=\\\"average_pool\\\"):\\n        # pooling process\\n        size_map = len(featuremaps[0])\\n        size_pooled = int(size_map / size_pooling)\\n        featuremap_pooled = []\\n        for i_map in range(len(featuremaps)):\\n            map = featuremaps[i_map]\\n            map_pooled = []\\n            for i_focus in range(0, size_map, size_pooling):\\n                for j_focus in range(0, size_map, size_pooling):\\n                    focus = map[\\n                        i_focus : i_focus + size_pooling,\\n                        j_focus : j_focus + size_pooling,\\n                    ]\\n                    if type == \\\"average_pool\\\":\\n                        # average pooling\\n                        map_pooled.append(np.average(focus))\\n                    elif type == \\\"max_pooling\\\":\\n                        # max pooling\\n                        map_pooled.append(np.max(focus))\\n            map_pooled = np.asmatrix(map_pooled).reshape(size_pooled, size_pooled)\\n            featuremap_pooled.append(map_pooled)\\n        return featuremap_pooled\\n\\n    def _expand(self, data):\\n        # expanding three dimension data to one dimension list\\n        data_expanded = []\\n        for i in range(len(data)):\\n            shapes = np.shape(data[i])\\n            data_listed = data[i].reshape(1, shapes[0] * shapes[1])\\n            data_listed = data_listed.getA().tolist()[0]\\n            data_expanded.extend(data_listed)\\n        data_expanded = np.asarray(data_expanded)\\n        return data_expanded\\n\\n    def _expand_mat(self, data_mat):\\n        # expanding matrix to one dimension list\\n        data_mat = np.asarray(data_mat)\\n        shapes = np.shape(data_mat)\\n        data_expanded = data_mat.reshape(1, shapes[0] * shapes[1])\\n        return data_expanded\\n\\n    def _calculate_gradient_from_pool(\\n        self, out_map, pd_pool, num_map, size_map, size_pooling\\n    ):\\n        \\\"\\\"\\\"\\n        calculate the gradient from the data slice of pool layer\\n        pd_pool: list of matrix\\n        out_map: the shape of data slice(size_map*size_map)\\n        return: pd_all: list of matrix, [num, size_map, size_map]\\n        \\\"\\\"\\\"\\n        pd_all = []\\n        i_pool = 0\\n        for i_map in range(num_map):\\n            pd_conv1 = np.ones((size_map, size_map))\\n            for i in range(0, size_map, size_pooling):\\n                for j in range(0, size_map, size_pooling):\\n                    pd_conv1[i : i + size_pooling, j : j + size_pooling] = pd_pool[\\n                        i_pool\\n                    ]\\n                    i_pool = i_pool + 1\\n            pd_conv2 = np.multiply(\\n                pd_conv1, np.multiply(out_map[i_map], (1 - out_map[i_map]))\\n            )\\n            pd_all.append(pd_conv2)\\n        return pd_all\\n\\n    def train(\\n        self, patterns, datas_train, datas_teach, n_repeat, error_accuracy, draw_e=bool\\n    ):\\n        # model traning\\n        print(\\\"----------------------Start Training-------------------------\\\")\\n        print((\\\" - - Shape: Train_Data  \\\", np.shape(datas_train)))\\n        print((\\\" - - Shape: Teach_Data  \\\", np.shape(datas_teach)))\\n        rp = 0\\n        all_mse = []\\n        mse = 10000\\n        while rp < n_repeat and mse >= error_accuracy:\\n            error_count = 0\\n            print(\\\"-------------Learning Time %d--------------\\\" % rp)\\n            for p in range(len(datas_train)):\\n                # print('------------Learning Image: %d--------------'%p)\\n                data_train = np.asmatrix(datas_train[p])\\n                data_teach = np.asarray(datas_teach[p])\\n                data_focus1, data_conved1 = self.convolute(\\n                    data_train,\\n                    self.conv1,\\n                    self.w_conv1,\\n                    self.thre_conv1,\\n                    conv_step=self.step_conv1,\\n                )\\n                data_pooled1 = self.pooling(data_conved1, self.size_pooling1)\\n                shape_featuremap1 = np.shape(data_conved1)\\n                \\\"\\\"\\\"\\n                print('  -----original shape   ', np.shape(data_train))\\n                print('  ---- after convolution  ',np.shape(data_conv1))\\n                print('  -----after pooling  ',np.shape(data_pooled1))\\n               \\\"\\\"\\\"\\n                data_bp_input = self._expand(data_pooled1)\\n                bp_out1 = data_bp_input\\n\\n                bp_net_j = np.dot(bp_out1, self.vji.T) - self.thre_bp2\\n                bp_out2 = self.sig(bp_net_j)\\n                bp_net_k = np.dot(bp_out2, self.wkj.T) - self.thre_bp3\\n                bp_out3 = self.sig(bp_net_k)\\n\\n                # --------------Model Leaning ------------------------\\n                # calculate error and gradient---------------\\n                pd_k_all = np.multiply(\\n                    (data_teach - bp_out3), np.multiply(bp_out3, (1 - bp_out3))\\n                )\\n                pd_j_all = np.multiply(\\n                    np.dot(pd_k_all, self.wkj), np.multiply(bp_out2, (1 - bp_out2))\\n                )\\n                pd_i_all = np.dot(pd_j_all, self.vji)\\n\\n                pd_conv1_pooled = pd_i_all / (self.size_pooling1 * self.size_pooling1)\\n                pd_conv1_pooled = pd_conv1_pooled.T.getA().tolist()\\n                pd_conv1_all = self._calculate_gradient_from_pool(\\n                    data_conved1,\\n                    pd_conv1_pooled,\\n                    shape_featuremap1[0],\\n                    shape_featuremap1[1],\\n                    self.size_pooling1,\\n                )\\n                # weight and threshold learning process---------\\n                # convolution layer\\n                for k_conv in range(self.conv1[1]):\\n                    pd_conv_list = self._expand_mat(pd_conv1_all[k_conv])\\n                    delta_w = self.rate_weight * np.dot(pd_conv_list, data_focus1)\\n\\n                    self.w_conv1[k_conv] = self.w_conv1[k_conv] + delta_w.reshape(\\n                        (self.conv1[0], self.conv1[0])\\n                    )\\n\\n                    self.thre_conv1[k_conv] = (\\n                        self.thre_conv1[k_conv]\\n                        - np.sum(pd_conv1_all[k_conv]) * self.rate_thre\\n                    )\\n                # all connected layer\\n                self.wkj = self.wkj + pd_k_all.T * bp_out2 * self.rate_weight\\n                self.vji = self.vji + pd_j_all.T * bp_out1 * self.rate_weight\\n                self.thre_bp3 = self.thre_bp3 - pd_k_all * self.rate_thre\\n                self.thre_bp2 = self.thre_bp2 - pd_j_all * self.rate_thre\\n                # calculate the sum error of all single image\\n                errors = np.sum(abs(data_teach - bp_out3))\\n                error_count += errors\\n                # print('   ----Teach      ',data_teach)\\n                # print('   ----BP_output  ',bp_out3)\\n            rp = rp + 1\\n            mse = error_count / patterns\\n            all_mse.append(mse)\\n\\n        def draw_error():\\n            yplot = [error_accuracy for i in range(int(n_repeat * 1.2))]\\n            plt.plot(all_mse, \\\"+-\\\")\\n            plt.plot(yplot, \\\"r--\\\")\\n            plt.xlabel(\\\"Learning Times\\\")\\n            plt.ylabel(\\\"All_mse\\\")\\n            plt.grid(True, alpha=0.5)\\n            plt.show()\\n\\n        print(\\\"------------------Training Complished---------------------\\\")\\n        print((\\\" - - Training epoch: \\\", rp, \\\"     - - Mse: %.6f\\\" % mse))\\n        if draw_e:\\n            draw_error()\\n        return mse\\n\\n    def predict(self, datas_test):\\n        # model predict\\n        produce_out = []\\n        print(\\\"-------------------Start Testing-------------------------\\\")\\n        print((\\\" - - Shape: Test_Data  \\\", np.shape(datas_test)))\\n        for p in range(len(datas_test)):\\n            data_test = np.asmatrix(datas_test[p])\\n            data_focus1, data_conved1 = self.convolute(\\n                data_test,\\n                self.conv1,\\n                self.w_conv1,\\n                self.thre_conv1,\\n                conv_step=self.step_conv1,\\n            )\\n            data_pooled1 = self.pooling(data_conved1, self.size_pooling1)\\n            data_bp_input = self._expand(data_pooled1)\\n\\n            bp_out1 = data_bp_input\\n            bp_net_j = bp_out1 * self.vji.T - self.thre_bp2\\n            bp_out2 = self.sig(bp_net_j)\\n            bp_net_k = bp_out2 * self.wkj.T - self.thre_bp3\\n            bp_out3 = self.sig(bp_net_k)\\n            produce_out.extend(bp_out3.getA().tolist())\\n        res = [list(map(self.do_round, each)) for each in produce_out]\\n        return np.asarray(res)\\n\\n    def convolution(self, data):\\n        # return the data of image after convoluting process so we can check it out\\n        data_test = np.asmatrix(data)\\n        data_focus1, data_conved1 = self.convolute(\\n            data_test,\\n            self.conv1,\\n            self.w_conv1,\\n            self.thre_conv1,\\n            conv_step=self.step_conv1,\\n        )\\n        data_pooled1 = self.pooling(data_conved1, self.size_pooling1)\\n\\n        return data_conved1, data_pooled1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    \\\"\\\"\\\"\\n    I will put the example on other file\\n    \\\"\\\"\\\"\\n\"",
    "gan": "\"import matplotlib.gridspec as gridspec\\nimport matplotlib.pyplot as plt\\nimport numpy as np\\nfrom sklearn.utils import shuffle\\nimport input_data\\n\\nrandom_numer = 42\\n\\nnp.random.seed(random_numer)\\n\\n\\ndef ReLu(x):\\n    mask = (x > 0) * 1.0\\n    return mask * x\\n\\n\\ndef d_ReLu(x):\\n    mask = (x > 0) * 1.0\\n    return mask\\n\\n\\ndef arctan(x):\\n    return np.arctan(x)\\n\\n\\ndef d_arctan(x):\\n    return 1 / (1 + x ** 2)\\n\\n\\ndef log(x):\\n    return 1 / (1 + np.exp(-1 * x))\\n\\n\\ndef d_log(x):\\n    return log(x) * (1 - log(x))\\n\\n\\ndef tanh(x):\\n    return np.tanh(x)\\n\\n\\ndef d_tanh(x):\\n    return 1 - np.tanh(x) ** 2\\n\\n\\ndef plot(samples):\\n    fig = plt.figure(figsize=(4, 4))\\n    gs = gridspec.GridSpec(4, 4)\\n    gs.update(wspace=0.05, hspace=0.05)\\n\\n    for i, sample in enumerate(samples):\\n        ax = plt.subplot(gs[i])\\n        plt.axis(\\\"off\\\")\\n        ax.set_xticklabels([])\\n        ax.set_yticklabels([])\\n        ax.set_aspect(\\\"equal\\\")\\n        plt.imshow(sample.reshape(28, 28), cmap=\\\"Greys_r\\\")\\n\\n    return fig\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # 1. Load Data and declare hyper\\n    print(\\\"--------- Load Data ----------\\\")\\n    mnist = input_data.read_data_sets(\\\"MNIST_data\\\", one_hot=False)\\n    temp = mnist.test\\n    images, labels = temp.images, temp.labels\\n    images, labels = shuffle(np.asarray(images), np.asarray(labels))\\n    num_epoch = 10\\n    learing_rate = 0.00009\\n    G_input = 100\\n    hidden_input, hidden_input2, hidden_input3 = 128, 256, 346\\n    hidden_input4, hidden_input5, hidden_input6 = 480, 560, 686\\n\\n    print(\\\"--------- Declare Hyper Parameters ----------\\\")\\n    # 2. Declare Weights\\n    D_W1 = (\\n        np.random.normal(size=(784, hidden_input), scale=(1.0 / np.sqrt(784 / 2.0)))\\n        * 0.002\\n    )\\n    # D_b1 = np.random.normal(size=(128),scale=(1. / np.sqrt(128 / 2.)))       *0.002\\n    D_b1 = np.zeros(hidden_input)\\n\\n    D_W2 = (\\n        np.random.normal(\\n            size=(hidden_input, 1), scale=(1.0 / np.sqrt(hidden_input / 2.0))\\n        )\\n        * 0.002\\n    )\\n    # D_b2 = np.random.normal(size=(1),scale=(1. / np.sqrt(1 / 2.)))           *0.002\\n    D_b2 = np.zeros(1)\\n\\n    G_W1 = (\\n        np.random.normal(\\n            size=(G_input, hidden_input), scale=(1.0 / np.sqrt(G_input / 2.0))\\n        )\\n        * 0.002\\n    )\\n    # G_b1 = np.random.normal(size=(128),scale=(1. / np.sqrt(128 / 2.)))      *0.002\\n    G_b1 = np.zeros(hidden_input)\\n\\n    G_W2 = (\\n        np.random.normal(\\n            size=(hidden_input, hidden_input2),\\n            scale=(1.0 / np.sqrt(hidden_input / 2.0)),\\n        )\\n        * 0.002\\n    )\\n    # G_b1 = np.random.normal(size=(128),scale=(1. / np.sqrt(128 / 2.)))      *0.002\\n    G_b2 = np.zeros(hidden_input2)\\n\\n    G_W3 = (\\n        np.random.normal(\\n            size=(hidden_input2, hidden_input3),\\n            scale=(1.0 / np.sqrt(hidden_input2 / 2.0)),\\n        )\\n        * 0.002\\n    )\\n    # G_b1 = np.random.normal(size=(128),scale=(1. / np.sqrt(128 / 2.)))      *0.002\\n    G_b3 = np.zeros(hidden_input3)\\n\\n    G_W4 = (\\n        np.random.normal(\\n            size=(hidden_input3, hidden_input4),\\n            scale=(1.0 / np.sqrt(hidden_input3 / 2.0)),\\n        )\\n        * 0.002\\n    )\\n    # G_b1 = np.random.normal(size=(128),scale=(1. / np.sqrt(128 / 2.)))      *0.002\\n    G_b4 = np.zeros(hidden_input4)\\n\\n    G_W5 = (\\n        np.random.normal(\\n            size=(hidden_input4, hidden_input5),\\n            scale=(1.0 / np.sqrt(hidden_input4 / 2.0)),\\n        )\\n        * 0.002\\n    )\\n    # G_b1 = np.random.normal(size=(128),scale=(1. / np.sqrt(128 / 2.)))      *0.002\\n    G_b5 = np.zeros(hidden_input5)\\n\\n    G_W6 = (\\n        np.random.normal(\\n            size=(hidden_input5, hidden_input6),\\n            scale=(1.0 / np.sqrt(hidden_input5 / 2.0)),\\n        )\\n        * 0.002\\n    )\\n    # G_b1 = np.random.normal(size=(128),scale=(1. / np.sqrt(128 / 2.)))      *0.002\\n    G_b6 = np.zeros(hidden_input6)\\n\\n    G_W7 = (\\n        np.random.normal(\\n            size=(hidden_input6, 784), scale=(1.0 / np.sqrt(hidden_input6 / 2.0))\\n        )\\n        * 0.002\\n    )\\n    # G_b2 = np.random.normal(size=(784),scale=(1. / np.sqrt(784 / 2.)))      *0.002\\n    G_b7 = np.zeros(784)\\n\\n    # 3. For Adam Optimzier\\n    v1, m1 = 0, 0\\n    v2, m2 = 0, 0\\n    v3, m3 = 0, 0\\n    v4, m4 = 0, 0\\n\\n    v5, m5 = 0, 0\\n    v6, m6 = 0, 0\\n    v7, m7 = 0, 0\\n    v8, m8 = 0, 0\\n    v9, m9 = 0, 0\\n    v10, m10 = 0, 0\\n    v11, m11 = 0, 0\\n    v12, m12 = 0, 0\\n\\n    v13, m13 = 0, 0\\n    v14, m14 = 0, 0\\n\\n    v15, m15 = 0, 0\\n    v16, m16 = 0, 0\\n\\n    v17, m17 = 0, 0\\n    v18, m18 = 0, 0\\n\\n    beta_1, beta_2, eps = 0.9, 0.999, 0.00000001\\n\\n    print(\\\"--------- Started Training ----------\\\")\\n    for iter in range(num_epoch):\\n\\n        random_int = np.random.randint(len(images) - 5)\\n        current_image = np.expand_dims(images[random_int], axis=0)\\n\\n        # Func: Generate The first Fake Data\\n        Z = np.random.uniform(-1.0, 1.0, size=[1, G_input])\\n        Gl1 = Z.dot(G_W1) + G_b1\\n        Gl1A = arctan(Gl1)\\n        Gl2 = Gl1A.dot(G_W2) + G_b2\\n        Gl2A = ReLu(Gl2)\\n        Gl3 = Gl2A.dot(G_W3) + G_b3\\n        Gl3A = arctan(Gl3)\\n\\n        Gl4 = Gl3A.dot(G_W4) + G_b4\\n        Gl4A = ReLu(Gl4)\\n        Gl5 = Gl4A.dot(G_W5) + G_b5\\n        Gl5A = tanh(Gl5)\\n        Gl6 = Gl5A.dot(G_W6) + G_b6\\n        Gl6A = ReLu(Gl6)\\n        Gl7 = Gl6A.dot(G_W7) + G_b7\\n\\n        current_fake_data = log(Gl7)\\n\\n        # Func: Forward Feed for Real data\\n        Dl1_r = current_image.dot(D_W1) + D_b1\\n        Dl1_rA = ReLu(Dl1_r)\\n        Dl2_r = Dl1_rA.dot(D_W2) + D_b2\\n        Dl2_rA = log(Dl2_r)\\n\\n        # Func: Forward Feed for Fake Data\\n        Dl1_f = current_fake_data.dot(D_W1) + D_b1\\n        Dl1_fA = ReLu(Dl1_f)\\n        Dl2_f = Dl1_fA.dot(D_W2) + D_b2\\n        Dl2_fA = log(Dl2_f)\\n\\n        # Func: Cost D\\n        D_cost = -np.log(Dl2_rA) + np.log(1.0 - Dl2_fA)\\n\\n        # Func: Gradient\\n        grad_f_w2_part_1 = 1 / (1.0 - Dl2_fA)\\n        grad_f_w2_part_2 = d_log(Dl2_f)\\n        grad_f_w2_part_3 = Dl1_fA\\n        grad_f_w2 = grad_f_w2_part_3.T.dot(grad_f_w2_part_1 * grad_f_w2_part_2)\\n        grad_f_b2 = grad_f_w2_part_1 * grad_f_w2_part_2\\n\\n        grad_f_w1_part_1 = (grad_f_w2_part_1 * grad_f_w2_part_2).dot(D_W2.T)\\n        grad_f_w1_part_2 = d_ReLu(Dl1_f)\\n        grad_f_w1_part_3 = current_fake_data\\n        grad_f_w1 = grad_f_w1_part_3.T.dot(grad_f_w1_part_1 * grad_f_w1_part_2)\\n        grad_f_b1 = grad_f_w1_part_1 * grad_f_w1_part_2\\n\\n        grad_r_w2_part_1 = -1 / Dl2_rA\\n        grad_r_w2_part_2 = d_log(Dl2_r)\\n        grad_r_w2_part_3 = Dl1_rA\\n        grad_r_w2 = grad_r_w2_part_3.T.dot(grad_r_w2_part_1 * grad_r_w2_part_2)\\n        grad_r_b2 = grad_r_w2_part_1 * grad_r_w2_part_2\\n\\n        grad_r_w1_part_1 = (grad_r_w2_part_1 * grad_r_w2_part_2).dot(D_W2.T)\\n        grad_r_w1_part_2 = d_ReLu(Dl1_r)\\n        grad_r_w1_part_3 = current_image\\n        grad_r_w1 = grad_r_w1_part_3.T.dot(grad_r_w1_part_1 * grad_r_w1_part_2)\\n        grad_r_b1 = grad_r_w1_part_1 * grad_r_w1_part_2\\n\\n        grad_w1 = grad_f_w1 + grad_r_w1\\n        grad_b1 = grad_f_b1 + grad_r_b1\\n\\n        grad_w2 = grad_f_w2 + grad_r_w2\\n        grad_b2 = grad_f_b2 + grad_r_b2\\n\\n        # ---- Update Gradient ----\\n        m1 = beta_1 * m1 + (1 - beta_1) * grad_w1\\n        v1 = beta_2 * v1 + (1 - beta_2) * grad_w1 ** 2\\n\\n        m2 = beta_1 * m2 + (1 - beta_1) * grad_b1\\n        v2 = beta_2 * v2 + (1 - beta_2) * grad_b1 ** 2\\n\\n        m3 = beta_1 * m3 + (1 - beta_1) * grad_w2\\n        v3 = beta_2 * v3 + (1 - beta_2) * grad_w2 ** 2\\n\\n        m4 = beta_1 * m4 + (1 - beta_1) * grad_b2\\n        v4 = beta_2 * v4 + (1 - beta_2) * grad_b2 ** 2\\n\\n        D_W1 = D_W1 - (learing_rate / (np.sqrt(v1 / (1 - beta_2)) + eps)) * (\\n            m1 / (1 - beta_1)\\n        )\\n        D_b1 = D_b1 - (learing_rate / (np.sqrt(v2 / (1 - beta_2)) + eps)) * (\\n            m2 / (1 - beta_1)\\n        )\\n\\n        D_W2 = D_W2 - (learing_rate / (np.sqrt(v3 / (1 - beta_2)) + eps)) * (\\n            m3 / (1 - beta_1)\\n        )\\n        D_b2 = D_b2 - (learing_rate / (np.sqrt(v4 / (1 - beta_2)) + eps)) * (\\n            m4 / (1 - beta_1)\\n        )\\n\\n        # Func: Forward Feed for G\\n        Z = np.random.uniform(-1.0, 1.0, size=[1, G_input])\\n        Gl1 = Z.dot(G_W1) + G_b1\\n        Gl1A = arctan(Gl1)\\n        Gl2 = Gl1A.dot(G_W2) + G_b2\\n        Gl2A = ReLu(Gl2)\\n        Gl3 = Gl2A.dot(G_W3) + G_b3\\n        Gl3A = arctan(Gl3)\\n\\n        Gl4 = Gl3A.dot(G_W4) + G_b4\\n        Gl4A = ReLu(Gl4)\\n        Gl5 = Gl4A.dot(G_W5) + G_b5\\n        Gl5A = tanh(Gl5)\\n        Gl6 = Gl5A.dot(G_W6) + G_b6\\n        Gl6A = ReLu(Gl6)\\n        Gl7 = Gl6A.dot(G_W7) + G_b7\\n\\n        current_fake_data = log(Gl7)\\n\\n        Dl1 = current_fake_data.dot(D_W1) + D_b1\\n        Dl1_A = ReLu(Dl1)\\n        Dl2 = Dl1_A.dot(D_W2) + D_b2\\n        Dl2_A = log(Dl2)\\n\\n        # Func: Cost G\\n        G_cost = -np.log(Dl2_A)\\n\\n        # Func: Gradient\\n        grad_G_w7_part_1 = ((-1 / Dl2_A) * d_log(Dl2).dot(D_W2.T) * (d_ReLu(Dl1))).dot(\\n            D_W1.T\\n        )\\n        grad_G_w7_part_2 = d_log(Gl7)\\n        grad_G_w7_part_3 = Gl6A\\n        grad_G_w7 = grad_G_w7_part_3.T.dot(grad_G_w7_part_1 * grad_G_w7_part_1)\\n        grad_G_b7 = grad_G_w7_part_1 * grad_G_w7_part_2\\n\\n        grad_G_w6_part_1 = (grad_G_w7_part_1 * grad_G_w7_part_2).dot(G_W7.T)\\n        grad_G_w6_part_2 = d_ReLu(Gl6)\\n        grad_G_w6_part_3 = Gl5A\\n        grad_G_w6 = grad_G_w6_part_3.T.dot(grad_G_w6_part_1 * grad_G_w6_part_2)\\n        grad_G_b6 = grad_G_w6_part_1 * grad_G_w6_part_2\\n\\n        grad_G_w5_part_1 = (grad_G_w6_part_1 * grad_G_w6_part_2).dot(G_W6.T)\\n        grad_G_w5_part_2 = d_tanh(Gl5)\\n        grad_G_w5_part_3 = Gl4A\\n        grad_G_w5 = grad_G_w5_part_3.T.dot(grad_G_w5_part_1 * grad_G_w5_part_2)\\n        grad_G_b5 = grad_G_w5_part_1 * grad_G_w5_part_2\\n\\n        grad_G_w4_part_1 = (grad_G_w5_part_1 * grad_G_w5_part_2).dot(G_W5.T)\\n        grad_G_w4_part_2 = d_ReLu(Gl4)\\n        grad_G_w4_part_3 = Gl3A\\n        grad_G_w4 = grad_G_w4_part_3.T.dot(grad_G_w4_part_1 * grad_G_w4_part_2)\\n        grad_G_b4 = grad_G_w4_part_1 * grad_G_w4_part_2\\n\\n        grad_G_w3_part_1 = (grad_G_w4_part_1 * grad_G_w4_part_2).dot(G_W4.T)\\n        grad_G_w3_part_2 = d_arctan(Gl3)\\n        grad_G_w3_part_3 = Gl2A\\n        grad_G_w3 = grad_G_w3_part_3.T.dot(grad_G_w3_part_1 * grad_G_w3_part_2)\\n        grad_G_b3 = grad_G_w3_part_1 * grad_G_w3_part_2\\n\\n        grad_G_w2_part_1 = (grad_G_w3_part_1 * grad_G_w3_part_2).dot(G_W3.T)\\n        grad_G_w2_part_2 = d_ReLu(Gl2)\\n        grad_G_w2_part_3 = Gl1A\\n        grad_G_w2 = grad_G_w2_part_3.T.dot(grad_G_w2_part_1 * grad_G_w2_part_2)\\n        grad_G_b2 = grad_G_w2_part_1 * grad_G_w2_part_2\\n\\n        grad_G_w1_part_1 = (grad_G_w2_part_1 * grad_G_w2_part_2).dot(G_W2.T)\\n        grad_G_w1_part_2 = d_arctan(Gl1)\\n        grad_G_w1_part_3 = Z\\n        grad_G_w1 = grad_G_w1_part_3.T.dot(grad_G_w1_part_1 * grad_G_w1_part_2)\\n        grad_G_b1 = grad_G_w1_part_1 * grad_G_w1_part_2\\n\\n        # ---- Update Gradient ----\\n        m5 = beta_1 * m5 + (1 - beta_1) * grad_G_w1\\n        v5 = beta_2 * v5 + (1 - beta_2) * grad_G_w1 ** 2\\n\\n        m6 = beta_1 * m6 + (1 - beta_1) * grad_G_b1\\n        v6 = beta_2 * v6 + (1 - beta_2) * grad_G_b1 ** 2\\n\\n        m7 = beta_1 * m7 + (1 - beta_1) * grad_G_w2\\n        v7 = beta_2 * v7 + (1 - beta_2) * grad_G_w2 ** 2\\n\\n        m8 = beta_1 * m8 + (1 - beta_1) * grad_G_b2\\n        v8 = beta_2 * v8 + (1 - beta_2) * grad_G_b2 ** 2\\n\\n        m9 = beta_1 * m9 + (1 - beta_1) * grad_G_w3\\n        v9 = beta_2 * v9 + (1 - beta_2) * grad_G_w3 ** 2\\n\\n        m10 = beta_1 * m10 + (1 - beta_1) * grad_G_b3\\n        v10 = beta_2 * v10 + (1 - beta_2) * grad_G_b3 ** 2\\n\\n        m11 = beta_1 * m11 + (1 - beta_1) * grad_G_w4\\n        v11 = beta_2 * v11 + (1 - beta_2) * grad_G_w4 ** 2\\n\\n        m12 = beta_1 * m12 + (1 - beta_1) * grad_G_b4\\n        v12 = beta_2 * v12 + (1 - beta_2) * grad_G_b4 ** 2\\n\\n        m13 = beta_1 * m13 + (1 - beta_1) * grad_G_w5\\n        v13 = beta_2 * v13 + (1 - beta_2) * grad_G_w5 ** 2\\n\\n        m14 = beta_1 * m14 + (1 - beta_1) * grad_G_b5\\n        v14 = beta_2 * v14 + (1 - beta_2) * grad_G_b5 ** 2\\n\\n        m15 = beta_1 * m15 + (1 - beta_1) * grad_G_w6\\n        v15 = beta_2 * v15 + (1 - beta_2) * grad_G_w6 ** 2\\n\\n        m16 = beta_1 * m16 + (1 - beta_1) * grad_G_b6\\n        v16 = beta_2 * v16 + (1 - beta_2) * grad_G_b6 ** 2\\n\\n        m17 = beta_1 * m17 + (1 - beta_1) * grad_G_w7\\n        v17 = beta_2 * v17 + (1 - beta_2) * grad_G_w7 ** 2\\n\\n        m18 = beta_1 * m18 + (1 - beta_1) * grad_G_b7\\n        v18 = beta_2 * v18 + (1 - beta_2) * grad_G_b7 ** 2\\n\\n        G_W1 = G_W1 - (learing_rate / (np.sqrt(v5 / (1 - beta_2)) + eps)) * (\\n            m5 / (1 - beta_1)\\n        )\\n        G_b1 = G_b1 - (learing_rate / (np.sqrt(v6 / (1 - beta_2)) + eps)) * (\\n            m6 / (1 - beta_1)\\n        )\\n\\n        G_W2 = G_W2 - (learing_rate / (np.sqrt(v7 / (1 - beta_2)) + eps)) * (\\n            m7 / (1 - beta_1)\\n        )\\n        G_b2 = G_b2 - (learing_rate / (np.sqrt(v8 / (1 - beta_2)) + eps)) * (\\n            m8 / (1 - beta_1)\\n        )\\n\\n        G_W3 = G_W3 - (learing_rate / (np.sqrt(v9 / (1 - beta_2)) + eps)) * (\\n            m9 / (1 - beta_1)\\n        )\\n        G_b3 = G_b3 - (learing_rate / (np.sqrt(v10 / (1 - beta_2)) + eps)) * (\\n            m10 / (1 - beta_1)\\n        )\\n\\n        G_W4 = G_W4 - (learing_rate / (np.sqrt(v11 / (1 - beta_2)) + eps)) * (\\n            m11 / (1 - beta_1)\\n        )\\n        G_b4 = G_b4 - (learing_rate / (np.sqrt(v12 / (1 - beta_2)) + eps)) * (\\n            m12 / (1 - beta_1)\\n        )\\n\\n        G_W5 = G_W5 - (learing_rate / (np.sqrt(v13 / (1 - beta_2)) + eps)) * (\\n            m13 / (1 - beta_1)\\n        )\\n        G_b5 = G_b5 - (learing_rate / (np.sqrt(v14 / (1 - beta_2)) + eps)) * (\\n            m14 / (1 - beta_1)\\n        )\\n\\n        G_W6 = G_W6 - (learing_rate / (np.sqrt(v15 / (1 - beta_2)) + eps)) * (\\n            m15 / (1 - beta_1)\\n        )\\n        G_b6 = G_b6 - (learing_rate / (np.sqrt(v16 / (1 - beta_2)) + eps)) * (\\n            m16 / (1 - beta_1)\\n        )\\n\\n        G_W7 = G_W7 - (learing_rate / (np.sqrt(v17 / (1 - beta_2)) + eps)) * (\\n            m17 / (1 - beta_1)\\n        )\\n        G_b7 = G_b7 - (learing_rate / (np.sqrt(v18 / (1 - beta_2)) + eps)) * (\\n            m18 / (1 - beta_1)\\n        )\\n\\n        # --- Print Error ----\\n        # print(\\\"Current Iter: \\\",iter, \\\" Current D cost:\\\",D_cost, \\\" Current G cost: \\\", G_cost,end='\\\\r')\\n\\n        if iter == 0:\\n            learing_rate = learing_rate * 0.01\\n        if iter == 40:\\n            learing_rate = learing_rate * 0.01\\n\\n        # ---- Print to Out put ----\\n        if iter % 10 == 0:\\n\\n            print(\\n                \\\"Current Iter: \\\",\\n                iter,\\n                \\\" Current D cost:\\\",\\n                D_cost,\\n                \\\" Current G cost: \\\",\\n                G_cost,\\n                end=\\\"\\\\r\\\",\\n            )\\n            print(\\\"--------- Show Example Result See Tab Above ----------\\\")\\n            print(\\\"--------- Wait for the image to load ---------\\\")\\n            Z = np.random.uniform(-1.0, 1.0, size=[16, G_input])\\n\\n            Gl1 = Z.dot(G_W1) + G_b1\\n            Gl1A = arctan(Gl1)\\n            Gl2 = Gl1A.dot(G_W2) + G_b2\\n            Gl2A = ReLu(Gl2)\\n            Gl3 = Gl2A.dot(G_W3) + G_b3\\n            Gl3A = arctan(Gl3)\\n\\n            Gl4 = Gl3A.dot(G_W4) + G_b4\\n            Gl4A = ReLu(Gl4)\\n            Gl5 = Gl4A.dot(G_W5) + G_b5\\n            Gl5A = tanh(Gl5)\\n            Gl6 = Gl5A.dot(G_W6) + G_b6\\n            Gl6A = ReLu(Gl6)\\n            Gl7 = Gl6A.dot(G_W7) + G_b7\\n\\n            current_fake_data = log(Gl7)\\n\\n            fig = plot(current_fake_data)\\n            fig.savefig(\\n                \\\"Click_Me_{}.png\\\".format(\\n                    str(iter).zfill(3)\\n                    + \\\"_Ginput_\\\"\\n                    + str(G_input)\\n                    + \\\"_hiddenone\\\"\\n                    + str(hidden_input)\\n                    + \\\"_hiddentwo\\\"\\n                    + str(hidden_input2)\\n                    + \\\"_LR_\\\"\\n                    + str(learing_rate)\\n                ),\\n                bbox_inches=\\\"tight\\\",\\n            )\\n    # for complete explanation visit https://towardsdatascience.com/only-numpy-implementing-gan-general-adversarial-networks-and-adam-optimizer-using-numpy-with-2a7e4e032021\\n    # -- end code --\\n\"",
    "input data": "\"# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\\n#\\n# Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n# you may not use this file except in compliance with the License.\\n# You may obtain a copy of the License at\\n#\\n#     http://www.apache.org/licenses/LICENSE-2.0\\n#\\n# Unless required by applicable law or agreed to in writing, software\\n# distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n# See the License for the specific language governing permissions and\\n# limitations under the License.\\n# ==============================================================================\\n\\\"\\\"\\\"Functions for downloading and reading MNIST data (deprecated).\\n\\nThis module and all its submodules are deprecated.\\n\\\"\\\"\\\"\\n\\n\\nimport collections\\nimport gzip\\nimport os\\n\\nimport numpy\\nfrom six.moves import urllib\\nfrom six.moves import xrange  # pylint: disable=redefined-builtin\\n\\nfrom tensorflow.python.framework import dtypes\\nfrom tensorflow.python.framework import random_seed\\nfrom tensorflow.python.platform import gfile\\nfrom tensorflow.python.util.deprecation import deprecated\\n\\n_Datasets = collections.namedtuple(\\\"_Datasets\\\", [\\\"train\\\", \\\"validation\\\", \\\"test\\\"])\\n\\n# CVDF mirror of http://yann.lecun.com/exdb/mnist/\\nDEFAULT_SOURCE_URL = \\\"https://storage.googleapis.com/cvdf-datasets/mnist/\\\"\\n\\n\\ndef _read32(bytestream):\\n    dt = numpy.dtype(numpy.uint32).newbyteorder(\\\">\\\")\\n    return numpy.frombuffer(bytestream.read(4), dtype=dt)[0]\\n\\n\\n@deprecated(None, \\\"Please use tf.data to implement this functionality.\\\")\\ndef _extract_images(f):\\n    \\\"\\\"\\\"Extract the images into a 4D uint8 numpy array [index, y, x, depth].\\n\\n  Args:\\n    f: A file object that can be passed into a gzip reader.\\n\\n  Returns:\\n    data: A 4D uint8 numpy array [index, y, x, depth].\\n\\n  Raises:\\n    ValueError: If the bytestream does not start with 2051.\\n\\n  \\\"\\\"\\\"\\n    print(\\\"Extracting\\\", f.name)\\n    with gzip.GzipFile(fileobj=f) as bytestream:\\n        magic = _read32(bytestream)\\n        if magic != 2051:\\n            raise ValueError(\\n                \\\"Invalid magic number %d in MNIST image file: %s\\\" % (magic, f.name)\\n            )\\n        num_images = _read32(bytestream)\\n        rows = _read32(bytestream)\\n        cols = _read32(bytestream)\\n        buf = bytestream.read(rows * cols * num_images)\\n        data = numpy.frombuffer(buf, dtype=numpy.uint8)\\n        data = data.reshape(num_images, rows, cols, 1)\\n        return data\\n\\n\\n@deprecated(None, \\\"Please use tf.one_hot on tensors.\\\")\\ndef _dense_to_one_hot(labels_dense, num_classes):\\n    \\\"\\\"\\\"Convert class labels from scalars to one-hot vectors.\\\"\\\"\\\"\\n    num_labels = labels_dense.shape[0]\\n    index_offset = numpy.arange(num_labels) * num_classes\\n    labels_one_hot = numpy.zeros((num_labels, num_classes))\\n    labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1\\n    return labels_one_hot\\n\\n\\n@deprecated(None, \\\"Please use tf.data to implement this functionality.\\\")\\ndef _extract_labels(f, one_hot=False, num_classes=10):\\n    \\\"\\\"\\\"Extract the labels into a 1D uint8 numpy array [index].\\n\\n  Args:\\n    f: A file object that can be passed into a gzip reader.\\n    one_hot: Does one hot encoding for the result.\\n    num_classes: Number of classes for the one hot encoding.\\n\\n  Returns:\\n    labels: a 1D uint8 numpy array.\\n\\n  Raises:\\n    ValueError: If the bystream doesn't start with 2049.\\n  \\\"\\\"\\\"\\n    print(\\\"Extracting\\\", f.name)\\n    with gzip.GzipFile(fileobj=f) as bytestream:\\n        magic = _read32(bytestream)\\n        if magic != 2049:\\n            raise ValueError(\\n                \\\"Invalid magic number %d in MNIST label file: %s\\\" % (magic, f.name)\\n            )\\n        num_items = _read32(bytestream)\\n        buf = bytestream.read(num_items)\\n        labels = numpy.frombuffer(buf, dtype=numpy.uint8)\\n        if one_hot:\\n            return _dense_to_one_hot(labels, num_classes)\\n        return labels\\n\\n\\nclass _DataSet:\\n    \\\"\\\"\\\"Container class for a _DataSet (deprecated).\\n\\n  THIS CLASS IS DEPRECATED.\\n  \\\"\\\"\\\"\\n\\n    @deprecated(\\n        None,\\n        \\\"Please use alternatives such as official/mnist/_DataSet.py\\\"\\n        \\\" from tensorflow/models.\\\",\\n    )\\n    def __init__(\\n        self,\\n        images,\\n        labels,\\n        fake_data=False,\\n        one_hot=False,\\n        dtype=dtypes.float32,\\n        reshape=True,\\n        seed=None,\\n    ):\\n        \\\"\\\"\\\"Construct a _DataSet.\\n\\n    one_hot arg is used only if fake_data is true.  `dtype` can be either\\n    `uint8` to leave the input as `[0, 255]`, or `float32` to rescale into\\n    `[0, 1]`.  Seed arg provides for convenient deterministic testing.\\n\\n    Args:\\n      images: The images\\n      labels: The labels\\n      fake_data: Ignore inages and labels, use fake data.\\n      one_hot: Bool, return the labels as one hot vectors (if True) or ints (if\\n        False).\\n      dtype: Output image dtype. One of [uint8, float32]. `uint8` output has\\n        range [0,255]. float32 output has range [0,1].\\n      reshape: Bool. If True returned images are returned flattened to vectors.\\n      seed: The random seed to use.\\n    \\\"\\\"\\\"\\n        seed1, seed2 = random_seed.get_seed(seed)\\n        # If op level seed is not set, use whatever graph level seed is returned\\n        numpy.random.seed(seed1 if seed is None else seed2)\\n        dtype = dtypes.as_dtype(dtype).base_dtype\\n        if dtype not in (dtypes.uint8, dtypes.float32):\\n            raise TypeError(\\\"Invalid image dtype %r, expected uint8 or float32\\\" % dtype)\\n        if fake_data:\\n            self._num_examples = 10000\\n            self.one_hot = one_hot\\n        else:\\n            assert (\\n                images.shape[0] == labels.shape[0]\\n            ), f\\\"images.shape: {images.shape} labels.shape: {labels.shape}\\\"\\n            self._num_examples = images.shape[0]\\n\\n            # Convert shape from [num examples, rows, columns, depth]\\n            # to [num examples, rows*columns] (assuming depth == 1)\\n            if reshape:\\n                assert images.shape[3] == 1\\n                images = images.reshape(\\n                    images.shape[0], images.shape[1] * images.shape[2]\\n                )\\n            if dtype == dtypes.float32:\\n                # Convert from [0, 255] -> [0.0, 1.0].\\n                images = images.astype(numpy.float32)\\n                images = numpy.multiply(images, 1.0 / 255.0)\\n        self._images = images\\n        self._labels = labels\\n        self._epochs_completed = 0\\n        self._index_in_epoch = 0\\n\\n    @property\\n    def images(self):\\n        return self._images\\n\\n    @property\\n    def labels(self):\\n        return self._labels\\n\\n    @property\\n    def num_examples(self):\\n        return self._num_examples\\n\\n    @property\\n    def epochs_completed(self):\\n        return self._epochs_completed\\n\\n    def next_batch(self, batch_size, fake_data=False, shuffle=True):\\n        \\\"\\\"\\\"Return the next `batch_size` examples from this data set.\\\"\\\"\\\"\\n        if fake_data:\\n            fake_image = [1] * 784\\n            if self.one_hot:\\n                fake_label = [1] + [0] * 9\\n            else:\\n                fake_label = 0\\n            return (\\n                [fake_image for _ in xrange(batch_size)],\\n                [fake_label for _ in xrange(batch_size)],\\n            )\\n        start = self._index_in_epoch\\n        # Shuffle for the first epoch\\n        if self._epochs_completed == 0 and start == 0 and shuffle:\\n            perm0 = numpy.arange(self._num_examples)\\n            numpy.random.shuffle(perm0)\\n            self._images = self.images[perm0]\\n            self._labels = self.labels[perm0]\\n        # Go to the next epoch\\n        if start + batch_size > self._num_examples:\\n            # Finished epoch\\n            self._epochs_completed += 1\\n            # Get the rest examples in this epoch\\n            rest_num_examples = self._num_examples - start\\n            images_rest_part = self._images[start : self._num_examples]\\n            labels_rest_part = self._labels[start : self._num_examples]\\n            # Shuffle the data\\n            if shuffle:\\n                perm = numpy.arange(self._num_examples)\\n                numpy.random.shuffle(perm)\\n                self._images = self.images[perm]\\n                self._labels = self.labels[perm]\\n            # Start next epoch\\n            start = 0\\n            self._index_in_epoch = batch_size - rest_num_examples\\n            end = self._index_in_epoch\\n            images_new_part = self._images[start:end]\\n            labels_new_part = self._labels[start:end]\\n            return (\\n                numpy.concatenate((images_rest_part, images_new_part), axis=0),\\n                numpy.concatenate((labels_rest_part, labels_new_part), axis=0),\\n            )\\n        else:\\n            self._index_in_epoch += batch_size\\n            end = self._index_in_epoch\\n            return self._images[start:end], self._labels[start:end]\\n\\n\\n@deprecated(None, \\\"Please write your own downloading logic.\\\")\\ndef _maybe_download(filename, work_directory, source_url):\\n    \\\"\\\"\\\"Download the data from source url, unless it's already here.\\n\\n  Args:\\n      filename: string, name of the file in the directory.\\n      work_directory: string, path to working directory.\\n      source_url: url to download from if file doesn't exist.\\n\\n  Returns:\\n      Path to resulting file.\\n  \\\"\\\"\\\"\\n    if not gfile.Exists(work_directory):\\n        gfile.MakeDirs(work_directory)\\n    filepath = os.path.join(work_directory, filename)\\n    if not gfile.Exists(filepath):\\n        urllib.request.urlretrieve(source_url, filepath)\\n        with gfile.GFile(filepath) as f:\\n            size = f.size()\\n        print(\\\"Successfully downloaded\\\", filename, size, \\\"bytes.\\\")\\n    return filepath\\n\\n\\n@deprecated(\\n    None, \\\"Please use alternatives such as:\\\" \\\" tensorflow_datasets.load('mnist')\\\"\\n)\\ndef read_data_sets(\\n    train_dir,\\n    fake_data=False,\\n    one_hot=False,\\n    dtype=dtypes.float32,\\n    reshape=True,\\n    validation_size=5000,\\n    seed=None,\\n    source_url=DEFAULT_SOURCE_URL,\\n):\\n    if fake_data:\\n\\n        def fake():\\n            return _DataSet(\\n                [], [], fake_data=True, one_hot=one_hot, dtype=dtype, seed=seed\\n            )\\n\\n        train = fake()\\n        validation = fake()\\n        test = fake()\\n        return _Datasets(train=train, validation=validation, test=test)\\n\\n    if not source_url:  # empty string check\\n        source_url = DEFAULT_SOURCE_URL\\n\\n    train_images_file = \\\"train-images-idx3-ubyte.gz\\\"\\n    train_labels_file = \\\"train-labels-idx1-ubyte.gz\\\"\\n    test_images_file = \\\"t10k-images-idx3-ubyte.gz\\\"\\n    test_labels_file = \\\"t10k-labels-idx1-ubyte.gz\\\"\\n\\n    local_file = _maybe_download(\\n        train_images_file, train_dir, source_url + train_images_file\\n    )\\n    with gfile.Open(local_file, \\\"rb\\\") as f:\\n        train_images = _extract_images(f)\\n\\n    local_file = _maybe_download(\\n        train_labels_file, train_dir, source_url + train_labels_file\\n    )\\n    with gfile.Open(local_file, \\\"rb\\\") as f:\\n        train_labels = _extract_labels(f, one_hot=one_hot)\\n\\n    local_file = _maybe_download(\\n        test_images_file, train_dir, source_url + test_images_file\\n    )\\n    with gfile.Open(local_file, \\\"rb\\\") as f:\\n        test_images = _extract_images(f)\\n\\n    local_file = _maybe_download(\\n        test_labels_file, train_dir, source_url + test_labels_file\\n    )\\n    with gfile.Open(local_file, \\\"rb\\\") as f:\\n        test_labels = _extract_labels(f, one_hot=one_hot)\\n\\n    if not 0 <= validation_size <= len(train_images):\\n        raise ValueError(\\n            f\\\"Validation size should be between 0 and {len(train_images)}. Received: {validation_size}.\\\"\\n        )\\n\\n    validation_images = train_images[:validation_size]\\n    validation_labels = train_labels[:validation_size]\\n    train_images = train_images[validation_size:]\\n    train_labels = train_labels[validation_size:]\\n\\n    options = dict(dtype=dtype, reshape=reshape, seed=seed)\\n\\n    train = _DataSet(train_images, train_labels, **options)\\n    validation = _DataSet(validation_images, validation_labels, **options)\\n    test = _DataSet(test_images, test_labels, **options)\\n\\n    return _Datasets(train=train, validation=validation, test=test)\\n\"",
    "perceptron": "\"\\\"\\\"\\\"\\n    Perceptron\\n    w = w + N * (d(k) - y) * x(k)\\n\\n    Using perceptron network for oil analysis, with Measuring of 3 parameters\\n    that represent chemical characteristics we can classify the oil, in p1 or p2\\n    p1 = -1\\n    p2 = 1\\n\\\"\\\"\\\"\\nimport random\\n\\n\\nclass Perceptron:\\n    def __init__(\\n        self,\\n        sample: list[list[float]],\\n        target: list[int],\\n        learning_rate: float = 0.01,\\n        epoch_number: int = 1000,\\n        bias: float = -1,\\n    ) -> None:\\n        \\\"\\\"\\\"\\n        Initializes a Perceptron network for oil analysis\\n        :param sample: sample dataset of 3 parameters with shape [30,3]\\n        :param target: variable for classification with two possible states -1 or 1\\n        :param learning_rate: learning rate used in optimizing.\\n        :param epoch_number: number of epochs to train network on.\\n        :param bias: bias value for the network.\\n\\n        >>> p = Perceptron([], (0, 1, 2))\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: Sample data can not be empty\\n        >>> p = Perceptron(([0], 1, 2), [])\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: Target data can not be empty\\n        >>> p = Perceptron(([0], 1, 2), (0, 1))\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: Sample data and Target data do not have matching lengths\\n        \\\"\\\"\\\"\\n        self.sample = sample\\n        if len(self.sample) == 0:\\n            raise ValueError(\\\"Sample data can not be empty\\\")\\n        self.target = target\\n        if len(self.target) == 0:\\n            raise ValueError(\\\"Target data can not be empty\\\")\\n        if len(self.sample) != len(self.target):\\n            raise ValueError(\\\"Sample data and Target data do not have matching lengths\\\")\\n        self.learning_rate = learning_rate\\n        self.epoch_number = epoch_number\\n        self.bias = bias\\n        self.number_sample = len(sample)\\n        self.col_sample = len(sample[0])  # number of columns in dataset\\n        self.weight: list = []\\n\\n    def training(self) -> None:\\n        \\\"\\\"\\\"\\n        Trains perceptron for epochs <= given number of epochs\\n        :return: None\\n        >>> data = [[2.0149, 0.6192, 10.9263]]\\n        >>> targets = [-1]\\n        >>> perceptron = Perceptron(data,targets)\\n        >>> perceptron.training() # doctest: +ELLIPSIS\\n        ('\\\\\\\\nEpoch:\\\\\\\\n', ...)\\n        ...\\n        \\\"\\\"\\\"\\n        for sample in self.sample:\\n            sample.insert(0, self.bias)\\n\\n        for i in range(self.col_sample):\\n            self.weight.append(random.random())\\n\\n        self.weight.insert(0, self.bias)\\n\\n        epoch_count = 0\\n\\n        while True:\\n            has_misclassified = False\\n            for i in range(self.number_sample):\\n                u = 0\\n                for j in range(self.col_sample + 1):\\n                    u = u + self.weight[j] * self.sample[i][j]\\n                y = self.sign(u)\\n                if y != self.target[i]:\\n                    for j in range(self.col_sample + 1):\\n                        self.weight[j] = (\\n                            self.weight[j]\\n                            + self.learning_rate\\n                            * (self.target[i] - y)\\n                            * self.sample[i][j]\\n                        )\\n                    has_misclassified = True\\n            # print('Epoch: \\\\n',epoch_count)\\n            epoch_count = epoch_count + 1\\n            # if you want control the epoch or just by error\\n            if not has_misclassified:\\n                print((\\\"\\\\nEpoch:\\\\n\\\", epoch_count))\\n                print(\\\"------------------------\\\\n\\\")\\n                # if epoch_count > self.epoch_number or not error:\\n                break\\n\\n    def sort(self, sample: list[float]) -> None:\\n        \\\"\\\"\\\"\\n        :param sample: example row to classify as P1 or P2\\n        :return: None\\n        >>> data = [[2.0149, 0.6192, 10.9263]]\\n        >>> targets = [-1]\\n        >>> perceptron = Perceptron(data,targets)\\n        >>> perceptron.training() # doctest: +ELLIPSIS\\n        ('\\\\\\\\nEpoch:\\\\\\\\n', ...)\\n        ...\\n        >>> perceptron.sort([-0.6508, 0.1097, 4.0009]) # doctest: +ELLIPSIS\\n        ('Sample: ', ...)\\n        classification: P...\\n        \\\"\\\"\\\"\\n        if len(self.sample) == 0:\\n            raise ValueError(\\\"Sample data can not be empty\\\")\\n        sample.insert(0, self.bias)\\n        u = 0\\n        for i in range(self.col_sample + 1):\\n            u = u + self.weight[i] * sample[i]\\n\\n        y = self.sign(u)\\n\\n        if y == -1:\\n            print((\\\"Sample: \\\", sample))\\n            print(\\\"classification: P1\\\")\\n        else:\\n            print((\\\"Sample: \\\", sample))\\n            print(\\\"classification: P2\\\")\\n\\n    def sign(self, u: float) -> int:\\n        \\\"\\\"\\\"\\n        threshold function for classification\\n        :param u: input number\\n        :return: 1 if the input is greater than 0, otherwise -1\\n        >>> data = [[0],[-0.5],[0.5]]\\n        >>> targets = [1,-1,1]\\n        >>> perceptron = Perceptron(data,targets)\\n        >>> perceptron.sign(0)\\n        1\\n        >>> perceptron.sign(-0.5)\\n        -1\\n        >>> perceptron.sign(0.5)\\n        1\\n        \\\"\\\"\\\"\\n        return 1 if u >= 0 else -1\\n\\n\\nsamples = [\\n    [-0.6508, 0.1097, 4.0009],\\n    [-1.4492, 0.8896, 4.4005],\\n    [2.0850, 0.6876, 12.0710],\\n    [0.2626, 1.1476, 7.7985],\\n    [0.6418, 1.0234, 7.0427],\\n    [0.2569, 0.6730, 8.3265],\\n    [1.1155, 0.6043, 7.4446],\\n    [0.0914, 0.3399, 7.0677],\\n    [0.0121, 0.5256, 4.6316],\\n    [-0.0429, 0.4660, 5.4323],\\n    [0.4340, 0.6870, 8.2287],\\n    [0.2735, 1.0287, 7.1934],\\n    [0.4839, 0.4851, 7.4850],\\n    [0.4089, -0.1267, 5.5019],\\n    [1.4391, 0.1614, 8.5843],\\n    [-0.9115, -0.1973, 2.1962],\\n    [0.3654, 1.0475, 7.4858],\\n    [0.2144, 0.7515, 7.1699],\\n    [0.2013, 1.0014, 6.5489],\\n    [0.6483, 0.2183, 5.8991],\\n    [-0.1147, 0.2242, 7.2435],\\n    [-0.7970, 0.8795, 3.8762],\\n    [-1.0625, 0.6366, 2.4707],\\n    [0.5307, 0.1285, 5.6883],\\n    [-1.2200, 0.7777, 1.7252],\\n    [0.3957, 0.1076, 5.6623],\\n    [-0.1013, 0.5989, 7.1812],\\n    [2.4482, 0.9455, 11.2095],\\n    [2.0149, 0.6192, 10.9263],\\n    [0.2012, 0.2611, 5.4631],\\n]\\n\\nexit = [\\n    -1,\\n    -1,\\n    -1,\\n    1,\\n    1,\\n    -1,\\n    1,\\n    -1,\\n    1,\\n    1,\\n    -1,\\n    1,\\n    -1,\\n    -1,\\n    -1,\\n    -1,\\n    1,\\n    1,\\n    1,\\n    1,\\n    -1,\\n    1,\\n    1,\\n    1,\\n    1,\\n    -1,\\n    -1,\\n    1,\\n    -1,\\n    1,\\n]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    network = Perceptron(\\n        sample=samples, target=exit, learning_rate=0.01, epoch_number=1000, bias=-1\\n    )\\n    network.training()\\n    print(\\\"Finished training perceptron\\\")\\n    print(\\\"Enter values to predict or q to exit\\\")\\n    while True:\\n        sample: list = []\\n        for i in range(len(samples[0])):\\n            user_input = input(\\\"value: \\\").strip()\\n            if user_input == \\\"q\\\":\\n                break\\n            observation = float(user_input)\\n            sample.insert(i, observation)\\n        network.sort(sample)\\n\"",
    "activity selection": "\"# flake8: noqa\\n\\n\\\"\\\"\\\"The following implementation assumes that the activities\\nare already sorted according to their finish time\\\"\\\"\\\"\\n\\n\\\"\\\"\\\"Prints a maximum set of activities that can be done by a\\nsingle person, one at a time\\\"\\\"\\\"\\n# n --> Total number of activities\\n# start[]--> An array that contains start time of all activities\\n# finish[] --> An array that contains finish time of all activities\\n\\n\\ndef printMaxActivities(start: list[int], finish: list[int]) -> None:\\n    \\\"\\\"\\\"\\n    >>> start = [1, 3, 0, 5, 8, 5]\\n    >>> finish = [2, 4, 6, 7, 9, 9]\\n    >>> printMaxActivities(start, finish)\\n    The following activities are selected:\\n    0,1,3,4,\\n    \\\"\\\"\\\"\\n    n = len(finish)\\n    print(\\\"The following activities are selected:\\\")\\n\\n    # The first activity is always selected\\n    i = 0\\n    print(i, end=\\\",\\\")\\n\\n    # Consider rest of the activities\\n    for j in range(n):\\n\\n        # If this activity has start time greater than\\n        # or equal to the finish time of previously\\n        # selected activity, then select it\\n        if start[j] >= finish[i]:\\n            print(j, end=\\\",\\\")\\n            i = j\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    start = [1, 3, 0, 5, 8, 5]\\n    finish = [2, 4, 6, 7, 9, 9]\\n    printMaxActivities(start, finish)\\n\"",
    "alternative list arrange": "\"def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\\n    \\\"\\\"\\\"\\n    The method arranges two lists as one list in alternative forms of the list elements.\\n    :param first_input_list:\\n    :param second_input_list:\\n    :return: List\\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\\\"A\\\", \\\"B\\\", \\\"C\\\"])\\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\\n    >>> alternative_list_arrange([\\\"A\\\", \\\"B\\\", \\\"C\\\"], [1, 2, 3, 4, 5])\\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\\n    >>> alternative_list_arrange([\\\"X\\\", \\\"Y\\\", \\\"Z\\\"], [9, 8, 7, 6])\\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\\n    [1, 2, 3, 4, 5]\\n    \\\"\\\"\\\"\\n    first_input_list_length: int = len(first_input_list)\\n    second_input_list_length: int = len(second_input_list)\\n    abs_length: int = (\\n        first_input_list_length\\n        if first_input_list_length > second_input_list_length\\n        else second_input_list_length\\n    )\\n    output_result_list: list = []\\n    for char_count in range(abs_length):\\n        if char_count < first_input_list_length:\\n            output_result_list.append(first_input_list[char_count])\\n        if char_count < second_input_list_length:\\n            output_result_list.append(second_input_list[char_count])\\n\\n    return output_result_list\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(alternative_list_arrange([\\\"A\\\", \\\"B\\\", \\\"C\\\"], [1, 2, 3, 4, 5]), end=\\\" \\\")\\n\"",
    "check strong password": "\"# This Will Check Whether A Given Password Is Strong Or Not\\n# It Follows The Rule that Length Of Password Should Be At Least 8 Characters\\n# And At Least 1 Lower, 1 Upper, 1 Number And 1 Special Character\\n\\nfrom string import ascii_lowercase, ascii_uppercase, digits, punctuation\\n\\n\\ndef strong_password_detector(password: str, min_length: int = 8) -> str:\\n    \\\"\\\"\\\"\\n    >>> strong_password_detector('Hwea7$2!')\\n    'This is a strong Password'\\n\\n    >>> strong_password_detector('Sh0r1')\\n    'Your Password must be at least 8 characters long'\\n\\n    >>> strong_password_detector('Hello123')\\n    'Password should contain UPPERCASE, lowercase, numbers, special characters'\\n\\n    >>> strong_password_detector('Hello1238udfhiaf038fajdvjjf!jaiuFhkqi1')\\n    'This is a strong Password'\\n\\n    >>> strong_password_detector(0)\\n    'Your Password must be at least 8 characters long'\\n    \\\"\\\"\\\"\\n\\n    if len(str(password)) < 8:\\n        return \\\"Your Password must be at least 8 characters long\\\"\\n\\n    upper = any(char in ascii_uppercase for char in password)\\n    lower = any(char in ascii_lowercase for char in password)\\n    num = any(char in digits for char in password)\\n    spec_char = any(char in punctuation for char in password)\\n\\n    if upper and lower and num and spec_char:\\n        return \\\"This is a strong Password\\\"\\n\\n    else:\\n        return (\\n            \\\"Password should contain UPPERCASE, lowercase, \\\"\\n            \\\"numbers, special characters\\\"\\n        )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "davisb putnamb logemannb loveland": "\"#!/usr/bin/env python3\\n\\n\\\"\\\"\\\"\\nDavis–Putnam–Logemann–Loveland (DPLL) algorithm is a complete, backtracking-based\\nsearch algorithm for deciding the satisfiability of propositional logic formulae in\\nconjunctive normal form, i.e, for solving the Conjunctive Normal Form SATisfiability\\n(CNF-SAT) problem.\\n\\nFor more information about the algorithm: https://en.wikipedia.org/wiki/DPLL_algorithm\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport random\\nfrom typing import Iterable\\n\\n\\nclass Clause:\\n    \\\"\\\"\\\"\\n    A clause represented in Conjunctive Normal Form.\\n    A clause is a set of literals, either complemented or otherwise.\\n    For example:\\n        {A1, A2, A3'} is the clause (A1 v A2 v A3')\\n        {A5', A2', A1} is the clause (A5' v A2' v A1)\\n\\n    Create model\\n    >>> clause = Clause([\\\"A1\\\", \\\"A2'\\\", \\\"A3\\\"])\\n    >>> clause.evaluate({\\\"A1\\\": True})\\n    True\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, literals: list[str]) -> None:\\n        \\\"\\\"\\\"\\n        Represent the literals and an assignment in a clause.\\\"\\n        \\\"\\\"\\\"\\n        # Assign all literals to None initially\\n        self.literals: dict[str, bool | None] = {literal: None for literal in literals}\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"\\n        To print a clause as in Conjunctive Normal Form.\\n        >>> str(Clause([\\\"A1\\\", \\\"A2'\\\", \\\"A3\\\"]))\\n        \\\"{A1 , A2' , A3}\\\"\\n        \\\"\\\"\\\"\\n        return \\\"{\\\" + \\\" , \\\".join(self.literals) + \\\"}\\\"\\n\\n    def __len__(self) -> int:\\n        \\\"\\\"\\\"\\n        To print a clause as in Conjunctive Normal Form.\\n        >>> len(Clause([]))\\n        0\\n        >>> len(Clause([\\\"A1\\\", \\\"A2'\\\", \\\"A3\\\"]))\\n        3\\n        \\\"\\\"\\\"\\n        return len(self.literals)\\n\\n    def assign(self, model: dict[str, bool | None]) -> None:\\n        \\\"\\\"\\\"\\n        Assign values to literals of the clause as given by model.\\n        \\\"\\\"\\\"\\n        for literal in self.literals:\\n            symbol = literal[:2]\\n            if symbol in model:\\n                value = model[symbol]\\n            else:\\n                continue\\n            if value is not None:\\n                # Complement assignment if literal is in complemented form\\n                if literal.endswith(\\\"'\\\"):\\n                    value = not value\\n            self.literals[literal] = value\\n\\n    def evaluate(self, model: dict[str, bool | None]) -> bool | None:\\n        \\\"\\\"\\\"\\n        Evaluates the clause with the assignments in model.\\n        This has the following steps:\\n        1. Return True if both a literal and its complement exist in the clause.\\n        2. Return True if a single literal has the assignment True.\\n        3. Return None(unable to complete evaluation) if a literal has no assignment.\\n        4. Compute disjunction of all values assigned in clause.\\n        \\\"\\\"\\\"\\n        for literal in self.literals:\\n            symbol = literal.rstrip(\\\"'\\\") if literal.endswith(\\\"'\\\") else literal + \\\"'\\\"\\n            if symbol in self.literals:\\n                return True\\n\\n        self.assign(model)\\n        for value in self.literals.values():\\n            if value in (True, None):\\n                return value\\n        return any(self.literals.values())\\n\\n\\nclass Formula:\\n    \\\"\\\"\\\"\\n    A formula represented in Conjunctive Normal Form.\\n    A formula is a set of clauses.\\n    For example,\\n        {{A1, A2, A3'}, {A5', A2', A1}} is ((A1 v A2 v A3') and (A5' v A2' v A1))\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, clauses: Iterable[Clause]) -> None:\\n        \\\"\\\"\\\"\\n        Represent the number of clauses and the clauses themselves.\\n        \\\"\\\"\\\"\\n        self.clauses = list(clauses)\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"\\n        To print a formula as in Conjunctive Normal Form.\\n        str(Formula([Clause([\\\"A1\\\", \\\"A2'\\\", \\\"A3\\\"]), Clause([\\\"A5'\\\", \\\"A2'\\\", \\\"A1\\\"])]))\\n        \\\"{{A1 , A2' , A3} , {A5' , A2' , A1}}\\\"\\n        \\\"\\\"\\\"\\n        return \\\"{\\\" + \\\" , \\\".join(str(clause) for clause in self.clauses) + \\\"}\\\"\\n\\n\\ndef generate_clause() -> Clause:\\n    \\\"\\\"\\\"\\n    Randomly generate a clause.\\n    All literals have the name Ax, where x is an integer from 1 to 5.\\n    \\\"\\\"\\\"\\n    literals = []\\n    no_of_literals = random.randint(1, 5)\\n    base_var = \\\"A\\\"\\n    i = 0\\n    while i < no_of_literals:\\n        var_no = random.randint(1, 5)\\n        var_name = base_var + str(var_no)\\n        var_complement = random.randint(0, 1)\\n        if var_complement == 1:\\n            var_name += \\\"'\\\"\\n        if var_name in literals:\\n            i -= 1\\n        else:\\n            literals.append(var_name)\\n        i += 1\\n    return Clause(literals)\\n\\n\\ndef generate_formula() -> Formula:\\n    \\\"\\\"\\\"\\n    Randomly generate a formula.\\n    \\\"\\\"\\\"\\n    clauses: set[Clause] = set()\\n    no_of_clauses = random.randint(1, 10)\\n    while len(clauses) < no_of_clauses:\\n        clauses.add(generate_clause())\\n    return Formula(clauses)\\n\\n\\ndef generate_parameters(formula: Formula) -> tuple[list[Clause], list[str]]:\\n    \\\"\\\"\\\"\\n    Return the clauses and symbols from a formula.\\n    A symbol is the uncomplemented form of a literal.\\n    For example,\\n        Symbol of A3 is A3.\\n        Symbol of A5' is A5.\\n\\n    >>> formula = Formula([Clause([\\\"A1\\\", \\\"A2'\\\", \\\"A3\\\"]), Clause([\\\"A5'\\\", \\\"A2'\\\", \\\"A1\\\"])])\\n    >>> clauses, symbols = generate_parameters(formula)\\n    >>> clauses_list = [str(i) for i in clauses]\\n    >>> clauses_list\\n    [\\\"{A1 , A2' , A3}\\\", \\\"{A5' , A2' , A1}\\\"]\\n    >>> symbols\\n    ['A1', 'A2', 'A3', 'A5']\\n    \\\"\\\"\\\"\\n    clauses = formula.clauses\\n    symbols_set = []\\n    for clause in formula.clauses:\\n        for literal in clause.literals:\\n            symbol = literal[:2]\\n            if symbol not in symbols_set:\\n                symbols_set.append(symbol)\\n    return clauses, symbols_set\\n\\n\\ndef find_pure_symbols(\\n    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]\\n) -> tuple[list[str], dict[str, bool | None]]:\\n    \\\"\\\"\\\"\\n    Return pure symbols and their values to satisfy clause.\\n    Pure symbols are symbols in a formula that exist only\\n    in one form, either complemented or otherwise.\\n    For example,\\n        { { A4 , A3 , A5' , A1 , A3' } , { A4 } , { A3 } } has\\n        pure symbols A4, A5' and A1.\\n    This has the following steps:\\n    1. Ignore clauses that have already evaluated to be True.\\n    2. Find symbols that occur only in one form in the rest of the clauses.\\n    3. Assign value True or False depending on whether the symbols occurs\\n    in normal or complemented form respectively.\\n\\n    >>> formula = Formula([Clause([\\\"A1\\\", \\\"A2'\\\", \\\"A3\\\"]), Clause([\\\"A5'\\\", \\\"A2'\\\", \\\"A1\\\"])])\\n    >>> clauses, symbols = generate_parameters(formula)\\n\\n    >>> pure_symbols, values = find_pure_symbols(clauses, symbols, {})\\n    >>> pure_symbols\\n    ['A1', 'A2', 'A3', 'A5']\\n    >>> values\\n    {'A1': True, 'A2': False, 'A3': True, 'A5': False}\\n    \\\"\\\"\\\"\\n    pure_symbols = []\\n    assignment: dict[str, bool | None] = dict()\\n    literals = []\\n\\n    for clause in clauses:\\n        if clause.evaluate(model):\\n            continue\\n        for literal in clause.literals:\\n            literals.append(literal)\\n\\n    for s in symbols:\\n        sym = s + \\\"'\\\"\\n        if (s in literals and sym not in literals) or (\\n            s not in literals and sym in literals\\n        ):\\n            pure_symbols.append(s)\\n    for p in pure_symbols:\\n        assignment[p] = None\\n    for s in pure_symbols:\\n        sym = s + \\\"'\\\"\\n        if s in literals:\\n            assignment[s] = True\\n        elif sym in literals:\\n            assignment[s] = False\\n    return pure_symbols, assignment\\n\\n\\ndef find_unit_clauses(\\n    clauses: list[Clause], model: dict[str, bool | None]\\n) -> tuple[list[str], dict[str, bool | None]]:\\n    \\\"\\\"\\\"\\n    Returns the unit symbols and their values to satisfy clause.\\n    Unit symbols are symbols in a formula that are:\\n    - Either the only symbol in a clause\\n    - Or all other literals in that clause have been assigned False\\n    This has the following steps:\\n    1. Find symbols that are the only occurrences in a clause.\\n    2. Find symbols in a clause where all other literals are assigned False.\\n    3. Assign True or False depending on whether the symbols occurs in\\n    normal or complemented form respectively.\\n\\n    >>> clause1 = Clause([\\\"A4\\\", \\\"A3\\\", \\\"A5'\\\", \\\"A1\\\", \\\"A3'\\\"])\\n    >>> clause2 = Clause([\\\"A4\\\"])\\n    >>> clause3 = Clause([\\\"A3\\\"])\\n    >>> clauses, symbols = generate_parameters(Formula([clause1, clause2, clause3]))\\n\\n    >>> unit_clauses, values = find_unit_clauses(clauses, {})\\n    >>> unit_clauses\\n    ['A4', 'A3']\\n    >>> values\\n    {'A4': True, 'A3': True}\\n    \\\"\\\"\\\"\\n    unit_symbols = []\\n    for clause in clauses:\\n        if len(clause) == 1:\\n            unit_symbols.append(list(clause.literals.keys())[0])\\n        else:\\n            Fcount, Ncount = 0, 0\\n            for literal, value in clause.literals.items():\\n                if value is False:\\n                    Fcount += 1\\n                elif value is None:\\n                    sym = literal\\n                    Ncount += 1\\n            if Fcount == len(clause) - 1 and Ncount == 1:\\n                unit_symbols.append(sym)\\n    assignment: dict[str, bool | None] = dict()\\n    for i in unit_symbols:\\n        symbol = i[:2]\\n        assignment[symbol] = len(i) == 2\\n    unit_symbols = [i[:2] for i in unit_symbols]\\n\\n    return unit_symbols, assignment\\n\\n\\ndef dpll_algorithm(\\n    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]\\n) -> tuple[bool | None, dict[str, bool | None] | None]:\\n    \\\"\\\"\\\"\\n    Returns the model if the formula is satisfiable, else None\\n    This has the following steps:\\n    1. If every clause in clauses is True, return True.\\n    2. If some clause in clauses is False, return False.\\n    3. Find pure symbols.\\n    4. Find unit symbols.\\n\\n    >>> formula = Formula([Clause([\\\"A4\\\", \\\"A3\\\", \\\"A5'\\\", \\\"A1\\\", \\\"A3'\\\"]), Clause([\\\"A4\\\"])])\\n    >>> clauses, symbols = generate_parameters(formula)\\n\\n    >>> soln, model = dpll_algorithm(clauses, symbols, {})\\n    >>> soln\\n    True\\n    >>> model\\n    {'A4': True}\\n    \\\"\\\"\\\"\\n    check_clause_all_true = True\\n    for clause in clauses:\\n        clause_check = clause.evaluate(model)\\n        if clause_check is False:\\n            return False, None\\n        elif clause_check is None:\\n            check_clause_all_true = False\\n            continue\\n\\n    if check_clause_all_true:\\n        return True, model\\n\\n    try:\\n        pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)\\n    except RecursionError:\\n        print(\\\"raises a RecursionError and is\\\")\\n        return None, {}\\n    P = None\\n    if len(pure_symbols) > 0:\\n        P, value = pure_symbols[0], assignment[pure_symbols[0]]\\n\\n    if P:\\n        tmp_model = model\\n        tmp_model[P] = value\\n        tmp_symbols = [i for i in symbols]\\n        if P in tmp_symbols:\\n            tmp_symbols.remove(P)\\n        return dpll_algorithm(clauses, tmp_symbols, tmp_model)\\n\\n    unit_symbols, assignment = find_unit_clauses(clauses, model)\\n    P = None\\n    if len(unit_symbols) > 0:\\n        P, value = unit_symbols[0], assignment[unit_symbols[0]]\\n    if P:\\n        tmp_model = model\\n        tmp_model[P] = value\\n        tmp_symbols = [i for i in symbols]\\n        if P in tmp_symbols:\\n            tmp_symbols.remove(P)\\n        return dpll_algorithm(clauses, tmp_symbols, tmp_model)\\n    P = symbols[0]\\n    rest = symbols[1:]\\n    tmp1, tmp2 = model, model\\n    tmp1[P], tmp2[P] = True, False\\n\\n    return dpll_algorithm(clauses, rest, tmp1) or dpll_algorithm(clauses, rest, tmp2)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    formula = generate_formula()\\n    print(f\\\"The formula {formula} is\\\", end=\\\" \\\")\\n\\n    clauses, symbols = generate_parameters(formula)\\n    solution, model = dpll_algorithm(clauses, symbols, {})\\n\\n    if solution:\\n        print(f\\\"satisfiable with the assignment {model}.\\\")\\n    else:\\n        print(\\\"not satisfiable.\\\")\\n\"",
    "dijkstra bankers algorithm": "\"# A Python implementation of the Banker's Algorithm in Operating Systems using\\n# Processes and Resources\\n# {\\n# \\\"Author: \\\"Biney Kingsley (bluedistro@github.io), bineykingsley36@gmail.com\\\",\\n# \\\"Date\\\": 28-10-2018\\n# }\\n\\\"\\\"\\\"\\nThe Banker's algorithm is a resource allocation and deadlock avoidance algorithm\\ndeveloped by Edsger Dijkstra that tests for safety by simulating the allocation of\\npredetermined maximum possible amounts of all resources, and then makes a \\\"s-state\\\"\\ncheck to test for possible deadlock conditions for all other pending activities,\\nbefore deciding whether allocation should be allowed to continue.\\n[Source] Wikipedia\\n[Credit] Rosetta Code C implementation helped very much.\\n (https://rosettacode.org/wiki/Banker%27s_algorithm)\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\nimport time\\n\\nimport numpy as np\\n\\ntest_claim_vector = [8, 5, 9, 7]\\ntest_allocated_res_table = [\\n    [2, 0, 1, 1],\\n    [0, 1, 2, 1],\\n    [4, 0, 0, 3],\\n    [0, 2, 1, 0],\\n    [1, 0, 3, 0],\\n]\\ntest_maximum_claim_table = [\\n    [3, 2, 1, 4],\\n    [0, 2, 5, 2],\\n    [5, 1, 0, 5],\\n    [1, 5, 3, 0],\\n    [3, 0, 3, 3],\\n]\\n\\n\\nclass BankersAlgorithm:\\n    def __init__(\\n        self,\\n        claim_vector: list[int],\\n        allocated_resources_table: list[list[int]],\\n        maximum_claim_table: list[list[int]],\\n    ) -> None:\\n        \\\"\\\"\\\"\\n        :param claim_vector: A nxn/nxm list depicting the amount of each resources\\n         (eg. memory, interface, semaphores, etc.) available.\\n        :param allocated_resources_table: A nxn/nxm list depicting the amount of each\\n         resource each process is currently holding\\n        :param maximum_claim_table: A nxn/nxm list depicting how much of each resource\\n         the system currently has available\\n        \\\"\\\"\\\"\\n        self.__claim_vector = claim_vector\\n        self.__allocated_resources_table = allocated_resources_table\\n        self.__maximum_claim_table = maximum_claim_table\\n\\n    def __processes_resource_summation(self) -> list[int]:\\n        \\\"\\\"\\\"\\n        Check for allocated resources in line with each resource in the claim vector\\n        \\\"\\\"\\\"\\n        return [\\n            sum(p_item[i] for p_item in self.__allocated_resources_table)\\n            for i in range(len(self.__allocated_resources_table[0]))\\n        ]\\n\\n    def __available_resources(self) -> list[int]:\\n        \\\"\\\"\\\"\\n        Check for available resources in line with each resource in the claim vector\\n        \\\"\\\"\\\"\\n        return np.array(self.__claim_vector) - np.array(\\n            self.__processes_resource_summation()\\n        )\\n\\n    def __need(self) -> list[list[int]]:\\n        \\\"\\\"\\\"\\n        Implement safety checker that calculates the needs by ensuring that\\n        max_claim[i][j] - alloc_table[i][j] <= avail[j]\\n        \\\"\\\"\\\"\\n        return [\\n            list(np.array(self.__maximum_claim_table[i]) - np.array(allocated_resource))\\n            for i, allocated_resource in enumerate(self.__allocated_resources_table)\\n        ]\\n\\n    def __need_index_manager(self) -> dict[int, list[int]]:\\n        \\\"\\\"\\\"\\n        This function builds an index control dictionary to track original ids/indices\\n        of processes when altered during execution of method \\\"main\\\"\\n            Return: {0: [a: int, b: int], 1: [c: int, d: int]}\\n        >>> (BankersAlgorithm(test_claim_vector, test_allocated_res_table,\\n        ...     test_maximum_claim_table)._BankersAlgorithm__need_index_manager()\\n        ...     )  # doctest: +NORMALIZE_WHITESPACE\\n        {0: [1, 2, 0, 3], 1: [0, 1, 3, 1], 2: [1, 1, 0, 2], 3: [1, 3, 2, 0],\\n         4: [2, 0, 0, 3]}\\n        \\\"\\\"\\\"\\n        return {self.__need().index(i): i for i in self.__need()}\\n\\n    def main(self, **kwargs) -> None:\\n        \\\"\\\"\\\"\\n        Utilize various methods in this class to simulate the Banker's algorithm\\n        Return: None\\n        >>> BankersAlgorithm(test_claim_vector, test_allocated_res_table,\\n        ...    test_maximum_claim_table).main(describe=True)\\n                 Allocated Resource Table\\n        P1       2        0        1        1\\n        <BLANKLINE>\\n        P2       0        1        2        1\\n        <BLANKLINE>\\n        P3       4        0        0        3\\n        <BLANKLINE>\\n        P4       0        2        1        0\\n        <BLANKLINE>\\n        P5       1        0        3        0\\n        <BLANKLINE>\\n                 System Resource Table\\n        P1       3        2        1        4\\n        <BLANKLINE>\\n        P2       0        2        5        2\\n        <BLANKLINE>\\n        P3       5        1        0        5\\n        <BLANKLINE>\\n        P4       1        5        3        0\\n        <BLANKLINE>\\n        P5       3        0        3        3\\n        <BLANKLINE>\\n        Current Usage by Active Processes: 8 5 9 7\\n        Initial Available Resources:       1 2 2 2\\n        __________________________________________________\\n        <BLANKLINE>\\n        Process 3 is executing.\\n        Updated available resource stack for processes: 5 2 2 5\\n        The process is in a safe state.\\n        <BLANKLINE>\\n        Process 1 is executing.\\n        Updated available resource stack for processes: 7 2 3 6\\n        The process is in a safe state.\\n        <BLANKLINE>\\n        Process 2 is executing.\\n        Updated available resource stack for processes: 7 3 5 7\\n        The process is in a safe state.\\n        <BLANKLINE>\\n        Process 4 is executing.\\n        Updated available resource stack for processes: 7 5 6 7\\n        The process is in a safe state.\\n        <BLANKLINE>\\n        Process 5 is executing.\\n        Updated available resource stack for processes: 8 5 9 7\\n        The process is in a safe state.\\n        <BLANKLINE>\\n        \\\"\\\"\\\"\\n        need_list = self.__need()\\n        alloc_resources_table = self.__allocated_resources_table\\n        available_resources = self.__available_resources()\\n        need_index_manager = self.__need_index_manager()\\n        for kw, val in kwargs.items():\\n            if kw and val is True:\\n                self.__pretty_data()\\n        print(\\\"_\\\" * 50 + \\\"\\\\n\\\")\\n        while need_list:\\n            safe = False\\n            for each_need in need_list:\\n                execution = True\\n                for index, need in enumerate(each_need):\\n                    if need > available_resources[index]:\\n                        execution = False\\n                        break\\n                if execution:\\n                    safe = True\\n                    # get the original index of the process from ind_ctrl db\\n                    for original_need_index, need_clone in need_index_manager.items():\\n                        if each_need == need_clone:\\n                            process_number = original_need_index\\n                    print(f\\\"Process {process_number + 1} is executing.\\\")\\n                    # remove the process run from stack\\n                    need_list.remove(each_need)\\n                    # update available/freed resources stack\\n                    available_resources = np.array(available_resources) + np.array(\\n                        alloc_resources_table[process_number]\\n                    )\\n                    print(\\n                        \\\"Updated available resource stack for processes: \\\"\\n                        + \\\" \\\".join([str(x) for x in available_resources])\\n                    )\\n                    break\\n            if safe:\\n                print(\\\"The process is in a safe state.\\\\n\\\")\\n            else:\\n                print(\\\"System in unsafe state. Aborting...\\\\n\\\")\\n                break\\n\\n    def __pretty_data(self):\\n        \\\"\\\"\\\"\\n        Properly align display of the algorithm's solution\\n        \\\"\\\"\\\"\\n        print(\\\" \\\" * 9 + \\\"Allocated Resource Table\\\")\\n        for item in self.__allocated_resources_table:\\n            print(\\n                f\\\"P{self.__allocated_resources_table.index(item) + 1}\\\"\\n                + \\\" \\\".join(f\\\"{it:>8}\\\" for it in item)\\n                + \\\"\\\\n\\\"\\n            )\\n        print(\\\" \\\" * 9 + \\\"System Resource Table\\\")\\n        for item in self.__maximum_claim_table:\\n            print(\\n                f\\\"P{self.__maximum_claim_table.index(item) + 1}\\\"\\n                + \\\" \\\".join(f\\\"{it:>8}\\\" for it in item)\\n                + \\\"\\\\n\\\"\\n            )\\n        print(\\n            \\\"Current Usage by Active Processes: \\\"\\n            + \\\" \\\".join(str(x) for x in self.__claim_vector)\\n        )\\n        print(\\n            \\\"Initial Available Resources:       \\\"\\n            + \\\" \\\".join(str(x) for x in self.__available_resources())\\n        )\\n        time.sleep(1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "doomsday": "\"#!/bin/python3\\n# Doomsday algorithm info: https://en.wikipedia.org/wiki/Doomsday_rule\\n\\nDOOMSDAY_LEAP = [4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\\nDOOMSDAY_NOT_LEAP = [3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\\nWEEK_DAY_NAMES = {\\n    0: \\\"Sunday\\\",\\n    1: \\\"Monday\\\",\\n    2: \\\"Tuesday\\\",\\n    3: \\\"Wednesday\\\",\\n    4: \\\"Thursday\\\",\\n    5: \\\"Friday\\\",\\n    6: \\\"Saturday\\\",\\n}\\n\\n\\ndef get_week_day(year: int, month: int, day: int) -> str:\\n    \\\"\\\"\\\"Returns the week-day name out of a given date.\\n\\n    >>> get_week_day(2020, 10, 24)\\n    'Saturday'\\n    >>> get_week_day(2017, 10, 24)\\n    'Tuesday'\\n    >>> get_week_day(2019, 5, 3)\\n    'Friday'\\n    >>> get_week_day(1970, 9, 16)\\n    'Wednesday'\\n    >>> get_week_day(1870, 8, 13)\\n    'Saturday'\\n    >>> get_week_day(2040, 3, 14)\\n    'Wednesday'\\n\\n    \\\"\\\"\\\"\\n    # minimal input check:\\n    assert len(str(year)) > 2, \\\"year should be in YYYY format\\\"\\n    assert 1 <= month <= 12, \\\"month should be between 1 to 12\\\"\\n    assert 1 <= day <= 31, \\\"day should be between 1 to 31\\\"\\n\\n    # Doomsday algorithm:\\n    century = year // 100\\n    century_anchor = (5 * (century % 4) + 2) % 7\\n    centurian = year % 100\\n    centurian_m = centurian % 12\\n    dooms_day = (\\n        (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor\\n    ) % 7\\n    day_anchor = (\\n        DOOMSDAY_NOT_LEAP[month - 1]\\n        if (year % 4 != 0) or (centurian == 0 and (year % 400) == 0)\\n        else DOOMSDAY_LEAP[month - 1]\\n    )\\n    week_day = (dooms_day + day - day_anchor) % 7\\n    return WEEK_DAY_NAMES[week_day]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "fischer yates shuffle": "\"#!/usr/bin/python\\n\\\"\\\"\\\"\\nThe Fisher–Yates shuffle is an algorithm for generating a random permutation of a\\nfinite sequence.\\nFor more details visit\\nwikipedia/Fischer-Yates-Shuffle.\\n\\\"\\\"\\\"\\nimport random\\nfrom typing import Any\\n\\n\\ndef fisher_yates_shuffle(data: list) -> list[Any]:\\n    for _ in range(len(data)):\\n        a = random.randint(0, len(data) - 1)\\n        b = random.randint(0, len(data) - 1)\\n        data[a], data[b] = data[b], data[a]\\n    return data\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    integers = [0, 1, 2, 3, 4, 5, 6, 7]\\n    strings = [\\\"python\\\", \\\"says\\\", \\\"hello\\\", \\\"!\\\"]\\n    print(\\\"Fisher-Yates Shuffle:\\\")\\n    print(\\\"List\\\", integers, strings)\\n    print(\\\"FY Shuffle\\\", fisher_yates_shuffle(integers), fisher_yates_shuffle(strings))\\n\"",
    "gauss easter": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Computus#Gauss'_Easter_algorithm\\n\\\"\\\"\\\"\\nimport math\\nfrom datetime import datetime, timedelta\\n\\n\\ndef gauss_easter(year: int) -> datetime:\\n    \\\"\\\"\\\"\\n    Calculation Gregorian easter date for given year\\n\\n    >>> gauss_easter(2007)\\n    datetime.datetime(2007, 4, 8, 0, 0)\\n\\n    >>> gauss_easter(2008)\\n    datetime.datetime(2008, 3, 23, 0, 0)\\n\\n    >>> gauss_easter(2020)\\n    datetime.datetime(2020, 4, 12, 0, 0)\\n\\n    >>> gauss_easter(2021)\\n    datetime.datetime(2021, 4, 4, 0, 0)\\n    \\\"\\\"\\\"\\n    metonic_cycle = year % 19\\n    julian_leap_year = year % 4\\n    non_leap_year = year % 7\\n    leap_day_inhibits = math.floor(year / 100)\\n    lunar_orbit_correction = math.floor((13 + 8 * leap_day_inhibits) / 25)\\n    leap_day_reinstall_number = leap_day_inhibits / 4\\n    secular_moon_shift = (\\n        15 - lunar_orbit_correction + leap_day_inhibits - leap_day_reinstall_number\\n    ) % 30\\n    century_starting_point = (4 + leap_day_inhibits - leap_day_reinstall_number) % 7\\n\\n    # days to be added to March 21\\n    days_to_add = (19 * metonic_cycle + secular_moon_shift) % 30\\n\\n    # PHM -> Paschal Full Moon\\n    days_from_phm_to_sunday = (\\n        2 * julian_leap_year\\n        + 4 * non_leap_year\\n        + 6 * days_to_add\\n        + century_starting_point\\n    ) % 7\\n\\n    if days_to_add == 29 and days_from_phm_to_sunday == 6:\\n        return datetime(year, 4, 19)\\n    elif days_to_add == 28 and days_from_phm_to_sunday == 6:\\n        return datetime(year, 4, 18)\\n    else:\\n        return datetime(year, 3, 22) + timedelta(\\n            days=int(days_to_add + days_from_phm_to_sunday)\\n        )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    for year in (1994, 2000, 2010, 2021, 2023):\\n        tense = \\\"will be\\\" if year > datetime.now().year else \\\"was\\\"\\n        print(f\\\"Easter in {year} {tense} {gauss_easter(year)}\\\")\\n\"",
    "graham scan": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the merge-insertion sort algorithm\\nSource: https://en.wikipedia.org/wiki/Graham_scan\\n\\nFor doctests run following command:\\npython3 -m doctest -v graham_scan.py\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\nfrom collections import deque\\nfrom enum import Enum\\nfrom math import atan2, degrees\\nfrom sys import maxsize\\n\\n\\ndef graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:\\n    \\\"\\\"\\\"Pure implementation of graham scan algorithm in Python\\n\\n    :param points: The unique points on coordinates.\\n    :return: The points on convex hell.\\n\\n    Examples:\\n    >>> graham_scan([(9, 6), (3, 1), (0, 0), (5, 5), (5, 2), (7, 0), (3, 3), (1, 4)])\\n    [(0, 0), (7, 0), (9, 6), (5, 5), (1, 4)]\\n\\n    >>> graham_scan([(0, 0), (1, 0), (1, 1), (0, 1)])\\n    [(0, 0), (1, 0), (1, 1), (0, 1)]\\n\\n    >>> graham_scan([(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)])\\n    [(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]\\n\\n    >>> graham_scan([(-100, 20), (99, 3), (1, 10000001), (5133186, -25), (-66, -4)])\\n    [(5133186, -25), (1, 10000001), (-100, 20), (-66, -4)]\\n    \\\"\\\"\\\"\\n\\n    if len(points) <= 2:\\n        # There is no convex hull\\n        raise ValueError(\\\"graham_scan: argument must contain more than 3 points.\\\")\\n    if len(points) == 3:\\n        return points\\n    # find the lowest and the most left point\\n    minidx = 0\\n    miny, minx = maxsize, maxsize\\n    for i, point in enumerate(points):\\n        x = point[0]\\n        y = point[1]\\n        if y < miny:\\n            miny = y\\n            minx = x\\n            minidx = i\\n        if y == miny:\\n            if x < minx:\\n                minx = x\\n                minidx = i\\n\\n    # remove the lowest and the most left point from points for preparing for sort\\n    points.pop(minidx)\\n\\n    def angle_comparer(point: tuple[int, int], minx: int, miny: int) -> float:\\n        \\\"\\\"\\\"Return the angle toward to point from (minx, miny)\\n\\n        :param point: The target point\\n               minx: The starting point's x\\n               miny: The starting point's y\\n        :return: the angle\\n\\n        Examples:\\n        >>> angle_comparer((1,1), 0, 0)\\n        45.0\\n\\n        >>> angle_comparer((100,1), 10, 10)\\n        -5.710593137499642\\n\\n        >>> angle_comparer((5,5), 2, 3)\\n        33.690067525979785\\n        \\\"\\\"\\\"\\n        # sort the points accorgind to the angle from the lowest and the most left point\\n        x = point[0]\\n        y = point[1]\\n        angle = degrees(atan2(y - miny, x - minx))\\n        return angle\\n\\n    sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))\\n    # This insert actually costs complexity,\\n    # and you should instead add (minx, miny) into stack later.\\n    # I'm using insert just for easy understanding.\\n    sorted_points.insert(0, (minx, miny))\\n\\n    # traversal from the lowest and the most left point in anti-clockwise direction\\n    # if direction gets right, the previous point is not the convex hull.\\n    class Direction(Enum):\\n        left = 1\\n        straight = 2\\n        right = 3\\n\\n    def check_direction(\\n        starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int]\\n    ) -> Direction:\\n        \\\"\\\"\\\"Return the direction toward to the line from via to target from starting\\n\\n        :param starting: The starting point\\n               via: The via point\\n               target: The target point\\n        :return: the Direction\\n\\n        Examples:\\n        >>> check_direction((1,1), (2,2), (3,3))\\n        Direction.straight\\n\\n        >>> check_direction((60,1), (-50,199), (30,2))\\n        Direction.left\\n\\n        >>> check_direction((0,0), (5,5), (10,0))\\n        Direction.right\\n        \\\"\\\"\\\"\\n        x0, y0 = starting\\n        x1, y1 = via\\n        x2, y2 = target\\n        via_angle = degrees(atan2(y1 - y0, x1 - x0))\\n        if via_angle < 0:\\n            via_angle += 360\\n        target_angle = degrees(atan2(y2 - y0, x2 - x0))\\n        if target_angle < 0:\\n            target_angle += 360\\n        # t-\\n        #  \\\\ \\\\\\n        #   \\\\ v\\n        #    \\\\|\\n        #     s\\n        # via_angle is always lower than target_angle, if direction is left.\\n        # If they are same, it means they are on a same line of convex hull.\\n        if target_angle > via_angle:\\n            return Direction.left\\n        elif target_angle == via_angle:\\n            return Direction.straight\\n        else:\\n            return Direction.right\\n\\n    stack: deque[tuple[int, int]] = deque()\\n    stack.append(sorted_points[0])\\n    stack.append(sorted_points[1])\\n    stack.append(sorted_points[2])\\n    # In any ways, the first 3 points line are towards left.\\n    # Because we sort them the angle from minx, miny.\\n    current_direction = Direction.left\\n\\n    for i in range(3, len(sorted_points)):\\n        while True:\\n            starting = stack[-2]\\n            via = stack[-1]\\n            target = sorted_points[i]\\n            next_direction = check_direction(starting, via, target)\\n\\n            if next_direction == Direction.left:\\n                current_direction = Direction.left\\n                break\\n            if next_direction == Direction.straight:\\n                if current_direction == Direction.left:\\n                    # We keep current_direction as left.\\n                    # Because if the straight line keeps as straight,\\n                    # we want to know if this straight line is towards left.\\n                    break\\n                elif current_direction == Direction.right:\\n                    # If the straight line is towards right,\\n                    # every previous points on those straigh line is not convex hull.\\n                    stack.pop()\\n            if next_direction == Direction.right:\\n                stack.pop()\\n        stack.append(sorted_points[i])\\n    return list(stack)\\n\"",
    "greedy": "\"class things:\\n    def __init__(self, name, value, weight):\\n        self.name = name\\n        self.value = value\\n        self.weight = weight\\n\\n    def __repr__(self):\\n        return f\\\"{self.__class__.__name__}({self.name}, {self.value}, {self.weight})\\\"\\n\\n    def get_value(self):\\n        return self.value\\n\\n    def get_name(self):\\n        return self.name\\n\\n    def get_weight(self):\\n        return self.weight\\n\\n    def value_Weight(self):\\n        return self.value / self.weight\\n\\n\\ndef build_menu(name, value, weight):\\n    menu = []\\n    for i in range(len(value)):\\n        menu.append(things(name[i], value[i], weight[i]))\\n    return menu\\n\\n\\ndef greedy(item, maxCost, keyFunc):\\n    itemsCopy = sorted(item, key=keyFunc, reverse=True)\\n    result = []\\n    totalValue, total_cost = 0.0, 0.0\\n    for i in range(len(itemsCopy)):\\n        if (total_cost + itemsCopy[i].get_weight()) <= maxCost:\\n            result.append(itemsCopy[i])\\n            total_cost += itemsCopy[i].get_weight()\\n            totalValue += itemsCopy[i].get_value()\\n    return (result, totalValue)\\n\\n\\ndef test_greedy():\\n    \\\"\\\"\\\"\\n    >>> food = [\\\"Burger\\\", \\\"Pizza\\\", \\\"Coca Cola\\\", \\\"Rice\\\",\\n    ...         \\\"Sambhar\\\", \\\"Chicken\\\", \\\"Fries\\\", \\\"Milk\\\"]\\n    >>> value = [80, 100, 60, 70, 50, 110, 90, 60]\\n    >>> weight = [40, 60, 40, 70, 100, 85, 55, 70]\\n    >>> foods = build_menu(food, value, weight)\\n    >>> foods  # doctest: +NORMALIZE_WHITESPACE\\n    [things(Burger, 80, 40), things(Pizza, 100, 60), things(Coca Cola, 60, 40),\\n     things(Rice, 70, 70), things(Sambhar, 50, 100), things(Chicken, 110, 85),\\n     things(Fries, 90, 55), things(Milk, 60, 70)]\\n    >>> greedy(foods, 500, things.get_value)  # doctest: +NORMALIZE_WHITESPACE\\n    ([things(Chicken, 110, 85), things(Pizza, 100, 60), things(Fries, 90, 55),\\n      things(Burger, 80, 40), things(Rice, 70, 70), things(Coca Cola, 60, 40),\\n      things(Milk, 60, 70)], 570.0)\\n    \\\"\\\"\\\"\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "least recently used": "\"from __future__ import annotations\\n\\nimport sys\\nfrom collections import deque\\nfrom typing import Generic, TypeVar\\n\\nT = TypeVar(\\\"T\\\")\\n\\n\\nclass LRUCache(Generic[T]):\\n    \\\"\\\"\\\"\\n    Page Replacement Algorithm, Least Recently Used (LRU) Caching.\\n\\n    >>> lru_cache: LRUCache[str | int] = LRUCache(4)\\n    >>> lru_cache.refer(\\\"A\\\")\\n    >>> lru_cache.refer(2)\\n    >>> lru_cache.refer(3)\\n\\n    >>> lru_cache\\n    LRUCache(4) => [3, 2, 'A']\\n\\n    >>> lru_cache.refer(\\\"A\\\")\\n    >>> lru_cache\\n    LRUCache(4) => ['A', 3, 2]\\n\\n    >>> lru_cache.refer(4)\\n    >>> lru_cache.refer(5)\\n    >>> lru_cache\\n    LRUCache(4) => [5, 4, 'A', 3]\\n\\n    \\\"\\\"\\\"\\n\\n    dq_store: deque[T]  # Cache store of keys\\n    key_reference: set[T]  # References of the keys in cache\\n    _MAX_CAPACITY: int = 10  # Maximum capacity of cache\\n\\n    def __init__(self, n: int) -> None:\\n        \\\"\\\"\\\"Creates an empty store and map for the keys.\\n        The LRUCache is set the size n.\\n        \\\"\\\"\\\"\\n        self.dq_store = deque()\\n        self.key_reference = set()\\n        if not n:\\n            LRUCache._MAX_CAPACITY = sys.maxsize\\n        elif n < 0:\\n            raise ValueError(\\\"n should be an integer greater than 0.\\\")\\n        else:\\n            LRUCache._MAX_CAPACITY = n\\n\\n    def refer(self, x: T) -> None:\\n        \\\"\\\"\\\"\\n        Looks for a page in the cache store and adds reference to the set.\\n        Remove the least recently used key if the store is full.\\n        Update store to reflect recent access.\\n        \\\"\\\"\\\"\\n        if x not in self.key_reference:\\n            if len(self.dq_store) == LRUCache._MAX_CAPACITY:\\n                last_element = self.dq_store.pop()\\n                self.key_reference.remove(last_element)\\n        else:\\n            self.dq_store.remove(x)\\n\\n        self.dq_store.appendleft(x)\\n        self.key_reference.add(x)\\n\\n    def display(self) -> None:\\n        \\\"\\\"\\\"\\n        Prints all the elements in the store.\\n        \\\"\\\"\\\"\\n        for k in self.dq_store:\\n            print(k)\\n\\n    def __repr__(self) -> str:\\n        return f\\\"LRUCache({self._MAX_CAPACITY}) => {list(self.dq_store)}\\\"\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    lru_cache: LRUCache[str | int] = LRUCache(4)\\n    lru_cache.refer(\\\"A\\\")\\n    lru_cache.refer(2)\\n    lru_cache.refer(3)\\n    lru_cache.refer(\\\"A\\\")\\n    lru_cache.refer(4)\\n    lru_cache.refer(5)\\n    lru_cache.display()\\n\\n    print(lru_cache)\\n    assert str(lru_cache) == \\\"LRUCache(4) => [5, 4, 'A', 3]\\\"\\n\"",
    "lfu cache": "\"from __future__ import annotations\\n\\nfrom typing import Callable, Generic, TypeVar\\n\\nT = TypeVar(\\\"T\\\")\\nU = TypeVar(\\\"U\\\")\\n\\n\\nclass DoubleLinkedListNode(Generic[T, U]):\\n    \\\"\\\"\\\"\\n    Double Linked List Node built specifically for LFU Cache\\n\\n    >>> node = DoubleLinkedListNode(1,1)\\n    >>> node\\n    Node: key: 1, val: 1, freq: 0, has next: False, has prev: False\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, key: T | None, val: U | None):\\n        self.key = key\\n        self.val = val\\n        self.freq: int = 0\\n        self.next: DoubleLinkedListNode[T, U] | None = None\\n        self.prev: DoubleLinkedListNode[T, U] | None = None\\n\\n    def __repr__(self) -> str:\\n        return \\\"Node: key: {}, val: {}, freq: {}, has next: {}, has prev: {}\\\".format(\\n            self.key, self.val, self.freq, self.next is not None, self.prev is not None\\n        )\\n\\n\\nclass DoubleLinkedList(Generic[T, U]):\\n    \\\"\\\"\\\"\\n    Double Linked List built specifically for LFU Cache\\n\\n    >>> dll: DoubleLinkedList = DoubleLinkedList()\\n    >>> dll\\n    DoubleLinkedList,\\n        Node: key: None, val: None, freq: 0, has next: True, has prev: False,\\n        Node: key: None, val: None, freq: 0, has next: False, has prev: True\\n\\n    >>> first_node = DoubleLinkedListNode(1,10)\\n    >>> first_node\\n    Node: key: 1, val: 10, freq: 0, has next: False, has prev: False\\n\\n\\n    >>> dll.add(first_node)\\n    >>> dll\\n    DoubleLinkedList,\\n        Node: key: None, val: None, freq: 0, has next: True, has prev: False,\\n        Node: key: 1, val: 10, freq: 1, has next: True, has prev: True,\\n        Node: key: None, val: None, freq: 0, has next: False, has prev: True\\n\\n    >>> # node is mutated\\n    >>> first_node\\n    Node: key: 1, val: 10, freq: 1, has next: True, has prev: True\\n\\n    >>> second_node = DoubleLinkedListNode(2,20)\\n    >>> second_node\\n    Node: key: 2, val: 20, freq: 0, has next: False, has prev: False\\n\\n    >>> dll.add(second_node)\\n    >>> dll\\n    DoubleLinkedList,\\n        Node: key: None, val: None, freq: 0, has next: True, has prev: False,\\n        Node: key: 1, val: 10, freq: 1, has next: True, has prev: True,\\n        Node: key: 2, val: 20, freq: 1, has next: True, has prev: True,\\n        Node: key: None, val: None, freq: 0, has next: False, has prev: True\\n\\n    >>> removed_node = dll.remove(first_node)\\n    >>> assert removed_node == first_node\\n    >>> dll\\n    DoubleLinkedList,\\n        Node: key: None, val: None, freq: 0, has next: True, has prev: False,\\n        Node: key: 2, val: 20, freq: 1, has next: True, has prev: True,\\n        Node: key: None, val: None, freq: 0, has next: False, has prev: True\\n\\n\\n    >>> # Attempt to remove node not on list\\n    >>> removed_node = dll.remove(first_node)\\n    >>> removed_node is None\\n    True\\n\\n    >>> # Attempt to remove head or rear\\n    >>> dll.head\\n    Node: key: None, val: None, freq: 0, has next: True, has prev: False\\n    >>> dll.remove(dll.head) is None\\n    True\\n\\n    >>> # Attempt to remove head or rear\\n    >>> dll.rear\\n    Node: key: None, val: None, freq: 0, has next: False, has prev: True\\n    >>> dll.remove(dll.rear) is None\\n    True\\n\\n\\n    \\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.head: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)\\n        self.rear: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)\\n        self.head.next, self.rear.prev = self.rear, self.head\\n\\n    def __repr__(self) -> str:\\n        rep = [\\\"DoubleLinkedList\\\"]\\n        node = self.head\\n        while node.next is not None:\\n            rep.append(str(node))\\n            node = node.next\\n        rep.append(str(self.rear))\\n        return \\\",\\\\n    \\\".join(rep)\\n\\n    def add(self, node: DoubleLinkedListNode[T, U]) -> None:\\n        \\\"\\\"\\\"\\n        Adds the given node at the tail of the list and shifting it to proper position\\n        \\\"\\\"\\\"\\n\\n        previous = self.rear.prev\\n\\n        # All nodes other than self.head are guaranteed to have non-None previous\\n        assert previous is not None\\n\\n        previous.next = node\\n        node.prev = previous\\n        self.rear.prev = node\\n        node.next = self.rear\\n        node.freq += 1\\n        self._position_node(node)\\n\\n    def _position_node(self, node: DoubleLinkedListNode[T, U]) -> None:\\n        \\\"\\\"\\\"\\n        Moves node forward to maintain invariant of sort by freq value\\n        \\\"\\\"\\\"\\n\\n        while node.prev is not None and node.prev.freq > node.freq:\\n            # swap node with previous node\\n            previous_node = node.prev\\n\\n            node.prev = previous_node.prev\\n            previous_node.next = node.prev\\n            node.next = previous_node\\n            previous_node.prev = node\\n\\n    def remove(\\n        self, node: DoubleLinkedListNode[T, U]\\n    ) -> DoubleLinkedListNode[T, U] | None:\\n        \\\"\\\"\\\"\\n        Removes and returns the given node from the list\\n\\n        Returns None if node.prev or node.next is None\\n        \\\"\\\"\\\"\\n\\n        if node.prev is None or node.next is None:\\n            return None\\n\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        node.prev = None\\n        node.next = None\\n        return node\\n\\n\\nclass LFUCache(Generic[T, U]):\\n    \\\"\\\"\\\"\\n    LFU Cache to store a given capacity of data. Can be used as a stand-alone object\\n    or as a function decorator.\\n\\n    >>> cache = LFUCache(2)\\n    >>> cache.set(1, 1)\\n    >>> cache.set(2, 2)\\n    >>> cache.get(1)\\n    1\\n    >>> cache.set(3, 3)\\n    >>> cache.get(2) is None\\n    True\\n    >>> cache.set(4, 4)\\n    >>> cache.get(1) is None\\n    True\\n    >>> cache.get(3)\\n    3\\n    >>> cache.get(4)\\n    4\\n    >>> cache\\n    CacheInfo(hits=3, misses=2, capacity=2, current_size=2)\\n    >>> @LFUCache.decorator(100)\\n    ... def fib(num):\\n    ...     if num in (1, 2):\\n    ...         return 1\\n    ...     return fib(num - 1) + fib(num - 2)\\n\\n    >>> for i in range(1, 101):\\n    ...     res = fib(i)\\n\\n    >>> fib.cache_info()\\n    CacheInfo(hits=196, misses=100, capacity=100, current_size=100)\\n    \\\"\\\"\\\"\\n\\n    # class variable to map the decorator functions to their respective instance\\n    decorator_function_to_instance_map: dict[Callable[[T], U], LFUCache[T, U]] = {}\\n\\n    def __init__(self, capacity: int):\\n        self.list: DoubleLinkedList[T, U] = DoubleLinkedList()\\n        self.capacity = capacity\\n        self.num_keys = 0\\n        self.hits = 0\\n        self.miss = 0\\n        self.cache: dict[T, DoubleLinkedListNode[T, U]] = {}\\n\\n    def __repr__(self) -> str:\\n        \\\"\\\"\\\"\\n        Return the details for the cache instance\\n        [hits, misses, capacity, current_size]\\n        \\\"\\\"\\\"\\n\\n        return (\\n            f\\\"CacheInfo(hits={self.hits}, misses={self.miss}, \\\"\\n            f\\\"capacity={self.capacity}, current_size={self.num_keys})\\\"\\n        )\\n\\n    def __contains__(self, key: T) -> bool:\\n        \\\"\\\"\\\"\\n        >>> cache = LFUCache(1)\\n\\n        >>> 1 in cache\\n        False\\n\\n        >>> cache.set(1, 1)\\n        >>> 1 in cache\\n        True\\n        \\\"\\\"\\\"\\n\\n        return key in self.cache\\n\\n    def get(self, key: T) -> U | None:\\n        \\\"\\\"\\\"\\n        Returns the value for the input key and updates the Double Linked List. Returns\\n        Returns None if key is not present in cache\\n        \\\"\\\"\\\"\\n\\n        if key in self.cache:\\n            self.hits += 1\\n            value_node: DoubleLinkedListNode[T, U] = self.cache[key]\\n            node = self.list.remove(self.cache[key])\\n            assert node == value_node\\n\\n            # node is guaranteed not None because it is in self.cache\\n            assert node is not None\\n            self.list.add(node)\\n            return node.val\\n        self.miss += 1\\n        return None\\n\\n    def set(self, key: T, value: U) -> None:\\n        \\\"\\\"\\\"\\n        Sets the value for the input key and updates the Double Linked List\\n        \\\"\\\"\\\"\\n\\n        if key not in self.cache:\\n            if self.num_keys >= self.capacity:\\n                # delete first node when over capacity\\n                first_node = self.list.head.next\\n\\n                # guaranteed to have a non-None first node when num_keys > 0\\n                # explain to type checker via assertions\\n                assert first_node is not None\\n                assert first_node.key is not None\\n                assert self.list.remove(first_node) is not None\\n                # first_node guaranteed to be in list\\n\\n                del self.cache[first_node.key]\\n                self.num_keys -= 1\\n            self.cache[key] = DoubleLinkedListNode(key, value)\\n            self.list.add(self.cache[key])\\n            self.num_keys += 1\\n\\n        else:\\n            node = self.list.remove(self.cache[key])\\n            assert node is not None  # node guaranteed to be in list\\n            node.val = value\\n            self.list.add(node)\\n\\n    @classmethod\\n    def decorator(\\n        cls: type[LFUCache[T, U]], size: int = 128\\n    ) -> Callable[[Callable[[T], U]], Callable[..., U]]:\\n        \\\"\\\"\\\"\\n        Decorator version of LFU Cache\\n\\n        Decorated function must be function of T -> U\\n        \\\"\\\"\\\"\\n\\n        def cache_decorator_inner(func: Callable[[T], U]) -> Callable[..., U]:\\n            def cache_decorator_wrapper(*args: T) -> U:\\n                if func not in cls.decorator_function_to_instance_map:\\n                    cls.decorator_function_to_instance_map[func] = LFUCache(size)\\n\\n                result = cls.decorator_function_to_instance_map[func].get(args[0])\\n                if result is None:\\n                    result = func(*args)\\n                    cls.decorator_function_to_instance_map[func].set(args[0], result)\\n                return result\\n\\n            def cache_info() -> LFUCache[T, U]:\\n                return cls.decorator_function_to_instance_map[func]\\n\\n            setattr(cache_decorator_wrapper, \\\"cache_info\\\", cache_info)\\n\\n            return cache_decorator_wrapper\\n\\n        return cache_decorator_inner\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "linear congruential generator": "\"__author__ = \\\"Tobias Carryer\\\"\\n\\nfrom time import time\\n\\n\\nclass LinearCongruentialGenerator:\\n    \\\"\\\"\\\"\\n    A pseudorandom number generator.\\n    \\\"\\\"\\\"\\n\\n    # The default value for **seed** is the result of a function call which is not\\n    # normally recommended and causes flake8-bugbear to raise a B008 error. However,\\n    # in this case, it is accptable because `LinearCongruentialGenerator.__init__()`\\n    # will only be called once per instance and it ensures that each instance will\\n    # generate a unique sequence of numbers.\\n\\n    def __init__(self, multiplier, increment, modulo, seed=int(time())):  # noqa: B008\\n        \\\"\\\"\\\"\\n        These parameters are saved and used when nextNumber() is called.\\n\\n        modulo is the largest number that can be generated (exclusive). The most\\n        efficient values are powers of 2. 2^32 is a common value.\\n        \\\"\\\"\\\"\\n        self.multiplier = multiplier\\n        self.increment = increment\\n        self.modulo = modulo\\n        self.seed = seed\\n\\n    def next_number(self):\\n        \\\"\\\"\\\"\\n        The smallest number that can be generated is zero.\\n        The largest number that can be generated is modulo-1. modulo is set in the\\n        constructor.\\n        \\\"\\\"\\\"\\n        self.seed = (self.multiplier * self.seed + self.increment) % self.modulo\\n        return self.seed\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # Show the LCG in action.\\n    lcg = LinearCongruentialGenerator(1664525, 1013904223, 2 << 31)\\n    while True:\\n        print(lcg.next_number())\\n\"",
    "lru cache": "\"from __future__ import annotations\\n\\nfrom typing import Callable, Generic, TypeVar\\n\\nT = TypeVar(\\\"T\\\")\\nU = TypeVar(\\\"U\\\")\\n\\n\\nclass DoubleLinkedListNode(Generic[T, U]):\\n    \\\"\\\"\\\"\\n    Double Linked List Node built specifically for LRU Cache\\n\\n    >>> DoubleLinkedListNode(1,1)\\n    Node: key: 1, val: 1, has next: False, has prev: False\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, key: T | None, val: U | None):\\n        self.key = key\\n        self.val = val\\n        self.next: DoubleLinkedListNode[T, U] | None = None\\n        self.prev: DoubleLinkedListNode[T, U] | None = None\\n\\n    def __repr__(self) -> str:\\n        return \\\"Node: key: {}, val: {}, has next: {}, has prev: {}\\\".format(\\n            self.key, self.val, self.next is not None, self.prev is not None\\n        )\\n\\n\\nclass DoubleLinkedList(Generic[T, U]):\\n    \\\"\\\"\\\"\\n    Double Linked List built specifically for LRU Cache\\n\\n    >>> dll: DoubleLinkedList = DoubleLinkedList()\\n    >>> dll\\n    DoubleLinkedList,\\n        Node: key: None, val: None, has next: True, has prev: False,\\n        Node: key: None, val: None, has next: False, has prev: True\\n\\n    >>> first_node = DoubleLinkedListNode(1,10)\\n    >>> first_node\\n    Node: key: 1, val: 10, has next: False, has prev: False\\n\\n\\n    >>> dll.add(first_node)\\n    >>> dll\\n    DoubleLinkedList,\\n        Node: key: None, val: None, has next: True, has prev: False,\\n        Node: key: 1, val: 10, has next: True, has prev: True,\\n        Node: key: None, val: None, has next: False, has prev: True\\n\\n    >>> # node is mutated\\n    >>> first_node\\n    Node: key: 1, val: 10, has next: True, has prev: True\\n\\n    >>> second_node = DoubleLinkedListNode(2,20)\\n    >>> second_node\\n    Node: key: 2, val: 20, has next: False, has prev: False\\n\\n    >>> dll.add(second_node)\\n    >>> dll\\n    DoubleLinkedList,\\n        Node: key: None, val: None, has next: True, has prev: False,\\n        Node: key: 1, val: 10, has next: True, has prev: True,\\n        Node: key: 2, val: 20, has next: True, has prev: True,\\n        Node: key: None, val: None, has next: False, has prev: True\\n\\n    >>> removed_node = dll.remove(first_node)\\n    >>> assert removed_node == first_node\\n    >>> dll\\n    DoubleLinkedList,\\n        Node: key: None, val: None, has next: True, has prev: False,\\n        Node: key: 2, val: 20, has next: True, has prev: True,\\n        Node: key: None, val: None, has next: False, has prev: True\\n\\n\\n    >>> # Attempt to remove node not on list\\n    >>> removed_node = dll.remove(first_node)\\n    >>> removed_node is None\\n    True\\n\\n    >>> # Attempt to remove head or rear\\n    >>> dll.head\\n    Node: key: None, val: None, has next: True, has prev: False\\n    >>> dll.remove(dll.head) is None\\n    True\\n\\n    >>> # Attempt to remove head or rear\\n    >>> dll.rear\\n    Node: key: None, val: None, has next: False, has prev: True\\n    >>> dll.remove(dll.rear) is None\\n    True\\n\\n\\n    \\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.head: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)\\n        self.rear: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)\\n        self.head.next, self.rear.prev = self.rear, self.head\\n\\n    def __repr__(self) -> str:\\n        rep = [\\\"DoubleLinkedList\\\"]\\n        node = self.head\\n        while node.next is not None:\\n            rep.append(str(node))\\n            node = node.next\\n        rep.append(str(self.rear))\\n        return \\\",\\\\n    \\\".join(rep)\\n\\n    def add(self, node: DoubleLinkedListNode[T, U]) -> None:\\n        \\\"\\\"\\\"\\n        Adds the given node to the end of the list (before rear)\\n        \\\"\\\"\\\"\\n\\n        previous = self.rear.prev\\n\\n        # All nodes other than self.head are guaranteed to have non-None previous\\n        assert previous is not None\\n\\n        previous.next = node\\n        node.prev = previous\\n        self.rear.prev = node\\n        node.next = self.rear\\n\\n    def remove(\\n        self, node: DoubleLinkedListNode[T, U]\\n    ) -> DoubleLinkedListNode[T, U] | None:\\n        \\\"\\\"\\\"\\n        Removes and returns the given node from the list\\n\\n        Returns None if node.prev or node.next is None\\n        \\\"\\\"\\\"\\n\\n        if node.prev is None or node.next is None:\\n            return None\\n\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        node.prev = None\\n        node.next = None\\n        return node\\n\\n\\nclass LRUCache(Generic[T, U]):\\n    \\\"\\\"\\\"\\n    LRU Cache to store a given capacity of data. Can be used as a stand-alone object\\n    or as a function decorator.\\n\\n    >>> cache = LRUCache(2)\\n\\n    >>> cache.set(1, 1)\\n    >>> cache.set(2, 2)\\n    >>> cache.get(1)\\n    1\\n\\n    >>> cache.list\\n    DoubleLinkedList,\\n        Node: key: None, val: None, has next: True, has prev: False,\\n        Node: key: 2, val: 2, has next: True, has prev: True,\\n        Node: key: 1, val: 1, has next: True, has prev: True,\\n        Node: key: None, val: None, has next: False, has prev: True\\n\\n    >>> cache.cache  # doctest: +NORMALIZE_WHITESPACE\\n    {1: Node: key: 1, val: 1, has next: True, has prev: True, \\\\\\n     2: Node: key: 2, val: 2, has next: True, has prev: True}\\n\\n    >>> cache.set(3, 3)\\n\\n    >>> cache.list\\n    DoubleLinkedList,\\n        Node: key: None, val: None, has next: True, has prev: False,\\n        Node: key: 1, val: 1, has next: True, has prev: True,\\n        Node: key: 3, val: 3, has next: True, has prev: True,\\n        Node: key: None, val: None, has next: False, has prev: True\\n\\n    >>> cache.cache  # doctest: +NORMALIZE_WHITESPACE\\n    {1: Node: key: 1, val: 1, has next: True, has prev: True, \\\\\\n     3: Node: key: 3, val: 3, has next: True, has prev: True}\\n\\n    >>> cache.get(2) is None\\n    True\\n\\n    >>> cache.set(4, 4)\\n\\n    >>> cache.get(1) is None\\n    True\\n\\n    >>> cache.get(3)\\n    3\\n\\n    >>> cache.get(4)\\n    4\\n\\n    >>> cache\\n    CacheInfo(hits=3, misses=2, capacity=2, current size=2)\\n\\n    >>> @LRUCache.decorator(100)\\n    ... def fib(num):\\n    ...     if num in (1, 2):\\n    ...         return 1\\n    ...     return fib(num - 1) + fib(num - 2)\\n\\n    >>> for i in range(1, 100):\\n    ...     res = fib(i)\\n\\n    >>> fib.cache_info()\\n    CacheInfo(hits=194, misses=99, capacity=100, current size=99)\\n    \\\"\\\"\\\"\\n\\n    # class variable to map the decorator functions to their respective instance\\n    decorator_function_to_instance_map: dict[Callable[[T], U], LRUCache[T, U]] = {}\\n\\n    def __init__(self, capacity: int):\\n        self.list: DoubleLinkedList[T, U] = DoubleLinkedList()\\n        self.capacity = capacity\\n        self.num_keys = 0\\n        self.hits = 0\\n        self.miss = 0\\n        self.cache: dict[T, DoubleLinkedListNode[T, U]] = {}\\n\\n    def __repr__(self) -> str:\\n        \\\"\\\"\\\"\\n        Return the details for the cache instance\\n        [hits, misses, capacity, current_size]\\n        \\\"\\\"\\\"\\n\\n        return (\\n            f\\\"CacheInfo(hits={self.hits}, misses={self.miss}, \\\"\\n            f\\\"capacity={self.capacity}, current size={self.num_keys})\\\"\\n        )\\n\\n    def __contains__(self, key: T) -> bool:\\n        \\\"\\\"\\\"\\n        >>> cache = LRUCache(1)\\n\\n        >>> 1 in cache\\n        False\\n\\n        >>> cache.set(1, 1)\\n\\n        >>> 1 in cache\\n        True\\n        \\\"\\\"\\\"\\n\\n        return key in self.cache\\n\\n    def get(self, key: T) -> U | None:\\n        \\\"\\\"\\\"\\n        Returns the value for the input key and updates the Double Linked List.\\n        Returns None if key is not present in cache\\n        \\\"\\\"\\\"\\n        # Note: pythonic interface would throw KeyError rather than return None\\n\\n        if key in self.cache:\\n            self.hits += 1\\n            value_node: DoubleLinkedListNode[T, U] = self.cache[key]\\n            node = self.list.remove(self.cache[key])\\n            assert node == value_node\\n\\n            # node is guaranteed not None because it is in self.cache\\n            assert node is not None\\n            self.list.add(node)\\n            return node.val\\n        self.miss += 1\\n        return None\\n\\n    def set(self, key: T, value: U) -> None:\\n        \\\"\\\"\\\"\\n        Sets the value for the input key and updates the Double Linked List\\n        \\\"\\\"\\\"\\n\\n        if key not in self.cache:\\n            if self.num_keys >= self.capacity:\\n                # delete first node (oldest) when over capacity\\n                first_node = self.list.head.next\\n\\n                # guaranteed to have a non-None first node when num_keys > 0\\n                # explain to type checker via assertions\\n                assert first_node is not None\\n                assert first_node.key is not None\\n                assert (\\n                    self.list.remove(first_node) is not None\\n                )  # node guaranteed to be in list assert node.key is not None\\n\\n                del self.cache[first_node.key]\\n                self.num_keys -= 1\\n            self.cache[key] = DoubleLinkedListNode(key, value)\\n            self.list.add(self.cache[key])\\n            self.num_keys += 1\\n\\n        else:\\n            # bump node to the end of the list, update value\\n            node = self.list.remove(self.cache[key])\\n            assert node is not None  # node guaranteed to be in list\\n            node.val = value\\n            self.list.add(node)\\n\\n    @classmethod\\n    def decorator(\\n        cls, size: int = 128\\n    ) -> Callable[[Callable[[T], U]], Callable[..., U]]:\\n        \\\"\\\"\\\"\\n        Decorator version of LRU Cache\\n\\n        Decorated function must be function of T -> U\\n        \\\"\\\"\\\"\\n\\n        def cache_decorator_inner(func: Callable[[T], U]) -> Callable[..., U]:\\n            def cache_decorator_wrapper(*args: T) -> U:\\n                if func not in cls.decorator_function_to_instance_map:\\n                    cls.decorator_function_to_instance_map[func] = LRUCache(size)\\n\\n                result = cls.decorator_function_to_instance_map[func].get(args[0])\\n                if result is None:\\n                    result = func(*args)\\n                    cls.decorator_function_to_instance_map[func].set(args[0], result)\\n                return result\\n\\n            def cache_info() -> LRUCache[T, U]:\\n                return cls.decorator_function_to_instance_map[func]\\n\\n            setattr(cache_decorator_wrapper, \\\"cache_info\\\", cache_info)\\n\\n            return cache_decorator_wrapper\\n\\n        return cache_decorator_inner\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "magicdiamondpattern": "\"# Python program for generating diamond pattern in Python 3.7+\\r\\n\\r\\n\\r\\n# Function to print upper half of diamond (pyramid)\\r\\ndef floyd(n):\\r\\n    \\\"\\\"\\\"\\r\\n        Parameters:\\r\\n    n : size of pattern\\r\\n    \\\"\\\"\\\"\\r\\n    for i in range(0, n):\\r\\n        for j in range(0, n - i - 1):  # printing spaces\\r\\n            print(\\\" \\\", end=\\\"\\\")\\r\\n        for k in range(0, i + 1):  # printing stars\\r\\n            print(\\\"* \\\", end=\\\"\\\")\\r\\n        print()\\r\\n\\r\\n\\r\\n# Function to print lower half of diamond (pyramid)\\r\\ndef reverse_floyd(n):\\r\\n    \\\"\\\"\\\"\\r\\n        Parameters:\\r\\n    n : size of pattern\\r\\n    \\\"\\\"\\\"\\r\\n    for i in range(n, 0, -1):\\r\\n        for j in range(i, 0, -1):  # printing stars\\r\\n            print(\\\"* \\\", end=\\\"\\\")\\r\\n        print()\\r\\n        for k in range(n - i + 1, 0, -1):  # printing spaces\\r\\n            print(\\\" \\\", end=\\\"\\\")\\r\\n\\r\\n\\r\\n# Function to print complete diamond pattern of \\\"*\\\"\\r\\ndef pretty_print(n):\\r\\n    \\\"\\\"\\\"\\r\\n        Parameters:\\r\\n    n : size of pattern\\r\\n    \\\"\\\"\\\"\\r\\n    if n <= 0:\\r\\n        print(\\\"       ...       ....        nothing printing :(\\\")\\r\\n        return\\r\\n    floyd(n)  # upper half\\r\\n    reverse_floyd(n)  # lower half\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    print(r\\\"| /\\\\ | |- |  |-  |--| |\\\\  /| |-\\\")\\r\\n    print(r\\\"|/  \\\\| |- |_ |_  |__| | \\\\/ | |_\\\")\\r\\n    K = 1\\r\\n    while K:\\r\\n        user_number = int(input(\\\"enter the number and , and see the magic : \\\"))\\r\\n        print()\\r\\n        pretty_print(user_number)\\r\\n        K = int(input(\\\"press 0 to exit... and 1 to continue...\\\"))\\r\\n\\r\\n    print(\\\"Good Bye...\\\")\\r\\n\"",
    "nested brackets": "\"\\\"\\\"\\\"\\nThe nested brackets problem is a problem that determines if a sequence of\\nbrackets are properly nested.  A sequence of brackets s is considered properly nested\\nif any of the following conditions are true:\\n\\n        - s is empty\\n        - s has the form (U) or [U] or {U} where U is a properly nested string\\n        - s has the form VW where V and W are properly nested strings\\n\\nFor example, the string \\\"()()[()]\\\" is properly nested but \\\"[(()]\\\" is not.\\n\\nThe function called is_balanced takes as input a string S which is a sequence of\\nbrackets and returns true if S is nested and false otherwise.\\n\\\"\\\"\\\"\\n\\n\\ndef is_balanced(S):\\n\\n    stack = []\\n    open_brackets = set({\\\"(\\\", \\\"[\\\", \\\"{\\\"})\\n    closed_brackets = set({\\\")\\\", \\\"]\\\", \\\"}\\\"})\\n    open_to_closed = dict({\\\"{\\\": \\\"}\\\", \\\"[\\\": \\\"]\\\", \\\"(\\\": \\\")\\\"})\\n\\n    for i in range(len(S)):\\n\\n        if S[i] in open_brackets:\\n            stack.append(S[i])\\n\\n        elif S[i] in closed_brackets:\\n            if len(stack) == 0 or (\\n                len(stack) > 0 and open_to_closed[stack.pop()] != S[i]\\n            ):\\n                return False\\n\\n    return len(stack) == 0\\n\\n\\ndef main():\\n    s = input(\\\"Enter sequence of brackets: \\\")\\n    if is_balanced(s):\\n        print(s, \\\"is balanced\\\")\\n    else:\\n        print(s, \\\"is not balanced\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "password generator": "\"\\\"\\\"\\\"Password Generator allows you to generate a random password of length N.\\\"\\\"\\\"\\nfrom random import choice, shuffle\\nfrom string import ascii_letters, digits, punctuation\\n\\n\\ndef password_generator(length=8):\\n    \\\"\\\"\\\"\\n    >>> len(password_generator())\\n    8\\n    >>> len(password_generator(length=16))\\n    16\\n    >>> len(password_generator(257))\\n    257\\n    >>> len(password_generator(length=0))\\n    0\\n    >>> len(password_generator(-1))\\n    0\\n    \\\"\\\"\\\"\\n    chars = ascii_letters + digits + punctuation\\n    return \\\"\\\".join(choice(chars) for x in range(length))\\n\\n\\n# ALTERNATIVE METHODS\\n# ctbi= characters that must be in password\\n# i= how many letters or characters the password length will be\\ndef alternative_password_generator(ctbi, i):\\n    # Password Generator = full boot with random_number, random_letters, and\\n    # random_character FUNCTIONS\\n    # Put your code here...\\n    i = i - len(ctbi)\\n    quotient = int(i / 3)\\n    remainder = i % 3\\n    # chars = ctbi + random_letters(ascii_letters, i / 3 + remainder) +\\n    #     random_number(digits, i / 3) + random_characters(punctuation, i / 3)\\n    chars = (\\n        ctbi\\n        + random(ascii_letters, quotient + remainder)\\n        + random(digits, quotient)\\n        + random(punctuation, quotient)\\n    )\\n    chars = list(chars)\\n    shuffle(chars)\\n    return \\\"\\\".join(chars)\\n\\n    # random is a generalised function for letters, characters and numbers\\n\\n\\ndef random(ctbi, i):\\n    return \\\"\\\".join(choice(ctbi) for x in range(i))\\n\\n\\ndef random_number(ctbi, i):\\n    pass  # Put your code here...\\n\\n\\ndef random_letters(ctbi, i):\\n    pass  # Put your code here...\\n\\n\\ndef random_characters(ctbi, i):\\n    pass  # Put your code here...\\n\\n\\ndef main():\\n    length = int(input(\\\"Please indicate the max length of your password: \\\").strip())\\n    ctbi = input(\\n        \\\"Please indicate the characters that must be in your password: \\\"\\n    ).strip()\\n    print(\\\"Password generated:\\\", password_generator(length))\\n    print(\\n        \\\"Alternative Password generated:\\\", alternative_password_generator(ctbi, length)\\n    )\\n    print(\\\"[If you are thinking of using this passsword, You better save it.]\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "scoring algorithm": "\"\\\"\\\"\\\"\\ndeveloped by: markmelnic\\noriginal repo: https://github.com/markmelnic/Scoring-Algorithm\\n\\nAnalyse data using a range based percentual proximity algorithm\\nand calculate the linear maximum likelihood estimation.\\nThe basic principle is that all values supplied will be broken\\ndown to a range from 0 to 1 and each column's score will be added\\nup to get the total score.\\n\\n==========\\nExample for data of vehicles\\nprice|mileage|registration_year\\n20k  |60k    |2012\\n22k  |50k    |2011\\n23k  |90k    |2015\\n16k  |210k   |2010\\n\\nWe want the vehicle with the lowest price,\\nlowest mileage but newest registration year.\\nThus the weights for each column are as follows:\\n[0, 0, 1]\\n\\\"\\\"\\\"\\n\\n\\ndef procentual_proximity(\\n    source_data: list[list[float]], weights: list[int]\\n) -> list[list[float]]:\\n\\n    \\\"\\\"\\\"\\n    weights - int list\\n    possible values - 0 / 1\\n    0 if lower values have higher weight in the data set\\n    1 if higher values have higher weight in the data set\\n\\n    >>> procentual_proximity([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]], [0, 0, 1])\\n    [[20, 60, 2012, 2.0], [23, 90, 2015, 1.0], [22, 50, 2011, 1.3333333333333335]]\\n    \\\"\\\"\\\"\\n\\n    # getting data\\n    data_lists: list[list[float]] = []\\n    for data in source_data:\\n        for i, el in enumerate(data):\\n            if len(data_lists) < i + 1:\\n                data_lists.append([])\\n            data_lists[i].append(float(el))\\n\\n    score_lists: list[list[float]] = []\\n    # calculating each score\\n    for dlist, weight in zip(data_lists, weights):\\n        mind = min(dlist)\\n        maxd = max(dlist)\\n\\n        score: list[float] = []\\n        # for weight 0 score is 1 - actual score\\n        if weight == 0:\\n            for item in dlist:\\n                try:\\n                    score.append(1 - ((item - mind) / (maxd - mind)))\\n                except ZeroDivisionError:\\n                    score.append(1)\\n\\n        elif weight == 1:\\n            for item in dlist:\\n                try:\\n                    score.append((item - mind) / (maxd - mind))\\n                except ZeroDivisionError:\\n                    score.append(0)\\n\\n        # weight not 0 or 1\\n        else:\\n            raise ValueError(\\\"Invalid weight of %f provided\\\" % (weight))\\n\\n        score_lists.append(score)\\n\\n    # initialize final scores\\n    final_scores: list[float] = [0 for i in range(len(score_lists[0]))]\\n\\n    # generate final scores\\n    for i, slist in enumerate(score_lists):\\n        for j, ele in enumerate(slist):\\n            final_scores[j] = final_scores[j] + ele\\n\\n    # append scores to source data\\n    for i, ele in enumerate(final_scores):\\n        source_data[i].append(ele)\\n\\n    return source_data\\n\"",
    "sdes": "\"def apply_table(inp, table):\\r\\n    \\\"\\\"\\\"\\r\\n    >>> apply_table(\\\"0123456789\\\", list(range(10)))\\r\\n    '9012345678'\\r\\n    >>> apply_table(\\\"0123456789\\\", list(range(9, -1, -1)))\\r\\n    '8765432109'\\r\\n    \\\"\\\"\\\"\\r\\n    res = \\\"\\\"\\r\\n    for i in table:\\r\\n        res += inp[i - 1]\\r\\n    return res\\r\\n\\r\\n\\r\\ndef left_shift(data):\\r\\n    \\\"\\\"\\\"\\r\\n    >>> left_shift(\\\"0123456789\\\")\\r\\n    '1234567890'\\r\\n    \\\"\\\"\\\"\\r\\n    return data[1:] + data[0]\\r\\n\\r\\n\\r\\ndef XOR(a, b):\\r\\n    \\\"\\\"\\\"\\r\\n    >>> XOR(\\\"01010101\\\", \\\"00001111\\\")\\r\\n    '01011010'\\r\\n    \\\"\\\"\\\"\\r\\n    res = \\\"\\\"\\r\\n    for i in range(len(a)):\\r\\n        if a[i] == b[i]:\\r\\n            res += \\\"0\\\"\\r\\n        else:\\r\\n            res += \\\"1\\\"\\r\\n    return res\\r\\n\\r\\n\\r\\ndef apply_sbox(s, data):\\r\\n    row = int(\\\"0b\\\" + data[0] + data[-1], 2)\\r\\n    col = int(\\\"0b\\\" + data[1:3], 2)\\r\\n    return bin(s[row][col])[2:]\\r\\n\\r\\n\\r\\ndef function(expansion, s0, s1, key, message):\\r\\n    left = message[:4]\\r\\n    right = message[4:]\\r\\n    temp = apply_table(right, expansion)\\r\\n    temp = XOR(temp, key)\\r\\n    l = apply_sbox(s0, temp[:4])  # noqa: E741\\r\\n    r = apply_sbox(s1, temp[4:])\\r\\n    l = \\\"0\\\" * (2 - len(l)) + l  # noqa: E741\\r\\n    r = \\\"0\\\" * (2 - len(r)) + r\\r\\n    temp = apply_table(l + r, p4_table)\\r\\n    temp = XOR(left, temp)\\r\\n    return temp + right\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n\\r\\n    key = input(\\\"Enter 10 bit key: \\\")\\r\\n    message = input(\\\"Enter 8 bit message: \\\")\\r\\n\\r\\n    p8_table = [6, 3, 7, 4, 8, 5, 10, 9]\\r\\n    p10_table = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]\\r\\n    p4_table = [2, 4, 3, 1]\\r\\n    IP = [2, 6, 3, 1, 4, 8, 5, 7]\\r\\n    IP_inv = [4, 1, 3, 5, 7, 2, 8, 6]\\r\\n    expansion = [4, 1, 2, 3, 2, 3, 4, 1]\\r\\n    s0 = [[1, 0, 3, 2], [3, 2, 1, 0], [0, 2, 1, 3], [3, 1, 3, 2]]\\r\\n    s1 = [[0, 1, 2, 3], [2, 0, 1, 3], [3, 0, 1, 0], [2, 1, 0, 3]]\\r\\n\\r\\n    # key generation\\r\\n    temp = apply_table(key, p10_table)\\r\\n    left = temp[:5]\\r\\n    right = temp[5:]\\r\\n    left = left_shift(left)\\r\\n    right = left_shift(right)\\r\\n    key1 = apply_table(left + right, p8_table)\\r\\n    left = left_shift(left)\\r\\n    right = left_shift(right)\\r\\n    left = left_shift(left)\\r\\n    right = left_shift(right)\\r\\n    key2 = apply_table(left + right, p8_table)\\r\\n\\r\\n    # encryption\\r\\n    temp = apply_table(message, IP)\\r\\n    temp = function(expansion, s0, s1, key1, temp)\\r\\n    temp = temp[4:] + temp[:4]\\r\\n    temp = function(expansion, s0, s1, key2, temp)\\r\\n    CT = apply_table(temp, IP_inv)\\r\\n    print(\\\"Cipher text is:\\\", CT)\\r\\n\\r\\n    # decryption\\r\\n    temp = apply_table(CT, IP)\\r\\n    temp = function(expansion, s0, s1, key2, temp)\\r\\n    temp = temp[4:] + temp[:4]\\r\\n    temp = function(expansion, s0, s1, key1, temp)\\r\\n    PT = apply_table(temp, IP_inv)\\r\\n    print(\\\"Plain text after decypting is:\\\", PT)\\r\\n\"",
    "tower of hanoi": "\"def moveTower(height, fromPole, toPole, withPole):\\n    \\\"\\\"\\\"\\n    >>> moveTower(3, 'A', 'B', 'C')\\n    moving disk from A to B\\n    moving disk from A to C\\n    moving disk from B to C\\n    moving disk from A to B\\n    moving disk from C to A\\n    moving disk from C to B\\n    moving disk from A to B\\n    \\\"\\\"\\\"\\n    if height >= 1:\\n        moveTower(height - 1, fromPole, withPole, toPole)\\n        moveDisk(fromPole, toPole)\\n        moveTower(height - 1, withPole, toPole, fromPole)\\n\\n\\ndef moveDisk(fp, tp):\\n    print(\\\"moving disk from\\\", fp, \\\"to\\\", tp)\\n\\n\\ndef main():\\n    height = int(input(\\\"Height of hanoi: \\\").strip())\\n    moveTower(height, \\\"A\\\", \\\"B\\\", \\\"C\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "newtons second law of motion": "\"\\\"\\\"\\\"\\nDescription :\\nNewton's second law of motion pertains to the behavior of objects for which\\nall existing forces are not balanced.\\nThe second law states that the acceleration of an object is dependent upon two variables\\n- the net force acting upon the object and the mass of the object.\\nThe acceleration of an object depends directly\\nupon the net force acting upon the object,\\nand inversely upon the mass of the object.\\nAs the force acting upon an object is increased,\\nthe acceleration of the object is increased.\\nAs the mass of an object is increased, the acceleration of the object is decreased.\\nSource: https://www.physicsclassroom.com/class/newtlaws/Lesson-3/Newton-s-Second-Law\\nFormulation: Fnet = m • a\\nDiagrammatic Explanation:\\n              Forces are unbalanced\\n                        |\\n                        |\\n                        |\\n                        V\\n               There is acceleration\\n                        /\\\\\\n                       /  \\\\\\n                      /    \\\\\\n                     /      \\\\\\n                    /        \\\\\\n                   /          \\\\\\n                  /            \\\\\\n        __________________   ____ ________________\\n        |The acceleration |  |The acceleration   |\\n        |depends directly |  |depends inversely  |\\n        |on the net Force |  |upon the object's  |\\n        |_________________|  |mass_______________|\\nUnits:\\n1 Newton = 1 kg X meters / (seconds^2)\\nHow to use?\\nInputs:\\n    ___________________________________________________\\n   |Name         | Units                   | Type      |\\n   |-------------|-------------------------|-----------|\\n   |mass         | (in kgs)                | float     |\\n   |-------------|-------------------------|-----------|\\n   |acceleration | (in meters/(seconds^2)) | float     |\\n   |_____________|_________________________|___________|\\n\\nOutput:\\n    ___________________________________________________\\n   |Name         | Units                   | Type      |\\n   |-------------|-------------------------|-----------|\\n   |force        | (in Newtons)            | float     |\\n   |_____________|_________________________|___________|\\n\\n\\\"\\\"\\\"\\n\\n\\ndef newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\\n    \\\"\\\"\\\"\\n    >>> newtons_second_law_of_motion(10, 10)\\n    100\\n    >>> newtons_second_law_of_motion(2.0, 1)\\n    2.0\\n    \\\"\\\"\\\"\\n    force = float()\\n    try:\\n        force = mass * acceleration\\n    except Exception:\\n        return -0.0\\n    return force\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    # run doctest\\n    doctest.testmod()\\n\\n    # demo\\n    mass = 12.5\\n    acceleration = 10\\n    force = newtons_second_law_of_motion(mass, acceleration)\\n    print(\\\"The force is \\\", force, \\\"N\\\")\\n\"",
    "n body simulation": "\"\\\"\\\"\\\"\\r\\nIn physics and astronomy, a gravitational N-body simulation is a simulation of a\\r\\ndynamical system of particles under the influence of gravity. The system\\r\\nconsists of a number of bodies, each of which exerts a gravitational force on all\\r\\nother bodies. These forces are calculated using Newton's law of universal\\r\\ngravitation. The Euler method is used at each time-step to calculate the change in\\r\\nvelocity and position brought about by these forces. Softening is used to prevent\\r\\nnumerical divergences when a particle comes too close to another (and the force\\r\\ngoes to infinity).\\r\\n(Description adapted from https://en.wikipedia.org/wiki/N-body_simulation )\\r\\n(See also http://www.shodor.org/refdesk/Resources/Algorithms/EulersMethod/ )\\r\\n\\\"\\\"\\\"\\r\\n\\r\\n\\r\\nfrom __future__ import annotations\\r\\n\\r\\nimport random\\r\\n\\r\\nfrom matplotlib import animation\\r\\nfrom matplotlib import pyplot as plt\\r\\n\\r\\n\\r\\nclass Body:\\r\\n    def __init__(\\r\\n        self,\\r\\n        position_x: float,\\r\\n        position_y: float,\\r\\n        velocity_x: float,\\r\\n        velocity_y: float,\\r\\n        mass: float = 1.0,\\r\\n        size: float = 1.0,\\r\\n        color: str = \\\"blue\\\",\\r\\n    ) -> None:\\r\\n        \\\"\\\"\\\"\\r\\n        The parameters \\\"size\\\" & \\\"color\\\" are not relevant for the simulation itself,\\r\\n        they are only used for plotting.\\r\\n        \\\"\\\"\\\"\\r\\n        self.position_x = position_x\\r\\n        self.position_y = position_y\\r\\n        self.velocity_x = velocity_x\\r\\n        self.velocity_y = velocity_y\\r\\n        self.mass = mass\\r\\n        self.size = size\\r\\n        self.color = color\\r\\n\\r\\n    @property\\r\\n    def position(self) -> tuple[float, float]:\\r\\n        return self.position_x, self.position_y\\r\\n\\r\\n    @property\\r\\n    def velocity(self) -> tuple[float, float]:\\r\\n        return self.velocity_x, self.velocity_y\\r\\n\\r\\n    def update_velocity(\\r\\n        self, force_x: float, force_y: float, delta_time: float\\r\\n    ) -> None:\\r\\n        \\\"\\\"\\\"\\r\\n        Euler algorithm for velocity\\r\\n\\r\\n        >>> body_1 = Body(0.,0.,0.,0.)\\r\\n        >>> body_1.update_velocity(1.,0.,1.)\\r\\n        >>> body_1.velocity\\r\\n        (1.0, 0.0)\\r\\n\\r\\n        >>> body_1.update_velocity(1.,0.,1.)\\r\\n        >>> body_1.velocity\\r\\n        (2.0, 0.0)\\r\\n\\r\\n        >>> body_2 = Body(0.,0.,5.,0.)\\r\\n        >>> body_2.update_velocity(0.,-10.,10.)\\r\\n        >>> body_2.velocity\\r\\n        (5.0, -100.0)\\r\\n\\r\\n        >>> body_2.update_velocity(0.,-10.,10.)\\r\\n        >>> body_2.velocity\\r\\n        (5.0, -200.0)\\r\\n        \\\"\\\"\\\"\\r\\n        self.velocity_x += force_x * delta_time\\r\\n        self.velocity_y += force_y * delta_time\\r\\n\\r\\n    def update_position(self, delta_time: float) -> None:\\r\\n        \\\"\\\"\\\"\\r\\n        Euler algorithm for position\\r\\n\\r\\n        >>> body_1 = Body(0.,0.,1.,0.)\\r\\n        >>> body_1.update_position(1.)\\r\\n        >>> body_1.position\\r\\n        (1.0, 0.0)\\r\\n\\r\\n        >>> body_1.update_position(1.)\\r\\n        >>> body_1.position\\r\\n        (2.0, 0.0)\\r\\n\\r\\n        >>> body_2 = Body(10.,10.,0.,-2.)\\r\\n        >>> body_2.update_position(1.)\\r\\n        >>> body_2.position\\r\\n        (10.0, 8.0)\\r\\n\\r\\n        >>> body_2.update_position(1.)\\r\\n        >>> body_2.position\\r\\n        (10.0, 6.0)\\r\\n        \\\"\\\"\\\"\\r\\n        self.position_x += self.velocity_x * delta_time\\r\\n        self.position_y += self.velocity_y * delta_time\\r\\n\\r\\n\\r\\nclass BodySystem:\\r\\n    \\\"\\\"\\\"\\r\\n    This class is used to hold the bodies, the gravitation constant, the time\\r\\n    factor and the softening factor. The time factor is used to control the speed\\r\\n    of the simulation. The softening factor is used for softening, a numerical\\r\\n    trick for N-body simulations to prevent numerical divergences when two bodies\\r\\n    get too close to each other.\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def __init__(\\r\\n        self,\\r\\n        bodies: list[Body],\\r\\n        gravitation_constant: float = 1.0,\\r\\n        time_factor: float = 1.0,\\r\\n        softening_factor: float = 0.0,\\r\\n    ) -> None:\\r\\n        self.bodies = bodies\\r\\n        self.gravitation_constant = gravitation_constant\\r\\n        self.time_factor = time_factor\\r\\n        self.softening_factor = softening_factor\\r\\n\\r\\n    def __len__(self) -> int:\\r\\n        return len(self.bodies)\\r\\n\\r\\n    def update_system(self, delta_time: float) -> None:\\r\\n        \\\"\\\"\\\"\\r\\n        For each body, loop through all other bodies to calculate the total\\r\\n        force they exert on it. Use that force to update the body's velocity.\\r\\n\\r\\n        >>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)])\\r\\n        >>> len(body_system_1)\\r\\n        2\\r\\n        >>> body_system_1.update_system(1)\\r\\n        >>> body_system_1.bodies[0].position\\r\\n        (0.01, 0.0)\\r\\n        >>> body_system_1.bodies[0].velocity\\r\\n        (0.01, 0.0)\\r\\n\\r\\n        >>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10)\\r\\n        >>> body_system_2.update_system(1)\\r\\n        >>> body_system_2.bodies[0].position\\r\\n        (-9.0, 0.0)\\r\\n        >>> body_system_2.bodies[0].velocity\\r\\n        (0.1, 0.0)\\r\\n        \\\"\\\"\\\"\\r\\n        for body1 in self.bodies:\\r\\n            force_x = 0.0\\r\\n            force_y = 0.0\\r\\n            for body2 in self.bodies:\\r\\n                if body1 != body2:\\r\\n                    dif_x = body2.position_x - body1.position_x\\r\\n                    dif_y = body2.position_y - body1.position_y\\r\\n\\r\\n                    # Calculation of the distance using Pythagoras's theorem\\r\\n                    # Extra factor due to the softening technique\\r\\n                    distance = (dif_x ** 2 + dif_y ** 2 + self.softening_factor) ** (\\r\\n                        1 / 2\\r\\n                    )\\r\\n\\r\\n                    # Newton's law of universal gravitation.\\r\\n                    force_x += (\\r\\n                        self.gravitation_constant * body2.mass * dif_x / distance ** 3\\r\\n                    )\\r\\n                    force_y += (\\r\\n                        self.gravitation_constant * body2.mass * dif_y / distance ** 3\\r\\n                    )\\r\\n\\r\\n            # Update the body's velocity once all the force components have been added\\r\\n            body1.update_velocity(force_x, force_y, delta_time * self.time_factor)\\r\\n\\r\\n        # Update the positions only after all the velocities have been updated\\r\\n        for body in self.bodies:\\r\\n            body.update_position(delta_time * self.time_factor)\\r\\n\\r\\n\\r\\ndef update_step(\\r\\n    body_system: BodySystem, delta_time: float, patches: list[plt.Circle]\\r\\n) -> None:\\r\\n    \\\"\\\"\\\"\\r\\n    Updates the body-system and applies the change to the patch-list used for plotting\\r\\n\\r\\n    >>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)])\\r\\n    >>> patches_1 = [plt.Circle((body.position_x, body.position_y), body.size,\\r\\n    ... fc=body.color)for body in body_system_1.bodies] #doctest: +ELLIPSIS\\r\\n    >>> update_step(body_system_1, 1, patches_1)\\r\\n    >>> patches_1[0].center\\r\\n    (0.01, 0.0)\\r\\n\\r\\n    >>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10)\\r\\n    >>> patches_2 = [plt.Circle((body.position_x, body.position_y), body.size,\\r\\n    ... fc=body.color)for body in body_system_2.bodies] #doctest: +ELLIPSIS\\r\\n    >>> update_step(body_system_2, 1, patches_2)\\r\\n    >>> patches_2[0].center\\r\\n    (-9.0, 0.0)\\r\\n    \\\"\\\"\\\"\\r\\n    # Update the positions of the bodies\\r\\n    body_system.update_system(delta_time)\\r\\n\\r\\n    # Update the positions of the patches\\r\\n    for patch, body in zip(patches, body_system.bodies):\\r\\n        patch.center = (body.position_x, body.position_y)\\r\\n\\r\\n\\r\\ndef plot(\\r\\n    title: str,\\r\\n    body_system: BodySystem,\\r\\n    x_start: float = -1,\\r\\n    x_end: float = 1,\\r\\n    y_start: float = -1,\\r\\n    y_end: float = 1,\\r\\n) -> None:\\r\\n    \\\"\\\"\\\"\\r\\n    Utility function to plot how the given body-system evolves over time.\\r\\n    No doctest provided since this function does not have a return value.\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    INTERVAL = 20  # Frame rate of the animation\\r\\n    DELTA_TIME = INTERVAL / 1000  # Time between time steps in seconds\\r\\n\\r\\n    fig = plt.figure()\\r\\n    fig.canvas.set_window_title(title)\\r\\n    ax = plt.axes(\\r\\n        xlim=(x_start, x_end), ylim=(y_start, y_end)\\r\\n    )  # Set section to be plotted\\r\\n    plt.gca().set_aspect(\\\"equal\\\")  # Fix aspect ratio\\r\\n\\r\\n    # Each body is drawn as a patch by the plt-function\\r\\n    patches = [\\r\\n        plt.Circle((body.position_x, body.position_y), body.size, fc=body.color)\\r\\n        for body in body_system.bodies\\r\\n    ]\\r\\n\\r\\n    for patch in patches:\\r\\n        ax.add_patch(patch)\\r\\n\\r\\n    # Function called at each step of the animation\\r\\n    def update(frame: int) -> list[plt.Circle]:\\r\\n        update_step(body_system, DELTA_TIME, patches)\\r\\n        return patches\\r\\n\\r\\n    anim = animation.FuncAnimation(  # noqa: F841\\r\\n        fig, update, interval=INTERVAL, blit=True\\r\\n    )\\r\\n\\r\\n    plt.show()\\r\\n\\r\\n\\r\\ndef example_1() -> BodySystem:\\r\\n    \\\"\\\"\\\"\\r\\n    Example 1: figure-8 solution to the 3-body-problem\\r\\n    This example can be seen as a test of the implementation: given the right\\r\\n    initial conditions, the bodies should move in a figure-8.\\r\\n    (initial conditions taken from http://www.artcompsci.org/vol_1/v1_web/node56.html)\\r\\n    >>> body_system = example_1()\\r\\n    >>> len(body_system)\\r\\n    3\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    position_x = 0.9700436\\r\\n    position_y = -0.24308753\\r\\n    velocity_x = 0.466203685\\r\\n    velocity_y = 0.43236573\\r\\n\\r\\n    bodies1 = [\\r\\n        Body(position_x, position_y, velocity_x, velocity_y, size=0.2, color=\\\"red\\\"),\\r\\n        Body(-position_x, -position_y, velocity_x, velocity_y, size=0.2, color=\\\"green\\\"),\\r\\n        Body(0, 0, -2 * velocity_x, -2 * velocity_y, size=0.2, color=\\\"blue\\\"),\\r\\n    ]\\r\\n    return BodySystem(bodies1, time_factor=3)\\r\\n\\r\\n\\r\\ndef example_2() -> BodySystem:\\r\\n    \\\"\\\"\\\"\\r\\n    Example 2: Moon's orbit around the earth\\r\\n    This example can be seen as a test of the implementation: given the right\\r\\n    initial conditions, the moon should orbit around the earth as it actually does.\\r\\n    (mass, velocity and distance taken from https://en.wikipedia.org/wiki/Earth\\r\\n    and https://en.wikipedia.org/wiki/Moon)\\r\\n    No doctest provided since this function does not have a return value.\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    moon_mass = 7.3476e22\\r\\n    earth_mass = 5.972e24\\r\\n    velocity_dif = 1022\\r\\n    earth_moon_distance = 384399000\\r\\n    gravitation_constant = 6.674e-11\\r\\n\\r\\n    # Calculation of the respective velocities so that total impulse is zero,\\r\\n    # i.e. the two bodies together don't move\\r\\n    moon_velocity = earth_mass * velocity_dif / (earth_mass + moon_mass)\\r\\n    earth_velocity = moon_velocity - velocity_dif\\r\\n\\r\\n    moon = Body(-earth_moon_distance, 0, 0, moon_velocity, moon_mass, 10000000, \\\"grey\\\")\\r\\n    earth = Body(0, 0, 0, earth_velocity, earth_mass, 50000000, \\\"blue\\\")\\r\\n    return BodySystem([earth, moon], gravitation_constant, time_factor=1000000)\\r\\n\\r\\n\\r\\ndef example_3() -> BodySystem:\\r\\n    \\\"\\\"\\\"\\r\\n    Example 3: Random system with many bodies.\\r\\n    No doctest provided since this function does not have a return value.\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    bodies = []\\r\\n    for i in range(10):\\r\\n        velocity_x = random.uniform(-0.5, 0.5)\\r\\n        velocity_y = random.uniform(-0.5, 0.5)\\r\\n\\r\\n        # Bodies are created pairwise with opposite velocities so that the\\r\\n        # total impulse remains zero\\r\\n        bodies.append(\\r\\n            Body(\\r\\n                random.uniform(-0.5, 0.5),\\r\\n                random.uniform(-0.5, 0.5),\\r\\n                velocity_x,\\r\\n                velocity_y,\\r\\n                size=0.05,\\r\\n            )\\r\\n        )\\r\\n        bodies.append(\\r\\n            Body(\\r\\n                random.uniform(-0.5, 0.5),\\r\\n                random.uniform(-0.5, 0.5),\\r\\n                -velocity_x,\\r\\n                -velocity_y,\\r\\n                size=0.05,\\r\\n            )\\r\\n        )\\r\\n    return BodySystem(bodies, 0.01, 10, 0.1)\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    plot(\\\"Figure-8 solution to the 3-body-problem\\\", example_1(), -2, 2, -2, 2)\\r\\n    plot(\\r\\n        \\\"Moon's orbit around the earth\\\",\\r\\n        example_2(),\\r\\n        -430000000,\\r\\n        430000000,\\r\\n        -430000000,\\r\\n        430000000,\\r\\n    )\\r\\n    plot(\\\"Random system with many bodies\\\", example_3(), -1.5, 1.5, -1.5, 1.5)\\r\\n\"",
    "deutsch jozsa": "\"#!/usr/bin/env python3\\n\\\"\\\"\\\"\\nDeutsch-Josza Algorithm is one of the first examples of a quantum\\nalgorithm that is exponentially faster than any possible deterministic\\nclassical algorithm\\n\\nPremise:\\nWe are given a hidden Boolean function f,\\nwhich takes as input a string of bits, and returns either 0 or 1:\\n\\nf({x0,x1,x2,...}) -> 0 or 1, where xn is 0 or 1\\n\\nThe property of the given Boolean function is that it is guaranteed to\\neither be balanced or constant. A constant function returns all 0's\\nor all 1's for any input, while a balanced function returns  0's for\\nexactly half of all inputs and 1's for the other half. Our task is to\\ndetermine whether the given function is balanced or constant.\\n\\nReferences:\\n- https://en.wikipedia.org/wiki/Deutsch-Jozsa_algorithm\\n- https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html\\n\\\"\\\"\\\"\\n\\nimport numpy as np\\nimport qiskit as q\\n\\n\\ndef dj_oracle(case: str, num_qubits: int) -> q.QuantumCircuit:\\n    \\\"\\\"\\\"\\n    Returns a Quantum Circuit for the Oracle function.\\n    The circuit returned can represent balanced or constant function,\\n    according to the arguments passed\\n    \\\"\\\"\\\"\\n    # This circuit has num_qubits+1 qubits: the size of the input,\\n    # plus one output qubit\\n    oracle_qc = q.QuantumCircuit(num_qubits + 1)\\n\\n    # First, let's deal with the case in which oracle is balanced\\n    if case == \\\"balanced\\\":\\n        # First generate a random number that tells us which CNOTs to\\n        # wrap in X-gates:\\n        b = np.random.randint(1, 2 ** num_qubits)\\n        # Next, format 'b' as a binary string of length 'n', padded with zeros:\\n        b_str = format(b, f\\\"0{num_qubits}b\\\")\\n        # Next, we place the first X-gates. Each digit in our binary string\\n        # correspopnds to a qubit, if the digit is 0, we do nothing, if it's 1\\n        # we apply an X-gate to that qubit:\\n        for index, bit in enumerate(b_str):\\n            if bit == \\\"1\\\":\\n                oracle_qc.x(index)\\n        # Do the controlled-NOT gates for each qubit, using the output qubit\\n        # as the target:\\n        for index in range(num_qubits):\\n            oracle_qc.cx(index, num_qubits)\\n        # Next, place the final X-gates\\n        for index, bit in enumerate(b_str):\\n            if bit == \\\"1\\\":\\n                oracle_qc.x(index)\\n\\n    # Case in which oracle is constant\\n    if case == \\\"constant\\\":\\n        # First decide what the fixed output of the oracle will be\\n        # (either always 0 or always 1)\\n        output = np.random.randint(2)\\n        if output == 1:\\n            oracle_qc.x(num_qubits)\\n\\n    oracle_gate = oracle_qc.to_gate()\\n    oracle_gate.name = \\\"Oracle\\\"  # To show when we display the circuit\\n    return oracle_gate\\n\\n\\ndef dj_algorithm(oracle: q.QuantumCircuit, num_qubits: int) -> q.QuantumCircuit:\\n    \\\"\\\"\\\"\\n    Returns the complete Deustch-Jozsa Quantum Circuit,\\n    adding Input & Output registers and Hadamard & Measurement Gates,\\n    to the Oracle Circuit passed in arguments\\n    \\\"\\\"\\\"\\n    dj_circuit = q.QuantumCircuit(num_qubits + 1, num_qubits)\\n    # Set up the output qubit:\\n    dj_circuit.x(num_qubits)\\n    dj_circuit.h(num_qubits)\\n    # And set up the input register:\\n    for qubit in range(num_qubits):\\n        dj_circuit.h(qubit)\\n    # Let's append the oracle gate to our circuit:\\n    dj_circuit.append(oracle, range(num_qubits + 1))\\n    # Finally, perform the H-gates again and measure:\\n    for qubit in range(num_qubits):\\n        dj_circuit.h(qubit)\\n\\n    for i in range(num_qubits):\\n        dj_circuit.measure(i, i)\\n\\n    return dj_circuit\\n\\n\\ndef deutsch_jozsa(case: str, num_qubits: int) -> q.result.counts.Counts:\\n    \\\"\\\"\\\"\\n    Main function that builds the circuit using other helper functions,\\n    runs the experiment 1000 times & returns the resultant qubit counts\\n    >>> deutsch_jozsa(\\\"constant\\\", 3)\\n    {'000': 1000}\\n    >>> deutsch_jozsa(\\\"balanced\\\", 3)\\n    {'111': 1000}\\n    \\\"\\\"\\\"\\n    # Use Aer's qasm_simulator\\n    simulator = q.Aer.get_backend(\\\"qasm_simulator\\\")\\n\\n    oracle_gate = dj_oracle(case, num_qubits)\\n    dj_circuit = dj_algorithm(oracle_gate, num_qubits)\\n\\n    # Execute the circuit on the qasm simulator\\n    job = q.execute(dj_circuit, simulator, shots=1000)\\n\\n    # Return the histogram data of the results of the experiment.\\n    return job.result().get_counts(dj_circuit)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(f\\\"Deutsch Jozsa - Constant Oracle: {deutsch_jozsa('constant', 3)}\\\")\\n    print(f\\\"Deutsch Jozsa - Balanced Oracle: {deutsch_jozsa('balanced', 3)}\\\")\\n\"",
    "half adder": "\"#!/usr/bin/env python3\\n\\\"\\\"\\\"\\nBuild a half-adder quantum circuit that takes two bits as input,\\nencodes them into qubits, then runs the half-adder circuit calculating\\nthe sum and carry qubits, observed over 1000 runs of the experiment\\n.\\n\\nReferences:\\nhttps://en.wikipedia.org/wiki/Adder_(electronics)\\nhttps://qiskit.org/textbook/ch-states/atoms-computation.html#4.2-Remembering-how-to-add-\\n\\\"\\\"\\\"\\n\\nimport qiskit as q\\n\\n\\ndef half_adder(bit0: int, bit1: int) -> q.result.counts.Counts:\\n    \\\"\\\"\\\"\\n    >>> half_adder(0, 0)\\n    {'00': 1000}\\n    >>> half_adder(0, 1)\\n    {'01': 1000}\\n    >>> half_adder(1, 0)\\n    {'01': 1000}\\n    >>> half_adder(1, 1)\\n    {'10': 1000}\\n    \\\"\\\"\\\"\\n    # Use Aer's qasm_simulator\\n    simulator = q.Aer.get_backend(\\\"qasm_simulator\\\")\\n\\n    qc_ha = q.QuantumCircuit(4, 2)\\n    # encode inputs in qubits 0 and 1\\n    if bit0 == 1:\\n        qc_ha.x(0)\\n    if bit1 == 1:\\n        qc_ha.x(1)\\n    qc_ha.barrier()\\n\\n    # use cnots to write XOR of the inputs on qubit2\\n    qc_ha.cx(0, 2)\\n    qc_ha.cx(1, 2)\\n\\n    # use ccx / toffoli gate to write AND of the inputs on qubit3\\n    qc_ha.ccx(0, 1, 3)\\n    qc_ha.barrier()\\n\\n    # extract outputs\\n    qc_ha.measure(2, 0)  # extract XOR value\\n    qc_ha.measure(3, 1)  # extract AND value\\n\\n    # Execute the circuit on the qasm simulator\\n    job = q.execute(qc_ha, simulator, shots=1000)\\n\\n    # Return the histogram data of the results of the experiment.\\n    return job.result().get_counts(qc_ha)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    counts = half_adder(1, 1)\\n    print(f\\\"Half Adder Output Qubit Counts: {counts}\\\")\\n\"",
    "not gate": "\"#!/usr/bin/env python3\\n\\\"\\\"\\\"\\nBuild a simple bare-minimum quantum circuit that starts with a single\\nqubit (by default, in state 0) and inverts it. Run the experiment 1000\\ntimes and print the total count of the states finally observed.\\nQiskit Docs: https://qiskit.org/documentation/getting_started.html\\n\\\"\\\"\\\"\\n\\nimport qiskit as q\\n\\n\\ndef single_qubit_measure(qubits: int, classical_bits: int) -> q.result.counts.Counts:\\n    \\\"\\\"\\\"\\n    >>> single_qubit_measure(2, 2)\\n    {'11': 1000}\\n    >>> single_qubit_measure(4, 4)\\n    {'0011': 1000}\\n    \\\"\\\"\\\"\\n    # Use Aer's qasm_simulator\\n    simulator = q.Aer.get_backend(\\\"qasm_simulator\\\")\\n\\n    # Create a Quantum Circuit acting on the q register\\n    circuit = q.QuantumCircuit(qubits, classical_bits)\\n\\n    # Apply X (NOT) Gate to Qubits 0 & 1\\n    circuit.x(0)\\n    circuit.x(1)\\n\\n    # Map the quantum measurement to the classical bits\\n    circuit.measure([0, 1], [0, 1])\\n\\n    # Execute the circuit on the qasm simulator\\n    job = q.execute(circuit, simulator, shots=1000)\\n\\n    # Return the histogram data of the results of the experiment.\\n    return job.result().get_counts(circuit)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    counts = single_qubit_measure(2, 2)\\n    print(f\\\"Total count for various states are: {counts}\\\")\\n\"",
    "quantum entanglement": "\"#!/usr/bin/env python3\\n\\\"\\\"\\\"\\nBuild a quantum circuit with pair or group of qubits to perform\\nquantum entanglement.\\nQuantum entanglement is a phenomenon observed at the quantum scale\\nwhere entangled particles stay connected (in some sense) so that\\nthe actions performed on one of the particles affects the other,\\nno matter the distance between two particles.\\n\\\"\\\"\\\"\\n\\nimport qiskit\\n\\n\\ndef quantum_entanglement(qubits: int = 2) -> qiskit.result.counts.Counts:\\n    \\\"\\\"\\\"\\n    # >>> quantum_entanglement(2)\\n    # {'00': 500, '11': 500}\\n    #      ┌───┐     ┌─┐\\n    # q_0: ┤ H ├──■──┤M├───\\n    #      └───┘┌─┴─┐└╥┘┌─┐\\n    # q_1: ─────┤ X ├─╫─┤M├\\n    #           └───┘ ║ └╥┘\\n    # c: 2/═══════════╩══╩═\\n    #                 0  1\\n    Args:\\n        qubits (int): number of quibits to use. Defaults to 2\\n    Returns:\\n        qiskit.result.counts.Counts: mapping of states to its counts\\n    \\\"\\\"\\\"\\n    classical_bits = qubits\\n\\n    # Using Aer's qasm_simulator\\n    simulator = qiskit.Aer.get_backend(\\\"qasm_simulator\\\")\\n\\n    # Creating a Quantum Circuit acting on the q register\\n    circuit = qiskit.QuantumCircuit(qubits, classical_bits)\\n\\n    # Adding a H gate on qubit 0 (now q0 in superposition)\\n    circuit.h(0)\\n\\n    for i in range(1, qubits):\\n        # Adding CX (CNOT) gate\\n        circuit.cx(i - 1, i)\\n\\n    # Mapping the quantum measurement to the classical bits\\n    circuit.measure(list(range(qubits)), list(range(classical_bits)))\\n\\n    # Now measuring any one qubit would affect other qubits to collapse\\n    # their super position and have same state as the measured one.\\n\\n    # Executing the circuit on the qasm simulator\\n    job = qiskit.execute(circuit, simulator, shots=1000)\\n\\n    return job.result().get_counts(circuit)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(f\\\"Total count for various states are: {quantum_entanglement(3)}\\\")\\n\"",
    "ripple adder classic": "\"# https://github.com/rupansh/QuantumComputing/blob/master/rippleadd.py\\n# https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder\\n# https://en.wikipedia.org/wiki/Controlled_NOT_gate\\n\\nfrom qiskit import Aer, QuantumCircuit, execute\\nfrom qiskit.providers import BaseBackend\\n\\n\\ndef store_two_classics(val1: int, val2: int) -> tuple[QuantumCircuit, str, str]:\\n    \\\"\\\"\\\"\\n    Generates a Quantum Circuit which stores two classical integers\\n    Returns the circuit and binary representation of the integers\\n    \\\"\\\"\\\"\\n    x, y = bin(val1)[2:], bin(val2)[2:]  # Remove leading '0b'\\n\\n    # Ensure that both strings are of the same length\\n    if len(x) > len(y):\\n        y = y.zfill(len(x))\\n    else:\\n        x = x.zfill(len(y))\\n\\n    # We need (3 * number of bits in the larger number)+1 qBits\\n    # The second parameter is the number of classical registers, to measure the result\\n    circuit = QuantumCircuit((len(x) * 3) + 1, len(x) + 1)\\n\\n    # We are essentially \\\"not-ing\\\" the bits that are 1\\n    # Reversed because its easier to perform ops on more significant bits\\n    for i in range(len(x)):\\n        if x[::-1][i] == \\\"1\\\":\\n            circuit.x(i)\\n    for j in range(len(y)):\\n        if y[::-1][j] == \\\"1\\\":\\n            circuit.x(len(x) + j)\\n\\n    return circuit, x, y\\n\\n\\ndef full_adder(\\n    circuit: QuantumCircuit,\\n    input1_loc: int,\\n    input2_loc: int,\\n    carry_in: int,\\n    carry_out: int,\\n):\\n    \\\"\\\"\\\"\\n    Quantum Equivalent of a Full Adder Circuit\\n    CX/CCX is like 2-way/3-way XOR\\n    \\\"\\\"\\\"\\n    circuit.ccx(input1_loc, input2_loc, carry_out)\\n    circuit.cx(input1_loc, input2_loc)\\n    circuit.ccx(input2_loc, carry_in, carry_out)\\n    circuit.cx(input2_loc, carry_in)\\n    circuit.cx(input1_loc, input2_loc)\\n\\n\\n# The default value for **backend** is the result of a function call which is not\\n# normally recommended and causes flake8-bugbear to raise a B008 error. However,\\n# in this case, this is accptable because `Aer.get_backend()` is called when the\\n# function is defined and that same backend is then reused for all function calls.\\n\\n\\ndef ripple_adder(\\n    val1: int,\\n    val2: int,\\n    backend: BaseBackend = Aer.get_backend(\\\"qasm_simulator\\\"),  # noqa: B008\\n) -> int:\\n    \\\"\\\"\\\"\\n    Quantum Equivalent of a Ripple Adder Circuit\\n    Uses qasm_simulator backend by default\\n\\n    Currently only adds 'emulated' Classical Bits\\n    but nothing prevents us from doing this with hadamard'd bits :)\\n\\n    Only supports adding positive integers\\n\\n    >>> ripple_adder(3, 4)\\n    7\\n    >>> ripple_adder(10, 4)\\n    14\\n    >>> ripple_adder(-1, 10)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Both Integers must be positive!\\n    \\\"\\\"\\\"\\n\\n    if val1 < 0 or val2 < 0:\\n        raise ValueError(\\\"Both Integers must be positive!\\\")\\n\\n    # Store the Integers\\n    circuit, x, y = store_two_classics(val1, val2)\\n\\n    \\\"\\\"\\\"\\n    We are essentially using each bit of x & y respectively as full_adder's input\\n    the carry_input is used from the previous circuit (for circuit num > 1)\\n\\n    the carry_out is just below carry_input because\\n    it will be essentially the carry_input for the next full_adder\\n    \\\"\\\"\\\"\\n    for i in range(len(x)):\\n        full_adder(circuit, i, len(x) + i, len(x) + len(y) + i, len(x) + len(y) + i + 1)\\n        circuit.barrier()  # Optional, just for aesthetics\\n\\n    # Measure the resultant qBits\\n    for i in range(len(x) + 1):\\n        circuit.measure([(len(x) * 2) + i], [i])\\n\\n    res = execute(circuit, backend, shots=1).result()\\n\\n    # The result is in binary. Convert it back to int\\n    return int(list(res.get_counts())[0], 2)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "single qubit measure": "\"#!/usr/bin/env python3\\n\\\"\\\"\\\"\\nBuild a simple bare-minimum quantum circuit that starts with a single\\nqubit (by default, in state 0), runs the experiment 1000 times, and\\nfinally prints the total count of the states finally observed.\\nQiskit Docs: https://qiskit.org/documentation/getting_started.html\\n\\\"\\\"\\\"\\n\\nimport qiskit as q\\n\\n\\ndef single_qubit_measure(qubits: int, classical_bits: int) -> q.result.counts.Counts:\\n    \\\"\\\"\\\"\\n    >>> single_qubit_measure(1, 1)\\n    {'0': 1000}\\n    \\\"\\\"\\\"\\n    # Use Aer's qasm_simulator\\n    simulator = q.Aer.get_backend(\\\"qasm_simulator\\\")\\n\\n    # Create a Quantum Circuit acting on the q register\\n    circuit = q.QuantumCircuit(qubits, classical_bits)\\n\\n    # Map the quantum measurement to the classical bits\\n    circuit.measure([0], [0])\\n\\n    # Execute the circuit on the qasm simulator\\n    job = q.execute(circuit, simulator, shots=1000)\\n\\n    # Return the histogram data of the results of the experiment.\\n    return job.result().get_counts(circuit)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(f\\\"Total count for various states are: {single_qubit_measure(1, 1)}\\\")\\n\"",
    "first come first served": "\"# Implementation of First Come First Served scheduling algorithm\\n# In this Algorithm we just care about the order that the processes arrived\\n# without carring about their duration time\\n# https://en.wikipedia.org/wiki/Scheduling_(computing)#First_come,_first_served\\nfrom __future__ import annotations\\n\\n\\ndef calculate_waiting_times(duration_times: list[int]) -> list[int]:\\n    \\\"\\\"\\\"\\n    This function calculates the waiting time of some processes that have a\\n    specified duration time.\\n        Return: The waiting time for each process.\\n    >>> calculate_waiting_times([5, 10, 15])\\n    [0, 5, 15]\\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\\n    [0, 1, 3, 6, 10]\\n    >>> calculate_waiting_times([10, 3])\\n    [0, 10]\\n    \\\"\\\"\\\"\\n    waiting_times = [0] * len(duration_times)\\n    for i in range(1, len(duration_times)):\\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\\n    return waiting_times\\n\\n\\ndef calculate_turnaround_times(\\n    duration_times: list[int], waiting_times: list[int]\\n) -> list[int]:\\n    \\\"\\\"\\\"\\n    This function calculates the turnaround time of some processes.\\n        Return: The time difference between the completion time and the\\n                arrival time.\\n                Practically waiting_time + duration_time\\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\\n    [5, 15, 30]\\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\\n    [1, 3, 6, 10, 15]\\n    >>> calculate_turnaround_times([10, 3], [0, 10])\\n    [10, 13]\\n    \\\"\\\"\\\"\\n    return [\\n        duration_time + waiting_times[i]\\n        for i, duration_time in enumerate(duration_times)\\n    ]\\n\\n\\ndef calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\\n    \\\"\\\"\\\"\\n    This function calculates the average of the turnaround times\\n        Return: The average of the turnaround times.\\n    >>> calculate_average_turnaround_time([0, 5, 16])\\n    7.0\\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\\n    6.5\\n    >>> calculate_average_turnaround_time([10, 24])\\n    17.0\\n    \\\"\\\"\\\"\\n    return sum(turnaround_times) / len(turnaround_times)\\n\\n\\ndef calculate_average_waiting_time(waiting_times: list[int]) -> float:\\n    \\\"\\\"\\\"\\n    This function calculates the average of the waiting times\\n        Return: The average of the waiting times.\\n    >>> calculate_average_waiting_time([0, 5, 16])\\n    7.0\\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\\n    6.5\\n    >>> calculate_average_waiting_time([10, 24])\\n    17.0\\n    \\\"\\\"\\\"\\n    return sum(waiting_times) / len(waiting_times)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # process id's\\n    processes = [1, 2, 3]\\n\\n    # ensure that we actually have processes\\n    if len(processes) == 0:\\n        print(\\\"Zero amount of processes\\\")\\n        exit()\\n\\n    # duration time of all processes\\n    duration_times = [19, 8, 9]\\n\\n    # ensure we can match each id to a duration time\\n    if len(duration_times) != len(processes):\\n        print(\\\"Unable to match all id's with their duration time\\\")\\n        exit()\\n\\n    # get the waiting times and the turnaround times\\n    waiting_times = calculate_waiting_times(duration_times)\\n    turnaround_times = calculate_turnaround_times(duration_times, waiting_times)\\n\\n    # get the average times\\n    average_waiting_time = calculate_average_waiting_time(waiting_times)\\n    average_turnaround_time = calculate_average_turnaround_time(turnaround_times)\\n\\n    # print all the results\\n    print(\\\"Process ID\\\\tDuration Time\\\\tWaiting Time\\\\tTurnaround Time\\\")\\n    for i, process in enumerate(processes):\\n        print(\\n            f\\\"{process}\\\\t\\\\t{duration_times[i]}\\\\t\\\\t{waiting_times[i]}\\\\t\\\\t\\\"\\n            f\\\"{turnaround_times[i]}\\\"\\n        )\\n    print(f\\\"Average waiting time = {average_waiting_time}\\\")\\n    print(f\\\"Average turn around time = {average_turnaround_time}\\\")\\n\"",
    "round robin": "\"\\\"\\\"\\\"\\r\\nRound Robin is a scheduling algorithm.\\r\\nIn Round Robin each process is assigned a fixed time slot in a cyclic way.\\r\\nhttps://en.wikipedia.org/wiki/Round-robin_scheduling\\r\\n\\\"\\\"\\\"\\r\\nfrom __future__ import annotations\\r\\n\\r\\nfrom statistics import mean\\r\\n\\r\\n\\r\\ndef calculate_waiting_times(burst_times: list[int]) -> list[int]:\\r\\n    \\\"\\\"\\\"\\r\\n    Calculate the waiting times of a list of processes that have a specified duration.\\r\\n\\r\\n    Return: The waiting time for each process.\\r\\n    >>> calculate_waiting_times([10, 5, 8])\\r\\n    [13, 10, 13]\\r\\n    >>> calculate_waiting_times([4, 6, 3, 1])\\r\\n    [5, 8, 9, 6]\\r\\n    >>> calculate_waiting_times([12, 2, 10])\\r\\n    [12, 2, 12]\\r\\n    \\\"\\\"\\\"\\r\\n    quantum = 2\\r\\n    rem_burst_times = list(burst_times)\\r\\n    waiting_times = [0] * len(burst_times)\\r\\n    t = 0\\r\\n    while True:\\r\\n        done = True\\r\\n        for i, burst_time in enumerate(burst_times):\\r\\n            if rem_burst_times[i] > 0:\\r\\n                done = False\\r\\n                if rem_burst_times[i] > quantum:\\r\\n                    t += quantum\\r\\n                    rem_burst_times[i] -= quantum\\r\\n                else:\\r\\n                    t += rem_burst_times[i]\\r\\n                    waiting_times[i] = t - burst_time\\r\\n                    rem_burst_times[i] = 0\\r\\n        if done is True:\\r\\n            return waiting_times\\r\\n\\r\\n\\r\\ndef calculate_turn_around_times(\\r\\n    burst_times: list[int], waiting_times: list[int]\\r\\n) -> list[int]:\\r\\n    \\\"\\\"\\\"\\r\\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\\r\\n    [1, 3, 6]\\r\\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\\r\\n    [20, 9, 18]\\r\\n    \\\"\\\"\\\"\\r\\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    burst_times = [3, 5, 7]\\r\\n    waiting_times = calculate_waiting_times(burst_times)\\r\\n    turn_around_times = calculate_turn_around_times(burst_times, waiting_times)\\r\\n    print(\\\"Process ID \\\\tBurst Time \\\\tWaiting Time \\\\tTurnaround Time\\\")\\r\\n    for i, burst_time in enumerate(burst_times):\\r\\n        print(\\r\\n            f\\\"  {i + 1}\\\\t\\\\t  {burst_time}\\\\t\\\\t  {waiting_times[i]}\\\\t\\\\t  \\\"\\r\\n            f\\\"{turn_around_times[i]}\\\"\\r\\n        )\\r\\n    print(f\\\"\\\\nAverage waiting time = {mean(waiting_times):.5f}\\\")\\r\\n    print(f\\\"Average turn around time = {mean(turn_around_times):.5f}\\\")\\r\\n\"",
    "shortest job first": "\"\\\"\\\"\\\"\\nShortest job remaining first\\nPlease note arrival time and burst\\nPlease use spaces to separate times entered.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport pandas as pd\\n\\n\\ndef calculate_waitingtime(\\n    arrival_time: list[int], burst_time: list[int], no_of_processes: int\\n) -> list[int]:\\n    \\\"\\\"\\\"\\n    Calculate the waiting time of each processes\\n    Return: List of waiting times.\\n    >>> calculate_waitingtime([1,2,3,4],[3,3,5,1],4)\\n    [0, 3, 5, 0]\\n    >>> calculate_waitingtime([1,2,3],[2,5,1],3)\\n    [0, 2, 0]\\n    >>> calculate_waitingtime([2,3],[5,1],2)\\n    [1, 0]\\n    \\\"\\\"\\\"\\n    remaining_time = [0] * no_of_processes\\n    waiting_time = [0] * no_of_processes\\n    # Copy the burst time into remaining_time[]\\n    for i in range(no_of_processes):\\n        remaining_time[i] = burst_time[i]\\n\\n    complete = 0\\n    increment_time = 0\\n    minm = 999999999\\n    short = 0\\n    check = False\\n\\n    # Process until all processes are completed\\n    while complete != no_of_processes:\\n        for j in range(no_of_processes):\\n            if arrival_time[j] <= increment_time:\\n                if remaining_time[j] > 0:\\n                    if remaining_time[j] < minm:\\n                        minm = remaining_time[j]\\n                        short = j\\n                        check = True\\n\\n        if not check:\\n            increment_time += 1\\n            continue\\n        remaining_time[short] -= 1\\n\\n        minm = remaining_time[short]\\n        if minm == 0:\\n            minm = 999999999\\n\\n        if remaining_time[short] == 0:\\n            complete += 1\\n            check = False\\n\\n            # Find finish time of current process\\n            finish_time = increment_time + 1\\n\\n            # Calculate waiting time\\n            finar = finish_time - arrival_time[short]\\n            waiting_time[short] = finar - burst_time[short]\\n\\n            if waiting_time[short] < 0:\\n                waiting_time[short] = 0\\n\\n        # Increment time\\n        increment_time += 1\\n    return waiting_time\\n\\n\\ndef calculate_turnaroundtime(\\n    burst_time: list[int], no_of_processes: int, waiting_time: list[int]\\n) -> list[int]:\\n    \\\"\\\"\\\"\\n    Calculate the turn around time of each Processes\\n    Return: list of turn around times.\\n    >>> calculate_turnaroundtime([3,3,5,1], 4, [0,3,5,0])\\n    [3, 6, 10, 1]\\n    >>> calculate_turnaroundtime([3,3], 2, [0,3])\\n    [3, 6]\\n    >>> calculate_turnaroundtime([8,10,1], 3, [1,0,3])\\n    [9, 10, 4]\\n    \\\"\\\"\\\"\\n    turn_around_time = [0] * no_of_processes\\n    for i in range(no_of_processes):\\n        turn_around_time[i] = burst_time[i] + waiting_time[i]\\n    return turn_around_time\\n\\n\\ndef calculate_average_times(\\n    waiting_time: list[int], turn_around_time: list[int], no_of_processes: int\\n) -> None:\\n    \\\"\\\"\\\"\\n    This function calculates the average of the waiting & turnaround times\\n    Prints: Average Waiting time & Average Turn Around Time\\n    >>> calculate_average_times([0,3,5,0],[3,6,10,1],4)\\n    Average waiting time = 2.00000\\n    Average turn around time = 5.0\\n    >>> calculate_average_times([2,3],[3,6],2)\\n    Average waiting time = 2.50000\\n    Average turn around time = 4.5\\n    >>> calculate_average_times([10,4,3],[2,7,6],3)\\n    Average waiting time = 5.66667\\n    Average turn around time = 5.0\\n    \\\"\\\"\\\"\\n    total_waiting_time = 0\\n    total_turn_around_time = 0\\n    for i in range(no_of_processes):\\n        total_waiting_time = total_waiting_time + waiting_time[i]\\n        total_turn_around_time = total_turn_around_time + turn_around_time[i]\\n    print(\\\"Average waiting time = %.5f\\\" % (total_waiting_time / no_of_processes))\\n    print(\\\"Average turn around time =\\\", total_turn_around_time / no_of_processes)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"Enter how many process you want to analyze\\\")\\n    no_of_processes = int(input())\\n    burst_time = [0] * no_of_processes\\n    arrival_time = [0] * no_of_processes\\n    processes = list(range(1, no_of_processes + 1))\\n\\n    for i in range(no_of_processes):\\n        print(\\\"Enter the arrival time and burst time for process:--\\\" + str(i + 1))\\n        arrival_time[i], burst_time[i] = map(int, input().split())\\n\\n    waiting_time = calculate_waitingtime(arrival_time, burst_time, no_of_processes)\\n\\n    bt = burst_time\\n    n = no_of_processes\\n    wt = waiting_time\\n    turn_around_time = calculate_turnaroundtime(bt, n, wt)\\n\\n    calculate_average_times(waiting_time, turn_around_time, no_of_processes)\\n\\n    fcfs = pd.DataFrame(\\n        list(zip(processes, burst_time, arrival_time, waiting_time, turn_around_time)),\\n        columns=[\\n            \\\"Process\\\",\\n            \\\"BurstTime\\\",\\n            \\\"ArrivalTime\\\",\\n            \\\"WaitingTime\\\",\\n            \\\"TurnAroundTime\\\",\\n        ],\\n    )\\n\\n    # Printing the dataFrame\\n    pd.set_option(\\\"display.max_rows\\\", fcfs.shape[0] + 1)\\n    print(fcfs)\\n\"",
    "binary search": "\"#!/usr/bin/env python3\\n\\n\\\"\\\"\\\"\\nThis is pure Python implementation of binary search algorithms\\n\\nFor doctests run following command:\\npython3 -m doctest -v binary_search.py\\n\\nFor manual testing run:\\npython3 binary_search.py\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport bisect\\n\\n\\ndef bisect_left(\\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\\n) -> int:\\n    \\\"\\\"\\\"\\n    Locates the first element in a sorted array that is larger or equal to a given\\n    value.\\n\\n    It has the same interface as\\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\\n\\n    :param sorted_collection: some ascending sorted collection with comparable items\\n    :param item: item to bisect\\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\\n        values in sorted_collection[i:hi] are >= item.\\n\\n    Examples:\\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\\n    0\\n\\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\\n    2\\n\\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\\n    5\\n\\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\\n    3\\n\\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\\n    2\\n    \\\"\\\"\\\"\\n    if hi < 0:\\n        hi = len(sorted_collection)\\n\\n    while lo < hi:\\n        mid = lo + (hi - lo) // 2\\n        if sorted_collection[mid] < item:\\n            lo = mid + 1\\n        else:\\n            hi = mid\\n\\n    return lo\\n\\n\\ndef bisect_right(\\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\\n) -> int:\\n    \\\"\\\"\\\"\\n    Locates the first element in a sorted array that is larger than a given value.\\n\\n    It has the same interface as\\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\\n\\n    :param sorted_collection: some ascending sorted collection with comparable items\\n    :param item: item to bisect\\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\\n        all values in sorted_collection[i:hi] are > item.\\n\\n    Examples:\\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\\n    1\\n\\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\\n    5\\n\\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\\n    2\\n\\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\\n    3\\n\\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\\n    2\\n    \\\"\\\"\\\"\\n    if hi < 0:\\n        hi = len(sorted_collection)\\n\\n    while lo < hi:\\n        mid = lo + (hi - lo) // 2\\n        if sorted_collection[mid] <= item:\\n            lo = mid + 1\\n        else:\\n            hi = mid\\n\\n    return lo\\n\\n\\ndef insort_left(\\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\\n) -> None:\\n    \\\"\\\"\\\"\\n    Inserts a given value into a sorted array before other values with the same value.\\n\\n    It has the same interface as\\n    https://docs.python.org/3/library/bisect.html#bisect.insort_left .\\n\\n    :param sorted_collection: some ascending sorted collection with comparable items\\n    :param item: item to insert\\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\\n\\n    Examples:\\n    >>> sorted_collection = [0, 5, 7, 10, 15]\\n    >>> insort_left(sorted_collection, 6)\\n    >>> sorted_collection\\n    [0, 5, 6, 7, 10, 15]\\n\\n    >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]\\n    >>> item = (5, 5)\\n    >>> insort_left(sorted_collection, item)\\n    >>> sorted_collection\\n    [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]\\n    >>> item is sorted_collection[1]\\n    True\\n    >>> item is sorted_collection[2]\\n    False\\n\\n    >>> sorted_collection = [0, 5, 7, 10, 15]\\n    >>> insort_left(sorted_collection, 20)\\n    >>> sorted_collection\\n    [0, 5, 7, 10, 15, 20]\\n\\n    >>> sorted_collection = [0, 5, 7, 10, 15]\\n    >>> insort_left(sorted_collection, 15, 1, 3)\\n    >>> sorted_collection\\n    [0, 5, 7, 15, 10, 15]\\n    \\\"\\\"\\\"\\n    sorted_collection.insert(bisect_left(sorted_collection, item, lo, hi), item)\\n\\n\\ndef insort_right(\\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\\n) -> None:\\n    \\\"\\\"\\\"\\n    Inserts a given value into a sorted array after other values with the same value.\\n\\n    It has the same interface as\\n    https://docs.python.org/3/library/bisect.html#bisect.insort_right .\\n\\n    :param sorted_collection: some ascending sorted collection with comparable items\\n    :param item: item to insert\\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\\n\\n    Examples:\\n    >>> sorted_collection = [0, 5, 7, 10, 15]\\n    >>> insort_right(sorted_collection, 6)\\n    >>> sorted_collection\\n    [0, 5, 6, 7, 10, 15]\\n\\n    >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]\\n    >>> item = (5, 5)\\n    >>> insort_right(sorted_collection, item)\\n    >>> sorted_collection\\n    [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]\\n    >>> item is sorted_collection[1]\\n    False\\n    >>> item is sorted_collection[2]\\n    True\\n\\n    >>> sorted_collection = [0, 5, 7, 10, 15]\\n    >>> insort_right(sorted_collection, 20)\\n    >>> sorted_collection\\n    [0, 5, 7, 10, 15, 20]\\n\\n    >>> sorted_collection = [0, 5, 7, 10, 15]\\n    >>> insort_right(sorted_collection, 15, 1, 3)\\n    >>> sorted_collection\\n    [0, 5, 7, 15, 10, 15]\\n    \\\"\\\"\\\"\\n    sorted_collection.insert(bisect_right(sorted_collection, item, lo, hi), item)\\n\\n\\ndef binary_search(sorted_collection: list[int], item: int) -> int | None:\\n    \\\"\\\"\\\"Pure implementation of binary search algorithm in Python\\n\\n    Be careful collection must be ascending sorted, otherwise result will be\\n    unpredictable\\n\\n    :param sorted_collection: some ascending sorted collection with comparable items\\n    :param item: item value to search\\n    :return: index of found item or None if item is not found\\n\\n    Examples:\\n    >>> binary_search([0, 5, 7, 10, 15], 0)\\n    0\\n\\n    >>> binary_search([0, 5, 7, 10, 15], 15)\\n    4\\n\\n    >>> binary_search([0, 5, 7, 10, 15], 5)\\n    1\\n\\n    >>> binary_search([0, 5, 7, 10, 15], 6)\\n\\n    \\\"\\\"\\\"\\n    left = 0\\n    right = len(sorted_collection) - 1\\n\\n    while left <= right:\\n        midpoint = left + (right - left) // 2\\n        current_item = sorted_collection[midpoint]\\n        if current_item == item:\\n            return midpoint\\n        elif item < current_item:\\n            right = midpoint - 1\\n        else:\\n            left = midpoint + 1\\n    return None\\n\\n\\ndef binary_search_std_lib(sorted_collection: list[int], item: int) -> int | None:\\n    \\\"\\\"\\\"Pure implementation of binary search algorithm in Python using stdlib\\n\\n    Be careful collection must be ascending sorted, otherwise result will be\\n    unpredictable\\n\\n    :param sorted_collection: some ascending sorted collection with comparable items\\n    :param item: item value to search\\n    :return: index of found item or None if item is not found\\n\\n    Examples:\\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 0)\\n    0\\n\\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 15)\\n    4\\n\\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 5)\\n    1\\n\\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 6)\\n\\n    \\\"\\\"\\\"\\n    index = bisect.bisect_left(sorted_collection, item)\\n    if index != len(sorted_collection) and sorted_collection[index] == item:\\n        return index\\n    return None\\n\\n\\ndef binary_search_by_recursion(\\n    sorted_collection: list[int], item: int, left: int, right: int\\n) -> int | None:\\n\\n    \\\"\\\"\\\"Pure implementation of binary search algorithm in Python by recursion\\n\\n    Be careful collection must be ascending sorted, otherwise result will be\\n    unpredictable\\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\\n\\n    :param sorted_collection: some ascending sorted collection with comparable items\\n    :param item: item value to search\\n    :return: index of found item or None if item is not found\\n\\n    Examples:\\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\\n    0\\n\\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\\n    4\\n\\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\\n    1\\n\\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\\n\\n    \\\"\\\"\\\"\\n    if right < left:\\n        return None\\n\\n    midpoint = left + (right - left) // 2\\n\\n    if sorted_collection[midpoint] == item:\\n        return midpoint\\n    elif sorted_collection[midpoint] > item:\\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\\n    else:\\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by comma:\\\\n\\\").strip()\\n    collection = sorted(int(item) for item in user_input.split(\\\",\\\"))\\n    target = int(input(\\\"Enter a single number to be found in the list:\\\\n\\\"))\\n    result = binary_search(collection, target)\\n    if result is None:\\n        print(f\\\"{target} was not found in {collection}.\\\")\\n    else:\\n        print(f\\\"{target} was found at position {result} in {collection}.\\\")\\n\"",
    "binary tree traversal": "\"# flake8: noqa\\n\\n\\\"\\\"\\\"\\nThis is pure Python implementation of tree traversal algorithms\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport queue\\n\\n\\nclass TreeNode:\\n    def __init__(self, data):\\n        self.data = data\\n        self.right = None\\n        self.left = None\\n\\n\\ndef build_tree():\\n    print(\\\"\\\\n********Press N to stop entering at any point of time********\\\\n\\\")\\n    check = input(\\\"Enter the value of the root node: \\\").strip().lower() or \\\"n\\\"\\n    if check == \\\"n\\\":\\n        return None\\n    q: queue.Queue = queue.Queue()\\n    tree_node = TreeNode(int(check))\\n    q.put(tree_node)\\n    while not q.empty():\\n        node_found = q.get()\\n        msg = \\\"Enter the left node of %s: \\\" % node_found.data\\n        check = input(msg).strip().lower() or \\\"n\\\"\\n        if check == \\\"n\\\":\\n            return tree_node\\n        left_node = TreeNode(int(check))\\n        node_found.left = left_node\\n        q.put(left_node)\\n        msg = \\\"Enter the right node of %s: \\\" % node_found.data\\n        check = input(msg).strip().lower() or \\\"n\\\"\\n        if check == \\\"n\\\":\\n            return tree_node\\n        right_node = TreeNode(int(check))\\n        node_found.right = right_node\\n        q.put(right_node)\\n\\n\\ndef pre_order(node: TreeNode) -> None:\\n    \\\"\\\"\\\"\\n    >>> root = TreeNode(1)\\n    >>> tree_node2 = TreeNode(2)\\n    >>> tree_node3 = TreeNode(3)\\n    >>> tree_node4 = TreeNode(4)\\n    >>> tree_node5 = TreeNode(5)\\n    >>> tree_node6 = TreeNode(6)\\n    >>> tree_node7 = TreeNode(7)\\n    >>> root.left, root.right = tree_node2, tree_node3\\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\\n    >>> pre_order(root)\\n    1,2,4,5,3,6,7,\\n    \\\"\\\"\\\"\\n    if not isinstance(node, TreeNode) or not node:\\n        return\\n    print(node.data, end=\\\",\\\")\\n    pre_order(node.left)\\n    pre_order(node.right)\\n\\n\\ndef in_order(node: TreeNode) -> None:\\n    \\\"\\\"\\\"\\n    >>> root = TreeNode(1)\\n    >>> tree_node2 = TreeNode(2)\\n    >>> tree_node3 = TreeNode(3)\\n    >>> tree_node4 = TreeNode(4)\\n    >>> tree_node5 = TreeNode(5)\\n    >>> tree_node6 = TreeNode(6)\\n    >>> tree_node7 = TreeNode(7)\\n    >>> root.left, root.right = tree_node2, tree_node3\\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\\n    >>> in_order(root)\\n    4,2,5,1,6,3,7,\\n    \\\"\\\"\\\"\\n    if not isinstance(node, TreeNode) or not node:\\n        return\\n    in_order(node.left)\\n    print(node.data, end=\\\",\\\")\\n    in_order(node.right)\\n\\n\\ndef post_order(node: TreeNode) -> None:\\n    \\\"\\\"\\\"\\n    >>> root = TreeNode(1)\\n    >>> tree_node2 = TreeNode(2)\\n    >>> tree_node3 = TreeNode(3)\\n    >>> tree_node4 = TreeNode(4)\\n    >>> tree_node5 = TreeNode(5)\\n    >>> tree_node6 = TreeNode(6)\\n    >>> tree_node7 = TreeNode(7)\\n    >>> root.left, root.right = tree_node2, tree_node3\\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\\n    >>> post_order(root)\\n    4,5,2,6,7,3,1,\\n    \\\"\\\"\\\"\\n    if not isinstance(node, TreeNode) or not node:\\n        return\\n    post_order(node.left)\\n    post_order(node.right)\\n    print(node.data, end=\\\",\\\")\\n\\n\\ndef level_order(node: TreeNode) -> None:\\n    \\\"\\\"\\\"\\n    >>> root = TreeNode(1)\\n    >>> tree_node2 = TreeNode(2)\\n    >>> tree_node3 = TreeNode(3)\\n    >>> tree_node4 = TreeNode(4)\\n    >>> tree_node5 = TreeNode(5)\\n    >>> tree_node6 = TreeNode(6)\\n    >>> tree_node7 = TreeNode(7)\\n    >>> root.left, root.right = tree_node2, tree_node3\\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\\n    >>> level_order(root)\\n    1,2,3,4,5,6,7,\\n    \\\"\\\"\\\"\\n    if not isinstance(node, TreeNode) or not node:\\n        return\\n    q: queue.Queue = queue.Queue()\\n    q.put(node)\\n    while not q.empty():\\n        node_dequeued = q.get()\\n        print(node_dequeued.data, end=\\\",\\\")\\n        if node_dequeued.left:\\n            q.put(node_dequeued.left)\\n        if node_dequeued.right:\\n            q.put(node_dequeued.right)\\n\\n\\ndef level_order_actual(node: TreeNode) -> None:\\n    \\\"\\\"\\\"\\n    >>> root = TreeNode(1)\\n    >>> tree_node2 = TreeNode(2)\\n    >>> tree_node3 = TreeNode(3)\\n    >>> tree_node4 = TreeNode(4)\\n    >>> tree_node5 = TreeNode(5)\\n    >>> tree_node6 = TreeNode(6)\\n    >>> tree_node7 = TreeNode(7)\\n    >>> root.left, root.right = tree_node2, tree_node3\\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\\n    >>> level_order_actual(root)\\n    1,\\n    2,3,\\n    4,5,6,7,\\n    \\\"\\\"\\\"\\n    if not isinstance(node, TreeNode) or not node:\\n        return\\n    q: queue.Queue = queue.Queue()\\n    q.put(node)\\n    while not q.empty():\\n        list = []\\n        while not q.empty():\\n            node_dequeued = q.get()\\n            print(node_dequeued.data, end=\\\",\\\")\\n            if node_dequeued.left:\\n                list.append(node_dequeued.left)\\n            if node_dequeued.right:\\n                list.append(node_dequeued.right)\\n        print()\\n        for node in list:\\n            q.put(node)\\n\\n\\n# iteration version\\ndef pre_order_iter(node: TreeNode) -> None:\\n    \\\"\\\"\\\"\\n    >>> root = TreeNode(1)\\n    >>> tree_node2 = TreeNode(2)\\n    >>> tree_node3 = TreeNode(3)\\n    >>> tree_node4 = TreeNode(4)\\n    >>> tree_node5 = TreeNode(5)\\n    >>> tree_node6 = TreeNode(6)\\n    >>> tree_node7 = TreeNode(7)\\n    >>> root.left, root.right = tree_node2, tree_node3\\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\\n    >>> pre_order_iter(root)\\n    1,2,4,5,3,6,7,\\n    \\\"\\\"\\\"\\n    if not isinstance(node, TreeNode) or not node:\\n        return\\n    stack: list[TreeNode] = []\\n    n = node\\n    while n or stack:\\n        while n:  # start from root node, find its left child\\n            print(n.data, end=\\\",\\\")\\n            stack.append(n)\\n            n = n.left\\n        # end of while means current node doesn't have left child\\n        n = stack.pop()\\n        # start to traverse its right child\\n        n = n.right\\n\\n\\ndef in_order_iter(node: TreeNode) -> None:\\n    \\\"\\\"\\\"\\n    >>> root = TreeNode(1)\\n    >>> tree_node2 = TreeNode(2)\\n    >>> tree_node3 = TreeNode(3)\\n    >>> tree_node4 = TreeNode(4)\\n    >>> tree_node5 = TreeNode(5)\\n    >>> tree_node6 = TreeNode(6)\\n    >>> tree_node7 = TreeNode(7)\\n    >>> root.left, root.right = tree_node2, tree_node3\\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\\n    >>> in_order_iter(root)\\n    4,2,5,1,6,3,7,\\n    \\\"\\\"\\\"\\n    if not isinstance(node, TreeNode) or not node:\\n        return\\n    stack: list[TreeNode] = []\\n    n = node\\n    while n or stack:\\n        while n:\\n            stack.append(n)\\n            n = n.left\\n        n = stack.pop()\\n        print(n.data, end=\\\",\\\")\\n        n = n.right\\n\\n\\ndef post_order_iter(node: TreeNode) -> None:\\n    \\\"\\\"\\\"\\n    >>> root = TreeNode(1)\\n    >>> tree_node2 = TreeNode(2)\\n    >>> tree_node3 = TreeNode(3)\\n    >>> tree_node4 = TreeNode(4)\\n    >>> tree_node5 = TreeNode(5)\\n    >>> tree_node6 = TreeNode(6)\\n    >>> tree_node7 = TreeNode(7)\\n    >>> root.left, root.right = tree_node2, tree_node3\\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\\n    >>> post_order_iter(root)\\n    4,5,2,6,7,3,1,\\n    \\\"\\\"\\\"\\n    if not isinstance(node, TreeNode) or not node:\\n        return\\n    stack1, stack2 = [], []\\n    n = node\\n    stack1.append(n)\\n    while stack1:  # to find the reversed order of post order, store it in stack2\\n        n = stack1.pop()\\n        if n.left:\\n            stack1.append(n.left)\\n        if n.right:\\n            stack1.append(n.right)\\n        stack2.append(n)\\n    while stack2:  # pop up from stack2 will be the post order\\n        print(stack2.pop().data, end=\\\",\\\")\\n\\n\\ndef prompt(s: str = \\\"\\\", width=50, char=\\\"*\\\") -> str:\\n    if not s:\\n        return \\\"\\\\n\\\" + width * char\\n    left, extra = divmod(width - len(s) - 2, 2)\\n    return f\\\"{left * char} {s} {(left + extra) * char}\\\"\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    print(prompt(\\\"Binary Tree Traversals\\\"))\\n\\n    node = build_tree()\\n    print(prompt(\\\"Pre Order Traversal\\\"))\\n    pre_order(node)\\n    print(prompt() + \\\"\\\\n\\\")\\n\\n    print(prompt(\\\"In Order Traversal\\\"))\\n    in_order(node)\\n    print(prompt() + \\\"\\\\n\\\")\\n\\n    print(prompt(\\\"Post Order Traversal\\\"))\\n    post_order(node)\\n    print(prompt() + \\\"\\\\n\\\")\\n\\n    print(prompt(\\\"Level Order Traversal\\\"))\\n    level_order(node)\\n    print(prompt() + \\\"\\\\n\\\")\\n\\n    print(prompt(\\\"Actual Level Order Traversal\\\"))\\n    level_order_actual(node)\\n    print(\\\"*\\\" * 50 + \\\"\\\\n\\\")\\n\\n    print(prompt(\\\"Pre Order Traversal - Iteration Version\\\"))\\n    pre_order_iter(node)\\n    print(prompt() + \\\"\\\\n\\\")\\n\\n    print(prompt(\\\"In Order Traversal - Iteration Version\\\"))\\n    in_order_iter(node)\\n    print(prompt() + \\\"\\\\n\\\")\\n\\n    print(prompt(\\\"Post Order Traversal - Iteration Version\\\"))\\n    post_order_iter(node)\\n    print(prompt())\\n\"",
    "double linear search": "\"from __future__ import annotations\\r\\n\\r\\n\\r\\ndef double_linear_search(array: list[int], search_item: int) -> int:\\r\\n    \\\"\\\"\\\"\\r\\n    Iterate through the array from both sides to find the index of search_item.\\r\\n\\r\\n    :param array: the array to be searched\\r\\n    :param search_item: the item to be searched\\r\\n    :return the index of search_item, if search_item is in array, else -1\\r\\n\\r\\n    Examples:\\r\\n    >>> double_linear_search([1, 5, 5, 10], 1)\\r\\n    0\\r\\n    >>> double_linear_search([1, 5, 5, 10], 5)\\r\\n    1\\r\\n    >>> double_linear_search([1, 5, 5, 10], 100)\\r\\n    -1\\r\\n    >>> double_linear_search([1, 5, 5, 10], 10)\\r\\n    3\\r\\n    \\\"\\\"\\\"\\r\\n    # define the start and end index of the given array\\r\\n    start_ind, end_ind = 0, len(array) - 1\\r\\n    while start_ind <= end_ind:\\r\\n        if array[start_ind] == search_item:\\r\\n            return start_ind\\r\\n        elif array[end_ind] == search_item:\\r\\n            return end_ind\\r\\n        else:\\r\\n            start_ind += 1\\r\\n            end_ind -= 1\\r\\n    # returns -1 if search_item is not found in array\\r\\n    return -1\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    print(double_linear_search(list(range(100)), 40))\\r\\n\"",
    "double linear search recursion": "\"def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:\\n    \\\"\\\"\\\"\\n    Iterate through the array to find the index of key using recursion.\\n    :param list_data: the list to be searched\\n    :param key: the key to be searched\\n    :param left: the index of first element\\n    :param right: the index of last element\\n    :return: the index of key value if found, -1 otherwise.\\n\\n    >>> search(list(range(0, 11)), 5)\\n    5\\n    >>> search([1, 2, 4, 5, 3], 4)\\n    2\\n    >>> search([1, 2, 4, 5, 3], 6)\\n    -1\\n    >>> search([5], 5)\\n    0\\n    >>> search([], 1)\\n    -1\\n    \\\"\\\"\\\"\\n    right = right or len(list_data) - 1\\n    if left > right:\\n        return -1\\n    elif list_data[left] == key:\\n        return left\\n    elif list_data[right] == key:\\n        return right\\n    else:\\n        return search(list_data, key, left + 1, right - 1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "fibonacci search": "\"\\\"\\\"\\\"\\nThis is pure Python implementation of fibonacci search.\\n\\nResources used:\\nhttps://en.wikipedia.org/wiki/Fibonacci_search_technique\\n\\nFor doctests run following command:\\npython3 -m doctest -v fibonacci_search.py\\n\\nFor manual testing run:\\npython3 fibonacci_search.py\\n\\\"\\\"\\\"\\nfrom functools import lru_cache\\n\\n\\n@lru_cache\\ndef fibonacci(k: int) -> int:\\n    \\\"\\\"\\\"Finds fibonacci number in index k.\\n\\n    Parameters\\n    ----------\\n    k :\\n        Index of fibonacci.\\n\\n    Returns\\n    -------\\n    int\\n        Fibonacci number in position k.\\n\\n    >>> fibonacci(0)\\n    0\\n    >>> fibonacci(2)\\n    1\\n    >>> fibonacci(5)\\n    5\\n    >>> fibonacci(15)\\n    610\\n    >>> fibonacci('a')\\n    Traceback (most recent call last):\\n    TypeError: k must be an integer.\\n    >>> fibonacci(-5)\\n    Traceback (most recent call last):\\n    ValueError: k integer must be greater or equal to zero.\\n    \\\"\\\"\\\"\\n    if not isinstance(k, int):\\n        raise TypeError(\\\"k must be an integer.\\\")\\n    if k < 0:\\n        raise ValueError(\\\"k integer must be greater or equal to zero.\\\")\\n    if k == 0:\\n        return 0\\n    elif k == 1:\\n        return 1\\n    else:\\n        return fibonacci(k - 1) + fibonacci(k - 2)\\n\\n\\ndef fibonacci_search(arr: list, val: int) -> int:\\n    \\\"\\\"\\\"A pure Python implementation of a fibonacci search algorithm.\\n\\n    Parameters\\n    ----------\\n    arr\\n        List of sorted elements.\\n    val\\n        Element to search in list.\\n\\n    Returns\\n    -------\\n    int\\n        The index of the element in the array.\\n        -1 if the element is not found.\\n\\n    >>> fibonacci_search([4, 5, 6, 7], 4)\\n    0\\n    >>> fibonacci_search([4, 5, 6, 7], -10)\\n    -1\\n    >>> fibonacci_search([-18, 2], -18)\\n    0\\n    >>> fibonacci_search([5], 5)\\n    0\\n    >>> fibonacci_search(['a', 'c', 'd'], 'c')\\n    1\\n    >>> fibonacci_search(['a', 'c', 'd'], 'f')\\n    -1\\n    >>> fibonacci_search([], 1)\\n    -1\\n    >>> fibonacci_search([.1, .4 , 7], .4)\\n    1\\n    >>> fibonacci_search([], 9)\\n    -1\\n    >>> fibonacci_search(list(range(100)), 63)\\n    63\\n    >>> fibonacci_search(list(range(100)), 99)\\n    99\\n    >>> fibonacci_search(list(range(-100, 100, 3)), -97)\\n    1\\n    >>> fibonacci_search(list(range(-100, 100, 3)), 0)\\n    -1\\n    >>> fibonacci_search(list(range(-100, 100, 5)), 0)\\n    20\\n    >>> fibonacci_search(list(range(-100, 100, 5)), 95)\\n    39\\n    \\\"\\\"\\\"\\n    len_list = len(arr)\\n    # Find m such that F_m >= n where F_i is the i_th fibonacci number.\\n    i = 0\\n    while True:\\n        if fibonacci(i) >= len_list:\\n            fibb_k = i\\n            break\\n        i += 1\\n    offset = 0\\n    while fibb_k > 0:\\n        index_k = min(\\n            offset + fibonacci(fibb_k - 1), len_list - 1\\n        )  # Prevent out of range\\n        item_k_1 = arr[index_k]\\n        if item_k_1 == val:\\n            return index_k\\n        elif val < item_k_1:\\n            fibb_k -= 1\\n        elif val > item_k_1:\\n            offset += fibonacci(fibb_k - 1)\\n            fibb_k -= 2\\n    else:\\n        return -1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "hill climbing": "\"# https://en.wikipedia.org/wiki/Hill_climbing\\nimport math\\n\\n\\nclass SearchProblem:\\n    \\\"\\\"\\\"\\n    An interface to define search problems.\\n    The interface will be illustrated using the example of mathematical function.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, x: int, y: int, step_size: int, function_to_optimize):\\n        \\\"\\\"\\\"\\n        The constructor of the search problem.\\n\\n        x: the x coordinate of the current search state.\\n        y: the y coordinate of the current search state.\\n        step_size: size of the step to take when looking for neighbors.\\n        function_to_optimize: a function to optimize having the signature f(x, y).\\n        \\\"\\\"\\\"\\n        self.x = x\\n        self.y = y\\n        self.step_size = step_size\\n        self.function = function_to_optimize\\n\\n    def score(self) -> int:\\n        \\\"\\\"\\\"\\n        Returns the output of the function called with current x and y coordinates.\\n        >>> def test_function(x, y):\\n        ...     return x + y\\n        >>> SearchProblem(0, 0, 1, test_function).score()  # 0 + 0 = 0\\n        0\\n        >>> SearchProblem(5, 7, 1, test_function).score()  # 5 + 7 = 12\\n        12\\n        \\\"\\\"\\\"\\n        return self.function(self.x, self.y)\\n\\n    def get_neighbors(self):\\n        \\\"\\\"\\\"\\n        Returns a list of coordinates of neighbors adjacent to the current coordinates.\\n\\n        Neighbors:\\n        | 0 | 1 | 2 |\\n        | 3 | _ | 4 |\\n        | 5 | 6 | 7 |\\n        \\\"\\\"\\\"\\n        step_size = self.step_size\\n        return [\\n            SearchProblem(x, y, step_size, self.function)\\n            for x, y in (\\n                (self.x - step_size, self.y - step_size),\\n                (self.x - step_size, self.y),\\n                (self.x - step_size, self.y + step_size),\\n                (self.x, self.y - step_size),\\n                (self.x, self.y + step_size),\\n                (self.x + step_size, self.y - step_size),\\n                (self.x + step_size, self.y),\\n                (self.x + step_size, self.y + step_size),\\n            )\\n        ]\\n\\n    def __hash__(self):\\n        \\\"\\\"\\\"\\n        hash the string representation of the current search state.\\n        \\\"\\\"\\\"\\n        return hash(str(self))\\n\\n    def __eq__(self, obj):\\n        \\\"\\\"\\\"\\n        Check if the 2 objects are equal.\\n        \\\"\\\"\\\"\\n        if isinstance(obj, SearchProblem):\\n            return hash(str(self)) == hash(str(obj))\\n        return False\\n\\n    def __str__(self):\\n        \\\"\\\"\\\"\\n        string representation of the current search state.\\n        >>> str(SearchProblem(0, 0, 1, None))\\n        'x: 0 y: 0'\\n        >>> str(SearchProblem(2, 5, 1, None))\\n        'x: 2 y: 5'\\n        \\\"\\\"\\\"\\n        return f\\\"x: {self.x} y: {self.y}\\\"\\n\\n\\ndef hill_climbing(\\n    search_prob,\\n    find_max: bool = True,\\n    max_x: float = math.inf,\\n    min_x: float = -math.inf,\\n    max_y: float = math.inf,\\n    min_y: float = -math.inf,\\n    visualization: bool = False,\\n    max_iter: int = 10000,\\n) -> SearchProblem:\\n    \\\"\\\"\\\"\\n    Implementation of the hill climbling algorithm.\\n    We start with a given state, find all its neighbors,\\n    move towards the neighbor which provides the maximum (or minimum) change.\\n    We keep doing this until we are at a state where we do not have any\\n    neighbors which can improve the solution.\\n        Args:\\n            search_prob: The search state at the start.\\n            find_max: If True, the algorithm should find the maximum else the minimum.\\n            max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.\\n            visualization: If True, a matplotlib graph is displayed.\\n            max_iter: number of times to run the iteration.\\n        Returns a search state having the maximum (or minimum) score.\\n    \\\"\\\"\\\"\\n    current_state = search_prob\\n    scores = []  # list to store the current score at each iteration\\n    iterations = 0\\n    solution_found = False\\n    visited = set()\\n    while not solution_found and iterations < max_iter:\\n        visited.add(current_state)\\n        iterations += 1\\n        current_score = current_state.score()\\n        scores.append(current_score)\\n        neighbors = current_state.get_neighbors()\\n        max_change = -math.inf\\n        min_change = math.inf\\n        next_state = None  # to hold the next best neighbor\\n        for neighbor in neighbors:\\n            if neighbor in visited:\\n                continue  # do not want to visit the same state again\\n            if (\\n                neighbor.x > max_x\\n                or neighbor.x < min_x\\n                or neighbor.y > max_y\\n                or neighbor.y < min_y\\n            ):\\n                continue  # neighbor outside our bounds\\n            change = neighbor.score() - current_score\\n            if find_max:  # finding max\\n                # going to direction with greatest ascent\\n                if change > max_change and change > 0:\\n                    max_change = change\\n                    next_state = neighbor\\n            else:  # finding min\\n                # to direction with greatest descent\\n                if change < min_change and change < 0:\\n                    min_change = change\\n                    next_state = neighbor\\n        if next_state is not None:\\n            # we found at least one neighbor which improved the current state\\n            current_state = next_state\\n        else:\\n            # since we have no neighbor that improves the solution we stop the search\\n            solution_found = True\\n\\n    if visualization:\\n        from matplotlib import pyplot as plt\\n\\n        plt.plot(range(iterations), scores)\\n        plt.xlabel(\\\"Iterations\\\")\\n        plt.ylabel(\\\"Function values\\\")\\n        plt.show()\\n\\n    return current_state\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    def test_f1(x, y):\\n        return (x ** 2) + (y ** 2)\\n\\n    # starting the problem with initial coordinates (3, 4)\\n    prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)\\n    local_min = hill_climbing(prob, find_max=False)\\n    print(\\n        \\\"The minimum score for f(x, y) = x^2 + y^2 found via hill climbing: \\\"\\n        f\\\"{local_min.score()}\\\"\\n    )\\n\\n    # starting the problem with initial coordinates (12, 47)\\n    prob = SearchProblem(x=12, y=47, step_size=1, function_to_optimize=test_f1)\\n    local_min = hill_climbing(\\n        prob, find_max=False, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True\\n    )\\n    print(\\n        \\\"The minimum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 \\\"\\n        f\\\"and 50 > y > - 5 found via hill climbing: {local_min.score()}\\\"\\n    )\\n\\n    def test_f2(x, y):\\n        return (3 * x ** 2) - (6 * y)\\n\\n    prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)\\n    local_min = hill_climbing(prob, find_max=True)\\n    print(\\n        \\\"The maximum score for f(x, y) = x^2 + y^2 found via hill climbing: \\\"\\n        f\\\"{local_min.score()}\\\"\\n    )\\n\"",
    "interpolation search": "\"\\\"\\\"\\\"\\nThis is pure Python implementation of interpolation search algorithm\\n\\\"\\\"\\\"\\n\\n\\ndef interpolation_search(sorted_collection, item):\\n    \\\"\\\"\\\"Pure implementation of interpolation search algorithm in Python\\n    Be careful collection must be ascending sorted, otherwise result will be\\n    unpredictable\\n    :param sorted_collection: some ascending sorted collection with comparable items\\n    :param item: item value to search\\n    :return: index of found item or None if item is not found\\n    \\\"\\\"\\\"\\n    left = 0\\n    right = len(sorted_collection) - 1\\n\\n    while left <= right:\\n        # avoid divided by 0 during interpolation\\n        if sorted_collection[left] == sorted_collection[right]:\\n            if sorted_collection[left] == item:\\n                return left\\n            else:\\n                return None\\n\\n        point = left + ((item - sorted_collection[left]) * (right - left)) // (\\n            sorted_collection[right] - sorted_collection[left]\\n        )\\n\\n        # out of range check\\n        if point < 0 or point >= len(sorted_collection):\\n            return None\\n\\n        current_item = sorted_collection[point]\\n        if current_item == item:\\n            return point\\n        else:\\n            if point < left:\\n                right = left\\n                left = point\\n            elif point > right:\\n                left = right\\n                right = point\\n            else:\\n                if item < current_item:\\n                    right = point - 1\\n                else:\\n                    left = point + 1\\n    return None\\n\\n\\ndef interpolation_search_by_recursion(sorted_collection, item, left, right):\\n\\n    \\\"\\\"\\\"Pure implementation of interpolation search algorithm in Python by recursion\\n    Be careful collection must be ascending sorted, otherwise result will be\\n    unpredictable\\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\\n    :param sorted_collection: some ascending sorted collection with comparable items\\n    :param item: item value to search\\n    :return: index of found item or None if item is not found\\n    \\\"\\\"\\\"\\n\\n    # avoid divided by 0 during interpolation\\n    if sorted_collection[left] == sorted_collection[right]:\\n        if sorted_collection[left] == item:\\n            return left\\n        else:\\n            return None\\n\\n    point = left + ((item - sorted_collection[left]) * (right - left)) // (\\n        sorted_collection[right] - sorted_collection[left]\\n    )\\n\\n    # out of range check\\n    if point < 0 or point >= len(sorted_collection):\\n        return None\\n\\n    if sorted_collection[point] == item:\\n        return point\\n    elif point < left:\\n        return interpolation_search_by_recursion(sorted_collection, item, point, left)\\n    elif point > right:\\n        return interpolation_search_by_recursion(sorted_collection, item, right, left)\\n    else:\\n        if sorted_collection[point] > item:\\n            return interpolation_search_by_recursion(\\n                sorted_collection, item, left, point - 1\\n            )\\n        else:\\n            return interpolation_search_by_recursion(\\n                sorted_collection, item, point + 1, right\\n            )\\n\\n\\ndef __assert_sorted(collection):\\n    \\\"\\\"\\\"Check if collection is ascending sorted, if not - raises :py:class:`ValueError`\\n    :param collection: collection\\n    :return: True if collection is ascending sorted\\n    :raise: :py:class:`ValueError` if collection is not ascending sorted\\n    Examples:\\n    >>> __assert_sorted([0, 1, 2, 4])\\n    True\\n    >>> __assert_sorted([10, -1, 5])\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Collection must be ascending sorted\\n    \\\"\\\"\\\"\\n    if collection != sorted(collection):\\n        raise ValueError(\\\"Collection must be ascending sorted\\\")\\n    return True\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import sys\\n\\n    \\\"\\\"\\\"\\n        user_input = input('Enter numbers separated by comma:\\\\n').strip()\\n    collection = [int(item) for item in user_input.split(',')]\\n    try:\\n        __assert_sorted(collection)\\n    except ValueError:\\n        sys.exit('Sequence must be ascending sorted to apply interpolation search')\\n\\n    target_input = input('Enter a single number to be found in the list:\\\\n')\\n    target = int(target_input)\\n        \\\"\\\"\\\"\\n\\n    debug = 0\\n    if debug == 1:\\n        collection = [10, 30, 40, 45, 50, 66, 77, 93]\\n        try:\\n            __assert_sorted(collection)\\n        except ValueError:\\n            sys.exit(\\\"Sequence must be ascending sorted to apply interpolation search\\\")\\n        target = 67\\n\\n    result = interpolation_search(collection, target)\\n    if result is not None:\\n        print(f\\\"{target} found at positions: {result}\\\")\\n    else:\\n        print(\\\"Not found\\\")\\n\"",
    "jump search": "\"\\\"\\\"\\\"\\nPure Python implementation of the jump search algorithm.\\nThis algorithm iterates through a sorted collection with a step of n^(1/2),\\nuntil the element compared is bigger than the one searched.\\nIt will then perform a linear search until it matches the wanted number.\\nIf not found, it returns -1.\\n\\\"\\\"\\\"\\n\\nimport math\\n\\n\\ndef jump_search(arr: list, x: int) -> int:\\n    \\\"\\\"\\\"\\n    Pure Python implementation of the jump search algorithm.\\n    Examples:\\n    >>> jump_search([0, 1, 2, 3, 4, 5], 3)\\n    3\\n    >>> jump_search([-5, -2, -1], -1)\\n    2\\n    >>> jump_search([0, 5, 10, 20], 8)\\n    -1\\n    >>> jump_search([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 55)\\n    10\\n    \\\"\\\"\\\"\\n\\n    n = len(arr)\\n    step = int(math.floor(math.sqrt(n)))\\n    prev = 0\\n    while arr[min(step, n) - 1] < x:\\n        prev = step\\n        step += int(math.floor(math.sqrt(n)))\\n        if prev >= n:\\n            return -1\\n\\n    while arr[prev] < x:\\n        prev = prev + 1\\n        if prev == min(step, n):\\n            return -1\\n    if arr[prev] == x:\\n        return prev\\n    return -1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    arr = [int(item) for item in user_input.split(\\\",\\\")]\\n    x = int(input(\\\"Enter the number to be searched:\\\\n\\\"))\\n    res = jump_search(arr, x)\\n    if res == -1:\\n        print(\\\"Number not found!\\\")\\n    else:\\n        print(f\\\"Number {x} is at index {res}\\\")\\n\"",
    "linear search": "\"\\\"\\\"\\\"\\nThis is pure Python implementation of linear search algorithm\\n\\nFor doctests run following command:\\npython3 -m doctest -v linear_search.py\\n\\nFor manual testing run:\\npython3 linear_search.py\\n\\\"\\\"\\\"\\n\\n\\ndef linear_search(sequence: list, target: int) -> int:\\n    \\\"\\\"\\\"A pure Python implementation of a linear search algorithm\\n\\n    :param sequence: a collection with comparable items (as sorted items not required\\n        in Linear Search)\\n    :param target: item value to search\\n    :return: index of found item or None if item is not found\\n\\n    Examples:\\n    >>> linear_search([0, 5, 7, 10, 15], 0)\\n    0\\n    >>> linear_search([0, 5, 7, 10, 15], 15)\\n    4\\n    >>> linear_search([0, 5, 7, 10, 15], 5)\\n    1\\n    >>> linear_search([0, 5, 7, 10, 15], 6)\\n    -1\\n    \\\"\\\"\\\"\\n    for index, item in enumerate(sequence):\\n        if item == target:\\n            return index\\n    return -1\\n\\n\\ndef rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\\n    \\\"\\\"\\\"\\n    A pure Python implementation of a recursive linear search algorithm\\n\\n    :param sequence: a collection with comparable items (as sorted items not required\\n        in Linear Search)\\n    :param low: Lower bound of the array\\n    :param high: Higher bound of the array\\n    :param target: The element to be found\\n    :return: Index of the key or -1 if key not found\\n\\n    Examples:\\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\\n    0\\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\\n    4\\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\\n    1\\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\\n    -1\\n    \\\"\\\"\\\"\\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\\n        raise Exception(\\\"Invalid upper or lower bound!\\\")\\n    if high < low:\\n        return -1\\n    if sequence[low] == target:\\n        return low\\n    if sequence[high] == target:\\n        return high\\n    return rec_linear_search(sequence, low + 1, high - 1, target)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by comma:\\\\n\\\").strip()\\n    sequence = [int(item.strip()) for item in user_input.split(\\\",\\\")]\\n\\n    target = int(input(\\\"Enter a single number to be found in the list:\\\\n\\\").strip())\\n    result = linear_search(sequence, target)\\n    if result != -1:\\n        print(f\\\"linear_search({sequence}, {target}) = {result}\\\")\\n    else:\\n        print(f\\\"{target} was not found in {sequence}\\\")\\n\"",
    "quick select": "\"\\\"\\\"\\\"\\nA Python implementation of the quick select algorithm, which is efficient for\\ncalculating the value that would appear in the index of a list if it would be\\nsorted, even if it is not already sorted\\nhttps://en.wikipedia.org/wiki/Quickselect\\n\\\"\\\"\\\"\\nimport random\\n\\n\\ndef _partition(data: list, pivot) -> tuple:\\n    \\\"\\\"\\\"\\n    Three way partition the data into smaller, equal and greater lists,\\n    in relationship to the pivot\\n    :param data: The data to be sorted (a list)\\n    :param pivot: The value to partition the data on\\n    :return: Three list: smaller, equal and greater\\n    \\\"\\\"\\\"\\n    less, equal, greater = [], [], []\\n    for element in data:\\n        if element < pivot:\\n            less.append(element)\\n        elif element > pivot:\\n            greater.append(element)\\n        else:\\n            equal.append(element)\\n    return less, equal, greater\\n\\n\\ndef quick_select(items: list, index: int):\\n    \\\"\\\"\\\"\\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)\\n    54\\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)\\n    4\\n    >>> quick_select([5, 4, 3, 2], 2)\\n    4\\n    >>> quick_select([3, 5, 7, 10, 2, 12], 3)\\n    7\\n    \\\"\\\"\\\"\\n    # index = len(items) // 2 when trying to find the median\\n    #   (value of index when items is sorted)\\n\\n    # invalid input\\n    if index >= len(items) or index < 0:\\n        return None\\n\\n    pivot = items[random.randint(0, len(items) - 1)]\\n    count = 0\\n    smaller, equal, larger = _partition(items, pivot)\\n    count = len(equal)\\n    m = len(smaller)\\n\\n    # index is the pivot\\n    if m <= index < m + count:\\n        return pivot\\n    # must be in smaller\\n    elif m > index:\\n        return quick_select(smaller, index)\\n    # must be in larger\\n    else:\\n        return quick_select(larger, index - (m + count))\\n\"",
    "sentinel linear search": "\"\\\"\\\"\\\"\\nThis is pure Python implementation of sentinel linear search algorithm\\n\\nFor doctests run following command:\\npython -m doctest -v sentinel_linear_search.py\\nor\\npython3 -m doctest -v sentinel_linear_search.py\\n\\nFor manual testing run:\\npython sentinel_linear_search.py\\n\\\"\\\"\\\"\\n\\n\\ndef sentinel_linear_search(sequence, target):\\n    \\\"\\\"\\\"Pure implementation of sentinel linear search algorithm in Python\\n\\n    :param sequence: some sequence with comparable items\\n    :param target: item value to search\\n    :return: index of found item or None if item is not found\\n\\n    Examples:\\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 0)\\n    0\\n\\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 15)\\n    4\\n\\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 5)\\n    1\\n\\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 6)\\n\\n    \\\"\\\"\\\"\\n    sequence.append(target)\\n\\n    index = 0\\n    while sequence[index] != target:\\n        index += 1\\n\\n    sequence.pop()\\n\\n    if index == len(sequence):\\n        return None\\n\\n    return index\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by comma:\\\\n\\\").strip()\\n    sequence = [int(item) for item in user_input.split(\\\",\\\")]\\n\\n    target_input = input(\\\"Enter a single number to be found in the list:\\\\n\\\")\\n    target = int(target_input)\\n    result = sentinel_linear_search(sequence, target)\\n    if result is not None:\\n        print(f\\\"{target} found at positions: {result}\\\")\\n    else:\\n        print(\\\"Not found\\\")\\n\"",
    "simple binary search": "\"\\\"\\\"\\\"\\nPure Python implementation of a binary search algorithm.\\n\\nFor doctests run following command:\\npython3 -m doctest -v simple_binary_search.py\\n\\nFor manual testing run:\\npython3 simple_binary_search.py\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef binary_search(a_list: list[int], item: int) -> bool:\\n    \\\"\\\"\\\"\\n    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\\n    >>> print(binary_search(test_list, 3))\\n    False\\n    >>> print(binary_search(test_list, 13))\\n    True\\n    >>> print(binary_search([4, 4, 5, 6, 7], 4))\\n    True\\n    >>> print(binary_search([4, 4, 5, 6, 7], -10))\\n    False\\n    >>> print(binary_search([-18, 2], -18))\\n    True\\n    >>> print(binary_search([5], 5))\\n    True\\n    >>> print(binary_search(['a', 'c', 'd'], 'c'))\\n    True\\n    >>> print(binary_search(['a', 'c', 'd'], 'f'))\\n    False\\n    >>> print(binary_search([], 1))\\n    False\\n    >>> print(binary_search([-.1, .1 , .8], .1))\\n    True\\n    >>> binary_search(range(-5000, 5000, 10), 80)\\n    True\\n    >>> binary_search(range(-5000, 5000, 10), 1255)\\n    False\\n    >>> binary_search(range(0, 10000, 5), 2)\\n    False\\n    \\\"\\\"\\\"\\n    if len(a_list) == 0:\\n        return False\\n    midpoint = len(a_list) // 2\\n    if a_list[midpoint] == item:\\n        return True\\n    if item < a_list[midpoint]:\\n        return binary_search(a_list[:midpoint], item)\\n    else:\\n        return binary_search(a_list[midpoint + 1 :], item)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by comma:\\\\n\\\").strip()\\n    sequence = [int(item.strip()) for item in user_input.split(\\\",\\\")]\\n    target = int(input(\\\"Enter the number to be found in the list:\\\\n\\\").strip())\\n    not_str = \\\"\\\" if binary_search(sequence, target) else \\\"not \\\"\\n    print(f\\\"{target} was {not_str}found in {sequence}\\\")\\n\"",
    "simulated annealing": "\"# https://en.wikipedia.org/wiki/Simulated_annealing\\nimport math\\nimport random\\nfrom typing import Any\\n\\nfrom .hill_climbing import SearchProblem\\n\\n\\ndef simulated_annealing(\\n    search_prob,\\n    find_max: bool = True,\\n    max_x: float = math.inf,\\n    min_x: float = -math.inf,\\n    max_y: float = math.inf,\\n    min_y: float = -math.inf,\\n    visualization: bool = False,\\n    start_temperate: float = 100,\\n    rate_of_decrease: float = 0.01,\\n    threshold_temp: float = 1,\\n) -> Any:\\n    \\\"\\\"\\\"\\n    Implementation of the simulated annealing algorithm. We start with a given state,\\n    find all its neighbors. Pick a random neighbor, if that neighbor improves the\\n    solution, we move in that direction, if that neighbor does not improve the solution,\\n    we generate a random real number between 0 and 1, if the number is within a certain\\n    range (calculated using temperature) we move in that direction, else we pick\\n    another neighbor randomly and repeat the process.\\n\\n    Args:\\n        search_prob: The search state at the start.\\n        find_max: If True, the algorithm should find the minimum else the minimum.\\n        max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.\\n        visualization: If True, a matplotlib graph is displayed.\\n        start_temperate: the initial temperate of the system when the program starts.\\n        rate_of_decrease: the rate at which the temperate decreases in each iteration.\\n        threshold_temp: the threshold temperature below which we end the search\\n    Returns a search state having the maximum (or minimum) score.\\n    \\\"\\\"\\\"\\n    search_end = False\\n    current_state = search_prob\\n    current_temp = start_temperate\\n    scores = []\\n    iterations = 0\\n    best_state = None\\n\\n    while not search_end:\\n        current_score = current_state.score()\\n        if best_state is None or current_score > best_state.score():\\n            best_state = current_state\\n        scores.append(current_score)\\n        iterations += 1\\n        next_state = None\\n        neighbors = current_state.get_neighbors()\\n        while (\\n            next_state is None and neighbors\\n        ):  # till we do not find a neighbor that we can move to\\n            index = random.randint(0, len(neighbors) - 1)  # picking a random neighbor\\n            picked_neighbor = neighbors.pop(index)\\n            change = picked_neighbor.score() - current_score\\n\\n            if (\\n                picked_neighbor.x > max_x\\n                or picked_neighbor.x < min_x\\n                or picked_neighbor.y > max_y\\n                or picked_neighbor.y < min_y\\n            ):\\n                continue  # neighbor outside our bounds\\n\\n            if not find_max:\\n                change = change * -1  # in case we are finding minimum\\n            if change > 0:  # improves the solution\\n                next_state = picked_neighbor\\n            else:\\n                probability = (math.e) ** (\\n                    change / current_temp\\n                )  # probability generation function\\n                if random.random() < probability:  # random number within probability\\n                    next_state = picked_neighbor\\n        current_temp = current_temp - (current_temp * rate_of_decrease)\\n\\n        if current_temp < threshold_temp or next_state is None:\\n            # temperature below threshold, or could not find a suitable neighbor\\n            search_end = True\\n        else:\\n            current_state = next_state\\n\\n    if visualization:\\n        from matplotlib import pyplot as plt\\n\\n        plt.plot(range(iterations), scores)\\n        plt.xlabel(\\\"Iterations\\\")\\n        plt.ylabel(\\\"Function values\\\")\\n        plt.show()\\n    return best_state\\n\\n\\nif __name__ == \\\"__main__\\\":\\n\\n    def test_f1(x, y):\\n        return (x ** 2) + (y ** 2)\\n\\n    # starting the problem with initial coordinates (12, 47)\\n    prob = SearchProblem(x=12, y=47, step_size=1, function_to_optimize=test_f1)\\n    local_min = simulated_annealing(\\n        prob, find_max=False, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True\\n    )\\n    print(\\n        \\\"The minimum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 \\\"\\n        f\\\"and 50 > y > - 5 found via hill climbing: {local_min.score()}\\\"\\n    )\\n\\n    # starting the problem with initial coordinates (12, 47)\\n    prob = SearchProblem(x=12, y=47, step_size=1, function_to_optimize=test_f1)\\n    local_min = simulated_annealing(\\n        prob, find_max=True, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True\\n    )\\n    print(\\n        \\\"The maximum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 \\\"\\n        f\\\"and 50 > y > - 5 found via hill climbing: {local_min.score()}\\\"\\n    )\\n\\n    def test_f2(x, y):\\n        return (3 * x ** 2) - (6 * y)\\n\\n    prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)\\n    local_min = simulated_annealing(prob, find_max=False, visualization=True)\\n    print(\\n        \\\"The minimum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: \\\"\\n        f\\\"{local_min.score()}\\\"\\n    )\\n\\n    prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)\\n    local_min = simulated_annealing(prob, find_max=True, visualization=True)\\n    print(\\n        \\\"The maximum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: \\\"\\n        f\\\"{local_min.score()}\\\"\\n    )\\n\"",
    "tabu search": "\"\\\"\\\"\\\"\\nThis is pure Python implementation of Tabu search algorithm for a Travelling Salesman\\nProblem, that the distances between the cities are symmetric (the distance between city\\n'a' and city 'b' is the same between city 'b' and city 'a').\\nThe TSP can be represented into a graph. The cities are represented by nodes and the\\ndistance between them is represented by the weight of the ark between the nodes.\\n\\nThe .txt file with the graph has the form:\\n\\nnode1 node2 distance_between_node1_and_node2\\nnode1 node3 distance_between_node1_and_node3\\n...\\n\\nBe careful node1, node2 and the distance between them, must exist only once. This means\\nin the .txt file should not exist:\\nnode1 node2 distance_between_node1_and_node2\\nnode2 node1 distance_between_node2_and_node1\\n\\nFor pytests run following command:\\npytest\\n\\nFor manual testing run:\\npython tabu_search.py -f your_file_name.txt -number_of_iterations_of_tabu_search \\\\\\n    -s size_of_tabu_search\\ne.g. python tabu_search.py -f tabudata2.txt -i 4 -s 3\\n\\\"\\\"\\\"\\nimport argparse\\nimport copy\\n\\n\\ndef generate_neighbours(path):\\n    \\\"\\\"\\\"\\n    Pure implementation of generating a dictionary of neighbors and the cost with each\\n    neighbor, given a path file that includes a graph.\\n\\n    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\\n    :return dict_of_neighbours: Dictionary with key each node and value a list of lists\\n        with the neighbors of the node and the cost (distance) for each neighbor.\\n\\n    Example of dict_of_neighbours:\\n    >>) dict_of_neighbours[a]\\n    [[b,20],[c,18],[d,22],[e,26]]\\n\\n    This indicates the neighbors of node (city) 'a', which has neighbor the node 'b'\\n    with distance 20, the node 'c' with distance 18, the node 'd' with distance 22 and\\n    the node 'e' with distance 26.\\n    \\\"\\\"\\\"\\n\\n    dict_of_neighbours = {}\\n\\n    with open(path) as f:\\n        for line in f:\\n            if line.split()[0] not in dict_of_neighbours:\\n                _list = list()\\n                _list.append([line.split()[1], line.split()[2]])\\n                dict_of_neighbours[line.split()[0]] = _list\\n            else:\\n                dict_of_neighbours[line.split()[0]].append(\\n                    [line.split()[1], line.split()[2]]\\n                )\\n            if line.split()[1] not in dict_of_neighbours:\\n                _list = list()\\n                _list.append([line.split()[0], line.split()[2]])\\n                dict_of_neighbours[line.split()[1]] = _list\\n            else:\\n                dict_of_neighbours[line.split()[1]].append(\\n                    [line.split()[0], line.split()[2]]\\n                )\\n\\n    return dict_of_neighbours\\n\\n\\ndef generate_first_solution(path, dict_of_neighbours):\\n    \\\"\\\"\\\"\\n    Pure implementation of generating the first solution for the Tabu search to start,\\n    with the redundant resolution strategy. That means that we start from the starting\\n    node (e.g. node 'a'), then we go to the city nearest (lowest distance) to this node\\n    (let's assume is node 'c'), then we go to the nearest city of the node 'c', etc.\\n    till we have visited all cities and return to the starting node.\\n\\n    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\\n        with the neighbors of the node and the cost (distance) for each neighbor.\\n    :return first_solution: The solution for the first iteration of Tabu search using\\n        the redundant resolution strategy in a list.\\n    :return distance_of_first_solution: The total distance that Travelling Salesman\\n        will travel, if he follows the path in first_solution.\\n    \\\"\\\"\\\"\\n\\n    with open(path) as f:\\n        start_node = f.read(1)\\n    end_node = start_node\\n\\n    first_solution = []\\n\\n    visiting = start_node\\n\\n    distance_of_first_solution = 0\\n    while visiting not in first_solution:\\n        minim = 10000\\n        for k in dict_of_neighbours[visiting]:\\n            if int(k[1]) < int(minim) and k[0] not in first_solution:\\n                minim = k[1]\\n                best_node = k[0]\\n\\n        first_solution.append(visiting)\\n        distance_of_first_solution = distance_of_first_solution + int(minim)\\n        visiting = best_node\\n\\n    first_solution.append(end_node)\\n\\n    position = 0\\n    for k in dict_of_neighbours[first_solution[-2]]:\\n        if k[0] == start_node:\\n            break\\n        position += 1\\n\\n    distance_of_first_solution = (\\n        distance_of_first_solution\\n        + int(dict_of_neighbours[first_solution[-2]][position][1])\\n        - 10000\\n    )\\n    return first_solution, distance_of_first_solution\\n\\n\\ndef find_neighborhood(solution, dict_of_neighbours):\\n    \\\"\\\"\\\"\\n    Pure implementation of generating the neighborhood (sorted by total distance of\\n    each solution from lowest to highest) of a solution with 1-1 exchange method, that\\n    means we exchange each node in a solution with each other node and generating a\\n    number of solution named neighborhood.\\n\\n    :param solution: The solution in which we want to find the neighborhood.\\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\\n        with the neighbors of the node and the cost (distance) for each neighbor.\\n    :return neighborhood_of_solution: A list that includes the solutions and the total\\n        distance of each solution (in form of list) that are produced with 1-1 exchange\\n        from the solution that the method took as an input\\n\\n    Example:\\n    >>> find_neighborhood(['a', 'c', 'b', 'd', 'e', 'a'],\\n    ...                   {'a': [['b', '20'], ['c', '18'], ['d', '22'], ['e', '26']],\\n    ...                    'c': [['a', '18'], ['b', '10'], ['d', '23'], ['e', '24']],\\n    ...                    'b': [['a', '20'], ['c', '10'], ['d', '11'], ['e', '12']],\\n    ...                    'e': [['a', '26'], ['b', '12'], ['c', '24'], ['d', '40']],\\n    ...                    'd': [['a', '22'], ['b', '11'], ['c', '23'], ['e', '40']]}\\n    ...                   )  # doctest: +NORMALIZE_WHITESPACE\\n    [['a', 'e', 'b', 'd', 'c', 'a', 90],\\n     ['a', 'c', 'd', 'b', 'e', 'a', 90],\\n     ['a', 'd', 'b', 'c', 'e', 'a', 93],\\n     ['a', 'c', 'b', 'e', 'd', 'a', 102],\\n     ['a', 'c', 'e', 'd', 'b', 'a', 113],\\n     ['a', 'b', 'c', 'd', 'e', 'a', 119]]\\n    \\\"\\\"\\\"\\n\\n    neighborhood_of_solution = []\\n\\n    for n in solution[1:-1]:\\n        idx1 = solution.index(n)\\n        for kn in solution[1:-1]:\\n            idx2 = solution.index(kn)\\n            if n == kn:\\n                continue\\n\\n            _tmp = copy.deepcopy(solution)\\n            _tmp[idx1] = kn\\n            _tmp[idx2] = n\\n\\n            distance = 0\\n\\n            for k in _tmp[:-1]:\\n                next_node = _tmp[_tmp.index(k) + 1]\\n                for i in dict_of_neighbours[k]:\\n                    if i[0] == next_node:\\n                        distance = distance + int(i[1])\\n            _tmp.append(distance)\\n\\n            if _tmp not in neighborhood_of_solution:\\n                neighborhood_of_solution.append(_tmp)\\n\\n    indexOfLastItemInTheList = len(neighborhood_of_solution[0]) - 1\\n\\n    neighborhood_of_solution.sort(key=lambda x: x[indexOfLastItemInTheList])\\n    return neighborhood_of_solution\\n\\n\\ndef tabu_search(\\n    first_solution, distance_of_first_solution, dict_of_neighbours, iters, size\\n):\\n    \\\"\\\"\\\"\\n    Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in\\n    Python.\\n\\n    :param first_solution: The solution for the first iteration of Tabu search using\\n        the redundant resolution strategy in a list.\\n    :param distance_of_first_solution: The total distance that Travelling Salesman will\\n        travel, if he follows the path in first_solution.\\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\\n        with the neighbors of the node and the cost (distance) for each neighbor.\\n    :param iters: The number of iterations that Tabu search will execute.\\n    :param size: The size of Tabu List.\\n    :return best_solution_ever: The solution with the lowest distance that occurred\\n        during the execution of Tabu search.\\n    :return best_cost: The total distance that Travelling Salesman will travel, if he\\n        follows the path in best_solution ever.\\n    \\\"\\\"\\\"\\n    count = 1\\n    solution = first_solution\\n    tabu_list = list()\\n    best_cost = distance_of_first_solution\\n    best_solution_ever = solution\\n\\n    while count <= iters:\\n        neighborhood = find_neighborhood(solution, dict_of_neighbours)\\n        index_of_best_solution = 0\\n        best_solution = neighborhood[index_of_best_solution]\\n        best_cost_index = len(best_solution) - 1\\n\\n        found = False\\n        while not found:\\n            i = 0\\n            while i < len(best_solution):\\n\\n                if best_solution[i] != solution[i]:\\n                    first_exchange_node = best_solution[i]\\n                    second_exchange_node = solution[i]\\n                    break\\n                i = i + 1\\n\\n            if [first_exchange_node, second_exchange_node] not in tabu_list and [\\n                second_exchange_node,\\n                first_exchange_node,\\n            ] not in tabu_list:\\n                tabu_list.append([first_exchange_node, second_exchange_node])\\n                found = True\\n                solution = best_solution[:-1]\\n                cost = neighborhood[index_of_best_solution][best_cost_index]\\n                if cost < best_cost:\\n                    best_cost = cost\\n                    best_solution_ever = solution\\n            else:\\n                index_of_best_solution = index_of_best_solution + 1\\n                best_solution = neighborhood[index_of_best_solution]\\n\\n        if len(tabu_list) >= size:\\n            tabu_list.pop(0)\\n\\n        count = count + 1\\n\\n    return best_solution_ever, best_cost\\n\\n\\ndef main(args=None):\\n    dict_of_neighbours = generate_neighbours(args.File)\\n\\n    first_solution, distance_of_first_solution = generate_first_solution(\\n        args.File, dict_of_neighbours\\n    )\\n\\n    best_sol, best_cost = tabu_search(\\n        first_solution,\\n        distance_of_first_solution,\\n        dict_of_neighbours,\\n        args.Iterations,\\n        args.Size,\\n    )\\n\\n    print(f\\\"Best solution: {best_sol}, with total distance: {best_cost}.\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    parser = argparse.ArgumentParser(description=\\\"Tabu Search\\\")\\n    parser.add_argument(\\n        \\\"-f\\\",\\n        \\\"--File\\\",\\n        type=str,\\n        help=\\\"Path to the file containing the data\\\",\\n        required=True,\\n    )\\n    parser.add_argument(\\n        \\\"-i\\\",\\n        \\\"--Iterations\\\",\\n        type=int,\\n        help=\\\"How many iterations the algorithm should perform\\\",\\n        required=True,\\n    )\\n    parser.add_argument(\\n        \\\"-s\\\", \\\"--Size\\\", type=int, help=\\\"Size of the tabu list\\\", required=True\\n    )\\n\\n    # Pass the arguments to main method\\n    main(parser.parse_args())\\n\"",
    "ternary search": "\"\\\"\\\"\\\"\\nThis is a type of divide and conquer algorithm which divides the search space into\\n3 parts and finds the target value based on the property of the array or list\\n(usually monotonic property).\\n\\nTime Complexity  : O(log3 N)\\nSpace Complexity : O(1)\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n# This is the precision for this function which can be altered.\\n# It is recommended for users to keep this number greater than or equal to 10.\\nprecision = 10\\n\\n\\n# This is the linear search that will occur after the search space has become smaller.\\n\\n\\ndef lin_search(left: int, right: int, array: list[int], target: int) -> int:\\n    \\\"\\\"\\\"Perform linear search in list. Returns -1 if element is not found.\\n\\n    Parameters\\n    ----------\\n    left : int\\n        left index bound.\\n    right : int\\n        right index bound.\\n    array : List[int]\\n        List of elements to be searched on\\n    target : int\\n        Element that is searched\\n\\n    Returns\\n    -------\\n    int\\n        index of element that is looked for.\\n\\n    Examples\\n    --------\\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\\n    3\\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\\n    -1\\n    >>> lin_search(0, 2, [-18, 2], -18)\\n    0\\n    >>> lin_search(0, 1, [5], 5)\\n    0\\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\\n    1\\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\\n    0\\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\\n    2\\n    \\\"\\\"\\\"\\n    for i in range(left, right):\\n        if array[i] == target:\\n            return i\\n    return -1\\n\\n\\ndef ite_ternary_search(array: list[int], target: int) -> int:\\n    \\\"\\\"\\\"Iterative method of the ternary search algorithm.\\n    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\\n    >>> ite_ternary_search(test_list, 3)\\n    -1\\n    >>> ite_ternary_search(test_list, 13)\\n    4\\n    >>> ite_ternary_search([4, 5, 6, 7], 4)\\n    0\\n    >>> ite_ternary_search([4, 5, 6, 7], -10)\\n    -1\\n    >>> ite_ternary_search([-18, 2], -18)\\n    0\\n    >>> ite_ternary_search([5], 5)\\n    0\\n    >>> ite_ternary_search(['a', 'c', 'd'], 'c')\\n    1\\n    >>> ite_ternary_search(['a', 'c', 'd'], 'f')\\n    -1\\n    >>> ite_ternary_search([], 1)\\n    -1\\n    >>> ite_ternary_search([.1, .4 , -.1], .1)\\n    0\\n    \\\"\\\"\\\"\\n\\n    left = 0\\n    right = len(array)\\n    while left <= right:\\n        if right - left < precision:\\n            return lin_search(left, right, array, target)\\n\\n        one_third = (left + right) // 3 + 1\\n        two_third = 2 * (left + right) // 3 + 1\\n\\n        if array[one_third] == target:\\n            return one_third\\n        elif array[two_third] == target:\\n            return two_third\\n\\n        elif target < array[one_third]:\\n            right = one_third - 1\\n        elif array[two_third] < target:\\n            left = two_third + 1\\n\\n        else:\\n\\n            left = one_third + 1\\n            right = two_third - 1\\n    else:\\n        return -1\\n\\n\\ndef rec_ternary_search(left: int, right: int, array: list[int], target: int) -> int:\\n    \\\"\\\"\\\"Recursive method of the ternary search algorithm.\\n\\n    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\\n    >>> rec_ternary_search(0, len(test_list), test_list, 3)\\n    -1\\n    >>> rec_ternary_search(4, len(test_list), test_list, 42)\\n    8\\n    >>> rec_ternary_search(0, 2, [4, 5, 6, 7], 4)\\n    0\\n    >>> rec_ternary_search(0, 3, [4, 5, 6, 7], -10)\\n    -1\\n    >>> rec_ternary_search(0, 1, [-18, 2], -18)\\n    0\\n    >>> rec_ternary_search(0, 1, [5], 5)\\n    0\\n    >>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'c')\\n    1\\n    >>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'f')\\n    -1\\n    >>> rec_ternary_search(0, 0, [], 1)\\n    -1\\n    >>> rec_ternary_search(0, 3, [.1, .4 , -.1], .1)\\n    0\\n    \\\"\\\"\\\"\\n    if left < right:\\n        if right - left < precision:\\n            return lin_search(left, right, array, target)\\n        one_third = (left + right) // 3 + 1\\n        two_third = 2 * (left + right) // 3 + 1\\n\\n        if array[one_third] == target:\\n            return one_third\\n        elif array[two_third] == target:\\n            return two_third\\n\\n        elif target < array[one_third]:\\n            return rec_ternary_search(left, one_third - 1, array, target)\\n        elif array[two_third] < target:\\n            return rec_ternary_search(two_third + 1, right, array, target)\\n        else:\\n            return rec_ternary_search(one_third + 1, two_third - 1, array, target)\\n    else:\\n        return -1\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    user_input = input(\\\"Enter numbers separated by comma:\\\\n\\\").strip()\\n    collection = [int(item.strip()) for item in user_input.split(\\\",\\\")]\\n    assert collection == sorted(collection), f\\\"List must be ordered.\\\\n{collection}.\\\"\\n    target = int(input(\\\"Enter the number to be found in the list:\\\\n\\\").strip())\\n    result1 = ite_ternary_search(collection, target)\\n    result2 = rec_ternary_search(0, len(collection) - 1, collection, target)\\n    if result2 != -1:\\n        print(f\\\"Iterative search: {target} found at positions: {result1}\\\")\\n        print(f\\\"Recursive search: {target} found at positions: {result2}\\\")\\n    else:\\n        print(\\\"Not found\\\")\\n\"",
    "bead sort": "\"\\\"\\\"\\\"\\nBead sort only works for sequences of non-negative integers.\\nhttps://en.wikipedia.org/wiki/Bead_sort\\n\\\"\\\"\\\"\\n\\n\\ndef bead_sort(sequence: list) -> list:\\n    \\\"\\\"\\\"\\n    >>> bead_sort([6, 11, 12, 4, 1, 5])\\n    [1, 4, 5, 6, 11, 12]\\n\\n    >>> bead_sort([9, 8, 7, 6, 5, 4 ,3, 2, 1])\\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n\\n    >>> bead_sort([5, 0, 4, 3])\\n    [0, 3, 4, 5]\\n\\n    >>> bead_sort([8, 2, 1])\\n    [1, 2, 8]\\n\\n    >>> bead_sort([1, .9, 0.0, 0, -1, -.9])\\n    Traceback (most recent call last):\\n    ...\\n    TypeError: Sequence must be list of non-negative integers\\n\\n    >>> bead_sort(\\\"Hello world\\\")\\n    Traceback (most recent call last):\\n    ...\\n    TypeError: Sequence must be list of non-negative integers\\n    \\\"\\\"\\\"\\n    if any(not isinstance(x, int) or x < 0 for x in sequence):\\n        raise TypeError(\\\"Sequence must be list of non-negative integers\\\")\\n    for _ in range(len(sequence)):\\n        for i, (rod_upper, rod_lower) in enumerate(zip(sequence, sequence[1:])):\\n            if rod_upper > rod_lower:\\n                sequence[i] -= rod_upper - rod_lower\\n                sequence[i + 1] += rod_upper - rod_lower\\n    return sequence\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    assert bead_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\\n    assert bead_sort([7, 9, 4, 3, 5]) == [3, 4, 5, 7, 9]\\n\"",
    "bitonic sort": "\"\\\"\\\"\\\"\\nPython program for Bitonic Sort.\\n\\nNote that this program works only when size of input is a power of 2.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:\\n    \\\"\\\"\\\"Compare the value at given index1 and index2 of the array and swap them as per\\n    the given direction.\\n\\n    The parameter direction indicates the sorting direction, ASCENDING(1) or\\n    DESCENDING(0); if (a[i] > a[j]) agrees with the direction, then a[i] and a[j] are\\n    interchanged.\\n\\n    >>> arr = [12, 42, -21, 1]\\n    >>> comp_and_swap(arr, 1, 2, 1)\\n    >>> print(arr)\\n    [12, -21, 42, 1]\\n\\n    >>> comp_and_swap(arr, 1, 2, 0)\\n    >>> print(arr)\\n    [12, 42, -21, 1]\\n\\n    >>> comp_and_swap(arr, 0, 3, 1)\\n    >>> print(arr)\\n    [1, 42, -21, 12]\\n\\n    >>> comp_and_swap(arr, 0, 3, 0)\\n    >>> print(arr)\\n    [12, 42, -21, 1]\\n    \\\"\\\"\\\"\\n    if (direction == 1 and array[index1] > array[index2]) or (\\n        direction == 0 and array[index1] < array[index2]\\n    ):\\n        array[index1], array[index2] = array[index2], array[index1]\\n\\n\\ndef bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:\\n    \\\"\\\"\\\"\\n    It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in\\n    descending if direction = 0.\\n    The sequence to be sorted starts at index position low, the parameter length is the\\n    number of elements to be sorted.\\n\\n    >>> arr = [12, 42, -21, 1]\\n    >>> bitonic_merge(arr, 0, 4, 1)\\n    >>> print(arr)\\n    [-21, 1, 12, 42]\\n\\n    >>> bitonic_merge(arr, 0, 4, 0)\\n    >>> print(arr)\\n    [42, 12, 1, -21]\\n    \\\"\\\"\\\"\\n    if length > 1:\\n        middle = int(length / 2)\\n        for i in range(low, low + middle):\\n            comp_and_swap(array, i, i + middle, direction)\\n        bitonic_merge(array, low, middle, direction)\\n        bitonic_merge(array, low + middle, middle, direction)\\n\\n\\ndef bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:\\n    \\\"\\\"\\\"\\n    This function first produces a bitonic sequence by recursively sorting its two\\n    halves in opposite sorting orders, and then calls bitonic_merge to make them in the\\n    same order.\\n\\n    >>> arr = [12, 34, 92, -23, 0, -121, -167, 145]\\n    >>> bitonic_sort(arr, 0, 8, 1)\\n    >>> arr\\n    [-167, -121, -23, 0, 12, 34, 92, 145]\\n\\n    >>> bitonic_sort(arr, 0, 8, 0)\\n    >>> arr\\n    [145, 92, 34, 12, 0, -23, -121, -167]\\n    \\\"\\\"\\\"\\n    if length > 1:\\n        middle = int(length / 2)\\n        bitonic_sort(array, low, middle, 1)\\n        bitonic_sort(array, low + middle, middle, 0)\\n        bitonic_merge(array, low, length, direction)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item.strip()) for item in user_input.split(\\\",\\\")]\\n\\n    bitonic_sort(unsorted, 0, len(unsorted), 1)\\n    print(\\\"\\\\nSorted array in ascending order is: \\\", end=\\\"\\\")\\n    print(*unsorted, sep=\\\", \\\")\\n\\n    bitonic_merge(unsorted, 0, len(unsorted), 0)\\n    print(\\\"Sorted array in descending order is: \\\", end=\\\"\\\")\\n    print(*unsorted, sep=\\\", \\\")\\n\"",
    "bogo sort": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the bogosort algorithm,\\nalso known as permutation sort, stupid sort, slowsort, shotgun sort, or monkey sort.\\nBogosort generates random permutations until it guesses the correct one.\\n\\nMore info on: https://en.wikipedia.org/wiki/Bogosort\\n\\nFor doctests run following command:\\npython -m doctest -v bogo_sort.py\\nor\\npython3 -m doctest -v bogo_sort.py\\nFor manual testing run:\\npython bogo_sort.py\\n\\\"\\\"\\\"\\n\\nimport random\\n\\n\\ndef bogo_sort(collection):\\n    \\\"\\\"\\\"Pure implementation of the bogosort algorithm in Python\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: the same collection ordered by ascending\\n    Examples:\\n    >>> bogo_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n    >>> bogo_sort([])\\n    []\\n    >>> bogo_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n    \\\"\\\"\\\"\\n\\n    def is_sorted(collection):\\n        if len(collection) < 2:\\n            return True\\n        for i in range(len(collection) - 1):\\n            if collection[i] > collection[i + 1]:\\n                return False\\n        return True\\n\\n    while not is_sorted(collection):\\n        random.shuffle(collection)\\n    return collection\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(bogo_sort(unsorted))\\n\"",
    "bubble sort": "\"def bubble_sort(collection):\\n    \\\"\\\"\\\"Pure implementation of bubble sort algorithm in Python\\n\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: the same collection ordered by ascending\\n\\n    Examples:\\n    >>> bubble_sort([0, 5, 2, 3, 2])\\n    [0, 2, 2, 3, 5]\\n    >>> bubble_sort([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])\\n    True\\n    >>> bubble_sort([]) == sorted([])\\n    True\\n    >>> bubble_sort([-2, -45, -5]) == sorted([-2, -45, -5])\\n    True\\n    >>> bubble_sort([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])\\n    True\\n    >>> bubble_sort(['d', 'a', 'b', 'e', 'c']) == sorted(['d', 'a', 'b', 'e', 'c'])\\n    True\\n    >>> import random\\n    >>> collection = random.sample(range(-50, 50), 100)\\n    >>> bubble_sort(collection) == sorted(collection)\\n    True\\n    >>> import string\\n    >>> collection = random.choices(string.ascii_letters + string.digits, k=100)\\n    >>> bubble_sort(collection) == sorted(collection)\\n    True\\n    \\\"\\\"\\\"\\n    length = len(collection)\\n    for i in range(length - 1):\\n        swapped = False\\n        for j in range(length - 1 - i):\\n            if collection[j] > collection[j + 1]:\\n                swapped = True\\n                collection[j], collection[j + 1] = collection[j + 1], collection[j]\\n        if not swapped:\\n            break  # Stop iteration if the collection is sorted.\\n    return collection\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n    import time\\n\\n    doctest.testmod()\\n\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    start = time.process_time()\\n    print(*bubble_sort(unsorted), sep=\\\",\\\")\\n    print(f\\\"Processing time: {time.process_time() - start}\\\")\\n\"",
    "bucket sort": "\"#!/usr/bin/env python3\\n\\\"\\\"\\\"\\nIllustrate how to implement bucket sort algorithm.\\n\\nAuthor: OMKAR PATHAK\\nThis program will illustrate how to implement bucket sort algorithm\\n\\nWikipedia says: Bucket sort, or bin sort, is a sorting algorithm that works\\nby distributing the elements of an array into a number of buckets.\\nEach bucket is then sorted individually, either using a different sorting\\nalgorithm, or by recursively applying the bucket sorting algorithm. It is a\\ndistribution sort, and is a cousin of radix sort in the most to least\\nsignificant digit flavour.\\nBucket sort is a generalization of pigeonhole sort. Bucket sort can be\\nimplemented with comparisons and therefore can also be considered a\\ncomparison sort algorithm. The computational complexity estimates involve the\\nnumber of buckets.\\n\\nTime Complexity of Solution:\\nWorst case scenario occurs when all the elements are placed in a single bucket.\\nThe overall performance would then be dominated by the algorithm used to sort each\\nbucket. In this case, O(n log n), because of TimSort\\n\\nAverage Case O(n + (n^2)/k + k), where k is the number of buckets\\n\\nIf k = O(n), time complexity is O(n)\\n\\nSource: https://en.wikipedia.org/wiki/Bucket_sort\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef bucket_sort(my_list: list) -> list:\\n    \\\"\\\"\\\"\\n    >>> data = [-1, 2, -5, 0]\\n    >>> bucket_sort(data) == sorted(data)\\n    True\\n    >>> data = [9, 8, 7, 6, -12]\\n    >>> bucket_sort(data) == sorted(data)\\n    True\\n    >>> data = [.4, 1.2, .1, .2, -.9]\\n    >>> bucket_sort(data) == sorted(data)\\n    True\\n    >>> bucket_sort([]) == sorted([])\\n    True\\n    >>> import random\\n    >>> collection = random.sample(range(-50, 50), 50)\\n    >>> bucket_sort(collection) == sorted(collection)\\n    True\\n    \\\"\\\"\\\"\\n    if len(my_list) == 0:\\n        return []\\n    min_value, max_value = min(my_list), max(my_list)\\n    bucket_count = int(max_value - min_value) + 1\\n    buckets: list[list] = [[] for _ in range(bucket_count)]\\n\\n    for i in range(len(my_list)):\\n        buckets[(int(my_list[i] - min_value) // bucket_count)].append(my_list[i])\\n\\n    return [v for bucket in buckets for v in sorted(bucket)]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n    assert bucket_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]\\n    assert bucket_sort([0, 1, -10, 15, 2, -2]) == [-10, -2, 0, 1, 2, 15]\\n\"",
    "cocktail shaker sort": "\"\\\"\\\"\\\" https://en.wikipedia.org/wiki/Cocktail_shaker_sort \\\"\\\"\\\"\\n\\n\\ndef cocktail_shaker_sort(unsorted: list) -> list:\\n    \\\"\\\"\\\"\\n    Pure implementation of the cocktail shaker sort algorithm in Python.\\n    >>> cocktail_shaker_sort([4, 5, 2, 1, 2])\\n    [1, 2, 2, 4, 5]\\n\\n    >>> cocktail_shaker_sort([-4, 5, 0, 1, 2, 11])\\n    [-4, 0, 1, 2, 5, 11]\\n\\n    >>> cocktail_shaker_sort([0.1, -2.4, 4.4, 2.2])\\n    [-2.4, 0.1, 2.2, 4.4]\\n\\n    >>> cocktail_shaker_sort([1, 2, 3, 4, 5])\\n    [1, 2, 3, 4, 5]\\n\\n    >>> cocktail_shaker_sort([-4, -5, -24, -7, -11])\\n    [-24, -11, -7, -5, -4]\\n    \\\"\\\"\\\"\\n    for i in range(len(unsorted) - 1, 0, -1):\\n        swapped = False\\n\\n        for j in range(i, 0, -1):\\n            if unsorted[j] < unsorted[j - 1]:\\n                unsorted[j], unsorted[j - 1] = unsorted[j - 1], unsorted[j]\\n                swapped = True\\n\\n        for j in range(i):\\n            if unsorted[j] > unsorted[j + 1]:\\n                unsorted[j], unsorted[j + 1] = unsorted[j + 1], unsorted[j]\\n                swapped = True\\n\\n        if not swapped:\\n            break\\n    return unsorted\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(f\\\"{cocktail_shaker_sort(unsorted) = }\\\")\\n\"",
    "comb sort": "\"\\\"\\\"\\\"\\nThis is pure Python implementation of comb sort algorithm.\\nComb sort is a relatively simple sorting algorithm originally designed by Wlodzimierz\\nDobosiewicz in 1980.  It was rediscovered by Stephen Lacey and Richard Box in 1991.\\nComb sort improves on bubble sort algorithm.\\nIn bubble sort, distance (or gap) between two compared elements is always one.\\nComb sort improvement is that gap can be much more than 1, in order to prevent slowing\\ndown by small values\\nat the end of a list.\\n\\nMore info on: https://en.wikipedia.org/wiki/Comb_sort\\n\\nFor doctests run following command:\\npython -m doctest -v comb_sort.py\\nor\\npython3 -m doctest -v comb_sort.py\\n\\nFor manual testing run:\\npython comb_sort.py\\n\\\"\\\"\\\"\\n\\n\\ndef comb_sort(data: list) -> list:\\n    \\\"\\\"\\\"Pure implementation of comb sort algorithm in Python\\n    :param data: mutable collection with comparable items\\n    :return: the same collection in ascending order\\n    Examples:\\n    >>> comb_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n    >>> comb_sort([])\\n    []\\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\\n    [-15, -7, 0, 2, 3, 8, 45, 99]\\n    \\\"\\\"\\\"\\n    shrink_factor = 1.3\\n    gap = len(data)\\n    completed = False\\n\\n    while not completed:\\n\\n        # Update the gap value for a next comb\\n        gap = int(gap / shrink_factor)\\n        if gap <= 1:\\n            completed = True\\n\\n        index = 0\\n        while index + gap < len(data):\\n            if data[index] > data[index + gap]:\\n                # Swap values\\n                data[index], data[index + gap] = data[index + gap], data[index]\\n                completed = False\\n            index += 1\\n\\n    return data\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(comb_sort(unsorted))\\n\"",
    "counting sort": "\"\\\"\\\"\\\"\\nThis is pure Python implementation of counting sort algorithm\\nFor doctests run following command:\\npython -m doctest -v counting_sort.py\\nor\\npython3 -m doctest -v counting_sort.py\\nFor manual testing run:\\npython counting_sort.py\\n\\\"\\\"\\\"\\n\\n\\ndef counting_sort(collection):\\n    \\\"\\\"\\\"Pure implementation of counting sort algorithm in Python\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: the same collection ordered by ascending\\n    Examples:\\n    >>> counting_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n    >>> counting_sort([])\\n    []\\n    >>> counting_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n    \\\"\\\"\\\"\\n    # if the collection is empty, returns empty\\n    if collection == []:\\n        return []\\n\\n    # get some information about the collection\\n    coll_len = len(collection)\\n    coll_max = max(collection)\\n    coll_min = min(collection)\\n\\n    # create the counting array\\n    counting_arr_length = coll_max + 1 - coll_min\\n    counting_arr = [0] * counting_arr_length\\n\\n    # count how much a number appears in the collection\\n    for number in collection:\\n        counting_arr[number - coll_min] += 1\\n\\n    # sum each position with it's predecessors. now, counting_arr[i] tells\\n    # us how many elements <= i has in the collection\\n    for i in range(1, counting_arr_length):\\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\\n\\n    # create the output collection\\n    ordered = [0] * coll_len\\n\\n    # place the elements in the output, respecting the original order (stable\\n    # sort) from end to begin, updating counting_arr\\n    for i in reversed(range(0, coll_len)):\\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\\n        counting_arr[collection[i] - coll_min] -= 1\\n\\n    return ordered\\n\\n\\ndef counting_sort_string(string):\\n    \\\"\\\"\\\"\\n    >>> counting_sort_string(\\\"thisisthestring\\\")\\n    'eghhiiinrsssttt'\\n    \\\"\\\"\\\"\\n    return \\\"\\\".join([chr(i) for i in counting_sort([ord(c) for c in string])])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # Test string sort\\n    assert \\\"eghhiiinrsssttt\\\" == counting_sort_string(\\\"thisisthestring\\\")\\n\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(counting_sort(unsorted))\\n\"",
    "cycle sort": "\"\\\"\\\"\\\"\\nCode contributed by Honey Sharma\\nSource: https://en.wikipedia.org/wiki/Cycle_sort\\n\\\"\\\"\\\"\\n\\n\\ndef cycle_sort(array: list) -> list:\\n    \\\"\\\"\\\"\\n    >>> cycle_sort([4, 3, 2, 1])\\n    [1, 2, 3, 4]\\n\\n    >>> cycle_sort([-4, 20, 0, -50, 100, -1])\\n    [-50, -4, -1, 0, 20, 100]\\n\\n    >>> cycle_sort([-.1, -.2, 1.3, -.8])\\n    [-0.8, -0.2, -0.1, 1.3]\\n\\n    >>> cycle_sort([])\\n    []\\n    \\\"\\\"\\\"\\n    array_len = len(array)\\n    for cycle_start in range(0, array_len - 1):\\n        item = array[cycle_start]\\n\\n        pos = cycle_start\\n        for i in range(cycle_start + 1, array_len):\\n            if array[i] < item:\\n                pos += 1\\n\\n        if pos == cycle_start:\\n            continue\\n\\n        while item == array[pos]:\\n            pos += 1\\n\\n        array[pos], item = item, array[pos]\\n        while pos != cycle_start:\\n            pos = cycle_start\\n            for i in range(cycle_start + 1, array_len):\\n                if array[i] < item:\\n                    pos += 1\\n\\n            while item == array[pos]:\\n                pos += 1\\n\\n            array[pos], item = item, array[pos]\\n\\n    return array\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    assert cycle_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]\\n    assert cycle_sort([0, 1, -10, 15, 2, -2]) == [-10, -2, 0, 1, 2, 15]\\n\"",
    "double sort": "\"def double_sort(lst):\\r\\n    \\\"\\\"\\\"This sorting algorithm sorts an array using the principle of bubble sort,\\r\\n    but does it both from left to right and right to left.\\r\\n    Hence, it's called \\\"Double sort\\\"\\r\\n    :param collection: mutable ordered sequence of elements\\r\\n    :return: the same collection in ascending order\\r\\n    Examples:\\r\\n    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6 ,-7])\\r\\n    [-7, -6, -5, -4, -3, -2, -1]\\r\\n    >>> double_sort([])\\r\\n    []\\r\\n    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6])\\r\\n    [-6, -5, -4, -3, -2, -1]\\r\\n    >>> double_sort([-3, 10, 16, -42, 29]) == sorted([-3, 10, 16, -42, 29])\\r\\n    True\\r\\n    \\\"\\\"\\\"\\r\\n    no_of_elements = len(lst)\\r\\n    for i in range(\\r\\n        0, int(((no_of_elements - 1) / 2) + 1)\\r\\n    ):  # we don't need to traverse to end of list as\\r\\n        for j in range(0, no_of_elements - 1):\\r\\n            if (\\r\\n                lst[j + 1] < lst[j]\\r\\n            ):  # applying bubble sort algorithm from left to right (or forwards)\\r\\n                temp = lst[j + 1]\\r\\n                lst[j + 1] = lst[j]\\r\\n                lst[j] = temp\\r\\n            if (\\r\\n                lst[no_of_elements - 1 - j] < lst[no_of_elements - 2 - j]\\r\\n            ):  # applying bubble sort algorithm from right to left (or backwards)\\r\\n                temp = lst[no_of_elements - 1 - j]\\r\\n                lst[no_of_elements - 1 - j] = lst[no_of_elements - 2 - j]\\r\\n                lst[no_of_elements - 2 - j] = temp\\r\\n    return lst\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    print(\\\"enter the list to be sorted\\\")\\r\\n    lst = [int(x) for x in input().split()]  # inputing elements of the list in one line\\r\\n    sorted_lst = double_sort(lst)\\r\\n    print(\\\"the sorted list is\\\")\\r\\n    print(sorted_lst)\\r\\n\"",
    "dutch national flag sort": "\"\\\"\\\"\\\"\\nA pure implementation of Dutch national flag (DNF) sort algorithm in Python.\\nDutch National Flag algorithm is an algorithm originally designed by Edsger Dijkstra.\\nIt is the most optimal sort for 3 unique values (eg. 0, 1, 2) in a sequence.  DNF can\\nsort a sequence of n size with [0 <= a[i] <= 2] at guaranteed O(n) complexity in a\\nsingle pass.\\n\\nThe flag of the Netherlands consists of three colors: white, red, and blue.\\nThe task is to randomly arrange balls of white, red, and blue in such a way that balls\\nof the same color are placed together.  DNF sorts a sequence of 0, 1, and 2's in linear\\ntime that does not consume any extra space.  This algorithm can be implemented only on\\na sequence that contains three unique elements.\\n\\n1) Time complexity is O(n).\\n2) Space complexity is O(1).\\n\\nMore info on: https://en.wikipedia.org/wiki/Dutch_national_flag_problem\\n\\nFor doctests run following command:\\npython3 -m doctest -v dutch_national_flag_sort.py\\n\\nFor manual testing run:\\npython dnf_sort.py\\n\\\"\\\"\\\"\\n\\n\\n# Python program to sort a sequence containing only 0, 1 and 2 in a single pass.\\nred = 0  # The first color of the flag.\\nwhite = 1  # The second color of the flag.\\nblue = 2  # The third color of the flag.\\ncolors = (red, white, blue)\\n\\n\\ndef dutch_national_flag_sort(sequence: list) -> list:\\n    \\\"\\\"\\\"\\n    A pure Python implementation of Dutch National Flag sort algorithm.\\n    :param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence\\n    :return: The same collection in ascending order\\n\\n    >>> dutch_national_flag_sort([])\\n    []\\n    >>> dutch_national_flag_sort([0])\\n    [0]\\n    >>> dutch_national_flag_sort([2, 1, 0, 0, 1, 2])\\n    [0, 0, 1, 1, 2, 2]\\n    >>> dutch_national_flag_sort([0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1])\\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2]\\n    >>> dutch_national_flag_sort(\\\"abacab\\\")\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\\n    >>> dutch_national_flag_sort(\\\"Abacab\\\")\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\\n    >>> dutch_national_flag_sort([3, 2, 3, 1, 3, 0, 3])\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\\n    >>> dutch_national_flag_sort([-1, 2, -1, 1, -1, 0, -1])\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\\n    >>> dutch_national_flag_sort([1.1, 2, 1.1, 1, 1.1, 0, 1.1])\\n    Traceback (most recent call last):\\n      ...\\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\\n    \\\"\\\"\\\"\\n    if not sequence:\\n        return []\\n    if len(sequence) == 1:\\n        return list(sequence)\\n    low = 0\\n    high = len(sequence) - 1\\n    mid = 0\\n    while mid <= high:\\n        if sequence[mid] == colors[0]:\\n            sequence[low], sequence[mid] = sequence[mid], sequence[low]\\n            low += 1\\n            mid += 1\\n        elif sequence[mid] == colors[1]:\\n            mid += 1\\n        elif sequence[mid] == colors[2]:\\n            sequence[mid], sequence[high] = sequence[high], sequence[mid]\\n            high -= 1\\n        else:\\n            raise ValueError(\\n                f\\\"The elements inside the sequence must contains only {colors} values\\\"\\n            )\\n    return sequence\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    user_input = input(\\\"Enter numbers separated by commas:\\\\n\\\").strip()\\n    unsorted = [int(item.strip()) for item in user_input.split(\\\",\\\")]\\n    print(f\\\"{dutch_national_flag_sort(unsorted)}\\\")\\n\"",
    "exchange sort": "\"def exchange_sort(numbers: list[int]) -> list[int]:\\n    \\\"\\\"\\\"\\n    Uses exchange sort to sort a list of numbers.\\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\\n    >>> exchange_sort([5, 4, 3, 2, 1])\\n    [1, 2, 3, 4, 5]\\n    >>> exchange_sort([-1, -2, -3])\\n    [-3, -2, -1]\\n    >>> exchange_sort([1, 2, 3, 4, 5])\\n    [1, 2, 3, 4, 5]\\n    >>> exchange_sort([0, 10, -2, 5, 3])\\n    [-2, 0, 3, 5, 10]\\n    >>> exchange_sort([])\\n    []\\n    \\\"\\\"\\\"\\n    numbers_length = len(numbers)\\n    for i in range(numbers_length):\\n        for j in range(i + 1, numbers_length):\\n            if numbers[j] < numbers[i]:\\n                numbers[i], numbers[j] = numbers[j], numbers[i]\\n    return numbers\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(exchange_sort(unsorted))\\n\"",
    "external sort": "\"#!/usr/bin/env python\\n\\n#\\n# Sort large text files in a minimum amount of memory\\n#\\nimport argparse\\nimport os\\n\\n\\nclass FileSplitter:\\n    BLOCK_FILENAME_FORMAT = \\\"block_{0}.dat\\\"\\n\\n    def __init__(self, filename):\\n        self.filename = filename\\n        self.block_filenames = []\\n\\n    def write_block(self, data, block_number):\\n        filename = self.BLOCK_FILENAME_FORMAT.format(block_number)\\n        with open(filename, \\\"w\\\") as file:\\n            file.write(data)\\n        self.block_filenames.append(filename)\\n\\n    def get_block_filenames(self):\\n        return self.block_filenames\\n\\n    def split(self, block_size, sort_key=None):\\n        i = 0\\n        with open(self.filename) as file:\\n            while True:\\n                lines = file.readlines(block_size)\\n\\n                if lines == []:\\n                    break\\n\\n                if sort_key is None:\\n                    lines.sort()\\n                else:\\n                    lines.sort(key=sort_key)\\n\\n                self.write_block(\\\"\\\".join(lines), i)\\n                i += 1\\n\\n    def cleanup(self):\\n        map(lambda f: os.remove(f), self.block_filenames)\\n\\n\\nclass NWayMerge:\\n    def select(self, choices):\\n        min_index = -1\\n        min_str = None\\n\\n        for i in range(len(choices)):\\n            if min_str is None or choices[i] < min_str:\\n                min_index = i\\n\\n        return min_index\\n\\n\\nclass FilesArray:\\n    def __init__(self, files):\\n        self.files = files\\n        self.empty = set()\\n        self.num_buffers = len(files)\\n        self.buffers = {i: None for i in range(self.num_buffers)}\\n\\n    def get_dict(self):\\n        return {\\n            i: self.buffers[i] for i in range(self.num_buffers) if i not in self.empty\\n        }\\n\\n    def refresh(self):\\n        for i in range(self.num_buffers):\\n            if self.buffers[i] is None and i not in self.empty:\\n                self.buffers[i] = self.files[i].readline()\\n\\n                if self.buffers[i] == \\\"\\\":\\n                    self.empty.add(i)\\n                    self.files[i].close()\\n\\n        if len(self.empty) == self.num_buffers:\\n            return False\\n\\n        return True\\n\\n    def unshift(self, index):\\n        value = self.buffers[index]\\n        self.buffers[index] = None\\n\\n        return value\\n\\n\\nclass FileMerger:\\n    def __init__(self, merge_strategy):\\n        self.merge_strategy = merge_strategy\\n\\n    def merge(self, filenames, outfilename, buffer_size):\\n        buffers = FilesArray(self.get_file_handles(filenames, buffer_size))\\n        with open(outfilename, \\\"w\\\", buffer_size) as outfile:\\n            while buffers.refresh():\\n                min_index = self.merge_strategy.select(buffers.get_dict())\\n                outfile.write(buffers.unshift(min_index))\\n\\n    def get_file_handles(self, filenames, buffer_size):\\n        files = {}\\n\\n        for i in range(len(filenames)):\\n            files[i] = open(filenames[i], \\\"r\\\", buffer_size)\\n\\n        return files\\n\\n\\nclass ExternalSort:\\n    def __init__(self, block_size):\\n        self.block_size = block_size\\n\\n    def sort(self, filename, sort_key=None):\\n        num_blocks = self.get_number_blocks(filename, self.block_size)\\n        splitter = FileSplitter(filename)\\n        splitter.split(self.block_size, sort_key)\\n\\n        merger = FileMerger(NWayMerge())\\n        buffer_size = self.block_size / (num_blocks + 1)\\n        merger.merge(splitter.get_block_filenames(), filename + \\\".out\\\", buffer_size)\\n\\n        splitter.cleanup()\\n\\n    def get_number_blocks(self, filename, block_size):\\n        return (os.stat(filename).st_size / block_size) + 1\\n\\n\\ndef parse_memory(string):\\n    if string[-1].lower() == \\\"k\\\":\\n        return int(string[:-1]) * 1024\\n    elif string[-1].lower() == \\\"m\\\":\\n        return int(string[:-1]) * 1024 * 1024\\n    elif string[-1].lower() == \\\"g\\\":\\n        return int(string[:-1]) * 1024 * 1024 * 1024\\n    else:\\n        return int(string)\\n\\n\\ndef main():\\n    parser = argparse.ArgumentParser()\\n    parser.add_argument(\\n        \\\"-m\\\", \\\"--mem\\\", help=\\\"amount of memory to use for sorting\\\", default=\\\"100M\\\"\\n    )\\n    parser.add_argument(\\n        \\\"filename\\\", metavar=\\\"<filename>\\\", nargs=1, help=\\\"name of file to sort\\\"\\n    )\\n    args = parser.parse_args()\\n\\n    sorter = ExternalSort(parse_memory(args.mem))\\n    sorter.sort(args.filename[0])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "gnome sort": "\"\\\"\\\"\\\"\\nGnome Sort Algorithm (A.K.A. Stupid Sort)\\n\\nThis algorithm iterates over a list comparing an element with the previous one.\\nIf order is not respected, it swaps element backward until order is respected with\\nprevious element.  It resumes the initial iteration from element new position.\\n\\nFor doctests run following command:\\npython3 -m doctest -v gnome_sort.py\\n\\nFor manual testing run:\\npython3 gnome_sort.py\\n\\\"\\\"\\\"\\n\\n\\ndef gnome_sort(lst: list) -> list:\\n    \\\"\\\"\\\"\\n    Pure implementation of the gnome sort algorithm in Python\\n\\n    Take some mutable ordered collection with heterogeneous comparable items inside as\\n    arguments, return the same collection ordered by ascending.\\n\\n    Examples:\\n    >>> gnome_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n\\n    >>> gnome_sort([])\\n    []\\n\\n    >>> gnome_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n\\n    >>> \\\"\\\".join(gnome_sort(list(set(\\\"Gnomes are stupid!\\\"))))\\n    ' !Gadeimnoprstu'\\n    \\\"\\\"\\\"\\n    if len(lst) <= 1:\\n        return lst\\n\\n    i = 1\\n\\n    while i < len(lst):\\n        if lst[i - 1] <= lst[i]:\\n            i += 1\\n        else:\\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\\n            i -= 1\\n            if i == 0:\\n                i = 1\\n\\n    return lst\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(gnome_sort(unsorted))\\n\"",
    "heap sort": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the heap sort algorithm.\\n\\nFor doctests run following command:\\npython -m doctest -v heap_sort.py\\nor\\npython3 -m doctest -v heap_sort.py\\n\\nFor manual testing run:\\npython heap_sort.py\\n\\\"\\\"\\\"\\n\\n\\ndef heapify(unsorted, index, heap_size):\\n    largest = index\\n    left_index = 2 * index + 1\\n    right_index = 2 * index + 2\\n    if left_index < heap_size and unsorted[left_index] > unsorted[largest]:\\n        largest = left_index\\n\\n    if right_index < heap_size and unsorted[right_index] > unsorted[largest]:\\n        largest = right_index\\n\\n    if largest != index:\\n        unsorted[largest], unsorted[index] = unsorted[index], unsorted[largest]\\n        heapify(unsorted, largest, heap_size)\\n\\n\\ndef heap_sort(unsorted):\\n    \\\"\\\"\\\"\\n    Pure implementation of the heap sort algorithm in Python\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: the same collection ordered by ascending\\n\\n    Examples:\\n    >>> heap_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n\\n    >>> heap_sort([])\\n    []\\n\\n    >>> heap_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n    \\\"\\\"\\\"\\n    n = len(unsorted)\\n    for i in range(n // 2 - 1, -1, -1):\\n        heapify(unsorted, i, n)\\n    for i in range(n - 1, 0, -1):\\n        unsorted[0], unsorted[i] = unsorted[i], unsorted[0]\\n        heapify(unsorted, 0, i)\\n    return unsorted\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(heap_sort(unsorted))\\n\"",
    "insertion sort": "\"\\\"\\\"\\\"\\nA pure Python implementation of the insertion sort algorithm\\n\\nThis algorithm sorts a collection by comparing adjacent elements.\\nWhen it finds that order is not respected, it moves the element compared\\nbackward until the order is correct.  It then goes back directly to the\\nelement's initial position resuming forward comparison.\\n\\nFor doctests run following command:\\npython3 -m doctest -v insertion_sort.py\\n\\nFor manual testing run:\\npython3 insertion_sort.py\\n\\\"\\\"\\\"\\n\\n\\ndef insertion_sort(collection: list) -> list:\\n    \\\"\\\"\\\"A pure Python implementation of the insertion sort algorithm\\n\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: the same collection ordered by ascending\\n\\n    Examples:\\n    >>> insertion_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n    >>> insertion_sort([]) == sorted([])\\n    True\\n    >>> insertion_sort([-2, -5, -45]) == sorted([-2, -5, -45])\\n    True\\n    >>> insertion_sort(['d', 'a', 'b', 'e', 'c']) == sorted(['d', 'a', 'b', 'e', 'c'])\\n    True\\n    >>> import random\\n    >>> collection = random.sample(range(-50, 50), 100)\\n    >>> insertion_sort(collection) == sorted(collection)\\n    True\\n    >>> import string\\n    >>> collection = random.choices(string.ascii_letters + string.digits, k=100)\\n    >>> insertion_sort(collection) == sorted(collection)\\n    True\\n    \\\"\\\"\\\"\\n\\n    for insert_index, insert_value in enumerate(collection[1:]):\\n        temp_index = insert_index\\n        while insert_index >= 0 and insert_value < collection[insert_index]:\\n            collection[insert_index + 1] = collection[insert_index]\\n            insert_index -= 1\\n        if insert_index != temp_index:\\n            collection[insert_index + 1] = insert_value\\n    return collection\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(f\\\"{insertion_sort(unsorted) = }\\\")\\n\"",
    "intro sort": "\"\\\"\\\"\\\"\\nIntrospective Sort is hybrid sort (Quick Sort + Heap Sort + Insertion Sort)\\nif the size of the list is under 16, use insertion sort\\nhttps://en.wikipedia.org/wiki/Introsort\\n\\\"\\\"\\\"\\nimport math\\n\\n\\ndef insertion_sort(array: list, start: int = 0, end: int = 0) -> list:\\n    \\\"\\\"\\\"\\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\\n\\n    >>> insertion_sort(array, 0, len(array))\\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\\n    \\\"\\\"\\\"\\n    end = end or len(array)\\n    for i in range(start, end):\\n        temp_index = i\\n        temp_index_value = array[i]\\n        while temp_index != start and temp_index_value < array[temp_index - 1]:\\n            array[temp_index] = array[temp_index - 1]\\n            temp_index -= 1\\n        array[temp_index] = temp_index_value\\n    return array\\n\\n\\ndef heapify(array: list, index: int, heap_size: int) -> None:  # Max Heap\\n    \\\"\\\"\\\"\\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\\n\\n    >>> heapify(array, len(array) // 2 ,len(array))\\n    \\\"\\\"\\\"\\n    largest = index\\n    left_index = 2 * index + 1  # Left Node\\n    right_index = 2 * index + 2  # Right Node\\n\\n    if left_index < heap_size and array[largest] < array[left_index]:\\n        largest = left_index\\n\\n    if right_index < heap_size and array[largest] < array[right_index]:\\n        largest = right_index\\n\\n    if largest != index:\\n        array[index], array[largest] = array[largest], array[index]\\n        heapify(array, largest, heap_size)\\n\\n\\ndef heap_sort(array: list) -> list:\\n    \\\"\\\"\\\"\\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\\n\\n    >>> heap_sort(array)\\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\\n    \\\"\\\"\\\"\\n    n = len(array)\\n\\n    for i in range(n // 2, -1, -1):\\n        heapify(array, i, n)\\n\\n    for i in range(n - 1, 0, -1):\\n        array[i], array[0] = array[0], array[i]\\n        heapify(array, 0, i)\\n\\n    return array\\n\\n\\ndef median_of_3(\\n    array: list, first_index: int, middle_index: int, last_index: int\\n) -> int:\\n    \\\"\\\"\\\"\\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\\n\\n    >>> median_of_3(array, 0, 0 + ((len(array) - 0) // 2) + 1, len(array) - 1)\\n    12\\n    \\\"\\\"\\\"\\n    if (array[first_index] > array[middle_index]) != (\\n        array[first_index] > array[last_index]\\n    ):\\n        return array[first_index]\\n    elif (array[middle_index] > array[first_index]) != (\\n        array[middle_index] > array[last_index]\\n    ):\\n        return array[middle_index]\\n    else:\\n        return array[last_index]\\n\\n\\ndef partition(array: list, low: int, high: int, pivot: int) -> int:\\n    \\\"\\\"\\\"\\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\\n\\n    >>> partition(array, 0, len(array), 12)\\n    8\\n    \\\"\\\"\\\"\\n    i = low\\n    j = high\\n    while True:\\n        while array[i] < pivot:\\n            i += 1\\n        j -= 1\\n        while pivot < array[j]:\\n            j -= 1\\n        if i >= j:\\n            return i\\n        array[i], array[j] = array[j], array[i]\\n        i += 1\\n\\n\\ndef sort(array: list) -> list:\\n    \\\"\\\"\\\"\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: the same collection ordered by ascending\\n\\n    Examples:\\n    >>> sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])\\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\\n\\n    >>> sort([-1, -5, -3, -13, -44])\\n    [-44, -13, -5, -3, -1]\\n\\n    >>> sort([])\\n    []\\n\\n    >>> sort([5])\\n    [5]\\n\\n    >>> sort([-3, 0, -7, 6, 23, -34])\\n    [-34, -7, -3, 0, 6, 23]\\n\\n    >>> sort([1.7, 1.0, 3.3, 2.1, 0.3 ])\\n    [0.3, 1.0, 1.7, 2.1, 3.3]\\n\\n    >>> sort(['d', 'a', 'b', 'e', 'c'])\\n    ['a', 'b', 'c', 'd', 'e']\\n    \\\"\\\"\\\"\\n    if len(array) == 0:\\n        return array\\n    max_depth = 2 * math.ceil(math.log2(len(array)))\\n    size_threshold = 16\\n    return intro_sort(array, 0, len(array), size_threshold, max_depth)\\n\\n\\ndef intro_sort(\\n    array: list, start: int, end: int, size_threshold: int, max_depth: int\\n) -> list:\\n    \\\"\\\"\\\"\\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\\n\\n    >>> max_depth = 2 * math.ceil(math.log2(len(array)))\\n\\n    >>> intro_sort(array, 0, len(array), 16, max_depth)\\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\\n    \\\"\\\"\\\"\\n    while end - start > size_threshold:\\n        if max_depth == 0:\\n            return heap_sort(array)\\n        max_depth -= 1\\n        pivot = median_of_3(array, start, start + ((end - start) // 2) + 1, end - 1)\\n        p = partition(array, start, end, pivot)\\n        intro_sort(array, p, end, size_threshold, max_depth)\\n        end = p\\n    return insertion_sort(array, start, end)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    user_input = input(\\\"Enter numbers separated by a comma : \\\").strip()\\n    unsorted = [float(item) for item in user_input.split(\\\",\\\")]\\n    print(sort(unsorted))\\n\"",
    "iterative merge sort": "\"\\\"\\\"\\\"\\nImplementation of iterative merge sort in Python\\nAuthor: Aman Gupta\\n\\nFor doctests run following command:\\npython3 -m doctest -v iterative_merge_sort.py\\n\\nFor manual testing run:\\npython3 iterative_merge_sort.py\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\n\\ndef merge(input_list: list, low: int, mid: int, high: int) -> list:\\n    \\\"\\\"\\\"\\n    sorting left-half and right-half individually\\n    then merging them into result\\n    \\\"\\\"\\\"\\n    result = []\\n    left, right = input_list[low:mid], input_list[mid : high + 1]\\n    while left and right:\\n        result.append((left if left[0] <= right[0] else right).pop(0))\\n    input_list[low : high + 1] = result + left + right\\n    return input_list\\n\\n\\n# iteration over the unsorted list\\ndef iter_merge_sort(input_list: list) -> list:\\n    \\\"\\\"\\\"\\n    Return a sorted copy of the input list\\n\\n    >>> iter_merge_sort([5, 9, 8, 7, 1, 2, 7])\\n    [1, 2, 5, 7, 7, 8, 9]\\n    >>> iter_merge_sort([6])\\n    [6]\\n    >>> iter_merge_sort([])\\n    []\\n    >>> iter_merge_sort([-2, -9, -1, -4])\\n    [-9, -4, -2, -1]\\n    >>> iter_merge_sort([1.1, 1, 0.0, -1, -1.1])\\n    [-1.1, -1, 0.0, 1, 1.1]\\n    >>> iter_merge_sort(['c', 'b', 'a'])\\n    ['a', 'b', 'c']\\n    >>> iter_merge_sort('cba')\\n    ['a', 'b', 'c']\\n    \\\"\\\"\\\"\\n    if len(input_list) <= 1:\\n        return input_list\\n    input_list = list(input_list)\\n\\n    # iteration for two-way merging\\n    p = 2\\n    while p < len(input_list):\\n        # getting low, high and middle value for merge-sort of single list\\n        for i in range(0, len(input_list), p):\\n            low = i\\n            high = i + p - 1\\n            mid = (low + high + 1) // 2\\n            input_list = merge(input_list, low, mid, high)\\n        # final merge of last two parts\\n        if p * 2 >= len(input_list):\\n            mid = i\\n            input_list = merge(input_list, 0, mid, len(input_list) - 1)\\n        p *= 2\\n\\n    return input_list\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item.strip()) for item in user_input.split(\\\",\\\")]\\n    print(iter_merge_sort(unsorted))\\n\"",
    "merge insertion sort": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the merge-insertion sort algorithm\\nSource: https://en.wikipedia.org/wiki/Merge-insertion_sort\\n\\nFor doctests run following command:\\npython3 -m doctest -v merge_insertion_sort.py\\nor\\npython -m doctest -v merge_insertion_sort.py\\n\\nFor manual testing run:\\npython3 merge_insertion_sort.py\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\n\\ndef merge_insertion_sort(collection: list[int]) -> list[int]:\\n    \\\"\\\"\\\"Pure implementation of merge-insertion sort algorithm in Python\\n\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: the same collection ordered by ascending\\n\\n    Examples:\\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n\\n    >>> merge_insertion_sort([99])\\n    [99]\\n\\n    >>> merge_insertion_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n    \\\"\\\"\\\"\\n\\n    def binary_search_insertion(sorted_list, item):\\n        left = 0\\n        right = len(sorted_list) - 1\\n        while left <= right:\\n            middle = (left + right) // 2\\n            if left == right:\\n                if sorted_list[middle] < item:\\n                    left = middle + 1\\n                break\\n            elif sorted_list[middle] < item:\\n                left = middle + 1\\n            else:\\n                right = middle - 1\\n        sorted_list.insert(left, item)\\n        return sorted_list\\n\\n    def sortlist_2d(list_2d):\\n        def merge(left, right):\\n            result = []\\n            while left and right:\\n                if left[0][0] < right[0][0]:\\n                    result.append(left.pop(0))\\n                else:\\n                    result.append(right.pop(0))\\n            return result + left + right\\n\\n        length = len(list_2d)\\n        if length <= 1:\\n            return list_2d\\n        middle = length // 2\\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\\n\\n    if len(collection) <= 1:\\n        return collection\\n\\n    \\\"\\\"\\\"\\n    Group the items into two pairs, and leave one element if there is a last odd item.\\n\\n    Example: [999, 100, 75, 40, 10000]\\n                -> [999, 100], [75, 40]. Leave 10000.\\n    \\\"\\\"\\\"\\n    two_paired_list = []\\n    has_last_odd_item = False\\n    for i in range(0, len(collection), 2):\\n        if i == len(collection) - 1:\\n            has_last_odd_item = True\\n        else:\\n            \\\"\\\"\\\"\\n            Sort two-pairs in each groups.\\n\\n            Example: [999, 100], [75, 40]\\n                        -> [100, 999], [40, 75]\\n            \\\"\\\"\\\"\\n            if collection[i] < collection[i + 1]:\\n                two_paired_list.append([collection[i], collection[i + 1]])\\n            else:\\n                two_paired_list.append([collection[i + 1], collection[i]])\\n\\n    \\\"\\\"\\\"\\n    Sort two_paired_list.\\n\\n    Example: [100, 999], [40, 75]\\n                -> [40, 75], [100, 999]\\n    \\\"\\\"\\\"\\n    sorted_list_2d = sortlist_2d(two_paired_list)\\n\\n    \\\"\\\"\\\"\\n    40 < 100 is sure because it has already been sorted.\\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\\n\\n    Example:\\n           group0 group1\\n           40     100\\n           75     999\\n        ->\\n           group0 group1\\n           [40,   100]\\n           75     999\\n    \\\"\\\"\\\"\\n    result = [i[0] for i in sorted_list_2d]\\n\\n    \\\"\\\"\\\"\\n    100 < 999 is sure because it has already been sorted.\\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\\n\\n    Example:\\n           group0 group1\\n           [40,   100]\\n           75     999\\n        ->\\n           group0 group1\\n           [40,   100,   999]\\n           75\\n    \\\"\\\"\\\"\\n    result.append(sorted_list_2d[-1][1])\\n\\n    \\\"\\\"\\\"\\n    Insert the last odd item left if there is.\\n\\n    Example:\\n           group0 group1\\n           [40,   100,   999]\\n           75\\n        ->\\n           group0 group1\\n           [40,   100,   999,   10000]\\n           75\\n    \\\"\\\"\\\"\\n    if has_last_odd_item:\\n        pivot = collection[-1]\\n        result = binary_search_insertion(result, pivot)\\n\\n    \\\"\\\"\\\"\\n    Insert the remaining items.\\n    In this case, 40 < 75 is sure because it has already been sorted.\\n    Therefore, you only need to insert 75 into [100, 999, 10000],\\n    so that you can avoid unnecessary comparison.\\n\\n    Example:\\n           group0 group1\\n           [40,   100,   999,   10000]\\n            ^ You don't need to compare with this as 40 < 75 is already sure.\\n           75\\n        ->\\n           [40,   75,    100,   999,   10000]\\n    \\\"\\\"\\\"\\n    is_last_odd_item_inserted_before_this_index = False\\n    for i in range(len(sorted_list_2d) - 1):\\n        if result[i] == collection[-i]:\\n            is_last_odd_item_inserted_before_this_index = True\\n        pivot = sorted_list_2d[i][1]\\n        # If last_odd_item is inserted before the item's index,\\n        # you should forward index one more.\\n        if is_last_odd_item_inserted_before_this_index:\\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\\n        else:\\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\\n\\n    return result\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(merge_insertion_sort(unsorted))\\n\"",
    "merge sort": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the merge sort algorithm\\nFor doctests run following command:\\npython -m doctest -v merge_sort.py\\nor\\npython3 -m doctest -v merge_sort.py\\nFor manual testing run:\\npython merge_sort.py\\n\\\"\\\"\\\"\\n\\n\\ndef merge_sort(collection: list) -> list:\\n    \\\"\\\"\\\"Pure implementation of the merge sort algorithm in Python\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: the same collection ordered by ascending\\n    Examples:\\n    >>> merge_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n    >>> merge_sort([])\\n    []\\n    >>> merge_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n    \\\"\\\"\\\"\\n\\n    def merge(left: list, right: list) -> list:\\n        \\\"\\\"\\\"merge left and right\\n        :param left: left collection\\n        :param right: right collection\\n        :return: merge result\\n        \\\"\\\"\\\"\\n\\n        def _merge():\\n            while left and right:\\n                yield (left if left[0] <= right[0] else right).pop(0)\\n            yield from left\\n            yield from right\\n\\n        return list(_merge())\\n\\n    if len(collection) <= 1:\\n        return collection\\n    mid = len(collection) // 2\\n    return merge(merge_sort(collection[:mid]), merge_sort(collection[mid:]))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(*merge_sort(unsorted), sep=\\\",\\\")\\n\"",
    "msd radix sort": "\"\\\"\\\"\\\"\\nPython implementation of the MSD radix sort algorithm.\\nIt used the binary representation of the integers to sort\\nthem.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef msd_radix_sort(list_of_ints: list[int]) -> list[int]:\\n    \\\"\\\"\\\"\\n    Implementation of the MSD radix sort algorithm. Only works\\n    with positive integers\\n    :param list_of_ints: A list of integers\\n    :return: Returns the sorted list\\n    >>> msd_radix_sort([40, 12, 1, 100, 4])\\n    [1, 4, 12, 40, 100]\\n    >>> msd_radix_sort([])\\n    []\\n    >>> msd_radix_sort([123, 345, 123, 80])\\n    [80, 123, 123, 345]\\n    >>> msd_radix_sort([1209, 834598, 1, 540402, 45])\\n    [1, 45, 1209, 540402, 834598]\\n    >>> msd_radix_sort([-1, 34, 45])\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: All numbers must be positive\\n    \\\"\\\"\\\"\\n    if not list_of_ints:\\n        return []\\n\\n    if min(list_of_ints) < 0:\\n        raise ValueError(\\\"All numbers must be positive\\\")\\n\\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\\n    return _msd_radix_sort(list_of_ints, most_bits)\\n\\n\\ndef _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\\n    \\\"\\\"\\\"\\n    Sort the given list based on the bit at bit_position. Numbers with a\\n    0 at that position will be at the start of the list, numbers with a\\n    1 at the end.\\n    :param list_of_ints: A list of integers\\n    :param bit_position: the position of the bit that gets compared\\n    :return: Returns a partially sorted list\\n    >>> _msd_radix_sort([45, 2, 32], 1)\\n    [2, 32, 45]\\n    >>> _msd_radix_sort([10, 4, 12], 2)\\n    [4, 12, 10]\\n    \\\"\\\"\\\"\\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\\n        return list_of_ints\\n\\n    zeros = list()\\n    ones = list()\\n    # Split numbers based on bit at bit_position from the right\\n    for number in list_of_ints:\\n        if (number >> (bit_position - 1)) & 1:\\n            # number has a one at bit bit_position\\n            ones.append(number)\\n        else:\\n            # number has a zero at bit bit_position\\n            zeros.append(number)\\n\\n    # recursively split both lists further\\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\\n    ones = _msd_radix_sort(ones, bit_position - 1)\\n\\n    # recombine lists\\n    res = zeros\\n    res.extend(ones)\\n\\n    return res\\n\\n\\ndef msd_radix_sort_inplace(list_of_ints: list[int]):\\n    \\\"\\\"\\\"\\n    Inplace implementation of the MSD radix sort algorithm.\\n    Sorts based on the binary representation of the integers.\\n    >>> lst = [1, 345, 23, 89, 0, 3]\\n    >>> msd_radix_sort_inplace(lst)\\n    >>> lst == sorted(lst)\\n    True\\n    >>> lst = [1, 43, 0, 0, 0, 24, 3, 3]\\n    >>> msd_radix_sort_inplace(lst)\\n    >>> lst == sorted(lst)\\n    True\\n    >>> lst = []\\n    >>> msd_radix_sort_inplace(lst)\\n    >>> lst == []\\n    True\\n    >>> lst = [-1, 34, 23, 4, -42]\\n    >>> msd_radix_sort_inplace(lst)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: All numbers must be positive\\n    \\\"\\\"\\\"\\n\\n    length = len(list_of_ints)\\n    if not list_of_ints or length == 1:\\n        return\\n\\n    if min(list_of_ints) < 0:\\n        raise ValueError(\\\"All numbers must be positive\\\")\\n\\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\\n    _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)\\n\\n\\ndef _msd_radix_sort_inplace(\\n    list_of_ints: list[int], bit_position: int, begin_index: int, end_index: int\\n):\\n    \\\"\\\"\\\"\\n    Sort the given list based on the bit at bit_position. Numbers with a\\n    0 at that position will be at the start of the list, numbers with a\\n    1 at the end.\\n    >>> lst = [45, 2, 32, 24, 534, 2932]\\n    >>> _msd_radix_sort_inplace(lst, 1, 0, 3)\\n    >>> lst == [32, 2, 45, 24, 534, 2932]\\n    True\\n    >>> lst = [0, 2, 1, 3, 12, 10, 4, 90, 54, 2323, 756]\\n    >>> _msd_radix_sort_inplace(lst, 2, 4, 7)\\n    >>> lst == [0, 2, 1, 3, 12, 4, 10, 90, 54, 2323, 756]\\n    True\\n    \\\"\\\"\\\"\\n    if bit_position == 0 or end_index - begin_index <= 1:\\n        return\\n\\n    bit_position -= 1\\n\\n    i = begin_index\\n    j = end_index - 1\\n    while i <= j:\\n        changed = False\\n        if not ((list_of_ints[i] >> bit_position) & 1):\\n            # found zero at the beginning\\n            i += 1\\n            changed = True\\n        if (list_of_ints[j] >> bit_position) & 1:\\n            # found one at the end\\n            j -= 1\\n            changed = True\\n\\n        if changed:\\n            continue\\n\\n        list_of_ints[i], list_of_ints[j] = list_of_ints[j], list_of_ints[i]\\n        j -= 1\\n        if not j == i:\\n            i += 1\\n\\n    _msd_radix_sort_inplace(list_of_ints, bit_position, begin_index, i)\\n    _msd_radix_sort_inplace(list_of_ints, bit_position, i, end_index)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "natural sort": "\"from __future__ import annotations\\n\\nimport re\\n\\n\\ndef natural_sort(input_list: list[str]) -> list[str]:\\n    \\\"\\\"\\\"\\n    Sort the given list of strings in the way that humans expect.\\n\\n    The normal Python sort algorithm sorts lexicographically,\\n    so you might not get the results that you expect...\\n\\n    >>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in']\\n    >>> sorted(example1)\\n    ['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in']\\n    >>> # The natural sort algorithm sort based on meaning and not computer code point.\\n    >>> natural_sort(example1)\\n    ['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']\\n\\n    >>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']\\n    >>> sorted(example2)\\n    ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']\\n    >>> natural_sort(example2)\\n    ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']\\n    \\\"\\\"\\\"\\n\\n    def alphanum_key(key):\\n        return [int(s) if s.isdigit() else s.lower() for s in re.split(\\\"([0-9]+)\\\", key)]\\n\\n    return sorted(input_list, key=alphanum_key)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "odd even sort": "\"\\\"\\\"\\\"For reference\\nhttps://en.wikipedia.org/wiki/Odd%E2%80%93even_sort\\n\\\"\\\"\\\"\\n\\n\\ndef odd_even_sort(input_list: list) -> list:\\n    \\\"\\\"\\\"this algorithm uses the same idea of bubblesort,\\n    but by first dividing in two phase (odd and even).\\n    Originally developed for use on parallel processors\\n    with local interconnections.\\n    :param collection: mutable ordered sequence of elements\\n    :return: same collection in ascending order\\n    Examples:\\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\\n    [1, 2, 3, 4, 5]\\n    >>> odd_even_sort([])\\n    []\\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\\n    [-10, -1, 2, 10]\\n    >>> odd_even_sort([1 ,2 ,3 ,4])\\n    [1, 2, 3, 4]\\n    \\\"\\\"\\\"\\n    sorted = False\\n    while sorted is False:  # Until all the indices are traversed keep looping\\n        sorted = True\\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\\n            if input_list[i] > input_list[i + 1]:\\n\\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\\n                # swapping if elements not in order\\n                sorted = False\\n\\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\\n            if input_list[i] > input_list[i + 1]:\\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\\n                # swapping if elements not in order\\n                sorted = False\\n    return input_list\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"Enter list to be sorted\\\")\\n    input_list = [int(x) for x in input().split()]\\n    # inputing elements of the list in one line\\n    sorted_list = odd_even_sort(input_list)\\n    print(\\\"The sorted list is\\\")\\n    print(sorted_list)\\n\"",
    "odd even transposition parallel": "\"\\\"\\\"\\\"\\nThis is an implementation of odd-even transposition sort.\\n\\nIt works by performing a series of parallel swaps between odd and even pairs of\\nvariables in the list.\\n\\nThis implementation represents each variable in the list with a process and\\neach process communicates with its neighboring processes in the list to perform\\ncomparisons.\\nThey are synchronized with locks and message passing but other forms of\\nsynchronization could be used.\\n\\\"\\\"\\\"\\nfrom multiprocessing import Lock, Pipe, Process\\n\\n# lock used to ensure that two processes do not access a pipe at the same time\\nprocessLock = Lock()\\n\\n\\\"\\\"\\\"\\nThe function run by the processes that sorts the list\\n\\nposition = the position in the list the process represents, used to know which\\n            neighbor we pass our value to\\nvalue = the initial value at list[position]\\nLSend, RSend = the pipes we use to send to our left and right neighbors\\nLRcv, RRcv = the pipes we use to receive from our left and right neighbors\\nresultPipe = the pipe used to send results back to main\\n\\\"\\\"\\\"\\n\\n\\ndef oeProcess(position, value, LSend, RSend, LRcv, RRcv, resultPipe):\\n    global processLock\\n\\n    # we perform n swaps since after n swaps we know we are sorted\\n    # we *could* stop early if we are sorted already, but it takes as long to\\n    # find out we are sorted as it does to sort the list with this algorithm\\n    for i in range(0, 10):\\n\\n        if (i + position) % 2 == 0 and RSend is not None:\\n            # send your value to your right neighbor\\n            processLock.acquire()\\n            RSend[1].send(value)\\n            processLock.release()\\n\\n            # receive your right neighbor's value\\n            processLock.acquire()\\n            temp = RRcv[0].recv()\\n            processLock.release()\\n\\n            # take the lower value since you are on the left\\n            value = min(value, temp)\\n        elif (i + position) % 2 != 0 and LSend is not None:\\n            # send your value to your left neighbor\\n            processLock.acquire()\\n            LSend[1].send(value)\\n            processLock.release()\\n\\n            # receive your left neighbor's value\\n            processLock.acquire()\\n            temp = LRcv[0].recv()\\n            processLock.release()\\n\\n            # take the higher value since you are on the right\\n            value = max(value, temp)\\n    # after all swaps are performed, send the values back to main\\n    resultPipe[1].send(value)\\n\\n\\n\\\"\\\"\\\"\\nthe function which creates the processes that perform the parallel swaps\\n\\narr = the list to be sorted\\n\\\"\\\"\\\"\\n\\n\\ndef OddEvenTransposition(arr):\\n    processArray = []\\n    resultPipe = []\\n    # initialize the list of pipes where the values will be retrieved\\n    for _ in arr:\\n        resultPipe.append(Pipe())\\n    # creates the processes\\n    # the first and last process only have one neighbor so they are made outside\\n    # of the loop\\n    tempRs = Pipe()\\n    tempRr = Pipe()\\n    processArray.append(\\n        Process(\\n            target=oeProcess,\\n            args=(0, arr[0], None, tempRs, None, tempRr, resultPipe[0]),\\n        )\\n    )\\n    tempLr = tempRs\\n    tempLs = tempRr\\n\\n    for i in range(1, len(arr) - 1):\\n        tempRs = Pipe()\\n        tempRr = Pipe()\\n        processArray.append(\\n            Process(\\n                target=oeProcess,\\n                args=(i, arr[i], tempLs, tempRs, tempLr, tempRr, resultPipe[i]),\\n            )\\n        )\\n        tempLr = tempRs\\n        tempLs = tempRr\\n\\n    processArray.append(\\n        Process(\\n            target=oeProcess,\\n            args=(\\n                len(arr) - 1,\\n                arr[len(arr) - 1],\\n                tempLs,\\n                None,\\n                tempLr,\\n                None,\\n                resultPipe[len(arr) - 1],\\n            ),\\n        )\\n    )\\n\\n    # start the processes\\n    for p in processArray:\\n        p.start()\\n\\n    # wait for the processes to end and write their values to the list\\n    for p in range(0, len(resultPipe)):\\n        arr[p] = resultPipe[p][0].recv()\\n        processArray[p].join()\\n    return arr\\n\\n\\n# creates a reverse sorted list and sorts it\\ndef main():\\n    arr = list(range(10, 0, -1))\\n    print(\\\"Initial List\\\")\\n    print(*arr)\\n    arr = OddEvenTransposition(arr)\\n    print(\\\"Sorted List\\\\n\\\")\\n    print(*arr)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "odd even transposition single threaded": "\"\\\"\\\"\\\"\\nSource: https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort\\n\\nThis is a non-parallelized implementation of odd-even transposition sort.\\n\\nNormally the swaps in each set happen simultaneously, without that the algorithm\\nis no better than bubble sort.\\n\\\"\\\"\\\"\\n\\n\\ndef odd_even_transposition(arr: list) -> list:\\n    \\\"\\\"\\\"\\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\\n    [1, 2, 3, 4, 5]\\n\\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\\n    [-1, 0, 11, 13, 18]\\n\\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\\n    [-2.9, -0.1, 0.1, 1.1]\\n    \\\"\\\"\\\"\\n    arr_size = len(arr)\\n    for _ in range(arr_size):\\n        for i in range(_ % 2, arr_size - 1, 2):\\n            if arr[i + 1] < arr[i]:\\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\\n\\n    return arr\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    arr = list(range(10, 0, -1))\\n    print(f\\\"Original: {arr}. Sorted: {odd_even_transposition(arr)}\\\")\\n\"",
    "pancake sort": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the pancake sort algorithm\\nFor doctests run following command:\\npython3 -m doctest -v pancake_sort.py\\nor\\npython -m doctest -v pancake_sort.py\\nFor manual testing run:\\npython pancake_sort.py\\n\\\"\\\"\\\"\\n\\n\\ndef pancake_sort(arr):\\n    \\\"\\\"\\\"Sort Array with Pancake Sort.\\n    :param arr: Collection containing comparable items\\n    :return: Collection ordered in ascending order of items\\n    Examples:\\n    >>> pancake_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n    >>> pancake_sort([])\\n    []\\n    >>> pancake_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n    \\\"\\\"\\\"\\n    cur = len(arr)\\n    while cur > 1:\\n        # Find the maximum number in arr\\n        mi = arr.index(max(arr[0:cur]))\\n        # Reverse from 0 to mi\\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\\n        # Reverse whole list\\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\\n        cur -= 1\\n    return arr\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(pancake_sort(unsorted))\\n\"",
    "patience sort": "\"from __future__ import annotations\\n\\nfrom bisect import bisect_left\\nfrom functools import total_ordering\\nfrom heapq import merge\\n\\n\\\"\\\"\\\"\\nA pure Python implementation of the patience sort algorithm\\n\\nFor more information: https://en.wikipedia.org/wiki/Patience_sorting\\n\\nThis algorithm is based on the card game patience\\n\\nFor doctests run following command:\\npython3 -m doctest -v patience_sort.py\\n\\nFor manual testing run:\\npython3 patience_sort.py\\n\\\"\\\"\\\"\\n\\n\\n@total_ordering\\nclass Stack(list):\\n    def __lt__(self, other):\\n        return self[-1] < other[-1]\\n\\n    def __eq__(self, other):\\n        return self[-1] == other[-1]\\n\\n\\ndef patience_sort(collection: list) -> list:\\n    \\\"\\\"\\\"A pure implementation of patience sort algorithm in Python\\n\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: the same collection ordered by ascending\\n\\n    Examples:\\n    >>> patience_sort([1, 9, 5, 21, 17, 6])\\n    [1, 5, 6, 9, 17, 21]\\n\\n    >>> patience_sort([])\\n    []\\n\\n    >>> patience_sort([-3, -17, -48])\\n    [-48, -17, -3]\\n    \\\"\\\"\\\"\\n    stacks: list[Stack] = []\\n    # sort into stacks\\n    for element in collection:\\n        new_stacks = Stack([element])\\n        i = bisect_left(stacks, new_stacks)\\n        if i != len(stacks):\\n            stacks[i].append(element)\\n        else:\\n            stacks.append(new_stacks)\\n\\n    # use a heap-based merge to merge stack efficiently\\n    collection[:] = merge(*(reversed(stack) for stack in stacks))\\n    return collection\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(patience_sort(unsorted))\\n\"",
    "pigeonhole sort": "\"# Python program to implement Pigeonhole Sorting in python\\n\\n# Algorithm for the pigeonhole sorting\\n\\n\\ndef pigeonhole_sort(a):\\n    \\\"\\\"\\\"\\n    >>> a = [8, 3, 2, 7, 4, 6, 8]\\n    >>> b = sorted(a)  # a nondestructive sort\\n    >>> pigeonhole_sort(a)  # a destructive sort\\n    >>> a == b\\n    True\\n    \\\"\\\"\\\"\\n    # size of range of values in the list (ie, number of pigeonholes we need)\\n\\n    min_val = min(a)  # min() finds the minimum value\\n    max_val = max(a)  # max() finds the maximum value\\n\\n    size = max_val - min_val + 1  # size is difference of max and min values plus one\\n\\n    # list of pigeonholes of size equal to the variable size\\n    holes = [0] * size\\n\\n    # Populate the pigeonholes.\\n    for x in a:\\n        assert isinstance(x, int), \\\"integers only please\\\"\\n        holes[x - min_val] += 1\\n\\n    # Putting the elements back into the array in an order.\\n    i = 0\\n    for count in range(size):\\n        while holes[count] > 0:\\n            holes[count] -= 1\\n            a[i] = count + min_val\\n            i += 1\\n\\n\\ndef main():\\n    a = [8, 3, 2, 7, 4, 6, 8]\\n    pigeonhole_sort(a)\\n    print(\\\"Sorted order is:\\\", \\\" \\\".join(a))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "pigeon sort": "\"\\\"\\\"\\\"\\n    This is an implementation of Pigeon Hole Sort.\\n    For doctests run following command:\\n\\n    python3 -m doctest -v pigeon_sort.py\\n    or\\n    python -m doctest -v pigeon_sort.py\\n\\n    For manual testing run:\\n    python pigeon_sort.py\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef pigeon_sort(array: list[int]) -> list[int]:\\n    \\\"\\\"\\\"\\n    Implementation of pigeon hole sort algorithm\\n    :param array: Collection of comparable items\\n    :return: Collection sorted in ascending order\\n    >>> pigeon_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n    >>> pigeon_sort([])\\n    []\\n    >>> pigeon_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n    \\\"\\\"\\\"\\n    if len(array) == 0:\\n        return array\\n\\n    _min, _max = min(array), max(array)\\n\\n    # Compute the variables\\n    holes_range = _max - _min + 1\\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\\n\\n    # Make the sorting.\\n    for i in array:\\n        index = i - _min\\n        holes[index] = i\\n        holes_repeat[index] += 1\\n\\n    # Makes the array back by replacing the numbers.\\n    index = 0\\n    for i in range(holes_range):\\n        while holes_repeat[i] > 0:\\n            array[index] = holes[i]\\n            index += 1\\n            holes_repeat[i] -= 1\\n\\n    # Returns the sorted array.\\n    return array\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    user_input = input(\\\"Enter numbers separated by comma:\\\\n\\\")\\n    unsorted = [int(x) for x in user_input.split(\\\",\\\")]\\n    print(pigeon_sort(unsorted))\\n\"",
    "quick sort": "\"\\\"\\\"\\\"\\nA pure Python implementation of the quick sort algorithm\\n\\nFor doctests run following command:\\npython3 -m doctest -v quick_sort.py\\n\\nFor manual testing run:\\npython3 quick_sort.py\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef quick_sort(collection: list) -> list:\\n    \\\"\\\"\\\"A pure Python implementation of quick sort algorithm\\n\\n    :param collection: a mutable collection of comparable items\\n    :return: the same collection ordered by ascending\\n\\n    Examples:\\n    >>> quick_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n    >>> quick_sort([])\\n    []\\n    >>> quick_sort([-2, 5, 0, -45])\\n    [-45, -2, 0, 5]\\n    \\\"\\\"\\\"\\n    if len(collection) < 2:\\n        return collection\\n    pivot = collection.pop()  # Use the last element as the first pivot\\n    greater: list[int] = []  # All elements greater than pivot\\n    lesser: list[int] = []  # All elements less than or equal to pivot\\n    for element in collection:\\n        (greater if element > pivot else lesser).append(element)\\n    return quick_sort(lesser) + [pivot] + quick_sort(greater)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(quick_sort(unsorted))\\n\"",
    "quick sort 3 partition": "\"def quick_sort_3partition(sorting: list, left: int, right: int) -> None:\\n    if right <= left:\\n        return\\n    a = i = left\\n    b = right\\n    pivot = sorting[left]\\n    while i <= b:\\n        if sorting[i] < pivot:\\n            sorting[a], sorting[i] = sorting[i], sorting[a]\\n            a += 1\\n            i += 1\\n        elif sorting[i] > pivot:\\n            sorting[b], sorting[i] = sorting[i], sorting[b]\\n            b -= 1\\n        else:\\n            i += 1\\n    quick_sort_3partition(sorting, left, a - 1)\\n    quick_sort_3partition(sorting, b + 1, right)\\n\\n\\ndef quick_sort_lomuto_partition(sorting: list, left: int, right: int) -> None:\\n    \\\"\\\"\\\"\\n    A pure Python implementation of quick sort algorithm(in-place)\\n    with Lomuto partition scheme:\\n    https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme\\n\\n    :param sorting: sort list\\n    :param left: left endpoint of sorting\\n    :param right: right endpoint of sorting\\n    :return: None\\n\\n    Examples:\\n    >>> nums1 = [0, 5, 3, 1, 2]\\n    >>> quick_sort_lomuto_partition(nums1, 0, 4)\\n    >>> nums1\\n    [0, 1, 2, 3, 5]\\n    >>> nums2 = []\\n    >>> quick_sort_lomuto_partition(nums2, 0, 0)\\n    >>> nums2\\n    []\\n    >>> nums3 = [-2, 5, 0, -4]\\n    >>> quick_sort_lomuto_partition(nums3, 0, 3)\\n    >>> nums3\\n    [-4, -2, 0, 5]\\n    \\\"\\\"\\\"\\n    if left < right:\\n        pivot_index = lomuto_partition(sorting, left, right)\\n        quick_sort_lomuto_partition(sorting, left, pivot_index - 1)\\n        quick_sort_lomuto_partition(sorting, pivot_index + 1, right)\\n\\n\\ndef lomuto_partition(sorting: list, left: int, right: int) -> int:\\n    \\\"\\\"\\\"\\n    Example:\\n    >>> lomuto_partition([1,5,7,6], 0, 3)\\n    2\\n    \\\"\\\"\\\"\\n    pivot = sorting[right]\\n    store_index = left\\n    for i in range(left, right):\\n        if sorting[i] < pivot:\\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\\n            store_index += 1\\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\\n    return store_index\\n\\n\\ndef three_way_radix_quicksort(sorting: list) -> list:\\n    \\\"\\\"\\\"\\n    Three-way radix quicksort:\\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\\n    First divide the list into three parts.\\n    Then recursively sort the \\\"less than\\\" and \\\"greater than\\\" partitions.\\n\\n    >>> three_way_radix_quicksort([])\\n    []\\n    >>> three_way_radix_quicksort([1])\\n    [1]\\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\\n    [-5, -2, -2, 0, 1, 1]\\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\\n    \\\"\\\"\\\"\\n    if len(sorting) <= 1:\\n        return sorting\\n    return (\\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\\n        + [i for i in sorting if i == sorting[0]]\\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod(verbose=True)\\n\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    quick_sort_3partition(unsorted, 0, len(unsorted) - 1)\\n    print(unsorted)\\n\"",
    "radix sort": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the quick sort algorithm\\nFor doctests run following command:\\npython -m doctest -v radix_sort.py\\nor\\npython3 -m doctest -v radix_sort.py\\nFor manual testing run:\\npython radix_sort.py\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef radix_sort(list_of_ints: list[int]) -> list[int]:\\n    \\\"\\\"\\\"\\n    Examples:\\n    >>> radix_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n\\n    >>> radix_sort(list(range(15))) == sorted(range(15))\\n    True\\n    >>> radix_sort(list(range(14,-1,-1))) == sorted(range(15))\\n    True\\n    >>> radix_sort([1,100,10,1000]) == sorted([1,100,10,1000])\\n    True\\n    \\\"\\\"\\\"\\n    RADIX = 10\\n    placement = 1\\n    max_digit = max(list_of_ints)\\n    while placement <= max_digit:\\n        # declare and initialize empty buckets\\n        buckets: list[list] = [list() for _ in range(RADIX)]\\n        # split list_of_ints between the buckets\\n        for i in list_of_ints:\\n            tmp = int((i / placement) % RADIX)\\n            buckets[tmp].append(i)\\n        # put each buckets' contents into list_of_ints\\n        a = 0\\n        for b in range(RADIX):\\n            for i in buckets[b]:\\n                list_of_ints[a] = i\\n                a += 1\\n        # move to next\\n        placement *= RADIX\\n    return list_of_ints\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "random normal distribution quicksort": "\"from random import randint\\nfrom tempfile import TemporaryFile\\n\\nimport numpy as np\\n\\n\\ndef _inPlaceQuickSort(A, start, end):\\n    count = 0\\n    if start < end:\\n        pivot = randint(start, end)\\n        temp = A[end]\\n        A[end] = A[pivot]\\n        A[pivot] = temp\\n\\n        p, count = _inPlacePartition(A, start, end)\\n        count += _inPlaceQuickSort(A, start, p - 1)\\n        count += _inPlaceQuickSort(A, p + 1, end)\\n    return count\\n\\n\\ndef _inPlacePartition(A, start, end):\\n\\n    count = 0\\n    pivot = randint(start, end)\\n    temp = A[end]\\n    A[end] = A[pivot]\\n    A[pivot] = temp\\n    newPivotIndex = start - 1\\n    for index in range(start, end):\\n\\n        count += 1\\n        if A[index] < A[end]:  # check if current val is less than pivot value\\n            newPivotIndex = newPivotIndex + 1\\n            temp = A[newPivotIndex]\\n            A[newPivotIndex] = A[index]\\n            A[index] = temp\\n\\n    temp = A[newPivotIndex + 1]\\n    A[newPivotIndex + 1] = A[end]\\n    A[end] = temp\\n    return newPivotIndex + 1, count\\n\\n\\noutfile = TemporaryFile()\\np = 100  # 1000 elements are to be sorted\\n\\n\\nmu, sigma = 0, 1  # mean and standard deviation\\nX = np.random.normal(mu, sigma, p)\\nnp.save(outfile, X)\\nprint(\\\"The array is\\\")\\nprint(X)\\n\\n\\noutfile.seek(0)  # using the same array\\nM = np.load(outfile)\\nr = len(M) - 1\\nz = _inPlaceQuickSort(M, 0, r)\\n\\nprint(\\n    \\\"No of Comparisons for 100 elements selected from a standard normal distribution\\\"\\n    \\\"is :\\\"\\n)\\nprint(z)\\n\"",
    "random pivot quick sort": "\"\\\"\\\"\\\"\\r\\nPicks the random index as the pivot\\r\\n\\\"\\\"\\\"\\r\\nimport random\\r\\n\\r\\n\\r\\ndef partition(A, left_index, right_index):\\r\\n    pivot = A[left_index]\\r\\n    i = left_index + 1\\r\\n    for j in range(left_index + 1, right_index):\\r\\n        if A[j] < pivot:\\r\\n            A[j], A[i] = A[i], A[j]\\r\\n            i += 1\\r\\n    A[left_index], A[i - 1] = A[i - 1], A[left_index]\\r\\n    return i - 1\\r\\n\\r\\n\\r\\ndef quick_sort_random(A, left, right):\\r\\n    if left < right:\\r\\n        pivot = random.randint(left, right - 1)\\r\\n        A[pivot], A[left] = (\\r\\n            A[left],\\r\\n            A[pivot],\\r\\n        )  # switches the pivot with the left most bound\\r\\n        pivot_index = partition(A, left, right)\\r\\n        quick_sort_random(\\r\\n            A, left, pivot_index\\r\\n        )  # recursive quicksort to the left of the pivot point\\r\\n        quick_sort_random(\\r\\n            A, pivot_index + 1, right\\r\\n        )  # recursive quicksort to the right of the pivot point\\r\\n\\r\\n\\r\\ndef main():\\r\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\r\\n    arr = [int(item) for item in user_input.split(\\\",\\\")]\\r\\n\\r\\n    quick_sort_random(arr, 0, len(arr))\\r\\n\\r\\n    print(arr)\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    main()\\r\\n\"",
    "recursive bubble sort": "\"def bubble_sort(list_data: list, length: int = 0) -> list:\\r\\n    \\\"\\\"\\\"\\r\\n    It is similar is bubble sort but recursive.\\r\\n    :param list_data: mutable ordered sequence of elements\\r\\n    :param length: length of list data\\r\\n    :return: the same list in ascending order\\r\\n\\r\\n    >>> bubble_sort([0, 5, 2, 3, 2], 5)\\r\\n    [0, 2, 2, 3, 5]\\r\\n\\r\\n    >>> bubble_sort([], 0)\\r\\n    []\\r\\n\\r\\n    >>> bubble_sort([-2, -45, -5], 3)\\r\\n    [-45, -5, -2]\\r\\n\\r\\n    >>> bubble_sort([-23, 0, 6, -4, 34], 5)\\r\\n    [-23, -4, 0, 6, 34]\\r\\n\\r\\n    >>> bubble_sort([-23, 0, 6, -4, 34], 5) == sorted([-23, 0, 6, -4, 34])\\r\\n    True\\r\\n\\r\\n    >>> bubble_sort(['z','a','y','b','x','c'], 6)\\r\\n    ['a', 'b', 'c', 'x', 'y', 'z']\\r\\n\\r\\n    >>> bubble_sort([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])\\r\\n    [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]\\r\\n    \\\"\\\"\\\"\\r\\n    length = length or len(list_data)\\r\\n    swapped = False\\r\\n    for i in range(length - 1):\\r\\n        if list_data[i] > list_data[i + 1]:\\r\\n            list_data[i], list_data[i + 1] = list_data[i + 1], list_data[i]\\r\\n            swapped = True\\r\\n\\r\\n    return list_data if not swapped else bubble_sort(list_data, length - 1)\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "recursive insertion sort": "\"\\\"\\\"\\\"\\nA recursive implementation of the insertion sort algorithm\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef rec_insertion_sort(collection: list, n: int):\\n    \\\"\\\"\\\"\\n    Given a collection of numbers and its length, sorts the collections\\n    in ascending order\\n\\n    :param collection: A mutable collection of comparable elements\\n    :param n: The length of collections\\n\\n    >>> col = [1, 2, 1]\\n    >>> rec_insertion_sort(col, len(col))\\n    >>> print(col)\\n    [1, 1, 2]\\n\\n    >>> col = [2, 1, 0, -1, -2]\\n    >>> rec_insertion_sort(col, len(col))\\n    >>> print(col)\\n    [-2, -1, 0, 1, 2]\\n\\n    >>> col = [1]\\n    >>> rec_insertion_sort(col, len(col))\\n    >>> print(col)\\n    [1]\\n    \\\"\\\"\\\"\\n    # Checks if the entire collection has been sorted\\n    if len(collection) <= 1 or n <= 1:\\n        return\\n\\n    insert_next(collection, n - 1)\\n    rec_insertion_sort(collection, n - 1)\\n\\n\\ndef insert_next(collection: list, index: int):\\n    \\\"\\\"\\\"\\n    Inserts the '(index-1)th' element into place\\n\\n    >>> col = [3, 2, 4, 2]\\n    >>> insert_next(col, 1)\\n    >>> print(col)\\n    [2, 3, 4, 2]\\n\\n    >>> col = [3, 2, 3]\\n    >>> insert_next(col, 2)\\n    >>> print(col)\\n    [3, 2, 3]\\n\\n    >>> col = []\\n    >>> insert_next(col, 1)\\n    >>> print(col)\\n    []\\n    \\\"\\\"\\\"\\n    # Checks order between adjacent elements\\n    if index >= len(collection) or collection[index - 1] <= collection[index]:\\n        return\\n\\n    # Swaps adjacent elements since they are not in ascending order\\n    collection[index - 1], collection[index] = (\\n        collection[index],\\n        collection[index - 1],\\n    )\\n\\n    insert_next(collection, index + 1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    numbers = input(\\\"Enter integers separated by spaces: \\\")\\n    number_list: list[int] = [int(num) for num in numbers.split()]\\n    rec_insertion_sort(number_list, len(number_list))\\n    print(number_list)\\n\"",
    "recursive mergesort array": "\"\\\"\\\"\\\"A merge sort which accepts an array as input and recursively\\nsplits an array in half and sorts and combines them.\\n\\\"\\\"\\\"\\n\\n\\\"\\\"\\\"https://en.wikipedia.org/wiki/Merge_sort \\\"\\\"\\\"\\n\\n\\ndef merge(arr: list[int]) -> list[int]:\\n    \\\"\\\"\\\"Return a sorted array.\\n    >>> merge([10,9,8,7,6,5,4,3,2,1])\\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\\n    >>> merge([1,2,3,4,5,6,7,8,9,10])\\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\\n    >>> merge([10,22,1,2,3,9,15,23])\\n    [1, 2, 3, 9, 10, 15, 22, 23]\\n    >>> merge([100])\\n    [100]\\n    >>> merge([])\\n    []\\n    \\\"\\\"\\\"\\n    if len(arr) > 1:\\n        middle_length = len(arr) // 2  # Finds the middle of the array\\n        left_array = arr[\\n            :middle_length\\n        ]  # Creates an array of the elements in the first half.\\n        right_array = arr[\\n            middle_length:\\n        ]  # Creates an array of the elements in the second half.\\n        left_size = len(left_array)\\n        right_size = len(right_array)\\n        merge(left_array)  # Starts sorting the left.\\n        merge(right_array)  # Starts sorting the right\\n        left_index = 0  # Left Counter\\n        right_index = 0  # Right Counter\\n        index = 0  # Position Counter\\n        while (\\n            left_index < left_size and right_index < right_size\\n        ):  # Runs until the lowers size of the left and right are sorted.\\n            if left_array[left_index] < right_array[right_index]:\\n                arr[index] = left_array[left_index]\\n                left_index += 1\\n            else:\\n                arr[index] = right_array[right_index]\\n                right_index += 1\\n            index += 1\\n        while (\\n            left_index < left_size\\n        ):  # Adds the left over elements in the left half of the array\\n            arr[index] = left_array[left_index]\\n            left_index += 1\\n            index += 1\\n        while (\\n            right_index < right_size\\n        ):  # Adds the left over elements in the right half of the array\\n            arr[index] = right_array[right_index]\\n            right_index += 1\\n            index += 1\\n    return arr\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "recursive quick sort": "\"def quick_sort(data: list) -> list:\\n    \\\"\\\"\\\"\\n    >>> for data in ([2, 1, 0], [2.2, 1.1, 0], \\\"quick_sort\\\"):\\n    ...     quick_sort(data) == sorted(data)\\n    True\\n    True\\n    True\\n    \\\"\\\"\\\"\\n    if len(data) <= 1:\\n        return data\\n    else:\\n        return (\\n            quick_sort([e for e in data[1:] if e <= data[0]])\\n            + [data[0]]\\n            + quick_sort([e for e in data[1:] if e > data[0]])\\n        )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "selection sort": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the selection sort algorithm\\n\\nFor doctests run following command:\\npython -m doctest -v selection_sort.py\\nor\\npython3 -m doctest -v selection_sort.py\\n\\nFor manual testing run:\\npython selection_sort.py\\n\\\"\\\"\\\"\\n\\n\\ndef selection_sort(collection):\\n    \\\"\\\"\\\"Pure implementation of the selection sort algorithm in Python\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: the same collection ordered by ascending\\n\\n\\n    Examples:\\n    >>> selection_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n\\n    >>> selection_sort([])\\n    []\\n\\n    >>> selection_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n    \\\"\\\"\\\"\\n\\n    length = len(collection)\\n    for i in range(length - 1):\\n        least = i\\n        for k in range(i + 1, length):\\n            if collection[k] < collection[least]:\\n                least = k\\n        if least != i:\\n            collection[least], collection[i] = (collection[i], collection[least])\\n    return collection\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(selection_sort(unsorted))\\n\"",
    "shell sort": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Shellsort#Pseudocode\\n\\\"\\\"\\\"\\n\\n\\ndef shell_sort(collection):\\n    \\\"\\\"\\\"Pure implementation of shell sort algorithm in Python\\n    :param collection:  Some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return:  the same collection ordered by ascending\\n\\n    >>> shell_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n    >>> shell_sort([])\\n    []\\n    >>> shell_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n    \\\"\\\"\\\"\\n    # Marcin Ciura's gap sequence\\n\\n    gaps = [701, 301, 132, 57, 23, 10, 4, 1]\\n    for gap in gaps:\\n        for i in range(gap, len(collection)):\\n            insert_value = collection[i]\\n            j = i\\n            while j >= gap and collection[j - gap] > insert_value:\\n                collection[j] = collection[j - gap]\\n                j -= gap\\n            if j != i:\\n                collection[j] = insert_value\\n    return collection\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(shell_sort(unsorted))\\n\"",
    "slowsort": "\"\\\"\\\"\\\"\\nSlowsort is a sorting algorithm. It is of humorous nature and not useful.\\nIt's based on the principle of multiply and surrender,\\na tongue-in-cheek joke of divide and conquer.\\nIt was published in 1986 by Andrei Broder and Jorge Stolfi\\nin their paper Pessimal Algorithms and Simplexity Analysis\\n(a parody of optimal algorithms and complexity analysis).\\n\\nSource: https://en.wikipedia.org/wiki/Slowsort\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\ndef slowsort(sequence: list, start: int | None = None, end: int | None = None) -> None:\\n    \\\"\\\"\\\"\\n    Sorts sequence[start..end] (both inclusive) in-place.\\n    start defaults to 0 if not given.\\n    end defaults to len(sequence) - 1 if not given.\\n    It returns None.\\n    >>> seq = [1, 6, 2, 5, 3, 4, 4, 5]; slowsort(seq); seq\\n    [1, 2, 3, 4, 4, 5, 5, 6]\\n    >>> seq = []; slowsort(seq); seq\\n    []\\n    >>> seq = [2]; slowsort(seq); seq\\n    [2]\\n    >>> seq = [1, 2, 3, 4]; slowsort(seq); seq\\n    [1, 2, 3, 4]\\n    >>> seq = [4, 3, 2, 1]; slowsort(seq); seq\\n    [1, 2, 3, 4]\\n    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, 2, 7); seq\\n    [9, 8, 2, 3, 4, 5, 6, 7, 1, 0]\\n    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, end = 4); seq\\n    [5, 6, 7, 8, 9, 4, 3, 2, 1, 0]\\n    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, start = 5); seq\\n    [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\\n    \\\"\\\"\\\"\\n    if start is None:\\n        start = 0\\n\\n    if end is None:\\n        end = len(sequence) - 1\\n\\n    if start >= end:\\n        return\\n\\n    mid = (start + end) // 2\\n\\n    slowsort(sequence, start, mid)\\n    slowsort(sequence, mid + 1, end)\\n\\n    if sequence[end] < sequence[mid]:\\n        sequence[end], sequence[mid] = sequence[mid], sequence[end]\\n\\n    slowsort(sequence, start, end - 1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "stooge sort": "\"def stooge_sort(arr):\\r\\n    \\\"\\\"\\\"\\r\\n    Examples:\\r\\n    >>> stooge_sort([18.1, 0, -7.1, -1, 2, 2])\\r\\n    [-7.1, -1, 0, 2, 2, 18.1]\\r\\n\\r\\n    >>> stooge_sort([])\\r\\n    []\\r\\n    \\\"\\\"\\\"\\r\\n    stooge(arr, 0, len(arr) - 1)\\r\\n    return arr\\r\\n\\r\\n\\r\\ndef stooge(arr, i, h):\\r\\n\\r\\n    if i >= h:\\r\\n        return\\r\\n\\r\\n    # If first element is smaller than the last then swap them\\r\\n    if arr[i] > arr[h]:\\r\\n        arr[i], arr[h] = arr[h], arr[i]\\r\\n\\r\\n    # If there are more than 2 elements in the array\\r\\n    if h - i + 1 > 2:\\r\\n        t = (int)((h - i + 1) / 3)\\r\\n\\r\\n        # Recursively sort first 2/3 elements\\r\\n        stooge(arr, i, (h - t))\\r\\n\\r\\n        # Recursively sort last 2/3 elements\\r\\n        stooge(arr, i + t, (h))\\r\\n\\r\\n        # Recursively sort first 2/3 elements\\r\\n        stooge(arr, i, (h - t))\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\r\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\r\\n    print(stooge_sort(unsorted))\\r\\n\"",
    "strand sort": "\"import operator\\n\\n\\ndef strand_sort(arr: list, reverse: bool = False, solution: list = None) -> list:\\n    \\\"\\\"\\\"\\n    Strand sort implementation\\n    source: https://en.wikipedia.org/wiki/Strand_sort\\n\\n    :param arr: Unordered input list\\n    :param reverse: Descent ordering flag\\n    :param solution: Ordered items container\\n\\n    Examples:\\n    >>> strand_sort([4, 2, 5, 3, 0, 1])\\n    [0, 1, 2, 3, 4, 5]\\n\\n    >>> strand_sort([4, 2, 5, 3, 0, 1], reverse=True)\\n    [5, 4, 3, 2, 1, 0]\\n    \\\"\\\"\\\"\\n    _operator = operator.lt if reverse else operator.gt\\n    solution = solution or []\\n\\n    if not arr:\\n        return solution\\n\\n    sublist = [arr.pop(0)]\\n    for i, item in enumerate(arr):\\n        if _operator(item, sublist[-1]):\\n            sublist.append(item)\\n            arr.pop(i)\\n\\n    #  merging sublist into solution list\\n    if not solution:\\n        solution.extend(sublist)\\n    else:\\n        while sublist:\\n            item = sublist.pop(0)\\n            for i, xx in enumerate(solution):\\n                if not _operator(item, xx):\\n                    solution.insert(i, item)\\n                    break\\n            else:\\n                solution.append(item)\\n\\n    strand_sort(arr, reverse, solution)\\n    return solution\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    assert strand_sort([4, 3, 5, 1, 2]) == [1, 2, 3, 4, 5]\\n    assert strand_sort([4, 3, 5, 1, 2], reverse=True) == [5, 4, 3, 2, 1]\\n\"",
    "tim sort": "\"def binary_search(lst, item, start, end):\\n    if start == end:\\n        return start if lst[start] > item else start + 1\\n    if start > end:\\n        return start\\n\\n    mid = (start + end) // 2\\n    if lst[mid] < item:\\n        return binary_search(lst, item, mid + 1, end)\\n    elif lst[mid] > item:\\n        return binary_search(lst, item, start, mid - 1)\\n    else:\\n        return mid\\n\\n\\ndef insertion_sort(lst):\\n    length = len(lst)\\n\\n    for index in range(1, length):\\n        value = lst[index]\\n        pos = binary_search(lst, value, 0, index - 1)\\n        lst = lst[:pos] + [value] + lst[pos:index] + lst[index + 1 :]\\n\\n    return lst\\n\\n\\ndef merge(left, right):\\n    if not left:\\n        return right\\n\\n    if not right:\\n        return left\\n\\n    if left[0] < right[0]:\\n        return [left[0]] + merge(left[1:], right)\\n\\n    return [right[0]] + merge(left, right[1:])\\n\\n\\ndef tim_sort(lst):\\n    \\\"\\\"\\\"\\n    >>> tim_sort(\\\"Python\\\")\\n    ['P', 'h', 'n', 'o', 't', 'y']\\n    >>> tim_sort((1.1, 1, 0, -1, -1.1))\\n    [-1.1, -1, 0, 1, 1.1]\\n    >>> tim_sort(list(reversed(list(range(7)))))\\n    [0, 1, 2, 3, 4, 5, 6]\\n    >>> tim_sort([3, 2, 1]) == insertion_sort([3, 2, 1])\\n    True\\n    >>> tim_sort([3, 2, 1]) == sorted([3, 2, 1])\\n    True\\n    \\\"\\\"\\\"\\n    length = len(lst)\\n    runs, sorted_runs = [], []\\n    new_run = [lst[0]]\\n    sorted_array = []\\n    i = 1\\n    while i < length:\\n        if lst[i] < lst[i - 1]:\\n            runs.append(new_run)\\n            new_run = [lst[i]]\\n        else:\\n            new_run.append(lst[i])\\n        i += 1\\n    runs.append(new_run)\\n\\n    for run in runs:\\n        sorted_runs.append(insertion_sort(run))\\n    for run in sorted_runs:\\n        sorted_array = merge(sorted_array, run)\\n\\n    return sorted_array\\n\\n\\ndef main():\\n\\n    lst = [5, 9, 10, 3, -4, 5, 178, 92, 46, -18, 0, 7]\\n    sorted_lst = tim_sort(lst)\\n    print(sorted_lst)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "topological sort": "\"\\\"\\\"\\\"Topological Sort.\\\"\\\"\\\"\\n\\n#     a\\n#    / \\\\\\n#   b  c\\n#  / \\\\\\n# d  e\\nedges = {\\\"a\\\": [\\\"c\\\", \\\"b\\\"], \\\"b\\\": [\\\"d\\\", \\\"e\\\"], \\\"c\\\": [], \\\"d\\\": [], \\\"e\\\": []}\\nvertices = [\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\"]\\n\\n\\ndef topological_sort(start, visited, sort):\\n    \\\"\\\"\\\"Perform topological sort on a directed acyclic graph.\\\"\\\"\\\"\\n    current = start\\n    # add current to visited\\n    visited.append(current)\\n    neighbors = edges[current]\\n    for neighbor in neighbors:\\n        # if neighbor not in visited, visit\\n        if neighbor not in visited:\\n            sort = topological_sort(neighbor, visited, sort)\\n    # if all neighbors visited add current to sort\\n    sort.append(current)\\n    # if all vertices haven't been visited select a new one to visit\\n    if len(visited) != len(vertices):\\n        for vertice in vertices:\\n            if vertice not in visited:\\n                sort = topological_sort(vertice, visited, sort)\\n    # return sort\\n    return sort\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    sort = topological_sort(\\\"a\\\", [], [])\\n    print(sort)\\n\"",
    "tree sort": "\"\\\"\\\"\\\"\\nTree_sort algorithm.\\n\\nBuild a BST and in order traverse.\\n\\\"\\\"\\\"\\n\\n\\nclass node:\\n    # BST data structure\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\n    def insert(self, val):\\n        if self.val:\\n            if val < self.val:\\n                if self.left is None:\\n                    self.left = node(val)\\n                else:\\n                    self.left.insert(val)\\n            elif val > self.val:\\n                if self.right is None:\\n                    self.right = node(val)\\n                else:\\n                    self.right.insert(val)\\n        else:\\n            self.val = val\\n\\n\\ndef inorder(root, res):\\n    # Recursive traversal\\n    if root:\\n        inorder(root.left, res)\\n        res.append(root.val)\\n        inorder(root.right, res)\\n\\n\\ndef tree_sort(arr):\\n    # Build BST\\n    if len(arr) == 0:\\n        return arr\\n    root = node(arr[0])\\n    for i in range(1, len(arr)):\\n        root.insert(arr[i])\\n    # Traverse BST in order.\\n    res = []\\n    inorder(root, res)\\n    return res\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(tree_sort([10, 1, 3, 2, 9, 14, 13]))\\n\"",
    "unknown sort": "\"\\\"\\\"\\\"\\nPython implementation of a sort algorithm.\\nBest Case Scenario : O(n)\\nWorst Case Scenario : O(n^2) because native Python functions:min, max and remove are\\nalready O(n)\\n\\\"\\\"\\\"\\n\\n\\ndef merge_sort(collection):\\n    \\\"\\\"\\\"Pure implementation of the fastest merge sort algorithm in Python\\n\\n    :param collection: some mutable ordered collection with heterogeneous\\n    comparable items inside\\n    :return: a collection ordered by ascending\\n\\n    Examples:\\n    >>> merge_sort([0, 5, 3, 2, 2])\\n    [0, 2, 2, 3, 5]\\n\\n    >>> merge_sort([])\\n    []\\n\\n    >>> merge_sort([-2, -5, -45])\\n    [-45, -5, -2]\\n    \\\"\\\"\\\"\\n    start, end = [], []\\n    while len(collection) > 1:\\n        min_one, max_one = min(collection), max(collection)\\n        start.append(min_one)\\n        end.append(max_one)\\n        collection.remove(min_one)\\n        collection.remove(max_one)\\n    end.reverse()\\n    return start + collection + end\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    user_input = input(\\\"Enter numbers separated by a comma:\\\\n\\\").strip()\\n    unsorted = [int(item) for item in user_input.split(\\\",\\\")]\\n    print(*merge_sort(unsorted), sep=\\\",\\\")\\n\"",
    "wiggle sort": "\"\\\"\\\"\\\"\\nWiggle Sort.\\n\\nGiven an unsorted array nums, reorder it such\\nthat nums[0] < nums[1] > nums[2] < nums[3]....\\nFor example:\\nif input numbers = [3, 5, 2, 1, 6, 4]\\none possible Wiggle Sorted answer is [3, 5, 1, 6, 2, 4].\\n\\\"\\\"\\\"\\n\\n\\ndef wiggle_sort(nums: list) -> list:\\n    \\\"\\\"\\\"\\n    Python implementation of wiggle.\\n    Example:\\n    >>> wiggle_sort([0, 5, 3, 2, 2])\\n    [0, 5, 2, 3, 2]\\n    >>> wiggle_sort([])\\n    []\\n    >>> wiggle_sort([-2, -5, -45])\\n    [-45, -2, -5]\\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\\n    [-45.11, -2.1, -5.68]\\n    \\\"\\\"\\\"\\n    for i, _ in enumerate(nums):\\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\\n\\n    return nums\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"Enter the array elements:\\\")\\n    array = list(map(int, input().split()))\\n    print(\\\"The unsorted array is:\\\")\\n    print(array)\\n    print(\\\"Array after Wiggle sort:\\\")\\n    print(wiggle_sort(array))\\n\"",
    "aho corasick": "\"from __future__ import annotations\\n\\nfrom collections import deque\\n\\n\\nclass Automaton:\\n    def __init__(self, keywords: list[str]):\\n        self.adlist: list[dict] = list()\\n        self.adlist.append(\\n            {\\\"value\\\": \\\"\\\", \\\"next_states\\\": [], \\\"fail_state\\\": 0, \\\"output\\\": []}\\n        )\\n\\n        for keyword in keywords:\\n            self.add_keyword(keyword)\\n        self.set_fail_transitions()\\n\\n    def find_next_state(self, current_state: int, char: str) -> int | None:\\n        for state in self.adlist[current_state][\\\"next_states\\\"]:\\n            if char == self.adlist[state][\\\"value\\\"]:\\n                return state\\n        return None\\n\\n    def add_keyword(self, keyword: str) -> None:\\n        current_state = 0\\n        for character in keyword:\\n            next_state = self.find_next_state(current_state, character)\\n            if next_state is None:\\n                self.adlist.append(\\n                    {\\n                        \\\"value\\\": character,\\n                        \\\"next_states\\\": [],\\n                        \\\"fail_state\\\": 0,\\n                        \\\"output\\\": [],\\n                    }\\n                )\\n                self.adlist[current_state][\\\"next_states\\\"].append(len(self.adlist) - 1)\\n                current_state = len(self.adlist) - 1\\n            else:\\n                current_state = next_state\\n        self.adlist[current_state][\\\"output\\\"].append(keyword)\\n\\n    def set_fail_transitions(self) -> None:\\n        q: deque = deque()\\n        for node in self.adlist[0][\\\"next_states\\\"]:\\n            q.append(node)\\n            self.adlist[node][\\\"fail_state\\\"] = 0\\n        while q:\\n            r = q.popleft()\\n            for child in self.adlist[r][\\\"next_states\\\"]:\\n                q.append(child)\\n                state = self.adlist[r][\\\"fail_state\\\"]\\n                while (\\n                    self.find_next_state(state, self.adlist[child][\\\"value\\\"]) is None\\n                    and state != 0\\n                ):\\n                    state = self.adlist[state][\\\"fail_state\\\"]\\n                self.adlist[child][\\\"fail_state\\\"] = self.find_next_state(\\n                    state, self.adlist[child][\\\"value\\\"]\\n                )\\n                if self.adlist[child][\\\"fail_state\\\"] is None:\\n                    self.adlist[child][\\\"fail_state\\\"] = 0\\n                self.adlist[child][\\\"output\\\"] = (\\n                    self.adlist[child][\\\"output\\\"]\\n                    + self.adlist[self.adlist[child][\\\"fail_state\\\"]][\\\"output\\\"]\\n                )\\n\\n    def search_in(self, string: str) -> dict[str, list[int]]:\\n        \\\"\\\"\\\"\\n        >>> A = Automaton([\\\"what\\\", \\\"hat\\\", \\\"ver\\\", \\\"er\\\"])\\n        >>> A.search_in(\\\"whatever, err ... , wherever\\\")\\n        {'what': [0], 'hat': [1], 'ver': [5, 25], 'er': [6, 10, 22, 26]}\\n        \\\"\\\"\\\"\\n        result: dict = (\\n            dict()\\n        )  # returns a dict with keywords and list of its occurrences\\n        current_state = 0\\n        for i in range(len(string)):\\n            while (\\n                self.find_next_state(current_state, string[i]) is None\\n                and current_state != 0\\n            ):\\n                current_state = self.adlist[current_state][\\\"fail_state\\\"]\\n            next_state = self.find_next_state(current_state, string[i])\\n            if next_state is None:\\n                current_state = 0\\n            else:\\n                current_state = next_state\\n                for key in self.adlist[current_state][\\\"output\\\"]:\\n                    if not (key in result):\\n                        result[key] = []\\n                    result[key].append(i - len(key) + 1)\\n        return result\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "alternative string arrange": "\"def alternative_string_arrange(first_str: str, second_str: str) -> str:\\n    \\\"\\\"\\\"\\n    Return the alternative arrangements of the two strings.\\n    :param first_str:\\n    :param second_str:\\n    :return: String\\n    >>> alternative_string_arrange(\\\"ABCD\\\", \\\"XY\\\")\\n    'AXBYCD'\\n    >>> alternative_string_arrange(\\\"XY\\\", \\\"ABCD\\\")\\n    'XAYBCD'\\n    >>> alternative_string_arrange(\\\"AB\\\", \\\"XYZ\\\")\\n    'AXBYZ'\\n    >>> alternative_string_arrange(\\\"ABC\\\", \\\"\\\")\\n    'ABC'\\n    \\\"\\\"\\\"\\n    first_str_length: int = len(first_str)\\n    second_str_length: int = len(second_str)\\n    abs_length: int = (\\n        first_str_length if first_str_length > second_str_length else second_str_length\\n    )\\n    output_list: list = []\\n    for char_count in range(abs_length):\\n        if char_count < first_str_length:\\n            output_list.append(first_str[char_count])\\n        if char_count < second_str_length:\\n            output_list.append(second_str[char_count])\\n    return \\\"\\\".join(output_list)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(alternative_string_arrange(\\\"AB\\\", \\\"XYZ\\\"), end=\\\" \\\")\\n\"",
    "anagrams": "\"from __future__ import annotations\\n\\nimport collections\\nimport pprint\\nfrom pathlib import Path\\n\\n\\ndef signature(word: str) -> str:\\n    \\\"\\\"\\\"Return a word sorted\\n    >>> signature(\\\"test\\\")\\n    'estt'\\n    >>> signature(\\\"this is a test\\\")\\n    '   aehiisssttt'\\n    >>> signature(\\\"finaltest\\\")\\n    'aefilnstt'\\n    \\\"\\\"\\\"\\n    return \\\"\\\".join(sorted(word))\\n\\n\\ndef anagram(my_word: str) -> list[str]:\\n    \\\"\\\"\\\"Return every anagram of the given word\\n    >>> anagram('test')\\n    ['sett', 'stet', 'test']\\n    >>> anagram('this is a test')\\n    []\\n    >>> anagram('final')\\n    ['final']\\n    \\\"\\\"\\\"\\n    return word_bysig[signature(my_word)]\\n\\n\\ndata: str = Path(__file__).parent.joinpath(\\\"words.txt\\\").read_text(encoding=\\\"utf-8\\\")\\nword_list = sorted({word.strip().lower() for word in data.splitlines()})\\n\\nword_bysig = collections.defaultdict(list)\\nfor word in word_list:\\n    word_bysig[signature(word)].append(word)\\n\\nif __name__ == \\\"__main__\\\":\\n    all_anagrams = {word: anagram(word) for word in word_list if len(anagram(word)) > 1}\\n\\n    with open(\\\"anagrams.txt\\\", \\\"w\\\") as file:\\n        file.write(\\\"all_anagrams = \\\\n \\\")\\n        file.write(pprint.pformat(all_anagrams))\\n\"",
    "autocomplete using trie": "\"END = \\\"#\\\"\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self._trie = {}\\n\\n    def insert_word(self, text):\\n        trie = self._trie\\n        for char in text:\\n            if char not in trie:\\n                trie[char] = {}\\n            trie = trie[char]\\n        trie[END] = True\\n\\n    def find_word(self, prefix):\\n        trie = self._trie\\n        for char in prefix:\\n            if char in trie:\\n                trie = trie[char]\\n            else:\\n                return []\\n        return self._elements(trie)\\n\\n    def _elements(self, d):\\n        result = []\\n        for c, v in d.items():\\n            if c == END:\\n                sub_result = [\\\" \\\"]\\n            else:\\n                sub_result = [c + s for s in self._elements(v)]\\n            result.extend(sub_result)\\n        return tuple(result)\\n\\n\\ntrie = Trie()\\nwords = (\\\"depart\\\", \\\"detergent\\\", \\\"daring\\\", \\\"dog\\\", \\\"deer\\\", \\\"deal\\\")\\nfor word in words:\\n    trie.insert_word(word)\\n\\n\\ndef autocomplete_using_trie(s):\\n    \\\"\\\"\\\"\\n    >>> trie = Trie()\\n    >>> for word in words:\\n    ...     trie.insert_word(word)\\n    ...\\n    >>> matches = autocomplete_using_trie(\\\"de\\\")\\n\\n    \\\"detergent \\\" in matches\\n    True\\n    \\\"dog \\\" in matches\\n    False\\n    \\\"\\\"\\\"\\n    suffixes = trie.find_word(s)\\n    return tuple(s + w for w in suffixes)\\n\\n\\ndef main():\\n    print(autocomplete_using_trie(\\\"de\\\"))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "boyer moore search": "\"\\\"\\\"\\\"\\nThe algorithm finds the pattern in given text using following rule.\\n\\nThe bad-character rule considers the mismatched character in Text.\\nThe next occurrence of that character to the left in Pattern is found,\\n\\nIf the mismatched character occurs to the left in Pattern,\\na shift is proposed that aligns text block and pattern.\\n\\nIf the mismatched character does not occur to the left in Pattern,\\na shift is proposed that moves the entirety of Pattern past\\nthe point of mismatch in the text.\\n\\nIf there no mismatch then the pattern matches with text block.\\n\\nTime Complexity : O(n/m)\\n    n=length of main string\\n    m=length of pattern string\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\nclass BoyerMooreSearch:\\n    def __init__(self, text: str, pattern: str):\\n        self.text, self.pattern = text, pattern\\n        self.textLen, self.patLen = len(text), len(pattern)\\n\\n    def match_in_pattern(self, char: str) -> int:\\n        \\\"\\\"\\\"finds the index of char in pattern in reverse order\\n\\n        Parameters :\\n            char (chr): character to be searched\\n\\n        Returns :\\n            i (int): index of char from last in pattern\\n            -1 (int): if char is not found in pattern\\n        \\\"\\\"\\\"\\n\\n        for i in range(self.patLen - 1, -1, -1):\\n            if char == self.pattern[i]:\\n                return i\\n        return -1\\n\\n    def mismatch_in_text(self, currentPos: int) -> int:\\n        \\\"\\\"\\\"\\n        find the index of mis-matched character in text when compared with pattern\\n        from last\\n\\n        Parameters :\\n            currentPos (int): current index position of text\\n\\n        Returns :\\n            i (int): index of mismatched char from last in text\\n            -1 (int): if there is no mismatch between pattern and text block\\n        \\\"\\\"\\\"\\n\\n        for i in range(self.patLen - 1, -1, -1):\\n            if self.pattern[i] != self.text[currentPos + i]:\\n                return currentPos + i\\n        return -1\\n\\n    def bad_character_heuristic(self) -> list[int]:\\n        # searches pattern in text and returns index positions\\n        positions = []\\n        for i in range(self.textLen - self.patLen + 1):\\n            mismatch_index = self.mismatch_in_text(i)\\n            if mismatch_index == -1:\\n                positions.append(i)\\n            else:\\n                match_index = self.match_in_pattern(self.text[mismatch_index])\\n                i = (\\n                    mismatch_index - match_index\\n                )  # shifting index lgtm [py/multiple-definition]\\n        return positions\\n\\n\\ntext = \\\"ABAABA\\\"\\npattern = \\\"AB\\\"\\nbms = BoyerMooreSearch(text, pattern)\\npositions = bms.bad_character_heuristic()\\n\\nif len(positions) == 0:\\n    print(\\\"No match found\\\")\\nelse:\\n    print(\\\"Pattern found in following positions: \\\")\\n    print(positions)\\n\"",
    "can string be rearranged as palindrome": "\"# Created by susmith98\\n\\nfrom collections import Counter\\nfrom timeit import timeit\\n\\n# Problem Description:\\n# Check if characters of the given string can be rearranged to form a palindrome.\\n# Counter is faster for long strings and non-Counter is faster for short strings.\\n\\n\\ndef can_string_be_rearranged_as_palindrome_counter(\\n    input_str: str = \\\"\\\",\\n) -> bool:\\n    \\\"\\\"\\\"\\n    A Palindrome is a String that reads the same forward as it does backwards.\\n    Examples of Palindromes mom, dad, malayalam\\n    >>> can_string_be_rearranged_as_palindrome_counter(\\\"Momo\\\")\\n    True\\n    >>> can_string_be_rearranged_as_palindrome_counter(\\\"Mother\\\")\\n    False\\n    >>> can_string_be_rearranged_as_palindrome_counter(\\\"Father\\\")\\n    False\\n    >>> can_string_be_rearranged_as_palindrome_counter(\\\"A man a plan a canal Panama\\\")\\n    True\\n    \\\"\\\"\\\"\\n    return sum(c % 2 for c in Counter(input_str.replace(\\\" \\\", \\\"\\\").lower()).values()) < 2\\n\\n\\ndef can_string_be_rearranged_as_palindrome(input_str: str = \\\"\\\") -> bool:\\n    \\\"\\\"\\\"\\n    A Palindrome is a String that reads the same forward as it does backwards.\\n    Examples of Palindromes mom, dad, malayalam\\n    >>> can_string_be_rearranged_as_palindrome(\\\"Momo\\\")\\n    True\\n    >>> can_string_be_rearranged_as_palindrome(\\\"Mother\\\")\\n    False\\n    >>> can_string_be_rearranged_as_palindrome(\\\"Father\\\")\\n    False\\n    >>> can_string_be_rearranged_as_palindrome_counter(\\\"A man a plan a canal Panama\\\")\\n    True\\n    \\\"\\\"\\\"\\n    if len(input_str) == 0:\\n        return True\\n    lower_case_input_str = input_str.replace(\\\" \\\", \\\"\\\").lower()\\n    # character_freq_dict: Stores the frequency of every character in the input string\\n    character_freq_dict: dict[str, int] = {}\\n\\n    for character in lower_case_input_str:\\n        character_freq_dict[character] = character_freq_dict.get(character, 0) + 1\\n    \\\"\\\"\\\"\\n    Above line of code is equivalent to:\\n    1) Getting the frequency of current character till previous index\\n    >>> character_freq =  character_freq_dict.get(character, 0)\\n    2) Incrementing the frequency of current character by 1\\n    >>> character_freq = character_freq + 1\\n    3) Updating the frequency of current character\\n    >>> character_freq_dict[character] = character_freq\\n    \\\"\\\"\\\"\\n    \\\"\\\"\\\"\\n    OBSERVATIONS:\\n    Even length palindrome\\n    -> Every character appears even no.of times.\\n    Odd length palindrome\\n    -> Every character appears even no.of times except for one character.\\n    LOGIC:\\n    Step 1: We'll count number of characters that appear odd number of times i.e oddChar\\n    Step 2:If we find more than 1 character that appears odd number of times,\\n    It is not possible to rearrange as a palindrome\\n    \\\"\\\"\\\"\\n    oddChar = 0\\n\\n    for character_count in character_freq_dict.values():\\n        if character_count % 2:\\n            oddChar += 1\\n    if oddChar > 1:\\n        return False\\n    return True\\n\\n\\ndef benchmark(input_str: str = \\\"\\\") -> None:\\n    \\\"\\\"\\\"\\n    Benchmark code for comparing above 2 functions\\n    \\\"\\\"\\\"\\n    print(\\\"\\\\nFor string = \\\", input_str, \\\":\\\")\\n    print(\\n        \\\"> can_string_be_rearranged_as_palindrome_counter()\\\",\\n        \\\"\\\\tans =\\\",\\n        can_string_be_rearranged_as_palindrome_counter(input_str),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\n            \\\"z.can_string_be_rearranged_as_palindrome_counter(z.check_str)\\\",\\n            setup=\\\"import __main__ as z\\\",\\n        ),\\n        \\\"seconds\\\",\\n    )\\n    print(\\n        \\\"> can_string_be_rearranged_as_palindrome()\\\",\\n        \\\"\\\\tans =\\\",\\n        can_string_be_rearranged_as_palindrome(input_str),\\n        \\\"\\\\ttime =\\\",\\n        timeit(\\n            \\\"z.can_string_be_rearranged_as_palindrome(z.check_str)\\\",\\n            setup=\\\"import __main__ as z\\\",\\n        ),\\n        \\\"seconds\\\",\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    check_str = input(\\n        \\\"Enter string to determine if it can be rearranged as a palindrome or not: \\\"\\n    ).strip()\\n    benchmark(check_str)\\n    status = can_string_be_rearranged_as_palindrome_counter(check_str)\\n    print(f\\\"{check_str} can {'' if status else 'not '}be rearranged as a palindrome\\\")\\n\"",
    "capitalize": "\"from string import ascii_lowercase, ascii_uppercase\\n\\n\\ndef capitalize(sentence: str) -> str:\\n    \\\"\\\"\\\"\\n    This function will capitalize the first letter of a sentence or a word\\n    >>> capitalize(\\\"hello world\\\")\\n    'Hello world'\\n    >>> capitalize(\\\"123 hello world\\\")\\n    '123 hello world'\\n    >>> capitalize(\\\" hello world\\\")\\n    ' hello world'\\n    >>> capitalize(\\\"a\\\")\\n    'A'\\n    >>> capitalize(\\\"\\\")\\n    ''\\n    \\\"\\\"\\\"\\n    if not sentence:\\n        return \\\"\\\"\\n    lower_to_upper = {lc: uc for lc, uc in zip(ascii_lowercase, ascii_uppercase)}\\n    return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "check anagrams": "\"\\\"\\\"\\\"\\r\\nwiki: https://en.wikipedia.org/wiki/Anagram\\r\\n\\\"\\\"\\\"\\r\\nfrom collections import defaultdict\\r\\nfrom typing import DefaultDict\\r\\n\\r\\n\\r\\ndef check_anagrams(first_str: str, second_str: str) -> bool:\\r\\n    \\\"\\\"\\\"\\r\\n    Two strings are anagrams if they are made up of the same letters but are\\r\\n    arranged differently (ignoring the case).\\r\\n    >>> check_anagrams('Silent', 'Listen')\\r\\n    True\\r\\n    >>> check_anagrams('This is a string', 'Is this a string')\\r\\n    True\\r\\n    >>> check_anagrams('This is    a      string', 'Is     this a string')\\r\\n    True\\r\\n    >>> check_anagrams('There', 'Their')\\r\\n    False\\r\\n    \\\"\\\"\\\"\\r\\n    first_str = first_str.lower().strip()\\r\\n    second_str = second_str.lower().strip()\\r\\n\\r\\n    # Remove whitespace\\r\\n    first_str = first_str.replace(\\\" \\\", \\\"\\\")\\r\\n    second_str = second_str.replace(\\\" \\\", \\\"\\\")\\r\\n\\r\\n    # Strings of different lengths are not anagrams\\r\\n    if len(first_str) != len(second_str):\\r\\n        return False\\r\\n\\r\\n    # Default values for count should be 0\\r\\n    count: DefaultDict[str, int] = defaultdict(int)\\r\\n\\r\\n    # For each character in input strings,\\r\\n    # increment count in the corresponding\\r\\n    for i in range(len(first_str)):\\r\\n        count[first_str[i]] += 1\\r\\n        count[second_str[i]] -= 1\\r\\n\\r\\n    for _count in count.values():\\r\\n        if _count != 0:\\r\\n            return False\\r\\n    return True\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    from doctest import testmod\\r\\n\\r\\n    testmod()\\r\\n    input_A = input(\\\"Enter the first string \\\").strip()\\r\\n    input_B = input(\\\"Enter the second string \\\").strip()\\r\\n\\r\\n    status = check_anagrams(input_A, input_B)\\r\\n    print(f\\\"{input_A} and {input_B} are {'' if status else 'not '}anagrams.\\\")\\r\\n\"",
    "check pangram": "\"\\\"\\\"\\\"\\nwiki: https://en.wikipedia.org/wiki/Pangram\\n\\\"\\\"\\\"\\n\\n\\ndef check_pangram(\\n    input_str: str = \\\"The quick brown fox jumps over the lazy dog\\\",\\n) -> bool:\\n    \\\"\\\"\\\"\\n    A Pangram String contains all the alphabets at least once.\\n    >>> check_pangram(\\\"The quick brown fox jumps over the lazy dog\\\")\\n    True\\n    >>> check_pangram(\\\"Waltz, bad nymph, for quick jigs vex.\\\")\\n    True\\n    >>> check_pangram(\\\"Jived fox nymph grabs quick waltz.\\\")\\n    True\\n    >>> check_pangram(\\\"My name is Unknown\\\")\\n    False\\n    >>> check_pangram(\\\"The quick brown fox jumps over the la_y dog\\\")\\n    False\\n    >>> check_pangram()\\n    True\\n    \\\"\\\"\\\"\\n    frequency = set()\\n    input_str = input_str.replace(\\n        \\\" \\\", \\\"\\\"\\n    )  # Replacing all the Whitespaces in our sentence\\n    for alpha in input_str:\\n        if \\\"a\\\" <= alpha.lower() <= \\\"z\\\":\\n            frequency.add(alpha.lower())\\n\\n    return True if len(frequency) == 26 else False\\n\\n\\ndef check_pangram_faster(\\n    input_str: str = \\\"The quick brown fox jumps over the lazy dog\\\",\\n) -> bool:\\n    \\\"\\\"\\\"\\n    >>> check_pangram_faster(\\\"The quick brown fox jumps over the lazy dog\\\")\\n    True\\n    >>> check_pangram_faster(\\\"Waltz, bad nymph, for quick jigs vex.\\\")\\n    True\\n    >>> check_pangram_faster(\\\"Jived fox nymph grabs quick waltz.\\\")\\n    True\\n    >>> check_pangram_faster(\\\"The quick brown fox jumps over the la_y dog\\\")\\n    False\\n    >>> check_pangram_faster()\\n    True\\n    \\\"\\\"\\\"\\n    flag = [False] * 26\\n    for char in input_str:\\n        if char.islower():\\n            flag[ord(char) - 97] = True\\n        elif char.isupper():\\n            flag[ord(char) - 65] = True\\n    return all(flag)\\n\\n\\ndef benchmark() -> None:\\n    \\\"\\\"\\\"\\n    Benchmark code comparing different version.\\n    \\\"\\\"\\\"\\n    from timeit import timeit\\n\\n    setup = \\\"from __main__ import check_pangram, check_pangram_faster\\\"\\n    print(timeit(\\\"check_pangram()\\\", setup=setup))\\n    print(timeit(\\\"check_pangram_faster()\\\", setup=setup))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    benchmark()\\n\"",
    "credit card validator": "\"\\\"\\\"\\\"\\nFunctions for testing the validity of credit card numbers.\\n\\nhttps://en.wikipedia.org/wiki/Luhn_algorithm\\n\\\"\\\"\\\"\\n\\n\\ndef validate_initial_digits(credit_card_number: str) -> bool:\\n    \\\"\\\"\\\"\\n    Function to validate initial digits of a given credit card number.\\n    >>> valid = \\\"4111111111111111 41111111111111 34 35 37 412345 523456 634567\\\"\\n    >>> all(validate_initial_digits(cc) for cc in valid.split())\\n    True\\n    >>> invalid = \\\"14 25 76 32323 36111111111111\\\"\\n    >>> all(validate_initial_digits(cc) is False for cc in invalid.split())\\n    True\\n    \\\"\\\"\\\"\\n    return credit_card_number.startswith((\\\"34\\\", \\\"35\\\", \\\"37\\\", \\\"4\\\", \\\"5\\\", \\\"6\\\"))\\n\\n\\ndef luhn_validation(credit_card_number: str) -> bool:\\n    \\\"\\\"\\\"\\n    Function to luhn algorithm validation for a given credit card number.\\n    >>> luhn_validation('4111111111111111')\\n    True\\n    >>> luhn_validation('36111111111111')\\n    True\\n    >>> luhn_validation('41111111111111')\\n    False\\n    \\\"\\\"\\\"\\n    cc_number = credit_card_number\\n    total = 0\\n    half_len = len(cc_number) - 2\\n    for i in range(half_len, -1, -2):\\n        #  double the value of every second digit\\n        digit = int(cc_number[i])\\n        digit *= 2\\n        # If doubling of a number results in a two digit number\\n        # i.e greater than 9(e.g., 6 × 2 = 12),\\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\\n        # to get a single digit number.\\n        if digit > 9:\\n            digit %= 10\\n            digit += 1\\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\\n        total += digit\\n\\n    # Sum up the remaining digits\\n    for i in range(len(cc_number) - 1, -1, -2):\\n        total += int(cc_number[i])\\n\\n    return total % 10 == 0\\n\\n\\ndef validate_credit_card_number(credit_card_number: str) -> bool:\\n    \\\"\\\"\\\"\\n    Function to validate the given credit card number.\\n    >>> validate_credit_card_number('4111111111111111')\\n    4111111111111111 is a valid credit card number.\\n    True\\n    >>> validate_credit_card_number('helloworld$')\\n    helloworld$ is an invalid credit card number because it has nonnumerical characters.\\n    False\\n    >>> validate_credit_card_number('32323')\\n    32323 is an invalid credit card number because of its length.\\n    False\\n    >>> validate_credit_card_number('32323323233232332323')\\n    32323323233232332323 is an invalid credit card number because of its length.\\n    False\\n    >>> validate_credit_card_number('36111111111111')\\n    36111111111111 is an invalid credit card number because of its first two digits.\\n    False\\n    >>> validate_credit_card_number('41111111111111')\\n    41111111111111 is an invalid credit card number because it fails the Luhn check.\\n    False\\n    \\\"\\\"\\\"\\n    error_message = f\\\"{credit_card_number} is an invalid credit card number because\\\"\\n    if not credit_card_number.isdigit():\\n        print(f\\\"{error_message} it has nonnumerical characters.\\\")\\n        return False\\n\\n    if not 13 <= len(credit_card_number) <= 16:\\n        print(f\\\"{error_message} of its length.\\\")\\n        return False\\n\\n    if not validate_initial_digits(credit_card_number):\\n        print(f\\\"{error_message} of its first two digits.\\\")\\n        return False\\n\\n    if not luhn_validation(credit_card_number):\\n        print(f\\\"{error_message} it fails the Luhn check.\\\")\\n        return False\\n\\n    print(f\\\"{credit_card_number} is a valid credit card number.\\\")\\n    return True\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    validate_credit_card_number(\\\"4111111111111111\\\")\\n    validate_credit_card_number(\\\"32323\\\")\\n\"",
    "detecting english programmatically": "\"import os\\n\\nUPPERLETTERS = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\nLETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + \\\" \\\\t\\\\n\\\"\\n\\n\\ndef loadDictionary():\\n    path = os.path.split(os.path.realpath(__file__))\\n    englishWords = {}\\n    with open(path[0] + \\\"/dictionary.txt\\\") as dictionaryFile:\\n        for word in dictionaryFile.read().split(\\\"\\\\n\\\"):\\n            englishWords[word] = None\\n    return englishWords\\n\\n\\nENGLISH_WORDS = loadDictionary()\\n\\n\\ndef getEnglishCount(message):\\n    message = message.upper()\\n    message = removeNonLetters(message)\\n    possibleWords = message.split()\\n\\n    if possibleWords == []:\\n        return 0.0\\n\\n    matches = 0\\n    for word in possibleWords:\\n        if word in ENGLISH_WORDS:\\n            matches += 1\\n\\n    return float(matches) / len(possibleWords)\\n\\n\\ndef removeNonLetters(message):\\n    lettersOnly = []\\n    for symbol in message:\\n        if symbol in LETTERS_AND_SPACE:\\n            lettersOnly.append(symbol)\\n    return \\\"\\\".join(lettersOnly)\\n\\n\\ndef isEnglish(message, wordPercentage=20, letterPercentage=85):\\n    \\\"\\\"\\\"\\n    >>> isEnglish('Hello World')\\n    True\\n\\n    >>> isEnglish('llold HorWd')\\n    False\\n    \\\"\\\"\\\"\\n    wordsMatch = getEnglishCount(message) * 100 >= wordPercentage\\n    numLetters = len(removeNonLetters(message))\\n    messageLettersPercentage = (float(numLetters) / len(message)) * 100\\n    lettersMatch = messageLettersPercentage >= letterPercentage\\n    return wordsMatch and lettersMatch\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "frequency finder": "\"# Frequency Finder\\n\\n# frequency taken from http://en.wikipedia.org/wiki/Letter_frequency\\nenglishLetterFreq = {\\n    \\\"E\\\": 12.70,\\n    \\\"T\\\": 9.06,\\n    \\\"A\\\": 8.17,\\n    \\\"O\\\": 7.51,\\n    \\\"I\\\": 6.97,\\n    \\\"N\\\": 6.75,\\n    \\\"S\\\": 6.33,\\n    \\\"H\\\": 6.09,\\n    \\\"R\\\": 5.99,\\n    \\\"D\\\": 4.25,\\n    \\\"L\\\": 4.03,\\n    \\\"C\\\": 2.78,\\n    \\\"U\\\": 2.76,\\n    \\\"M\\\": 2.41,\\n    \\\"W\\\": 2.36,\\n    \\\"F\\\": 2.23,\\n    \\\"G\\\": 2.02,\\n    \\\"Y\\\": 1.97,\\n    \\\"P\\\": 1.93,\\n    \\\"B\\\": 1.29,\\n    \\\"V\\\": 0.98,\\n    \\\"K\\\": 0.77,\\n    \\\"J\\\": 0.15,\\n    \\\"X\\\": 0.15,\\n    \\\"Q\\\": 0.10,\\n    \\\"Z\\\": 0.07,\\n}\\nETAOIN = \\\"ETAOINSHRDLCUMWFGYPBVKJXQZ\\\"\\nLETTERS = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\n\\n\\ndef getLetterCount(message):\\n    letterCount = {\\n        \\\"A\\\": 0,\\n        \\\"B\\\": 0,\\n        \\\"C\\\": 0,\\n        \\\"D\\\": 0,\\n        \\\"E\\\": 0,\\n        \\\"F\\\": 0,\\n        \\\"G\\\": 0,\\n        \\\"H\\\": 0,\\n        \\\"I\\\": 0,\\n        \\\"J\\\": 0,\\n        \\\"K\\\": 0,\\n        \\\"L\\\": 0,\\n        \\\"M\\\": 0,\\n        \\\"N\\\": 0,\\n        \\\"O\\\": 0,\\n        \\\"P\\\": 0,\\n        \\\"Q\\\": 0,\\n        \\\"R\\\": 0,\\n        \\\"S\\\": 0,\\n        \\\"T\\\": 0,\\n        \\\"U\\\": 0,\\n        \\\"V\\\": 0,\\n        \\\"W\\\": 0,\\n        \\\"X\\\": 0,\\n        \\\"Y\\\": 0,\\n        \\\"Z\\\": 0,\\n    }\\n    for letter in message.upper():\\n        if letter in LETTERS:\\n            letterCount[letter] += 1\\n\\n    return letterCount\\n\\n\\ndef getItemAtIndexZero(x):\\n    return x[0]\\n\\n\\ndef getFrequencyOrder(message):\\n    letterToFreq = getLetterCount(message)\\n    freqToLetter = {}\\n    for letter in LETTERS:\\n        if letterToFreq[letter] not in freqToLetter:\\n            freqToLetter[letterToFreq[letter]] = [letter]\\n        else:\\n            freqToLetter[letterToFreq[letter]].append(letter)\\n\\n    for freq in freqToLetter:\\n        freqToLetter[freq].sort(key=ETAOIN.find, reverse=True)\\n        freqToLetter[freq] = \\\"\\\".join(freqToLetter[freq])\\n\\n    freqPairs = list(freqToLetter.items())\\n    freqPairs.sort(key=getItemAtIndexZero, reverse=True)\\n\\n    freqOrder = []\\n    for freqPair in freqPairs:\\n        freqOrder.append(freqPair[1])\\n\\n    return \\\"\\\".join(freqOrder)\\n\\n\\ndef englishFreqMatchScore(message):\\n    \\\"\\\"\\\"\\n    >>> englishFreqMatchScore('Hello World')\\n    1\\n    \\\"\\\"\\\"\\n    freqOrder = getFrequencyOrder(message)\\n    matchScore = 0\\n    for commonLetter in ETAOIN[:6]:\\n        if commonLetter in freqOrder[:6]:\\n            matchScore += 1\\n\\n    for uncommonLetter in ETAOIN[-6:]:\\n        if uncommonLetter in freqOrder[-6:]:\\n            matchScore += 1\\n\\n    return matchScore\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "indian phone validator": "\"import re\\n\\n\\ndef indian_phone_validator(phone: str) -> bool:\\n    \\\"\\\"\\\"\\n    Determine whether the string is a valid phone number or not\\n    :param phone:\\n    :return: Boolean\\n    >>> indian_phone_validator(\\\"+91123456789\\\")\\n    False\\n    >>> indian_phone_validator(\\\"+919876543210\\\")\\n    True\\n    >>> indian_phone_validator(\\\"01234567896\\\")\\n    False\\n    >>> indian_phone_validator(\\\"919876543218\\\")\\n    True\\n    >>> indian_phone_validator(\\\"+91-1234567899\\\")\\n    False\\n    >>> indian_phone_validator(\\\"+91-9876543218\\\")\\n    True\\n    \\\"\\\"\\\"\\n    pat = re.compile(r\\\"^(\\\\+91[\\\\-\\\\s]?)?[0]?(91)?[789]\\\\d{9}$\\\")\\n    match = re.search(pat, phone)\\n    if match:\\n        return match.string == phone\\n    return False\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(indian_phone_validator(\\\"+918827897895\\\"))\\n\"",
    "is contains unique chars": "\"def is_contains_unique_chars(input_str: str) -> bool:\\n    \\\"\\\"\\\"\\n    Check if all characters in the string is unique or not.\\n    >>> is_contains_unique_chars(\\\"I_love.py\\\")\\n    True\\n    >>> is_contains_unique_chars(\\\"I don't love Python\\\")\\n    False\\n\\n    Time complexity: O(n)\\n    Space compexity: O(1) 19320 bytes as we are having 144697 characters in unicode\\n    \\\"\\\"\\\"\\n\\n    # Each bit will represent each unicode character\\n    # For example 65th bit representing 'A'\\n    # https://stackoverflow.com/a/12811293\\n    bitmap = 0\\n    for ch in input_str:\\n        ch_unicode = ord(ch)\\n        ch_bit_index_on = pow(2, ch_unicode)\\n\\n        # If we already turned on bit for current character's unicode\\n        if bitmap >> ch_unicode & 1 == 1:\\n            return False\\n        bitmap |= ch_bit_index_on\\n    return True\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "is palindrome": "\"def is_palindrome(s: str) -> bool:\\n    \\\"\\\"\\\"\\n    Determine whether the string is palindrome\\n    :param s:\\n    :return: Boolean\\n    >>> is_palindrome(\\\"a man a plan a canal panama\\\".replace(\\\" \\\", \\\"\\\"))\\n    True\\n    >>> is_palindrome(\\\"Hello\\\")\\n    False\\n    >>> is_palindrome(\\\"Able was I ere I saw Elba\\\")\\n    True\\n    >>> is_palindrome(\\\"racecar\\\")\\n    True\\n    >>> is_palindrome(\\\"Mr. Owl ate my metal worm?\\\")\\n    True\\n    \\\"\\\"\\\"\\n    # Since Punctuation, capitalization, and spaces are usually ignored while checking\\n    # Palindrome,  we first remove them from our string.\\n    s = \\\"\\\".join([character for character in s.lower() if character.isalnum()])\\n    return s == s[::-1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    s = input(\\\"Enter string to determine whether its palindrome or not: \\\").strip()\\n    if is_palindrome(s):\\n        print(\\\"Given string is palindrome\\\")\\n    else:\\n        print(\\\"Given string is not palindrome\\\")\\n\"",
    "jaro winkler": "\"\\\"\\\"\\\"https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\\\"\\\"\\\"\\n\\n\\ndef jaro_winkler(str1: str, str2: str) -> float:\\n    \\\"\\\"\\\"\\n    Jaro–Winkler distance is a string metric measuring an edit distance between two\\n    sequences.\\n    Output value is between 0.0 and 1.0.\\n\\n    >>> jaro_winkler(\\\"martha\\\", \\\"marhta\\\")\\n    0.9611111111111111\\n    >>> jaro_winkler(\\\"CRATE\\\", \\\"TRACE\\\")\\n    0.7333333333333334\\n    >>> jaro_winkler(\\\"test\\\", \\\"dbdbdbdb\\\")\\n    0.0\\n    >>> jaro_winkler(\\\"test\\\", \\\"test\\\")\\n    1.0\\n    >>> jaro_winkler(\\\"hello world\\\", \\\"HeLLo W0rlD\\\")\\n    0.6363636363636364\\n    >>> jaro_winkler(\\\"test\\\", \\\"\\\")\\n    0.0\\n    >>> jaro_winkler(\\\"hello\\\", \\\"world\\\")\\n    0.4666666666666666\\n    >>> jaro_winkler(\\\"hell**o\\\", \\\"*world\\\")\\n    0.4365079365079365\\n    \\\"\\\"\\\"\\n\\n    def get_matched_characters(_str1: str, _str2: str) -> str:\\n        matched = []\\n        limit = min(len(_str1), len(_str2)) // 2\\n        for i, l in enumerate(_str1):\\n            left = int(max(0, i - limit))\\n            right = int(min(i + limit + 1, len(_str2)))\\n            if l in _str2[left:right]:\\n                matched.append(l)\\n                _str2 = f\\\"{_str2[0:_str2.index(l)]} {_str2[_str2.index(l) + 1:]}\\\"\\n\\n        return \\\"\\\".join(matched)\\n\\n    # matching characters\\n    matching_1 = get_matched_characters(str1, str2)\\n    matching_2 = get_matched_characters(str2, str1)\\n    match_count = len(matching_1)\\n\\n    # transposition\\n    transpositions = (\\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\\n    )\\n\\n    if not match_count:\\n        jaro = 0.0\\n    else:\\n        jaro = (\\n            1\\n            / 3\\n            * (\\n                match_count / len(str1)\\n                + match_count / len(str2)\\n                + (match_count - transpositions) / match_count\\n            )\\n        )\\n\\n    # common prefix up to 4 characters\\n    prefix_len = 0\\n    for c1, c2 in zip(str1[:4], str2[:4]):\\n        if c1 == c2:\\n            prefix_len += 1\\n        else:\\n            break\\n\\n    return jaro + 0.1 * prefix_len * (1 - jaro)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    print(jaro_winkler(\\\"hello\\\", \\\"world\\\"))\\n\"",
    "join": "\"\\\"\\\"\\\"\\nProgram to join a list of strings with a given separator\\n\\\"\\\"\\\"\\n\\n\\ndef join(separator: str, separated: list[str]) -> str:\\n    \\\"\\\"\\\"\\n    >>> join(\\\"\\\", [\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"])\\n    'abcd'\\n    >>> join(\\\"#\\\", [\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"])\\n    'a#b#c#d'\\n    >>> join(\\\"#\\\", \\\"a\\\")\\n    'a'\\n    >>> join(\\\" \\\", [\\\"You\\\", \\\"are\\\", \\\"amazing!\\\"])\\n    'You are amazing!'\\n    >>> join(\\\"#\\\", [\\\"a\\\", \\\"b\\\", \\\"c\\\", 1])\\n    Traceback (most recent call last):\\n    ...\\n    Exception: join() accepts only strings to be joined\\n    \\\"\\\"\\\"\\n    joined = \\\"\\\"\\n    for word_or_phrase in separated:\\n        if not isinstance(word_or_phrase, str):\\n            raise Exception(\\\"join() accepts only strings to be joined\\\")\\n        joined += word_or_phrase + separator\\n    return joined.strip(separator)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "knuth morris pratt": "\"from __future__ import annotations\\n\\n\\ndef kmp(pattern: str, text: str) -> bool:\\n    \\\"\\\"\\\"\\n    The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text\\n    with complexity O(n + m)\\n\\n    1) Preprocess pattern to identify any suffixes that are identical to prefixes\\n\\n        This tells us where to continue from if we get a mismatch between a character\\n        in our pattern and the text.\\n\\n    2) Step through the text one character at a time and compare it to a character in\\n        the pattern updating our location within the pattern if necessary\\n\\n    \\\"\\\"\\\"\\n\\n    # 1) Construct the failure array\\n    failure = get_failure_array(pattern)\\n\\n    # 2) Step through text searching for pattern\\n    i, j = 0, 0  # index into text, pattern\\n    while i < len(text):\\n        if pattern[j] == text[i]:\\n            if j == (len(pattern) - 1):\\n                return True\\n            j += 1\\n\\n        # if this is a prefix in our pattern\\n        # just go back far enough to continue\\n        elif j > 0:\\n            j = failure[j - 1]\\n            continue\\n        i += 1\\n    return False\\n\\n\\ndef get_failure_array(pattern: str) -> list[int]:\\n    \\\"\\\"\\\"\\n    Calculates the new index we should go to if we fail a comparison\\n    :param pattern:\\n    :return:\\n    \\\"\\\"\\\"\\n    failure = [0]\\n    i = 0\\n    j = 1\\n    while j < len(pattern):\\n        if pattern[i] == pattern[j]:\\n            i += 1\\n        elif i > 0:\\n            i = failure[i - 1]\\n            continue\\n        j += 1\\n        failure.append(i)\\n    return failure\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # Test 1)\\n    pattern = \\\"abc1abc12\\\"\\n    text1 = \\\"alskfjaldsabc1abc1abc12k23adsfabcabc\\\"\\n    text2 = \\\"alskfjaldsk23adsfabcabc\\\"\\n    assert kmp(pattern, text1) and not kmp(pattern, text2)\\n\\n    # Test 2)\\n    pattern = \\\"ABABX\\\"\\n    text = \\\"ABABZABABYABABX\\\"\\n    assert kmp(pattern, text)\\n\\n    # Test 3)\\n    pattern = \\\"AAAB\\\"\\n    text = \\\"ABAAAAAB\\\"\\n    assert kmp(pattern, text)\\n\\n    # Test 4)\\n    pattern = \\\"abcdabcy\\\"\\n    text = \\\"abcxabcdabxabcdabcdabcy\\\"\\n    assert kmp(pattern, text)\\n\\n    # Test 5)\\n    pattern = \\\"aabaabaaa\\\"\\n    assert get_failure_array(pattern) == [0, 1, 0, 1, 2, 3, 4, 5, 2]\\n\"",
    "levenshtein distance": "\"\\\"\\\"\\\"\\nThis is a Python implementation of the levenshtein distance.\\nLevenshtein distance is a string metric for measuring the\\ndifference between two sequences.\\n\\nFor doctests run following command:\\npython -m doctest -v levenshtein-distance.py\\nor\\npython3 -m doctest -v levenshtein-distance.py\\n\\nFor manual testing run:\\npython levenshtein-distance.py\\n\\\"\\\"\\\"\\n\\n\\ndef levenshtein_distance(first_word: str, second_word: str) -> int:\\n    \\\"\\\"\\\"Implementation of the levenshtein distance in Python.\\n    :param first_word: the first word to measure the difference.\\n    :param second_word: the second word to measure the difference.\\n    :return: the levenshtein distance between the two words.\\n    Examples:\\n    >>> levenshtein_distance(\\\"planet\\\", \\\"planetary\\\")\\n    3\\n    >>> levenshtein_distance(\\\"\\\", \\\"test\\\")\\n    4\\n    >>> levenshtein_distance(\\\"book\\\", \\\"back\\\")\\n    2\\n    >>> levenshtein_distance(\\\"book\\\", \\\"book\\\")\\n    0\\n    >>> levenshtein_distance(\\\"test\\\", \\\"\\\")\\n    4\\n    >>> levenshtein_distance(\\\"\\\", \\\"\\\")\\n    0\\n    >>> levenshtein_distance(\\\"orchestration\\\", \\\"container\\\")\\n    10\\n    \\\"\\\"\\\"\\n    # The longer word should come first\\n    if len(first_word) < len(second_word):\\n        return levenshtein_distance(second_word, first_word)\\n\\n    if len(second_word) == 0:\\n        return len(first_word)\\n\\n    previous_row = list(range(len(second_word) + 1))\\n\\n    for i, c1 in enumerate(first_word):\\n\\n        current_row = [i + 1]\\n\\n        for j, c2 in enumerate(second_word):\\n\\n            # Calculate insertions, deletions and substitutions\\n            insertions = previous_row[j + 1] + 1\\n            deletions = current_row[j] + 1\\n            substitutions = previous_row[j] + (c1 != c2)\\n\\n            # Get the minimum to append to the current row\\n            current_row.append(min(insertions, deletions, substitutions))\\n\\n        # Store the previous row\\n        previous_row = current_row\\n\\n    # Returns the last element (distance)\\n    return previous_row[-1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    first_word = input(\\\"Enter the first word:\\\\n\\\").strip()\\n    second_word = input(\\\"Enter the second word:\\\\n\\\").strip()\\n\\n    result = levenshtein_distance(first_word, second_word)\\n    print(f\\\"Levenshtein distance between {first_word} and {second_word} is {result}\\\")\\n\"",
    "lower": "\"def lower(word: str) -> str:\\n    \\\"\\\"\\\"\\n    Will convert the entire string to lowercase letters\\n\\n    >>> lower(\\\"wow\\\")\\n    'wow'\\n    >>> lower(\\\"HellZo\\\")\\n    'hellzo'\\n    >>> lower(\\\"WHAT\\\")\\n    'what'\\n    >>> lower(\\\"wh[]32\\\")\\n    'wh[]32'\\n    >>> lower(\\\"whAT\\\")\\n    'what'\\n    \\\"\\\"\\\"\\n\\n    # converting to ascii value int value and checking to see if char is a capital\\n    # letter if it is a capital letter it is getting shift by 32 which makes it a lower\\n    # case letter\\n    return \\\"\\\".join(chr(ord(char) + 32) if \\\"A\\\" <= char <= \\\"Z\\\" else char for char in word)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "manacher": "\"def palindromic_string(input_string: str) -> str:\\r\\n    \\\"\\\"\\\"\\r\\n    >>> palindromic_string('abbbaba')\\r\\n    'abbba'\\r\\n    >>> palindromic_string('ababa')\\r\\n    'ababa'\\r\\n\\r\\n    Manacher’s algorithm which finds Longest palindromic Substring in linear time.\\r\\n\\r\\n    1. first this convert input_string(\\\"xyx\\\") into new_string(\\\"x|y|x\\\") where odd\\r\\n        positions are actual input characters.\\r\\n    2. for each character in new_string it find corresponding length and store the\\r\\n        length and l,r to store previously calculated info.(please look the explanation\\r\\n        for details)\\r\\n\\r\\n    3. return corresponding output_string by removing all \\\"|\\\"\\r\\n    \\\"\\\"\\\"\\r\\n    max_length = 0\\r\\n\\r\\n    # if input_string is \\\"aba\\\" than new_input_string become \\\"a|b|a\\\"\\r\\n    new_input_string = \\\"\\\"\\r\\n    output_string = \\\"\\\"\\r\\n\\r\\n    # append each character + \\\"|\\\" in new_string for range(0, length-1)\\r\\n    for i in input_string[: len(input_string) - 1]:\\r\\n        new_input_string += i + \\\"|\\\"\\r\\n    # append last character\\r\\n    new_input_string += input_string[-1]\\r\\n\\r\\n    # we will store the starting and ending of previous furthest ending palindromic\\r\\n    # substring\\r\\n    l, r = 0, 0\\r\\n\\r\\n    # length[i] shows the length of palindromic substring with center i\\r\\n    length = [1 for i in range(len(new_input_string))]\\r\\n\\r\\n    # for each character in new_string find corresponding palindromic string\\r\\n    start = 0\\r\\n    for j in range(len(new_input_string)):\\r\\n        k = 1 if j > r else min(length[l + r - j] // 2, r - j + 1)\\r\\n        while (\\r\\n            j - k >= 0\\r\\n            and j + k < len(new_input_string)\\r\\n            and new_input_string[k + j] == new_input_string[j - k]\\r\\n        ):\\r\\n            k += 1\\r\\n\\r\\n        length[j] = 2 * k - 1\\r\\n\\r\\n        # does this string is ending after the previously explored end (that is r) ?\\r\\n        # if yes the update the new r to the last index of this\\r\\n        if j + k - 1 > r:\\r\\n            l = j - k + 1  # noqa: E741\\r\\n            r = j + k - 1\\r\\n\\r\\n        # update max_length and start position\\r\\n        if max_length < length[j]:\\r\\n            max_length = length[j]\\r\\n            start = j\\r\\n\\r\\n    # create that string\\r\\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\\r\\n    for i in s:\\r\\n        if i != \\\"|\\\":\\r\\n            output_string += i\\r\\n\\r\\n    return output_string\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\\r\\n\\\"\\\"\\\"\\r\\n...a0...a1...a2.....a3......a4...a5...a6....\\r\\n\\r\\nconsider the string for which we are calculating the longest palindromic substring is\\r\\nshown above where ... are some characters in between and right now we are calculating\\r\\nthe length of palindromic substring with center at a5 with following conditions :\\r\\ni) we have stored the length of palindromic substring which has center at a3 (starts at\\r\\n    l ends at r) and it is the furthest ending till now, and it has ending after a6\\r\\nii) a2 and a4 are equally distant from a3 so char(a2) == char(a4)\\r\\niii) a0 and a6 are equally distant from a3 so char(a0) == char(a6)\\r\\niv) a1 is corresponding equal character of a5 in palindrome with center a3 (remember\\r\\n    that in below derivation of a4==a6)\\r\\n\\r\\nnow for a5 we will calculate the length of palindromic substring with center as a5 but\\r\\ncan we use previously calculated information in some way?\\r\\nYes, look the above string we know that a5 is inside the palindrome with center a3 and\\r\\npreviously we have have calculated that\\r\\na0==a2 (palindrome of center a1)\\r\\na2==a4 (palindrome of center a3)\\r\\na0==a6 (palindrome of center a3)\\r\\nso a4==a6\\r\\n\\r\\nso we can say that palindrome at center a5 is at least as long as palindrome at center\\r\\na1 but this only holds if a0 and a6 are inside the limits of palindrome centered at a3\\r\\nso finally ..\\r\\n\\r\\nlen_of_palindrome__at(a5) = min(len_of_palindrome_at(a1), r-a5)\\r\\nwhere a3 lies from l to r and we have to keep updating that\\r\\n\\r\\nand if the a5 lies outside of l,r boundary we calculate length of palindrome with\\r\\nbruteforce and update l,r.\\r\\n\\r\\nit gives the linear time complexity just like z-function\\r\\n\\\"\\\"\\\"\\r\\n\"",
    "min cost string conversion": "\"\\\"\\\"\\\"\\nAlgorithm for calculating the most cost-efficient sequence for converting one string\\ninto another.\\nThe only allowed operations are\\n--- Cost to copy a character is copy_cost\\n--- Cost to replace a character is replace_cost\\n--- Cost to delete a character is delete_cost\\n--- Cost to insert a character is insert_cost\\n\\\"\\\"\\\"\\n\\n\\ndef compute_transform_tables(\\n    source_string: str,\\n    destination_string: str,\\n    copy_cost: int,\\n    replace_cost: int,\\n    delete_cost: int,\\n    insert_cost: int,\\n) -> tuple[list[list[int]], list[list[str]]]:\\n    source_seq = list(source_string)\\n    destination_seq = list(destination_string)\\n    len_source_seq = len(source_seq)\\n    len_destination_seq = len(destination_seq)\\n\\n    costs = [\\n        [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\\n    ]\\n    ops = [\\n        [\\\"0\\\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\\n    ]\\n\\n    for i in range(1, len_source_seq + 1):\\n        costs[i][0] = i * delete_cost\\n        ops[i][0] = \\\"D%c\\\" % source_seq[i - 1]\\n\\n    for i in range(1, len_destination_seq + 1):\\n        costs[0][i] = i * insert_cost\\n        ops[0][i] = \\\"I%c\\\" % destination_seq[i - 1]\\n\\n    for i in range(1, len_source_seq + 1):\\n        for j in range(1, len_destination_seq + 1):\\n            if source_seq[i - 1] == destination_seq[j - 1]:\\n                costs[i][j] = costs[i - 1][j - 1] + copy_cost\\n                ops[i][j] = \\\"C%c\\\" % source_seq[i - 1]\\n            else:\\n                costs[i][j] = costs[i - 1][j - 1] + replace_cost\\n                ops[i][j] = \\\"R%c\\\" % source_seq[i - 1] + str(destination_seq[j - 1])\\n\\n            if costs[i - 1][j] + delete_cost < costs[i][j]:\\n                costs[i][j] = costs[i - 1][j] + delete_cost\\n                ops[i][j] = \\\"D%c\\\" % source_seq[i - 1]\\n\\n            if costs[i][j - 1] + insert_cost < costs[i][j]:\\n                costs[i][j] = costs[i][j - 1] + insert_cost\\n                ops[i][j] = \\\"I%c\\\" % destination_seq[j - 1]\\n\\n    return costs, ops\\n\\n\\ndef assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:\\n    if i == 0 and j == 0:\\n        return []\\n    else:\\n        if ops[i][j][0] == \\\"C\\\" or ops[i][j][0] == \\\"R\\\":\\n            seq = assemble_transformation(ops, i - 1, j - 1)\\n            seq.append(ops[i][j])\\n            return seq\\n        elif ops[i][j][0] == \\\"D\\\":\\n            seq = assemble_transformation(ops, i - 1, j)\\n            seq.append(ops[i][j])\\n            return seq\\n        else:\\n            seq = assemble_transformation(ops, i, j - 1)\\n            seq.append(ops[i][j])\\n            return seq\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    _, operations = compute_transform_tables(\\\"Python\\\", \\\"Algorithms\\\", -1, 1, 2, 2)\\n\\n    m = len(operations)\\n    n = len(operations[0])\\n    sequence = assemble_transformation(operations, m - 1, n - 1)\\n\\n    string = list(\\\"Python\\\")\\n    i = 0\\n    cost = 0\\n\\n    with open(\\\"min_cost.txt\\\", \\\"w\\\") as file:\\n        for op in sequence:\\n            print(\\\"\\\".join(string))\\n\\n            if op[0] == \\\"C\\\":\\n                file.write(\\\"%-16s\\\" % \\\"Copy %c\\\" % op[1])\\n                file.write(\\\"\\\\t\\\\t\\\\t\\\" + \\\"\\\".join(string))\\n                file.write(\\\"\\\\r\\\\n\\\")\\n\\n                cost -= 1\\n            elif op[0] == \\\"R\\\":\\n                string[i] = op[2]\\n\\n                file.write(\\\"%-16s\\\" % (\\\"Replace %c\\\" % op[1] + \\\" with \\\" + str(op[2])))\\n                file.write(\\\"\\\\t\\\\t\\\" + \\\"\\\".join(string))\\n                file.write(\\\"\\\\r\\\\n\\\")\\n\\n                cost += 1\\n            elif op[0] == \\\"D\\\":\\n                string.pop(i)\\n\\n                file.write(\\\"%-16s\\\" % \\\"Delete %c\\\" % op[1])\\n                file.write(\\\"\\\\t\\\\t\\\\t\\\" + \\\"\\\".join(string))\\n                file.write(\\\"\\\\r\\\\n\\\")\\n\\n                cost += 2\\n            else:\\n                string.insert(i, op[1])\\n\\n                file.write(\\\"%-16s\\\" % \\\"Insert %c\\\" % op[1])\\n                file.write(\\\"\\\\t\\\\t\\\\t\\\" + \\\"\\\".join(string))\\n                file.write(\\\"\\\\r\\\\n\\\")\\n\\n                cost += 2\\n\\n            i += 1\\n\\n        print(\\\"\\\".join(string))\\n        print(\\\"Cost: \\\", cost)\\n\\n        file.write(\\\"\\\\r\\\\nMinimum cost: \\\" + str(cost))\\n\"",
    "naive string search": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/String-searching_algorithm#Na%C3%AFve_string_search\\nthis algorithm tries to find the pattern from every position of\\nthe mainString if pattern is found from position i it add it to\\nthe answer and does the same for position i+1\\nComplexity : O(n*m)\\n    n=length of main string\\n    m=length of pattern string\\n\\\"\\\"\\\"\\n\\n\\ndef naive_pattern_search(s: str, pattern: str) -> list:\\n    \\\"\\\"\\\"\\n    >>> naive_pattern_search(\\\"ABAAABCDBBABCDDEBCABC\\\", \\\"ABC\\\")\\n    [4, 10, 18]\\n    >>> naive_pattern_search(\\\"ABC\\\", \\\"ABAAABCDBBABCDDEBCABC\\\")\\n    []\\n    >>> naive_pattern_search(\\\"\\\", \\\"ABC\\\")\\n    []\\n    >>> naive_pattern_search(\\\"TEST\\\", \\\"TEST\\\")\\n    [0]\\n    >>> naive_pattern_search(\\\"ABCDEGFTEST\\\", \\\"TEST\\\")\\n    [7]\\n    \\\"\\\"\\\"\\n    pat_len = len(pattern)\\n    position = []\\n    for i in range(len(s) - pat_len + 1):\\n        match_found = True\\n        for j in range(pat_len):\\n            if s[i + j] != pattern[j]:\\n                match_found = False\\n                break\\n        if match_found:\\n            position.append(i)\\n    return position\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    assert naive_pattern_search(\\\"ABCDEFG\\\", \\\"DE\\\") == [3]\\n    print(naive_pattern_search(\\\"ABAAABCDBBABCDDEBCABC\\\", \\\"ABC\\\"))\\n\"",
    "palindrome": "\"# Algorithms to determine if a string is palindrome\\n\\ntest_data = {\\n    \\\"MALAYALAM\\\": True,\\n    \\\"String\\\": False,\\n    \\\"rotor\\\": True,\\n    \\\"level\\\": True,\\n    \\\"A\\\": True,\\n    \\\"BB\\\": True,\\n    \\\"ABC\\\": False,\\n    \\\"amanaplanacanalpanama\\\": True,  # \\\"a man a plan a canal panama\\\"\\n}\\n# Ensure our test data is valid\\nassert all((key == key[::-1]) is value for key, value in test_data.items())\\n\\n\\ndef is_palindrome(s: str) -> bool:\\n    \\\"\\\"\\\"\\n    Return True if s is a palindrome otherwise return False.\\n\\n    >>> all(is_palindrome(key) is value for key, value in test_data.items())\\n    True\\n    \\\"\\\"\\\"\\n\\n    start_i = 0\\n    end_i = len(s) - 1\\n    while start_i < end_i:\\n        if s[start_i] == s[end_i]:\\n            start_i += 1\\n            end_i -= 1\\n        else:\\n            return False\\n    return True\\n\\n\\ndef is_palindrome_recursive(s: str) -> bool:\\n    \\\"\\\"\\\"\\n    Return True if s is a palindrome otherwise return False.\\n\\n    >>> all(is_palindrome_recursive(key) is value for key, value in test_data.items())\\n    True\\n    \\\"\\\"\\\"\\n    if len(s) <= 1:\\n        return True\\n    if s[0] == s[len(s) - 1]:\\n        return is_palindrome_recursive(s[1:-1])\\n    else:\\n        return False\\n\\n\\ndef is_palindrome_slice(s: str) -> bool:\\n    \\\"\\\"\\\"\\n    Return True if s is a palindrome otherwise return False.\\n\\n    >>> all(is_palindrome_slice(key) is value for key, value in test_data.items())\\n    True\\n    \\\"\\\"\\\"\\n    return s == s[::-1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    for key, value in test_data.items():\\n        assert is_palindrome(key) is is_palindrome_recursive(key)\\n        assert is_palindrome(key) is is_palindrome_slice(key)\\n        print(f\\\"{key:21} {value}\\\")\\n    print(\\\"a man a plan a canal panama\\\")\\n\"",
    "prefix function": "\"\\\"\\\"\\\"\\nhttps://cp-algorithms.com/string/prefix-function.html\\n\\nPrefix function Knuth–Morris–Pratt algorithm\\n\\nDifferent algorithm than Knuth-Morris-Pratt pattern finding\\n\\nE.x. Finding longest prefix which is also suffix\\n\\nTime Complexity: O(n) - where n is the length of the string\\n\\\"\\\"\\\"\\n\\n\\ndef prefix_function(input_string: str) -> list:\\n    \\\"\\\"\\\"\\n    For the given string this function computes value for each index(i),\\n    which represents the longest coincidence of prefix and suffix\\n    for given substring (input_str[0...i])\\n\\n    For the value of the first element the algorithm always returns 0\\n\\n    >>> prefix_function(\\\"aabcdaabc\\\")\\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\\n    >>> prefix_function(\\\"asdasdad\\\")\\n    [0, 0, 0, 1, 2, 3, 4, 0]\\n    \\\"\\\"\\\"\\n\\n    # list for the result values\\n    prefix_result = [0] * len(input_string)\\n\\n    for i in range(1, len(input_string)):\\n\\n        # use last results for better performance - dynamic programming\\n        j = prefix_result[i - 1]\\n        while j > 0 and input_string[i] != input_string[j]:\\n            j = prefix_result[j - 1]\\n\\n        if input_string[i] == input_string[j]:\\n            j += 1\\n        prefix_result[i] = j\\n\\n    return prefix_result\\n\\n\\ndef longest_prefix(input_str: str) -> int:\\n    \\\"\\\"\\\"\\n    Prefix-function use case\\n    Finding longest prefix which is suffix as well\\n\\n    >>> longest_prefix(\\\"aabcdaabc\\\")\\n    4\\n    >>> longest_prefix(\\\"asdasdad\\\")\\n    4\\n    >>> longest_prefix(\\\"abcab\\\")\\n    2\\n    \\\"\\\"\\\"\\n\\n    # just returning maximum value of the array gives us answer\\n    return max(prefix_function(input_str))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "rabin karp": "\"# Numbers of alphabet which we call base\\nalphabet_size = 256\\n# Modulus to hash a string\\nmodulus = 1000003\\n\\n\\ndef rabin_karp(pattern: str, text: str) -> bool:\\n    \\\"\\\"\\\"\\n    The Rabin-Karp Algorithm for finding a pattern within a piece of text\\n    with complexity O(nm), most efficient when it is used with multiple patterns\\n    as it is able to check if any of a set of patterns match a section of text in o(1)\\n    given the precomputed hashes.\\n\\n    This will be the simple version which only assumes one pattern is being searched\\n    for but it's not hard to modify\\n\\n    1) Calculate pattern hash\\n\\n    2) Step through the text one character at a time passing a window with the same\\n        length as the pattern\\n        calculating the hash of the text within the window compare it with the hash\\n        of the pattern. Only testing equality if the hashes match\\n    \\\"\\\"\\\"\\n    p_len = len(pattern)\\n    t_len = len(text)\\n    if p_len > t_len:\\n        return False\\n\\n    p_hash = 0\\n    text_hash = 0\\n    modulus_power = 1\\n\\n    # Calculating the hash of pattern and substring of text\\n    for i in range(p_len):\\n        p_hash = (ord(pattern[i]) + p_hash * alphabet_size) % modulus\\n        text_hash = (ord(text[i]) + text_hash * alphabet_size) % modulus\\n        if i == p_len - 1:\\n            continue\\n        modulus_power = (modulus_power * alphabet_size) % modulus\\n\\n    for i in range(0, t_len - p_len + 1):\\n        if text_hash == p_hash and text[i : i + p_len] == pattern:\\n            return True\\n        if i == t_len - p_len:\\n            continue\\n        # Calculate the https://en.wikipedia.org/wiki/Rolling_hash\\n        text_hash = (\\n            (text_hash - ord(text[i]) * modulus_power) * alphabet_size\\n            + ord(text[i + p_len])\\n        ) % modulus\\n    return False\\n\\n\\ndef test_rabin_karp() -> None:\\n    \\\"\\\"\\\"\\n    >>> test_rabin_karp()\\n    Success.\\n    \\\"\\\"\\\"\\n    # Test 1)\\n    pattern = \\\"abc1abc12\\\"\\n    text1 = \\\"alskfjaldsabc1abc1abc12k23adsfabcabc\\\"\\n    text2 = \\\"alskfjaldsk23adsfabcabc\\\"\\n    assert rabin_karp(pattern, text1) and not rabin_karp(pattern, text2)\\n\\n    # Test 2)\\n    pattern = \\\"ABABX\\\"\\n    text = \\\"ABABZABABYABABX\\\"\\n    assert rabin_karp(pattern, text)\\n\\n    # Test 3)\\n    pattern = \\\"AAAB\\\"\\n    text = \\\"ABAAAAAB\\\"\\n    assert rabin_karp(pattern, text)\\n\\n    # Test 4)\\n    pattern = \\\"abcdabcy\\\"\\n    text = \\\"abcxabcdabxabcdabcdabcy\\\"\\n    assert rabin_karp(pattern, text)\\n\\n    # Test 5)\\n    pattern = \\\"Lü\\\"\\n    text = \\\"Lüsai\\\"\\n    assert rabin_karp(pattern, text)\\n    pattern = \\\"Lue\\\"\\n    assert not rabin_karp(pattern, text)\\n    print(\\\"Success.\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    test_rabin_karp()\\n\"",
    "remove duplicate": "\"def remove_duplicates(sentence: str) -> str:\\n    \\\"\\\"\\\"\\n    Remove duplicates from sentence\\n    >>> remove_duplicates(\\\"Python is great and Java is also great\\\")\\n    'Java Python also and great is'\\n    >>> remove_duplicates(\\\"Python   is      great and Java is also great\\\")\\n    'Java Python also and great is'\\n    \\\"\\\"\\\"\\n    return \\\" \\\".join(sorted(set(sentence.split())))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "reverse letters": "\"def reverse_letters(input_str: str) -> str:\\n    \\\"\\\"\\\"\\n    Reverses letters in a given string without adjusting the position of the words\\n    >>> reverse_letters('The cat in the hat')\\n    'ehT tac ni eht tah'\\n    >>> reverse_letters('The quick brown fox jumped over the lazy dog.')\\n    'ehT kciuq nworb xof depmuj revo eht yzal .god'\\n    >>> reverse_letters('Is this true?')\\n    'sI siht ?eurt'\\n    >>> reverse_letters(\\\"I   love       Python\\\")\\n    'I evol nohtyP'\\n    \\\"\\\"\\\"\\n    return \\\" \\\".join([word[::-1] for word in input_str.split()])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "reverse long words": "\"def reverse_long_words(sentence: str) -> str:\\n    \\\"\\\"\\\"\\n    Reverse all words that are longer than 4 characters in a sentence.\\n\\n    >>> reverse_long_words(\\\"Hey wollef sroirraw\\\")\\n    'Hey fellow warriors'\\n    >>> reverse_long_words(\\\"nohtyP is nohtyP\\\")\\n    'Python is Python'\\n    >>> reverse_long_words(\\\"1 12 123 1234 54321 654321\\\")\\n    '1 12 123 1234 12345 123456'\\n    \\\"\\\"\\\"\\n    return \\\" \\\".join(\\n        \\\"\\\".join(word[::-1]) if len(word) > 4 else word for word in sentence.split()\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    print(reverse_long_words(\\\"Hey wollef sroirraw\\\"))\\n\"",
    "reverse words": "\"def reverse_words(input_str: str) -> str:\\n    \\\"\\\"\\\"\\n    Reverses words in a given string\\n    >>> reverse_words(\\\"I love Python\\\")\\n    'Python love I'\\n    >>> reverse_words(\\\"I     Love          Python\\\")\\n    'Python Love I'\\n    \\\"\\\"\\\"\\n    return \\\" \\\".join(input_str.split()[::-1])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "split": "\"def split(string: str, separator: str = \\\" \\\") -> list:\\n    \\\"\\\"\\\"\\n    Will split the string up into all the values separated by the separator\\n    (defaults to spaces)\\n\\n    >>> split(\\\"apple#banana#cherry#orange\\\",separator='#')\\n    ['apple', 'banana', 'cherry', 'orange']\\n\\n    >>> split(\\\"Hello there\\\")\\n    ['Hello', 'there']\\n\\n    >>> split(\\\"11/22/63\\\",separator = '/')\\n    ['11', '22', '63']\\n\\n    >>> split(\\\"12:43:39\\\",separator = \\\":\\\")\\n    ['12', '43', '39']\\n    \\\"\\\"\\\"\\n\\n    split_words = []\\n\\n    last_index = 0\\n    for index, char in enumerate(string):\\n        if char == separator:\\n            split_words.append(string[last_index:index])\\n            last_index = index + 1\\n        elif index + 1 == len(string):\\n            split_words.append(string[last_index : index + 1])\\n    return split_words\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "upper": "\"def upper(word: str) -> str:\\n    \\\"\\\"\\\"\\n    Will convert the entire string to uppercase letters\\n\\n    >>> upper(\\\"wow\\\")\\n    'WOW'\\n    >>> upper(\\\"Hello\\\")\\n    'HELLO'\\n    >>> upper(\\\"WHAT\\\")\\n    'WHAT'\\n    >>> upper(\\\"wh[]32\\\")\\n    'WH[]32'\\n    \\\"\\\"\\\"\\n\\n    # Converting to ascii value int value and checking to see if char is a lower letter\\n    # if it is a lowercase letter it is getting shift by 32 which makes it an uppercase\\n    # case letter\\n    return \\\"\\\".join(chr(ord(char) - 32) if \\\"a\\\" <= char <= \\\"z\\\" else char for char in word)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "wildcard pattern matching": "\"\\\"\\\"\\\"\\nImplementation of regular expression matching with support for '.' and '*'.\\n'.' Matches any single character.\\n'*' Matches zero or more of the preceding element.\\nThe matching should cover the entire input string (not partial).\\n\\n\\\"\\\"\\\"\\n\\n\\ndef match_pattern(input_string: str, pattern: str) -> bool:\\n    \\\"\\\"\\\"\\n    uses bottom-up dynamic programming solution for matching the input\\n    string with a given pattern.\\n\\n    Runtime: O(len(input_string)*len(pattern))\\n\\n    Arguments\\n    --------\\n    input_string: str, any string which should be compared with the pattern\\n    pattern: str, the string that represents a pattern and may contain\\n    '.' for single character matches and '*' for zero or more of preceding character\\n    matches\\n\\n    Note\\n    ----\\n    the pattern cannot start with a '*',\\n    because there should be at least one character before *\\n\\n    Returns\\n    -------\\n    A Boolean denoting whether the given string follows the pattern\\n\\n    Examples\\n    -------\\n    >>> match_pattern(\\\"aab\\\", \\\"c*a*b\\\")\\n    True\\n    >>> match_pattern(\\\"dabc\\\", \\\"*abc\\\")\\n    False\\n    >>> match_pattern(\\\"aaa\\\", \\\"aa\\\")\\n    False\\n    >>> match_pattern(\\\"aaa\\\", \\\"a.a\\\")\\n    True\\n    >>> match_pattern(\\\"aaab\\\", \\\"aa*\\\")\\n    False\\n    >>> match_pattern(\\\"aaab\\\", \\\".*\\\")\\n    True\\n    >>> match_pattern(\\\"a\\\", \\\"bbbb\\\")\\n    False\\n    >>> match_pattern(\\\"\\\", \\\"bbbb\\\")\\n    False\\n    >>> match_pattern(\\\"a\\\", \\\"\\\")\\n    False\\n    >>> match_pattern(\\\"\\\", \\\"\\\")\\n    True\\n    \\\"\\\"\\\"\\n\\n    len_string = len(input_string) + 1\\n    len_pattern = len(pattern) + 1\\n\\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\\n    # length i of input_string matches with prefix string of length j of\\n    # given pattern.\\n    # \\\"dp\\\" stands for dynamic programming.\\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\\n\\n    # since string of zero length match pattern of zero length\\n    dp[0][0] = 1\\n\\n    # since pattern of zero length will never match with string of non-zero length\\n    for i in range(1, len_string):\\n        dp[i][0] = 0\\n\\n    # since string of zero length will match with pattern where there\\n    # is at least one * alternatively\\n    for j in range(1, len_pattern):\\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \\\"*\\\" else 0\\n\\n    # now using bottom-up approach to find for all remaining lengths\\n    for i in range(1, len_string):\\n        for j in range(1, len_pattern):\\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \\\".\\\":\\n                dp[i][j] = dp[i - 1][j - 1]\\n\\n            elif pattern[j - 1] == \\\"*\\\":\\n                if dp[i][j - 2] == 1:\\n                    dp[i][j] = 1\\n                elif pattern[j - 2] in (input_string[i - 1], \\\".\\\"):\\n                    dp[i][j] = dp[i - 1][j]\\n                else:\\n                    dp[i][j] = 0\\n            else:\\n                dp[i][j] = 0\\n\\n    return bool(dp[-1][-1])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    # inputing the strings\\n    # input_string = input(\\\"input a string :\\\")\\n    # pattern = input(\\\"input a pattern :\\\")\\n\\n    input_string = \\\"aab\\\"\\n    pattern = \\\"c*a*b\\\"\\n\\n    # using function to check whether given string matches the given pattern\\n    if match_pattern(input_string, pattern):\\n        print(f\\\"{input_string} matches the given pattern {pattern}\\\")\\n    else:\\n        print(f\\\"{input_string} does not match with the given pattern {pattern}\\\")\\n\"",
    "word occurrence": "\"# Created by sarathkaul on 17/11/19\\n# Modified by Arkadip Bhattacharya(@darkmatter18) on 20/04/2020\\nfrom collections import defaultdict\\n\\n\\ndef word_occurence(sentence: str) -> dict:\\n    \\\"\\\"\\\"\\n    >>> from collections import Counter\\n    >>> SENTENCE = \\\"a b A b c b d b d e f e g e h e i e j e 0\\\"\\n    >>> occurence_dict = word_occurence(SENTENCE)\\n    >>> all(occurence_dict[word] == count for word, count\\n    ...     in Counter(SENTENCE.split()).items())\\n    True\\n    >>> dict(word_occurence(\\\"Two  spaces\\\"))\\n    {'Two': 1, 'spaces': 1}\\n    \\\"\\\"\\\"\\n    occurrence: dict = defaultdict(int)\\n    # Creating a dictionary containing count of each word\\n    for word in sentence.split():\\n        occurrence[word] += 1\\n    return occurrence\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    for word, count in word_occurence(\\\"INPUT STRING\\\").items():\\n        print(f\\\"{word}: {count}\\\")\\n\"",
    "word patterns": "\"def get_word_pattern(word: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> get_word_pattern(\\\"pattern\\\")\\n    '0.1.2.2.3.4.5'\\n    >>> get_word_pattern(\\\"word pattern\\\")\\n    '0.1.2.3.4.5.6.7.7.8.2.9'\\n    >>> get_word_pattern(\\\"get word pattern\\\")\\n    '0.1.2.3.4.5.6.7.3.8.9.2.2.1.6.10'\\n    \\\"\\\"\\\"\\n    word = word.upper()\\n    next_num = 0\\n    letter_nums = {}\\n    word_pattern = []\\n\\n    for letter in word:\\n        if letter not in letter_nums:\\n            letter_nums[letter] = str(next_num)\\n            next_num += 1\\n        word_pattern.append(letter_nums[letter])\\n    return \\\".\\\".join(word_pattern)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import pprint\\n    import time\\n\\n    start_time = time.time()\\n    with open(\\\"dictionary.txt\\\") as in_file:\\n        wordList = in_file.read().splitlines()\\n\\n    all_patterns: dict = {}\\n    for word in wordList:\\n        pattern = get_word_pattern(word)\\n        if pattern in all_patterns:\\n            all_patterns[pattern].append(word)\\n        else:\\n            all_patterns[pattern] = [word]\\n\\n    with open(\\\"word_patterns.txt\\\", \\\"w\\\") as out_file:\\n        out_file.write(pprint.pformat(all_patterns))\\n\\n    totalTime = round(time.time() - start_time, 2)\\n    print(f\\\"Done!  {len(all_patterns):,} word patterns found in {totalTime} seconds.\\\")\\n    # Done!  9,581 word patterns found in 0.58 seconds.\\n\"",
    "z function": "\"\\\"\\\"\\\"\\nhttps://cp-algorithms.com/string/z-function.html\\n\\nZ-function or Z algorithm\\n\\nEfficient algorithm for pattern occurrence in a string\\n\\nTime Complexity: O(n) - where n is the length of the string\\n\\n\\\"\\\"\\\"\\n\\n\\ndef z_function(input_str: str) -> list:\\n    \\\"\\\"\\\"\\n    For the given string this function computes value for each index,\\n    which represents the maximal length substring starting from the index\\n    and is the same as the prefix of the same size\\n\\n    e.x.  for string 'abab' for second index value would be 2\\n\\n    For the value of the first element the algorithm always returns 0\\n\\n    >>> z_function(\\\"abracadabra\\\")\\n    [0, 0, 0, 1, 0, 1, 0, 4, 0, 0, 1]\\n    >>> z_function(\\\"aaaa\\\")\\n    [0, 3, 2, 1]\\n    >>> z_function(\\\"zxxzxxz\\\")\\n    [0, 0, 0, 4, 0, 0, 1]\\n    \\\"\\\"\\\"\\n    z_result = [0] * len(input_str)\\n\\n    # initialize interval's left pointer and right pointer\\n    left_pointer, right_pointer = 0, 0\\n\\n    for i in range(1, len(input_str)):\\n        # case when current index is inside the interval\\n        if i <= right_pointer:\\n            min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])\\n            z_result[i] = min_edge\\n\\n        while go_next(i, z_result, input_str):\\n            z_result[i] += 1\\n\\n        # if new index's result gives us more right interval,\\n        # we've to update left_pointer and right_pointer\\n        if i + z_result[i] - 1 > right_pointer:\\n            left_pointer, right_pointer = i, i + z_result[i] - 1\\n\\n    return z_result\\n\\n\\ndef go_next(i, z_result, s):\\n    \\\"\\\"\\\"\\n    Check if we have to move forward to the next characters or not\\n    \\\"\\\"\\\"\\n    return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]\\n\\n\\ndef find_pattern(pattern: str, input_str: str) -> int:\\n    \\\"\\\"\\\"\\n    Example of using z-function for pattern occurrence\\n    Given function returns the number of times 'pattern'\\n    appears in 'input_str' as a substring\\n\\n    >>> find_pattern(\\\"abr\\\", \\\"abracadabra\\\")\\n    2\\n    >>> find_pattern(\\\"a\\\", \\\"aaaa\\\")\\n    4\\n    >>> find_pattern(\\\"xz\\\", \\\"zxxzxxz\\\")\\n    2\\n    \\\"\\\"\\\"\\n    answer = 0\\n    # concatenate 'pattern' and 'input_str' and call z_function\\n    # with concatenated string\\n    z_result = z_function(pattern + input_str)\\n\\n    for val in z_result:\\n        # if value is greater then length of the pattern string\\n        # that means this index is starting position of substring\\n        # which is equal to pattern string\\n        if val >= len(pattern):\\n            answer += 1\\n\\n    return answer\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "co2 emission": "\"\\\"\\\"\\\"\\nGet CO2 emission data from the UK CarbonIntensity API\\n\\\"\\\"\\\"\\nfrom datetime import date\\n\\nimport requests\\n\\nBASE_URL = \\\"https://api.carbonintensity.org.uk/intensity\\\"\\n\\n\\n# Emission in the last half hour\\ndef fetch_last_half_hour() -> str:\\n    last_half_hour = requests.get(BASE_URL).json()[\\\"data\\\"][0]\\n    return last_half_hour[\\\"intensity\\\"][\\\"actual\\\"]\\n\\n\\n# Emissions in a specific date range\\ndef fetch_from_to(start, end) -> list:\\n    return requests.get(f\\\"{BASE_URL}/{start}/{end}\\\").json()[\\\"data\\\"]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    for entry in fetch_from_to(start=date(2020, 10, 1), end=date(2020, 10, 3)):\\n        print(\\\"from {from} to {to}: {intensity[actual]}\\\".format(**entry))\\n    print(f\\\"{fetch_last_half_hour() = }\\\")\\n\"",
    "covid stats via xpath": "\"\\\"\\\"\\\"\\nThis is to show simple COVID19 info fetching from worldometers site using lxml\\n* The main motivation to use lxml in place of bs4 is that it is faster and therefore\\nmore convenient to use in Python web projects (e.g. Django or Flask-based)\\n\\\"\\\"\\\"\\n\\nfrom collections import namedtuple\\n\\nimport requests\\nfrom lxml import html  # type: ignore\\n\\ncovid_data = namedtuple(\\\"covid_data\\\", \\\"cases deaths recovered\\\")\\n\\n\\ndef covid_stats(url: str = \\\"https://www.worldometers.info/coronavirus/\\\") -> covid_data:\\n    xpath_str = '//div[@class = \\\"maincounter-number\\\"]/span/text()'\\n    return covid_data(*html.fromstring(requests.get(url).content).xpath(xpath_str))\\n\\n\\nfmt = \\\"\\\"\\\"Total COVID-19 cases in the world: {}\\nTotal deaths due to COVID-19 in the world: {}\\nTotal COVID-19 patients recovered in the world: {}\\\"\\\"\\\"\\nprint(fmt.format(*covid_stats()))\\n\"",
    "crawl google results": "\"import sys\\nimport webbrowser\\n\\nimport requests\\nfrom bs4 import BeautifulSoup\\nfrom fake_useragent import UserAgent\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"Googling.....\\\")\\n    url = \\\"https://www.google.com/search?q=\\\" + \\\" \\\".join(sys.argv[1:])\\n    res = requests.get(url, headers={\\\"UserAgent\\\": UserAgent().random})\\n    # res.raise_for_status()\\n    with open(\\\"project1a.html\\\", \\\"wb\\\") as out_file:  # only for knowing the class\\n        for data in res.iter_content(10000):\\n            out_file.write(data)\\n    soup = BeautifulSoup(res.text, \\\"html.parser\\\")\\n    links = list(soup.select(\\\".eZt8xd\\\"))[:5]\\n\\n    print(len(links))\\n    for link in links:\\n        if link.text == \\\"Maps\\\":\\n            webbrowser.open(link.get(\\\"href\\\"))\\n        else:\\n            webbrowser.open(f\\\"http://google.com{link.get('href')}\\\")\\n\"",
    "crawl google scholar citation": "\"\\\"\\\"\\\"\\nGet the citation from google scholar\\nusing title and year of publication, and volume and pages of journal.\\n\\\"\\\"\\\"\\n\\nimport requests\\nfrom bs4 import BeautifulSoup\\n\\n\\ndef get_citation(base_url: str, params: dict) -> str:\\n    \\\"\\\"\\\"\\n    Return the citation number.\\n    \\\"\\\"\\\"\\n    soup = BeautifulSoup(requests.get(base_url, params=params).content, \\\"html.parser\\\")\\n    div = soup.find(\\\"div\\\", attrs={\\\"class\\\": \\\"gs_ri\\\"})\\n    anchors = div.find(\\\"div\\\", attrs={\\\"class\\\": \\\"gs_fl\\\"}).find_all(\\\"a\\\")\\n    return anchors[2].get_text()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    params = {\\n        \\\"title\\\": (\\n            \\\"Precisely geometry controlled microsupercapacitors for ultrahigh areal \\\"\\n            \\\"capacitance, volumetric capacitance, and energy density\\\"\\n        ),\\n        \\\"journal\\\": \\\"Chem. Mater.\\\",\\n        \\\"volume\\\": 30,\\n        \\\"pages\\\": \\\"3979-3990\\\",\\n        \\\"year\\\": 2018,\\n        \\\"hl\\\": \\\"en\\\",\\n    }\\n    print(get_citation(\\\"http://scholar.google.com/scholar_lookup\\\", params=params))\\n\"",
    "currency converter": "\"\\\"\\\"\\\"\\nThis is used to convert the currency using the Amdoren Currency API\\nhttps://www.amdoren.com\\n\\\"\\\"\\\"\\n\\nimport os\\n\\nimport requests\\n\\nURL_BASE = \\\"https://www.amdoren.com/api/currency.php\\\"\\nTESTING = os.getenv(\\\"CI\\\", False)\\nAPI_KEY = os.getenv(\\\"AMDOREN_API_KEY\\\", \\\"\\\")\\nif not API_KEY and not TESTING:\\n    raise KeyError(\\\"Please put your API key in an environment variable.\\\")\\n\\n\\n# Currency and their description\\nlist_of_currencies = \\\"\\\"\\\"\\nAED\\tUnited Arab Emirates Dirham\\nAFN\\tAfghan Afghani\\nALL\\tAlbanian Lek\\nAMD\\tArmenian Dram\\nANG\\tNetherlands Antillean Guilder\\nAOA\\tAngolan Kwanza\\nARS\\tArgentine Peso\\nAUD\\tAustralian Dollar\\nAWG\\tAruban Florin\\nAZN\\tAzerbaijani Manat\\nBAM\\tBosnia & Herzegovina Convertible Mark\\nBBD\\tBarbadian Dollar\\nBDT\\tBangladeshi Taka\\nBGN\\tBulgarian Lev\\nBHD\\tBahraini Dinar\\nBIF\\tBurundian Franc\\nBMD\\tBermudian Dollar\\nBND\\tBrunei Dollar\\nBOB\\tBolivian Boliviano\\nBRL\\tBrazilian Real\\nBSD\\tBahamian Dollar\\nBTN\\tBhutanese Ngultrum\\nBWP\\tBotswana Pula\\nBYN\\tBelarus Ruble\\nBZD\\tBelize Dollar\\nCAD\\tCanadian Dollar\\nCDF\\tCongolese Franc\\nCHF\\tSwiss Franc\\nCLP\\tChilean Peso\\nCNY\\tChinese Yuan\\nCOP\\tColombian Peso\\nCRC\\tCosta Rican Colon\\nCUC\\tCuban Convertible Peso\\nCVE\\tCape Verdean Escudo\\nCZK\\tCzech Republic Koruna\\nDJF\\tDjiboutian Franc\\nDKK\\tDanish Krone\\nDOP\\tDominican Peso\\nDZD\\tAlgerian Dinar\\nEGP\\tEgyptian Pound\\nERN\\tEritrean Nakfa\\nETB\\tEthiopian Birr\\nEUR\\tEuro\\nFJD\\tFiji Dollar\\nGBP\\tBritish Pound Sterling\\nGEL\\tGeorgian Lari\\nGHS\\tGhanaian Cedi\\nGIP\\tGibraltar Pound\\nGMD\\tGambian Dalasi\\nGNF\\tGuinea Franc\\nGTQ\\tGuatemalan Quetzal\\nGYD\\tGuyanaese Dollar\\nHKD\\tHong Kong Dollar\\nHNL\\tHonduran Lempira\\nHRK\\tCroatian Kuna\\nHTG\\tHaiti Gourde\\nHUF\\tHungarian Forint\\nIDR\\tIndonesian Rupiah\\nILS\\tIsraeli Shekel\\nINR\\tIndian Rupee\\nIQD\\tIraqi Dinar\\nIRR\\tIranian Rial\\nISK\\tIcelandic Krona\\nJMD\\tJamaican Dollar\\nJOD\\tJordanian Dinar\\nJPY\\tJapanese Yen\\nKES\\tKenyan Shilling\\nKGS\\tKyrgystani Som\\nKHR\\tCambodian Riel\\nKMF\\tComorian Franc\\nKPW\\tNorth Korean Won\\nKRW\\tSouth Korean Won\\nKWD\\tKuwaiti Dinar\\nKYD\\tCayman Islands Dollar\\nKZT\\tKazakhstan Tenge\\nLAK\\tLaotian Kip\\nLBP\\tLebanese Pound\\nLKR\\tSri Lankan Rupee\\nLRD\\tLiberian Dollar\\nLSL\\tLesotho Loti\\nLYD\\tLibyan Dinar\\nMAD\\tMoroccan Dirham\\nMDL\\tMoldovan Leu\\nMGA\\tMalagasy Ariary\\nMKD\\tMacedonian Denar\\nMMK\\tMyanma Kyat\\nMNT\\tMongolian Tugrik\\nMOP\\tMacau Pataca\\nMRO\\tMauritanian Ouguiya\\nMUR\\tMauritian Rupee\\nMVR\\tMaldivian Rufiyaa\\nMWK\\tMalawi Kwacha\\nMXN\\tMexican Peso\\nMYR\\tMalaysian Ringgit\\nMZN\\tMozambican Metical\\nNAD\\tNamibian Dollar\\nNGN\\tNigerian Naira\\nNIO\\tNicaragua Cordoba\\nNOK\\tNorwegian Krone\\nNPR\\tNepalese Rupee\\nNZD\\tNew Zealand Dollar\\nOMR\\tOmani Rial\\nPAB\\tPanamanian Balboa\\nPEN\\tPeruvian Nuevo Sol\\nPGK\\tPapua New Guinean Kina\\nPHP\\tPhilippine Peso\\nPKR\\tPakistani Rupee\\nPLN\\tPolish Zloty\\nPYG\\tParaguayan Guarani\\nQAR\\tQatari Riyal\\nRON\\tRomanian Leu\\nRSD\\tSerbian Dinar\\nRUB\\tRussian Ruble\\nRWF\\tRwanda Franc\\nSAR\\tSaudi Riyal\\nSBD\\tSolomon Islands Dollar\\nSCR\\tSeychellois Rupee\\nSDG\\tSudanese Pound\\nSEK\\tSwedish Krona\\nSGD\\tSingapore Dollar\\nSHP\\tSaint Helena Pound\\nSLL\\tSierra Leonean Leone\\nSOS\\tSomali Shilling\\nSRD\\tSurinamese Dollar\\nSSP\\tSouth Sudanese Pound\\nSTD\\tSao Tome and Principe Dobra\\nSYP\\tSyrian Pound\\nSZL\\tSwazi Lilangeni\\nTHB\\tThai Baht\\nTJS\\tTajikistan Somoni\\nTMT\\tTurkmenistani Manat\\nTND\\tTunisian Dinar\\nTOP\\tTonga Paanga\\nTRY\\tTurkish Lira\\nTTD\\tTrinidad and Tobago Dollar\\nTWD\\tNew Taiwan Dollar\\nTZS\\tTanzanian Shilling\\nUAH\\tUkrainian Hryvnia\\nUGX\\tUgandan Shilling\\nUSD\\tUnited States Dollar\\nUYU\\tUruguayan Peso\\nUZS\\tUzbekistan Som\\nVEF\\tVenezuelan Bolivar\\nVND\\tVietnamese Dong\\nVUV\\tVanuatu Vatu\\nWST\\tSamoan Tala\\nXAF\\tCentral African CFA franc\\nXCD\\tEast Caribbean Dollar\\nXOF\\tWest African CFA franc\\nXPF\\tCFP Franc\\nYER\\tYemeni Rial\\nZAR\\tSouth African Rand\\nZMW\\tZambian Kwacha\\n\\\"\\\"\\\"\\n\\n\\ndef convert_currency(\\n    from_: str = \\\"USD\\\", to: str = \\\"INR\\\", amount: float = 1.0, api_key: str = API_KEY\\n) -> str:\\n    \\\"\\\"\\\"https://www.amdoren.com/currency-api/\\\"\\\"\\\"\\n    params = locals()\\n    params[\\\"from\\\"] = params.pop(\\\"from_\\\")\\n    res = requests.get(URL_BASE, params=params).json()\\n    return str(res[\\\"amount\\\"]) if res[\\\"error\\\"] == 0 else res[\\\"error_message\\\"]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\n        convert_currency(\\n            input(\\\"Enter from currency: \\\").strip(),\\n            input(\\\"Enter to currency: \\\").strip(),\\n            float(input(\\\"Enter the amount: \\\").strip()),\\n        )\\n    )\\n\"",
    "current stock price": "\"import requests\\nfrom bs4 import BeautifulSoup\\n\\n\\ndef stock_price(symbol: str = \\\"AAPL\\\") -> str:\\n    url = f\\\"https://in.finance.yahoo.com/quote/{symbol}?s={symbol}\\\"\\n    soup = BeautifulSoup(requests.get(url).text, \\\"html.parser\\\")\\n    class_ = \\\"My(6px) Pos(r) smartphone_Mt(6px)\\\"\\n    return soup.find(\\\"div\\\", class_=class_).find(\\\"span\\\").text\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    for symbol in \\\"AAPL AMZN IBM GOOG MSFT ORCL\\\".split():\\n        print(f\\\"Current {symbol:<4} stock price is {stock_price(symbol):>8}\\\")\\n\"",
    "current weather": "\"import requests\\n\\nAPPID = \\\"\\\"  # <-- Put your OpenWeatherMap appid here!\\nURL_BASE = \\\"http://api.openweathermap.org/data/2.5/\\\"\\n\\n\\ndef current_weather(q: str = \\\"Chicago\\\", appid: str = APPID) -> dict:\\n    \\\"\\\"\\\"https://openweathermap.org/api\\\"\\\"\\\"\\n    return requests.get(URL_BASE + \\\"weather\\\", params=locals()).json()\\n\\n\\ndef weather_forecast(q: str = \\\"Kolkata, India\\\", appid: str = APPID) -> dict:\\n    \\\"\\\"\\\"https://openweathermap.org/forecast5\\\"\\\"\\\"\\n    return requests.get(URL_BASE + \\\"forecast\\\", params=locals()).json()\\n\\n\\ndef weather_onecall(lat: float = 55.68, lon: float = 12.57, appid: str = APPID) -> dict:\\n    \\\"\\\"\\\"https://openweathermap.org/api/one-call-api\\\"\\\"\\\"\\n    return requests.get(URL_BASE + \\\"onecall\\\", params=locals()).json()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from pprint import pprint\\n\\n    while True:\\n        location = input(\\\"Enter a location:\\\").strip()\\n        if location:\\n            pprint(current_weather(location))\\n        else:\\n            break\\n\"",
    "daily horoscope": "\"import requests\\nfrom bs4 import BeautifulSoup\\n\\n\\ndef horoscope(zodiac_sign: int, day: str) -> str:\\n    url = (\\n        \\\"https://www.horoscope.com/us/horoscopes/general/\\\"\\n        f\\\"horoscope-general-daily-{day}.aspx?sign={zodiac_sign}\\\"\\n    )\\n    soup = BeautifulSoup(requests.get(url).content, \\\"html.parser\\\")\\n    return soup.find(\\\"div\\\", class_=\\\"main-horoscope\\\").p.text\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"Daily Horoscope. \\\\n\\\")\\n    print(\\n        \\\"enter your Zodiac sign number:\\\\n\\\",\\n        \\\"1. Aries\\\\n\\\",\\n        \\\"2. Taurus\\\\n\\\",\\n        \\\"3. Gemini\\\\n\\\",\\n        \\\"4. Cancer\\\\n\\\",\\n        \\\"5. Leo\\\\n\\\",\\n        \\\"6. Virgo\\\\n\\\",\\n        \\\"7. Libra\\\\n\\\",\\n        \\\"8. Scorpio\\\\n\\\",\\n        \\\"9. Sagittarius\\\\n\\\",\\n        \\\"10. Capricorn\\\\n\\\",\\n        \\\"11. Aquarius\\\\n\\\",\\n        \\\"12. Pisces\\\\n\\\",\\n    )\\n    zodiac_sign = int(input(\\\"number> \\\").strip())\\n    print(\\\"choose some day:\\\\n\\\", \\\"yesterday\\\\n\\\", \\\"today\\\\n\\\", \\\"tomorrow\\\\n\\\")\\n    day = input(\\\"enter the day> \\\")\\n    horoscope_text = horoscope(zodiac_sign, day)\\n    print(horoscope_text)\\n\"",
    "download images from google query": "\"import json\\nimport os\\nimport re\\nimport sys\\nimport urllib.request\\n\\nimport requests\\nfrom bs4 import BeautifulSoup\\n\\nheaders = {\\n    \\\"User-Agent\\\": \\\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\\\"\\n    \\\" (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.19582\\\"\\n}\\n\\n\\ndef download_images_from_google_query(query: str = \\\"dhaka\\\", max_images: int = 5) -> int:\\n    \\\"\\\"\\\"Searches google using the provided query term and downloads the images in a folder.\\n\\n    Args:\\n         query : The image search term to be provided by the user. Defaults to\\n        \\\"dhaka\\\".\\n        image_numbers : [description]. Defaults to 5.\\n\\n    Returns:\\n        The number of images successfully downloaded.\\n\\n    # Comment out slow (4.20s call) doctests\\n    # >>> download_images_from_google_query()\\n    5\\n    # >>> download_images_from_google_query(\\\"potato\\\")\\n    5\\n    \\\"\\\"\\\"\\n    max_images = min(max_images, 50)  # Prevent abuse!\\n    params = {\\n        \\\"q\\\": query,\\n        \\\"tbm\\\": \\\"isch\\\",\\n        \\\"hl\\\": \\\"en\\\",\\n        \\\"ijn\\\": \\\"0\\\",\\n    }\\n\\n    html = requests.get(\\\"https://www.google.com/search\\\", params=params, headers=headers)\\n    soup = BeautifulSoup(html.text, \\\"html.parser\\\")\\n    matched_images_data = \\\"\\\".join(\\n        re.findall(r\\\"AF_initDataCallback\\\\(([^<]+)\\\\);\\\", str(soup.select(\\\"script\\\")))\\n    )\\n\\n    matched_images_data_fix = json.dumps(matched_images_data)\\n    matched_images_data_json = json.loads(matched_images_data_fix)\\n\\n    matched_google_image_data = re.findall(\\n        r\\\"\\\\[\\\\\\\"GRID_STATE0\\\\\\\",null,\\\\[\\\\[1,\\\\[0,\\\\\\\".*?\\\\\\\",(.*),\\\\\\\"All\\\\\\\",\\\",\\n        matched_images_data_json,\\n    )\\n    if not matched_google_image_data:\\n        return 0\\n\\n    removed_matched_google_images_thumbnails = re.sub(\\n        r\\\"\\\\[\\\\\\\"(https\\\\:\\\\/\\\\/encrypted-tbn0\\\\.gstatic\\\\.com\\\\/images\\\\?.*?)\\\\\\\",\\\\d+,\\\\d+\\\\]\\\",\\n        \\\"\\\",\\n        str(matched_google_image_data),\\n    )\\n\\n    matched_google_full_resolution_images = re.findall(\\n        r\\\"(?:'|,),\\\\[\\\\\\\"(https:|http.*?)\\\\\\\",\\\\d+,\\\\d+\\\\]\\\",\\n        removed_matched_google_images_thumbnails,\\n    )\\n    for index, fixed_full_res_image in enumerate(matched_google_full_resolution_images):\\n        if index >= max_images:\\n            return index\\n        original_size_img_not_fixed = bytes(fixed_full_res_image, \\\"ascii\\\").decode(\\n            \\\"unicode-escape\\\"\\n        )\\n        original_size_img = bytes(original_size_img_not_fixed, \\\"ascii\\\").decode(\\n            \\\"unicode-escape\\\"\\n        )\\n        opener = urllib.request.build_opener()\\n        opener.addheaders = [\\n            (\\n                \\\"User-Agent\\\",\\n                \\\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\\\"\\n                \\\" (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.19582\\\",\\n            )\\n        ]\\n        urllib.request.install_opener(opener)\\n        path_name = f\\\"query_{query.replace(' ', '_')}\\\"\\n        if not os.path.exists(path_name):\\n            os.makedirs(path_name)\\n        urllib.request.urlretrieve(\\n            original_size_img, f\\\"{path_name}/original_size_img_{index}.jpg\\\"\\n        )\\n    return index\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    try:\\n        image_count = download_images_from_google_query(sys.argv[1])\\n        print(f\\\"{image_count} images were downloaded to disk.\\\")\\n    except IndexError:\\n        print(\\\"Please provide a search term.\\\")\\n        raise\\n\"",
    "emails from url": "\"\\\"\\\"\\\"Get the site emails from URL.\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n__author__ = \\\"Muhammad Umer Farooq\\\"\\n__license__ = \\\"MIT\\\"\\n__version__ = \\\"1.0.0\\\"\\n__maintainer__ = \\\"Muhammad Umer Farooq\\\"\\n__email__ = \\\"contact@muhammadumerfarooq.me\\\"\\n__status__ = \\\"Alpha\\\"\\n\\nimport re\\nfrom html.parser import HTMLParser\\nfrom urllib import parse\\n\\nimport requests\\n\\n\\nclass Parser(HTMLParser):\\n    def __init__(self, domain: str) -> None:\\n        super().__init__()\\n        self.urls: list[str] = []\\n        self.domain = domain\\n\\n    def handle_starttag(self, tag: str, attrs: list[tuple[str, str | None]]) -> None:\\n        \\\"\\\"\\\"\\n        This function parse html to take takes url from tags\\n        \\\"\\\"\\\"\\n        # Only parse the 'anchor' tag.\\n        if tag == \\\"a\\\":\\n            # Check the list of defined attributes.\\n            for name, value in attrs:\\n                # If href is defined, and not empty nor # print it.\\n                if name == \\\"href\\\" and value != \\\"#\\\" and value != \\\"\\\":\\n                    # If not already in urls.\\n                    if value not in self.urls:\\n                        url = parse.urljoin(self.domain, value)\\n                        self.urls.append(url)\\n\\n\\n# Get main domain name (example.com)\\ndef get_domain_name(url: str) -> str:\\n    \\\"\\\"\\\"\\n    This function get the main domain name\\n\\n    >>> get_domain_name(\\\"https://a.b.c.d/e/f?g=h,i=j#k\\\")\\n    'c.d'\\n    >>> get_domain_name(\\\"Not a URL!\\\")\\n    ''\\n    \\\"\\\"\\\"\\n    return \\\".\\\".join(get_sub_domain_name(url).split(\\\".\\\")[-2:])\\n\\n\\n# Get sub domain name (sub.example.com)\\ndef get_sub_domain_name(url: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> get_sub_domain_name(\\\"https://a.b.c.d/e/f?g=h,i=j#k\\\")\\n    'a.b.c.d'\\n    >>> get_sub_domain_name(\\\"Not a URL!\\\")\\n    ''\\n    \\\"\\\"\\\"\\n    return parse.urlparse(url).netloc\\n\\n\\ndef emails_from_url(url: str = \\\"https://github.com\\\") -> list[str]:\\n    \\\"\\\"\\\"\\n    This function takes url and return all valid urls\\n    \\\"\\\"\\\"\\n    # Get the base domain from the url\\n    domain = get_domain_name(url)\\n\\n    # Initialize the parser\\n    parser = Parser(domain)\\n\\n    try:\\n        # Open URL\\n        r = requests.get(url)\\n\\n        # pass the raw HTML to the parser to get links\\n        parser.feed(r.text)\\n\\n        # Get links and loop through\\n        valid_emails = set()\\n        for link in parser.urls:\\n            # open URL.\\n            # read = requests.get(link)\\n            try:\\n                read = requests.get(link)\\n                # Get the valid email.\\n                emails = re.findall(\\\"[a-zA-Z0-9]+@\\\" + domain, read.text)\\n                # If not in list then append it.\\n                for email in emails:\\n                    valid_emails.add(email)\\n            except ValueError:\\n                pass\\n    except ValueError:\\n        exit(-1)\\n\\n    # Finally return a sorted list of email addresses with no duplicates.\\n    return sorted(valid_emails)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    emails = emails_from_url(\\\"https://github.com\\\")\\n    print(f\\\"{len(emails)} emails found:\\\")\\n    print(\\\"\\\\n\\\".join(sorted(emails)))\\n\"",
    "fetch bbc news": "\"# Created by sarathkaul on 12/11/19\\n\\nimport requests\\n\\n_NEWS_API = \\\"https://newsapi.org/v1/articles?source=bbc-news&sortBy=top&apiKey=\\\"\\n\\n\\ndef fetch_bbc_news(bbc_news_api_key: str) -> None:\\n    # fetching a list of articles in json format\\n    bbc_news_page = requests.get(_NEWS_API + bbc_news_api_key).json()\\n    # each article in the list is a dict\\n    for i, article in enumerate(bbc_news_page[\\\"articles\\\"], 1):\\n        print(f\\\"{i}.) {article['title']}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    fetch_bbc_news(bbc_news_api_key=\\\"<Your BBC News API key goes here>\\\")\\n\"",
    "fetch github info": "\"#!/usr/bin/env python3\\n\\\"\\\"\\\"\\nCreated by sarathkaul on 14/11/19\\nUpdated by lawric1 on 24/11/20\\n\\nAuthentication will be made via access token.\\nTo generate your personal access token visit https://github.com/settings/tokens.\\n\\nNOTE:\\nNever hardcode any credential information in the code. Always use an environment\\nfile to store the private information and use the `os` module to get the information\\nduring runtime.\\n\\nCreate a \\\".env\\\" file in the root directory and write these two lines in that file\\nwith your token::\\n\\n#!/usr/bin/env bash\\nexport USER_TOKEN=\\\"\\\"\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport os\\nfrom typing import Any\\n\\nimport requests\\n\\nBASE_URL = \\\"https://api.github.com\\\"\\n\\n# https://docs.github.com/en/free-pro-team@latest/rest/reference/users#get-the-authenticated-user\\nAUTHENTICATED_USER_ENDPOINT = BASE_URL + \\\"/user\\\"\\n\\n# https://github.com/settings/tokens\\nUSER_TOKEN = os.environ.get(\\\"USER_TOKEN\\\", \\\"\\\")\\n\\n\\ndef fetch_github_info(auth_token: str) -> dict[Any, Any]:\\n    \\\"\\\"\\\"\\n    Fetch GitHub info of a user using the requests module\\n    \\\"\\\"\\\"\\n    headers = {\\n        \\\"Authorization\\\": f\\\"token {auth_token}\\\",\\n        \\\"Accept\\\": \\\"application/vnd.github.v3+json\\\",\\n    }\\n    return requests.get(AUTHENTICATED_USER_ENDPOINT, headers=headers).json()\\n\\n\\nif __name__ == \\\"__main__\\\":  # pragma: no cover\\n    if USER_TOKEN:\\n        for key, value in fetch_github_info(USER_TOKEN).items():\\n            print(f\\\"{key}: {value}\\\")\\n    else:\\n        raise ValueError(\\\"'USER_TOKEN' field cannot be empty.\\\")\\n\"",
    "fetch jobs": "\"\\\"\\\"\\\"\\nScraping jobs given job title and location from indeed website\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom typing import Generator\\n\\nimport requests\\nfrom bs4 import BeautifulSoup\\n\\nurl = \\\"https://www.indeed.co.in/jobs?q=mobile+app+development&l=\\\"\\n\\n\\ndef fetch_jobs(location: str = \\\"mumbai\\\") -> Generator[tuple[str, str], None, None]:\\n    soup = BeautifulSoup(requests.get(url + location).content, \\\"html.parser\\\")\\n    # This attribute finds out all the specifics listed in a job\\n    for job in soup.find_all(\\\"div\\\", attrs={\\\"data-tn-component\\\": \\\"organicJob\\\"}):\\n        job_title = job.find(\\\"a\\\", attrs={\\\"data-tn-element\\\": \\\"jobTitle\\\"}).text.strip()\\n        company_name = job.find(\\\"span\\\", {\\\"class\\\": \\\"company\\\"}).text.strip()\\n        yield job_title, company_name\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    for i, job in enumerate(fetch_jobs(\\\"Bangalore\\\"), 1):\\n        print(f\\\"Job {i:>2} is {job[0]} at {job[1]}\\\")\\n\"",
    "get imdbtop": "\"import bs4\\nimport requests\\n\\n\\ndef get_movie_data_from_soup(soup: bs4.element.ResultSet) -> dict[str, str]:\\n    return {\\n        \\\"name\\\": soup.h3.a.text,\\n        \\\"genre\\\": soup.find(\\\"span\\\", class_=\\\"genre\\\").text.strip(),\\n        \\\"rating\\\": soup.strong.text,\\n        \\\"page_link\\\": f\\\"https://www.imdb.com{soup.a.get('href')}\\\",\\n    }\\n\\n\\ndef get_imdb_top_movies(num_movies: int = 5) -> tuple:\\n    \\\"\\\"\\\"Get the top num_movies most highly rated movies from IMDB and\\n    return a tuple of dicts describing each movie's name, genre, rating, and URL.\\n\\n    Args:\\n        num_movies: The number of movies to get. Defaults to 5.\\n\\n    Returns:\\n        A list of tuples containing information about the top n movies.\\n\\n    >>> len(get_imdb_top_movies(5))\\n    5\\n    >>> len(get_imdb_top_movies(-3))\\n    0\\n    >>> len(get_imdb_top_movies(4.99999))\\n    4\\n    \\\"\\\"\\\"\\n    num_movies = int(float(num_movies))\\n    if num_movies < 1:\\n        return ()\\n    base_url = (\\n        \\\"https://www.imdb.com/search/title?title_type=\\\"\\n        f\\\"feature&sort=num_votes,desc&count={num_movies}\\\"\\n    )\\n    source = bs4.BeautifulSoup(requests.get(base_url).content, \\\"html.parser\\\")\\n    return tuple(\\n        get_movie_data_from_soup(movie)\\n        for movie in source.find_all(\\\"div\\\", class_=\\\"lister-item mode-advanced\\\")\\n    )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import json\\n\\n    num_movies = int(input(\\\"How many movies would you like to see? \\\"))\\n    print(\\n        \\\", \\\".join(\\n            json.dumps(movie, indent=4) for movie in get_imdb_top_movies(num_movies)\\n        )\\n    )\\n\"",
    "get imdb top 250 movies csv": "\"from __future__ import annotations\\n\\nimport csv\\n\\nimport requests\\nfrom bs4 import BeautifulSoup\\n\\n\\ndef get_imdb_top_250_movies(url: str = \\\"\\\") -> dict[str, float]:\\n    url = url or \\\"https://www.imdb.com/chart/top/?ref_=nv_mv_250\\\"\\n    soup = BeautifulSoup(requests.get(url).text, \\\"html.parser\\\")\\n    titles = soup.find_all(\\\"td\\\", attrs=\\\"titleColumn\\\")\\n    ratings = soup.find_all(\\\"td\\\", class_=\\\"ratingColumn imdbRating\\\")\\n    return {\\n        title.a.text: float(rating.strong.text)\\n        for title, rating in zip(titles, ratings)\\n    }\\n\\n\\ndef write_movies(filename: str = \\\"IMDb_Top_250_Movies.csv\\\") -> None:\\n    movies = get_imdb_top_250_movies()\\n    with open(filename, \\\"w\\\", newline=\\\"\\\") as out_file:\\n        writer = csv.writer(out_file)\\n        writer.writerow([\\\"Movie title\\\", \\\"IMDb rating\\\"])\\n        for title, rating in movies.items():\\n            writer.writerow([title, rating])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    write_movies()\\n\"",
    "get top hn posts": "\"from __future__ import annotations\\n\\nimport requests\\n\\n\\ndef get_hackernews_story(story_id: str) -> dict:\\n    url = f\\\"https://hacker-news.firebaseio.com/v0/item/{story_id}.json?print=pretty\\\"\\n    return requests.get(url).json()\\n\\n\\ndef hackernews_top_stories(max_stories: int = 10) -> list[dict]:\\n    \\\"\\\"\\\"\\n    Get the top max_stories posts from HackerNews - https://news.ycombinator.com/\\n    \\\"\\\"\\\"\\n    url = \\\"https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty\\\"\\n    story_ids = requests.get(url).json()[:max_stories]\\n    return [get_hackernews_story(story_id) for story_id in story_ids]\\n\\n\\ndef hackernews_top_stories_as_markdown(max_stories: int = 10) -> str:\\n    stories = hackernews_top_stories(max_stories)\\n    return \\\"\\\\n\\\".join(\\\"* [{title}]({url})\\\".format(**story) for story in stories)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(hackernews_top_stories_as_markdown())\\n\"",
    "get user tweets": "\"import csv\\n\\nimport tweepy\\n\\n# Twitter API credentials\\nconsumer_key = \\\"\\\"\\nconsumer_secret = \\\"\\\"\\naccess_key = \\\"\\\"\\naccess_secret = \\\"\\\"\\n\\n\\ndef get_all_tweets(screen_name: str) -> None:\\n\\n    # authorize twitter, initialize tweepy\\n    auth = tweepy.OAuthHandler(consumer_key, consumer_secret)\\n    auth.set_access_token(access_key, access_secret)\\n    api = tweepy.API(auth)\\n\\n    # initialize a list to hold all the tweepy Tweets\\n    alltweets = []\\n\\n    # make initial request for most recent tweets (200 is the maximum allowed count)\\n    new_tweets = api.user_timeline(screen_name=screen_name, count=200)\\n\\n    # save most recent tweets\\n    alltweets.extend(new_tweets)\\n\\n    # save the id of the oldest tweet less one\\n    oldest = alltweets[-1].id - 1\\n\\n    # keep grabbing tweets until there are no tweets left to grab\\n    while len(new_tweets) > 0:\\n        print(f\\\"getting tweets before {oldest}\\\")\\n\\n        # all subsequent requests use the max_id param to prevent duplicates\\n        new_tweets = api.user_timeline(\\n            screen_name=screen_name, count=200, max_id=oldest\\n        )\\n\\n        # save most recent tweets\\n        alltweets.extend(new_tweets)\\n\\n        # update the id of the oldest tweet less one\\n        oldest = alltweets[-1].id - 1\\n\\n        print(f\\\"...{len(alltweets)} tweets downloaded so far\\\")\\n\\n    # transform the tweepy tweets into a 2D array that will populate the csv\\n    outtweets = [[tweet.id_str, tweet.created_at, tweet.text] for tweet in alltweets]\\n\\n    # write the csv\\n    with open(f\\\"new_{screen_name}_tweets.csv\\\", \\\"w\\\") as f:\\n        writer = csv.writer(f)\\n        writer.writerow([\\\"id\\\", \\\"created_at\\\", \\\"text\\\"])\\n        writer.writerows(outtweets)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # pass in the username of the account you want to download\\n    get_all_tweets(\\\"FirePing32\\\")\\n\"",
    "giphy": "\"#!/usr/bin/env python3\\nimport requests\\n\\ngiphy_api_key = \\\"YOUR API KEY\\\"\\n# Can be fetched from https://developers.giphy.com/dashboard/\\n\\n\\ndef get_gifs(query: str, api_key: str = giphy_api_key) -> list:\\n    \\\"\\\"\\\"\\n    Get a list of URLs of GIFs based on a given query..\\n    \\\"\\\"\\\"\\n    formatted_query = \\\"+\\\".join(query.split())\\n    url = f\\\"http://api.giphy.com/v1/gifs/search?q={formatted_query}&api_key={api_key}\\\"\\n    gifs = requests.get(url).json()[\\\"data\\\"]\\n    return [gif[\\\"url\\\"] for gif in gifs]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"\\\\n\\\".join(get_gifs(\\\"space ship\\\")))\\n\"",
    "instagram crawler": "\"#!/usr/bin/env python3\\nfrom __future__ import annotations\\n\\nimport json\\n\\nimport requests\\nfrom bs4 import BeautifulSoup\\nfrom fake_useragent import UserAgent\\n\\nheaders = {\\\"UserAgent\\\": UserAgent().random}\\n\\n\\ndef extract_user_profile(script) -> dict:\\n    \\\"\\\"\\\"\\n    May raise json.decoder.JSONDecodeError\\n    \\\"\\\"\\\"\\n    data = script.contents[0]\\n    info = json.loads(data[data.find('{\\\"config\\\"') : -1])\\n    return info[\\\"entry_data\\\"][\\\"ProfilePage\\\"][0][\\\"graphql\\\"][\\\"user\\\"]\\n\\n\\nclass InstagramUser:\\n    \\\"\\\"\\\"\\n    Class Instagram crawl instagram user information\\n\\n    Usage: (doctest failing on GitHub Actions)\\n    # >>> instagram_user = InstagramUser(\\\"github\\\")\\n    # >>> instagram_user.is_verified\\n    True\\n    # >>> instagram_user.biography\\n    'Built for developers.'\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, username):\\n        self.url = f\\\"https://www.instagram.com/{username}/\\\"\\n        self.user_data = self.get_json()\\n\\n    def get_json(self) -> dict:\\n        \\\"\\\"\\\"\\n        Return a dict of user information\\n        \\\"\\\"\\\"\\n        html = requests.get(self.url, headers=headers).text\\n        scripts = BeautifulSoup(html, \\\"html.parser\\\").find_all(\\\"script\\\")\\n        try:\\n            return extract_user_profile(scripts[4])\\n        except (json.decoder.JSONDecodeError, KeyError):\\n            return extract_user_profile(scripts[3])\\n\\n    def __repr__(self) -> str:\\n        return f\\\"{self.__class__.__name__}('{self.username}')\\\"\\n\\n    def __str__(self) -> str:\\n        return f\\\"{self.fullname} ({self.username}) is {self.biography}\\\"\\n\\n    @property\\n    def username(self) -> str:\\n        return self.user_data[\\\"username\\\"]\\n\\n    @property\\n    def fullname(self) -> str:\\n        return self.user_data[\\\"full_name\\\"]\\n\\n    @property\\n    def biography(self) -> str:\\n        return self.user_data[\\\"biography\\\"]\\n\\n    @property\\n    def email(self) -> str:\\n        return self.user_data[\\\"business_email\\\"]\\n\\n    @property\\n    def website(self) -> str:\\n        return self.user_data[\\\"external_url\\\"]\\n\\n    @property\\n    def number_of_followers(self) -> int:\\n        return self.user_data[\\\"edge_followed_by\\\"][\\\"count\\\"]\\n\\n    @property\\n    def number_of_followings(self) -> int:\\n        return self.user_data[\\\"edge_follow\\\"][\\\"count\\\"]\\n\\n    @property\\n    def number_of_posts(self) -> int:\\n        return self.user_data[\\\"edge_owner_to_timeline_media\\\"][\\\"count\\\"]\\n\\n    @property\\n    def profile_picture_url(self) -> str:\\n        return self.user_data[\\\"profile_pic_url_hd\\\"]\\n\\n    @property\\n    def is_verified(self) -> bool:\\n        return self.user_data[\\\"is_verified\\\"]\\n\\n    @property\\n    def is_private(self) -> bool:\\n        return self.user_data[\\\"is_private\\\"]\\n\\n\\ndef test_instagram_user(username: str = \\\"github\\\") -> None:\\n    \\\"\\\"\\\"\\n    A self running doctest\\n    >>> test_instagram_user()\\n    \\\"\\\"\\\"\\n    import os\\n\\n    if os.environ.get(\\\"CI\\\"):\\n        return None  # test failing on GitHub Actions\\n    instagram_user = InstagramUser(username)\\n    assert instagram_user.user_data\\n    assert isinstance(instagram_user.user_data, dict)\\n    assert instagram_user.username == username\\n    if username != \\\"github\\\":\\n        return\\n    assert instagram_user.fullname == \\\"GitHub\\\"\\n    assert instagram_user.biography == \\\"Built for developers.\\\"\\n    assert instagram_user.number_of_posts > 150\\n    assert instagram_user.number_of_followers > 120000\\n    assert instagram_user.number_of_followings > 15\\n    assert instagram_user.email == \\\"support@github.com\\\"\\n    assert instagram_user.website == \\\"https://github.com/readme\\\"\\n    assert instagram_user.profile_picture_url.startswith(\\\"https://instagram.\\\")\\n    assert instagram_user.is_verified is True\\n    assert instagram_user.is_private is False\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    instagram_user = InstagramUser(\\\"github\\\")\\n    print(instagram_user)\\n    print(f\\\"{instagram_user.number_of_posts = }\\\")\\n    print(f\\\"{instagram_user.number_of_followers = }\\\")\\n    print(f\\\"{instagram_user.number_of_followings = }\\\")\\n    print(f\\\"{instagram_user.email = }\\\")\\n    print(f\\\"{instagram_user.website = }\\\")\\n    print(f\\\"{instagram_user.profile_picture_url = }\\\")\\n    print(f\\\"{instagram_user.is_verified = }\\\")\\n    print(f\\\"{instagram_user.is_private = }\\\")\\n\"",
    "instagram pic": "\"from datetime import datetime\\n\\nimport requests\\nfrom bs4 import BeautifulSoup\\n\\nif __name__ == \\\"__main__\\\":\\n    url = input(\\\"Enter image url: \\\").strip()\\n    print(f\\\"Downloading image from {url} ...\\\")\\n    soup = BeautifulSoup(requests.get(url).content, \\\"html.parser\\\")\\n    # The image URL is in the content field of the first meta tag with property og:image\\n    image_url = soup.find(\\\"meta\\\", {\\\"property\\\": \\\"og:image\\\"})[\\\"content\\\"]\\n    image_data = requests.get(image_url).content\\n    file_name = f\\\"{datetime.now():%Y-%m-%d_%H:%M:%S}.jpg\\\"\\n    with open(file_name, \\\"wb\\\") as fp:\\n        fp.write(image_data)\\n    print(f\\\"Done. Image saved to disk as {file_name}.\\\")\\n\"",
    "instagram video": "\"from datetime import datetime\\n\\nimport requests\\n\\n\\ndef download_video(url: str) -> bytes:\\n    base_url = \\\"https://downloadgram.net/wp-json/wppress/video-downloader/video?url=\\\"\\n    video_url = requests.get(base_url + url).json()[0][\\\"urls\\\"][0][\\\"src\\\"]\\n    return requests.get(video_url).content\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    url = input(\\\"Enter Video/IGTV url: \\\").strip()\\n    file_name = f\\\"{datetime.now():%Y-%m-%d_%H:%M:%S}.mp4\\\"\\n    with open(file_name, \\\"wb\\\") as fp:\\n        fp.write(download_video(url))\\n    print(f\\\"Done. Video saved to disk as {file_name}.\\\")\\n\"",
    "nasa data": "\"import shutil\\n\\nimport requests\\n\\n\\ndef get_apod_data(api_key: str, download: bool = False, path: str = \\\".\\\") -> dict:\\n    \\\"\\\"\\\"\\n    Get the APOD(Astronomical Picture of the day) data\\n    Get your API Key from: https://api.nasa.gov/\\n    \\\"\\\"\\\"\\n    url = \\\"https://api.nasa.gov/planetary/apod\\\"\\n    return requests.get(url, params={\\\"api_key\\\": api_key}).json()\\n\\n\\ndef save_apod(api_key: str, path: str = \\\".\\\") -> dict:\\n    apod_data = get_apod_data(api_key)\\n    img_url = apod_data[\\\"url\\\"]\\n    img_name = img_url.split(\\\"/\\\")[-1]\\n    response = requests.get(img_url, stream=True)\\n\\n    with open(f\\\"{path}/{img_name}\\\", \\\"wb+\\\") as img_file:\\n        shutil.copyfileobj(response.raw, img_file)\\n    del response\\n    return apod_data\\n\\n\\ndef get_archive_data(query: str) -> dict:\\n    \\\"\\\"\\\"\\n    Get the data of a particular query from NASA archives\\n    \\\"\\\"\\\"\\n    url = \\\"https://images-api.nasa.gov/search\\\"\\n    return requests.get(url, params={\\\"q\\\": query}).json()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(save_apod(\\\"YOUR API KEY\\\"))\\n    apollo_2011_items = get_archive_data(\\\"apollo 2011\\\")[\\\"collection\\\"][\\\"items\\\"]\\n    print(apollo_2011_items[0][\\\"data\\\"][0][\\\"description\\\"])\\n\"",
    "random anime character": "\"import os\\n\\nimport requests\\nfrom bs4 import BeautifulSoup\\nfrom fake_useragent import UserAgent\\n\\nheaders = {\\\"UserAgent\\\": UserAgent().random}\\nURL = \\\"https://www.mywaifulist.moe/random\\\"\\n\\n\\ndef save_image(image_url: str, image_title: str) -> None:\\n    \\\"\\\"\\\"\\n    Saves the image of anime character\\n    \\\"\\\"\\\"\\n    image = requests.get(image_url, headers=headers)\\n    with open(image_title, \\\"wb\\\") as file:\\n        file.write(image.content)\\n\\n\\ndef random_anime_character() -> tuple[str, str, str]:\\n    \\\"\\\"\\\"\\n    Returns the Title, Description, and Image Title of a random anime character .\\n    \\\"\\\"\\\"\\n    soup = BeautifulSoup(requests.get(URL, headers=headers).text, \\\"html.parser\\\")\\n    title = soup.find(\\\"meta\\\", attrs={\\\"property\\\": \\\"og:title\\\"}).attrs[\\\"content\\\"]\\n    image_url = soup.find(\\\"meta\\\", attrs={\\\"property\\\": \\\"og:image\\\"}).attrs[\\\"content\\\"]\\n    description = soup.find(\\\"p\\\", id=\\\"description\\\").get_text()\\n    _, image_extension = os.path.splitext(os.path.basename(image_url))\\n    image_title = title.strip().replace(\\\" \\\", \\\"_\\\")\\n    image_title = f\\\"{image_title}{image_extension}\\\"\\n    save_image(image_url, image_title)\\n    return (title, description, image_title)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    title, desc, image_title = random_anime_character()\\n    print(f\\\"{title}\\\\n\\\\n{desc}\\\\n\\\\nImage saved : {image_title}\\\")\\n\"",
    "recaptcha verification": "\"\\\"\\\"\\\"\\nRecaptcha is a free captcha service offered by Google in order to secure websites and\\nforms.  At https://www.google.com/recaptcha/admin/create you can create new recaptcha\\nkeys and see the keys that your have already created.\\n* Keep in mind that recaptcha doesn't work with localhost\\nWhen you create a recaptcha key, your will get two separate keys: ClientKey & SecretKey.\\nClientKey should be kept in your site's front end\\nSecretKey should be kept in your site's  back end\\n\\n# An example HTML login form with recaptcha tag is shown below\\n\\n    <form action=\\\"\\\" method=\\\"post\\\">\\n        <h2 class=\\\"text-center\\\">Log in</h2>\\n        {% csrf_token %}\\n        <div class=\\\"form-group\\\">\\n            <input type=\\\"text\\\" name=\\\"username\\\" required=\\\"required\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n            <input type=\\\"password\\\" name=\\\"password\\\" required=\\\"required\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n            <button type=\\\"submit\\\">Log in</button>\\n        </div>\\n        <!-- Below is the recaptcha tag of html -->\\n        <div class=\\\"g-recaptcha\\\" data-sitekey=\\\"ClientKey\\\"></div>\\n    </form>\\n\\n    <!-- Below is the recaptcha script to be kept inside html tag -->\\n    <script src=\\\"https://www.google.com/recaptcha/api.js\\\" async defer></script>\\n\\nBelow a Django function for the views.py file contains a login form for demonstrating\\nrecaptcha verification.\\n\\\"\\\"\\\"\\nimport requests\\n\\ntry:\\n    from django.contrib.auth import authenticate, login\\n    from django.shortcuts import redirect, render\\nexcept ImportError:\\n    authenticate = login = render = redirect = print\\n\\n\\ndef login_using_recaptcha(request):\\n    # Enter your recaptcha secret key here\\n    secret_key = \\\"secretKey\\\"\\n    url = \\\"https://www.google.com/recaptcha/api/siteverify\\\"\\n\\n    # when method is not POST, direct user to login page\\n    if request.method != \\\"POST\\\":\\n        return render(request, \\\"login.html\\\")\\n\\n    # from the frontend, get username, password, and client_key\\n    username = request.POST.get(\\\"username\\\")\\n    password = request.POST.get(\\\"password\\\")\\n    client_key = request.POST.get(\\\"g-recaptcha-response\\\")\\n\\n    # post recaptcha response to Google's recaptcha api\\n    response = requests.post(url, data={\\\"secret\\\": secret_key, \\\"response\\\": client_key})\\n    # if the recaptcha api verified our keys\\n    if response.json().get(\\\"success\\\", False):\\n        # authenticate the user\\n        user_in_database = authenticate(request, username=username, password=password)\\n        if user_in_database:\\n            login(request, user_in_database)\\n            return redirect(\\\"/your-webpage\\\")\\n    return render(request, \\\"login.html\\\")\\n\"",
    "reddit": "\"from __future__ import annotations\\n\\nimport requests\\n\\nvalid_terms = set(\\n    \\\"\\\"\\\"approved_at_utc approved_by author_flair_background_color\\nauthor_flair_css_class author_flair_richtext author_flair_template_id author_fullname\\nauthor_premium can_mod_post category clicked content_categories created_utc downs\\nedited gilded gildings hidden hide_score is_created_from_ads_ui is_meta\\nis_original_content is_reddit_media_domain is_video link_flair_css_class\\nlink_flair_richtext link_flair_text link_flair_text_color media_embed mod_reason_title\\nname permalink pwls quarantine saved score secure_media secure_media_embed selftext\\nsubreddit subreddit_name_prefixed subreddit_type thumbnail title top_awarded_type\\ntotal_awards_received ups upvote_ratio url user_reports\\\"\\\"\\\".split()\\n)\\n\\n\\ndef get_subreddit_data(\\n    subreddit: str, limit: int = 1, age: str = \\\"new\\\", wanted_data: list | None = None\\n) -> dict:\\n    \\\"\\\"\\\"\\n    subreddit : Subreddit to query\\n    limit : Number of posts to fetch\\n    age : [\\\"new\\\", \\\"top\\\", \\\"hot\\\"]\\n    wanted_data : Get only the required data in the list\\n\\n    >>> pass\\n    \\\"\\\"\\\"\\n    wanted_data = wanted_data or []\\n    if invalid_search_terms := \\\", \\\".join(sorted(set(wanted_data) - valid_terms)):\\n        raise ValueError(f\\\"Invalid search term: {invalid_search_terms}\\\")\\n    response = requests.get(\\n        f\\\"https://reddit.com/r/{subreddit}/{age}.json?limit={limit}\\\",\\n        headers={\\\"User-agent\\\": \\\"A random string\\\"},\\n    )\\n    if response.status_code == 429:\\n        raise requests.HTTPError\\n\\n    data = response.json()\\n    if not wanted_data:\\n        return {id_: data[\\\"data\\\"][\\\"children\\\"][id_] for id_ in range(limit)}\\n\\n    data_dict = {}\\n    for id_ in range(limit):\\n        data_dict[id_] = {\\n            item: data[\\\"data\\\"][\\\"children\\\"][id_][\\\"data\\\"][item] for item in wanted_data\\n        }\\n    return data_dict\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # If you get Error 429, that means you are rate limited.Try after some time\\n    print(get_subreddit_data(\\\"learnpython\\\", wanted_data=[\\\"title\\\", \\\"url\\\", \\\"selftext\\\"]))\\n\"",
    "search books by isbn": "\"\\\"\\\"\\\"\\nGet book and author data from https://openlibrary.org\\n\\nISBN: https://en.wikipedia.org/wiki/International_Standard_Book_Number\\n\\\"\\\"\\\"\\nfrom json import JSONDecodeError  # Workaround for requests.exceptions.JSONDecodeError\\n\\nimport requests\\n\\n\\ndef get_openlibrary_data(olid: str = \\\"isbn/0140328726\\\") -> dict:\\n    \\\"\\\"\\\"\\n    Given an 'isbn/0140328726', return book data from Open Library as a Python dict.\\n    Given an '/authors/OL34184A', return authors data as a Python dict.\\n    This code must work for olids with or without a leading slash ('/').\\n\\n    # Comment out doctests if they take too long or have results that may change\\n    # >>> get_openlibrary_data(olid='isbn/0140328726')  # doctest: +ELLIPSIS\\n    {'publishers': ['Puffin'], 'number_of_pages': 96, 'isbn_10': ['0140328726'], ...\\n    # >>> get_openlibrary_data(olid='/authors/OL7353617A')  # doctest: +ELLIPSIS\\n    {'name': 'Adrian Brisku', 'created': {'type': '/type/datetime', ...\\n    >>> pass  # Placate https://github.com/apps/algorithms-keeper\\n    \\\"\\\"\\\"\\n    new_olid = olid.strip().strip(\\\"/\\\")  # Remove leading/trailing whitespace & slashes\\n    if new_olid.count(\\\"/\\\") != 1:\\n        raise ValueError(f\\\"{olid} is not a valid Open Library olid\\\")\\n    return requests.get(f\\\"https://openlibrary.org/{new_olid}.json\\\").json()\\n\\n\\ndef summarize_book(ol_book_data: dict) -> dict:\\n    \\\"\\\"\\\"\\n     Given Open Library book data, return a summary as a Python dict.\\n\\n    >>> pass  # Placate https://github.com/apps/algorithms-keeper\\n    \\\"\\\"\\\"\\n    desired_keys = {\\n        \\\"title\\\": \\\"Title\\\",\\n        \\\"publish_date\\\": \\\"Publish date\\\",\\n        \\\"authors\\\": \\\"Authors\\\",\\n        \\\"number_of_pages\\\": \\\"Number of pages:\\\",\\n        \\\"first_sentence\\\": \\\"First sentence\\\",\\n        \\\"isbn_10\\\": \\\"ISBN (10)\\\",\\n        \\\"isbn_13\\\": \\\"ISBN (13)\\\",\\n    }\\n    data = {better_key: ol_book_data[key] for key, better_key in desired_keys.items()}\\n    data[\\\"Authors\\\"] = [\\n        get_openlibrary_data(author[\\\"key\\\"])[\\\"name\\\"] for author in data[\\\"Authors\\\"]\\n    ]\\n    data[\\\"First sentence\\\"] = data[\\\"First sentence\\\"][\\\"value\\\"]\\n    for key, value in data.items():\\n        if isinstance(value, list):\\n            data[key] = \\\", \\\".join(value)\\n    return data\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    while True:\\n        isbn = input(\\\"\\\\nEnter the ISBN code to search (or 'quit' to stop): \\\").strip()\\n        if isbn.lower() in (\\\"\\\", \\\"q\\\", \\\"quit\\\", \\\"exit\\\", \\\"stop\\\"):\\n            break\\n\\n        if len(isbn) not in (10, 13) or not isbn.isdigit():\\n            print(f\\\"Sorry, {isbn} is not a valid ISBN.  Please, input a valid ISBN.\\\")\\n            continue\\n\\n        print(f\\\"\\\\nSearching Open Library for ISBN: {isbn}...\\\\n\\\")\\n\\n        try:\\n            book_summary = summarize_book(get_openlibrary_data(f\\\"isbn/{isbn}\\\"))\\n            print(\\\"\\\\n\\\".join(f\\\"{key}: {value}\\\" for key, value in book_summary.items()))\\n        except JSONDecodeError:  # Workaround for requests.exceptions.RequestException:\\n            print(f\\\"Sorry, there are no results for ISBN: {isbn}.\\\")\\n\"",
    "slack message": "\"# Created by sarathkaul on 12/11/19\\n\\nimport requests\\n\\n\\ndef send_slack_message(message_body: str, slack_url: str) -> None:\\n    headers = {\\\"Content-Type\\\": \\\"application/json\\\"}\\n    response = requests.post(slack_url, json={\\\"text\\\": message_body}, headers=headers)\\n    if response.status_code != 200:\\n        raise ValueError(\\n            f\\\"Request to slack returned an error {response.status_code}, \\\"\\n            f\\\"the response is:\\\\n{response.text}\\\"\\n        )\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    # Set the slack url to the one provided by Slack when you create the webhook at\\n    # https://my.slack.com/services/new/incoming-webhook/\\n    send_slack_message(\\\"<YOUR MESSAGE BODY>\\\", \\\"<SLACK CHANNEL URL>\\\")\\n\"",
    "test fetch github info": "\"import json\\n\\nimport requests\\n\\nfrom .fetch_github_info import AUTHENTICATED_USER_ENDPOINT, fetch_github_info\\n\\n\\ndef test_fetch_github_info(monkeypatch):\\n    class FakeResponse:\\n        def __init__(self, content) -> None:\\n            assert isinstance(content, (bytes, str))\\n            self.content = content\\n\\n        def json(self):\\n            return json.loads(self.content)\\n\\n    def mock_response(*args, **kwargs):\\n        assert args[0] == AUTHENTICATED_USER_ENDPOINT\\n        assert \\\"Authorization\\\" in kwargs[\\\"headers\\\"]\\n        assert kwargs[\\\"headers\\\"][\\\"Authorization\\\"].startswith(\\\"token \\\")\\n        assert \\\"Accept\\\" in kwargs[\\\"headers\\\"]\\n        return FakeResponse(b'{\\\"login\\\":\\\"test\\\",\\\"id\\\":1}')\\n\\n    monkeypatch.setattr(requests, \\\"get\\\", mock_response)\\n    result = fetch_github_info(\\\"token\\\")\\n    assert result[\\\"login\\\"] == \\\"test\\\"\\n    assert result[\\\"id\\\"] == 1\\n\"",
    "world covid19 stats": "\"#!/usr/bin/env python3\\n\\n\\\"\\\"\\\"\\nProvide the current worldwide COVID-19 statistics.\\nThis data is being scrapped from 'https://www.worldometers.info/coronavirus/'.\\n\\\"\\\"\\\"\\n\\nimport requests\\nfrom bs4 import BeautifulSoup\\n\\n\\ndef world_covid19_stats(url: str = \\\"https://www.worldometers.info/coronavirus\\\") -> dict:\\n    \\\"\\\"\\\"\\n    Return a dict of current worldwide COVID-19 statistics\\n    \\\"\\\"\\\"\\n    soup = BeautifulSoup(requests.get(url).text, \\\"html.parser\\\")\\n    keys = soup.findAll(\\\"h1\\\")\\n    values = soup.findAll(\\\"div\\\", {\\\"class\\\": \\\"maincounter-number\\\"})\\n    keys += soup.findAll(\\\"span\\\", {\\\"class\\\": \\\"panel-title\\\"})\\n    values += soup.findAll(\\\"div\\\", {\\\"class\\\": \\\"number-table-main\\\"})\\n    return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"\\\\033[1m\\\" + \\\"COVID-19 Status of the World\\\" + \\\"\\\\033[0m\\\\n\\\")\\n    for key, value in world_covid19_stats().items():\\n        print(f\\\"{key}\\\\n{value}\\\\n\\\")\\n\"",
    "avl tree": "\"\\\"\\\"\\\"\\nImplementation of an auto-balanced binary tree!\\nFor doctests run following command:\\npython3 -m doctest -v avl_tree.py\\nFor testing run:\\npython avl_tree.py\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport math\\nimport random\\nfrom typing import Any\\n\\n\\nclass my_queue:\\n    def __init__(self) -> None:\\n        self.data: list[Any] = []\\n        self.head: int = 0\\n        self.tail: int = 0\\n\\n    def is_empty(self) -> bool:\\n        return self.head == self.tail\\n\\n    def push(self, data: Any) -> None:\\n        self.data.append(data)\\n        self.tail = self.tail + 1\\n\\n    def pop(self) -> Any:\\n        ret = self.data[self.head]\\n        self.head = self.head + 1\\n        return ret\\n\\n    def count(self) -> int:\\n        return self.tail - self.head\\n\\n    def print(self) -> None:\\n        print(self.data)\\n        print(\\\"**************\\\")\\n        print(self.data[self.head : self.tail])\\n\\n\\nclass my_node:\\n    def __init__(self, data: Any) -> None:\\n        self.data = data\\n        self.left: my_node | None = None\\n        self.right: my_node | None = None\\n        self.height: int = 1\\n\\n    def get_data(self) -> Any:\\n        return self.data\\n\\n    def get_left(self) -> my_node | None:\\n        return self.left\\n\\n    def get_right(self) -> my_node | None:\\n        return self.right\\n\\n    def get_height(self) -> int:\\n        return self.height\\n\\n    def set_data(self, data: Any) -> None:\\n        self.data = data\\n        return\\n\\n    def set_left(self, node: my_node | None) -> None:\\n        self.left = node\\n        return\\n\\n    def set_right(self, node: my_node | None) -> None:\\n        self.right = node\\n        return\\n\\n    def set_height(self, height: int) -> None:\\n        self.height = height\\n        return\\n\\n\\ndef get_height(node: my_node | None) -> int:\\n    if node is None:\\n        return 0\\n    return node.get_height()\\n\\n\\ndef my_max(a: int, b: int) -> int:\\n    if a > b:\\n        return a\\n    return b\\n\\n\\ndef right_rotation(node: my_node) -> my_node:\\n    r\\\"\\\"\\\"\\n            A                      B\\n           / \\\\                    / \\\\\\n          B   C                  Bl  A\\n         / \\\\       -->          /   / \\\\\\n        Bl  Br                 UB Br  C\\n       /\\n     UB\\n    UB = unbalanced node\\n    \\\"\\\"\\\"\\n    print(\\\"left rotation node:\\\", node.get_data())\\n    ret = node.get_left()\\n    assert ret is not None\\n    node.set_left(ret.get_right())\\n    ret.set_right(node)\\n    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1\\n    node.set_height(h1)\\n    h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1\\n    ret.set_height(h2)\\n    return ret\\n\\n\\ndef left_rotation(node: my_node) -> my_node:\\n    \\\"\\\"\\\"\\n    a mirror symmetry rotation of the left_rotation\\n    \\\"\\\"\\\"\\n    print(\\\"right rotation node:\\\", node.get_data())\\n    ret = node.get_right()\\n    assert ret is not None\\n    node.set_right(ret.get_left())\\n    ret.set_left(node)\\n    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1\\n    node.set_height(h1)\\n    h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1\\n    ret.set_height(h2)\\n    return ret\\n\\n\\ndef lr_rotation(node: my_node) -> my_node:\\n    r\\\"\\\"\\\"\\n            A              A                    Br\\n           / \\\\            / \\\\                  /  \\\\\\n          B   C    LR    Br  C       RR       B    A\\n         / \\\\       -->  /  \\\\         -->    /     / \\\\\\n        Bl  Br         B   UB              Bl    UB  C\\n             \\\\        /\\n             UB     Bl\\n    RR = right_rotation   LR = left_rotation\\n    \\\"\\\"\\\"\\n    left_child = node.get_left()\\n    assert left_child is not None\\n    node.set_left(left_rotation(left_child))\\n    return right_rotation(node)\\n\\n\\ndef rl_rotation(node: my_node) -> my_node:\\n    right_child = node.get_right()\\n    assert right_child is not None\\n    node.set_right(right_rotation(right_child))\\n    return left_rotation(node)\\n\\n\\ndef insert_node(node: my_node | None, data: Any) -> my_node | None:\\n    if node is None:\\n        return my_node(data)\\n    if data < node.get_data():\\n        node.set_left(insert_node(node.get_left(), data))\\n        if (\\n            get_height(node.get_left()) - get_height(node.get_right()) == 2\\n        ):  # an unbalance detected\\n            left_child = node.get_left()\\n            assert left_child is not None\\n            if (\\n                data < left_child.get_data()\\n            ):  # new node is the left child of the left child\\n                node = right_rotation(node)\\n            else:\\n                node = lr_rotation(node)\\n    else:\\n        node.set_right(insert_node(node.get_right(), data))\\n        if get_height(node.get_right()) - get_height(node.get_left()) == 2:\\n            right_child = node.get_right()\\n            assert right_child is not None\\n            if data < right_child.get_data():\\n                node = rl_rotation(node)\\n            else:\\n                node = left_rotation(node)\\n    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1\\n    node.set_height(h1)\\n    return node\\n\\n\\ndef get_rightMost(root: my_node) -> Any:\\n    while True:\\n        right_child = root.get_right()\\n        if right_child is None:\\n            break\\n        root = right_child\\n    return root.get_data()\\n\\n\\ndef get_leftMost(root: my_node) -> Any:\\n    while True:\\n        left_child = root.get_left()\\n        if left_child is None:\\n            break\\n        root = left_child\\n    return root.get_data()\\n\\n\\ndef del_node(root: my_node, data: Any) -> my_node | None:\\n    left_child = root.get_left()\\n    right_child = root.get_right()\\n    if root.get_data() == data:\\n        if left_child is not None and right_child is not None:\\n            temp_data = get_leftMost(right_child)\\n            root.set_data(temp_data)\\n            root.set_right(del_node(right_child, temp_data))\\n        elif left_child is not None:\\n            root = left_child\\n        elif right_child is not None:\\n            root = right_child\\n        else:\\n            return None\\n    elif root.get_data() > data:\\n        if left_child is None:\\n            print(\\\"No such data\\\")\\n            return root\\n        else:\\n            root.set_left(del_node(left_child, data))\\n    else:  # root.get_data() < data\\n        if right_child is None:\\n            return root\\n        else:\\n            root.set_right(del_node(right_child, data))\\n\\n    if get_height(right_child) - get_height(left_child) == 2:\\n        assert right_child is not None\\n        if get_height(right_child.get_right()) > get_height(right_child.get_left()):\\n            root = left_rotation(root)\\n        else:\\n            root = rl_rotation(root)\\n    elif get_height(right_child) - get_height(left_child) == -2:\\n        assert left_child is not None\\n        if get_height(left_child.get_left()) > get_height(left_child.get_right()):\\n            root = right_rotation(root)\\n        else:\\n            root = lr_rotation(root)\\n    height = my_max(get_height(root.get_right()), get_height(root.get_left())) + 1\\n    root.set_height(height)\\n    return root\\n\\n\\nclass AVLtree:\\n    \\\"\\\"\\\"\\n    An AVL tree doctest\\n    Examples:\\n    >>> t = AVLtree()\\n    >>> t.insert(4)\\n    insert:4\\n    >>> print(str(t).replace(\\\" \\\\\\\\n\\\",\\\"\\\\\\\\n\\\"))\\n     4\\n    *************************************\\n    >>> t.insert(2)\\n    insert:2\\n    >>> print(str(t).replace(\\\" \\\\\\\\n\\\",\\\"\\\\\\\\n\\\").replace(\\\" \\\\\\\\n\\\",\\\"\\\\\\\\n\\\"))\\n      4\\n     2  *\\n    *************************************\\n    >>> t.insert(3)\\n    insert:3\\n    right rotation node: 2\\n    left rotation node: 4\\n    >>> print(str(t).replace(\\\" \\\\\\\\n\\\",\\\"\\\\\\\\n\\\").replace(\\\" \\\\\\\\n\\\",\\\"\\\\\\\\n\\\"))\\n      3\\n     2  4\\n    *************************************\\n    >>> t.get_height()\\n    2\\n    >>> t.del_node(3)\\n    delete:3\\n    >>> print(str(t).replace(\\\" \\\\\\\\n\\\",\\\"\\\\\\\\n\\\").replace(\\\" \\\\\\\\n\\\",\\\"\\\\\\\\n\\\"))\\n      4\\n     2  *\\n    *************************************\\n    \\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.root: my_node | None = None\\n\\n    def get_height(self) -> int:\\n        return get_height(self.root)\\n\\n    def insert(self, data: Any) -> None:\\n        print(\\\"insert:\\\" + str(data))\\n        self.root = insert_node(self.root, data)\\n\\n    def del_node(self, data: Any) -> None:\\n        print(\\\"delete:\\\" + str(data))\\n        if self.root is None:\\n            print(\\\"Tree is empty!\\\")\\n            return\\n        self.root = del_node(self.root, data)\\n\\n    def __str__(\\n        self,\\n    ) -> str:  # a level traversale, gives a more intuitive look on the tree\\n        output = \\\"\\\"\\n        q = my_queue()\\n        q.push(self.root)\\n        layer = self.get_height()\\n        if layer == 0:\\n            return output\\n        cnt = 0\\n        while not q.is_empty():\\n            node = q.pop()\\n            space = \\\" \\\" * int(math.pow(2, layer - 1))\\n            output += space\\n            if node is None:\\n                output += \\\"*\\\"\\n                q.push(None)\\n                q.push(None)\\n            else:\\n                output += str(node.get_data())\\n                q.push(node.get_left())\\n                q.push(node.get_right())\\n            output += space\\n            cnt = cnt + 1\\n            for i in range(100):\\n                if cnt == math.pow(2, i) - 1:\\n                    layer = layer - 1\\n                    if layer == 0:\\n                        output += \\\"\\\\n*************************************\\\"\\n                        return output\\n                    output += \\\"\\\\n\\\"\\n                    break\\n        output += \\\"\\\\n*************************************\\\"\\n        return output\\n\\n\\ndef _test() -> None:\\n    import doctest\\n\\n    doctest.testmod()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    _test()\\n    t = AVLtree()\\n    lst = list(range(10))\\n    random.shuffle(lst)\\n    for i in lst:\\n        t.insert(i)\\n        print(str(t))\\n    random.shuffle(lst)\\n    for i in lst:\\n        t.del_node(i)\\n        print(str(t))\\n\"",
    "basic binary tree": "\"from __future__ import annotations\\n\\n\\nclass Node:\\n    \\\"\\\"\\\"\\n    A Node has data variable and pointers to Nodes to its left and right.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, data: int) -> None:\\n        self.data = data\\n        self.left: Node | None = None\\n        self.right: Node | None = None\\n\\n\\ndef display(tree: Node | None) -> None:  # In Order traversal of the tree\\n    \\\"\\\"\\\"\\n    >>> root = Node(1)\\n    >>> root.left = Node(0)\\n    >>> root.right = Node(2)\\n    >>> display(root)\\n    0\\n    1\\n    2\\n    >>> display(root.right)\\n    2\\n    \\\"\\\"\\\"\\n    if tree:\\n        display(tree.left)\\n        print(tree.data)\\n        display(tree.right)\\n\\n\\ndef depth_of_tree(tree: Node | None) -> int:\\n    \\\"\\\"\\\"\\n    Recursive function that returns the depth of a binary tree.\\n\\n    >>> root = Node(0)\\n    >>> depth_of_tree(root)\\n    1\\n    >>> root.left = Node(0)\\n    >>> depth_of_tree(root)\\n    2\\n    >>> root.right = Node(0)\\n    >>> depth_of_tree(root)\\n    2\\n    >>> root.left.right = Node(0)\\n    >>> depth_of_tree(root)\\n    3\\n    >>> depth_of_tree(root.left)\\n    2\\n    \\\"\\\"\\\"\\n    return 1 + max(depth_of_tree(tree.left), depth_of_tree(tree.right)) if tree else 0\\n\\n\\ndef is_full_binary_tree(tree: Node) -> bool:\\n    \\\"\\\"\\\"\\n    Returns True if this is a full binary tree\\n\\n    >>> root = Node(0)\\n    >>> is_full_binary_tree(root)\\n    True\\n    >>> root.left = Node(0)\\n    >>> is_full_binary_tree(root)\\n    False\\n    >>> root.right = Node(0)\\n    >>> is_full_binary_tree(root)\\n    True\\n    >>> root.left.left = Node(0)\\n    >>> is_full_binary_tree(root)\\n    False\\n    >>> root.right.right = Node(0)\\n    >>> is_full_binary_tree(root)\\n    False\\n    \\\"\\\"\\\"\\n    if not tree:\\n        return True\\n    if tree.left and tree.right:\\n        return is_full_binary_tree(tree.left) and is_full_binary_tree(tree.right)\\n    else:\\n        return not tree.left and not tree.right\\n\\n\\ndef main() -> None:  # Main function for testing.\\n    tree = Node(1)\\n    tree.left = Node(2)\\n    tree.right = Node(3)\\n    tree.left.left = Node(4)\\n    tree.left.right = Node(5)\\n    tree.left.right.left = Node(6)\\n    tree.right.left = Node(7)\\n    tree.right.left.left = Node(8)\\n    tree.right.left.left.right = Node(9)\\n\\n    print(is_full_binary_tree(tree))\\n    print(depth_of_tree(tree))\\n    print(\\\"Tree is: \\\")\\n    display(tree)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "binary search tree": "\"\\\"\\\"\\\"\\nA binary search Tree\\n\\\"\\\"\\\"\\n\\n\\nclass Node:\\n    def __init__(self, value, parent):\\n        self.value = value\\n        self.parent = parent  # Added in order to delete a node easier\\n        self.left = None\\n        self.right = None\\n\\n    def __repr__(self):\\n        from pprint import pformat\\n\\n        if self.left is None and self.right is None:\\n            return str(self.value)\\n        return pformat({\\\"%s\\\" % (self.value): (self.left, self.right)}, indent=1)\\n\\n\\nclass BinarySearchTree:\\n    def __init__(self, root=None):\\n        self.root = root\\n\\n    def __str__(self):\\n        \\\"\\\"\\\"\\n        Return a string of all the Nodes using in order traversal\\n        \\\"\\\"\\\"\\n        return str(self.root)\\n\\n    def __reassign_nodes(self, node, new_children):\\n        if new_children is not None:  # reset its kids\\n            new_children.parent = node.parent\\n        if node.parent is not None:  # reset its parent\\n            if self.is_right(node):  # If it is the right children\\n                node.parent.right = new_children\\n            else:\\n                node.parent.left = new_children\\n        else:\\n            self.root = new_children\\n\\n    def is_right(self, node):\\n        return node == node.parent.right\\n\\n    def empty(self):\\n        return self.root is None\\n\\n    def __insert(self, value):\\n        \\\"\\\"\\\"\\n        Insert a new node in Binary Search Tree with value label\\n        \\\"\\\"\\\"\\n        new_node = Node(value, None)  # create a new Node\\n        if self.empty():  # if Tree is empty\\n            self.root = new_node  # set its root\\n        else:  # Tree is not empty\\n            parent_node = self.root  # from root\\n            while True:  # While we don't get to a leaf\\n                if value < parent_node.value:  # We go left\\n                    if parent_node.left is None:\\n                        parent_node.left = new_node  # We insert the new node in a leaf\\n                        break\\n                    else:\\n                        parent_node = parent_node.left\\n                else:\\n                    if parent_node.right is None:\\n                        parent_node.right = new_node\\n                        break\\n                    else:\\n                        parent_node = parent_node.right\\n            new_node.parent = parent_node\\n\\n    def insert(self, *values):\\n        for value in values:\\n            self.__insert(value)\\n        return self\\n\\n    def search(self, value):\\n        if self.empty():\\n            raise IndexError(\\\"Warning: Tree is empty! please use another.\\\")\\n        else:\\n            node = self.root\\n            # use lazy evaluation here to avoid NoneType Attribute error\\n            while node is not None and node.value is not value:\\n                node = node.left if value < node.value else node.right\\n            return node\\n\\n    def get_max(self, node=None):\\n        \\\"\\\"\\\"\\n        We go deep on the right branch\\n        \\\"\\\"\\\"\\n        if node is None:\\n            node = self.root\\n        if not self.empty():\\n            while node.right is not None:\\n                node = node.right\\n        return node\\n\\n    def get_min(self, node=None):\\n        \\\"\\\"\\\"\\n        We go deep on the left branch\\n        \\\"\\\"\\\"\\n        if node is None:\\n            node = self.root\\n        if not self.empty():\\n            node = self.root\\n            while node.left is not None:\\n                node = node.left\\n        return node\\n\\n    def remove(self, value):\\n        node = self.search(value)  # Look for the node with that label\\n        if node is not None:\\n            if node.left is None and node.right is None:  # If it has no children\\n                self.__reassign_nodes(node, None)\\n            elif node.left is None:  # Has only right children\\n                self.__reassign_nodes(node, node.right)\\n            elif node.right is None:  # Has only left children\\n                self.__reassign_nodes(node, node.left)\\n            else:\\n                tmp_node = self.get_max(\\n                    node.left\\n                )  # Gets the max value of the left branch\\n                self.remove(tmp_node.value)\\n                node.value = (\\n                    tmp_node.value\\n                )  # Assigns the value to the node to delete and keep tree structure\\n\\n    def preorder_traverse(self, node):\\n        if node is not None:\\n            yield node  # Preorder Traversal\\n            yield from self.preorder_traverse(node.left)\\n            yield from self.preorder_traverse(node.right)\\n\\n    def traversal_tree(self, traversal_function=None):\\n        \\\"\\\"\\\"\\n        This function traversal the tree.\\n        You can pass a function to traversal the tree as needed by client code\\n        \\\"\\\"\\\"\\n        if traversal_function is None:\\n            return self.preorder_traverse(self.root)\\n        else:\\n            return traversal_function(self.root)\\n\\n    def inorder(self, arr: list, node: Node):\\n        \\\"\\\"\\\"Perform an inorder traversal and append values of the nodes to\\n        a list named arr\\\"\\\"\\\"\\n        if node:\\n            self.inorder(arr, node.left)\\n            arr.append(node.value)\\n            self.inorder(arr, node.right)\\n\\n    def find_kth_smallest(self, k: int, node: Node) -> int:\\n        \\\"\\\"\\\"Return the kth smallest element in a binary search tree\\\"\\\"\\\"\\n        arr: list = []\\n        self.inorder(arr, node)  # append all values to list using inorder traversal\\n        return arr[k - 1]\\n\\n\\ndef postorder(curr_node):\\n    \\\"\\\"\\\"\\n    postOrder (left, right, self)\\n    \\\"\\\"\\\"\\n    node_list = list()\\n    if curr_node is not None:\\n        node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]\\n    return node_list\\n\\n\\ndef binary_search_tree():\\n    r\\\"\\\"\\\"\\n    Example\\n                  8\\n                 / \\\\\\n                3   10\\n               / \\\\    \\\\\\n              1   6    14\\n                 / \\\\   /\\n                4   7 13\\n\\n    >>> t = BinarySearchTree().insert(8, 3, 6, 1, 10, 14, 13, 4, 7)\\n    >>> print(\\\" \\\".join(repr(i.value) for i in t.traversal_tree()))\\n    8 3 1 6 4 7 10 14 13\\n    >>> print(\\\" \\\".join(repr(i.value) for i in t.traversal_tree(postorder)))\\n    1 4 7 6 3 13 14 10 8\\n    >>> BinarySearchTree().search(6)\\n    Traceback (most recent call last):\\n    ...\\n    IndexError: Warning: Tree is empty! please use another.\\n    \\\"\\\"\\\"\\n    testlist = (8, 3, 6, 1, 10, 14, 13, 4, 7)\\n    t = BinarySearchTree()\\n    for i in testlist:\\n        t.insert(i)\\n\\n    # Prints all the elements of the list in order traversal\\n    print(t)\\n\\n    if t.search(6) is not None:\\n        print(\\\"The value 6 exists\\\")\\n    else:\\n        print(\\\"The value 6 doesn't exist\\\")\\n\\n    if t.search(-1) is not None:\\n        print(\\\"The value -1 exists\\\")\\n    else:\\n        print(\\\"The value -1 doesn't exist\\\")\\n\\n    if not t.empty():\\n        print(\\\"Max Value: \\\", t.get_max().value)\\n        print(\\\"Min Value: \\\", t.get_min().value)\\n\\n    for i in testlist:\\n        t.remove(i)\\n        print(t)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    # binary_search_tree()\\n\"",
    "binary search tree recursive": "\"\\\"\\\"\\\"\\nThis is a python3 implementation of binary search tree using recursion\\n\\nTo run tests:\\npython -m unittest binary_search_tree_recursive.py\\n\\nTo run an example:\\npython binary_search_tree_recursive.py\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nimport unittest\\nfrom typing import Iterator\\n\\n\\nclass Node:\\n    def __init__(self, label: int, parent: Node | None) -> None:\\n        self.label = label\\n        self.parent = parent\\n        self.left: Node | None = None\\n        self.right: Node | None = None\\n\\n\\nclass BinarySearchTree:\\n    def __init__(self) -> None:\\n        self.root: Node | None = None\\n\\n    def empty(self) -> None:\\n        \\\"\\\"\\\"\\n        Empties the tree\\n\\n        >>> t = BinarySearchTree()\\n        >>> assert t.root is None\\n        >>> t.put(8)\\n        >>> assert t.root is not None\\n        \\\"\\\"\\\"\\n        self.root = None\\n\\n    def is_empty(self) -> bool:\\n        \\\"\\\"\\\"\\n        Checks if the tree is empty\\n\\n        >>> t = BinarySearchTree()\\n        >>> t.is_empty()\\n        True\\n        >>> t.put(8)\\n        >>> t.is_empty()\\n        False\\n        \\\"\\\"\\\"\\n        return self.root is None\\n\\n    def put(self, label: int) -> None:\\n        \\\"\\\"\\\"\\n        Put a new node in the tree\\n\\n        >>> t = BinarySearchTree()\\n        >>> t.put(8)\\n        >>> assert t.root.parent is None\\n        >>> assert t.root.label == 8\\n\\n        >>> t.put(10)\\n        >>> assert t.root.right.parent == t.root\\n        >>> assert t.root.right.label == 10\\n\\n        >>> t.put(3)\\n        >>> assert t.root.left.parent == t.root\\n        >>> assert t.root.left.label == 3\\n        \\\"\\\"\\\"\\n        self.root = self._put(self.root, label)\\n\\n    def _put(self, node: Node | None, label: int, parent: Node | None = None) -> Node:\\n        if node is None:\\n            node = Node(label, parent)\\n        else:\\n            if label < node.label:\\n                node.left = self._put(node.left, label, node)\\n            elif label > node.label:\\n                node.right = self._put(node.right, label, node)\\n            else:\\n                raise Exception(f\\\"Node with label {label} already exists\\\")\\n\\n        return node\\n\\n    def search(self, label: int) -> Node:\\n        \\\"\\\"\\\"\\n        Searches a node in the tree\\n\\n        >>> t = BinarySearchTree()\\n        >>> t.put(8)\\n        >>> t.put(10)\\n        >>> node = t.search(8)\\n        >>> assert node.label == 8\\n\\n        >>> node = t.search(3)\\n        Traceback (most recent call last):\\n            ...\\n        Exception: Node with label 3 does not exist\\n        \\\"\\\"\\\"\\n        return self._search(self.root, label)\\n\\n    def _search(self, node: Node | None, label: int) -> Node:\\n        if node is None:\\n            raise Exception(f\\\"Node with label {label} does not exist\\\")\\n        else:\\n            if label < node.label:\\n                node = self._search(node.left, label)\\n            elif label > node.label:\\n                node = self._search(node.right, label)\\n\\n        return node\\n\\n    def remove(self, label: int) -> None:\\n        \\\"\\\"\\\"\\n        Removes a node in the tree\\n\\n        >>> t = BinarySearchTree()\\n        >>> t.put(8)\\n        >>> t.put(10)\\n        >>> t.remove(8)\\n        >>> assert t.root.label == 10\\n\\n        >>> t.remove(3)\\n        Traceback (most recent call last):\\n            ...\\n        Exception: Node with label 3 does not exist\\n        \\\"\\\"\\\"\\n        node = self.search(label)\\n        if node.right and node.left:\\n            lowest_node = self._get_lowest_node(node.right)\\n            lowest_node.left = node.left\\n            lowest_node.right = node.right\\n            node.left.parent = lowest_node\\n            if node.right:\\n                node.right.parent = lowest_node\\n            self._reassign_nodes(node, lowest_node)\\n        elif not node.right and node.left:\\n            self._reassign_nodes(node, node.left)\\n        elif node.right and not node.left:\\n            self._reassign_nodes(node, node.right)\\n        else:\\n            self._reassign_nodes(node, None)\\n\\n    def _reassign_nodes(self, node: Node, new_children: Node | None) -> None:\\n        if new_children:\\n            new_children.parent = node.parent\\n\\n        if node.parent:\\n            if node.parent.right == node:\\n                node.parent.right = new_children\\n            else:\\n                node.parent.left = new_children\\n        else:\\n            self.root = new_children\\n\\n    def _get_lowest_node(self, node: Node) -> Node:\\n        if node.left:\\n            lowest_node = self._get_lowest_node(node.left)\\n        else:\\n            lowest_node = node\\n            self._reassign_nodes(node, node.right)\\n\\n        return lowest_node\\n\\n    def exists(self, label: int) -> bool:\\n        \\\"\\\"\\\"\\n        Checks if a node exists in the tree\\n\\n        >>> t = BinarySearchTree()\\n        >>> t.put(8)\\n        >>> t.put(10)\\n        >>> t.exists(8)\\n        True\\n\\n        >>> t.exists(3)\\n        False\\n        \\\"\\\"\\\"\\n        try:\\n            self.search(label)\\n            return True\\n        except Exception:\\n            return False\\n\\n    def get_max_label(self) -> int:\\n        \\\"\\\"\\\"\\n        Gets the max label inserted in the tree\\n\\n        >>> t = BinarySearchTree()\\n        >>> t.get_max_label()\\n        Traceback (most recent call last):\\n            ...\\n        Exception: Binary search tree is empty\\n\\n        >>> t.put(8)\\n        >>> t.put(10)\\n        >>> t.get_max_label()\\n        10\\n        \\\"\\\"\\\"\\n        if self.root is None:\\n            raise Exception(\\\"Binary search tree is empty\\\")\\n\\n        node = self.root\\n        while node.right is not None:\\n            node = node.right\\n\\n        return node.label\\n\\n    def get_min_label(self) -> int:\\n        \\\"\\\"\\\"\\n        Gets the min label inserted in the tree\\n\\n        >>> t = BinarySearchTree()\\n        >>> t.get_min_label()\\n        Traceback (most recent call last):\\n            ...\\n        Exception: Binary search tree is empty\\n\\n        >>> t.put(8)\\n        >>> t.put(10)\\n        >>> t.get_min_label()\\n        8\\n        \\\"\\\"\\\"\\n        if self.root is None:\\n            raise Exception(\\\"Binary search tree is empty\\\")\\n\\n        node = self.root\\n        while node.left is not None:\\n            node = node.left\\n\\n        return node.label\\n\\n    def inorder_traversal(self) -> Iterator[Node]:\\n        \\\"\\\"\\\"\\n        Return the inorder traversal of the tree\\n\\n        >>> t = BinarySearchTree()\\n        >>> [i.label for i in t.inorder_traversal()]\\n        []\\n\\n        >>> t.put(8)\\n        >>> t.put(10)\\n        >>> t.put(9)\\n        >>> [i.label for i in t.inorder_traversal()]\\n        [8, 9, 10]\\n        \\\"\\\"\\\"\\n        return self._inorder_traversal(self.root)\\n\\n    def _inorder_traversal(self, node: Node | None) -> Iterator[Node]:\\n        if node is not None:\\n            yield from self._inorder_traversal(node.left)\\n            yield node\\n            yield from self._inorder_traversal(node.right)\\n\\n    def preorder_traversal(self) -> Iterator[Node]:\\n        \\\"\\\"\\\"\\n        Return the preorder traversal of the tree\\n\\n        >>> t = BinarySearchTree()\\n        >>> [i.label for i in t.preorder_traversal()]\\n        []\\n\\n        >>> t.put(8)\\n        >>> t.put(10)\\n        >>> t.put(9)\\n        >>> [i.label for i in t.preorder_traversal()]\\n        [8, 10, 9]\\n        \\\"\\\"\\\"\\n        return self._preorder_traversal(self.root)\\n\\n    def _preorder_traversal(self, node: Node | None) -> Iterator[Node]:\\n        if node is not None:\\n            yield node\\n            yield from self._preorder_traversal(node.left)\\n            yield from self._preorder_traversal(node.right)\\n\\n\\nclass BinarySearchTreeTest(unittest.TestCase):\\n    @staticmethod\\n    def _get_binary_search_tree() -> BinarySearchTree:\\n        r\\\"\\\"\\\"\\n              8\\n             / \\\\\\n            3   10\\n           / \\\\    \\\\\\n          1   6    14\\n             / \\\\   /\\n            4   7 13\\n             \\\\\\n              5\\n        \\\"\\\"\\\"\\n        t = BinarySearchTree()\\n        t.put(8)\\n        t.put(3)\\n        t.put(6)\\n        t.put(1)\\n        t.put(10)\\n        t.put(14)\\n        t.put(13)\\n        t.put(4)\\n        t.put(7)\\n        t.put(5)\\n\\n        return t\\n\\n    def test_put(self) -> None:\\n        t = BinarySearchTree()\\n        assert t.is_empty()\\n\\n        t.put(8)\\n        r\\\"\\\"\\\"\\n              8\\n        \\\"\\\"\\\"\\n        assert t.root is not None\\n        assert t.root.parent is None\\n        assert t.root.label == 8\\n\\n        t.put(10)\\n        r\\\"\\\"\\\"\\n              8\\n               \\\\\\n                10\\n        \\\"\\\"\\\"\\n        assert t.root.right is not None\\n        assert t.root.right.parent == t.root\\n        assert t.root.right.label == 10\\n\\n        t.put(3)\\n        r\\\"\\\"\\\"\\n              8\\n             / \\\\\\n            3   10\\n        \\\"\\\"\\\"\\n        assert t.root.left is not None\\n        assert t.root.left.parent == t.root\\n        assert t.root.left.label == 3\\n\\n        t.put(6)\\n        r\\\"\\\"\\\"\\n              8\\n             / \\\\\\n            3   10\\n             \\\\\\n              6\\n        \\\"\\\"\\\"\\n        assert t.root.left.right is not None\\n        assert t.root.left.right.parent == t.root.left\\n        assert t.root.left.right.label == 6\\n\\n        t.put(1)\\n        r\\\"\\\"\\\"\\n              8\\n             / \\\\\\n            3   10\\n           / \\\\\\n          1   6\\n        \\\"\\\"\\\"\\n        assert t.root.left.left is not None\\n        assert t.root.left.left.parent == t.root.left\\n        assert t.root.left.left.label == 1\\n\\n        with self.assertRaises(Exception):\\n            t.put(1)\\n\\n    def test_search(self) -> None:\\n        t = self._get_binary_search_tree()\\n\\n        node = t.search(6)\\n        assert node.label == 6\\n\\n        node = t.search(13)\\n        assert node.label == 13\\n\\n        with self.assertRaises(Exception):\\n            t.search(2)\\n\\n    def test_remove(self) -> None:\\n        t = self._get_binary_search_tree()\\n\\n        t.remove(13)\\n        r\\\"\\\"\\\"\\n              8\\n             / \\\\\\n            3   10\\n           / \\\\    \\\\\\n          1   6    14\\n             / \\\\\\n            4   7\\n             \\\\\\n              5\\n        \\\"\\\"\\\"\\n        assert t.root is not None\\n        assert t.root.right is not None\\n        assert t.root.right.right is not None\\n        assert t.root.right.right.right is None\\n        assert t.root.right.right.left is None\\n\\n        t.remove(7)\\n        r\\\"\\\"\\\"\\n              8\\n             / \\\\\\n            3   10\\n           / \\\\    \\\\\\n          1   6    14\\n             /\\n            4\\n             \\\\\\n              5\\n        \\\"\\\"\\\"\\n        assert t.root.left is not None\\n        assert t.root.left.right is not None\\n        assert t.root.left.right.left is not None\\n        assert t.root.left.right.right is None\\n        assert t.root.left.right.left.label == 4\\n\\n        t.remove(6)\\n        r\\\"\\\"\\\"\\n              8\\n             / \\\\\\n            3   10\\n           / \\\\    \\\\\\n          1   4    14\\n               \\\\\\n                5\\n        \\\"\\\"\\\"\\n        assert t.root.left.left is not None\\n        assert t.root.left.right.right is not None\\n        assert t.root.left.left.label == 1\\n        assert t.root.left.right.label == 4\\n        assert t.root.left.right.right.label == 5\\n        assert t.root.left.right.left is None\\n        assert t.root.left.left.parent == t.root.left\\n        assert t.root.left.right.parent == t.root.left\\n\\n        t.remove(3)\\n        r\\\"\\\"\\\"\\n              8\\n             / \\\\\\n            4   10\\n           / \\\\    \\\\\\n          1   5    14\\n        \\\"\\\"\\\"\\n        assert t.root is not None\\n        assert t.root.left.label == 4\\n        assert t.root.left.right.label == 5\\n        assert t.root.left.left.label == 1\\n        assert t.root.left.parent == t.root\\n        assert t.root.left.left.parent == t.root.left\\n        assert t.root.left.right.parent == t.root.left\\n\\n        t.remove(4)\\n        r\\\"\\\"\\\"\\n              8\\n             / \\\\\\n            5   10\\n           /      \\\\\\n          1        14\\n        \\\"\\\"\\\"\\n        assert t.root.left is not None\\n        assert t.root.left.left is not None\\n        assert t.root.left.label == 5\\n        assert t.root.left.right is None\\n        assert t.root.left.left.label == 1\\n        assert t.root.left.parent == t.root\\n        assert t.root.left.left.parent == t.root.left\\n\\n    def test_remove_2(self) -> None:\\n        t = self._get_binary_search_tree()\\n\\n        t.remove(3)\\n        r\\\"\\\"\\\"\\n              8\\n             / \\\\\\n            4   10\\n           / \\\\    \\\\\\n          1   6    14\\n             / \\\\   /\\n            5   7 13\\n        \\\"\\\"\\\"\\n        assert t.root is not None\\n        assert t.root.left is not None\\n        assert t.root.left.left is not None\\n        assert t.root.left.right is not None\\n        assert t.root.left.right.left is not None\\n        assert t.root.left.right.right is not None\\n        assert t.root.left.label == 4\\n        assert t.root.left.right.label == 6\\n        assert t.root.left.left.label == 1\\n        assert t.root.left.right.right.label == 7\\n        assert t.root.left.right.left.label == 5\\n        assert t.root.left.parent == t.root\\n        assert t.root.left.right.parent == t.root.left\\n        assert t.root.left.left.parent == t.root.left\\n        assert t.root.left.right.left.parent == t.root.left.right\\n\\n    def test_empty(self) -> None:\\n        t = self._get_binary_search_tree()\\n        t.empty()\\n        assert t.root is None\\n\\n    def test_is_empty(self) -> None:\\n        t = self._get_binary_search_tree()\\n        assert not t.is_empty()\\n\\n        t.empty()\\n        assert t.is_empty()\\n\\n    def test_exists(self) -> None:\\n        t = self._get_binary_search_tree()\\n\\n        assert t.exists(6)\\n        assert not t.exists(-1)\\n\\n    def test_get_max_label(self) -> None:\\n        t = self._get_binary_search_tree()\\n\\n        assert t.get_max_label() == 14\\n\\n        t.empty()\\n        with self.assertRaises(Exception):\\n            t.get_max_label()\\n\\n    def test_get_min_label(self) -> None:\\n        t = self._get_binary_search_tree()\\n\\n        assert t.get_min_label() == 1\\n\\n        t.empty()\\n        with self.assertRaises(Exception):\\n            t.get_min_label()\\n\\n    def test_inorder_traversal(self) -> None:\\n        t = self._get_binary_search_tree()\\n\\n        inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]\\n        assert inorder_traversal_nodes == [1, 3, 4, 5, 6, 7, 8, 10, 13, 14]\\n\\n    def test_preorder_traversal(self) -> None:\\n        t = self._get_binary_search_tree()\\n\\n        preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]\\n        assert preorder_traversal_nodes == [8, 3, 1, 6, 4, 5, 7, 10, 14, 13]\\n\\n\\ndef binary_search_tree_example() -> None:\\n    r\\\"\\\"\\\"\\n    Example\\n                  8\\n                 / \\\\\\n                3   10\\n               / \\\\    \\\\\\n              1   6    14\\n                 / \\\\   /\\n                4   7 13\\n                \\\\\\n                5\\n\\n    Example After Deletion\\n                  4\\n                 / \\\\\\n                1   7\\n                     \\\\\\n                      5\\n\\n    \\\"\\\"\\\"\\n\\n    t = BinarySearchTree()\\n    t.put(8)\\n    t.put(3)\\n    t.put(6)\\n    t.put(1)\\n    t.put(10)\\n    t.put(14)\\n    t.put(13)\\n    t.put(4)\\n    t.put(7)\\n    t.put(5)\\n\\n    print(\\n        \\\"\\\"\\\"\\n            8\\n           / \\\\\\\\\\n          3   10\\n         / \\\\\\\\    \\\\\\\\\\n        1   6    14\\n           / \\\\\\\\   /\\n          4   7 13\\n           \\\\\\\\\\n            5\\n        \\\"\\\"\\\"\\n    )\\n\\n    print(\\\"Label 6 exists:\\\", t.exists(6))\\n    print(\\\"Label 13 exists:\\\", t.exists(13))\\n    print(\\\"Label -1 exists:\\\", t.exists(-1))\\n    print(\\\"Label 12 exists:\\\", t.exists(12))\\n\\n    # Prints all the elements of the list in inorder traversal\\n    inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]\\n    print(\\\"Inorder traversal:\\\", inorder_traversal_nodes)\\n\\n    # Prints all the elements of the list in preorder traversal\\n    preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]\\n    print(\\\"Preorder traversal:\\\", preorder_traversal_nodes)\\n\\n    print(\\\"Max. label:\\\", t.get_max_label())\\n    print(\\\"Min. label:\\\", t.get_min_label())\\n\\n    # Delete elements\\n    print(\\\"\\\\nDeleting elements 13, 10, 8, 3, 6, 14\\\")\\n    print(\\n        \\\"\\\"\\\"\\n          4\\n         / \\\\\\\\\\n        1   7\\n             \\\\\\\\\\n              5\\n        \\\"\\\"\\\"\\n    )\\n    t.remove(13)\\n    t.remove(10)\\n    t.remove(8)\\n    t.remove(3)\\n    t.remove(6)\\n    t.remove(14)\\n\\n    # Prints all the elements of the list in inorder traversal after delete\\n    inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]\\n    print(\\\"Inorder traversal after delete:\\\", inorder_traversal_nodes)\\n\\n    # Prints all the elements of the list in preorder traversal after delete\\n    preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]\\n    print(\\\"Preorder traversal after delete:\\\", preorder_traversal_nodes)\\n\\n    print(\\\"Max. label:\\\", t.get_max_label())\\n    print(\\\"Min. label:\\\", t.get_min_label())\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    binary_search_tree_example()\\n\"",
    "binary tree mirror": "\"\\\"\\\"\\\"\\nProblem Description:\\nGiven a binary tree, return its mirror.\\n\\\"\\\"\\\"\\n\\n\\ndef binary_tree_mirror_dict(binary_tree_mirror_dictionary: dict, root: int):\\n    if not root or root not in binary_tree_mirror_dictionary:\\n        return\\n    left_child, right_child = binary_tree_mirror_dictionary[root][:2]\\n    binary_tree_mirror_dictionary[root] = [right_child, left_child]\\n    binary_tree_mirror_dict(binary_tree_mirror_dictionary, left_child)\\n    binary_tree_mirror_dict(binary_tree_mirror_dictionary, right_child)\\n\\n\\ndef binary_tree_mirror(binary_tree: dict, root: int = 1) -> dict:\\n    \\\"\\\"\\\"\\n    >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 7: [8,9]}, 1)\\n    {1: [3, 2], 2: [5, 4], 3: [7, 6], 7: [9, 8]}\\n    >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 1)\\n    {1: [3, 2], 2: [5, 4], 3: [7, 6], 4: [11, 10]}\\n    >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 5)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: root 5 is not present in the binary_tree\\n    >>> binary_tree_mirror({}, 5)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: binary tree cannot be empty\\n    \\\"\\\"\\\"\\n    if not binary_tree:\\n        raise ValueError(\\\"binary tree cannot be empty\\\")\\n    if root not in binary_tree:\\n        raise ValueError(f\\\"root {root} is not present in the binary_tree\\\")\\n    binary_tree_mirror_dictionary = dict(binary_tree)\\n    binary_tree_mirror_dict(binary_tree_mirror_dictionary, root)\\n    return binary_tree_mirror_dictionary\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    binary_tree = {1: [2, 3], 2: [4, 5], 3: [6, 7], 7: [8, 9]}\\n    print(f\\\"Binary tree: {binary_tree}\\\")\\n    binary_tree_mirror_dictionary = binary_tree_mirror(binary_tree, 5)\\n    print(f\\\"Binary tree mirror: {binary_tree_mirror_dictionary}\\\")\\n\"",
    "binary tree traversals": "\"# https://en.wikipedia.org/wiki/Tree_traversal\\r\\nfrom __future__ import annotations\\r\\n\\r\\nfrom collections import deque\\r\\nfrom dataclasses import dataclass\\r\\nfrom typing import Any, Sequence\\r\\n\\r\\n\\r\\n@dataclass\\r\\nclass Node:\\r\\n    data: int\\r\\n    left: Node | None = None\\r\\n    right: Node | None = None\\r\\n\\r\\n\\r\\ndef make_tree() -> Node | None:\\r\\n    return Node(1, Node(2, Node(4), Node(5)), Node(3))\\r\\n\\r\\n\\r\\ndef preorder(root: Node | None) -> list[int]:\\r\\n    \\\"\\\"\\\"\\r\\n    Pre-order traversal visits root node, left subtree, right subtree.\\r\\n    >>> preorder(make_tree())\\r\\n    [1, 2, 4, 5, 3]\\r\\n    \\\"\\\"\\\"\\r\\n    return [root.data] + preorder(root.left) + preorder(root.right) if root else []\\r\\n\\r\\n\\r\\ndef postorder(root: Node | None) -> list[int]:\\r\\n    \\\"\\\"\\\"\\r\\n    Post-order traversal visits left subtree, right subtree, root node.\\r\\n    >>> postorder(make_tree())\\r\\n    [4, 5, 2, 3, 1]\\r\\n    \\\"\\\"\\\"\\r\\n    return postorder(root.left) + postorder(root.right) + [root.data] if root else []\\r\\n\\r\\n\\r\\ndef inorder(root: Node | None) -> list[int]:\\r\\n    \\\"\\\"\\\"\\r\\n    In-order traversal visits left subtree, root node, right subtree.\\r\\n    >>> inorder(make_tree())\\r\\n    [4, 2, 5, 1, 3]\\r\\n    \\\"\\\"\\\"\\r\\n    return inorder(root.left) + [root.data] + inorder(root.right) if root else []\\r\\n\\r\\n\\r\\ndef height(root: Node | None) -> int:\\r\\n    \\\"\\\"\\\"\\r\\n    Recursive function for calculating the height of the binary tree.\\r\\n    >>> height(None)\\r\\n    0\\r\\n    >>> height(make_tree())\\r\\n    3\\r\\n    \\\"\\\"\\\"\\r\\n    return (max(height(root.left), height(root.right)) + 1) if root else 0\\r\\n\\r\\n\\r\\ndef level_order(root: Node | None) -> Sequence[Node | None]:\\r\\n    \\\"\\\"\\\"\\r\\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\\r\\n    Level Order traverse: Visit nodes of the tree level-by-level.\\r\\n    \\\"\\\"\\\"\\r\\n    output: list[Any] = []\\r\\n\\r\\n    if root is None:\\r\\n        return output\\r\\n\\r\\n    process_queue = deque([root])\\r\\n\\r\\n    while process_queue:\\r\\n        node = process_queue.popleft()\\r\\n        output.append(node.data)\\r\\n\\r\\n        if node.left:\\r\\n            process_queue.append(node.left)\\r\\n        if node.right:\\r\\n            process_queue.append(node.right)\\r\\n    return output\\r\\n\\r\\n\\r\\ndef get_nodes_from_left_to_right(\\r\\n    root: Node | None, level: int\\r\\n) -> Sequence[Node | None]:\\r\\n    \\\"\\\"\\\"\\r\\n    Returns a list of nodes value from a particular level:\\r\\n    Left to right direction of the binary tree.\\r\\n    \\\"\\\"\\\"\\r\\n    output: list[Any] = []\\r\\n\\r\\n    def populate_output(root: Node | None, level: int) -> None:\\r\\n        if not root:\\r\\n            return\\r\\n        if level == 1:\\r\\n\\r\\n            output.append(root.data)\\r\\n        elif level > 1:\\r\\n            populate_output(root.left, level - 1)\\r\\n            populate_output(root.right, level - 1)\\r\\n\\r\\n    populate_output(root, level)\\r\\n    return output\\r\\n\\r\\n\\r\\ndef get_nodes_from_right_to_left(\\r\\n    root: Node | None, level: int\\r\\n) -> Sequence[Node | None]:\\r\\n    \\\"\\\"\\\"\\r\\n    Returns a list of nodes value from a particular level:\\r\\n    Right to left direction of the binary tree.\\r\\n    \\\"\\\"\\\"\\r\\n    output: list[Any] = []\\r\\n\\r\\n    def populate_output(root: Node | None, level: int) -> None:\\r\\n        if root is None:\\r\\n            return\\r\\n        if level == 1:\\r\\n            output.append(root.data)\\r\\n        elif level > 1:\\r\\n            populate_output(root.right, level - 1)\\r\\n            populate_output(root.left, level - 1)\\r\\n\\r\\n    populate_output(root, level)\\r\\n    return output\\r\\n\\r\\n\\r\\ndef zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\\r\\n    \\\"\\\"\\\"\\r\\n    ZigZag traverse:\\r\\n    Returns a list of nodes value from left to right and right to left, alternatively.\\r\\n    \\\"\\\"\\\"\\r\\n    if root is None:\\r\\n        return []\\r\\n\\r\\n    output: list[Sequence[Node | None]] = []\\r\\n\\r\\n    flag = 0\\r\\n    height_tree = height(root)\\r\\n\\r\\n    for h in range(1, height_tree + 1):\\r\\n        if not flag:\\r\\n            output.append(get_nodes_from_left_to_right(root, h))\\r\\n            flag = 1\\r\\n        else:\\r\\n            output.append(get_nodes_from_right_to_left(root, h))\\r\\n            flag = 0\\r\\n\\r\\n    return output\\r\\n\\r\\n\\r\\ndef main() -> None:  # Main function for testing.\\r\\n    \\\"\\\"\\\"\\r\\n    Create binary tree.\\r\\n    \\\"\\\"\\\"\\r\\n    root = make_tree()\\r\\n    \\\"\\\"\\\"\\r\\n    All Traversals of the binary are as follows:\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    print(f\\\"In-order Traversal: {inorder(root)}\\\")\\r\\n    print(f\\\"Pre-order Traversal: {preorder(root)}\\\")\\r\\n    print(f\\\"Post-order Traversal: {postorder(root)}\\\", \\\"\\\\n\\\")\\r\\n\\r\\n    print(f\\\"Height of Tree: {height(root)}\\\", \\\"\\\\n\\\")\\r\\n\\r\\n    print(\\\"Complete Level Order Traversal: \\\")\\r\\n    print(level_order(root), \\\"\\\\n\\\")\\r\\n\\r\\n    print(\\\"Level-wise order Traversal: \\\")\\r\\n\\r\\n    for level in range(1, height(root) + 1):\\r\\n        print(f\\\"Level {level}:\\\", get_nodes_from_left_to_right(root, level=level))\\r\\n\\r\\n    print(\\\"\\\\nZigZag order Traversal: \\\")\\r\\n    print(zigzag(root))\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n    main()\\r\\n\"",
    "fenwick tree": "\"class FenwickTree:\\n    def __init__(self, SIZE):  # create fenwick tree with size SIZE\\n        self.Size = SIZE\\n        self.ft = [0 for i in range(0, SIZE)]\\n\\n    def update(self, i, val):  # update data (adding) in index i in O(lg N)\\n        while i < self.Size:\\n            self.ft[i] += val\\n            i += i & (-i)\\n\\n    def query(self, i):  # query cumulative data from index 0 to i in O(lg N)\\n        ret = 0\\n        while i > 0:\\n            ret += self.ft[i]\\n            i -= i & (-i)\\n        return ret\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    f = FenwickTree(100)\\n    f.update(1, 20)\\n    f.update(4, 4)\\n    print(f.query(1))\\n    print(f.query(3))\\n    print(f.query(4))\\n    f.update(2, -5)\\n    print(f.query(1))\\n    print(f.query(3))\\n\"",
    "lazy segment tree": "\"from __future__ import annotations\\n\\nimport math\\n\\n\\nclass SegmentTree:\\n    def __init__(self, size: int) -> None:\\n        self.size = size\\n        # approximate the overall size of segment tree with given value\\n        self.segment_tree = [0 for i in range(0, 4 * size)]\\n        # create array to store lazy update\\n        self.lazy = [0 for i in range(0, 4 * size)]\\n        self.flag = [0 for i in range(0, 4 * size)]  # flag for lazy update\\n\\n    def left(self, idx: int) -> int:\\n        \\\"\\\"\\\"\\n        >>> segment_tree = SegmentTree(15)\\n        >>> segment_tree.left(1)\\n        2\\n        >>> segment_tree.left(2)\\n        4\\n        >>> segment_tree.left(12)\\n        24\\n        \\\"\\\"\\\"\\n        return idx * 2\\n\\n    def right(self, idx: int) -> int:\\n        \\\"\\\"\\\"\\n        >>> segment_tree = SegmentTree(15)\\n        >>> segment_tree.right(1)\\n        3\\n        >>> segment_tree.right(2)\\n        5\\n        >>> segment_tree.right(12)\\n        25\\n        \\\"\\\"\\\"\\n        return idx * 2 + 1\\n\\n    def build(\\n        self, idx: int, left_element: int, right_element: int, A: list[int]\\n    ) -> None:\\n        if left_element == right_element:\\n            self.segment_tree[idx] = A[left_element - 1]\\n        else:\\n            mid = (left_element + right_element) // 2\\n            self.build(self.left(idx), left_element, mid, A)\\n            self.build(self.right(idx), mid + 1, right_element, A)\\n            self.segment_tree[idx] = max(\\n                self.segment_tree[self.left(idx)], self.segment_tree[self.right(idx)]\\n            )\\n\\n    def update(\\n        self, idx: int, left_element: int, right_element: int, a: int, b: int, val: int\\n    ) -> bool:\\n        \\\"\\\"\\\"\\n        update with O(lg n) (Normal segment tree without lazy update will take O(nlg n)\\n        for each update)\\n\\n        update(1, 1, size, a, b, v) for update val v to [a,b]\\n        \\\"\\\"\\\"\\n        if self.flag[idx] is True:\\n            self.segment_tree[idx] = self.lazy[idx]\\n            self.flag[idx] = False\\n            if left_element != right_element:\\n                self.lazy[self.left(idx)] = self.lazy[idx]\\n                self.lazy[self.right(idx)] = self.lazy[idx]\\n                self.flag[self.left(idx)] = True\\n                self.flag[self.right(idx)] = True\\n\\n        if right_element < a or left_element > b:\\n            return True\\n        if left_element >= a and right_element <= b:\\n            self.segment_tree[idx] = val\\n            if left_element != right_element:\\n                self.lazy[self.left(idx)] = val\\n                self.lazy[self.right(idx)] = val\\n                self.flag[self.left(idx)] = True\\n                self.flag[self.right(idx)] = True\\n            return True\\n        mid = (left_element + right_element) // 2\\n        self.update(self.left(idx), left_element, mid, a, b, val)\\n        self.update(self.right(idx), mid + 1, right_element, a, b, val)\\n        self.segment_tree[idx] = max(\\n            self.segment_tree[self.left(idx)], self.segment_tree[self.right(idx)]\\n        )\\n        return True\\n\\n    # query with O(lg n)\\n    def query(\\n        self, idx: int, left_element: int, right_element: int, a: int, b: int\\n    ) -> int | float:\\n        \\\"\\\"\\\"\\n        query(1, 1, size, a, b) for query max of [a,b]\\n        >>> A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]\\n        >>> segment_tree = SegmentTree(15)\\n        >>> segment_tree.build(1, 1, 15, A)\\n        >>> segment_tree.query(1, 1, 15, 4, 6)\\n        7\\n        >>> segment_tree.query(1, 1, 15, 7, 11)\\n        14\\n        >>> segment_tree.query(1, 1, 15, 7, 12)\\n        15\\n        \\\"\\\"\\\"\\n        if self.flag[idx] is True:\\n            self.segment_tree[idx] = self.lazy[idx]\\n            self.flag[idx] = False\\n            if left_element != right_element:\\n                self.lazy[self.left(idx)] = self.lazy[idx]\\n                self.lazy[self.right(idx)] = self.lazy[idx]\\n                self.flag[self.left(idx)] = True\\n                self.flag[self.right(idx)] = True\\n        if right_element < a or left_element > b:\\n            return -math.inf\\n        if left_element >= a and right_element <= b:\\n            return self.segment_tree[idx]\\n        mid = (left_element + right_element) // 2\\n        q1 = self.query(self.left(idx), left_element, mid, a, b)\\n        q2 = self.query(self.right(idx), mid + 1, right_element, a, b)\\n        return max(q1, q2)\\n\\n    def __str__(self) -> str:\\n        return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]\\n    size = 15\\n    segt = SegmentTree(size)\\n    segt.build(1, 1, size, A)\\n    print(segt.query(1, 1, size, 4, 6))\\n    print(segt.query(1, 1, size, 7, 11))\\n    print(segt.query(1, 1, size, 7, 12))\\n    segt.update(1, 1, size, 1, 3, 111)\\n    print(segt.query(1, 1, size, 1, 15))\\n    segt.update(1, 1, size, 7, 8, 235)\\n    print(segt)\\n\"",
    "lowest common ancestor": "\"# https://en.wikipedia.org/wiki/Lowest_common_ancestor\\n# https://en.wikipedia.org/wiki/Breadth-first_search\\n\\nfrom __future__ import annotations\\n\\nfrom queue import Queue\\n\\n\\ndef swap(a: int, b: int) -> tuple[int, int]:\\n    \\\"\\\"\\\"\\n    Return a tuple (b, a) when given two integers a and b\\n    >>> swap(2,3)\\n    (3, 2)\\n    >>> swap(3,4)\\n    (4, 3)\\n    >>> swap(67, 12)\\n    (12, 67)\\n    \\\"\\\"\\\"\\n    a ^= b\\n    b ^= a\\n    a ^= b\\n    return a, b\\n\\n\\ndef create_sparse(max_node: int, parent: list[list[int]]) -> list[list[int]]:\\n    \\\"\\\"\\\"\\n    creating sparse table which saves each nodes 2^i-th parent\\n    \\\"\\\"\\\"\\n    j = 1\\n    while (1 << j) < max_node:\\n        for i in range(1, max_node + 1):\\n            parent[j][i] = parent[j - 1][parent[j - 1][i]]\\n        j += 1\\n    return parent\\n\\n\\n# returns lca of node u,v\\ndef lowest_common_ancestor(\\n    u: int, v: int, level: list[int], parent: list[list[int]]\\n) -> int:\\n    # u must be deeper in the tree than v\\n    if level[u] < level[v]:\\n        u, v = swap(u, v)\\n    # making depth of u same as depth of v\\n    for i in range(18, -1, -1):\\n        if level[u] - (1 << i) >= level[v]:\\n            u = parent[i][u]\\n    # at the same depth if u==v that mean lca is found\\n    if u == v:\\n        return u\\n    # moving both nodes upwards till lca in found\\n    for i in range(18, -1, -1):\\n        if parent[i][u] not in [0, parent[i][v]]:\\n            u, v = parent[i][u], parent[i][v]\\n    # returning longest common ancestor of u,v\\n    return parent[0][u]\\n\\n\\n# runs a breadth first search from root node of the tree\\ndef breadth_first_search(\\n    level: list[int],\\n    parent: list[list[int]],\\n    max_node: int,\\n    graph: dict[int, list[int]],\\n    root: int = 1,\\n) -> tuple[list[int], list[list[int]]]:\\n    \\\"\\\"\\\"\\n    sets every nodes direct parent\\n    parent of root node is set to 0\\n    calculates depth of each node from root node\\n    \\\"\\\"\\\"\\n    level[root] = 0\\n    q: Queue[int] = Queue(maxsize=max_node)\\n    q.put(root)\\n    while q.qsize() != 0:\\n        u = q.get()\\n        for v in graph[u]:\\n            if level[v] == -1:\\n                level[v] = level[u] + 1\\n                q.put(v)\\n                parent[0][v] = u\\n    return level, parent\\n\\n\\ndef main() -> None:\\n    max_node = 13\\n    # initializing with 0\\n    parent = [[0 for _ in range(max_node + 10)] for _ in range(20)]\\n    # initializing with -1 which means every node is unvisited\\n    level = [-1 for _ in range(max_node + 10)]\\n    graph: dict[int, list[int]] = {\\n        1: [2, 3, 4],\\n        2: [5],\\n        3: [6, 7],\\n        4: [8],\\n        5: [9, 10],\\n        6: [11],\\n        7: [],\\n        8: [12, 13],\\n        9: [],\\n        10: [],\\n        11: [],\\n        12: [],\\n        13: [],\\n    }\\n    level, parent = breadth_first_search(level, parent, max_node, graph, 1)\\n    parent = create_sparse(max_node, parent)\\n    print(\\\"LCA of node 1 and 3 is: \\\", lowest_common_ancestor(1, 3, level, parent))\\n    print(\\\"LCA of node 5 and 6 is: \\\", lowest_common_ancestor(5, 6, level, parent))\\n    print(\\\"LCA of node 7 and 11 is: \\\", lowest_common_ancestor(7, 11, level, parent))\\n    print(\\\"LCA of node 6 and 7 is: \\\", lowest_common_ancestor(6, 7, level, parent))\\n    print(\\\"LCA of node 4 and 12 is: \\\", lowest_common_ancestor(4, 12, level, parent))\\n    print(\\\"LCA of node 8 and 8 is: \\\", lowest_common_ancestor(8, 8, level, parent))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "merge two binary trees": "\"#!/usr/local/bin/python3\\n\\\"\\\"\\\"\\nProblem Description: Given two binary tree, return the merged tree.\\nThe rule for merging is that if two nodes overlap, then put the value sum of\\nboth nodes to the new value of the merged node. Otherwise, the NOT null node\\nwill be used as the node of new tree.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\n\\nclass Node:\\n    \\\"\\\"\\\"\\n    A binary node has value variable and pointers to its left and right node.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, value: int = 0) -> None:\\n        self.value = value\\n        self.left: Node | None = None\\n        self.right: Node | None = None\\n\\n\\ndef merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:\\n    \\\"\\\"\\\"\\n    Returns root node of the merged tree.\\n\\n    >>> tree1 = Node(5)\\n    >>> tree1.left = Node(6)\\n    >>> tree1.right = Node(7)\\n    >>> tree1.left.left = Node(2)\\n    >>> tree2 = Node(4)\\n    >>> tree2.left = Node(5)\\n    >>> tree2.right = Node(8)\\n    >>> tree2.left.right = Node(1)\\n    >>> tree2.right.right = Node(4)\\n    >>> merged_tree = merge_two_binary_trees(tree1, tree2)\\n    >>> print_preorder(merged_tree)\\n    9\\n    11\\n    2\\n    1\\n    15\\n    4\\n    \\\"\\\"\\\"\\n    if tree1 is None:\\n        return tree2\\n    if tree2 is None:\\n        return tree1\\n\\n    tree1.value = tree1.value + tree2.value\\n    tree1.left = merge_two_binary_trees(tree1.left, tree2.left)\\n    tree1.right = merge_two_binary_trees(tree1.right, tree2.right)\\n    return tree1\\n\\n\\ndef print_preorder(root: Node | None) -> None:\\n    \\\"\\\"\\\"\\n    Print pre-order traversal of the tree.\\n\\n    >>> root = Node(1)\\n    >>> root.left = Node(2)\\n    >>> root.right = Node(3)\\n    >>> print_preorder(root)\\n    1\\n    2\\n    3\\n    >>> print_preorder(root.right)\\n    3\\n    \\\"\\\"\\\"\\n    if root:\\n        print(root.value)\\n        print_preorder(root.left)\\n        print_preorder(root.right)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    tree1 = Node(1)\\n    tree1.left = Node(2)\\n    tree1.right = Node(3)\\n    tree1.left.left = Node(4)\\n\\n    tree2 = Node(2)\\n    tree2.left = Node(4)\\n    tree2.right = Node(6)\\n    tree2.left.right = Node(9)\\n    tree2.right.right = Node(5)\\n\\n    print(\\\"Tree1 is: \\\")\\n    print_preorder(tree1)\\n    print(\\\"Tree2 is: \\\")\\n    print_preorder(tree2)\\n    merged_tree = merge_two_binary_trees(tree1, tree2)\\n    print(\\\"Merged Tree is: \\\")\\n    print_preorder(merged_tree)\\n\"",
    "non recursive segment tree": "\"\\\"\\\"\\\"\\nA non-recursive Segment Tree implementation with range query and single element update,\\nworks virtually with any list of the same type of elements with a \\\"commutative\\\"\\ncombiner.\\n\\nExplanation:\\nhttps://www.geeksforgeeks.org/iterative-segment-tree-range-minimum-query/\\nhttps://www.geeksforgeeks.org/segment-tree-efficient-implementation/\\n\\n>>> SegmentTree([1, 2, 3], lambda a, b: a + b).query(0, 2)\\n6\\n>>> SegmentTree([3, 1, 2], min).query(0, 2)\\n1\\n>>> SegmentTree([2, 3, 1], max).query(0, 2)\\n3\\n>>> st = SegmentTree([1, 5, 7, -1, 6], lambda a, b: a + b)\\n>>> st.update(1, -1)\\n>>> st.update(2, 3)\\n>>> st.query(1, 2)\\n2\\n>>> st.query(1, 1)\\n-1\\n>>> st.update(4, 1)\\n>>> st.query(3, 4)\\n0\\n>>> st = SegmentTree([[1, 2, 3], [3, 2, 1], [1, 1, 1]], lambda a, b: [a[i] + b[i] for i\\n...                                                                   in range(len(a))])\\n>>> st.query(0, 1)\\n[4, 4, 4]\\n>>> st.query(1, 2)\\n[4, 3, 2]\\n>>> st.update(1, [-1, -1, -1])\\n>>> st.query(1, 2)\\n[0, 0, 0]\\n>>> st.query(0, 2)\\n[1, 2, 3]\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom typing import Any, Callable, Generic, TypeVar\\n\\nT = TypeVar(\\\"T\\\")\\n\\n\\nclass SegmentTree(Generic[T]):\\n    def __init__(self, arr: list[T], fnc: Callable[[T, T], T]) -> None:\\n        \\\"\\\"\\\"\\n        Segment Tree constructor, it works just with commutative combiner.\\n        :param arr: list of elements for the segment tree\\n        :param fnc: commutative function for combine two elements\\n\\n        >>> SegmentTree(['a', 'b', 'c'], lambda a, b: f'{a}{b}').query(0, 2)\\n        'abc'\\n        >>> SegmentTree([(1, 2), (2, 3), (3, 4)],\\n        ...             lambda a, b: (a[0] + b[0], a[1] + b[1])).query(0, 2)\\n        (6, 9)\\n        \\\"\\\"\\\"\\n        any_type: Any | T = None\\n\\n        self.N: int = len(arr)\\n        self.st: list[T] = [any_type for _ in range(self.N)] + arr\\n        self.fn = fnc\\n        self.build()\\n\\n    def build(self) -> None:\\n        for p in range(self.N - 1, 0, -1):\\n            self.st[p] = self.fn(self.st[p * 2], self.st[p * 2 + 1])\\n\\n    def update(self, p: int, v: T) -> None:\\n        \\\"\\\"\\\"\\n        Update an element in log(N) time\\n        :param p: position to be update\\n        :param v: new value\\n\\n        >>> st = SegmentTree([3, 1, 2, 4], min)\\n        >>> st.query(0, 3)\\n        1\\n        >>> st.update(2, -1)\\n        >>> st.query(0, 3)\\n        -1\\n        \\\"\\\"\\\"\\n        p += self.N\\n        self.st[p] = v\\n        while p > 1:\\n            p = p // 2\\n            self.st[p] = self.fn(self.st[p * 2], self.st[p * 2 + 1])\\n\\n    def query(self, l: int, r: int) -> T | None:  # noqa: E741\\n        \\\"\\\"\\\"\\n        Get range query value in log(N) time\\n        :param l: left element index\\n        :param r: right element index\\n        :return: element combined in the range [l, r]\\n\\n        >>> st = SegmentTree([1, 2, 3, 4], lambda a, b: a + b)\\n        >>> st.query(0, 2)\\n        6\\n        >>> st.query(1, 2)\\n        5\\n        >>> st.query(0, 3)\\n        10\\n        >>> st.query(2, 3)\\n        7\\n        \\\"\\\"\\\"\\n        l, r = l + self.N, r + self.N  # noqa: E741\\n\\n        res: T | None = None\\n        while l <= r:  # noqa: E741\\n            if l % 2 == 1:\\n                res = self.st[l] if res is None else self.fn(res, self.st[l])\\n            if r % 2 == 0:\\n                res = self.st[r] if res is None else self.fn(res, self.st[r])\\n            l, r = (l + 1) // 2, (r - 1) // 2\\n        return res\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from functools import reduce\\n\\n    test_array = [1, 10, -2, 9, -3, 8, 4, -7, 5, 6, 11, -12]\\n\\n    test_updates = {\\n        0: 7,\\n        1: 2,\\n        2: 6,\\n        3: -14,\\n        4: 5,\\n        5: 4,\\n        6: 7,\\n        7: -10,\\n        8: 9,\\n        9: 10,\\n        10: 12,\\n        11: 1,\\n    }\\n\\n    min_segment_tree = SegmentTree(test_array, min)\\n    max_segment_tree = SegmentTree(test_array, max)\\n    sum_segment_tree = SegmentTree(test_array, lambda a, b: a + b)\\n\\n    def test_all_segments() -> None:\\n        \\\"\\\"\\\"\\n        Test all possible segments\\n        \\\"\\\"\\\"\\n        for i in range(len(test_array)):\\n            for j in range(i, len(test_array)):\\n                min_range = reduce(min, test_array[i : j + 1])\\n                max_range = reduce(max, test_array[i : j + 1])\\n                sum_range = reduce(lambda a, b: a + b, test_array[i : j + 1])\\n                assert min_range == min_segment_tree.query(i, j)\\n                assert max_range == max_segment_tree.query(i, j)\\n                assert sum_range == sum_segment_tree.query(i, j)\\n\\n    test_all_segments()\\n\\n    for index, value in test_updates.items():\\n        test_array[index] = value\\n        min_segment_tree.update(index, value)\\n        max_segment_tree.update(index, value)\\n        sum_segment_tree.update(index, value)\\n        test_all_segments()\\n\"",
    "number of possible binary trees": "\"\\\"\\\"\\\"\\nHey, we are going to find an exciting number called Catalan number which is use to find\\nthe number of possible binary search trees from tree of a given number of nodes.\\n\\nWe will use the formula: t(n) = SUMMATION(i = 1 to n)t(i-1)t(n-i)\\n\\nFurther details at Wikipedia: https://en.wikipedia.org/wiki/Catalan_number\\n\\\"\\\"\\\"\\n\\\"\\\"\\\"\\nOur Contribution:\\nBasically we Create the 2 function:\\n    1. catalan_number(node_count: int) -> int\\n        Returns the number of possible binary search trees for n nodes.\\n    2. binary_tree_count(node_count: int) -> int\\n        Returns the number of possible binary trees for n nodes.\\n\\\"\\\"\\\"\\n\\n\\ndef binomial_coefficient(n: int, k: int) -> int:\\n    \\\"\\\"\\\"\\n    Since Here we Find the Binomial Coefficient:\\n    https://en.wikipedia.org/wiki/Binomial_coefficient\\n    C(n,k) = n! / k!(n-k)!\\n    :param n: 2 times of Number of nodes\\n    :param k: Number of nodes\\n    :return:  Integer Value\\n\\n    >>> binomial_coefficient(4, 2)\\n    6\\n    \\\"\\\"\\\"\\n    result = 1  # To kept the Calculated Value\\n    # Since C(n, k) = C(n, n-k)\\n    if k > (n - k):\\n        k = n - k\\n    # Calculate C(n,k)\\n    for i in range(k):\\n        result *= n - i\\n        result //= i + 1\\n    return result\\n\\n\\ndef catalan_number(node_count: int) -> int:\\n    \\\"\\\"\\\"\\n    We can find Catalan number many ways but here we use Binomial Coefficient because it\\n    does the job in O(n)\\n\\n    return the Catalan number of n using 2nCn/(n+1).\\n    :param n: number of nodes\\n    :return: Catalan number of n nodes\\n\\n    >>> catalan_number(5)\\n    42\\n    >>> catalan_number(6)\\n    132\\n    \\\"\\\"\\\"\\n    return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)\\n\\n\\ndef factorial(n: int) -> int:\\n    \\\"\\\"\\\"\\n    Return the factorial of a number.\\n    :param n: Number to find the Factorial of.\\n    :return: Factorial of n.\\n\\n    >>> import math\\n    >>> all(factorial(i) == math.factorial(i) for i in range(10))\\n    True\\n    >>> factorial(-5)  # doctest: +ELLIPSIS\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: factorial() not defined for negative values\\n    \\\"\\\"\\\"\\n    if n < 0:\\n        raise ValueError(\\\"factorial() not defined for negative values\\\")\\n    result = 1\\n    for i in range(1, n + 1):\\n        result *= i\\n    return result\\n\\n\\ndef binary_tree_count(node_count: int) -> int:\\n    \\\"\\\"\\\"\\n    Return the number of possible of binary trees.\\n    :param n: number of nodes\\n    :return: Number of possible binary trees\\n\\n    >>> binary_tree_count(5)\\n    5040\\n    >>> binary_tree_count(6)\\n    95040\\n    \\\"\\\"\\\"\\n    return catalan_number(node_count) * factorial(node_count)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    node_count = int(input(\\\"Enter the number of nodes: \\\").strip() or 0)\\n    if node_count <= 0:\\n        raise ValueError(\\\"We need some nodes to work with.\\\")\\n    print(\\n        f\\\"Given {node_count} nodes, there are {binary_tree_count(node_count)} \\\"\\n        f\\\"binary trees and {catalan_number(node_count)} binary search trees.\\\"\\n    )\\n\"",
    "red black tree": "\"\\\"\\\"\\\"\\r\\npython/black : true\\r\\nflake8 : passed\\r\\n\\\"\\\"\\\"\\r\\nfrom __future__ import annotations\\r\\n\\r\\nfrom typing import Iterator\\r\\n\\r\\n\\r\\nclass RedBlackTree:\\r\\n    \\\"\\\"\\\"\\r\\n    A Red-Black tree, which is a self-balancing BST (binary search\\r\\n    tree).\\r\\n    This tree has similar performance to AVL trees, but the balancing is\\r\\n    less strict, so it will perform faster for writing/deleting nodes\\r\\n    and slower for reading in the average case, though, because they're\\r\\n    both balanced binary search trees, both will get the same asymptotic\\r\\n    performance.\\r\\n    To read more about them, https://en.wikipedia.org/wiki/Red–black_tree\\r\\n    Unless otherwise specified, all asymptotic runtimes are specified in\\r\\n    terms of the size of the tree.\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def __init__(\\r\\n        self,\\r\\n        label: int | None = None,\\r\\n        color: int = 0,\\r\\n        parent: RedBlackTree | None = None,\\r\\n        left: RedBlackTree | None = None,\\r\\n        right: RedBlackTree | None = None,\\r\\n    ) -> None:\\r\\n        \\\"\\\"\\\"Initialize a new Red-Black Tree node with the given values:\\r\\n        label: The value associated with this node\\r\\n        color: 0 if black, 1 if red\\r\\n        parent: The parent to this node\\r\\n        left: This node's left child\\r\\n        right: This node's right child\\r\\n        \\\"\\\"\\\"\\r\\n        self.label = label\\r\\n        self.parent = parent\\r\\n        self.left = left\\r\\n        self.right = right\\r\\n        self.color = color\\r\\n\\r\\n    # Here are functions which are specific to red-black trees\\r\\n\\r\\n    def rotate_left(self) -> RedBlackTree:\\r\\n        \\\"\\\"\\\"Rotate the subtree rooted at this node to the left and\\r\\n        returns the new root to this subtree.\\r\\n        Performing one rotation can be done in O(1).\\r\\n        \\\"\\\"\\\"\\r\\n        parent = self.parent\\r\\n        right = self.right\\r\\n        if right is None:\\r\\n            return self\\r\\n        self.right = right.left\\r\\n        if self.right:\\r\\n            self.right.parent = self\\r\\n        self.parent = right\\r\\n        right.left = self\\r\\n        if parent is not None:\\r\\n            if parent.left == self:\\r\\n                parent.left = right\\r\\n            else:\\r\\n                parent.right = right\\r\\n        right.parent = parent\\r\\n        return right\\r\\n\\r\\n    def rotate_right(self) -> RedBlackTree:\\r\\n        \\\"\\\"\\\"Rotate the subtree rooted at this node to the right and\\r\\n        returns the new root to this subtree.\\r\\n        Performing one rotation can be done in O(1).\\r\\n        \\\"\\\"\\\"\\r\\n        if self.left is None:\\r\\n            return self\\r\\n        parent = self.parent\\r\\n        left = self.left\\r\\n        self.left = left.right\\r\\n        if self.left:\\r\\n            self.left.parent = self\\r\\n        self.parent = left\\r\\n        left.right = self\\r\\n        if parent is not None:\\r\\n            if parent.right is self:\\r\\n                parent.right = left\\r\\n            else:\\r\\n                parent.left = left\\r\\n        left.parent = parent\\r\\n        return left\\r\\n\\r\\n    def insert(self, label: int) -> RedBlackTree:\\r\\n        \\\"\\\"\\\"Inserts label into the subtree rooted at self, performs any\\r\\n        rotations necessary to maintain balance, and then returns the\\r\\n        new root to this subtree (likely self).\\r\\n        This is guaranteed to run in O(log(n)) time.\\r\\n        \\\"\\\"\\\"\\r\\n        if self.label is None:\\r\\n            # Only possible with an empty tree\\r\\n            self.label = label\\r\\n            return self\\r\\n        if self.label == label:\\r\\n            return self\\r\\n        elif self.label > label:\\r\\n            if self.left:\\r\\n                self.left.insert(label)\\r\\n            else:\\r\\n                self.left = RedBlackTree(label, 1, self)\\r\\n                self.left._insert_repair()\\r\\n        else:\\r\\n            if self.right:\\r\\n                self.right.insert(label)\\r\\n            else:\\r\\n                self.right = RedBlackTree(label, 1, self)\\r\\n                self.right._insert_repair()\\r\\n        return self.parent or self\\r\\n\\r\\n    def _insert_repair(self) -> None:\\r\\n        \\\"\\\"\\\"Repair the coloring from inserting into a tree.\\\"\\\"\\\"\\r\\n        if self.parent is None:\\r\\n            # This node is the root, so it just needs to be black\\r\\n            self.color = 0\\r\\n        elif color(self.parent) == 0:\\r\\n            # If the parent is black, then it just needs to be red\\r\\n            self.color = 1\\r\\n        else:\\r\\n            uncle = self.parent.sibling\\r\\n            if color(uncle) == 0:\\r\\n                if self.is_left() and self.parent.is_right():\\r\\n                    self.parent.rotate_right()\\r\\n                    if self.right:\\r\\n                        self.right._insert_repair()\\r\\n                elif self.is_right() and self.parent.is_left():\\r\\n                    self.parent.rotate_left()\\r\\n                    if self.left:\\r\\n                        self.left._insert_repair()\\r\\n                elif self.is_left():\\r\\n                    if self.grandparent:\\r\\n                        self.grandparent.rotate_right()\\r\\n                        self.parent.color = 0\\r\\n                    if self.parent.right:\\r\\n                        self.parent.right.color = 1\\r\\n                else:\\r\\n                    if self.grandparent:\\r\\n                        self.grandparent.rotate_left()\\r\\n                        self.parent.color = 0\\r\\n                    if self.parent.left:\\r\\n                        self.parent.left.color = 1\\r\\n            else:\\r\\n                self.parent.color = 0\\r\\n                if uncle and self.grandparent:\\r\\n                    uncle.color = 0\\r\\n                    self.grandparent.color = 1\\r\\n                    self.grandparent._insert_repair()\\r\\n\\r\\n    def remove(self, label: int) -> RedBlackTree:\\r\\n        \\\"\\\"\\\"Remove label from this tree.\\\"\\\"\\\"\\r\\n        if self.label == label:\\r\\n            if self.left and self.right:\\r\\n                # It's easier to balance a node with at most one child,\\r\\n                # so we replace this node with the greatest one less than\\r\\n                # it and remove that.\\r\\n                value = self.left.get_max()\\r\\n                if value is not None:\\r\\n                    self.label = value\\r\\n                    self.left.remove(value)\\r\\n            else:\\r\\n                # This node has at most one non-None child, so we don't\\r\\n                # need to replace\\r\\n                child = self.left or self.right\\r\\n                if self.color == 1:\\r\\n                    # This node is red, and its child is black\\r\\n                    # The only way this happens to a node with one child\\r\\n                    # is if both children are None leaves.\\r\\n                    # We can just remove this node and call it a day.\\r\\n                    if self.parent:\\r\\n                        if self.is_left():\\r\\n                            self.parent.left = None\\r\\n                        else:\\r\\n                            self.parent.right = None\\r\\n                else:\\r\\n                    # The node is black\\r\\n                    if child is None:\\r\\n                        # This node and its child are black\\r\\n                        if self.parent is None:\\r\\n                            # The tree is now empty\\r\\n                            return RedBlackTree(None)\\r\\n                        else:\\r\\n                            self._remove_repair()\\r\\n                            if self.is_left():\\r\\n                                self.parent.left = None\\r\\n                            else:\\r\\n                                self.parent.right = None\\r\\n                            self.parent = None\\r\\n                    else:\\r\\n                        # This node is black and its child is red\\r\\n                        # Move the child node here and make it black\\r\\n                        self.label = child.label\\r\\n                        self.left = child.left\\r\\n                        self.right = child.right\\r\\n                        if self.left:\\r\\n                            self.left.parent = self\\r\\n                        if self.right:\\r\\n                            self.right.parent = self\\r\\n        elif self.label is not None and self.label > label:\\r\\n            if self.left:\\r\\n                self.left.remove(label)\\r\\n        else:\\r\\n            if self.right:\\r\\n                self.right.remove(label)\\r\\n        return self.parent or self\\r\\n\\r\\n    def _remove_repair(self) -> None:\\r\\n        \\\"\\\"\\\"Repair the coloring of the tree that may have been messed up.\\\"\\\"\\\"\\r\\n        if (\\r\\n            self.parent is None\\r\\n            or self.sibling is None\\r\\n            or self.parent.sibling is None\\r\\n            or self.grandparent is None\\r\\n        ):\\r\\n            return\\r\\n        if color(self.sibling) == 1:\\r\\n            self.sibling.color = 0\\r\\n            self.parent.color = 1\\r\\n            if self.is_left():\\r\\n                self.parent.rotate_left()\\r\\n            else:\\r\\n                self.parent.rotate_right()\\r\\n        if (\\r\\n            color(self.parent) == 0\\r\\n            and color(self.sibling) == 0\\r\\n            and color(self.sibling.left) == 0\\r\\n            and color(self.sibling.right) == 0\\r\\n        ):\\r\\n            self.sibling.color = 1\\r\\n            self.parent._remove_repair()\\r\\n            return\\r\\n        if (\\r\\n            color(self.parent) == 1\\r\\n            and color(self.sibling) == 0\\r\\n            and color(self.sibling.left) == 0\\r\\n            and color(self.sibling.right) == 0\\r\\n        ):\\r\\n            self.sibling.color = 1\\r\\n            self.parent.color = 0\\r\\n            return\\r\\n        if (\\r\\n            self.is_left()\\r\\n            and color(self.sibling) == 0\\r\\n            and color(self.sibling.right) == 0\\r\\n            and color(self.sibling.left) == 1\\r\\n        ):\\r\\n            self.sibling.rotate_right()\\r\\n            self.sibling.color = 0\\r\\n            if self.sibling.right:\\r\\n                self.sibling.right.color = 1\\r\\n        if (\\r\\n            self.is_right()\\r\\n            and color(self.sibling) == 0\\r\\n            and color(self.sibling.right) == 1\\r\\n            and color(self.sibling.left) == 0\\r\\n        ):\\r\\n            self.sibling.rotate_left()\\r\\n            self.sibling.color = 0\\r\\n            if self.sibling.left:\\r\\n                self.sibling.left.color = 1\\r\\n        if (\\r\\n            self.is_left()\\r\\n            and color(self.sibling) == 0\\r\\n            and color(self.sibling.right) == 1\\r\\n        ):\\r\\n            self.parent.rotate_left()\\r\\n            self.grandparent.color = self.parent.color\\r\\n            self.parent.color = 0\\r\\n            self.parent.sibling.color = 0\\r\\n        if (\\r\\n            self.is_right()\\r\\n            and color(self.sibling) == 0\\r\\n            and color(self.sibling.left) == 1\\r\\n        ):\\r\\n            self.parent.rotate_right()\\r\\n            self.grandparent.color = self.parent.color\\r\\n            self.parent.color = 0\\r\\n            self.parent.sibling.color = 0\\r\\n\\r\\n    def check_color_properties(self) -> bool:\\r\\n        \\\"\\\"\\\"Check the coloring of the tree, and return True iff the tree\\r\\n        is colored in a way which matches these five properties:\\r\\n        (wording stolen from wikipedia article)\\r\\n         1. Each node is either red or black.\\r\\n         2. The root node is black.\\r\\n         3. All leaves are black.\\r\\n         4. If a node is red, then both its children are black.\\r\\n         5. Every path from any node to all of its descendent NIL nodes\\r\\n            has the same number of black nodes.\\r\\n        This function runs in O(n) time, because properties 4 and 5 take\\r\\n        that long to check.\\r\\n        \\\"\\\"\\\"\\r\\n        # I assume property 1 to hold because there is nothing that can\\r\\n        # make the color be anything other than 0 or 1.\\r\\n        # Property 2\\r\\n        if self.color:\\r\\n            # The root was red\\r\\n            print(\\\"Property 2\\\")\\r\\n            return False\\r\\n        # Property 3 does not need to be checked, because None is assumed\\r\\n        # to be black and is all the leaves.\\r\\n        # Property 4\\r\\n        if not self.check_coloring():\\r\\n            print(\\\"Property 4\\\")\\r\\n            return False\\r\\n        # Property 5\\r\\n        if self.black_height() is None:\\r\\n            print(\\\"Property 5\\\")\\r\\n            return False\\r\\n        # All properties were met\\r\\n        return True\\r\\n\\r\\n    def check_coloring(self) -> bool:\\r\\n        \\\"\\\"\\\"A helper function to recursively check Property 4 of a\\r\\n        Red-Black Tree. See check_color_properties for more info.\\r\\n        \\\"\\\"\\\"\\r\\n        if self.color == 1:\\r\\n            if color(self.left) == 1 or color(self.right) == 1:\\r\\n                return False\\r\\n        if self.left and not self.left.check_coloring():\\r\\n            return False\\r\\n        if self.right and not self.right.check_coloring():\\r\\n            return False\\r\\n        return True\\r\\n\\r\\n    def black_height(self) -> int | None:\\r\\n        \\\"\\\"\\\"Returns the number of black nodes from this node to the\\r\\n        leaves of the tree, or None if there isn't one such value (the\\r\\n        tree is color incorrectly).\\r\\n        \\\"\\\"\\\"\\r\\n        if self is None or self.left is None or self.right is None:\\r\\n            # If we're already at a leaf, there is no path\\r\\n            return 1\\r\\n        left = RedBlackTree.black_height(self.left)\\r\\n        right = RedBlackTree.black_height(self.right)\\r\\n        if left is None or right is None:\\r\\n            # There are issues with coloring below children nodes\\r\\n            return None\\r\\n        if left != right:\\r\\n            # The two children have unequal depths\\r\\n            return None\\r\\n        # Return the black depth of children, plus one if this node is\\r\\n        # black\\r\\n        return left + (1 - self.color)\\r\\n\\r\\n    # Here are functions which are general to all binary search trees\\r\\n\\r\\n    def __contains__(self, label: int) -> bool:\\r\\n        \\\"\\\"\\\"Search through the tree for label, returning True iff it is\\r\\n        found somewhere in the tree.\\r\\n        Guaranteed to run in O(log(n)) time.\\r\\n        \\\"\\\"\\\"\\r\\n        return self.search(label) is not None\\r\\n\\r\\n    def search(self, label: int) -> RedBlackTree | None:\\r\\n        \\\"\\\"\\\"Search through the tree for label, returning its node if\\r\\n        it's found, and None otherwise.\\r\\n        This method is guaranteed to run in O(log(n)) time.\\r\\n        \\\"\\\"\\\"\\r\\n        if self.label == label:\\r\\n            return self\\r\\n        elif self.label is not None and label > self.label:\\r\\n            if self.right is None:\\r\\n                return None\\r\\n            else:\\r\\n                return self.right.search(label)\\r\\n        else:\\r\\n            if self.left is None:\\r\\n                return None\\r\\n            else:\\r\\n                return self.left.search(label)\\r\\n\\r\\n    def floor(self, label: int) -> int | None:\\r\\n        \\\"\\\"\\\"Returns the largest element in this tree which is at most label.\\r\\n        This method is guaranteed to run in O(log(n)) time.\\\"\\\"\\\"\\r\\n        if self.label == label:\\r\\n            return self.label\\r\\n        elif self.label is not None and self.label > label:\\r\\n            if self.left:\\r\\n                return self.left.floor(label)\\r\\n            else:\\r\\n                return None\\r\\n        else:\\r\\n            if self.right:\\r\\n                attempt = self.right.floor(label)\\r\\n                if attempt is not None:\\r\\n                    return attempt\\r\\n            return self.label\\r\\n\\r\\n    def ceil(self, label: int) -> int | None:\\r\\n        \\\"\\\"\\\"Returns the smallest element in this tree which is at least label.\\r\\n        This method is guaranteed to run in O(log(n)) time.\\r\\n        \\\"\\\"\\\"\\r\\n        if self.label == label:\\r\\n            return self.label\\r\\n        elif self.label is not None and self.label < label:\\r\\n            if self.right:\\r\\n                return self.right.ceil(label)\\r\\n            else:\\r\\n                return None\\r\\n        else:\\r\\n            if self.left:\\r\\n                attempt = self.left.ceil(label)\\r\\n                if attempt is not None:\\r\\n                    return attempt\\r\\n            return self.label\\r\\n\\r\\n    def get_max(self) -> int | None:\\r\\n        \\\"\\\"\\\"Returns the largest element in this tree.\\r\\n        This method is guaranteed to run in O(log(n)) time.\\r\\n        \\\"\\\"\\\"\\r\\n        if self.right:\\r\\n            # Go as far right as possible\\r\\n            return self.right.get_max()\\r\\n        else:\\r\\n            return self.label\\r\\n\\r\\n    def get_min(self) -> int | None:\\r\\n        \\\"\\\"\\\"Returns the smallest element in this tree.\\r\\n        This method is guaranteed to run in O(log(n)) time.\\r\\n        \\\"\\\"\\\"\\r\\n        if self.left:\\r\\n            # Go as far left as possible\\r\\n            return self.left.get_min()\\r\\n        else:\\r\\n            return self.label\\r\\n\\r\\n    @property\\r\\n    def grandparent(self) -> RedBlackTree | None:\\r\\n        \\\"\\\"\\\"Get the current node's grandparent, or None if it doesn't exist.\\\"\\\"\\\"\\r\\n        if self.parent is None:\\r\\n            return None\\r\\n        else:\\r\\n            return self.parent.parent\\r\\n\\r\\n    @property\\r\\n    def sibling(self) -> RedBlackTree | None:\\r\\n        \\\"\\\"\\\"Get the current node's sibling, or None if it doesn't exist.\\\"\\\"\\\"\\r\\n        if self.parent is None:\\r\\n            return None\\r\\n        elif self.parent.left is self:\\r\\n            return self.parent.right\\r\\n        else:\\r\\n            return self.parent.left\\r\\n\\r\\n    def is_left(self) -> bool:\\r\\n        \\\"\\\"\\\"Returns true iff this node is the left child of its parent.\\\"\\\"\\\"\\r\\n        if self.parent is None:\\r\\n            return False\\r\\n        return self.parent.left is self.parent.left is self\\r\\n\\r\\n    def is_right(self) -> bool:\\r\\n        \\\"\\\"\\\"Returns true iff this node is the right child of its parent.\\\"\\\"\\\"\\r\\n        if self.parent is None:\\r\\n            return False\\r\\n        return self.parent.right is self\\r\\n\\r\\n    def __bool__(self) -> bool:\\r\\n        return True\\r\\n\\r\\n    def __len__(self) -> int:\\r\\n        \\\"\\\"\\\"\\r\\n        Return the number of nodes in this tree.\\r\\n        \\\"\\\"\\\"\\r\\n        ln = 1\\r\\n        if self.left:\\r\\n            ln += len(self.left)\\r\\n        if self.right:\\r\\n            ln += len(self.right)\\r\\n        return ln\\r\\n\\r\\n    def preorder_traverse(self) -> Iterator[int | None]:\\r\\n        yield self.label\\r\\n        if self.left:\\r\\n            yield from self.left.preorder_traverse()\\r\\n        if self.right:\\r\\n            yield from self.right.preorder_traverse()\\r\\n\\r\\n    def inorder_traverse(self) -> Iterator[int | None]:\\r\\n        if self.left:\\r\\n            yield from self.left.inorder_traverse()\\r\\n        yield self.label\\r\\n        if self.right:\\r\\n            yield from self.right.inorder_traverse()\\r\\n\\r\\n    def postorder_traverse(self) -> Iterator[int | None]:\\r\\n        if self.left:\\r\\n            yield from self.left.postorder_traverse()\\r\\n        if self.right:\\r\\n            yield from self.right.postorder_traverse()\\r\\n        yield self.label\\r\\n\\r\\n    def __repr__(self) -> str:\\r\\n        from pprint import pformat\\r\\n\\r\\n        if self.left is None and self.right is None:\\r\\n            return f\\\"'{self.label} {(self.color and 'red') or 'blk'}'\\\"\\r\\n        return pformat(\\r\\n            {\\r\\n                f\\\"{self.label} {(self.color and 'red') or 'blk'}\\\": (\\r\\n                    self.left,\\r\\n                    self.right,\\r\\n                )\\r\\n            },\\r\\n            indent=1,\\r\\n        )\\r\\n\\r\\n    def __eq__(self, other: object) -> bool:\\r\\n        \\\"\\\"\\\"Test if two trees are equal.\\\"\\\"\\\"\\r\\n        if not isinstance(other, RedBlackTree):\\r\\n            return NotImplemented\\r\\n        if self.label == other.label:\\r\\n            return self.left == other.left and self.right == other.right\\r\\n        else:\\r\\n            return False\\r\\n\\r\\n\\r\\ndef color(node: RedBlackTree | None) -> int:\\r\\n    \\\"\\\"\\\"Returns the color of a node, allowing for None leaves.\\\"\\\"\\\"\\r\\n    if node is None:\\r\\n        return 0\\r\\n    else:\\r\\n        return node.color\\r\\n\\r\\n\\r\\n\\\"\\\"\\\"\\r\\nCode for testing the various\\r\\nfunctions of the red-black tree.\\r\\n\\\"\\\"\\\"\\r\\n\\r\\n\\r\\ndef test_rotations() -> bool:\\r\\n    \\\"\\\"\\\"Test that the rotate_left and rotate_right functions work.\\\"\\\"\\\"\\r\\n    # Make a tree to test on\\r\\n    tree = RedBlackTree(0)\\r\\n    tree.left = RedBlackTree(-10, parent=tree)\\r\\n    tree.right = RedBlackTree(10, parent=tree)\\r\\n    tree.left.left = RedBlackTree(-20, parent=tree.left)\\r\\n    tree.left.right = RedBlackTree(-5, parent=tree.left)\\r\\n    tree.right.left = RedBlackTree(5, parent=tree.right)\\r\\n    tree.right.right = RedBlackTree(20, parent=tree.right)\\r\\n    # Make the right rotation\\r\\n    left_rot = RedBlackTree(10)\\r\\n    left_rot.left = RedBlackTree(0, parent=left_rot)\\r\\n    left_rot.left.left = RedBlackTree(-10, parent=left_rot.left)\\r\\n    left_rot.left.right = RedBlackTree(5, parent=left_rot.left)\\r\\n    left_rot.left.left.left = RedBlackTree(-20, parent=left_rot.left.left)\\r\\n    left_rot.left.left.right = RedBlackTree(-5, parent=left_rot.left.left)\\r\\n    left_rot.right = RedBlackTree(20, parent=left_rot)\\r\\n    tree = tree.rotate_left()\\r\\n    if tree != left_rot:\\r\\n        return False\\r\\n    tree = tree.rotate_right()\\r\\n    tree = tree.rotate_right()\\r\\n    # Make the left rotation\\r\\n    right_rot = RedBlackTree(-10)\\r\\n    right_rot.left = RedBlackTree(-20, parent=right_rot)\\r\\n    right_rot.right = RedBlackTree(0, parent=right_rot)\\r\\n    right_rot.right.left = RedBlackTree(-5, parent=right_rot.right)\\r\\n    right_rot.right.right = RedBlackTree(10, parent=right_rot.right)\\r\\n    right_rot.right.right.left = RedBlackTree(5, parent=right_rot.right.right)\\r\\n    right_rot.right.right.right = RedBlackTree(20, parent=right_rot.right.right)\\r\\n    if tree != right_rot:\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n\\r\\ndef test_insertion_speed() -> bool:\\r\\n    \\\"\\\"\\\"Test that the tree balances inserts to O(log(n)) by doing a lot\\r\\n    of them.\\r\\n    \\\"\\\"\\\"\\r\\n    tree = RedBlackTree(-1)\\r\\n    for i in range(300000):\\r\\n        tree = tree.insert(i)\\r\\n    return True\\r\\n\\r\\n\\r\\ndef test_insert() -> bool:\\r\\n    \\\"\\\"\\\"Test the insert() method of the tree correctly balances, colors,\\r\\n    and inserts.\\r\\n    \\\"\\\"\\\"\\r\\n    tree = RedBlackTree(0)\\r\\n    tree.insert(8)\\r\\n    tree.insert(-8)\\r\\n    tree.insert(4)\\r\\n    tree.insert(12)\\r\\n    tree.insert(10)\\r\\n    tree.insert(11)\\r\\n    ans = RedBlackTree(0, 0)\\r\\n    ans.left = RedBlackTree(-8, 0, ans)\\r\\n    ans.right = RedBlackTree(8, 1, ans)\\r\\n    ans.right.left = RedBlackTree(4, 0, ans.right)\\r\\n    ans.right.right = RedBlackTree(11, 0, ans.right)\\r\\n    ans.right.right.left = RedBlackTree(10, 1, ans.right.right)\\r\\n    ans.right.right.right = RedBlackTree(12, 1, ans.right.right)\\r\\n    return tree == ans\\r\\n\\r\\n\\r\\ndef test_insert_and_search() -> bool:\\r\\n    \\\"\\\"\\\"Tests searching through the tree for values.\\\"\\\"\\\"\\r\\n    tree = RedBlackTree(0)\\r\\n    tree.insert(8)\\r\\n    tree.insert(-8)\\r\\n    tree.insert(4)\\r\\n    tree.insert(12)\\r\\n    tree.insert(10)\\r\\n    tree.insert(11)\\r\\n    if 5 in tree or -6 in tree or -10 in tree or 13 in tree:\\r\\n        # Found something not in there\\r\\n        return False\\r\\n    if not (11 in tree and 12 in tree and -8 in tree and 0 in tree):\\r\\n        # Didn't find something in there\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n\\r\\ndef test_insert_delete() -> bool:\\r\\n    \\\"\\\"\\\"Test the insert() and delete() method of the tree, verifying the\\r\\n    insertion and removal of elements, and the balancing of the tree.\\r\\n    \\\"\\\"\\\"\\r\\n    tree = RedBlackTree(0)\\r\\n    tree = tree.insert(-12)\\r\\n    tree = tree.insert(8)\\r\\n    tree = tree.insert(-8)\\r\\n    tree = tree.insert(15)\\r\\n    tree = tree.insert(4)\\r\\n    tree = tree.insert(12)\\r\\n    tree = tree.insert(10)\\r\\n    tree = tree.insert(9)\\r\\n    tree = tree.insert(11)\\r\\n    tree = tree.remove(15)\\r\\n    tree = tree.remove(-12)\\r\\n    tree = tree.remove(9)\\r\\n    if not tree.check_color_properties():\\r\\n        return False\\r\\n    if list(tree.inorder_traverse()) != [-8, 0, 4, 8, 10, 11, 12]:\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n\\r\\ndef test_floor_ceil() -> bool:\\r\\n    \\\"\\\"\\\"Tests the floor and ceiling functions in the tree.\\\"\\\"\\\"\\r\\n    tree = RedBlackTree(0)\\r\\n    tree.insert(-16)\\r\\n    tree.insert(16)\\r\\n    tree.insert(8)\\r\\n    tree.insert(24)\\r\\n    tree.insert(20)\\r\\n    tree.insert(22)\\r\\n    tuples = [(-20, None, -16), (-10, -16, 0), (8, 8, 8), (50, 24, None)]\\r\\n    for val, floor, ceil in tuples:\\r\\n        if tree.floor(val) != floor or tree.ceil(val) != ceil:\\r\\n            return False\\r\\n    return True\\r\\n\\r\\n\\r\\ndef test_min_max() -> bool:\\r\\n    \\\"\\\"\\\"Tests the min and max functions in the tree.\\\"\\\"\\\"\\r\\n    tree = RedBlackTree(0)\\r\\n    tree.insert(-16)\\r\\n    tree.insert(16)\\r\\n    tree.insert(8)\\r\\n    tree.insert(24)\\r\\n    tree.insert(20)\\r\\n    tree.insert(22)\\r\\n    if tree.get_max() != 22 or tree.get_min() != -16:\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n\\r\\ndef test_tree_traversal() -> bool:\\r\\n    \\\"\\\"\\\"Tests the three different tree traversal functions.\\\"\\\"\\\"\\r\\n    tree = RedBlackTree(0)\\r\\n    tree = tree.insert(-16)\\r\\n    tree.insert(16)\\r\\n    tree.insert(8)\\r\\n    tree.insert(24)\\r\\n    tree.insert(20)\\r\\n    tree.insert(22)\\r\\n    if list(tree.inorder_traverse()) != [-16, 0, 8, 16, 20, 22, 24]:\\r\\n        return False\\r\\n    if list(tree.preorder_traverse()) != [0, -16, 16, 8, 22, 20, 24]:\\r\\n        return False\\r\\n    if list(tree.postorder_traverse()) != [-16, 8, 20, 24, 22, 16, 0]:\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n\\r\\ndef test_tree_chaining() -> bool:\\r\\n    \\\"\\\"\\\"Tests the three different tree chaining functions.\\\"\\\"\\\"\\r\\n    tree = RedBlackTree(0)\\r\\n    tree = tree.insert(-16).insert(16).insert(8).insert(24).insert(20).insert(22)\\r\\n    if list(tree.inorder_traverse()) != [-16, 0, 8, 16, 20, 22, 24]:\\r\\n        return False\\r\\n    if list(tree.preorder_traverse()) != [0, -16, 16, 8, 22, 20, 24]:\\r\\n        return False\\r\\n    if list(tree.postorder_traverse()) != [-16, 8, 20, 24, 22, 16, 0]:\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n\\r\\ndef print_results(msg: str, passes: bool) -> None:\\r\\n    print(str(msg), \\\"works!\\\" if passes else \\\"doesn't work :(\\\")\\r\\n\\r\\n\\r\\ndef pytests() -> None:\\r\\n    assert test_rotations()\\r\\n    assert test_insert()\\r\\n    assert test_insert_and_search()\\r\\n    assert test_insert_delete()\\r\\n    assert test_floor_ceil()\\r\\n    assert test_tree_traversal()\\r\\n    assert test_tree_chaining()\\r\\n\\r\\n\\r\\ndef main() -> None:\\r\\n    \\\"\\\"\\\"\\r\\n    >>> pytests()\\r\\n    \\\"\\\"\\\"\\r\\n    print_results(\\\"Rotating right and left\\\", test_rotations())\\r\\n    print_results(\\\"Inserting\\\", test_insert())\\r\\n    print_results(\\\"Searching\\\", test_insert_and_search())\\r\\n    print_results(\\\"Deleting\\\", test_insert_delete())\\r\\n    print_results(\\\"Floor and ceil\\\", test_floor_ceil())\\r\\n    print_results(\\\"Tree traversal\\\", test_tree_traversal())\\r\\n    print_results(\\\"Tree traversal\\\", test_tree_chaining())\\r\\n    print(\\\"Testing tree balancing...\\\")\\r\\n    print(\\\"This should only be a few seconds.\\\")\\r\\n    test_insertion_speed()\\r\\n    print(\\\"Done!\\\")\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    main()\\r\\n\"",
    "segment tree": "\"import math\\n\\n\\nclass SegmentTree:\\n    def __init__(self, A):\\n        self.N = len(A)\\n        self.st = [0] * (\\n            4 * self.N\\n        )  # approximate the overall size of segment tree with array N\\n        self.build(1, 0, self.N - 1)\\n\\n    def left(self, idx):\\n        return idx * 2\\n\\n    def right(self, idx):\\n        return idx * 2 + 1\\n\\n    def build(self, idx, l, r):  # noqa: E741\\n        if l == r:  # noqa: E741\\n            self.st[idx] = A[l]\\n        else:\\n            mid = (l + r) // 2\\n            self.build(self.left(idx), l, mid)\\n            self.build(self.right(idx), mid + 1, r)\\n            self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])\\n\\n    def update(self, a, b, val):\\n        return self.update_recursive(1, 0, self.N - 1, a - 1, b - 1, val)\\n\\n    def update_recursive(self, idx, l, r, a, b, val):  # noqa: E741\\n        \\\"\\\"\\\"\\n        update(1, 1, N, a, b, v) for update val v to [a,b]\\n        \\\"\\\"\\\"\\n        if r < a or l > b:\\n            return True\\n        if l == r:  # noqa: E741\\n            self.st[idx] = val\\n            return True\\n        mid = (l + r) // 2\\n        self.update_recursive(self.left(idx), l, mid, a, b, val)\\n        self.update_recursive(self.right(idx), mid + 1, r, a, b, val)\\n        self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])\\n        return True\\n\\n    def query(self, a, b):\\n        return self.query_recursive(1, 0, self.N - 1, a - 1, b - 1)\\n\\n    def query_recursive(self, idx, l, r, a, b):  # noqa: E741\\n        \\\"\\\"\\\"\\n        query(1, 1, N, a, b) for query max of [a,b]\\n        \\\"\\\"\\\"\\n        if r < a or l > b:\\n            return -math.inf\\n        if l >= a and r <= b:  # noqa: E741\\n            return self.st[idx]\\n        mid = (l + r) // 2\\n        q1 = self.query_recursive(self.left(idx), l, mid, a, b)\\n        q2 = self.query_recursive(self.right(idx), mid + 1, r, a, b)\\n        return max(q1, q2)\\n\\n    def showData(self):\\n        showList = []\\n        for i in range(1, N + 1):\\n            showList += [self.query(i, i)]\\n        print(showList)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]\\n    N = 15\\n    segt = SegmentTree(A)\\n    print(segt.query(4, 6))\\n    print(segt.query(7, 11))\\n    print(segt.query(7, 12))\\n    segt.update(1, 3, 111)\\n    print(segt.query(1, 15))\\n    segt.update(7, 8, 235)\\n    segt.showData()\\n\"",
    "segment tree other": "\"\\\"\\\"\\\"\\nSegment_tree creates a segment tree with a given array and function,\\nallowing queries to be done later in log(N) time\\nfunction takes 2 values and returns a same type value\\n\\\"\\\"\\\"\\nfrom collections.abc import Sequence\\nfrom queue import Queue\\n\\n\\nclass SegmentTreeNode:\\n    def __init__(self, start, end, val, left=None, right=None):\\n        self.start = start\\n        self.end = end\\n        self.val = val\\n        self.mid = (start + end) // 2\\n        self.left = left\\n        self.right = right\\n\\n    def __str__(self):\\n        return f\\\"val: {self.val}, start: {self.start}, end: {self.end}\\\"\\n\\n\\nclass SegmentTree:\\n    \\\"\\\"\\\"\\n    >>> import operator\\n    >>> num_arr = SegmentTree([2, 1, 5, 3, 4], operator.add)\\n    >>> for node in num_arr.traverse():\\n    ...     print(node)\\n    ...\\n    val: 15, start: 0, end: 4\\n    val: 8, start: 0, end: 2\\n    val: 7, start: 3, end: 4\\n    val: 3, start: 0, end: 1\\n    val: 5, start: 2, end: 2\\n    val: 3, start: 3, end: 3\\n    val: 4, start: 4, end: 4\\n    val: 2, start: 0, end: 0\\n    val: 1, start: 1, end: 1\\n    >>>\\n    >>> num_arr.update(1, 5)\\n    >>> for node in num_arr.traverse():\\n    ...     print(node)\\n    ...\\n    val: 19, start: 0, end: 4\\n    val: 12, start: 0, end: 2\\n    val: 7, start: 3, end: 4\\n    val: 7, start: 0, end: 1\\n    val: 5, start: 2, end: 2\\n    val: 3, start: 3, end: 3\\n    val: 4, start: 4, end: 4\\n    val: 2, start: 0, end: 0\\n    val: 5, start: 1, end: 1\\n    >>>\\n    >>> num_arr.query_range(3, 4)\\n    7\\n    >>> num_arr.query_range(2, 2)\\n    5\\n    >>> num_arr.query_range(1, 3)\\n    13\\n    >>>\\n    >>> max_arr = SegmentTree([2, 1, 5, 3, 4], max)\\n    >>> for node in max_arr.traverse():\\n    ...     print(node)\\n    ...\\n    val: 5, start: 0, end: 4\\n    val: 5, start: 0, end: 2\\n    val: 4, start: 3, end: 4\\n    val: 2, start: 0, end: 1\\n    val: 5, start: 2, end: 2\\n    val: 3, start: 3, end: 3\\n    val: 4, start: 4, end: 4\\n    val: 2, start: 0, end: 0\\n    val: 1, start: 1, end: 1\\n    >>>\\n    >>> max_arr.update(1, 5)\\n    >>> for node in max_arr.traverse():\\n    ...     print(node)\\n    ...\\n    val: 5, start: 0, end: 4\\n    val: 5, start: 0, end: 2\\n    val: 4, start: 3, end: 4\\n    val: 5, start: 0, end: 1\\n    val: 5, start: 2, end: 2\\n    val: 3, start: 3, end: 3\\n    val: 4, start: 4, end: 4\\n    val: 2, start: 0, end: 0\\n    val: 5, start: 1, end: 1\\n    >>>\\n    >>> max_arr.query_range(3, 4)\\n    4\\n    >>> max_arr.query_range(2, 2)\\n    5\\n    >>> max_arr.query_range(1, 3)\\n    5\\n    >>>\\n    >>> min_arr = SegmentTree([2, 1, 5, 3, 4], min)\\n    >>> for node in min_arr.traverse():\\n    ...     print(node)\\n    ...\\n    val: 1, start: 0, end: 4\\n    val: 1, start: 0, end: 2\\n    val: 3, start: 3, end: 4\\n    val: 1, start: 0, end: 1\\n    val: 5, start: 2, end: 2\\n    val: 3, start: 3, end: 3\\n    val: 4, start: 4, end: 4\\n    val: 2, start: 0, end: 0\\n    val: 1, start: 1, end: 1\\n    >>>\\n    >>> min_arr.update(1, 5)\\n    >>> for node in min_arr.traverse():\\n    ...     print(node)\\n    ...\\n    val: 2, start: 0, end: 4\\n    val: 2, start: 0, end: 2\\n    val: 3, start: 3, end: 4\\n    val: 2, start: 0, end: 1\\n    val: 5, start: 2, end: 2\\n    val: 3, start: 3, end: 3\\n    val: 4, start: 4, end: 4\\n    val: 2, start: 0, end: 0\\n    val: 5, start: 1, end: 1\\n    >>>\\n    >>> min_arr.query_range(3, 4)\\n    3\\n    >>> min_arr.query_range(2, 2)\\n    5\\n    >>> min_arr.query_range(1, 3)\\n    3\\n    >>>\\n\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, collection: Sequence, function):\\n        self.collection = collection\\n        self.fn = function\\n        if self.collection:\\n            self.root = self._build_tree(0, len(collection) - 1)\\n\\n    def update(self, i, val):\\n        \\\"\\\"\\\"\\n        Update an element in log(N) time\\n        :param i: position to be update\\n        :param val: new value\\n        >>> import operator\\n        >>> num_arr = SegmentTree([2, 1, 5, 3, 4], operator.add)\\n        >>> num_arr.update(1, 5)\\n        >>> num_arr.query_range(1, 3)\\n        13\\n        \\\"\\\"\\\"\\n        self._update_tree(self.root, i, val)\\n\\n    def query_range(self, i, j):\\n        \\\"\\\"\\\"\\n        Get range query value in log(N) time\\n        :param i: left element index\\n        :param j: right element index\\n        :return: element combined in the range [i, j]\\n        >>> import operator\\n        >>> num_arr = SegmentTree([2, 1, 5, 3, 4], operator.add)\\n        >>> num_arr.update(1, 5)\\n        >>> num_arr.query_range(3, 4)\\n        7\\n        >>> num_arr.query_range(2, 2)\\n        5\\n        >>> num_arr.query_range(1, 3)\\n        13\\n        >>>\\n        \\\"\\\"\\\"\\n        return self._query_range(self.root, i, j)\\n\\n    def _build_tree(self, start, end):\\n        if start == end:\\n            return SegmentTreeNode(start, end, self.collection[start])\\n        mid = (start + end) // 2\\n        left = self._build_tree(start, mid)\\n        right = self._build_tree(mid + 1, end)\\n        return SegmentTreeNode(start, end, self.fn(left.val, right.val), left, right)\\n\\n    def _update_tree(self, node, i, val):\\n        if node.start == i and node.end == i:\\n            node.val = val\\n            return\\n        if i <= node.mid:\\n            self._update_tree(node.left, i, val)\\n        else:\\n            self._update_tree(node.right, i, val)\\n        node.val = self.fn(node.left.val, node.right.val)\\n\\n    def _query_range(self, node, i, j):\\n        if node.start == i and node.end == j:\\n            return node.val\\n\\n        if i <= node.mid:\\n            if j <= node.mid:\\n                # range in left child tree\\n                return self._query_range(node.left, i, j)\\n            else:\\n                # range in left child tree and right child tree\\n                return self.fn(\\n                    self._query_range(node.left, i, node.mid),\\n                    self._query_range(node.right, node.mid + 1, j),\\n                )\\n        else:\\n            # range in right child tree\\n            return self._query_range(node.right, i, j)\\n\\n    def traverse(self):\\n        if self.root is not None:\\n            queue = Queue()\\n            queue.put(self.root)\\n            while not queue.empty():\\n                node = queue.get()\\n                yield node\\n\\n                if node.left is not None:\\n                    queue.put(node.left)\\n\\n                if node.right is not None:\\n                    queue.put(node.right)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import operator\\n\\n    for fn in [operator.add, max, min]:\\n        print(\\\"*\\\" * 50)\\n        arr = SegmentTree([2, 1, 5, 3, 4], fn)\\n        for node in arr.traverse():\\n            print(node)\\n        print()\\n\\n        arr.update(1, 5)\\n        for node in arr.traverse():\\n            print(node)\\n        print()\\n\\n        print(arr.query_range(3, 4))  # 7\\n        print(arr.query_range(2, 2))  # 5\\n        print(arr.query_range(1, 3))  # 13\\n        print()\\n\"",
    "treap": "\"from __future__ import annotations\\n\\nfrom random import random\\n\\n\\nclass Node:\\n    \\\"\\\"\\\"\\n    Treap's node\\n    Treap is a binary tree by value and heap by priority\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, value: int | None = None):\\n        self.value = value\\n        self.prior = random()\\n        self.left: Node | None = None\\n        self.right: Node | None = None\\n\\n    def __repr__(self) -> str:\\n        from pprint import pformat\\n\\n        if self.left is None and self.right is None:\\n            return f\\\"'{self.value}: {self.prior:.5}'\\\"\\n        else:\\n            return pformat(\\n                {f\\\"{self.value}: {self.prior:.5}\\\": (self.left, self.right)}, indent=1\\n            )\\n\\n    def __str__(self) -> str:\\n        value = str(self.value) + \\\" \\\"\\n        left = str(self.left or \\\"\\\")\\n        right = str(self.right or \\\"\\\")\\n        return value + left + right\\n\\n\\ndef split(root: Node | None, value: int) -> tuple[Node | None, Node | None]:\\n    \\\"\\\"\\\"\\n    We split current tree into 2 trees with value:\\n\\n    Left tree contains all values less than split value.\\n    Right tree contains all values greater or equal, than split value\\n    \\\"\\\"\\\"\\n    if root is None:  # None tree is split into 2 Nones\\n        return None, None\\n    elif root.value is None:\\n        return None, None\\n    else:\\n        if value < root.value:\\n            \\\"\\\"\\\"\\n            Right tree's root will be current node.\\n            Now we split(with the same value) current node's left son\\n            Left tree: left part of that split\\n            Right tree's left son: right part of that split\\n            \\\"\\\"\\\"\\n            left, root.left = split(root.left, value)\\n            return left, root\\n        else:\\n            \\\"\\\"\\\"\\n            Just symmetric to previous case\\n            \\\"\\\"\\\"\\n            root.right, right = split(root.right, value)\\n            return root, right\\n\\n\\ndef merge(left: Node | None, right: Node | None) -> Node | None:\\n    \\\"\\\"\\\"\\n    We merge 2 trees into one.\\n    Note: all left tree's values must be less than all right tree's\\n    \\\"\\\"\\\"\\n    if (not left) or (not right):  # If one node is None, return the other\\n        return left or right\\n    elif left.prior < right.prior:\\n        \\\"\\\"\\\"\\n        Left will be root because it has more priority\\n        Now we need to merge left's right son and right tree\\n        \\\"\\\"\\\"\\n        left.right = merge(left.right, right)\\n        return left\\n    else:\\n        \\\"\\\"\\\"\\n        Symmetric as well\\n        \\\"\\\"\\\"\\n        right.left = merge(left, right.left)\\n        return right\\n\\n\\ndef insert(root: Node | None, value: int) -> Node | None:\\n    \\\"\\\"\\\"\\n    Insert element\\n\\n    Split current tree with a value into left, right,\\n    Insert new node into the middle\\n    Merge left, node, right into root\\n    \\\"\\\"\\\"\\n    node = Node(value)\\n    left, right = split(root, value)\\n    return merge(merge(left, node), right)\\n\\n\\ndef erase(root: Node | None, value: int) -> Node | None:\\n    \\\"\\\"\\\"\\n    Erase element\\n\\n    Split all nodes with values less into left,\\n    Split all nodes with values greater into right.\\n    Merge left, right\\n    \\\"\\\"\\\"\\n    left, right = split(root, value - 1)\\n    _, right = split(right, value)\\n    return merge(left, right)\\n\\n\\ndef inorder(root: Node | None) -> None:\\n    \\\"\\\"\\\"\\n    Just recursive print of a tree\\n    \\\"\\\"\\\"\\n    if not root:  # None\\n        return\\n    else:\\n        inorder(root.left)\\n        print(root.value, end=\\\",\\\")\\n        inorder(root.right)\\n\\n\\ndef interactTreap(root: Node | None, args: str) -> Node | None:\\n    \\\"\\\"\\\"\\n    Commands:\\n    + value to add value into treap\\n    - value to erase all nodes with value\\n\\n        >>> root = interactTreap(None, \\\"+1\\\")\\n        >>> inorder(root)\\n        1,\\n        >>> root = interactTreap(root, \\\"+3 +5 +17 +19 +2 +16 +4 +0\\\")\\n        >>> inorder(root)\\n        0,1,2,3,4,5,16,17,19,\\n        >>> root = interactTreap(root, \\\"+4 +4 +4\\\")\\n        >>> inorder(root)\\n        0,1,2,3,4,4,4,4,5,16,17,19,\\n        >>> root = interactTreap(root, \\\"-0\\\")\\n        >>> inorder(root)\\n        1,2,3,4,4,4,4,5,16,17,19,\\n        >>> root = interactTreap(root, \\\"-4\\\")\\n        >>> inorder(root)\\n        1,2,3,5,16,17,19,\\n        >>> root = interactTreap(root, \\\"=0\\\")\\n        Unknown command\\n    \\\"\\\"\\\"\\n    for arg in args.split():\\n        if arg[0] == \\\"+\\\":\\n            root = insert(root, int(arg[1:]))\\n\\n        elif arg[0] == \\\"-\\\":\\n            root = erase(root, int(arg[1:]))\\n\\n        else:\\n            print(\\\"Unknown command\\\")\\n\\n    return root\\n\\n\\ndef main() -> None:\\n    \\\"\\\"\\\"After each command, program prints treap\\\"\\\"\\\"\\n    root = None\\n    print(\\n        \\\"enter numbers to create a tree, + value to add value into treap, \\\"\\n        \\\"- value to erase all nodes with value. 'q' to quit. \\\"\\n    )\\n\\n    args = input()\\n    while args != \\\"q\\\":\\n        root = interactTreap(root, args)\\n        print(root)\\n        args = input()\\n\\n    print(\\\"good by!\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    main()\\n\"",
    "wavelet tree": "\"\\\"\\\"\\\"\\nWavelet tree is a data-structure designed to efficiently answer various range queries\\nfor arrays. Wavelets trees are different from other binary trees in the sense that\\nthe nodes are split based on the actual values of the elements and not on indices,\\nsuch as the with segment trees or fenwick trees. You can read more about them here:\\n1. https://users.dcc.uchile.cl/~jperez/papers/ioiconf16.pdf\\n2. https://www.youtube.com/watch?v=4aSv9PcecDw&t=811s\\n3. https://www.youtube.com/watch?v=CybAgVF-MMc&t=1178s\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\ntest_array = [2, 1, 4, 5, 6, 0, 8, 9, 1, 2, 0, 6, 4, 2, 0, 6, 5, 3, 2, 7]\\n\\n\\nclass Node:\\n    def __init__(self, length: int) -> None:\\n        self.minn: int = -1\\n        self.maxx: int = -1\\n        self.map_left: list[int] = [-1] * length\\n        self.left: Node | None = None\\n        self.right: Node | None = None\\n\\n    def __repr__(self) -> str:\\n        \\\"\\\"\\\"\\n        >>> node = Node(length=27)\\n        >>> repr(node)\\n        'min_value: -1, max_value: -1'\\n        >>> repr(node) == str(node)\\n        True\\n        \\\"\\\"\\\"\\n        return f\\\"min_value: {self.minn}, max_value: {self.maxx}\\\"\\n\\n\\ndef build_tree(arr: list[int]) -> Node | None:\\n    \\\"\\\"\\\"\\n    Builds the tree for arr and returns the root\\n    of the constructed tree\\n\\n    >>> build_tree(test_array)\\n    min_value: 0, max_value: 9\\n    \\\"\\\"\\\"\\n    root = Node(len(arr))\\n    root.minn, root.maxx = min(arr), max(arr)\\n    # Leaf node case where the node contains only one unique value\\n    if root.minn == root.maxx:\\n        return root\\n    \\\"\\\"\\\"\\n    Take the mean of min and max element of arr as the pivot and\\n    partition arr into left_arr and right_arr with all elements <= pivot in the\\n    left_arr and the rest in right_arr, maintaining the order of the elements,\\n    then recursively build trees for left_arr and right_arr\\n    \\\"\\\"\\\"\\n    pivot = (root.minn + root.maxx) // 2\\n\\n    left_arr: list[int] = []\\n    right_arr: list[int] = []\\n\\n    for index, num in enumerate(arr):\\n        if num <= pivot:\\n            left_arr.append(num)\\n        else:\\n            right_arr.append(num)\\n        root.map_left[index] = len(left_arr)\\n    root.left = build_tree(left_arr)\\n    root.right = build_tree(right_arr)\\n    return root\\n\\n\\ndef rank_till_index(node: Node | None, num: int, index: int) -> int:\\n    \\\"\\\"\\\"\\n    Returns the number of occurrences of num in interval [0, index] in the list\\n\\n    >>> root = build_tree(test_array)\\n    >>> rank_till_index(root, 6, 6)\\n    1\\n    >>> rank_till_index(root, 2, 0)\\n    1\\n    >>> rank_till_index(root, 1, 10)\\n    2\\n    >>> rank_till_index(root, 17, 7)\\n    0\\n    >>> rank_till_index(root, 0, 9)\\n    1\\n    \\\"\\\"\\\"\\n    if index < 0 or node is None:\\n        return 0\\n    # Leaf node cases\\n    if node.minn == node.maxx:\\n        return index + 1 if node.minn == num else 0\\n    pivot = (node.minn + node.maxx) // 2\\n    if num <= pivot:\\n        # go the left subtree and map index to the left subtree\\n        return rank_till_index(node.left, num, node.map_left[index] - 1)\\n    else:\\n        # go to the right subtree and map index to the right subtree\\n        return rank_till_index(node.right, num, index - node.map_left[index])\\n\\n\\ndef rank(node: Node | None, num: int, start: int, end: int) -> int:\\n    \\\"\\\"\\\"\\n    Returns the number of occurrences of num in interval [start, end] in the list\\n\\n    >>> root = build_tree(test_array)\\n    >>> rank(root, 6, 3, 13)\\n    2\\n    >>> rank(root, 2, 0, 19)\\n    4\\n    >>> rank(root, 9, 2 ,2)\\n    0\\n    >>> rank(root, 0, 5, 10)\\n    2\\n    \\\"\\\"\\\"\\n    if start > end:\\n        return 0\\n    rank_till_end = rank_till_index(node, num, end)\\n    rank_before_start = rank_till_index(node, num, start - 1)\\n    return rank_till_end - rank_before_start\\n\\n\\ndef quantile(node: Node | None, index: int, start: int, end: int) -> int:\\n    \\\"\\\"\\\"\\n    Returns the index'th smallest element in interval [start, end] in the list\\n    index is 0-indexed\\n\\n    >>> root = build_tree(test_array)\\n    >>> quantile(root, 2, 2, 5)\\n    5\\n    >>> quantile(root, 5, 2, 13)\\n    4\\n    >>> quantile(root, 0, 6, 6)\\n    8\\n    >>> quantile(root, 4, 2, 5)\\n    -1\\n    \\\"\\\"\\\"\\n    if index > (end - start) or start > end or node is None:\\n        return -1\\n    # Leaf node case\\n    if node.minn == node.maxx:\\n        return node.minn\\n    # Number of elements in the left subtree in interval [start, end]\\n    num_elements_in_left_tree = node.map_left[end] - (\\n        node.map_left[start - 1] if start else 0\\n    )\\n    if num_elements_in_left_tree > index:\\n        return quantile(\\n            node.left,\\n            index,\\n            (node.map_left[start - 1] if start else 0),\\n            node.map_left[end] - 1,\\n        )\\n    else:\\n        return quantile(\\n            node.right,\\n            index - num_elements_in_left_tree,\\n            start - (node.map_left[start - 1] if start else 0),\\n            end - node.map_left[end],\\n        )\\n\\n\\ndef range_counting(\\n    node: Node | None, start: int, end: int, start_num: int, end_num: int\\n) -> int:\\n    \\\"\\\"\\\"\\n    Returns the number of elements in range [start_num, end_num]\\n    in interval [start, end] in the list\\n\\n    >>> root = build_tree(test_array)\\n    >>> range_counting(root, 1, 10, 3, 7)\\n    3\\n    >>> range_counting(root, 2, 2, 1, 4)\\n    1\\n    >>> range_counting(root, 0, 19, 0, 100)\\n    20\\n    >>> range_counting(root, 1, 0, 1, 100)\\n    0\\n    >>> range_counting(root, 0, 17, 100, 1)\\n    0\\n    \\\"\\\"\\\"\\n    if (\\n        start > end\\n        or node is None\\n        or start_num > end_num\\n        or node.minn > end_num\\n        or node.maxx < start_num\\n    ):\\n        return 0\\n    if start_num <= node.minn and node.maxx <= end_num:\\n        return end - start + 1\\n    left = range_counting(\\n        node.left,\\n        (node.map_left[start - 1] if start else 0),\\n        node.map_left[end] - 1,\\n        start_num,\\n        end_num,\\n    )\\n    right = range_counting(\\n        node.right,\\n        start - (node.map_left[start - 1] if start else 0),\\n        end - node.map_left[end],\\n        start_num,\\n        end_num,\\n    )\\n    return left + right\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "alternate disjoint set": "\"\\\"\\\"\\\"\\nImplements a disjoint set using Lists and some added heuristics for efficiency\\nUnion by Rank Heuristic and Path Compression\\n\\\"\\\"\\\"\\n\\n\\nclass DisjointSet:\\n    def __init__(self, set_counts: list) -> None:\\n        \\\"\\\"\\\"\\n        Initialize with a list of the number of items in each set\\n        and with rank = 1 for each set\\n        \\\"\\\"\\\"\\n        self.set_counts = set_counts\\n        self.max_set = max(set_counts)\\n        num_sets = len(set_counts)\\n        self.ranks = [1] * num_sets\\n        self.parents = list(range(num_sets))\\n\\n    def merge(self, src: int, dst: int) -> bool:\\n        \\\"\\\"\\\"\\n        Merge two sets together using Union by rank heuristic\\n        Return True if successful\\n        Merge two disjoint sets\\n        >>> A = DisjointSet([1, 1, 1])\\n        >>> A.merge(1, 2)\\n        True\\n        >>> A.merge(0, 2)\\n        True\\n        >>> A.merge(0, 1)\\n        False\\n        \\\"\\\"\\\"\\n        src_parent = self.get_parent(src)\\n        dst_parent = self.get_parent(dst)\\n\\n        if src_parent == dst_parent:\\n            return False\\n\\n        if self.ranks[dst_parent] >= self.ranks[src_parent]:\\n            self.set_counts[dst_parent] += self.set_counts[src_parent]\\n            self.set_counts[src_parent] = 0\\n            self.parents[src_parent] = dst_parent\\n            if self.ranks[dst_parent] == self.ranks[src_parent]:\\n                self.ranks[dst_parent] += 1\\n            joined_set_size = self.set_counts[dst_parent]\\n        else:\\n            self.set_counts[src_parent] += self.set_counts[dst_parent]\\n            self.set_counts[dst_parent] = 0\\n            self.parents[dst_parent] = src_parent\\n            joined_set_size = self.set_counts[src_parent]\\n\\n        self.max_set = max(self.max_set, joined_set_size)\\n        return True\\n\\n    def get_parent(self, disj_set: int) -> int:\\n        \\\"\\\"\\\"\\n        Find the Parent of a given set\\n        >>> A = DisjointSet([1, 1, 1])\\n        >>> A.merge(1, 2)\\n        True\\n        >>> A.get_parent(0)\\n        0\\n        >>> A.get_parent(1)\\n        2\\n        \\\"\\\"\\\"\\n        if self.parents[disj_set] == disj_set:\\n            return disj_set\\n        self.parents[disj_set] = self.get_parent(self.parents[disj_set])\\n        return self.parents[disj_set]\\n\"",
    "disjoint set": "\"\\\"\\\"\\\"\\r\\n    Disjoint set.\\r\\n    Reference: https://en.wikipedia.org/wiki/Disjoint-set_data_structure\\r\\n\\\"\\\"\\\"\\r\\n\\r\\n\\r\\nclass Node:\\r\\n    def __init__(self, data: int) -> None:\\r\\n        self.data = data\\r\\n        self.rank: int\\r\\n        self.parent: Node\\r\\n\\r\\n\\r\\ndef make_set(x: Node) -> None:\\r\\n    \\\"\\\"\\\"\\r\\n    Make x as a set.\\r\\n    \\\"\\\"\\\"\\r\\n    # rank is the distance from x to its' parent\\r\\n    # root's rank is 0\\r\\n    x.rank = 0\\r\\n    x.parent = x\\r\\n\\r\\n\\r\\ndef union_set(x: Node, y: Node) -> None:\\r\\n    \\\"\\\"\\\"\\r\\n    Union of two sets.\\r\\n    set with bigger rank should be parent, so that the\\r\\n    disjoint set tree will be more flat.\\r\\n    \\\"\\\"\\\"\\r\\n    x, y = find_set(x), find_set(y)\\r\\n    if x == y:\\r\\n        return\\r\\n\\r\\n    elif x.rank > y.rank:\\r\\n        y.parent = x\\r\\n    else:\\r\\n        x.parent = y\\r\\n        if x.rank == y.rank:\\r\\n            y.rank += 1\\r\\n\\r\\n\\r\\ndef find_set(x: Node) -> Node:\\r\\n    \\\"\\\"\\\"\\r\\n    Return the parent of x\\r\\n    \\\"\\\"\\\"\\r\\n    if x != x.parent:\\r\\n        x.parent = find_set(x.parent)\\r\\n    return x.parent\\r\\n\\r\\n\\r\\ndef find_python_set(node: Node) -> set:\\r\\n    \\\"\\\"\\\"\\r\\n    Return a Python Standard Library set that contains i.\\r\\n    \\\"\\\"\\\"\\r\\n    sets = ({0, 1, 2}, {3, 4, 5})\\r\\n    for s in sets:\\r\\n        if node.data in s:\\r\\n            return s\\r\\n    raise ValueError(f\\\"{node.data} is not in {sets}\\\")\\r\\n\\r\\n\\r\\ndef test_disjoint_set() -> None:\\r\\n    \\\"\\\"\\\"\\r\\n    >>> test_disjoint_set()\\r\\n    \\\"\\\"\\\"\\r\\n    vertex = [Node(i) for i in range(6)]\\r\\n    for v in vertex:\\r\\n        make_set(v)\\r\\n\\r\\n    union_set(vertex[0], vertex[1])\\r\\n    union_set(vertex[1], vertex[2])\\r\\n    union_set(vertex[3], vertex[4])\\r\\n    union_set(vertex[3], vertex[5])\\r\\n\\r\\n    for node0 in vertex:\\r\\n        for node1 in vertex:\\r\\n            if find_python_set(node0).isdisjoint(find_python_set(node1)):\\r\\n                assert find_set(node0) != find_set(node1)\\r\\n            else:\\r\\n                assert find_set(node0) == find_set(node1)\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    test_disjoint_set()\\r\\n\"",
    "double hash": "\"#!/usr/bin/env python3\\nfrom .hash_table import HashTable\\nfrom .number_theory.prime_numbers import check_prime, next_prime\\n\\n\\nclass DoubleHash(HashTable):\\n    \\\"\\\"\\\"\\n    Hash Table example with open addressing and Double Hash\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, *args, **kwargs):\\n        super().__init__(*args, **kwargs)\\n\\n    def __hash_function_2(self, value, data):\\n\\n        next_prime_gt = (\\n            next_prime(value % self.size_table)\\n            if not check_prime(value % self.size_table)\\n            else value % self.size_table\\n        )  # gt = bigger than\\n        return next_prime_gt - (data % next_prime_gt)\\n\\n    def __hash_double_function(self, key, data, increment):\\n        return (increment * self.__hash_function_2(key, data)) % self.size_table\\n\\n    def _collision_resolution(self, key, data=None):\\n        i = 1\\n        new_key = self.hash_function(data)\\n\\n        while self.values[new_key] is not None and self.values[new_key] != key:\\n            new_key = (\\n                self.__hash_double_function(key, data, i)\\n                if self.balanced_factor() >= self.lim_charge\\n                else None\\n            )\\n            if new_key is None:\\n                break\\n            else:\\n                i += 1\\n\\n        return new_key\\n\"",
    "hash table": "\"#!/usr/bin/env python3\\nfrom .number_theory.prime_numbers import next_prime\\n\\n\\nclass HashTable:\\n    \\\"\\\"\\\"\\n    Basic Hash Table example with open addressing and linear probing\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, size_table, charge_factor=None, lim_charge=None):\\n        self.size_table = size_table\\n        self.values = [None] * self.size_table\\n        self.lim_charge = 0.75 if lim_charge is None else lim_charge\\n        self.charge_factor = 1 if charge_factor is None else charge_factor\\n        self.__aux_list = []\\n        self._keys = {}\\n\\n    def keys(self):\\n        return self._keys\\n\\n    def balanced_factor(self):\\n        return sum(1 for slot in self.values if slot is not None) / (\\n            self.size_table * self.charge_factor\\n        )\\n\\n    def hash_function(self, key):\\n        return key % self.size_table\\n\\n    def _step_by_step(self, step_ord):\\n\\n        print(f\\\"step {step_ord}\\\")\\n        print([i for i in range(len(self.values))])\\n        print(self.values)\\n\\n    def bulk_insert(self, values):\\n        i = 1\\n        self.__aux_list = values\\n        for value in values:\\n            self.insert_data(value)\\n            self._step_by_step(i)\\n            i += 1\\n\\n    def _set_value(self, key, data):\\n        self.values[key] = data\\n        self._keys[key] = data\\n\\n    def _collision_resolution(self, key, data=None):\\n        new_key = self.hash_function(key + 1)\\n\\n        while self.values[new_key] is not None and self.values[new_key] != key:\\n\\n            if self.values.count(None) > 0:\\n                new_key = self.hash_function(new_key + 1)\\n            else:\\n                new_key = None\\n                break\\n\\n        return new_key\\n\\n    def rehashing(self):\\n        survivor_values = [value for value in self.values if value is not None]\\n        self.size_table = next_prime(self.size_table, factor=2)\\n        self._keys.clear()\\n        self.values = [None] * self.size_table  # hell's pointers D: don't DRY ;/\\n        for value in survivor_values:\\n            self.insert_data(value)\\n\\n    def insert_data(self, data):\\n        key = self.hash_function(data)\\n\\n        if self.values[key] is None:\\n            self._set_value(key, data)\\n\\n        elif self.values[key] == data:\\n            pass\\n\\n        else:\\n            collision_resolution = self._collision_resolution(key, data)\\n            if collision_resolution is not None:\\n                self._set_value(collision_resolution, data)\\n            else:\\n                self.rehashing()\\n                self.insert_data(data)\\n\"",
    "hash table with linked list": "\"from collections import deque\\n\\nfrom .hash_table import HashTable\\n\\n\\nclass HashTableWithLinkedList(HashTable):\\n    def __init__(self, *args, **kwargs):\\n        super().__init__(*args, **kwargs)\\n\\n    def _set_value(self, key, data):\\n        self.values[key] = deque([]) if self.values[key] is None else self.values[key]\\n        self.values[key].appendleft(data)\\n        self._keys[key] = self.values[key]\\n\\n    def balanced_factor(self):\\n        return (\\n            sum(self.charge_factor - len(slot) for slot in self.values)\\n            / self.size_table\\n            * self.charge_factor\\n        )\\n\\n    def _collision_resolution(self, key, data=None):\\n        if not (\\n            len(self.values[key]) == self.charge_factor and self.values.count(None) == 0\\n        ):\\n            return key\\n        return super()._collision_resolution(key, data)\\n\"",
    "quadratic probing": "\"#!/usr/bin/env python3\\n\\nfrom .hash_table import HashTable\\n\\n\\nclass QuadraticProbing(HashTable):\\n    \\\"\\\"\\\"\\n    Basic Hash Table example with open addressing using Quadratic Probing\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, *args, **kwargs):\\n        super().__init__(*args, **kwargs)\\n\\n    def _collision_resolution(self, key, data=None):\\n        i = 1\\n        new_key = self.hash_function(key + i * i)\\n\\n        while self.values[new_key] is not None and self.values[new_key] != key:\\n            i += 1\\n            new_key = (\\n                self.hash_function(key + i * i)\\n                if not self.balanced_factor() >= self.lim_charge\\n                else None\\n            )\\n\\n            if new_key is None:\\n                break\\n\\n        return new_key\\n\"",
    "binomial heap": "\"# flake8: noqa\\r\\n\\r\\n\\\"\\\"\\\"\\r\\nBinomial Heap\\r\\nReference: Advanced Data Structures, Peter Brass\\r\\n\\\"\\\"\\\"\\r\\n\\r\\n\\r\\nclass Node:\\r\\n    \\\"\\\"\\\"\\r\\n    Node in a doubly-linked binomial tree, containing:\\r\\n        - value\\r\\n        - size of left subtree\\r\\n        - link to left, right and parent nodes\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def __init__(self, val):\\r\\n        self.val = val\\r\\n        # Number of nodes in left subtree\\r\\n        self.left_tree_size = 0\\r\\n        self.left = None\\r\\n        self.right = None\\r\\n        self.parent = None\\r\\n\\r\\n    def mergeTrees(self, other):\\r\\n        \\\"\\\"\\\"\\r\\n        In-place merge of two binomial trees of equal size.\\r\\n        Returns the root of the resulting tree\\r\\n        \\\"\\\"\\\"\\r\\n        assert self.left_tree_size == other.left_tree_size, \\\"Unequal Sizes of Blocks\\\"\\r\\n\\r\\n        if self.val < other.val:\\r\\n            other.left = self.right\\r\\n            other.parent = None\\r\\n            if self.right:\\r\\n                self.right.parent = other\\r\\n            self.right = other\\r\\n            self.left_tree_size = self.left_tree_size * 2 + 1\\r\\n            return self\\r\\n        else:\\r\\n            self.left = other.right\\r\\n            self.parent = None\\r\\n            if other.right:\\r\\n                other.right.parent = self\\r\\n            other.right = self\\r\\n            other.left_tree_size = other.left_tree_size * 2 + 1\\r\\n            return other\\r\\n\\r\\n\\r\\nclass BinomialHeap:\\r\\n    r\\\"\\\"\\\"\\r\\n    Min-oriented priority queue implemented with the Binomial Heap data\\r\\n    structure implemented with the BinomialHeap class. It supports:\\r\\n        - Insert element in a heap with n elements: Guaranteed logn, amoratized 1\\r\\n        - Merge (meld) heaps of size m and n: O(logn + logm)\\r\\n        - Delete Min: O(logn)\\r\\n        - Peek (return min without deleting it): O(1)\\r\\n\\r\\n    Example:\\r\\n\\r\\n    Create a random permutation of 30 integers to be inserted and 19 of them deleted\\r\\n    >>> import numpy as np\\r\\n    >>> permutation = np.random.permutation(list(range(30)))\\r\\n\\r\\n    Create a Heap and insert the 30 integers\\r\\n    __init__() test\\r\\n    >>> first_heap = BinomialHeap()\\r\\n\\r\\n    30 inserts - insert() test\\r\\n    >>> for number in permutation:\\r\\n    ...     first_heap.insert(number)\\r\\n\\r\\n    Size test\\r\\n    >>> print(first_heap.size)\\r\\n    30\\r\\n\\r\\n    Deleting - delete() test\\r\\n    >>> for i in range(25):\\r\\n    ...     print(first_heap.deleteMin(), end=\\\" \\\")\\r\\n    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \\r\\n\\r\\n    Create a new Heap\\r\\n    >>> second_heap = BinomialHeap()\\r\\n    >>> vals = [17, 20, 31, 34]\\r\\n    >>> for value in vals:\\r\\n    ...     second_heap.insert(value)\\r\\n\\r\\n\\r\\n    The heap should have the following structure:\\r\\n\\r\\n                    17\\r\\n                   /  \\\\\\r\\n                  #    31\\r\\n                      /  \\\\\\r\\n                    20    34\\r\\n                   /  \\\\  /  \\\\\\r\\n                  #    # #   #\\r\\n\\r\\n    preOrder() test\\r\\n    >>> print(second_heap.preOrder())\\r\\n    [(17, 0), ('#', 1), (31, 1), (20, 2), ('#', 3), ('#', 3), (34, 2), ('#', 3), ('#', 3)]\\r\\n\\r\\n    printing Heap - __str__() test\\r\\n    >>> print(second_heap)\\r\\n    17\\r\\n    -#\\r\\n    -31\\r\\n    --20\\r\\n    ---#\\r\\n    ---#\\r\\n    --34\\r\\n    ---#\\r\\n    ---#\\r\\n\\r\\n    mergeHeaps() test\\r\\n    >>> merged = second_heap.mergeHeaps(first_heap)\\r\\n    >>> merged.peek()\\r\\n    17\\r\\n\\r\\n    values in merged heap; (merge is inplace)\\r\\n    >>> while not first_heap.isEmpty():\\r\\n    ...     print(first_heap.deleteMin(), end=\\\" \\\")\\r\\n    17 20 25 26 27 28 29 31 34 \\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def __init__(self, bottom_root=None, min_node=None, heap_size=0):\\r\\n        self.size = heap_size\\r\\n        self.bottom_root = bottom_root\\r\\n        self.min_node = min_node\\r\\n\\r\\n    def mergeHeaps(self, other):\\r\\n        \\\"\\\"\\\"\\r\\n        In-place merge of two binomial heaps.\\r\\n        Both of them become the resulting merged heap\\r\\n        \\\"\\\"\\\"\\r\\n\\r\\n        # Empty heaps corner cases\\r\\n        if other.size == 0:\\r\\n            return\\r\\n        if self.size == 0:\\r\\n            self.size = other.size\\r\\n            self.bottom_root = other.bottom_root\\r\\n            self.min_node = other.min_node\\r\\n            return\\r\\n        # Update size\\r\\n        self.size = self.size + other.size\\r\\n\\r\\n        # Update min.node\\r\\n        if self.min_node.val > other.min_node.val:\\r\\n            self.min_node = other.min_node\\r\\n        # Merge\\r\\n\\r\\n        # Order roots by left_subtree_size\\r\\n        combined_roots_list = []\\r\\n        i, j = self.bottom_root, other.bottom_root\\r\\n        while i or j:\\r\\n            if i and ((not j) or i.left_tree_size < j.left_tree_size):\\r\\n                combined_roots_list.append((i, True))\\r\\n                i = i.parent\\r\\n            else:\\r\\n                combined_roots_list.append((j, False))\\r\\n                j = j.parent\\r\\n        # Insert links between them\\r\\n        for i in range(len(combined_roots_list) - 1):\\r\\n            if combined_roots_list[i][1] != combined_roots_list[i + 1][1]:\\r\\n                combined_roots_list[i][0].parent = combined_roots_list[i + 1][0]\\r\\n                combined_roots_list[i + 1][0].left = combined_roots_list[i][0]\\r\\n        # Consecutively merge roots with same left_tree_size\\r\\n        i = combined_roots_list[0][0]\\r\\n        while i.parent:\\r\\n            if (\\r\\n                (i.left_tree_size == i.parent.left_tree_size) and (not i.parent.parent)\\r\\n            ) or (\\r\\n                i.left_tree_size == i.parent.left_tree_size\\r\\n                and i.left_tree_size != i.parent.parent.left_tree_size\\r\\n            ):\\r\\n\\r\\n                # Neighbouring Nodes\\r\\n                previous_node = i.left\\r\\n                next_node = i.parent.parent\\r\\n\\r\\n                # Merging trees\\r\\n                i = i.mergeTrees(i.parent)\\r\\n\\r\\n                # Updating links\\r\\n                i.left = previous_node\\r\\n                i.parent = next_node\\r\\n                if previous_node:\\r\\n                    previous_node.parent = i\\r\\n                if next_node:\\r\\n                    next_node.left = i\\r\\n            else:\\r\\n                i = i.parent\\r\\n        # Updating self.bottom_root\\r\\n        while i.left:\\r\\n            i = i.left\\r\\n        self.bottom_root = i\\r\\n\\r\\n        # Update other\\r\\n        other.size = self.size\\r\\n        other.bottom_root = self.bottom_root\\r\\n        other.min_node = self.min_node\\r\\n\\r\\n        # Return the merged heap\\r\\n        return self\\r\\n\\r\\n    def insert(self, val):\\r\\n        \\\"\\\"\\\"\\r\\n        insert a value in the heap\\r\\n        \\\"\\\"\\\"\\r\\n        if self.size == 0:\\r\\n            self.bottom_root = Node(val)\\r\\n            self.size = 1\\r\\n            self.min_node = self.bottom_root\\r\\n        else:\\r\\n            # Create new node\\r\\n            new_node = Node(val)\\r\\n\\r\\n            # Update size\\r\\n            self.size += 1\\r\\n\\r\\n            # update min_node\\r\\n            if val < self.min_node.val:\\r\\n                self.min_node = new_node\\r\\n            # Put new_node as a bottom_root in heap\\r\\n            self.bottom_root.left = new_node\\r\\n            new_node.parent = self.bottom_root\\r\\n            self.bottom_root = new_node\\r\\n\\r\\n            # Consecutively merge roots with same left_tree_size\\r\\n            while (\\r\\n                self.bottom_root.parent\\r\\n                and self.bottom_root.left_tree_size\\r\\n                == self.bottom_root.parent.left_tree_size\\r\\n            ):\\r\\n\\r\\n                # Next node\\r\\n                next_node = self.bottom_root.parent.parent\\r\\n\\r\\n                # Merge\\r\\n                self.bottom_root = self.bottom_root.mergeTrees(self.bottom_root.parent)\\r\\n\\r\\n                # Update Links\\r\\n                self.bottom_root.parent = next_node\\r\\n                self.bottom_root.left = None\\r\\n                if next_node:\\r\\n                    next_node.left = self.bottom_root\\r\\n\\r\\n    def peek(self):\\r\\n        \\\"\\\"\\\"\\r\\n        return min element without deleting it\\r\\n        \\\"\\\"\\\"\\r\\n        return self.min_node.val\\r\\n\\r\\n    def isEmpty(self):\\r\\n        return self.size == 0\\r\\n\\r\\n    def deleteMin(self):\\r\\n        \\\"\\\"\\\"\\r\\n        delete min element and return it\\r\\n        \\\"\\\"\\\"\\r\\n        # assert not self.isEmpty(), \\\"Empty Heap\\\"\\r\\n\\r\\n        # Save minimal value\\r\\n        min_value = self.min_node.val\\r\\n\\r\\n        # Last element in heap corner case\\r\\n        if self.size == 1:\\r\\n            # Update size\\r\\n            self.size = 0\\r\\n\\r\\n            # Update bottom root\\r\\n            self.bottom_root = None\\r\\n\\r\\n            # Update min_node\\r\\n            self.min_node = None\\r\\n\\r\\n            return min_value\\r\\n        # No right subtree corner case\\r\\n        # The structure of the tree implies that this should be the bottom root\\r\\n        # and there is at least one other root\\r\\n        if self.min_node.right is None:\\r\\n            # Update size\\r\\n            self.size -= 1\\r\\n\\r\\n            # Update bottom root\\r\\n            self.bottom_root = self.bottom_root.parent\\r\\n            self.bottom_root.left = None\\r\\n\\r\\n            # Update min_node\\r\\n            self.min_node = self.bottom_root\\r\\n            i = self.bottom_root.parent\\r\\n            while i:\\r\\n                if i.val < self.min_node.val:\\r\\n                    self.min_node = i\\r\\n                i = i.parent\\r\\n            return min_value\\r\\n        # General case\\r\\n        # Find the BinomialHeap of the right subtree of min_node\\r\\n        bottom_of_new = self.min_node.right\\r\\n        bottom_of_new.parent = None\\r\\n        min_of_new = bottom_of_new\\r\\n        size_of_new = 1\\r\\n\\r\\n        # Size, min_node and bottom_root\\r\\n        while bottom_of_new.left:\\r\\n            size_of_new = size_of_new * 2 + 1\\r\\n            bottom_of_new = bottom_of_new.left\\r\\n            if bottom_of_new.val < min_of_new.val:\\r\\n                min_of_new = bottom_of_new\\r\\n        # Corner case of single root on top left path\\r\\n        if (not self.min_node.left) and (not self.min_node.parent):\\r\\n            self.size = size_of_new\\r\\n            self.bottom_root = bottom_of_new\\r\\n            self.min_node = min_of_new\\r\\n            # print(\\\"Single root, multiple nodes case\\\")\\r\\n            return min_value\\r\\n        # Remaining cases\\r\\n        # Construct heap of right subtree\\r\\n        newHeap = BinomialHeap(\\r\\n            bottom_root=bottom_of_new, min_node=min_of_new, heap_size=size_of_new\\r\\n        )\\r\\n\\r\\n        # Update size\\r\\n        self.size = self.size - 1 - size_of_new\\r\\n\\r\\n        # Neighbour nodes\\r\\n        previous_node = self.min_node.left\\r\\n        next_node = self.min_node.parent\\r\\n\\r\\n        # Initialize new bottom_root and min_node\\r\\n        self.min_node = previous_node or next_node\\r\\n        self.bottom_root = next_node\\r\\n\\r\\n        # Update links of previous_node and search below for new min_node and\\r\\n        # bottom_root\\r\\n        if previous_node:\\r\\n            previous_node.parent = next_node\\r\\n\\r\\n            # Update bottom_root and search for min_node below\\r\\n            self.bottom_root = previous_node\\r\\n            self.min_node = previous_node\\r\\n            while self.bottom_root.left:\\r\\n                self.bottom_root = self.bottom_root.left\\r\\n                if self.bottom_root.val < self.min_node.val:\\r\\n                    self.min_node = self.bottom_root\\r\\n        if next_node:\\r\\n            next_node.left = previous_node\\r\\n\\r\\n            # Search for new min_node above min_node\\r\\n            i = next_node\\r\\n            while i:\\r\\n                if i.val < self.min_node.val:\\r\\n                    self.min_node = i\\r\\n                i = i.parent\\r\\n        # Merge heaps\\r\\n        self.mergeHeaps(newHeap)\\r\\n\\r\\n        return min_value\\r\\n\\r\\n    def preOrder(self):\\r\\n        \\\"\\\"\\\"\\r\\n        Returns the Pre-order representation of the heap including\\r\\n        values of nodes plus their level distance from the root;\\r\\n        Empty nodes appear as #\\r\\n        \\\"\\\"\\\"\\r\\n        # Find top root\\r\\n        top_root = self.bottom_root\\r\\n        while top_root.parent:\\r\\n            top_root = top_root.parent\\r\\n        # preorder\\r\\n        heap_preOrder = []\\r\\n        self.__traversal(top_root, heap_preOrder)\\r\\n        return heap_preOrder\\r\\n\\r\\n    def __traversal(self, curr_node, preorder, level=0):\\r\\n        \\\"\\\"\\\"\\r\\n        Pre-order traversal of nodes\\r\\n        \\\"\\\"\\\"\\r\\n        if curr_node:\\r\\n            preorder.append((curr_node.val, level))\\r\\n            self.__traversal(curr_node.left, preorder, level + 1)\\r\\n            self.__traversal(curr_node.right, preorder, level + 1)\\r\\n        else:\\r\\n            preorder.append((\\\"#\\\", level))\\r\\n\\r\\n    def __str__(self):\\r\\n        \\\"\\\"\\\"\\r\\n        Overwriting str for a pre-order print of nodes in heap;\\r\\n        Performance is poor, so use only for small examples\\r\\n        \\\"\\\"\\\"\\r\\n        if self.isEmpty():\\r\\n            return \\\"\\\"\\r\\n        preorder_heap = self.preOrder()\\r\\n\\r\\n        return \\\"\\\\n\\\".join((\\\"-\\\" * level + str(value)) for value, level in preorder_heap)\\r\\n\\r\\n\\r\\n# Unit Tests\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    import doctest\\r\\n\\r\\n    doctest.testmod()\\r\\n\"",
    "heap": "\"from __future__ import annotations\\n\\nfrom typing import Iterable\\n\\n\\nclass Heap:\\n    \\\"\\\"\\\"A Max Heap Implementation\\n\\n    >>> unsorted = [103, 9, 1, 7, 11, 15, 25, 201, 209, 107, 5]\\n    >>> h = Heap()\\n    >>> h.build_max_heap(unsorted)\\n    >>> print(h)\\n    [209, 201, 25, 103, 107, 15, 1, 9, 7, 11, 5]\\n    >>>\\n    >>> h.extract_max()\\n    209\\n    >>> print(h)\\n    [201, 107, 25, 103, 11, 15, 1, 9, 7, 5]\\n    >>>\\n    >>> h.insert(100)\\n    >>> print(h)\\n    [201, 107, 25, 103, 100, 15, 1, 9, 7, 5, 11]\\n    >>>\\n    >>> h.heap_sort()\\n    >>> print(h)\\n    [1, 5, 7, 9, 11, 15, 25, 100, 103, 107, 201]\\n    \\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.h: list[float] = []\\n        self.heap_size: int = 0\\n\\n    def __repr__(self) -> str:\\n        return str(self.h)\\n\\n    def parent_index(self, child_idx: int) -> int | None:\\n        \\\"\\\"\\\"return the parent index of given child\\\"\\\"\\\"\\n        if child_idx > 0:\\n            return (child_idx - 1) // 2\\n        return None\\n\\n    def left_child_idx(self, parent_idx: int) -> int | None:\\n        \\\"\\\"\\\"\\n        return the left child index if the left child exists.\\n        if not, return None.\\n        \\\"\\\"\\\"\\n        left_child_index = 2 * parent_idx + 1\\n        if left_child_index < self.heap_size:\\n            return left_child_index\\n        return None\\n\\n    def right_child_idx(self, parent_idx: int) -> int | None:\\n        \\\"\\\"\\\"\\n        return the right child index if the right child exists.\\n        if not, return None.\\n        \\\"\\\"\\\"\\n        right_child_index = 2 * parent_idx + 2\\n        if right_child_index < self.heap_size:\\n            return right_child_index\\n        return None\\n\\n    def max_heapify(self, index: int) -> None:\\n        \\\"\\\"\\\"\\n        correct a single violation of the heap property in a subtree's root.\\n        \\\"\\\"\\\"\\n        if index < self.heap_size:\\n            violation: int = index\\n            left_child = self.left_child_idx(index)\\n            right_child = self.right_child_idx(index)\\n            # check which child is larger than its parent\\n            if left_child is not None and self.h[left_child] > self.h[violation]:\\n                violation = left_child\\n            if right_child is not None and self.h[right_child] > self.h[violation]:\\n                violation = right_child\\n            # if violation indeed exists\\n            if violation != index:\\n                # swap to fix the violation\\n                self.h[violation], self.h[index] = self.h[index], self.h[violation]\\n                # fix the subsequent violation recursively if any\\n                self.max_heapify(violation)\\n\\n    def build_max_heap(self, collection: Iterable[float]) -> None:\\n        \\\"\\\"\\\"build max heap from an unsorted array\\\"\\\"\\\"\\n        self.h = list(collection)\\n        self.heap_size = len(self.h)\\n        if self.heap_size > 1:\\n            # max_heapify from right to left but exclude leaves (last level)\\n            for i in range(self.heap_size // 2 - 1, -1, -1):\\n                self.max_heapify(i)\\n\\n    def max(self) -> float:\\n        \\\"\\\"\\\"return the max in the heap\\\"\\\"\\\"\\n        if self.heap_size >= 1:\\n            return self.h[0]\\n        else:\\n            raise Exception(\\\"Empty heap\\\")\\n\\n    def extract_max(self) -> float:\\n        \\\"\\\"\\\"get and remove max from heap\\\"\\\"\\\"\\n        if self.heap_size >= 2:\\n            me = self.h[0]\\n            self.h[0] = self.h.pop(-1)\\n            self.heap_size -= 1\\n            self.max_heapify(0)\\n            return me\\n        elif self.heap_size == 1:\\n            self.heap_size -= 1\\n            return self.h.pop(-1)\\n        else:\\n            raise Exception(\\\"Empty heap\\\")\\n\\n    def insert(self, value: float) -> None:\\n        \\\"\\\"\\\"insert a new value into the max heap\\\"\\\"\\\"\\n        self.h.append(value)\\n        idx = (self.heap_size - 1) // 2\\n        self.heap_size += 1\\n        while idx >= 0:\\n            self.max_heapify(idx)\\n            idx = (idx - 1) // 2\\n\\n    def heap_sort(self) -> None:\\n        size = self.heap_size\\n        for j in range(size - 1, 0, -1):\\n            self.h[0], self.h[j] = self.h[j], self.h[0]\\n            self.heap_size -= 1\\n            self.max_heapify(0)\\n        self.heap_size = size\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    # run doc test\\n    doctest.testmod()\\n\\n    # demo\\n    for unsorted in [\\n        [0],\\n        [2],\\n        [3, 5],\\n        [5, 3],\\n        [5, 5],\\n        [0, 0, 0, 0],\\n        [1, 1, 1, 1],\\n        [2, 2, 3, 5],\\n        [0, 2, 2, 3, 5],\\n        [2, 5, 3, 0, 2, 3, 0, 3],\\n        [6, 1, 2, 7, 9, 3, 4, 5, 10, 8],\\n        [103, 9, 1, 7, 11, 15, 25, 201, 209, 107, 5],\\n        [-45, -2, -5],\\n    ]:\\n        print(f\\\"unsorted array: {unsorted}\\\")\\n\\n        heap = Heap()\\n        heap.build_max_heap(unsorted)\\n        print(f\\\"after build heap: {heap}\\\")\\n\\n        print(f\\\"max value: {heap.extract_max()}\\\")\\n        print(f\\\"after max value removed: {heap}\\\")\\n\\n        heap.insert(100)\\n        print(f\\\"after new value 100 inserted: {heap}\\\")\\n\\n        heap.heap_sort()\\n        print(f\\\"heap-sorted array: {heap}\\\\n\\\")\\n\"",
    "heap generic": "\"class Heap:\\n    \\\"\\\"\\\"\\n    A generic Heap class, can be used as min or max by passing the key function\\n    accordingly.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, key=None):\\n        # Stores actual heap items.\\n        self.arr = list()\\n        # Stores indexes of each item for supporting updates and deletion.\\n        self.pos_map = {}\\n        # Stores current size of heap.\\n        self.size = 0\\n        # Stores function used to evaluate the score of an item on which basis ordering\\n        # will be done.\\n        self.key = key or (lambda x: x)\\n\\n    def _parent(self, i):\\n        \\\"\\\"\\\"Returns parent index of given index if exists else None\\\"\\\"\\\"\\n        return int((i - 1) / 2) if i > 0 else None\\n\\n    def _left(self, i):\\n        \\\"\\\"\\\"Returns left-child-index of given index if exists else None\\\"\\\"\\\"\\n        left = int(2 * i + 1)\\n        return left if 0 < left < self.size else None\\n\\n    def _right(self, i):\\n        \\\"\\\"\\\"Returns right-child-index of given index if exists else None\\\"\\\"\\\"\\n        right = int(2 * i + 2)\\n        return right if 0 < right < self.size else None\\n\\n    def _swap(self, i, j):\\n        \\\"\\\"\\\"Performs changes required for swapping two elements in the heap\\\"\\\"\\\"\\n        # First update the indexes of the items in index map.\\n        self.pos_map[self.arr[i][0]], self.pos_map[self.arr[j][0]] = (\\n            self.pos_map[self.arr[j][0]],\\n            self.pos_map[self.arr[i][0]],\\n        )\\n        # Then swap the items in the list.\\n        self.arr[i], self.arr[j] = self.arr[j], self.arr[i]\\n\\n    def _cmp(self, i, j):\\n        \\\"\\\"\\\"Compares the two items using default comparison\\\"\\\"\\\"\\n        return self.arr[i][1] < self.arr[j][1]\\n\\n    def _get_valid_parent(self, i):\\n        \\\"\\\"\\\"\\n        Returns index of valid parent as per desired ordering among given index and\\n        both it's children\\n        \\\"\\\"\\\"\\n        left = self._left(i)\\n        right = self._right(i)\\n        valid_parent = i\\n\\n        if left is not None and not self._cmp(left, valid_parent):\\n            valid_parent = left\\n        if right is not None and not self._cmp(right, valid_parent):\\n            valid_parent = right\\n\\n        return valid_parent\\n\\n    def _heapify_up(self, index):\\n        \\\"\\\"\\\"Fixes the heap in upward direction of given index\\\"\\\"\\\"\\n        parent = self._parent(index)\\n        while parent is not None and not self._cmp(index, parent):\\n            self._swap(index, parent)\\n            index, parent = parent, self._parent(parent)\\n\\n    def _heapify_down(self, index):\\n        \\\"\\\"\\\"Fixes the heap in downward direction of given index\\\"\\\"\\\"\\n        valid_parent = self._get_valid_parent(index)\\n        while valid_parent != index:\\n            self._swap(index, valid_parent)\\n            index, valid_parent = valid_parent, self._get_valid_parent(valid_parent)\\n\\n    def update_item(self, item, item_value):\\n        \\\"\\\"\\\"Updates given item value in heap if present\\\"\\\"\\\"\\n        if item not in self.pos_map:\\n            return\\n        index = self.pos_map[item]\\n        self.arr[index] = [item, self.key(item_value)]\\n        # Make sure heap is right in both up and down direction.\\n        # Ideally only one of them will make any change.\\n        self._heapify_up(index)\\n        self._heapify_down(index)\\n\\n    def delete_item(self, item):\\n        \\\"\\\"\\\"Deletes given item from heap if present\\\"\\\"\\\"\\n        if item not in self.pos_map:\\n            return\\n        index = self.pos_map[item]\\n        del self.pos_map[item]\\n        self.arr[index] = self.arr[self.size - 1]\\n        self.pos_map[self.arr[self.size - 1][0]] = index\\n        self.size -= 1\\n        # Make sure heap is right in both up and down direction. Ideally only one\\n        # of them will make any change- so no performance loss in calling both.\\n        if self.size > index:\\n            self._heapify_up(index)\\n            self._heapify_down(index)\\n\\n    def insert_item(self, item, item_value):\\n        \\\"\\\"\\\"Inserts given item with given value in heap\\\"\\\"\\\"\\n        arr_len = len(self.arr)\\n        if arr_len == self.size:\\n            self.arr.append([item, self.key(item_value)])\\n        else:\\n            self.arr[self.size] = [item, self.key(item_value)]\\n        self.pos_map[item] = self.size\\n        self.size += 1\\n        self._heapify_up(self.size - 1)\\n\\n    def get_top(self):\\n        \\\"\\\"\\\"Returns top item tuple (Calculated value, item) from heap if present\\\"\\\"\\\"\\n        return self.arr[0] if self.size else None\\n\\n    def extract_top(self):\\n        \\\"\\\"\\\"\\n        Return top item tuple (Calculated value, item) from heap and removes it as well\\n        if present\\n        \\\"\\\"\\\"\\n        top_item_tuple = self.get_top()\\n        if top_item_tuple:\\n            self.delete_item(top_item_tuple[0])\\n        return top_item_tuple\\n\\n\\ndef test_heap() -> None:\\n    \\\"\\\"\\\"\\n    >>> h = Heap()  # Max-heap\\n    >>> h.insert_item(5, 34)\\n    >>> h.insert_item(6, 31)\\n    >>> h.insert_item(7, 37)\\n    >>> h.get_top()\\n    [7, 37]\\n    >>> h.extract_top()\\n    [7, 37]\\n    >>> h.extract_top()\\n    [5, 34]\\n    >>> h.extract_top()\\n    [6, 31]\\n    >>> h = Heap(key=lambda x: -x)  # Min heap\\n    >>> h.insert_item(5, 34)\\n    >>> h.insert_item(6, 31)\\n    >>> h.insert_item(7, 37)\\n    >>> h.get_top()\\n    [6, -31]\\n    >>> h.extract_top()\\n    [6, -31]\\n    >>> h.extract_top()\\n    [5, -34]\\n    >>> h.extract_top()\\n    [7, -37]\\n    >>> h.insert_item(8, 45)\\n    >>> h.insert_item(9, 40)\\n    >>> h.insert_item(10, 50)\\n    >>> h.get_top()\\n    [9, -40]\\n    >>> h.update_item(10, 30)\\n    >>> h.get_top()\\n    [10, -30]\\n    >>> h.delete_item(10)\\n    >>> h.get_top()\\n    [9, -40]\\n    \\\"\\\"\\\"\\n    pass\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "max heap": "\"class BinaryHeap:\\n    \\\"\\\"\\\"\\n    A max-heap implementation in Python\\n    >>> binary_heap = BinaryHeap()\\n    >>> binary_heap.insert(6)\\n    >>> binary_heap.insert(10)\\n    >>> binary_heap.insert(15)\\n    >>> binary_heap.insert(12)\\n    >>> binary_heap.pop()\\n    15\\n    >>> binary_heap.pop()\\n    12\\n    >>> binary_heap.get_list\\n    [10, 6]\\n    >>> len(binary_heap)\\n    2\\n    \\\"\\\"\\\"\\n\\n    def __init__(self):\\n        self.__heap = [0]\\n        self.__size = 0\\n\\n    def __swap_up(self, i: int) -> None:\\n        \\\"\\\"\\\"Swap the element up\\\"\\\"\\\"\\n        temporary = self.__heap[i]\\n        while i // 2 > 0:\\n            if self.__heap[i] > self.__heap[i // 2]:\\n                self.__heap[i] = self.__heap[i // 2]\\n                self.__heap[i // 2] = temporary\\n            i //= 2\\n\\n    def insert(self, value: int) -> None:\\n        \\\"\\\"\\\"Insert new element\\\"\\\"\\\"\\n        self.__heap.append(value)\\n        self.__size += 1\\n        self.__swap_up(self.__size)\\n\\n    def __swap_down(self, i: int) -> None:\\n        \\\"\\\"\\\"Swap the element down\\\"\\\"\\\"\\n        while self.__size >= 2 * i:\\n            if 2 * i + 1 > self.__size:\\n                bigger_child = 2 * i\\n            else:\\n                if self.__heap[2 * i] > self.__heap[2 * i + 1]:\\n                    bigger_child = 2 * i\\n                else:\\n                    bigger_child = 2 * i + 1\\n            temporary = self.__heap[i]\\n            if self.__heap[i] < self.__heap[bigger_child]:\\n                self.__heap[i] = self.__heap[bigger_child]\\n                self.__heap[bigger_child] = temporary\\n            i = bigger_child\\n\\n    def pop(self) -> int:\\n        \\\"\\\"\\\"Pop the root element\\\"\\\"\\\"\\n        max_value = self.__heap[1]\\n        self.__heap[1] = self.__heap[self.__size]\\n        self.__size -= 1\\n        self.__heap.pop()\\n        self.__swap_down(1)\\n        return max_value\\n\\n    @property\\n    def get_list(self):\\n        return self.__heap[1:]\\n\\n    def __len__(self):\\n        \\\"\\\"\\\"Length of the array\\\"\\\"\\\"\\n        return self.__size\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    # create an instance of BinaryHeap\\n    binary_heap = BinaryHeap()\\n    binary_heap.insert(6)\\n    binary_heap.insert(10)\\n    binary_heap.insert(15)\\n    binary_heap.insert(12)\\n    # pop root(max-values because it is max heap)\\n    print(binary_heap.pop())  # 15\\n    print(binary_heap.pop())  # 12\\n    # get the list and size after operations\\n    print(binary_heap.get_list)\\n    print(len(binary_heap))\\n\"",
    "min heap": "\"# Min heap data structure\\n# with decrease key functionality - in O(log(n)) time\\n\\n\\nclass Node:\\n    def __init__(self, name, val):\\n        self.name = name\\n        self.val = val\\n\\n    def __str__(self):\\n        return f\\\"{self.__class__.__name__}({self.name}, {self.val})\\\"\\n\\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\n\\nclass MinHeap:\\n    \\\"\\\"\\\"\\n    >>> r = Node(\\\"R\\\", -1)\\n    >>> b = Node(\\\"B\\\", 6)\\n    >>> a = Node(\\\"A\\\", 3)\\n    >>> x = Node(\\\"X\\\", 1)\\n    >>> e = Node(\\\"E\\\", 4)\\n    >>> print(b)\\n    Node(B, 6)\\n    >>> myMinHeap = MinHeap([r, b, a, x, e])\\n    >>> myMinHeap.decrease_key(b, -17)\\n    >>> print(b)\\n    Node(B, -17)\\n    >>> print(myMinHeap[\\\"B\\\"])\\n    -17\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, array):\\n        self.idx_of_element = {}\\n        self.heap_dict = {}\\n        self.heap = self.build_heap(array)\\n\\n    def __getitem__(self, key):\\n        return self.get_value(key)\\n\\n    def get_parent_idx(self, idx):\\n        return (idx - 1) // 2\\n\\n    def get_left_child_idx(self, idx):\\n        return idx * 2 + 1\\n\\n    def get_right_child_idx(self, idx):\\n        return idx * 2 + 2\\n\\n    def get_value(self, key):\\n        return self.heap_dict[key]\\n\\n    def build_heap(self, array):\\n        lastIdx = len(array) - 1\\n        startFrom = self.get_parent_idx(lastIdx)\\n\\n        for idx, i in enumerate(array):\\n            self.idx_of_element[i] = idx\\n            self.heap_dict[i.name] = i.val\\n\\n        for i in range(startFrom, -1, -1):\\n            self.sift_down(i, array)\\n        return array\\n\\n    # this is min-heapify method\\n    def sift_down(self, idx, array):\\n        while True:\\n            l = self.get_left_child_idx(idx)  # noqa: E741\\n            r = self.get_right_child_idx(idx)\\n\\n            smallest = idx\\n            if l < len(array) and array[l] < array[idx]:\\n                smallest = l\\n            if r < len(array) and array[r] < array[smallest]:\\n                smallest = r\\n\\n            if smallest != idx:\\n                array[idx], array[smallest] = array[smallest], array[idx]\\n                (\\n                    self.idx_of_element[array[idx]],\\n                    self.idx_of_element[array[smallest]],\\n                ) = (\\n                    self.idx_of_element[array[smallest]],\\n                    self.idx_of_element[array[idx]],\\n                )\\n                idx = smallest\\n            else:\\n                break\\n\\n    def sift_up(self, idx):\\n        p = self.get_parent_idx(idx)\\n        while p >= 0 and self.heap[p] > self.heap[idx]:\\n            self.heap[p], self.heap[idx] = self.heap[idx], self.heap[p]\\n            self.idx_of_element[self.heap[p]], self.idx_of_element[self.heap[idx]] = (\\n                self.idx_of_element[self.heap[idx]],\\n                self.idx_of_element[self.heap[p]],\\n            )\\n            idx = p\\n            p = self.get_parent_idx(idx)\\n\\n    def peek(self):\\n        return self.heap[0]\\n\\n    def remove(self):\\n        self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]\\n        self.idx_of_element[self.heap[0]], self.idx_of_element[self.heap[-1]] = (\\n            self.idx_of_element[self.heap[-1]],\\n            self.idx_of_element[self.heap[0]],\\n        )\\n\\n        x = self.heap.pop()\\n        del self.idx_of_element[x]\\n        self.sift_down(0, self.heap)\\n        return x\\n\\n    def insert(self, node):\\n        self.heap.append(node)\\n        self.idx_of_element[node] = len(self.heap) - 1\\n        self.heap_dict[node.name] = node.val\\n        self.sift_up(len(self.heap) - 1)\\n\\n    def is_empty(self):\\n        return True if len(self.heap) == 0 else False\\n\\n    def decrease_key(self, node, newValue):\\n        assert (\\n            self.heap[self.idx_of_element[node]].val > newValue\\n        ), \\\"newValue must be less that current value\\\"\\n        node.val = newValue\\n        self.heap_dict[node.name] = newValue\\n        self.sift_up(self.idx_of_element[node])\\n\\n\\n# USAGE\\n\\nr = Node(\\\"R\\\", -1)\\nb = Node(\\\"B\\\", 6)\\na = Node(\\\"A\\\", 3)\\nx = Node(\\\"X\\\", 1)\\ne = Node(\\\"E\\\", 4)\\n\\n# Use one of these two ways to generate Min-Heap\\n\\n# Generating Min-Heap from array\\nmyMinHeap = MinHeap([r, b, a, x, e])\\n\\n# Generating Min-Heap by Insert method\\n# myMinHeap.insert(a)\\n# myMinHeap.insert(b)\\n# myMinHeap.insert(x)\\n# myMinHeap.insert(r)\\n# myMinHeap.insert(e)\\n\\n# Before\\nprint(\\\"Min Heap - before decrease key\\\")\\nfor i in myMinHeap.heap:\\n    print(i)\\n\\nprint(\\\"Min Heap - After decrease key of node [B -> -17]\\\")\\nmyMinHeap.decrease_key(b, -17)\\n\\n# After\\nfor i in myMinHeap.heap:\\n    print(i)\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "randomized heap": "\"#!/usr/bin/env python3\\n\\nfrom __future__ import annotations\\n\\nimport random\\nfrom typing import Any, Generic, Iterable, TypeVar\\n\\nT = TypeVar(\\\"T\\\", bound=bool)\\n\\n\\nclass RandomizedHeapNode(Generic[T]):\\n    \\\"\\\"\\\"\\n    One node of the randomized heap. Contains the value and references to\\n    two children.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, value: T) -> None:\\n        self._value: T = value\\n        self.left: RandomizedHeapNode[T] | None = None\\n        self.right: RandomizedHeapNode[T] | None = None\\n\\n    @property\\n    def value(self) -> T:\\n        \\\"\\\"\\\"Return the value of the node.\\\"\\\"\\\"\\n        return self._value\\n\\n    @staticmethod\\n    def merge(\\n        root1: RandomizedHeapNode[T] | None, root2: RandomizedHeapNode[T] | None\\n    ) -> RandomizedHeapNode[T] | None:\\n        \\\"\\\"\\\"Merge 2 nodes together.\\\"\\\"\\\"\\n        if not root1:\\n            return root2\\n\\n        if not root2:\\n            return root1\\n\\n        if root1.value > root2.value:\\n            root1, root2 = root2, root1\\n\\n        if random.choice([True, False]):\\n            root1.left, root1.right = root1.right, root1.left\\n\\n        root1.left = RandomizedHeapNode.merge(root1.left, root2)\\n\\n        return root1\\n\\n\\nclass RandomizedHeap(Generic[T]):\\n    \\\"\\\"\\\"\\n    A data structure that allows inserting a new value and to pop the smallest\\n    values. Both operations take O(logN) time where N is the size of the\\n    structure.\\n    Wiki: https://en.wikipedia.org/wiki/Randomized_meldable_heap\\n\\n    >>> RandomizedHeap([2, 3, 1, 5, 1, 7]).to_sorted_list()\\n    [1, 1, 2, 3, 5, 7]\\n\\n    >>> rh = RandomizedHeap()\\n    >>> rh.pop()\\n    Traceback (most recent call last):\\n        ...\\n    IndexError: Can't get top element for the empty heap.\\n\\n    >>> rh.insert(1)\\n    >>> rh.insert(-1)\\n    >>> rh.insert(0)\\n    >>> rh.to_sorted_list()\\n    [-1, 0, 1]\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, data: Iterable[T] | None = ()) -> None:\\n        \\\"\\\"\\\"\\n        >>> rh = RandomizedHeap([3, 1, 3, 7])\\n        >>> rh.to_sorted_list()\\n        [1, 3, 3, 7]\\n        \\\"\\\"\\\"\\n        self._root: RandomizedHeapNode[T] | None = None\\n\\n        if data:\\n            for item in data:\\n                self.insert(item)\\n\\n    def insert(self, value: T) -> None:\\n        \\\"\\\"\\\"\\n        Insert the value into the heap.\\n\\n        >>> rh = RandomizedHeap()\\n        >>> rh.insert(3)\\n        >>> rh.insert(1)\\n        >>> rh.insert(3)\\n        >>> rh.insert(7)\\n        >>> rh.to_sorted_list()\\n        [1, 3, 3, 7]\\n        \\\"\\\"\\\"\\n        self._root = RandomizedHeapNode.merge(self._root, RandomizedHeapNode(value))\\n\\n    def pop(self) -> T | None:\\n        \\\"\\\"\\\"\\n        Pop the smallest value from the heap and return it.\\n\\n        >>> rh = RandomizedHeap([3, 1, 3, 7])\\n        >>> rh.pop()\\n        1\\n        >>> rh.pop()\\n        3\\n        >>> rh.pop()\\n        3\\n        >>> rh.pop()\\n        7\\n        >>> rh.pop()\\n        Traceback (most recent call last):\\n            ...\\n        IndexError: Can't get top element for the empty heap.\\n        \\\"\\\"\\\"\\n\\n        result = self.top()\\n\\n        if self._root is None:\\n            return None\\n\\n        self._root = RandomizedHeapNode.merge(self._root.left, self._root.right)\\n\\n        return result\\n\\n    def top(self) -> T:\\n        \\\"\\\"\\\"\\n        Return the smallest value from the heap.\\n\\n        >>> rh = RandomizedHeap()\\n        >>> rh.insert(3)\\n        >>> rh.top()\\n        3\\n        >>> rh.insert(1)\\n        >>> rh.top()\\n        1\\n        >>> rh.insert(3)\\n        >>> rh.top()\\n        1\\n        >>> rh.insert(7)\\n        >>> rh.top()\\n        1\\n        \\\"\\\"\\\"\\n        if not self._root:\\n            raise IndexError(\\\"Can't get top element for the empty heap.\\\")\\n        return self._root.value\\n\\n    def clear(self) -> None:\\n        \\\"\\\"\\\"\\n        Clear the heap.\\n\\n        >>> rh = RandomizedHeap([3, 1, 3, 7])\\n        >>> rh.clear()\\n        >>> rh.pop()\\n        Traceback (most recent call last):\\n            ...\\n        IndexError: Can't get top element for the empty heap.\\n        \\\"\\\"\\\"\\n        self._root = None\\n\\n    def to_sorted_list(self) -> list[Any]:\\n        \\\"\\\"\\\"\\n        Returns sorted list containing all the values in the heap.\\n\\n        >>> rh = RandomizedHeap([3, 1, 3, 7])\\n        >>> rh.to_sorted_list()\\n        [1, 3, 3, 7]\\n        \\\"\\\"\\\"\\n        result = []\\n        while self:\\n            result.append(self.pop())\\n\\n        return result\\n\\n    def __bool__(self) -> bool:\\n        \\\"\\\"\\\"\\n        Check if the heap is not empty.\\n\\n        >>> rh = RandomizedHeap()\\n        >>> bool(rh)\\n        False\\n        >>> rh.insert(1)\\n        >>> bool(rh)\\n        True\\n        >>> rh.clear()\\n        >>> bool(rh)\\n        False\\n        \\\"\\\"\\\"\\n        return self._root is not None\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "skew heap": "\"#!/usr/bin/env python3\\n\\nfrom __future__ import annotations\\n\\nfrom typing import Any, Generic, Iterable, Iterator, TypeVar\\n\\nT = TypeVar(\\\"T\\\", bound=bool)\\n\\n\\nclass SkewNode(Generic[T]):\\n    \\\"\\\"\\\"\\n    One node of the skew heap. Contains the value and references to\\n    two children.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, value: T) -> None:\\n        self._value: T = value\\n        self.left: SkewNode[T] | None = None\\n        self.right: SkewNode[T] | None = None\\n\\n    @property\\n    def value(self) -> T:\\n        \\\"\\\"\\\"Return the value of the node.\\\"\\\"\\\"\\n        return self._value\\n\\n    @staticmethod\\n    def merge(\\n        root1: SkewNode[T] | None, root2: SkewNode[T] | None\\n    ) -> SkewNode[T] | None:\\n        \\\"\\\"\\\"Merge 2 nodes together.\\\"\\\"\\\"\\n        if not root1:\\n            return root2\\n\\n        if not root2:\\n            return root1\\n\\n        if root1.value > root2.value:\\n            root1, root2 = root2, root1\\n\\n        result = root1\\n        temp = root1.right\\n        result.right = root1.left\\n        result.left = SkewNode.merge(temp, root2)\\n\\n        return result\\n\\n\\nclass SkewHeap(Generic[T]):\\n    \\\"\\\"\\\"\\n    A data structure that allows inserting a new value and to pop the smallest\\n    values. Both operations take O(logN) time where N is the size of the\\n    structure.\\n    Wiki: https://en.wikipedia.org/wiki/Skew_heap\\n    Visualization: https://www.cs.usfca.edu/~galles/visualization/SkewHeap.html\\n\\n    >>> list(SkewHeap([2, 3, 1, 5, 1, 7]))\\n    [1, 1, 2, 3, 5, 7]\\n\\n    >>> sh = SkewHeap()\\n    >>> sh.pop()\\n    Traceback (most recent call last):\\n        ...\\n    IndexError: Can't get top element for the empty heap.\\n\\n    >>> sh.insert(1)\\n    >>> sh.insert(-1)\\n    >>> sh.insert(0)\\n    >>> list(sh)\\n    [-1, 0, 1]\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, data: Iterable[T] | None = ()) -> None:\\n\\n        \\\"\\\"\\\"\\n        >>> sh = SkewHeap([3, 1, 3, 7])\\n        >>> list(sh)\\n        [1, 3, 3, 7]\\n        \\\"\\\"\\\"\\n        self._root: SkewNode[T] | None = None\\n        if data:\\n            for item in data:\\n                self.insert(item)\\n\\n    def __bool__(self) -> bool:\\n        \\\"\\\"\\\"\\n        Check if the heap is not empty.\\n\\n        >>> sh = SkewHeap()\\n        >>> bool(sh)\\n        False\\n        >>> sh.insert(1)\\n        >>> bool(sh)\\n        True\\n        >>> sh.clear()\\n        >>> bool(sh)\\n        False\\n        \\\"\\\"\\\"\\n        return self._root is not None\\n\\n    def __iter__(self) -> Iterator[T]:\\n        \\\"\\\"\\\"\\n        Returns sorted list containing all the values in the heap.\\n\\n        >>> sh = SkewHeap([3, 1, 3, 7])\\n        >>> list(sh)\\n        [1, 3, 3, 7]\\n        \\\"\\\"\\\"\\n        result: list[Any] = []\\n        while self:\\n            result.append(self.pop())\\n\\n        # Pushing items back to the heap not to clear it.\\n        for item in result:\\n            self.insert(item)\\n\\n        return iter(result)\\n\\n    def insert(self, value: T) -> None:\\n        \\\"\\\"\\\"\\n        Insert the value into the heap.\\n\\n        >>> sh = SkewHeap()\\n        >>> sh.insert(3)\\n        >>> sh.insert(1)\\n        >>> sh.insert(3)\\n        >>> sh.insert(7)\\n        >>> list(sh)\\n        [1, 3, 3, 7]\\n        \\\"\\\"\\\"\\n        self._root = SkewNode.merge(self._root, SkewNode(value))\\n\\n    def pop(self) -> T | None:\\n        \\\"\\\"\\\"\\n        Pop the smallest value from the heap and return it.\\n\\n        >>> sh = SkewHeap([3, 1, 3, 7])\\n        >>> sh.pop()\\n        1\\n        >>> sh.pop()\\n        3\\n        >>> sh.pop()\\n        3\\n        >>> sh.pop()\\n        7\\n        >>> sh.pop()\\n        Traceback (most recent call last):\\n            ...\\n        IndexError: Can't get top element for the empty heap.\\n        \\\"\\\"\\\"\\n        result = self.top()\\n        self._root = (\\n            SkewNode.merge(self._root.left, self._root.right) if self._root else None\\n        )\\n\\n        return result\\n\\n    def top(self) -> T:\\n        \\\"\\\"\\\"\\n        Return the smallest value from the heap.\\n\\n        >>> sh = SkewHeap()\\n        >>> sh.insert(3)\\n        >>> sh.top()\\n        3\\n        >>> sh.insert(1)\\n        >>> sh.top()\\n        1\\n        >>> sh.insert(3)\\n        >>> sh.top()\\n        1\\n        >>> sh.insert(7)\\n        >>> sh.top()\\n        1\\n        \\\"\\\"\\\"\\n        if not self._root:\\n            raise IndexError(\\\"Can't get top element for the empty heap.\\\")\\n        return self._root.value\\n\\n    def clear(self) -> None:\\n        \\\"\\\"\\\"\\n        Clear the heap.\\n\\n        >>> sh = SkewHeap([3, 1, 3, 7])\\n        >>> sh.clear()\\n        >>> sh.pop()\\n        Traceback (most recent call last):\\n            ...\\n        IndexError: Can't get top element for the empty heap.\\n        \\\"\\\"\\\"\\n        self._root = None\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "circular linked list": "\"from __future__ import annotations\\n\\nfrom typing import Any, Iterator\\n\\n\\nclass Node:\\n    def __init__(self, data: Any):\\n        self.data: Any = data\\n        self.next: Node | None = None\\n\\n\\nclass CircularLinkedList:\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n\\n    def __iter__(self) -> Iterator[Any]:\\n        node = self.head\\n        while self.head:\\n            yield node.data\\n            node = node.next\\n            if node == self.head:\\n                break\\n\\n    def __len__(self) -> int:\\n        return len(tuple(iter(self)))\\n\\n    def __repr__(self):\\n        return \\\"->\\\".join(str(item) for item in iter(self))\\n\\n    def insert_tail(self, data: Any) -> None:\\n        self.insert_nth(len(self), data)\\n\\n    def insert_head(self, data: Any) -> None:\\n        self.insert_nth(0, data)\\n\\n    def insert_nth(self, index: int, data: Any) -> None:\\n        if index < 0 or index > len(self):\\n            raise IndexError(\\\"list index out of range.\\\")\\n        new_node = Node(data)\\n        if self.head is None:\\n            new_node.next = new_node  # first node points itself\\n            self.tail = self.head = new_node\\n        elif index == 0:  # insert at head\\n            new_node.next = self.head\\n            self.head = self.tail.next = new_node\\n        else:\\n            temp = self.head\\n            for _ in range(index - 1):\\n                temp = temp.next\\n            new_node.next = temp.next\\n            temp.next = new_node\\n            if index == len(self) - 1:  # insert at tail\\n                self.tail = new_node\\n\\n    def delete_front(self):\\n        return self.delete_nth(0)\\n\\n    def delete_tail(self) -> Any:\\n        return self.delete_nth(len(self) - 1)\\n\\n    def delete_nth(self, index: int = 0) -> Any:\\n        if not 0 <= index < len(self):\\n            raise IndexError(\\\"list index out of range.\\\")\\n        delete_node = self.head\\n        if self.head == self.tail:  # just one node\\n            self.head = self.tail = None\\n        elif index == 0:  # delete head node\\n            self.tail.next = self.tail.next.next\\n            self.head = self.head.next\\n        else:\\n            temp = self.head\\n            for _ in range(index - 1):\\n                temp = temp.next\\n            delete_node = temp.next\\n            temp.next = temp.next.next\\n            if index == len(self) - 1:  # delete at tail\\n                self.tail = temp\\n        return delete_node.data\\n\\n    def is_empty(self) -> bool:\\n        return len(self) == 0\\n\\n\\ndef test_circular_linked_list() -> None:\\n    \\\"\\\"\\\"\\n    >>> test_circular_linked_list()\\n    \\\"\\\"\\\"\\n    circular_linked_list = CircularLinkedList()\\n    assert len(circular_linked_list) == 0\\n    assert circular_linked_list.is_empty() is True\\n    assert str(circular_linked_list) == \\\"\\\"\\n\\n    try:\\n        circular_linked_list.delete_front()\\n        assert False  # This should not happen\\n    except IndexError:\\n        assert True  # This should happen\\n\\n    try:\\n        circular_linked_list.delete_tail()\\n        assert False  # This should not happen\\n    except IndexError:\\n        assert True  # This should happen\\n\\n    try:\\n        circular_linked_list.delete_nth(-1)\\n        assert False\\n    except IndexError:\\n        assert True\\n\\n    try:\\n        circular_linked_list.delete_nth(0)\\n        assert False\\n    except IndexError:\\n        assert True\\n\\n    assert circular_linked_list.is_empty() is True\\n    for i in range(5):\\n        assert len(circular_linked_list) == i\\n        circular_linked_list.insert_nth(i, i + 1)\\n    assert str(circular_linked_list) == \\\"->\\\".join(str(i) for i in range(1, 6))\\n\\n    circular_linked_list.insert_tail(6)\\n    assert str(circular_linked_list) == \\\"->\\\".join(str(i) for i in range(1, 7))\\n    circular_linked_list.insert_head(0)\\n    assert str(circular_linked_list) == \\\"->\\\".join(str(i) for i in range(0, 7))\\n\\n    assert circular_linked_list.delete_front() == 0\\n    assert circular_linked_list.delete_tail() == 6\\n    assert str(circular_linked_list) == \\\"->\\\".join(str(i) for i in range(1, 6))\\n    assert circular_linked_list.delete_nth(2) == 3\\n\\n    circular_linked_list.insert_nth(2, 3)\\n    assert str(circular_linked_list) == \\\"->\\\".join(str(i) for i in range(1, 6))\\n\\n    assert circular_linked_list.is_empty() is False\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "deque doubly": "\"\\\"\\\"\\\"\\nImplementing Deque using DoublyLinkedList ...\\nOperations:\\n    1. insertion in the front -> O(1)\\n    2. insertion in the end -> O(1)\\n    3. remove from the front -> O(1)\\n    4. remove from the end -> O(1)\\n\\\"\\\"\\\"\\n\\n\\nclass _DoublyLinkedBase:\\n    \\\"\\\"\\\"A Private class (to be inherited)\\\"\\\"\\\"\\n\\n    class _Node:\\n        __slots__ = \\\"_prev\\\", \\\"_data\\\", \\\"_next\\\"\\n\\n        def __init__(self, link_p, element, link_n):\\n            self._prev = link_p\\n            self._data = element\\n            self._next = link_n\\n\\n        def has_next_and_prev(self):\\n            return (\\n                f\\\" Prev -> {self._prev is not None}, Next -> {self._next is not None}\\\"\\n            )\\n\\n    def __init__(self):\\n        self._header = self._Node(None, None, None)\\n        self._trailer = self._Node(None, None, None)\\n        self._header._next = self._trailer\\n        self._trailer._prev = self._header\\n        self._size = 0\\n\\n    def __len__(self):\\n        return self._size\\n\\n    def is_empty(self):\\n        return self.__len__() == 0\\n\\n    def _insert(self, predecessor, e, successor):\\n        # Create new_node by setting it's prev.link -> header\\n        # setting it's next.link -> trailer\\n        new_node = self._Node(predecessor, e, successor)\\n        predecessor._next = new_node\\n        successor._prev = new_node\\n        self._size += 1\\n        return self\\n\\n    def _delete(self, node):\\n        predecessor = node._prev\\n        successor = node._next\\n\\n        predecessor._next = successor\\n        successor._prev = predecessor\\n        self._size -= 1\\n        temp = node._data\\n        node._prev = node._next = node._data = None\\n        del node\\n        return temp\\n\\n\\nclass LinkedDeque(_DoublyLinkedBase):\\n    def first(self):\\n        \\\"\\\"\\\"return first element\\n        >>> d = LinkedDeque()\\n        >>> d.add_first('A').first()\\n        'A'\\n        >>> d.add_first('B').first()\\n        'B'\\n        \\\"\\\"\\\"\\n        if self.is_empty():\\n            raise Exception(\\\"List is empty\\\")\\n        return self._header._next._data\\n\\n    def last(self):\\n        \\\"\\\"\\\"return last element\\n        >>> d = LinkedDeque()\\n        >>> d.add_last('A').last()\\n        'A'\\n        >>> d.add_last('B').last()\\n        'B'\\n        \\\"\\\"\\\"\\n        if self.is_empty():\\n            raise Exception(\\\"List is empty\\\")\\n        return self._trailer._prev._data\\n\\n    # DEque Insert Operations (At the front, At the end)\\n\\n    def add_first(self, element):\\n        \\\"\\\"\\\"insertion in the front\\n        >>> LinkedDeque().add_first('AV').first()\\n        'AV'\\n        \\\"\\\"\\\"\\n        return self._insert(self._header, element, self._header._next)\\n\\n    def add_last(self, element):\\n        \\\"\\\"\\\"insertion in the end\\n        >>> LinkedDeque().add_last('B').last()\\n        'B'\\n        \\\"\\\"\\\"\\n        return self._insert(self._trailer._prev, element, self._trailer)\\n\\n    # DEqueu Remove Operations (At the front, At the end)\\n\\n    def remove_first(self):\\n        \\\"\\\"\\\"removal from the front\\n        >>> d = LinkedDeque()\\n        >>> d.is_empty()\\n        True\\n        >>> d.remove_first()\\n        Traceback (most recent call last):\\n           ...\\n        IndexError: remove_first from empty list\\n        >>> d.add_first('A') # doctest: +ELLIPSIS\\n        <data_structures.linked_list.deque_doubly.LinkedDeque object at ...\\n        >>> d.remove_first()\\n        'A'\\n        >>> d.is_empty()\\n        True\\n        \\\"\\\"\\\"\\n        if self.is_empty():\\n            raise IndexError(\\\"remove_first from empty list\\\")\\n        return self._delete(self._header._next)\\n\\n    def remove_last(self):\\n        \\\"\\\"\\\"removal in the end\\n        >>> d = LinkedDeque()\\n        >>> d.is_empty()\\n        True\\n        >>> d.remove_last()\\n        Traceback (most recent call last):\\n           ...\\n        IndexError: remove_first from empty list\\n        >>> d.add_first('A') # doctest: +ELLIPSIS\\n        <data_structures.linked_list.deque_doubly.LinkedDeque object at ...\\n        >>> d.remove_last()\\n        'A'\\n        >>> d.is_empty()\\n        True\\n        \\\"\\\"\\\"\\n        if self.is_empty():\\n            raise IndexError(\\\"remove_first from empty list\\\")\\n        return self._delete(self._trailer._prev)\\n\"",
    "doubly linked list": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Doubly_linked_list\\n\\\"\\\"\\\"\\n\\n\\nclass Node:\\n    def __init__(self, data):\\n        self.data = data\\n        self.previous = None\\n        self.next = None\\n\\n    def __str__(self):\\n        return f\\\"{self.data}\\\"\\n\\n\\nclass DoublyLinkedList:\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n\\n    def __iter__(self):\\n        \\\"\\\"\\\"\\n        >>> linked_list = DoublyLinkedList()\\n        >>> linked_list.insert_at_head('b')\\n        >>> linked_list.insert_at_head('a')\\n        >>> linked_list.insert_at_tail('c')\\n        >>> tuple(linked_list)\\n        ('a', 'b', 'c')\\n        \\\"\\\"\\\"\\n        node = self.head\\n        while node:\\n            yield node.data\\n            node = node.next\\n\\n    def __str__(self):\\n        \\\"\\\"\\\"\\n        >>> linked_list = DoublyLinkedList()\\n        >>> linked_list.insert_at_tail('a')\\n        >>> linked_list.insert_at_tail('b')\\n        >>> linked_list.insert_at_tail('c')\\n        >>> str(linked_list)\\n        'a->b->c'\\n        \\\"\\\"\\\"\\n        return \\\"->\\\".join([str(item) for item in self])\\n\\n    def __len__(self):\\n        \\\"\\\"\\\"\\n        >>> linked_list = DoublyLinkedList()\\n        >>> for i in range(0, 5):\\n        ...     linked_list.insert_at_nth(i, i + 1)\\n        >>> len(linked_list) == 5\\n        True\\n        \\\"\\\"\\\"\\n        return len(tuple(iter(self)))\\n\\n    def insert_at_head(self, data):\\n        self.insert_at_nth(0, data)\\n\\n    def insert_at_tail(self, data):\\n        self.insert_at_nth(len(self), data)\\n\\n    def insert_at_nth(self, index: int, data):\\n        \\\"\\\"\\\"\\n        >>> linked_list = DoublyLinkedList()\\n        >>> linked_list.insert_at_nth(-1, 666)\\n        Traceback (most recent call last):\\n        ....\\n        IndexError: list index out of range\\n        >>> linked_list.insert_at_nth(1, 666)\\n        Traceback (most recent call last):\\n        ....\\n        IndexError: list index out of range\\n        >>> linked_list.insert_at_nth(0, 2)\\n        >>> linked_list.insert_at_nth(0, 1)\\n        >>> linked_list.insert_at_nth(2, 4)\\n        >>> linked_list.insert_at_nth(2, 3)\\n        >>> str(linked_list)\\n        '1->2->3->4'\\n        >>> linked_list.insert_at_nth(5, 5)\\n        Traceback (most recent call last):\\n        ....\\n        IndexError: list index out of range\\n        \\\"\\\"\\\"\\n        if not 0 <= index <= len(self):\\n            raise IndexError(\\\"list index out of range\\\")\\n        new_node = Node(data)\\n        if self.head is None:\\n            self.head = self.tail = new_node\\n        elif index == 0:\\n            self.head.previous = new_node\\n            new_node.next = self.head\\n            self.head = new_node\\n        elif index == len(self):\\n            self.tail.next = new_node\\n            new_node.previous = self.tail\\n            self.tail = new_node\\n        else:\\n            temp = self.head\\n            for i in range(0, index):\\n                temp = temp.next\\n            temp.previous.next = new_node\\n            new_node.previous = temp.previous\\n            new_node.next = temp\\n            temp.previous = new_node\\n\\n    def delete_head(self):\\n        return self.delete_at_nth(0)\\n\\n    def delete_tail(self):\\n        return self.delete_at_nth(len(self) - 1)\\n\\n    def delete_at_nth(self, index: int):\\n        \\\"\\\"\\\"\\n        >>> linked_list = DoublyLinkedList()\\n        >>> linked_list.delete_at_nth(0)\\n        Traceback (most recent call last):\\n        ....\\n        IndexError: list index out of range\\n        >>> for i in range(0, 5):\\n        ...     linked_list.insert_at_nth(i, i + 1)\\n        >>> linked_list.delete_at_nth(0) == 1\\n        True\\n        >>> linked_list.delete_at_nth(3) == 5\\n        True\\n        >>> linked_list.delete_at_nth(1) == 3\\n        True\\n        >>> str(linked_list)\\n        '2->4'\\n        >>> linked_list.delete_at_nth(2)\\n        Traceback (most recent call last):\\n        ....\\n        IndexError: list index out of range\\n        \\\"\\\"\\\"\\n        if not 0 <= index <= len(self) - 1:\\n            raise IndexError(\\\"list index out of range\\\")\\n        delete_node = self.head  # default first node\\n        if len(self) == 1:\\n            self.head = self.tail = None\\n        elif index == 0:\\n            self.head = self.head.next\\n            self.head.previous = None\\n        elif index == len(self) - 1:\\n            delete_node = self.tail\\n            self.tail = self.tail.previous\\n            self.tail.next = None\\n        else:\\n            temp = self.head\\n            for i in range(0, index):\\n                temp = temp.next\\n            delete_node = temp\\n            temp.next.previous = temp.previous\\n            temp.previous.next = temp.next\\n        return delete_node.data\\n\\n    def delete(self, data) -> str:\\n        current = self.head\\n\\n        while current.data != data:  # Find the position to delete\\n            if current.next:\\n                current = current.next\\n            else:  # We have reached the end an no value matches\\n                return \\\"No data matching given value\\\"\\n\\n        if current == self.head:\\n            self.delete_head()\\n\\n        elif current == self.tail:\\n            self.delete_tail()\\n\\n        else:  # Before: 1 <--> 2(current) <--> 3\\n            current.previous.next = current.next  # 1 --> 3\\n            current.next.previous = current.previous  # 1 <--> 3\\n        return data\\n\\n    def is_empty(self):\\n        \\\"\\\"\\\"\\n        >>> linked_list = DoublyLinkedList()\\n        >>> linked_list.is_empty()\\n        True\\n        >>> linked_list.insert_at_tail(1)\\n        >>> linked_list.is_empty()\\n        False\\n        \\\"\\\"\\\"\\n        return len(self) == 0\\n\\n\\ndef test_doubly_linked_list() -> None:\\n    \\\"\\\"\\\"\\n    >>> test_doubly_linked_list()\\n    \\\"\\\"\\\"\\n    linked_list = DoublyLinkedList()\\n    assert linked_list.is_empty() is True\\n    assert str(linked_list) == \\\"\\\"\\n\\n    try:\\n        linked_list.delete_head()\\n        assert False  # This should not happen.\\n    except IndexError:\\n        assert True  # This should happen.\\n\\n    try:\\n        linked_list.delete_tail()\\n        assert False  # This should not happen.\\n    except IndexError:\\n        assert True  # This should happen.\\n\\n    for i in range(10):\\n        assert len(linked_list) == i\\n        linked_list.insert_at_nth(i, i + 1)\\n    assert str(linked_list) == \\\"->\\\".join(str(i) for i in range(1, 11))\\n\\n    linked_list.insert_at_head(0)\\n    linked_list.insert_at_tail(11)\\n    assert str(linked_list) == \\\"->\\\".join(str(i) for i in range(0, 12))\\n\\n    assert linked_list.delete_head() == 0\\n    assert linked_list.delete_at_nth(9) == 10\\n    assert linked_list.delete_tail() == 11\\n    assert len(linked_list) == 9\\n    assert str(linked_list) == \\\"->\\\".join(str(i) for i in range(1, 10))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "doubly linked list two": "\"\\\"\\\"\\\"\\n- A linked list is similar to an array, it holds values. However, links in a linked\\n    list do not have indexes.\\n- This is an example of a double ended, doubly linked list.\\n- Each link references the next link and the previous one.\\n- A Doubly Linked List (DLL) contains an extra pointer, typically called previous\\n    pointer, together with next pointer and data which are there in singly linked list.\\n - Advantages over SLL - It can be traversed in both forward and backward direction.\\n     Delete operation is more efficient\\n\\\"\\\"\\\"\\n\\n\\nclass Node:\\n    def __init__(self, data: int, previous=None, next_node=None):\\n        self.data = data\\n        self.previous = previous\\n        self.next = next_node\\n\\n    def __str__(self) -> str:\\n        return f\\\"{self.data}\\\"\\n\\n    def get_data(self) -> int:\\n        return self.data\\n\\n    def get_next(self):\\n        return self.next\\n\\n    def get_previous(self):\\n        return self.previous\\n\\n\\nclass LinkedListIterator:\\n    def __init__(self, head):\\n        self.current = head\\n\\n    def __iter__(self):\\n        return self\\n\\n    def __next__(self):\\n        if not self.current:\\n            raise StopIteration\\n        else:\\n            value = self.current.get_data()\\n            self.current = self.current.get_next()\\n            return value\\n\\n\\nclass LinkedList:\\n    def __init__(self):\\n        self.head = None  # First node in list\\n        self.tail = None  # Last node in list\\n\\n    def __str__(self):\\n        current = self.head\\n        nodes = []\\n        while current is not None:\\n            nodes.append(current.get_data())\\n            current = current.get_next()\\n        return \\\" \\\".join(str(node) for node in nodes)\\n\\n    def __contains__(self, value: int):\\n        current = self.head\\n        while current:\\n            if current.get_data() == value:\\n                return True\\n            current = current.get_next()\\n        return False\\n\\n    def __iter__(self):\\n        return LinkedListIterator(self.head)\\n\\n    def get_head_data(self):\\n        if self.head:\\n            return self.head.get_data()\\n        return None\\n\\n    def get_tail_data(self):\\n        if self.tail:\\n            return self.tail.get_data()\\n        return None\\n\\n    def set_head(self, node: Node) -> None:\\n\\n        if self.head is None:\\n            self.head = node\\n            self.tail = node\\n        else:\\n            self.insert_before_node(self.head, node)\\n\\n    def set_tail(self, node: Node) -> None:\\n        if self.head is None:\\n            self.set_head(node)\\n        else:\\n            self.insert_after_node(self.tail, node)\\n\\n    def insert(self, value: int) -> None:\\n        node = Node(value)\\n        if self.head is None:\\n            self.set_head(node)\\n        else:\\n            self.set_tail(node)\\n\\n    def insert_before_node(self, node: Node, node_to_insert: Node) -> None:\\n        node_to_insert.next = node\\n        node_to_insert.previous = node.previous\\n\\n        if node.get_previous() is None:\\n            self.head = node_to_insert\\n        else:\\n            node.previous.next = node_to_insert\\n\\n        node.previous = node_to_insert\\n\\n    def insert_after_node(self, node: Node, node_to_insert: Node) -> None:\\n        node_to_insert.previous = node\\n        node_to_insert.next = node.next\\n\\n        if node.get_next() is None:\\n            self.tail = node_to_insert\\n        else:\\n            node.next.previous = node_to_insert\\n\\n        node.next = node_to_insert\\n\\n    def insert_at_position(self, position: int, value: int) -> None:\\n        current_position = 1\\n        new_node = Node(value)\\n        node = self.head\\n        while node:\\n            if current_position == position:\\n                self.insert_before_node(node, new_node)\\n                return None\\n            current_position += 1\\n            node = node.next\\n        self.insert_after_node(self.tail, new_node)\\n\\n    def get_node(self, item: int) -> Node:\\n        node = self.head\\n        while node:\\n            if node.get_data() == item:\\n                return node\\n            node = node.get_next()\\n        raise Exception(\\\"Node not found\\\")\\n\\n    def delete_value(self, value):\\n        node = self.get_node(value)\\n\\n        if node is not None:\\n            if node == self.head:\\n                self.head = self.head.get_next()\\n\\n            if node == self.tail:\\n                self.tail = self.tail.get_previous()\\n\\n            self.remove_node_pointers(node)\\n\\n    @staticmethod\\n    def remove_node_pointers(node: Node) -> None:\\n        if node.get_next():\\n            node.next.previous = node.previous\\n\\n        if node.get_previous():\\n            node.previous.next = node.next\\n\\n        node.next = None\\n        node.previous = None\\n\\n    def is_empty(self):\\n        return self.head is None\\n\\n\\ndef create_linked_list() -> None:\\n    \\\"\\\"\\\"\\n    >>> new_linked_list = LinkedList()\\n    >>> new_linked_list.get_head_data() is None\\n    True\\n    >>> new_linked_list.get_tail_data() is None\\n    True\\n    >>> new_linked_list.is_empty()\\n    True\\n    >>> new_linked_list.insert(10)\\n    >>> new_linked_list.get_head_data()\\n    10\\n    >>> new_linked_list.get_tail_data()\\n    10\\n    >>> new_linked_list.insert_at_position(position=3, value=20)\\n    >>> new_linked_list.get_head_data()\\n    10\\n    >>> new_linked_list.get_tail_data()\\n    20\\n    >>> new_linked_list.set_head(Node(1000))\\n    >>> new_linked_list.get_head_data()\\n    1000\\n    >>> new_linked_list.get_tail_data()\\n    20\\n    >>> new_linked_list.set_tail(Node(2000))\\n    >>> new_linked_list.get_head_data()\\n    1000\\n    >>> new_linked_list.get_tail_data()\\n    2000\\n    >>> for value in new_linked_list:\\n    ...    print(value)\\n    1000\\n    10\\n    20\\n    2000\\n    >>> new_linked_list.is_empty()\\n    False\\n    >>> for value in new_linked_list:\\n    ...    print(value)\\n    1000\\n    10\\n    20\\n    2000\\n    >>> 10 in new_linked_list\\n    True\\n    >>> new_linked_list.delete_value(value=10)\\n    >>> 10 in new_linked_list\\n    False\\n    >>> new_linked_list.delete_value(value=2000)\\n    >>> new_linked_list.get_tail_data()\\n    20\\n    >>> new_linked_list.delete_value(value=1000)\\n    >>> new_linked_list.get_tail_data()\\n    20\\n    >>> new_linked_list.get_head_data()\\n    20\\n    >>> for value in new_linked_list:\\n    ...    print(value)\\n    20\\n    >>> new_linked_list.delete_value(value=20)\\n    >>> for value in new_linked_list:\\n    ...    print(value)\\n    >>> for value in range(1,10):\\n    ...    new_linked_list.insert(value=value)\\n    >>> for value in new_linked_list:\\n    ...    print(value)\\n    1\\n    2\\n    3\\n    4\\n    5\\n    6\\n    7\\n    8\\n    9\\n    \\\"\\\"\\\"\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "from sequence": "\"# Recursive Prorgam to create a Linked List from a sequence and\\n# print a string representation of it.\\n\\n\\nclass Node:\\n    def __init__(self, data=None):\\n        self.data = data\\n        self.next = None\\n\\n    def __repr__(self):\\n        \\\"\\\"\\\"Returns a visual representation of the node and all its following nodes.\\\"\\\"\\\"\\n        string_rep = \\\"\\\"\\n        temp = self\\n        while temp:\\n            string_rep += f\\\"<{temp.data}> ---> \\\"\\n            temp = temp.next\\n        string_rep += \\\"<END>\\\"\\n        return string_rep\\n\\n\\ndef make_linked_list(elements_list):\\n    \\\"\\\"\\\"Creates a Linked List from the elements of the given sequence\\n    (list/tuple) and returns the head of the Linked List.\\\"\\\"\\\"\\n\\n    # if elements_list is empty\\n    if not elements_list:\\n        raise Exception(\\\"The Elements List is empty\\\")\\n\\n    # Set first element as Head\\n    head = Node(elements_list[0])\\n    current = head\\n    # Loop through elements from position 1\\n    for data in elements_list[1:]:\\n        current.next = Node(data)\\n        current = current.next\\n    return head\\n\\n\\nlist_data = [1, 3, 5, 32, 44, 12, 43]\\nprint(f\\\"List: {list_data}\\\")\\nprint(\\\"Creating Linked List from List.\\\")\\nlinked_list = make_linked_list(list_data)\\nprint(\\\"Linked List:\\\")\\nprint(linked_list)\\n\"",
    "has loop": "\"from __future__ import annotations\\n\\nfrom typing import Any\\n\\n\\nclass ContainsLoopError(Exception):\\n    pass\\n\\n\\nclass Node:\\n    def __init__(self, data: Any) -> None:\\n        self.data: Any = data\\n        self.next_node: Node | None = None\\n\\n    def __iter__(self):\\n        node = self\\n        visited = []\\n        while node:\\n            if node in visited:\\n                raise ContainsLoopError\\n            visited.append(node)\\n            yield node.data\\n            node = node.next_node\\n\\n    @property\\n    def has_loop(self) -> bool:\\n        \\\"\\\"\\\"\\n        A loop is when the exact same Node appears more than once in a linked list.\\n        >>> root_node = Node(1)\\n        >>> root_node.next_node = Node(2)\\n        >>> root_node.next_node.next_node = Node(3)\\n        >>> root_node.next_node.next_node.next_node = Node(4)\\n        >>> root_node.has_loop\\n        False\\n        >>> root_node.next_node.next_node.next_node = root_node.next_node\\n        >>> root_node.has_loop\\n        True\\n        \\\"\\\"\\\"\\n        try:\\n            list(self)\\n            return False\\n        except ContainsLoopError:\\n            return True\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    root_node = Node(1)\\n    root_node.next_node = Node(2)\\n    root_node.next_node.next_node = Node(3)\\n    root_node.next_node.next_node.next_node = Node(4)\\n    print(root_node.has_loop)  # False\\n    root_node.next_node.next_node.next_node = root_node.next_node\\n    print(root_node.has_loop)  # True\\n\\n    root_node = Node(5)\\n    root_node.next_node = Node(6)\\n    root_node.next_node.next_node = Node(5)\\n    root_node.next_node.next_node.next_node = Node(6)\\n    print(root_node.has_loop)  # False\\n\\n    root_node = Node(1)\\n    print(root_node.has_loop)  # False\\n\"",
    "is palindrome": "\"def is_palindrome(head):\\n    if not head:\\n        return True\\n    # split the list to two parts\\n    fast, slow = head.next, head\\n    while fast and fast.next:\\n        fast = fast.next.next\\n        slow = slow.next\\n    second = slow.next\\n    slow.next = None  # Don't forget here! But forget still works!\\n    # reverse the second part\\n    node = None\\n    while second:\\n        nxt = second.next\\n        second.next = node\\n        node = second\\n        second = nxt\\n    # compare two parts\\n    # second part has the same or one less node\\n    while node:\\n        if node.val != head.val:\\n            return False\\n        node = node.next\\n        head = head.next\\n    return True\\n\\n\\ndef is_palindrome_stack(head):\\n    if not head or not head.next:\\n        return True\\n\\n    # 1. Get the midpoint (slow)\\n    slow = fast = cur = head\\n    while fast and fast.next:\\n        fast, slow = fast.next.next, slow.next\\n\\n    # 2. Push the second half into the stack\\n    stack = [slow.val]\\n    while slow.next:\\n        slow = slow.next\\n        stack.append(slow.val)\\n\\n    # 3. Comparison\\n    while stack:\\n        if stack.pop() != cur.val:\\n            return False\\n        cur = cur.next\\n\\n    return True\\n\\n\\ndef is_palindrome_dict(head):\\n    if not head or not head.next:\\n        return True\\n    d = {}\\n    pos = 0\\n    while head:\\n        if head.val in d.keys():\\n            d[head.val].append(pos)\\n        else:\\n            d[head.val] = [pos]\\n        head = head.next\\n        pos += 1\\n    checksum = pos - 1\\n    middle = 0\\n    for v in d.values():\\n        if len(v) % 2 != 0:\\n            middle += 1\\n        else:\\n            step = 0\\n            for i in range(0, len(v)):\\n                if v[i] + v[len(v) - 1 - step] != checksum:\\n                    return False\\n                step += 1\\n        if middle > 1:\\n            return False\\n    return True\\n\"",
    "merge two lists": "\"\\\"\\\"\\\"\\nAlgorithm that merges two sorted linked lists into one sorted linked list.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom collections.abc import Iterable, Iterator\\nfrom dataclasses import dataclass\\n\\ntest_data_odd = (3, 9, -11, 0, 7, 5, 1, -1)\\ntest_data_even = (4, 6, 2, 0, 8, 10, 3, -2)\\n\\n\\n@dataclass\\nclass Node:\\n    data: int\\n    next: Node | None\\n\\n\\nclass SortedLinkedList:\\n    def __init__(self, ints: Iterable[int]) -> None:\\n        self.head: Node | None = None\\n        for i in reversed(sorted(ints)):\\n            self.head = Node(i, self.head)\\n\\n    def __iter__(self) -> Iterator[int]:\\n        \\\"\\\"\\\"\\n        >>> tuple(SortedLinkedList(test_data_odd)) == tuple(sorted(test_data_odd))\\n        True\\n        >>> tuple(SortedLinkedList(test_data_even)) == tuple(sorted(test_data_even))\\n        True\\n        \\\"\\\"\\\"\\n        node = self.head\\n        while node:\\n            yield node.data\\n            node = node.next\\n\\n    def __len__(self) -> int:\\n        \\\"\\\"\\\"\\n        >>> for i in range(3):\\n        ...     len(SortedLinkedList(range(i))) == i\\n        True\\n        True\\n        True\\n        >>> len(SortedLinkedList(test_data_odd))\\n        8\\n        \\\"\\\"\\\"\\n        return len(tuple(iter(self)))\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"\\n        >>> str(SortedLinkedList([]))\\n        ''\\n        >>> str(SortedLinkedList(test_data_odd))\\n        '-11 -> -1 -> 0 -> 1 -> 3 -> 5 -> 7 -> 9'\\n        >>> str(SortedLinkedList(test_data_even))\\n        '-2 -> 0 -> 2 -> 3 -> 4 -> 6 -> 8 -> 10'\\n        \\\"\\\"\\\"\\n        return \\\" -> \\\".join([str(node) for node in self])\\n\\n\\ndef merge_lists(\\n    sll_one: SortedLinkedList, sll_two: SortedLinkedList\\n) -> SortedLinkedList:\\n    \\\"\\\"\\\"\\n    >>> SSL = SortedLinkedList\\n    >>> merged = merge_lists(SSL(test_data_odd), SSL(test_data_even))\\n    >>> len(merged)\\n    16\\n    >>> str(merged)\\n    '-11 -> -2 -> -1 -> 0 -> 0 -> 1 -> 2 -> 3 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10'\\n    >>> list(merged) == list(sorted(test_data_odd + test_data_even))\\n    True\\n    \\\"\\\"\\\"\\n    return SortedLinkedList(list(sll_one) + list(sll_two))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n    SSL = SortedLinkedList\\n    print(merge_lists(SSL(test_data_odd), SSL(test_data_even)))\\n\"",
    "middle element of linked list": "\"from __future__ import annotations\\n\\n\\nclass Node:\\n    def __init__(self, data: int) -> None:\\n        self.data = data\\n        self.next = None\\n\\n\\nclass LinkedList:\\n    def __init__(self):\\n        self.head = None\\n\\n    def push(self, new_data: int) -> int:\\n        new_node = Node(new_data)\\n        new_node.next = self.head\\n        self.head = new_node\\n        return self.head.data\\n\\n    def middle_element(self) -> int | None:\\n        \\\"\\\"\\\"\\n        >>> link = LinkedList()\\n        >>> link.middle_element()\\n        No element found.\\n        >>> link.push(5)\\n        5\\n        >>> link.push(6)\\n        6\\n        >>> link.push(8)\\n        8\\n        >>> link.push(8)\\n        8\\n        >>> link.push(10)\\n        10\\n        >>> link.push(12)\\n        12\\n        >>> link.push(17)\\n        17\\n        >>> link.push(7)\\n        7\\n        >>> link.push(3)\\n        3\\n        >>> link.push(20)\\n        20\\n        >>> link.push(-20)\\n        -20\\n        >>> link.middle_element()\\n        12\\n        >>>\\n        \\\"\\\"\\\"\\n        slow_pointer = self.head\\n        fast_pointer = self.head\\n        if self.head:\\n            while fast_pointer and fast_pointer.next:\\n                fast_pointer = fast_pointer.next.next\\n                slow_pointer = slow_pointer.next\\n            return slow_pointer.data\\n        else:\\n            print(\\\"No element found.\\\")\\n            return None\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    link = LinkedList()\\n    for i in range(int(input().strip())):\\n        data = int(input().strip())\\n        link.push(data)\\n    print(link.middle_element())\\n\"",
    "print reverse": "\"from __future__ import annotations\\n\\n\\nclass Node:\\n    def __init__(self, data=None):\\n        self.data = data\\n        self.next = None\\n\\n    def __repr__(self):\\n        \\\"\\\"\\\"Returns a visual representation of the node and all its following nodes.\\\"\\\"\\\"\\n        string_rep = []\\n        temp = self\\n        while temp:\\n            string_rep.append(f\\\"{temp.data}\\\")\\n            temp = temp.next\\n        return \\\"->\\\".join(string_rep)\\n\\n\\ndef make_linked_list(elements_list: list):\\n    \\\"\\\"\\\"Creates a Linked List from the elements of the given sequence\\n    (list/tuple) and returns the head of the Linked List.\\n    >>> make_linked_list([])\\n    Traceback (most recent call last):\\n        ...\\n    Exception: The Elements List is empty\\n    >>> make_linked_list([7])\\n    7\\n    >>> make_linked_list(['abc'])\\n    abc\\n    >>> make_linked_list([7, 25])\\n    7->25\\n    \\\"\\\"\\\"\\n    if not elements_list:\\n        raise Exception(\\\"The Elements List is empty\\\")\\n\\n    current = head = Node(elements_list[0])\\n    for i in range(1, len(elements_list)):\\n        current.next = Node(elements_list[i])\\n        current = current.next\\n    return head\\n\\n\\ndef print_reverse(head_node: Node) -> None:\\n    \\\"\\\"\\\"Prints the elements of the given Linked List in reverse order\\n    >>> print_reverse([])\\n    >>> linked_list = make_linked_list([69, 88, 73])\\n    >>> print_reverse(linked_list)\\n    73\\n    88\\n    69\\n    \\\"\\\"\\\"\\n    if head_node is not None and isinstance(head_node, Node):\\n        print_reverse(head_node.next)\\n        print(head_node.data)\\n\\n\\ndef main():\\n    from doctest import testmod\\n\\n    testmod()\\n\\n    linked_list = make_linked_list([14, 52, 14, 12, 43])\\n    print(\\\"Linked List:\\\")\\n    print(linked_list)\\n    print(\\\"Elements in Reverse:\\\")\\n    print_reverse(linked_list)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "singly linked list": "\"from typing import Any\\n\\n\\nclass Node:\\n    def __init__(self, data: Any):\\n        \\\"\\\"\\\"\\n        Create and initialize Node class instance.\\n        >>> Node(20)\\n        Node(20)\\n        >>> Node(\\\"Hello, world!\\\")\\n        Node(Hello, world!)\\n        >>> Node(None)\\n        Node(None)\\n        >>> Node(True)\\n        Node(True)\\n        \\\"\\\"\\\"\\n        self.data = data\\n        self.next = None\\n\\n    def __repr__(self) -> str:\\n        \\\"\\\"\\\"\\n        Get the string representation of this node.\\n        >>> Node(10).__repr__()\\n        'Node(10)'\\n        \\\"\\\"\\\"\\n        return f\\\"Node({self.data})\\\"\\n\\n\\nclass LinkedList:\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        Create and initialize LinkedList class instance.\\n        >>> linked_list = LinkedList()\\n        \\\"\\\"\\\"\\n        self.head = None\\n\\n    def __iter__(self) -> Any:\\n        \\\"\\\"\\\"\\n        This function is intended for iterators to access\\n        and iterate through data inside linked list.\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.insert_tail(\\\"tail\\\")\\n        >>> linked_list.insert_tail(\\\"tail_1\\\")\\n        >>> linked_list.insert_tail(\\\"tail_2\\\")\\n        >>> for node in linked_list: # __iter__ used here.\\n        ...     node\\n        'tail'\\n        'tail_1'\\n        'tail_2'\\n        \\\"\\\"\\\"\\n        node = self.head\\n        while node:\\n            yield node.data\\n            node = node.next\\n\\n    def __len__(self) -> int:\\n        \\\"\\\"\\\"\\n        Return length of linked list i.e. number of nodes\\n        >>> linked_list = LinkedList()\\n        >>> len(linked_list)\\n        0\\n        >>> linked_list.insert_tail(\\\"tail\\\")\\n        >>> len(linked_list)\\n        1\\n        >>> linked_list.insert_head(\\\"head\\\")\\n        >>> len(linked_list)\\n        2\\n        >>> _ = linked_list.delete_tail()\\n        >>> len(linked_list)\\n        1\\n        >>> _ = linked_list.delete_head()\\n        >>> len(linked_list)\\n        0\\n        \\\"\\\"\\\"\\n        return len(tuple(iter(self)))\\n\\n    def __repr__(self) -> str:\\n        \\\"\\\"\\\"\\n        String representation/visualization of a Linked Lists\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.insert_tail(1)\\n        >>> linked_list.insert_tail(3)\\n        >>> linked_list.__repr__()\\n        '1->3'\\n        \\\"\\\"\\\"\\n        return \\\"->\\\".join([str(item) for item in self])\\n\\n    def __getitem__(self, index: int) -> Any:\\n        \\\"\\\"\\\"\\n        Indexing Support. Used to get a node at particular position\\n        >>> linked_list = LinkedList()\\n        >>> for i in range(0, 10):\\n        ...     linked_list.insert_nth(i, i)\\n        >>> all(str(linked_list[i]) == str(i) for i in range(0, 10))\\n        True\\n        >>> linked_list[-10]\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: list index out of range.\\n        >>> linked_list[len(linked_list)]\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: list index out of range.\\n        \\\"\\\"\\\"\\n        if not 0 <= index < len(self):\\n            raise ValueError(\\\"list index out of range.\\\")\\n        for i, node in enumerate(self):\\n            if i == index:\\n                return node\\n\\n    # Used to change the data of a particular node\\n    def __setitem__(self, index: int, data: Any) -> None:\\n        \\\"\\\"\\\"\\n        >>> linked_list = LinkedList()\\n        >>> for i in range(0, 10):\\n        ...     linked_list.insert_nth(i, i)\\n        >>> linked_list[0] = 666\\n        >>> linked_list[0]\\n        666\\n        >>> linked_list[5] = -666\\n        >>> linked_list[5]\\n        -666\\n        >>> linked_list[-10] = 666\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: list index out of range.\\n        >>> linked_list[len(linked_list)] = 666\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: list index out of range.\\n        \\\"\\\"\\\"\\n        if not 0 <= index < len(self):\\n            raise ValueError(\\\"list index out of range.\\\")\\n        current = self.head\\n        for i in range(index):\\n            current = current.next\\n        current.data = data\\n\\n    def insert_tail(self, data: Any) -> None:\\n        \\\"\\\"\\\"\\n        Insert data to the end of linked list.\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.insert_tail(\\\"tail\\\")\\n        >>> linked_list\\n        tail\\n        >>> linked_list.insert_tail(\\\"tail_2\\\")\\n        >>> linked_list\\n        tail->tail_2\\n        >>> linked_list.insert_tail(\\\"tail_3\\\")\\n        >>> linked_list\\n        tail->tail_2->tail_3\\n        \\\"\\\"\\\"\\n        self.insert_nth(len(self), data)\\n\\n    def insert_head(self, data: Any) -> None:\\n        \\\"\\\"\\\"\\n        Insert data to the beginning of linked list.\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.insert_head(\\\"head\\\")\\n        >>> linked_list\\n        head\\n        >>> linked_list.insert_head(\\\"head_2\\\")\\n        >>> linked_list\\n        head_2->head\\n        >>> linked_list.insert_head(\\\"head_3\\\")\\n        >>> linked_list\\n        head_3->head_2->head\\n        \\\"\\\"\\\"\\n        self.insert_nth(0, data)\\n\\n    def insert_nth(self, index: int, data: Any) -> None:\\n        \\\"\\\"\\\"\\n        Insert data at given index.\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.insert_tail(\\\"first\\\")\\n        >>> linked_list.insert_tail(\\\"second\\\")\\n        >>> linked_list.insert_tail(\\\"third\\\")\\n        >>> linked_list\\n        first->second->third\\n        >>> linked_list.insert_nth(1, \\\"fourth\\\")\\n        >>> linked_list\\n        first->fourth->second->third\\n        >>> linked_list.insert_nth(3, \\\"fifth\\\")\\n        >>> linked_list\\n        first->fourth->second->fifth->third\\n        \\\"\\\"\\\"\\n        if not 0 <= index <= len(self):\\n            raise IndexError(\\\"list index out of range\\\")\\n        new_node = Node(data)\\n        if self.head is None:\\n            self.head = new_node\\n        elif index == 0:\\n            new_node.next = self.head  # link new_node to head\\n            self.head = new_node\\n        else:\\n            temp = self.head\\n            for _ in range(index - 1):\\n                temp = temp.next\\n            new_node.next = temp.next\\n            temp.next = new_node\\n\\n    def print_list(self) -> None:  # print every node data\\n        \\\"\\\"\\\"\\n        This method prints every node data.\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.insert_tail(\\\"first\\\")\\n        >>> linked_list.insert_tail(\\\"second\\\")\\n        >>> linked_list.insert_tail(\\\"third\\\")\\n        >>> linked_list\\n        first->second->third\\n        \\\"\\\"\\\"\\n        print(self)\\n\\n    def delete_head(self) -> Any:\\n        \\\"\\\"\\\"\\n        Delete the first node and return the\\n        node's data.\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.insert_tail(\\\"first\\\")\\n        >>> linked_list.insert_tail(\\\"second\\\")\\n        >>> linked_list.insert_tail(\\\"third\\\")\\n        >>> linked_list\\n        first->second->third\\n        >>> linked_list.delete_head()\\n        'first'\\n        >>> linked_list\\n        second->third\\n        >>> linked_list.delete_head()\\n        'second'\\n        >>> linked_list\\n        third\\n        >>> linked_list.delete_head()\\n        'third'\\n        >>> linked_list.delete_head()\\n        Traceback (most recent call last):\\n        ...\\n        IndexError: List index out of range.\\n        \\\"\\\"\\\"\\n        return self.delete_nth(0)\\n\\n    def delete_tail(self) -> Any:  # delete from tail\\n        \\\"\\\"\\\"\\n        Delete the tail end node and return the\\n        node's data.\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.insert_tail(\\\"first\\\")\\n        >>> linked_list.insert_tail(\\\"second\\\")\\n        >>> linked_list.insert_tail(\\\"third\\\")\\n        >>> linked_list\\n        first->second->third\\n        >>> linked_list.delete_tail()\\n        'third'\\n        >>> linked_list\\n        first->second\\n        >>> linked_list.delete_tail()\\n        'second'\\n        >>> linked_list\\n        first\\n        >>> linked_list.delete_tail()\\n        'first'\\n        >>> linked_list.delete_tail()\\n        Traceback (most recent call last):\\n        ...\\n        IndexError: List index out of range.\\n        \\\"\\\"\\\"\\n        return self.delete_nth(len(self) - 1)\\n\\n    def delete_nth(self, index: int = 0) -> Any:\\n        \\\"\\\"\\\"\\n        Delete node at given index and return the\\n        node's data.\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.insert_tail(\\\"first\\\")\\n        >>> linked_list.insert_tail(\\\"second\\\")\\n        >>> linked_list.insert_tail(\\\"third\\\")\\n        >>> linked_list\\n        first->second->third\\n        >>> linked_list.delete_nth(1) # delete middle\\n        'second'\\n        >>> linked_list\\n        first->third\\n        >>> linked_list.delete_nth(5) # this raises error\\n        Traceback (most recent call last):\\n        ...\\n        IndexError: List index out of range.\\n        >>> linked_list.delete_nth(-1) # this also raises error\\n        Traceback (most recent call last):\\n        ...\\n        IndexError: List index out of range.\\n        \\\"\\\"\\\"\\n        if not 0 <= index <= len(self) - 1:  # test if index is valid\\n            raise IndexError(\\\"List index out of range.\\\")\\n        delete_node = self.head  # default first node\\n        if index == 0:\\n            self.head = self.head.next\\n        else:\\n            temp = self.head\\n            for _ in range(index - 1):\\n                temp = temp.next\\n            delete_node = temp.next\\n            temp.next = temp.next.next\\n        return delete_node.data\\n\\n    def is_empty(self) -> bool:\\n        \\\"\\\"\\\"\\n        Check if linked list is empty.\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.is_empty()\\n        True\\n        >>> linked_list.insert_head(\\\"first\\\")\\n        >>> linked_list.is_empty()\\n        False\\n        \\\"\\\"\\\"\\n        return self.head is None\\n\\n    def reverse(self) -> None:\\n        \\\"\\\"\\\"\\n        This reverses the linked list order.\\n        >>> linked_list = LinkedList()\\n        >>> linked_list.insert_tail(\\\"first\\\")\\n        >>> linked_list.insert_tail(\\\"second\\\")\\n        >>> linked_list.insert_tail(\\\"third\\\")\\n        >>> linked_list\\n        first->second->third\\n        >>> linked_list.reverse()\\n        >>> linked_list\\n        third->second->first\\n        \\\"\\\"\\\"\\n        prev = None\\n        current = self.head\\n\\n        while current:\\n            # Store the current node's next node.\\n            next_node = current.next\\n            # Make the current node's next point backwards\\n            current.next = prev\\n            # Make the previous node be the current node\\n            prev = current\\n            # Make the current node the next node (to progress iteration)\\n            current = next_node\\n        # Return prev in order to put the head at the end\\n        self.head = prev\\n\\n\\ndef test_singly_linked_list() -> None:\\n    \\\"\\\"\\\"\\n    >>> test_singly_linked_list()\\n    \\\"\\\"\\\"\\n    linked_list = LinkedList()\\n    assert linked_list.is_empty() is True\\n    assert str(linked_list) == \\\"\\\"\\n\\n    try:\\n        linked_list.delete_head()\\n        assert False  # This should not happen.\\n    except IndexError:\\n        assert True  # This should happen.\\n\\n    try:\\n        linked_list.delete_tail()\\n        assert False  # This should not happen.\\n    except IndexError:\\n        assert True  # This should happen.\\n\\n    for i in range(10):\\n        assert len(linked_list) == i\\n        linked_list.insert_nth(i, i + 1)\\n    assert str(linked_list) == \\\"->\\\".join(str(i) for i in range(1, 11))\\n\\n    linked_list.insert_head(0)\\n    linked_list.insert_tail(11)\\n    assert str(linked_list) == \\\"->\\\".join(str(i) for i in range(0, 12))\\n\\n    assert linked_list.delete_head() == 0\\n    assert linked_list.delete_nth(9) == 10\\n    assert linked_list.delete_tail() == 11\\n    assert len(linked_list) == 9\\n    assert str(linked_list) == \\\"->\\\".join(str(i) for i in range(1, 10))\\n\\n    assert all(linked_list[i] == i + 1 for i in range(0, 9)) is True\\n\\n    for i in range(0, 9):\\n        linked_list[i] = -i\\n    assert all(linked_list[i] == -i for i in range(0, 9)) is True\\n\\n    linked_list.reverse()\\n    assert str(linked_list) == \\\"->\\\".join(str(i) for i in range(-8, 1))\\n\\n\\ndef test_singly_linked_list_2() -> None:\\n    \\\"\\\"\\\"\\n    This section of the test used varying data types for input.\\n    >>> test_singly_linked_list_2()\\n    \\\"\\\"\\\"\\n    input = [\\n        -9,\\n        100,\\n        Node(77345112),\\n        \\\"dlrow olleH\\\",\\n        7,\\n        5555,\\n        0,\\n        -192.55555,\\n        \\\"Hello, world!\\\",\\n        77.9,\\n        Node(10),\\n        None,\\n        None,\\n        12.20,\\n    ]\\n    linked_list = LinkedList()\\n\\n    for i in input:\\n        linked_list.insert_tail(i)\\n\\n    # Check if it's empty or not\\n    assert linked_list.is_empty() is False\\n    assert (\\n        str(linked_list) == \\\"-9->100->Node(77345112)->dlrow olleH->7->5555->0->\\\"\\n        \\\"-192.55555->Hello, world!->77.9->Node(10)->None->None->12.2\\\"\\n    )\\n\\n    # Delete the head\\n    result = linked_list.delete_head()\\n    assert result == -9\\n    assert (\\n        str(linked_list) == \\\"100->Node(77345112)->dlrow olleH->7->5555->0->-192.55555->\\\"\\n        \\\"Hello, world!->77.9->Node(10)->None->None->12.2\\\"\\n    )\\n\\n    # Delete the tail\\n    result = linked_list.delete_tail()\\n    assert result == 12.2\\n    assert (\\n        str(linked_list) == \\\"100->Node(77345112)->dlrow olleH->7->5555->0->-192.55555->\\\"\\n        \\\"Hello, world!->77.9->Node(10)->None->None\\\"\\n    )\\n\\n    # Delete a node in specific location in linked list\\n    result = linked_list.delete_nth(10)\\n    assert result is None\\n    assert (\\n        str(linked_list) == \\\"100->Node(77345112)->dlrow olleH->7->5555->0->-192.55555->\\\"\\n        \\\"Hello, world!->77.9->Node(10)->None\\\"\\n    )\\n\\n    # Add a Node instance to its head\\n    linked_list.insert_head(Node(\\\"Hello again, world!\\\"))\\n    assert (\\n        str(linked_list)\\n        == \\\"Node(Hello again, world!)->100->Node(77345112)->dlrow olleH->\\\"\\n        \\\"7->5555->0->-192.55555->Hello, world!->77.9->Node(10)->None\\\"\\n    )\\n\\n    # Add None to its tail\\n    linked_list.insert_tail(None)\\n    assert (\\n        str(linked_list)\\n        == \\\"Node(Hello again, world!)->100->Node(77345112)->dlrow olleH->\\\"\\n        \\\"7->5555->0->-192.55555->Hello, world!->77.9->Node(10)->None->None\\\"\\n    )\\n\\n    # Reverse the linked list\\n    linked_list.reverse()\\n    assert (\\n        str(linked_list)\\n        == \\\"None->None->Node(10)->77.9->Hello, world!->-192.55555->0->5555->\\\"\\n        \\\"7->dlrow olleH->Node(77345112)->100->Node(Hello again, world!)\\\"\\n    )\\n\\n\\ndef main():\\n    from doctest import testmod\\n\\n    testmod()\\n\\n    linked_list = LinkedList()\\n    linked_list.insert_head(input(\\\"Inserting 1st at head \\\").strip())\\n    linked_list.insert_head(input(\\\"Inserting 2nd at head \\\").strip())\\n    print(\\\"\\\\nPrint list:\\\")\\n    linked_list.print_list()\\n    linked_list.insert_tail(input(\\\"\\\\nInserting 1st at tail \\\").strip())\\n    linked_list.insert_tail(input(\\\"Inserting 2nd at tail \\\").strip())\\n    print(\\\"\\\\nPrint list:\\\")\\n    linked_list.print_list()\\n    print(\\\"\\\\nDelete head\\\")\\n    linked_list.delete_head()\\n    print(\\\"Delete tail\\\")\\n    linked_list.delete_tail()\\n    print(\\\"\\\\nPrint list:\\\")\\n    linked_list.print_list()\\n    print(\\\"\\\\nReverse linked list\\\")\\n    linked_list.reverse()\\n    print(\\\"\\\\nPrint list:\\\")\\n    linked_list.print_list()\\n    print(\\\"\\\\nString representation of linked list:\\\")\\n    print(linked_list)\\n    print(\\\"\\\\nReading/changing Node data using indexing:\\\")\\n    print(f\\\"Element at Position 1: {linked_list[1]}\\\")\\n    linked_list[1] = input(\\\"Enter New Value: \\\").strip()\\n    print(\\\"New list:\\\")\\n    print(linked_list)\\n    print(f\\\"length of linked_list is : {len(linked_list)}\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "skip list": "\"\\\"\\\"\\\"\\nBased on \\\"Skip Lists: A Probabilistic Alternative to Balanced Trees\\\" by William Pugh\\nhttps://epaperpress.com/sortsearch/download/skiplist.pdf\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom random import random\\nfrom typing import Generic, TypeVar\\n\\nKT = TypeVar(\\\"KT\\\")\\nVT = TypeVar(\\\"VT\\\")\\n\\n\\nclass Node(Generic[KT, VT]):\\n    def __init__(self, key: KT | str = \\\"root\\\", value: VT | None = None):\\n        self.key = key\\n        self.value = value\\n        self.forward: list[Node[KT, VT]] = []\\n\\n    def __repr__(self) -> str:\\n        \\\"\\\"\\\"\\n        :return: Visual representation of Node\\n\\n        >>> node = Node(\\\"Key\\\", 2)\\n        >>> repr(node)\\n        'Node(Key: 2)'\\n        \\\"\\\"\\\"\\n\\n        return f\\\"Node({self.key}: {self.value})\\\"\\n\\n    @property\\n    def level(self) -> int:\\n        \\\"\\\"\\\"\\n        :return: Number of forward references\\n\\n        >>> node = Node(\\\"Key\\\", 2)\\n        >>> node.level\\n        0\\n        >>> node.forward.append(Node(\\\"Key2\\\", 4))\\n        >>> node.level\\n        1\\n        >>> node.forward.append(Node(\\\"Key3\\\", 6))\\n        >>> node.level\\n        2\\n        \\\"\\\"\\\"\\n\\n        return len(self.forward)\\n\\n\\nclass SkipList(Generic[KT, VT]):\\n    def __init__(self, p: float = 0.5, max_level: int = 16):\\n        self.head: Node[KT, VT] = Node[KT, VT]()\\n        self.level = 0\\n        self.p = p\\n        self.max_level = max_level\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"\\n        :return: Visual representation of SkipList\\n\\n        >>> skip_list = SkipList()\\n        >>> print(skip_list)\\n        SkipList(level=0)\\n        >>> skip_list.insert(\\\"Key1\\\", \\\"Value\\\")\\n        >>> print(skip_list) # doctest: +ELLIPSIS\\n        SkipList(level=...\\n        [root]--...\\n        [Key1]--Key1...\\n        None    *...\\n        >>> skip_list.insert(\\\"Key2\\\", \\\"OtherValue\\\")\\n        >>> print(skip_list) # doctest: +ELLIPSIS\\n        SkipList(level=...\\n        [root]--...\\n        [Key1]--Key1...\\n        [Key2]--Key2...\\n        None    *...\\n        \\\"\\\"\\\"\\n\\n        items = list(self)\\n\\n        if len(items) == 0:\\n            return f\\\"SkipList(level={self.level})\\\"\\n\\n        label_size = max((len(str(item)) for item in items), default=4)\\n        label_size = max(label_size, 4) + 4\\n\\n        node = self.head\\n        lines = []\\n\\n        forwards = node.forward.copy()\\n        lines.append(f\\\"[{node.key}]\\\".ljust(label_size, \\\"-\\\") + \\\"* \\\" * len(forwards))\\n        lines.append(\\\" \\\" * label_size + \\\"| \\\" * len(forwards))\\n\\n        while len(node.forward) != 0:\\n            node = node.forward[0]\\n\\n            lines.append(\\n                f\\\"[{node.key}]\\\".ljust(label_size, \\\"-\\\")\\n                + \\\" \\\".join(str(n.key) if n.key == node.key else \\\"|\\\" for n in forwards)\\n            )\\n            lines.append(\\\" \\\" * label_size + \\\"| \\\" * len(forwards))\\n            forwards[: node.level] = node.forward\\n\\n        lines.append(\\\"None\\\".ljust(label_size) + \\\"* \\\" * len(forwards))\\n        return f\\\"SkipList(level={self.level})\\\\n\\\" + \\\"\\\\n\\\".join(lines)\\n\\n    def __iter__(self):\\n        node = self.head\\n\\n        while len(node.forward) != 0:\\n            yield node.forward[0].key\\n            node = node.forward[0]\\n\\n    def random_level(self) -> int:\\n        \\\"\\\"\\\"\\n        :return: Random level from [1, self.max_level] interval.\\n                 Higher values are less likely.\\n        \\\"\\\"\\\"\\n\\n        level = 1\\n        while random() < self.p and level < self.max_level:\\n            level += 1\\n\\n        return level\\n\\n    def _locate_node(self, key) -> tuple[Node[KT, VT] | None, list[Node[KT, VT]]]:\\n        \\\"\\\"\\\"\\n        :param key: Searched key,\\n        :return: Tuple with searched node (or None if given key is not present)\\n                 and list of nodes that refer (if key is present) of should refer to\\n                 given node.\\n        \\\"\\\"\\\"\\n\\n        # Nodes with refer or should refer to output node\\n        update_vector = []\\n\\n        node = self.head\\n\\n        for i in reversed(range(self.level)):\\n            # i < node.level - When node level is lesser than `i` decrement `i`.\\n            # node.forward[i].key < key - Jumping to node with key value higher\\n            #                             or equal to searched key would result\\n            #                             in skipping searched key.\\n            while i < node.level and node.forward[i].key < key:\\n                node = node.forward[i]\\n            # Each leftmost node (relative to searched node) will potentially have to\\n            # be updated.\\n            update_vector.append(node)\\n\\n        update_vector.reverse()  # Note that we were inserting values in reverse order.\\n\\n        # len(node.forward) != 0 - If current node doesn't contain any further\\n        #                          references then searched key is not present.\\n        # node.forward[0].key == key - Next node key should be equal to search key\\n        #                              if key is present.\\n        if len(node.forward) != 0 and node.forward[0].key == key:\\n            return node.forward[0], update_vector\\n        else:\\n            return None, update_vector\\n\\n    def delete(self, key: KT):\\n        \\\"\\\"\\\"\\n        :param key: Key to remove from list.\\n\\n        >>> skip_list = SkipList()\\n        >>> skip_list.insert(2, \\\"Two\\\")\\n        >>> skip_list.insert(1, \\\"One\\\")\\n        >>> skip_list.insert(3, \\\"Three\\\")\\n        >>> list(skip_list)\\n        [1, 2, 3]\\n        >>> skip_list.delete(2)\\n        >>> list(skip_list)\\n        [1, 3]\\n        \\\"\\\"\\\"\\n\\n        node, update_vector = self._locate_node(key)\\n\\n        if node is not None:\\n            for i, update_node in enumerate(update_vector):\\n                # Remove or replace all references to removed node.\\n                if update_node.level > i and update_node.forward[i].key == key:\\n                    if node.level > i:\\n                        update_node.forward[i] = node.forward[i]\\n                    else:\\n                        update_node.forward = update_node.forward[:i]\\n\\n    def insert(self, key: KT, value: VT):\\n        \\\"\\\"\\\"\\n        :param key: Key to insert.\\n        :param value: Value associated with given key.\\n\\n        >>> skip_list = SkipList()\\n        >>> skip_list.insert(2, \\\"Two\\\")\\n        >>> skip_list.find(2)\\n        'Two'\\n        >>> list(skip_list)\\n        [2]\\n        \\\"\\\"\\\"\\n\\n        node, update_vector = self._locate_node(key)\\n        if node is not None:\\n            node.value = value\\n        else:\\n            level = self.random_level()\\n\\n            if level > self.level:\\n                # After level increase we have to add additional nodes to head.\\n                for i in range(self.level - 1, level):\\n                    update_vector.append(self.head)\\n                self.level = level\\n\\n            new_node = Node(key, value)\\n\\n            for i, update_node in enumerate(update_vector[:level]):\\n                # Change references to pass through new node.\\n                if update_node.level > i:\\n                    new_node.forward.append(update_node.forward[i])\\n\\n                if update_node.level < i + 1:\\n                    update_node.forward.append(new_node)\\n                else:\\n                    update_node.forward[i] = new_node\\n\\n    def find(self, key: VT) -> VT | None:\\n        \\\"\\\"\\\"\\n        :param key: Search key.\\n        :return: Value associated with given key or None if given key is not present.\\n\\n        >>> skip_list = SkipList()\\n        >>> skip_list.find(2)\\n        >>> skip_list.insert(2, \\\"Two\\\")\\n        >>> skip_list.find(2)\\n        'Two'\\n        >>> skip_list.insert(2, \\\"Three\\\")\\n        >>> skip_list.find(2)\\n        'Three'\\n        \\\"\\\"\\\"\\n\\n        node, _ = self._locate_node(key)\\n\\n        if node is not None:\\n            return node.value\\n\\n        return None\\n\\n\\ndef test_insert():\\n    skip_list = SkipList()\\n    skip_list.insert(\\\"Key1\\\", 3)\\n    skip_list.insert(\\\"Key2\\\", 12)\\n    skip_list.insert(\\\"Key3\\\", 41)\\n    skip_list.insert(\\\"Key4\\\", -19)\\n\\n    node = skip_list.head\\n    all_values = {}\\n    while node.level != 0:\\n        node = node.forward[0]\\n        all_values[node.key] = node.value\\n\\n    assert len(all_values) == 4\\n    assert all_values[\\\"Key1\\\"] == 3\\n    assert all_values[\\\"Key2\\\"] == 12\\n    assert all_values[\\\"Key3\\\"] == 41\\n    assert all_values[\\\"Key4\\\"] == -19\\n\\n\\ndef test_insert_overrides_existing_value():\\n    skip_list = SkipList()\\n    skip_list.insert(\\\"Key1\\\", 10)\\n    skip_list.insert(\\\"Key1\\\", 12)\\n\\n    skip_list.insert(\\\"Key5\\\", 7)\\n    skip_list.insert(\\\"Key7\\\", 10)\\n    skip_list.insert(\\\"Key10\\\", 5)\\n\\n    skip_list.insert(\\\"Key7\\\", 7)\\n    skip_list.insert(\\\"Key5\\\", 5)\\n    skip_list.insert(\\\"Key10\\\", 10)\\n\\n    node = skip_list.head\\n    all_values = {}\\n    while node.level != 0:\\n        node = node.forward[0]\\n        all_values[node.key] = node.value\\n\\n    if len(all_values) != 4:\\n        print()\\n    assert len(all_values) == 4\\n    assert all_values[\\\"Key1\\\"] == 12\\n    assert all_values[\\\"Key7\\\"] == 7\\n    assert all_values[\\\"Key5\\\"] == 5\\n    assert all_values[\\\"Key10\\\"] == 10\\n\\n\\ndef test_searching_empty_list_returns_none():\\n    skip_list = SkipList()\\n    assert skip_list.find(\\\"Some key\\\") is None\\n\\n\\ndef test_search():\\n    skip_list = SkipList()\\n\\n    skip_list.insert(\\\"Key2\\\", 20)\\n    assert skip_list.find(\\\"Key2\\\") == 20\\n\\n    skip_list.insert(\\\"Some Key\\\", 10)\\n    skip_list.insert(\\\"Key2\\\", 8)\\n    skip_list.insert(\\\"V\\\", 13)\\n\\n    assert skip_list.find(\\\"Y\\\") is None\\n    assert skip_list.find(\\\"Key2\\\") == 8\\n    assert skip_list.find(\\\"Some Key\\\") == 10\\n    assert skip_list.find(\\\"V\\\") == 13\\n\\n\\ndef test_deleting_item_from_empty_list_do_nothing():\\n    skip_list = SkipList()\\n    skip_list.delete(\\\"Some key\\\")\\n\\n    assert len(skip_list.head.forward) == 0\\n\\n\\ndef test_deleted_items_are_not_founded_by_find_method():\\n    skip_list = SkipList()\\n\\n    skip_list.insert(\\\"Key1\\\", 12)\\n    skip_list.insert(\\\"V\\\", 13)\\n    skip_list.insert(\\\"X\\\", 14)\\n    skip_list.insert(\\\"Key2\\\", 15)\\n\\n    skip_list.delete(\\\"V\\\")\\n    skip_list.delete(\\\"Key2\\\")\\n\\n    assert skip_list.find(\\\"V\\\") is None\\n    assert skip_list.find(\\\"Key2\\\") is None\\n\\n\\ndef test_delete_removes_only_given_key():\\n    skip_list = SkipList()\\n\\n    skip_list.insert(\\\"Key1\\\", 12)\\n    skip_list.insert(\\\"V\\\", 13)\\n    skip_list.insert(\\\"X\\\", 14)\\n    skip_list.insert(\\\"Key2\\\", 15)\\n\\n    skip_list.delete(\\\"V\\\")\\n    assert skip_list.find(\\\"V\\\") is None\\n    assert skip_list.find(\\\"X\\\") == 14\\n    assert skip_list.find(\\\"Key1\\\") == 12\\n    assert skip_list.find(\\\"Key2\\\") == 15\\n\\n    skip_list.delete(\\\"X\\\")\\n    assert skip_list.find(\\\"V\\\") is None\\n    assert skip_list.find(\\\"X\\\") is None\\n    assert skip_list.find(\\\"Key1\\\") == 12\\n    assert skip_list.find(\\\"Key2\\\") == 15\\n\\n    skip_list.delete(\\\"Key1\\\")\\n    assert skip_list.find(\\\"V\\\") is None\\n    assert skip_list.find(\\\"X\\\") is None\\n    assert skip_list.find(\\\"Key1\\\") is None\\n    assert skip_list.find(\\\"Key2\\\") == 15\\n\\n    skip_list.delete(\\\"Key2\\\")\\n    assert skip_list.find(\\\"V\\\") is None\\n    assert skip_list.find(\\\"X\\\") is None\\n    assert skip_list.find(\\\"Key1\\\") is None\\n    assert skip_list.find(\\\"Key2\\\") is None\\n\\n\\ndef test_delete_doesnt_leave_dead_nodes():\\n    skip_list = SkipList()\\n\\n    skip_list.insert(\\\"Key1\\\", 12)\\n    skip_list.insert(\\\"V\\\", 13)\\n    skip_list.insert(\\\"X\\\", 142)\\n    skip_list.insert(\\\"Key2\\\", 15)\\n\\n    skip_list.delete(\\\"X\\\")\\n\\n    def traverse_keys(node):\\n        yield node.key\\n        for forward_node in node.forward:\\n            yield from traverse_keys(forward_node)\\n\\n    assert len(set(traverse_keys(skip_list.head))) == 4\\n\\n\\ndef test_iter_always_yields_sorted_values():\\n    def is_sorted(lst):\\n        for item, next_item in zip(lst, lst[1:]):\\n            if next_item < item:\\n                return False\\n        return True\\n\\n    skip_list = SkipList()\\n    for i in range(10):\\n        skip_list.insert(i, i)\\n    assert is_sorted(list(skip_list))\\n    skip_list.delete(5)\\n    skip_list.delete(8)\\n    skip_list.delete(2)\\n    assert is_sorted(list(skip_list))\\n    skip_list.insert(-12, -12)\\n    skip_list.insert(77, 77)\\n    assert is_sorted(list(skip_list))\\n\\n\\ndef pytests():\\n    for i in range(100):\\n        # Repeat test 100 times due to the probabilistic nature of skip list\\n        # random values == random bugs\\n        test_insert()\\n        test_insert_overrides_existing_value()\\n\\n        test_searching_empty_list_returns_none()\\n        test_search()\\n\\n        test_deleting_item_from_empty_list_do_nothing()\\n        test_deleted_items_are_not_founded_by_find_method()\\n        test_delete_removes_only_given_key()\\n        test_delete_doesnt_leave_dead_nodes()\\n\\n        test_iter_always_yields_sorted_values()\\n\\n\\ndef main():\\n    \\\"\\\"\\\"\\n    >>> pytests()\\n    \\\"\\\"\\\"\\n\\n    skip_list = SkipList()\\n    skip_list.insert(2, \\\"2\\\")\\n    skip_list.insert(4, \\\"4\\\")\\n    skip_list.insert(6, \\\"4\\\")\\n    skip_list.insert(4, \\\"5\\\")\\n    skip_list.insert(8, \\\"4\\\")\\n    skip_list.insert(9, \\\"4\\\")\\n\\n    skip_list.delete(4)\\n\\n    print(skip_list)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "swap nodes": "\"from typing import Any\\r\\n\\r\\n\\r\\nclass Node:\\r\\n    def __init__(self, data: Any):\\r\\n        self.data = data\\r\\n        self.next = None\\r\\n\\r\\n\\r\\nclass LinkedList:\\r\\n    def __init__(self):\\r\\n        self.head = None\\r\\n\\r\\n    def print_list(self):\\r\\n        temp = self.head\\r\\n        while temp is not None:\\r\\n            print(temp.data, end=\\\" \\\")\\r\\n            temp = temp.next\\r\\n        print()\\r\\n\\r\\n    # adding nodes\\r\\n    def push(self, new_data: Any):\\r\\n        new_node = Node(new_data)\\r\\n        new_node.next = self.head\\r\\n        self.head = new_node\\r\\n\\r\\n    # swapping nodes\\r\\n    def swap_nodes(self, node_data_1, node_data_2):\\r\\n        if node_data_1 == node_data_2:\\r\\n            return\\r\\n        else:\\r\\n            node_1 = self.head\\r\\n            while node_1 is not None and node_1.data != node_data_1:\\r\\n                node_1 = node_1.next\\r\\n\\r\\n            node_2 = self.head\\r\\n            while node_2 is not None and node_2.data != node_data_2:\\r\\n                node_2 = node_2.next\\r\\n\\r\\n            if node_1 is None or node_2 is None:\\r\\n                return\\r\\n\\r\\n            node_1.data, node_2.data = node_2.data, node_1.data\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    ll = LinkedList()\\r\\n    for i in range(5, 0, -1):\\r\\n        ll.push(i)\\r\\n\\r\\n    ll.print_list()\\r\\n\\r\\n    ll.swap_nodes(1, 4)\\r\\n    print(\\\"After swapping\\\")\\r\\n    ll.print_list()\\r\\n\"",
    "circular queue": "\"# Implementation of Circular Queue (using Python lists)\\n\\n\\nclass CircularQueue:\\n    \\\"\\\"\\\"Circular FIFO queue with a fixed capacity\\\"\\\"\\\"\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.array = [None] * self.n\\n        self.front = 0  # index of the first element\\n        self.rear = 0\\n        self.size = 0\\n\\n    def __len__(self) -> int:\\n        \\\"\\\"\\\"\\n        >>> cq = CircularQueue(5)\\n        >>> len(cq)\\n        0\\n        >>> cq.enqueue(\\\"A\\\")  # doctest: +ELLIPSIS\\n        <data_structures.queue.circular_queue.CircularQueue object at ...\\n        >>> len(cq)\\n        1\\n        \\\"\\\"\\\"\\n        return self.size\\n\\n    def is_empty(self) -> bool:\\n        \\\"\\\"\\\"\\n        >>> cq = CircularQueue(5)\\n        >>> cq.is_empty()\\n        True\\n        >>> cq.enqueue(\\\"A\\\").is_empty()\\n        False\\n        \\\"\\\"\\\"\\n        return self.size == 0\\n\\n    def first(self):\\n        \\\"\\\"\\\"\\n        >>> cq = CircularQueue(5)\\n        >>> cq.first()\\n        False\\n        >>> cq.enqueue(\\\"A\\\").first()\\n        'A'\\n        \\\"\\\"\\\"\\n        return False if self.is_empty() else self.array[self.front]\\n\\n    def enqueue(self, data):\\n        \\\"\\\"\\\"\\n        This function insert an element in the queue using self.rear value as an index\\n        >>> cq = CircularQueue(5)\\n        >>> cq.enqueue(\\\"A\\\")  # doctest: +ELLIPSIS\\n        <data_structures.queue.circular_queue.CircularQueue object at ...\\n        >>> (cq.size, cq.first())\\n        (1, 'A')\\n        >>> cq.enqueue(\\\"B\\\")  # doctest: +ELLIPSIS\\n        <data_structures.queue.circular_queue.CircularQueue object at ...\\n        >>> (cq.size, cq.first())\\n        (2, 'A')\\n        \\\"\\\"\\\"\\n        if self.size >= self.n:\\n            raise Exception(\\\"QUEUE IS FULL\\\")\\n\\n        self.array[self.rear] = data\\n        self.rear = (self.rear + 1) % self.n\\n        self.size += 1\\n        return self\\n\\n    def dequeue(self):\\n        \\\"\\\"\\\"\\n        This function removes an element from the queue using on self.front value as an\\n        index\\n        >>> cq = CircularQueue(5)\\n        >>> cq.dequeue()\\n        Traceback (most recent call last):\\n           ...\\n        Exception: UNDERFLOW\\n        >>> cq.enqueue(\\\"A\\\").enqueue(\\\"B\\\").dequeue()\\n        'A'\\n        >>> (cq.size, cq.first())\\n        (1, 'B')\\n        >>> cq.dequeue()\\n        'B'\\n        >>> cq.dequeue()\\n        Traceback (most recent call last):\\n           ...\\n        Exception: UNDERFLOW\\n        \\\"\\\"\\\"\\n        if self.size == 0:\\n            raise Exception(\\\"UNDERFLOW\\\")\\n\\n        temp = self.array[self.front]\\n        self.array[self.front] = None\\n        self.front = (self.front + 1) % self.n\\n        self.size -= 1\\n        return temp\\n\"",
    "circular queue linked list": "\"# Implementation of Circular Queue using linked lists\\n# https://en.wikipedia.org/wiki/Circular_buffer\\n\\nfrom __future__ import annotations\\n\\nfrom typing import Any\\n\\n\\nclass CircularQueueLinkedList:\\n    \\\"\\\"\\\"\\n    Circular FIFO list with the given capacity (default queue length : 6)\\n\\n    >>> cq = CircularQueueLinkedList(2)\\n    >>> cq.enqueue('a')\\n    >>> cq.enqueue('b')\\n    >>> cq.enqueue('c')\\n    Traceback (most recent call last):\\n       ...\\n    Exception: Full Queue\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, initial_capacity: int = 6) -> None:\\n        self.front: Node | None = None\\n        self.rear: Node | None = None\\n        self.create_linked_list(initial_capacity)\\n\\n    def create_linked_list(self, initial_capacity: int) -> None:\\n        current_node = Node()\\n        self.front = current_node\\n        self.rear = current_node\\n        previous_node = current_node\\n        for _ in range(1, initial_capacity):\\n            current_node = Node()\\n            previous_node.next = current_node\\n            current_node.prev = previous_node\\n            previous_node = current_node\\n        previous_node.next = self.front\\n        self.front.prev = previous_node\\n\\n    def is_empty(self) -> bool:\\n        \\\"\\\"\\\"\\n        Checks where the queue is empty or not\\n        >>> cq = CircularQueueLinkedList()\\n        >>> cq.is_empty()\\n        True\\n        >>> cq.enqueue('a')\\n        >>> cq.is_empty()\\n        False\\n        >>> cq.dequeue()\\n        'a'\\n        >>> cq.is_empty()\\n        True\\n        \\\"\\\"\\\"\\n\\n        return (\\n            self.front == self.rear\\n            and self.front is not None\\n            and self.front.data is None\\n        )\\n\\n    def first(self) -> Any | None:\\n        \\\"\\\"\\\"\\n        Returns the first element of the queue\\n        >>> cq = CircularQueueLinkedList()\\n        >>> cq.first()\\n        Traceback (most recent call last):\\n           ...\\n        Exception: Empty Queue\\n        >>> cq.enqueue('a')\\n        >>> cq.first()\\n        'a'\\n        >>> cq.dequeue()\\n        'a'\\n        >>> cq.first()\\n        Traceback (most recent call last):\\n           ...\\n        Exception: Empty Queue\\n        >>> cq.enqueue('b')\\n        >>> cq.enqueue('c')\\n        >>> cq.first()\\n        'b'\\n        \\\"\\\"\\\"\\n        self.check_can_perform_operation()\\n        return self.front.data if self.front else None\\n\\n    def enqueue(self, data: Any) -> None:\\n        \\\"\\\"\\\"\\n        Saves data at the end of the queue\\n\\n        >>> cq = CircularQueueLinkedList()\\n        >>> cq.enqueue('a')\\n        >>> cq.enqueue('b')\\n        >>> cq.dequeue()\\n        'a'\\n        >>> cq.dequeue()\\n        'b'\\n        >>> cq.dequeue()\\n        Traceback (most recent call last):\\n           ...\\n        Exception: Empty Queue\\n        \\\"\\\"\\\"\\n        if self.rear is None:\\n            return\\n\\n        self.check_is_full()\\n        if not self.is_empty():\\n            self.rear = self.rear.next\\n        if self.rear:\\n            self.rear.data = data\\n\\n    def dequeue(self) -> Any:\\n        \\\"\\\"\\\"\\n        Removes and retrieves the first element of the queue\\n\\n        >>> cq = CircularQueueLinkedList()\\n        >>> cq.dequeue()\\n        Traceback (most recent call last):\\n           ...\\n        Exception: Empty Queue\\n        >>> cq.enqueue('a')\\n        >>> cq.dequeue()\\n        'a'\\n        >>> cq.dequeue()\\n        Traceback (most recent call last):\\n           ...\\n        Exception: Empty Queue\\n        \\\"\\\"\\\"\\n        self.check_can_perform_operation()\\n        if self.rear is None or self.front is None:\\n            return\\n        if self.front == self.rear:\\n            data = self.front.data\\n            self.front.data = None\\n            return data\\n\\n        old_front = self.front\\n        self.front = old_front.next\\n        data = old_front.data\\n        old_front.data = None\\n        return data\\n\\n    def check_can_perform_operation(self) -> None:\\n        if self.is_empty():\\n            raise Exception(\\\"Empty Queue\\\")\\n\\n    def check_is_full(self) -> None:\\n        if self.rear and self.rear.next == self.front:\\n            raise Exception(\\\"Full Queue\\\")\\n\\n\\nclass Node:\\n    def __init__(self) -> None:\\n        self.data: Any | None = None\\n        self.next: Node | None = None\\n        self.prev: Node | None = None\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "double ended queue": "\"\\\"\\\"\\\"\\nImplementation of double ended queue.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom dataclasses import dataclass\\nfrom typing import Any, Iterable\\n\\n\\nclass Deque:\\n    \\\"\\\"\\\"\\n    Deque data structure.\\n    Operations\\n    ----------\\n    append(val: Any) -> None\\n    appendleft(val: Any) -> None\\n    extend(iter: Iterable) -> None\\n    extendleft(iter: Iterable) -> None\\n    pop() -> Any\\n    popleft() -> Any\\n    Observers\\n    ---------\\n    is_empty() -> bool\\n    Attributes\\n    ----------\\n    _front: _Node\\n        front of the deque a.k.a. the first element\\n    _back: _Node\\n        back of the element a.k.a. the last element\\n    _len: int\\n        the number of nodes\\n    \\\"\\\"\\\"\\n\\n    __slots__ = [\\\"_front\\\", \\\"_back\\\", \\\"_len\\\"]\\n\\n    @dataclass\\n    class _Node:\\n        \\\"\\\"\\\"\\n        Representation of a node.\\n        Contains a value and a pointer to the next node as well as to the previous one.\\n        \\\"\\\"\\\"\\n\\n        val: Any = None\\n        next: Deque._Node | None = None\\n        prev: Deque._Node | None = None\\n\\n    class _Iterator:\\n        \\\"\\\"\\\"\\n        Helper class for iteration. Will be used to implement iteration.\\n        Attributes\\n        ----------\\n        _cur: _Node\\n            the current node of the iteration.\\n        \\\"\\\"\\\"\\n\\n        __slots__ = [\\\"_cur\\\"]\\n\\n        def __init__(self, cur: Deque._Node | None) -> None:\\n            self._cur = cur\\n\\n        def __iter__(self) -> Deque._Iterator:\\n            \\\"\\\"\\\"\\n            >>> our_deque = Deque([1, 2, 3])\\n            >>> iterator = iter(our_deque)\\n            \\\"\\\"\\\"\\n            return self\\n\\n        def __next__(self) -> Any:\\n            \\\"\\\"\\\"\\n            >>> our_deque = Deque([1, 2, 3])\\n            >>> iterator = iter(our_deque)\\n            >>> next(iterator)\\n            1\\n            >>> next(iterator)\\n            2\\n            >>> next(iterator)\\n            3\\n            \\\"\\\"\\\"\\n            if self._cur is None:\\n                # finished iterating\\n                raise StopIteration\\n            val = self._cur.val\\n            self._cur = self._cur.next\\n\\n            return val\\n\\n    def __init__(self, iterable: Iterable[Any] | None = None) -> None:\\n        self._front: Any = None\\n        self._back: Any = None\\n        self._len: int = 0\\n\\n        if iterable is not None:\\n            # append every value to the deque\\n            for val in iterable:\\n                self.append(val)\\n\\n    def append(self, val: Any) -> None:\\n        \\\"\\\"\\\"\\n        Adds val to the end of the deque.\\n        Time complexity: O(1)\\n        >>> our_deque_1 = Deque([1, 2, 3])\\n        >>> our_deque_1.append(4)\\n        >>> our_deque_1\\n        [1, 2, 3, 4]\\n        >>> our_deque_2 = Deque('ab')\\n        >>> our_deque_2.append('c')\\n        >>> our_deque_2\\n        ['a', 'b', 'c']\\n        >>> from collections import deque\\n        >>> deque_collections_1 = deque([1, 2, 3])\\n        >>> deque_collections_1.append(4)\\n        >>> deque_collections_1\\n        deque([1, 2, 3, 4])\\n        >>> deque_collections_2 = deque('ab')\\n        >>> deque_collections_2.append('c')\\n        >>> deque_collections_2\\n        deque(['a', 'b', 'c'])\\n        >>> list(our_deque_1) == list(deque_collections_1)\\n        True\\n        >>> list(our_deque_2) == list(deque_collections_2)\\n        True\\n        \\\"\\\"\\\"\\n        node = self._Node(val, None, None)\\n        if self.is_empty():\\n            # front = back\\n            self._front = self._back = node\\n            self._len = 1\\n        else:\\n            # connect nodes\\n            self._back.next = node\\n            node.prev = self._back\\n            self._back = node  # assign new back to the new node\\n\\n            self._len += 1\\n\\n            # make sure there were no errors\\n            assert not self.is_empty(), \\\"Error on appending value.\\\"\\n\\n    def appendleft(self, val: Any) -> None:\\n        \\\"\\\"\\\"\\n        Adds val to the beginning of the deque.\\n        Time complexity: O(1)\\n        >>> our_deque_1 = Deque([2, 3])\\n        >>> our_deque_1.appendleft(1)\\n        >>> our_deque_1\\n        [1, 2, 3]\\n        >>> our_deque_2 = Deque('bc')\\n        >>> our_deque_2.appendleft('a')\\n        >>> our_deque_2\\n        ['a', 'b', 'c']\\n        >>> from collections import deque\\n        >>> deque_collections_1 = deque([2, 3])\\n        >>> deque_collections_1.appendleft(1)\\n        >>> deque_collections_1\\n        deque([1, 2, 3])\\n        >>> deque_collections_2 = deque('bc')\\n        >>> deque_collections_2.appendleft('a')\\n        >>> deque_collections_2\\n        deque(['a', 'b', 'c'])\\n        >>> list(our_deque_1) == list(deque_collections_1)\\n        True\\n        >>> list(our_deque_2) == list(deque_collections_2)\\n        True\\n        \\\"\\\"\\\"\\n        node = self._Node(val, None, None)\\n        if self.is_empty():\\n            # front = back\\n            self._front = self._back = node\\n            self._len = 1\\n        else:\\n            # connect nodes\\n            node.next = self._front\\n            self._front.prev = node\\n            self._front = node  # assign new front to the new node\\n\\n            self._len += 1\\n\\n            # make sure there were no errors\\n            assert not self.is_empty(), \\\"Error on appending value.\\\"\\n\\n    def extend(self, iter: Iterable[Any]) -> None:\\n        \\\"\\\"\\\"\\n        Appends every value of iter to the end of the deque.\\n        Time complexity: O(n)\\n        >>> our_deque_1 = Deque([1, 2, 3])\\n        >>> our_deque_1.extend([4, 5])\\n        >>> our_deque_1\\n        [1, 2, 3, 4, 5]\\n        >>> our_deque_2 = Deque('ab')\\n        >>> our_deque_2.extend('cd')\\n        >>> our_deque_2\\n        ['a', 'b', 'c', 'd']\\n        >>> from collections import deque\\n        >>> deque_collections_1 = deque([1, 2, 3])\\n        >>> deque_collections_1.extend([4, 5])\\n        >>> deque_collections_1\\n        deque([1, 2, 3, 4, 5])\\n        >>> deque_collections_2 = deque('ab')\\n        >>> deque_collections_2.extend('cd')\\n        >>> deque_collections_2\\n        deque(['a', 'b', 'c', 'd'])\\n        >>> list(our_deque_1) == list(deque_collections_1)\\n        True\\n        >>> list(our_deque_2) == list(deque_collections_2)\\n        True\\n        \\\"\\\"\\\"\\n        for val in iter:\\n            self.append(val)\\n\\n    def extendleft(self, iter: Iterable[Any]) -> None:\\n        \\\"\\\"\\\"\\n        Appends every value of iter to the beginning of the deque.\\n        Time complexity: O(n)\\n        >>> our_deque_1 = Deque([1, 2, 3])\\n        >>> our_deque_1.extendleft([0, -1])\\n        >>> our_deque_1\\n        [-1, 0, 1, 2, 3]\\n        >>> our_deque_2 = Deque('cd')\\n        >>> our_deque_2.extendleft('ba')\\n        >>> our_deque_2\\n        ['a', 'b', 'c', 'd']\\n        >>> from collections import deque\\n        >>> deque_collections_1 = deque([1, 2, 3])\\n        >>> deque_collections_1.extendleft([0, -1])\\n        >>> deque_collections_1\\n        deque([-1, 0, 1, 2, 3])\\n        >>> deque_collections_2 = deque('cd')\\n        >>> deque_collections_2.extendleft('ba')\\n        >>> deque_collections_2\\n        deque(['a', 'b', 'c', 'd'])\\n        >>> list(our_deque_1) == list(deque_collections_1)\\n        True\\n        >>> list(our_deque_2) == list(deque_collections_2)\\n        True\\n        \\\"\\\"\\\"\\n        for val in iter:\\n            self.appendleft(val)\\n\\n    def pop(self) -> Any:\\n        \\\"\\\"\\\"\\n        Removes the last element of the deque and returns it.\\n        Time complexity: O(1)\\n        @returns topop.val: the value of the node to pop.\\n        >>> our_deque = Deque([1, 2, 3, 15182])\\n        >>> our_popped = our_deque.pop()\\n        >>> our_popped\\n        15182\\n        >>> our_deque\\n        [1, 2, 3]\\n        >>> from collections import deque\\n        >>> deque_collections = deque([1, 2, 3, 15182])\\n        >>> collections_popped = deque_collections.pop()\\n        >>> collections_popped\\n        15182\\n        >>> deque_collections\\n        deque([1, 2, 3])\\n        >>> list(our_deque) == list(deque_collections)\\n        True\\n        >>> our_popped == collections_popped\\n        True\\n        \\\"\\\"\\\"\\n        # make sure the deque has elements to pop\\n        assert not self.is_empty(), \\\"Deque is empty.\\\"\\n\\n        topop = self._back\\n        self._back = self._back.prev  # set new back\\n        self._back.next = (\\n            None  # drop the last node - python will deallocate memory automatically\\n        )\\n\\n        self._len -= 1\\n\\n        return topop.val\\n\\n    def popleft(self) -> Any:\\n        \\\"\\\"\\\"\\n        Removes the first element of the deque and returns it.\\n        Time complexity: O(1)\\n        @returns topop.val: the value of the node to pop.\\n        >>> our_deque = Deque([15182, 1, 2, 3])\\n        >>> our_popped = our_deque.popleft()\\n        >>> our_popped\\n        15182\\n        >>> our_deque\\n        [1, 2, 3]\\n        >>> from collections import deque\\n        >>> deque_collections = deque([15182, 1, 2, 3])\\n        >>> collections_popped = deque_collections.popleft()\\n        >>> collections_popped\\n        15182\\n        >>> deque_collections\\n        deque([1, 2, 3])\\n        >>> list(our_deque) == list(deque_collections)\\n        True\\n        >>> our_popped == collections_popped\\n        True\\n        \\\"\\\"\\\"\\n        # make sure the deque has elements to pop\\n        assert not self.is_empty(), \\\"Deque is empty.\\\"\\n\\n        topop = self._front\\n        self._front = self._front.next  # set new front and drop the first node\\n        self._front.prev = None\\n\\n        self._len -= 1\\n\\n        return topop.val\\n\\n    def is_empty(self) -> bool:\\n        \\\"\\\"\\\"\\n        Checks if the deque is empty.\\n        Time complexity: O(1)\\n        >>> our_deque = Deque([1, 2, 3])\\n        >>> our_deque.is_empty()\\n        False\\n        >>> our_empty_deque = Deque()\\n        >>> our_empty_deque.is_empty()\\n        True\\n        >>> from collections import deque\\n        >>> empty_deque_collections = deque()\\n        >>> list(our_empty_deque) == list(empty_deque_collections)\\n        True\\n        \\\"\\\"\\\"\\n        return self._front is None\\n\\n    def __len__(self) -> int:\\n        \\\"\\\"\\\"\\n        Implements len() function. Returns the length of the deque.\\n        Time complexity: O(1)\\n        >>> our_deque = Deque([1, 2, 3])\\n        >>> len(our_deque)\\n        3\\n        >>> our_empty_deque = Deque()\\n        >>> len(our_empty_deque)\\n        0\\n        >>> from collections import deque\\n        >>> deque_collections = deque([1, 2, 3])\\n        >>> len(deque_collections)\\n        3\\n        >>> empty_deque_collections = deque()\\n        >>> len(empty_deque_collections)\\n        0\\n        >>> len(our_empty_deque) == len(empty_deque_collections)\\n        True\\n        \\\"\\\"\\\"\\n        return self._len\\n\\n    def __eq__(self, other: object) -> bool:\\n        \\\"\\\"\\\"\\n        Implements \\\"==\\\" operator. Returns if *self* is equal to *other*.\\n        Time complexity: O(n)\\n        >>> our_deque_1 = Deque([1, 2, 3])\\n        >>> our_deque_2 = Deque([1, 2, 3])\\n        >>> our_deque_1 == our_deque_2\\n        True\\n        >>> our_deque_3 = Deque([1, 2])\\n        >>> our_deque_1 == our_deque_3\\n        False\\n        >>> from collections import deque\\n        >>> deque_collections_1 = deque([1, 2, 3])\\n        >>> deque_collections_2 = deque([1, 2, 3])\\n        >>> deque_collections_1 == deque_collections_2\\n        True\\n        >>> deque_collections_3 = deque([1, 2])\\n        >>> deque_collections_1 == deque_collections_3\\n        False\\n        >>> (our_deque_1 == our_deque_2) == (deque_collections_1 == deque_collections_2)\\n        True\\n        >>> (our_deque_1 == our_deque_3) == (deque_collections_1 == deque_collections_3)\\n        True\\n        \\\"\\\"\\\"\\n\\n        if not isinstance(other, Deque):\\n            return NotImplemented\\n\\n        me = self._front\\n        oth = other._front\\n\\n        # if the length of the deques are not the same, they are not equal\\n        if len(self) != len(other):\\n            return False\\n\\n        while me is not None and oth is not None:\\n            # compare every value\\n            if me.val != oth.val:\\n                return False\\n            me = me.next\\n            oth = oth.next\\n\\n        return True\\n\\n    def __iter__(self) -> Deque._Iterator:\\n        \\\"\\\"\\\"\\n        Implements iteration.\\n        Time complexity: O(1)\\n        >>> our_deque = Deque([1, 2, 3])\\n        >>> for v in our_deque:\\n        ...     print(v)\\n        1\\n        2\\n        3\\n        >>> from collections import deque\\n        >>> deque_collections = deque([1, 2, 3])\\n        >>> for v in deque_collections:\\n        ...     print(v)\\n        1\\n        2\\n        3\\n        \\\"\\\"\\\"\\n        return Deque._Iterator(self._front)\\n\\n    def __repr__(self) -> str:\\n        \\\"\\\"\\\"\\n        Implements representation of the deque.\\n        Represents it as a list, with its values between '[' and ']'.\\n        Time complexity: O(n)\\n        >>> our_deque = Deque([1, 2, 3])\\n        >>> our_deque\\n        [1, 2, 3]\\n        \\\"\\\"\\\"\\n        values_list = []\\n        aux = self._front\\n        while aux is not None:\\n            # append the values in a list to display\\n            values_list.append(aux.val)\\n            aux = aux.next\\n\\n        return \\\"[\\\" + \\\", \\\".join(repr(val) for val in values_list) + \\\"]\\\"\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "linked queue": "\"\\\"\\\"\\\" A Queue using a linked list like structure \\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom typing import Any, Iterator\\n\\n\\nclass Node:\\n    def __init__(self, data: Any) -> None:\\n        self.data: Any = data\\n        self.next: Node | None = None\\n\\n    def __str__(self) -> str:\\n        return f\\\"{self.data}\\\"\\n\\n\\nclass LinkedQueue:\\n    \\\"\\\"\\\"\\n    >>> queue = LinkedQueue()\\n    >>> queue.is_empty()\\n    True\\n    >>> queue.put(5)\\n    >>> queue.put(9)\\n    >>> queue.put('python')\\n    >>> queue.is_empty();\\n    False\\n    >>> queue.get()\\n    5\\n    >>> queue.put('algorithms')\\n    >>> queue.get()\\n    9\\n    >>> queue.get()\\n    'python'\\n    >>> queue.get()\\n    'algorithms'\\n    >>> queue.is_empty()\\n    True\\n    >>> queue.get()\\n    Traceback (most recent call last):\\n        ...\\n    IndexError: dequeue from empty queue\\n    \\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.front: Node | None = None\\n        self.rear: Node | None = None\\n\\n    def __iter__(self) -> Iterator[Any]:\\n        node = self.front\\n        while node:\\n            yield node.data\\n            node = node.next\\n\\n    def __len__(self) -> int:\\n        \\\"\\\"\\\"\\n        >>> queue = LinkedQueue()\\n        >>> for i in range(1, 6):\\n        ...     queue.put(i)\\n        >>> len(queue)\\n        5\\n        >>> for i in range(1, 6):\\n        ...     assert len(queue) == 6 - i\\n        ...     _ = queue.get()\\n        >>> len(queue)\\n        0\\n        \\\"\\\"\\\"\\n        return len(tuple(iter(self)))\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"\\n        >>> queue = LinkedQueue()\\n        >>> for i in range(1, 4):\\n        ...     queue.put(i)\\n        >>> queue.put(\\\"Python\\\")\\n        >>> queue.put(3.14)\\n        >>> queue.put(True)\\n        >>> str(queue)\\n        '1 <- 2 <- 3 <- Python <- 3.14 <- True'\\n        \\\"\\\"\\\"\\n        return \\\" <- \\\".join(str(item) for item in self)\\n\\n    def is_empty(self) -> bool:\\n        \\\"\\\"\\\"\\n        >>> queue = LinkedQueue()\\n        >>> queue.is_empty()\\n        True\\n        >>> for i in range(1, 6):\\n        ...     queue.put(i)\\n        >>> queue.is_empty()\\n        False\\n        \\\"\\\"\\\"\\n        return len(self) == 0\\n\\n    def put(self, item: Any) -> None:\\n        \\\"\\\"\\\"\\n        >>> queue = LinkedQueue()\\n        >>> queue.get()\\n        Traceback (most recent call last):\\n        ...\\n        IndexError: dequeue from empty queue\\n        >>> for i in range(1, 6):\\n        ...     queue.put(i)\\n        >>> str(queue)\\n        '1 <- 2 <- 3 <- 4 <- 5'\\n        \\\"\\\"\\\"\\n        node = Node(item)\\n        if self.is_empty():\\n            self.front = self.rear = node\\n        else:\\n            assert isinstance(self.rear, Node)\\n            self.rear.next = node\\n            self.rear = node\\n\\n    def get(self) -> Any:\\n        \\\"\\\"\\\"\\n        >>> queue = LinkedQueue()\\n        >>> queue.get()\\n        Traceback (most recent call last):\\n        ...\\n        IndexError: dequeue from empty queue\\n        >>> queue = LinkedQueue()\\n        >>> for i in range(1, 6):\\n        ...     queue.put(i)\\n        >>> for i in range(1, 6):\\n        ...     assert queue.get() == i\\n        >>> len(queue)\\n        0\\n        \\\"\\\"\\\"\\n        if self.is_empty():\\n            raise IndexError(\\\"dequeue from empty queue\\\")\\n        assert isinstance(self.front, Node)\\n        node = self.front\\n        self.front = self.front.next\\n        if self.front is None:\\n            self.rear = None\\n        return node.data\\n\\n    def clear(self) -> None:\\n        \\\"\\\"\\\"\\n        >>> queue = LinkedQueue()\\n        >>> for i in range(1, 6):\\n        ...     queue.put(i)\\n        >>> queue.clear()\\n        >>> len(queue)\\n        0\\n        >>> str(queue)\\n        ''\\n        \\\"\\\"\\\"\\n        self.front = self.rear = None\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\"",
    "priority queue using list": "\"\\\"\\\"\\\"\\nPure Python implementations of a Fixed Priority Queue and an Element Priority Queue\\nusing Python lists.\\n\\\"\\\"\\\"\\n\\n\\nclass OverFlowError(Exception):\\n    pass\\n\\n\\nclass UnderFlowError(Exception):\\n    pass\\n\\n\\nclass FixedPriorityQueue:\\n    \\\"\\\"\\\"\\n    Tasks can be added to a Priority Queue at any time and in any order but when Tasks\\n    are removed then the Task with the highest priority is removed in FIFO order.  In\\n    code we will use three levels of priority with priority zero Tasks being the most\\n    urgent (high priority) and priority 2 tasks being the least urgent.\\n\\n    Examples\\n    >>> fpq = FixedPriorityQueue()\\n    >>> fpq.enqueue(0, 10)\\n    >>> fpq.enqueue(1, 70)\\n    >>> fpq.enqueue(0, 100)\\n    >>> fpq.enqueue(2, 1)\\n    >>> fpq.enqueue(2, 5)\\n    >>> fpq.enqueue(1, 7)\\n    >>> fpq.enqueue(2, 4)\\n    >>> fpq.enqueue(1, 64)\\n    >>> fpq.enqueue(0, 128)\\n    >>> print(fpq)\\n    Priority 0: [10, 100, 128]\\n    Priority 1: [70, 7, 64]\\n    Priority 2: [1, 5, 4]\\n    >>> fpq.dequeue()\\n    10\\n    >>> fpq.dequeue()\\n    100\\n    >>> fpq.dequeue()\\n    128\\n    >>> fpq.dequeue()\\n    70\\n    >>> fpq.dequeue()\\n    7\\n    >>> print(fpq)\\n    Priority 0: []\\n    Priority 1: [64]\\n    Priority 2: [1, 5, 4]\\n    >>> fpq.dequeue()\\n    64\\n    >>> fpq.dequeue()\\n    1\\n    >>> fpq.dequeue()\\n    5\\n    >>> fpq.dequeue()\\n    4\\n    >>> fpq.dequeue()\\n    Traceback (most recent call last):\\n    ...\\n    data_structures.queue.priority_queue_using_list.UnderFlowError: All queues are empty\\n    >>> print(fpq)\\n    Priority 0: []\\n    Priority 1: []\\n    Priority 2: []\\n    \\\"\\\"\\\"\\n\\n    def __init__(self):\\n        self.queues = [\\n            [],\\n            [],\\n            [],\\n        ]\\n\\n    def enqueue(self, priority: int, data: int) -> None:\\n        \\\"\\\"\\\"\\n        Add an element to a queue based on its priority.\\n        If the priority is invalid ValueError is raised.\\n        If the queue is full an OverFlowError is raised.\\n        \\\"\\\"\\\"\\n        try:\\n            if len(self.queues[priority]) >= 100:\\n                raise OverflowError(\\\"Maximum queue size is 100\\\")\\n            self.queues[priority].append(data)\\n        except IndexError:\\n            raise ValueError(\\\"Valid priorities are 0, 1, and 2\\\")\\n\\n    def dequeue(self) -> int:\\n        \\\"\\\"\\\"\\n        Return the highest priority element in FIFO order.\\n        If the queue is empty then an under flow exception is raised.\\n        \\\"\\\"\\\"\\n        for queue in self.queues:\\n            if queue:\\n                return queue.pop(0)\\n        raise UnderFlowError(\\\"All queues are empty\\\")\\n\\n    def __str__(self) -> str:\\n        return \\\"\\\\n\\\".join(f\\\"Priority {i}: {q}\\\" for i, q in enumerate(self.queues))\\n\\n\\nclass ElementPriorityQueue:\\n    \\\"\\\"\\\"\\n    Element Priority Queue is the same as Fixed Priority Queue except that the value of\\n    the element itself is the priority. The rules for priorities are the same the as\\n    Fixed Priority Queue.\\n\\n    >>> epq = ElementPriorityQueue()\\n    >>> epq.enqueue(10)\\n    >>> epq.enqueue(70)\\n    >>> epq.enqueue(4)\\n    >>> epq.enqueue(1)\\n    >>> epq.enqueue(5)\\n    >>> epq.enqueue(7)\\n    >>> epq.enqueue(4)\\n    >>> epq.enqueue(64)\\n    >>> epq.enqueue(128)\\n    >>> print(epq)\\n    [10, 70, 4, 1, 5, 7, 4, 64, 128]\\n    >>> epq.dequeue()\\n    1\\n    >>> epq.dequeue()\\n    4\\n    >>> epq.dequeue()\\n    4\\n    >>> epq.dequeue()\\n    5\\n    >>> epq.dequeue()\\n    7\\n    >>> epq.dequeue()\\n    10\\n    >>> print(epq)\\n    [70, 64, 128]\\n    >>> epq.dequeue()\\n    64\\n    >>> epq.dequeue()\\n    70\\n    >>> epq.dequeue()\\n    128\\n    >>> epq.dequeue()\\n    Traceback (most recent call last):\\n        ...\\n    data_structures.queue.priority_queue_using_list.UnderFlowError: The queue is empty\\n    >>> print(epq)\\n    []\\n    \\\"\\\"\\\"\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def enqueue(self, data: int) -> None:\\n        \\\"\\\"\\\"\\n        This function enters the element into the queue\\n        If the queue is full an Exception is raised saying Over Flow!\\n        \\\"\\\"\\\"\\n        if len(self.queue) == 100:\\n            raise OverFlowError(\\\"Maximum queue size is 100\\\")\\n        self.queue.append(data)\\n\\n    def dequeue(self) -> int:\\n        \\\"\\\"\\\"\\n        Return the highest priority element in FIFO order.\\n        If the queue is empty then an under flow exception is raised.\\n        \\\"\\\"\\\"\\n        if not self.queue:\\n            raise UnderFlowError(\\\"The queue is empty\\\")\\n        else:\\n            data = min(self.queue)\\n            self.queue.remove(data)\\n            return data\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"\\n        Prints all the elements within the Element Priority Queue\\n        \\\"\\\"\\\"\\n        return str(self.queue)\\n\\n\\ndef fixed_priority_queue():\\n    fpq = FixedPriorityQueue()\\n    fpq.enqueue(0, 10)\\n    fpq.enqueue(1, 70)\\n    fpq.enqueue(0, 100)\\n    fpq.enqueue(2, 1)\\n    fpq.enqueue(2, 5)\\n    fpq.enqueue(1, 7)\\n    fpq.enqueue(2, 4)\\n    fpq.enqueue(1, 64)\\n    fpq.enqueue(0, 128)\\n    print(fpq)\\n    print(fpq.dequeue())\\n    print(fpq.dequeue())\\n    print(fpq.dequeue())\\n    print(fpq.dequeue())\\n    print(fpq.dequeue())\\n    print(fpq)\\n    print(fpq.dequeue())\\n    print(fpq.dequeue())\\n    print(fpq.dequeue())\\n    print(fpq.dequeue())\\n    print(fpq.dequeue())\\n\\n\\ndef element_priority_queue():\\n    epq = ElementPriorityQueue()\\n    epq.enqueue(10)\\n    epq.enqueue(70)\\n    epq.enqueue(100)\\n    epq.enqueue(1)\\n    epq.enqueue(5)\\n    epq.enqueue(7)\\n    epq.enqueue(4)\\n    epq.enqueue(64)\\n    epq.enqueue(128)\\n    print(epq)\\n    print(epq.dequeue())\\n    print(epq.dequeue())\\n    print(epq.dequeue())\\n    print(epq.dequeue())\\n    print(epq.dequeue())\\n    print(epq)\\n    print(epq.dequeue())\\n    print(epq.dequeue())\\n    print(epq.dequeue())\\n    print(epq.dequeue())\\n    print(epq.dequeue())\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    fixed_priority_queue()\\n    element_priority_queue()\\n\"",
    "queue on list": "\"\\\"\\\"\\\"Queue represented by a Python list\\\"\\\"\\\"\\r\\n\\r\\n\\r\\nclass Queue:\\r\\n    def __init__(self):\\r\\n        self.entries = []\\r\\n        self.length = 0\\r\\n        self.front = 0\\r\\n\\r\\n    def __str__(self):\\r\\n        printed = \\\"<\\\" + str(self.entries)[1:-1] + \\\">\\\"\\r\\n        return printed\\r\\n\\r\\n    \\\"\\\"\\\"Enqueues {@code item}\\r\\n    @param item\\r\\n        item to enqueue\\\"\\\"\\\"\\r\\n\\r\\n    def put(self, item):\\r\\n        self.entries.append(item)\\r\\n        self.length = self.length + 1\\r\\n\\r\\n    \\\"\\\"\\\"Dequeues {@code item}\\r\\n    @requirement: |self.length| > 0\\r\\n    @return dequeued\\r\\n        item that was dequeued\\\"\\\"\\\"\\r\\n\\r\\n    def get(self):\\r\\n        self.length = self.length - 1\\r\\n        dequeued = self.entries[self.front]\\r\\n        # self.front-=1\\r\\n        # self.entries = self.entries[self.front:]\\r\\n        self.entries = self.entries[1:]\\r\\n        return dequeued\\r\\n\\r\\n    \\\"\\\"\\\"Rotates the queue {@code rotation} times\\r\\n    @param rotation\\r\\n        number of times to rotate queue\\\"\\\"\\\"\\r\\n\\r\\n    def rotate(self, rotation):\\r\\n        for i in range(rotation):\\r\\n            self.put(self.get())\\r\\n\\r\\n    \\\"\\\"\\\"Enqueues {@code item}\\r\\n    @return item at front of self.entries\\\"\\\"\\\"\\r\\n\\r\\n    def get_front(self):\\r\\n        return self.entries[0]\\r\\n\\r\\n    \\\"\\\"\\\"Returns the length of this.entries\\\"\\\"\\\"\\r\\n\\r\\n    def size(self):\\r\\n        return self.length\\r\\n\"",
    "queue on pseudo stack": "\"\\\"\\\"\\\"Queue represented by a pseudo stack (represented by a list with pop and append)\\\"\\\"\\\"\\r\\n\\r\\n\\r\\nclass Queue:\\r\\n    def __init__(self):\\r\\n        self.stack = []\\r\\n        self.length = 0\\r\\n\\r\\n    def __str__(self):\\r\\n        printed = \\\"<\\\" + str(self.stack)[1:-1] + \\\">\\\"\\r\\n        return printed\\r\\n\\r\\n    \\\"\\\"\\\"Enqueues {@code item}\\r\\n    @param item\\r\\n        item to enqueue\\\"\\\"\\\"\\r\\n\\r\\n    def put(self, item):\\r\\n        self.stack.append(item)\\r\\n        self.length = self.length + 1\\r\\n\\r\\n    \\\"\\\"\\\"Dequeues {@code item}\\r\\n    @requirement: |self.length| > 0\\r\\n    @return dequeued\\r\\n        item that was dequeued\\\"\\\"\\\"\\r\\n\\r\\n    def get(self):\\r\\n        self.rotate(1)\\r\\n        dequeued = self.stack[self.length - 1]\\r\\n        self.stack = self.stack[:-1]\\r\\n        self.rotate(self.length - 1)\\r\\n        self.length = self.length - 1\\r\\n        return dequeued\\r\\n\\r\\n    \\\"\\\"\\\"Rotates the queue {@code rotation} times\\r\\n    @param rotation\\r\\n        number of times to rotate queue\\\"\\\"\\\"\\r\\n\\r\\n    def rotate(self, rotation):\\r\\n        for i in range(rotation):\\r\\n            temp = self.stack[0]\\r\\n            self.stack = self.stack[1:]\\r\\n            self.put(temp)\\r\\n            self.length = self.length - 1\\r\\n\\r\\n    \\\"\\\"\\\"Reports item at the front of self\\r\\n    @return item at front of self.stack\\\"\\\"\\\"\\r\\n\\r\\n    def front(self):\\r\\n        front = self.get()\\r\\n        self.put(front)\\r\\n        self.rotate(self.length - 1)\\r\\n        return front\\r\\n\\r\\n    \\\"\\\"\\\"Returns the length of this.stack\\\"\\\"\\\"\\r\\n\\r\\n    def size(self):\\r\\n        return self.length\\r\\n\"",
    "balanced parentheses": "\"from .stack import Stack\\n\\n\\ndef balanced_parentheses(parentheses: str) -> bool:\\n    \\\"\\\"\\\"Use a stack to check if a string of parentheses is balanced.\\n    >>> balanced_parentheses(\\\"([]{})\\\")\\n    True\\n    >>> balanced_parentheses(\\\"[()]{}{[()()]()}\\\")\\n    True\\n    >>> balanced_parentheses(\\\"[(])\\\")\\n    False\\n    >>> balanced_parentheses(\\\"1+2*3-4\\\")\\n    True\\n    >>> balanced_parentheses(\\\"\\\")\\n    True\\n    \\\"\\\"\\\"\\n    stack: Stack[str] = Stack()\\n    bracket_pairs = {\\\"(\\\": \\\")\\\", \\\"[\\\": \\\"]\\\", \\\"{\\\": \\\"}\\\"}\\n    for bracket in parentheses:\\n        if bracket in bracket_pairs:\\n            stack.push(bracket)\\n        elif bracket in (\\\")\\\", \\\"]\\\", \\\"}\\\"):\\n            if stack.is_empty() or bracket_pairs[stack.pop()] != bracket:\\n                return False\\n    return stack.is_empty()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n\\n    examples = [\\\"((()))\\\", \\\"((())\\\", \\\"(()))\\\"]\\n    print(\\\"Balanced parentheses demonstration:\\\\n\\\")\\n    for example in examples:\\n        not_str = \\\"\\\" if balanced_parentheses(example) else \\\"not \\\"\\n        print(f\\\"{example} is {not_str}balanced\\\")\\n\"",
    "dijkstras two stack algorithm": "\"\\\"\\\"\\\"\\nAuthor: Alexander Joslin\\nGitHub: github.com/echoaj\\n\\nExplanation:  https://medium.com/@haleesammar/implemented-in-js-dijkstras-2-stack-\\n              algorithm-for-evaluating-mathematical-expressions-fc0837dae1ea\\n\\nWe can use Dijkstra's two stack algorithm to solve an equation\\nsuch as: (5 + ((4 * 2) * (2 + 3)))\\n\\nTHESE ARE THE ALGORITHM'S RULES:\\nRULE 1: Scan the expression from left to right. When an operand is encountered,\\n        push it onto the the operand stack.\\n\\nRULE 2: When an operator is encountered in the expression,\\n        push it onto the operator stack.\\n\\nRULE 3: When a left parenthesis is encountered in the expression, ignore it.\\n\\nRULE 4: When a right parenthesis is encountered in the expression,\\n        pop an operator off the operator stack.  The two operands it must\\n        operate on must be the last two operands pushed onto the operand stack.\\n        We therefore pop the operand stack twice, perform the operation,\\n        and push the result back onto the operand stack so it will be available\\n        for use as an operand of the next operator popped off the operator stack.\\n\\nRULE 5: When the entire infix expression has been scanned, the value left on\\n        the operand stack represents the value of the expression.\\n\\nNOTE:   It only works with whole numbers.\\n\\\"\\\"\\\"\\n__author__ = \\\"Alexander Joslin\\\"\\n\\nimport operator as op\\n\\nfrom .stack import Stack\\n\\n\\ndef dijkstras_two_stack_algorithm(equation: str) -> int:\\n    \\\"\\\"\\\"\\n    DocTests\\n    >>> dijkstras_two_stack_algorithm(\\\"(5 + 3)\\\")\\n    8\\n    >>> dijkstras_two_stack_algorithm(\\\"((9 - (2 + 9)) + (8 - 1))\\\")\\n    5\\n    >>> dijkstras_two_stack_algorithm(\\\"((((3 - 2) - (2 + 3)) + (2 - 4)) + 3)\\\")\\n    -3\\n\\n    :param equation: a string\\n    :return: result: an integer\\n    \\\"\\\"\\\"\\n    operators = {\\\"*\\\": op.mul, \\\"/\\\": op.truediv, \\\"+\\\": op.add, \\\"-\\\": op.sub}\\n\\n    operand_stack: Stack[int] = Stack()\\n    operator_stack: Stack[str] = Stack()\\n\\n    for i in equation:\\n        if i.isdigit():\\n            # RULE 1\\n            operand_stack.push(int(i))\\n        elif i in operators:\\n            # RULE 2\\n            operator_stack.push(i)\\n        elif i == \\\")\\\":\\n            # RULE 4\\n            opr = operator_stack.peek()\\n            operator_stack.pop()\\n            num1 = operand_stack.peek()\\n            operand_stack.pop()\\n            num2 = operand_stack.peek()\\n            operand_stack.pop()\\n\\n            total = operators[opr](num2, num1)\\n            operand_stack.push(total)\\n\\n    # RULE 5\\n    return operand_stack.peek()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    equation = \\\"(5 + ((4 * 2) * (2 + 3)))\\\"\\n    # answer = 45\\n    print(f\\\"{equation} = {dijkstras_two_stack_algorithm(equation)}\\\")\\n\"",
    "evaluate postfix notations": "\"\\\"\\\"\\\"\\nThe Reverse Polish Nation also known as Polish postfix notation\\nor simply postfix notation.\\nhttps://en.wikipedia.org/wiki/Reverse_Polish_notation\\nClassic examples of simple stack implementations\\nValid operators are +, -, *, /.\\nEach operand may be an integer or another expression.\\n\\\"\\\"\\\"\\nfrom __future__ import annotations\\n\\nfrom typing import Any\\n\\n\\ndef evaluate_postfix(postfix_notation: list) -> int:\\n    \\\"\\\"\\\"\\n    >>> evaluate_postfix([\\\"2\\\", \\\"1\\\", \\\"+\\\", \\\"3\\\", \\\"*\\\"])\\n    9\\n    >>> evaluate_postfix([\\\"4\\\", \\\"13\\\", \\\"5\\\", \\\"/\\\", \\\"+\\\"])\\n    6\\n    >>> evaluate_postfix([])\\n    0\\n    \\\"\\\"\\\"\\n    if not postfix_notation:\\n        return 0\\n\\n    operations = {\\\"+\\\", \\\"-\\\", \\\"*\\\", \\\"/\\\"}\\n    stack: list[Any] = []\\n\\n    for token in postfix_notation:\\n        if token in operations:\\n            b, a = stack.pop(), stack.pop()\\n            if token == \\\"+\\\":\\n                stack.append(a + b)\\n            elif token == \\\"-\\\":\\n                stack.append(a - b)\\n            elif token == \\\"*\\\":\\n                stack.append(a * b)\\n            else:\\n                if a * b < 0 and a % b != 0:\\n                    stack.append(a // b + 1)\\n                else:\\n                    stack.append(a // b)\\n        else:\\n            stack.append(int(token))\\n\\n    return stack.pop()\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "infix to postfix conversion": "\"\\\"\\\"\\\"\\nhttps://en.wikipedia.org/wiki/Infix_notation\\nhttps://en.wikipedia.org/wiki/Reverse_Polish_notation\\nhttps://en.wikipedia.org/wiki/Shunting-yard_algorithm\\n\\\"\\\"\\\"\\n\\nfrom .balanced_parentheses import balanced_parentheses\\nfrom .stack import Stack\\n\\n\\ndef precedence(char: str) -> int:\\n    \\\"\\\"\\\"\\n    Return integer value representing an operator's precedence, or\\n    order of operation.\\n    https://en.wikipedia.org/wiki/Order_of_operations\\n    \\\"\\\"\\\"\\n    return {\\\"+\\\": 1, \\\"-\\\": 1, \\\"*\\\": 2, \\\"/\\\": 2, \\\"^\\\": 3}.get(char, -1)\\n\\n\\ndef infix_to_postfix(expression_str: str) -> str:\\n    \\\"\\\"\\\"\\n    >>> infix_to_postfix(\\\"(1*(2+3)+4))\\\")\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: Mismatched parentheses\\n    >>> infix_to_postfix(\\\"\\\")\\n    ''\\n    >>> infix_to_postfix(\\\"3+2\\\")\\n    '3 2 +'\\n    >>> infix_to_postfix(\\\"(3+4)*5-6\\\")\\n    '3 4 + 5 * 6 -'\\n    >>> infix_to_postfix(\\\"(1+2)*3/4-5\\\")\\n    '1 2 + 3 * 4 / 5 -'\\n    >>> infix_to_postfix(\\\"a+b*c+(d*e+f)*g\\\")\\n    'a b c * + d e * f + g * +'\\n    >>> infix_to_postfix(\\\"x^y/(5*z)+2\\\")\\n    'x y ^ 5 z * / 2 +'\\n    \\\"\\\"\\\"\\n    if not balanced_parentheses(expression_str):\\n        raise ValueError(\\\"Mismatched parentheses\\\")\\n    stack: Stack[str] = Stack()\\n    postfix = []\\n    for char in expression_str:\\n        if char.isalpha() or char.isdigit():\\n            postfix.append(char)\\n        elif char == \\\"(\\\":\\n            stack.push(char)\\n        elif char == \\\")\\\":\\n            while not stack.is_empty() and stack.peek() != \\\"(\\\":\\n                postfix.append(stack.pop())\\n            stack.pop()\\n        else:\\n            while not stack.is_empty() and precedence(char) <= precedence(stack.peek()):\\n                postfix.append(stack.pop())\\n            stack.push(char)\\n    while not stack.is_empty():\\n        postfix.append(stack.pop())\\n    return \\\" \\\".join(postfix)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n\\n    testmod()\\n    expression = \\\"a+b*(c^d-e)^(f+g*h)-i\\\"\\n\\n    print(\\\"Infix to Postfix Notation demonstration:\\\\n\\\")\\n    print(\\\"Infix notation: \\\" + expression)\\n    print(\\\"Postfix notation: \\\" + infix_to_postfix(expression))\\n\"",
    "infix to prefix conversion": "\"\\\"\\\"\\\"\\nOutput:\\n\\nEnter an Infix Equation = a + b ^c\\n Symbol  |  Stack  | Postfix\\n----------------------------\\n   c     |         | c\\n   ^     | ^       | c\\n   b     | ^       | cb\\n   +     | +       | cb^\\n   a     | +       | cb^a\\n         |         | cb^a+\\n\\n         a+b^c (Infix) ->  +a^bc (Prefix)\\n\\\"\\\"\\\"\\n\\n\\ndef infix_2_postfix(Infix):\\n    Stack = []\\n    Postfix = []\\n    priority = {\\n        \\\"^\\\": 3,\\n        \\\"*\\\": 2,\\n        \\\"/\\\": 2,\\n        \\\"%\\\": 2,\\n        \\\"+\\\": 1,\\n        \\\"-\\\": 1,\\n    }  # Priority of each operator\\n    print_width = len(Infix) if (len(Infix) > 7) else 7\\n\\n    # Print table header for output\\n    print(\\n        \\\"Symbol\\\".center(8),\\n        \\\"Stack\\\".center(print_width),\\n        \\\"Postfix\\\".center(print_width),\\n        sep=\\\" | \\\",\\n    )\\n    print(\\\"-\\\" * (print_width * 3 + 7))\\n\\n    for x in Infix:\\n        if x.isalpha() or x.isdigit():\\n            Postfix.append(x)  # if x is Alphabet / Digit, add it to Postfix\\n        elif x == \\\"(\\\":\\n            Stack.append(x)  # if x is \\\"(\\\" push to Stack\\n        elif x == \\\")\\\":  # if x is \\\")\\\" pop stack until \\\"(\\\" is encountered\\n            while Stack[-1] != \\\"(\\\":\\n                Postfix.append(Stack.pop())  # Pop stack & add the content to Postfix\\n            Stack.pop()\\n        else:\\n            if len(Stack) == 0:\\n                Stack.append(x)  # If stack is empty, push x to stack\\n            else:  # while priority of x is not > priority of element in the stack\\n                while len(Stack) > 0 and priority[x] <= priority[Stack[-1]]:\\n                    Postfix.append(Stack.pop())  # pop stack & add to Postfix\\n                Stack.append(x)  # push x to stack\\n\\n        print(\\n            x.center(8),\\n            (\\\"\\\".join(Stack)).ljust(print_width),\\n            (\\\"\\\".join(Postfix)).ljust(print_width),\\n            sep=\\\" | \\\",\\n        )  # Output in tabular format\\n\\n    while len(Stack) > 0:  # while stack is not empty\\n        Postfix.append(Stack.pop())  # pop stack & add to Postfix\\n        print(\\n            \\\" \\\".center(8),\\n            (\\\"\\\".join(Stack)).ljust(print_width),\\n            (\\\"\\\".join(Postfix)).ljust(print_width),\\n            sep=\\\" | \\\",\\n        )  # Output in tabular format\\n\\n    return \\\"\\\".join(Postfix)  # return Postfix as str\\n\\n\\ndef infix_2_prefix(Infix):\\n    Infix = list(Infix[::-1])  # reverse the infix equation\\n\\n    for i in range(len(Infix)):\\n        if Infix[i] == \\\"(\\\":\\n            Infix[i] = \\\")\\\"  # change \\\"(\\\" to \\\")\\\"\\n        elif Infix[i] == \\\")\\\":\\n            Infix[i] = \\\"(\\\"  # change \\\")\\\" to \\\"(\\\"\\n\\n    return (infix_2_postfix(\\\"\\\".join(Infix)))[\\n        ::-1\\n    ]  # call infix_2_postfix on Infix, return reverse of Postfix\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    Infix = input(\\\"\\\\nEnter an Infix Equation = \\\")  # Input an Infix equation\\n    Infix = \\\"\\\".join(Infix.split())  # Remove spaces from the input\\n    print(\\\"\\\\n\\\\t\\\", Infix, \\\"(Infix) -> \\\", infix_2_prefix(Infix), \\\"(Prefix)\\\")\\n\"",
    "next greater element": "\"from __future__ import annotations\\n\\narr = [-10, -5, 0, 5, 5.1, 11, 13, 21, 3, 4, -21, -10, -5, -1, 0]\\nexpect = [-5, 0, 5, 5.1, 11, 13, 21, -1, 4, -1, -10, -5, -1, 0, -1]\\n\\n\\ndef next_greatest_element_slow(arr: list[float]) -> list[float]:\\n    \\\"\\\"\\\"\\n    Get the Next Greatest Element (NGE) for all elements in a list.\\n    Maximum element present after the current one which is also greater than the\\n    current one.\\n    >>> next_greatest_element_slow(arr) == expect\\n    True\\n    \\\"\\\"\\\"\\n\\n    result = []\\n    arr_size = len(arr)\\n\\n    for i in range(arr_size):\\n        next: float = -1\\n        for j in range(i + 1, arr_size):\\n            if arr[i] < arr[j]:\\n                next = arr[j]\\n                break\\n        result.append(next)\\n    return result\\n\\n\\ndef next_greatest_element_fast(arr: list[float]) -> list[float]:\\n    \\\"\\\"\\\"\\n    Like next_greatest_element_slow() but changes the loops to use\\n    enumerate() instead of range(len()) for the outer loop and\\n    for in a slice of arr for the inner loop.\\n    >>> next_greatest_element_fast(arr) == expect\\n    True\\n    \\\"\\\"\\\"\\n    result = []\\n    for i, outer in enumerate(arr):\\n        next: float = -1\\n        for inner in arr[i + 1 :]:\\n            if outer < inner:\\n                next = inner\\n                break\\n        result.append(next)\\n    return result\\n\\n\\ndef next_greatest_element(arr: list[float]) -> list[float]:\\n    \\\"\\\"\\\"\\n    Get the Next Greatest Element (NGE) for all elements in a list.\\n    Maximum element present after the current one which is also greater than the\\n    current one.\\n\\n    A naive way to solve this is to take two loops and check for the next bigger\\n    number but that will make the time complexity as O(n^2). The better way to solve\\n    this would be to use a stack to keep track of maximum number giving a linear time\\n    solution.\\n    >>> next_greatest_element(arr) == expect\\n    True\\n    \\\"\\\"\\\"\\n    arr_size = len(arr)\\n    stack: list[float] = []\\n    result: list[float] = [-1] * arr_size\\n\\n    for index in reversed(range(arr_size)):\\n        if stack:\\n            while stack[-1] <= arr[index]:\\n                stack.pop()\\n                if not stack:\\n                    break\\n        if stack:\\n            result[index] = stack[-1]\\n        stack.append(arr[index])\\n    return result\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    from doctest import testmod\\n    from timeit import timeit\\n\\n    testmod()\\n    print(next_greatest_element_slow(arr))\\n    print(next_greatest_element_fast(arr))\\n    print(next_greatest_element(arr))\\n\\n    setup = (\\n        \\\"from __main__ import arr, next_greatest_element_slow, \\\"\\n        \\\"next_greatest_element_fast, next_greatest_element\\\"\\n    )\\n    print(\\n        \\\"next_greatest_element_slow():\\\",\\n        timeit(\\\"next_greatest_element_slow(arr)\\\", setup=setup),\\n    )\\n    print(\\n        \\\"next_greatest_element_fast():\\\",\\n        timeit(\\\"next_greatest_element_fast(arr)\\\", setup=setup),\\n    )\\n    print(\\n        \\\"     next_greatest_element():\\\",\\n        timeit(\\\"next_greatest_element(arr)\\\", setup=setup),\\n    )\\n\"",
    "postfix evaluation": "\"\\\"\\\"\\\"\\nOutput:\\n\\nEnter a Postfix Equation (space separated) = 5 6 9 * +\\n Symbol  |    Action    | Stack\\n-----------------------------------\\n       5 | push(5)      | 5\\n       6 | push(6)      | 5,6\\n       9 | push(9)      | 5,6,9\\n         | pop(9)       | 5,6\\n         | pop(6)       | 5\\n       * | push(6*9)    | 5,54\\n         | pop(54)      | 5\\n         | pop(5)       |\\n       + | push(5+54)   | 59\\n\\n        Result =  59\\n\\\"\\\"\\\"\\n\\nimport operator as op\\n\\n\\ndef Solve(Postfix):\\n    Stack = []\\n    Div = lambda x, y: int(x / y)  # noqa: E731 integer division operation\\n    Opr = {\\n        \\\"^\\\": op.pow,\\n        \\\"*\\\": op.mul,\\n        \\\"/\\\": Div,\\n        \\\"+\\\": op.add,\\n        \\\"-\\\": op.sub,\\n    }  # operators & their respective operation\\n\\n    # print table header\\n    print(\\\"Symbol\\\".center(8), \\\"Action\\\".center(12), \\\"Stack\\\", sep=\\\" | \\\")\\n    print(\\\"-\\\" * (30 + len(Postfix)))\\n\\n    for x in Postfix:\\n        if x.isdigit():  # if x in digit\\n            Stack.append(x)  # append x to stack\\n            # output in tabular format\\n            print(x.rjust(8), (\\\"push(\\\" + x + \\\")\\\").ljust(12), \\\",\\\".join(Stack), sep=\\\" | \\\")\\n        else:\\n            B = Stack.pop()  # pop stack\\n            # output in tabular format\\n            print(\\\"\\\".rjust(8), (\\\"pop(\\\" + B + \\\")\\\").ljust(12), \\\",\\\".join(Stack), sep=\\\" | \\\")\\n\\n            A = Stack.pop()  # pop stack\\n            # output in tabular format\\n            print(\\\"\\\".rjust(8), (\\\"pop(\\\" + A + \\\")\\\").ljust(12), \\\",\\\".join(Stack), sep=\\\" | \\\")\\n\\n            Stack.append(\\n                str(Opr[x](int(A), int(B)))\\n            )  # evaluate the 2 values popped from stack & push result to stack\\n            # output in tabular format\\n            print(\\n                x.rjust(8),\\n                (\\\"push(\\\" + A + x + B + \\\")\\\").ljust(12),\\n                \\\",\\\".join(Stack),\\n                sep=\\\" | \\\",\\n            )\\n\\n    return int(Stack[0])\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    Postfix = input(\\\"\\\\n\\\\nEnter a Postfix Equation (space separated) = \\\").split(\\\" \\\")\\n    print(\\\"\\\\n\\\\tResult = \\\", Solve(Postfix))\\n\"",
    "prefix evaluation": "\"\\\"\\\"\\\"\\nPython3 program to evaluate a prefix expression.\\n\\\"\\\"\\\"\\n\\ncalc = {\\n    \\\"+\\\": lambda x, y: x + y,\\n    \\\"-\\\": lambda x, y: x - y,\\n    \\\"*\\\": lambda x, y: x * y,\\n    \\\"/\\\": lambda x, y: x / y,\\n}\\n\\n\\ndef is_operand(c):\\n    \\\"\\\"\\\"\\n    Return True if the given char c is an operand, e.g. it is a number\\n\\n    >>> is_operand(\\\"1\\\")\\n    True\\n    >>> is_operand(\\\"+\\\")\\n    False\\n    \\\"\\\"\\\"\\n    return c.isdigit()\\n\\n\\ndef evaluate(expression):\\n    \\\"\\\"\\\"\\n    Evaluate a given expression in prefix notation.\\n    Asserts that the given expression is valid.\\n\\n    >>> evaluate(\\\"+ 9 * 2 6\\\")\\n    21\\n    >>> evaluate(\\\"/ * 10 2 + 4 1 \\\")\\n    4.0\\n    \\\"\\\"\\\"\\n    stack = []\\n\\n    # iterate over the string in reverse order\\n    for c in expression.split()[::-1]:\\n\\n        # push operand to stack\\n        if is_operand(c):\\n            stack.append(int(c))\\n\\n        else:\\n            # pop values from stack can calculate the result\\n            # push the result onto the stack again\\n            o1 = stack.pop()\\n            o2 = stack.pop()\\n            stack.append(calc[c](o1, o2))\\n\\n    return stack.pop()\\n\\n\\n# Driver code\\nif __name__ == \\\"__main__\\\":\\n    test_expression = \\\"+ 9 * 2 6\\\"\\n    print(evaluate(test_expression))\\n\\n    test_expression = \\\"/ * 10 2 + 4 1 \\\"\\n    print(evaluate(test_expression))\\n\"",
    "stack": "\"from __future__ import annotations\\n\\nfrom typing import Generic, TypeVar\\n\\nT = TypeVar(\\\"T\\\")\\n\\n\\nclass StackOverflowError(BaseException):\\n    pass\\n\\n\\nclass StackUnderflowError(BaseException):\\n    pass\\n\\n\\nclass Stack(Generic[T]):\\n    \\\"\\\"\\\"A stack is an abstract data type that serves as a collection of\\n    elements with two principal operations: push() and pop(). push() adds an\\n    element to the top of the stack, and pop() removes an element from the top\\n    of a stack. The order in which elements come off of a stack are\\n    Last In, First Out (LIFO).\\n    https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, limit: int = 10):\\n        self.stack: list[T] = []\\n        self.limit = limit\\n\\n    def __bool__(self) -> bool:\\n        return bool(self.stack)\\n\\n    def __str__(self) -> str:\\n        return str(self.stack)\\n\\n    def push(self, data: T) -> None:\\n        \\\"\\\"\\\"Push an element to the top of the stack.\\\"\\\"\\\"\\n        if len(self.stack) >= self.limit:\\n            raise StackOverflowError\\n        self.stack.append(data)\\n\\n    def pop(self) -> T:\\n        \\\"\\\"\\\"\\n        Pop an element off of the top of the stack.\\n\\n        >>> Stack().pop()\\n        Traceback (most recent call last):\\n            ...\\n        data_structures.stacks.stack.StackUnderflowError\\n        \\\"\\\"\\\"\\n        if not self.stack:\\n            raise StackUnderflowError\\n        return self.stack.pop()\\n\\n    def peek(self) -> T:\\n        \\\"\\\"\\\"\\n        Peek at the top-most element of the stack.\\n\\n        >>> Stack().pop()\\n        Traceback (most recent call last):\\n            ...\\n        data_structures.stacks.stack.StackUnderflowError\\n        \\\"\\\"\\\"\\n        if not self.stack:\\n            raise StackUnderflowError\\n        return self.stack[-1]\\n\\n    def is_empty(self) -> bool:\\n        \\\"\\\"\\\"Check if a stack is empty.\\\"\\\"\\\"\\n        return not bool(self.stack)\\n\\n    def is_full(self) -> bool:\\n        return self.size() == self.limit\\n\\n    def size(self) -> int:\\n        \\\"\\\"\\\"Return the size of the stack.\\\"\\\"\\\"\\n        return len(self.stack)\\n\\n    def __contains__(self, item: T) -> bool:\\n        \\\"\\\"\\\"Check if item is in stack\\\"\\\"\\\"\\n        return item in self.stack\\n\\n\\ndef test_stack() -> None:\\n    \\\"\\\"\\\"\\n    >>> test_stack()\\n    \\\"\\\"\\\"\\n    stack: Stack[int] = Stack(10)\\n    assert bool(stack) is False\\n    assert stack.is_empty() is True\\n    assert stack.is_full() is False\\n    assert str(stack) == \\\"[]\\\"\\n\\n    try:\\n        _ = stack.pop()\\n        assert False  # This should not happen\\n    except StackUnderflowError:\\n        assert True  # This should happen\\n\\n    try:\\n        _ = stack.peek()\\n        assert False  # This should not happen\\n    except StackUnderflowError:\\n        assert True  # This should happen\\n\\n    for i in range(10):\\n        assert stack.size() == i\\n        stack.push(i)\\n\\n    assert bool(stack)\\n    assert not stack.is_empty()\\n    assert stack.is_full()\\n    assert str(stack) == str(list(range(10)))\\n    assert stack.pop() == 9\\n    assert stack.peek() == 8\\n\\n    stack.push(100)\\n    assert str(stack) == str([0, 1, 2, 3, 4, 5, 6, 7, 8, 100])\\n\\n    try:\\n        stack.push(200)\\n        assert False  # This should not happen\\n    except StackOverflowError:\\n        assert True  # This should happen\\n\\n    assert not stack.is_empty()\\n    assert stack.size() == 10\\n\\n    assert 5 in stack\\n    assert 55 not in stack\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    test_stack()\\n\"",
    "stack with doubly linked list": "\"# A complete working Python program to demonstrate all\\r\\n# stack operations using a doubly linked list\\r\\n\\r\\nfrom __future__ import annotations\\r\\n\\r\\nfrom typing import Generic, TypeVar\\r\\n\\r\\nT = TypeVar(\\\"T\\\")\\r\\n\\r\\n\\r\\nclass Node(Generic[T]):\\r\\n    def __init__(self, data: T):\\r\\n        self.data = data  # Assign data\\r\\n        self.next: Node[T] | None = None  # Initialize next as null\\r\\n        self.prev: Node[T] | None = None  # Initialize prev as null\\r\\n\\r\\n\\r\\nclass Stack(Generic[T]):\\r\\n    \\\"\\\"\\\"\\r\\n    >>> stack = Stack()\\r\\n    >>> stack.is_empty()\\r\\n    True\\r\\n    >>> stack.print_stack()\\r\\n    stack elements are:\\r\\n    >>> for i in range(4):\\r\\n    ...     stack.push(i)\\r\\n    ...\\r\\n    >>> stack.is_empty()\\r\\n    False\\r\\n    >>> stack.print_stack()\\r\\n    stack elements are:\\r\\n    3->2->1->0->\\r\\n    >>> stack.top()\\r\\n    3\\r\\n    >>> len(stack)\\r\\n    4\\r\\n    >>> stack.pop()\\r\\n    3\\r\\n    >>> stack.print_stack()\\r\\n    stack elements are:\\r\\n    2->1->0->\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def __init__(self) -> None:\\r\\n        self.head: Node[T] | None = None\\r\\n\\r\\n    def push(self, data: T) -> None:\\r\\n        \\\"\\\"\\\"add a Node to the stack\\\"\\\"\\\"\\r\\n        if self.head is None:\\r\\n            self.head = Node(data)\\r\\n        else:\\r\\n            new_node = Node(data)\\r\\n            self.head.prev = new_node\\r\\n            new_node.next = self.head\\r\\n            new_node.prev = None\\r\\n            self.head = new_node\\r\\n\\r\\n    def pop(self) -> T | None:\\r\\n        \\\"\\\"\\\"pop the top element off the stack\\\"\\\"\\\"\\r\\n        if self.head is None:\\r\\n            return None\\r\\n        else:\\r\\n            assert self.head is not None\\r\\n            temp = self.head.data\\r\\n            self.head = self.head.next\\r\\n            if self.head is not None:\\r\\n                self.head.prev = None\\r\\n            return temp\\r\\n\\r\\n    def top(self) -> T | None:\\r\\n        \\\"\\\"\\\"return the top element of the stack\\\"\\\"\\\"\\r\\n        return self.head.data if self.head is not None else None\\r\\n\\r\\n    def __len__(self) -> int:\\r\\n        temp = self.head\\r\\n        count = 0\\r\\n        while temp is not None:\\r\\n            count += 1\\r\\n            temp = temp.next\\r\\n        return count\\r\\n\\r\\n    def is_empty(self) -> bool:\\r\\n        return self.head is None\\r\\n\\r\\n    def print_stack(self) -> None:\\r\\n        print(\\\"stack elements are:\\\")\\r\\n        temp = self.head\\r\\n        while temp is not None:\\r\\n            print(temp.data, end=\\\"->\\\")\\r\\n            temp = temp.next\\r\\n\\r\\n\\r\\n# Code execution starts here\\r\\nif __name__ == \\\"__main__\\\":\\r\\n\\r\\n    # Start with the empty stack\\r\\n    stack: Stack[int] = Stack()\\r\\n\\r\\n    # Insert 4 at the beginning. So stack becomes 4->None\\r\\n    print(\\\"Stack operations using Doubly LinkedList\\\")\\r\\n    stack.push(4)\\r\\n\\r\\n    # Insert 5 at the beginning. So stack becomes 4->5->None\\r\\n    stack.push(5)\\r\\n\\r\\n    # Insert 6 at the beginning. So stack becomes 4->5->6->None\\r\\n    stack.push(6)\\r\\n\\r\\n    # Insert 7 at the beginning. So stack becomes 4->5->6->7->None\\r\\n    stack.push(7)\\r\\n\\r\\n    # Print the stack\\r\\n    stack.print_stack()\\r\\n\\r\\n    # Print the top element\\r\\n    print(\\\"\\\\nTop element is \\\", stack.top())\\r\\n\\r\\n    # Print the stack size\\r\\n    print(\\\"Size of the stack is \\\", len(stack))\\r\\n\\r\\n    # pop the top element\\r\\n    stack.pop()\\r\\n\\r\\n    # pop the top element\\r\\n    stack.pop()\\r\\n\\r\\n    # two elements have now been popped off\\r\\n    stack.print_stack()\\r\\n\\r\\n    # Print True if the stack is empty else False\\r\\n    print(\\\"\\\\nstack is empty:\\\", stack.is_empty())\\r\\n\"",
    "stack with singly linked list": "\"\\\"\\\"\\\" A Stack using a linked list like structure \\\"\\\"\\\"\\r\\nfrom __future__ import annotations\\r\\n\\r\\nfrom collections.abc import Iterator\\r\\nfrom typing import Generic, TypeVar\\r\\n\\r\\nT = TypeVar(\\\"T\\\")\\r\\n\\r\\n\\r\\nclass Node(Generic[T]):\\r\\n    def __init__(self, data: T):\\r\\n        self.data = data\\r\\n        self.next: Node[T] | None = None\\r\\n\\r\\n    def __str__(self) -> str:\\r\\n        return f\\\"{self.data}\\\"\\r\\n\\r\\n\\r\\nclass LinkedStack(Generic[T]):\\r\\n    \\\"\\\"\\\"\\r\\n    Linked List Stack implementing push (to top),\\r\\n    pop (from top) and is_empty\\r\\n\\r\\n    >>> stack = LinkedStack()\\r\\n    >>> stack.is_empty()\\r\\n    True\\r\\n    >>> stack.push(5)\\r\\n    >>> stack.push(9)\\r\\n    >>> stack.push('python')\\r\\n    >>> stack.is_empty()\\r\\n    False\\r\\n    >>> stack.pop()\\r\\n    'python'\\r\\n    >>> stack.push('algorithms')\\r\\n    >>> stack.pop()\\r\\n    'algorithms'\\r\\n    >>> stack.pop()\\r\\n    9\\r\\n    >>> stack.pop()\\r\\n    5\\r\\n    >>> stack.is_empty()\\r\\n    True\\r\\n    >>> stack.pop()\\r\\n    Traceback (most recent call last):\\r\\n        ...\\r\\n    IndexError: pop from empty stack\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    def __init__(self) -> None:\\r\\n        self.top: Node[T] | None = None\\r\\n\\r\\n    def __iter__(self) -> Iterator[T]:\\r\\n        node = self.top\\r\\n        while node:\\r\\n            yield node.data\\r\\n            node = node.next\\r\\n\\r\\n    def __str__(self) -> str:\\r\\n        \\\"\\\"\\\"\\r\\n        >>> stack = LinkedStack()\\r\\n        >>> stack.push(\\\"c\\\")\\r\\n        >>> stack.push(\\\"b\\\")\\r\\n        >>> stack.push(\\\"a\\\")\\r\\n        >>> str(stack)\\r\\n        'a->b->c'\\r\\n        \\\"\\\"\\\"\\r\\n        return \\\"->\\\".join([str(item) for item in self])\\r\\n\\r\\n    def __len__(self) -> int:\\r\\n        \\\"\\\"\\\"\\r\\n        >>> stack = LinkedStack()\\r\\n        >>> len(stack) == 0\\r\\n        True\\r\\n        >>> stack.push(\\\"c\\\")\\r\\n        >>> stack.push(\\\"b\\\")\\r\\n        >>> stack.push(\\\"a\\\")\\r\\n        >>> len(stack) == 3\\r\\n        True\\r\\n        \\\"\\\"\\\"\\r\\n        return len(tuple(iter(self)))\\r\\n\\r\\n    def is_empty(self) -> bool:\\r\\n        \\\"\\\"\\\"\\r\\n        >>> stack = LinkedStack()\\r\\n        >>> stack.is_empty()\\r\\n        True\\r\\n        >>> stack.push(1)\\r\\n        >>> stack.is_empty()\\r\\n        False\\r\\n        \\\"\\\"\\\"\\r\\n        return self.top is None\\r\\n\\r\\n    def push(self, item: T) -> None:\\r\\n        \\\"\\\"\\\"\\r\\n        >>> stack = LinkedStack()\\r\\n        >>> stack.push(\\\"Python\\\")\\r\\n        >>> stack.push(\\\"Java\\\")\\r\\n        >>> stack.push(\\\"C\\\")\\r\\n        >>> str(stack)\\r\\n        'C->Java->Python'\\r\\n        \\\"\\\"\\\"\\r\\n        node = Node(item)\\r\\n        if not self.is_empty():\\r\\n            node.next = self.top\\r\\n        self.top = node\\r\\n\\r\\n    def pop(self) -> T:\\r\\n        \\\"\\\"\\\"\\r\\n        >>> stack = LinkedStack()\\r\\n        >>> stack.pop()\\r\\n        Traceback (most recent call last):\\r\\n        ...\\r\\n        IndexError: pop from empty stack\\r\\n        >>> stack.push(\\\"c\\\")\\r\\n        >>> stack.push(\\\"b\\\")\\r\\n        >>> stack.push(\\\"a\\\")\\r\\n        >>> stack.pop() == 'a'\\r\\n        True\\r\\n        >>> stack.pop() == 'b'\\r\\n        True\\r\\n        >>> stack.pop() == 'c'\\r\\n        True\\r\\n        \\\"\\\"\\\"\\r\\n        if self.is_empty():\\r\\n            raise IndexError(\\\"pop from empty stack\\\")\\r\\n        assert isinstance(self.top, Node)\\r\\n        pop_node = self.top\\r\\n        self.top = self.top.next\\r\\n        return pop_node.data\\r\\n\\r\\n    def peek(self) -> T:\\r\\n        \\\"\\\"\\\"\\r\\n        >>> stack = LinkedStack()\\r\\n        >>> stack.push(\\\"Java\\\")\\r\\n        >>> stack.push(\\\"C\\\")\\r\\n        >>> stack.push(\\\"Python\\\")\\r\\n        >>> stack.peek()\\r\\n        'Python'\\r\\n        \\\"\\\"\\\"\\r\\n        if self.is_empty():\\r\\n            raise IndexError(\\\"peek from empty stack\\\")\\r\\n\\r\\n        assert self.top is not None\\r\\n        return self.top.data\\r\\n\\r\\n    def clear(self) -> None:\\r\\n        \\\"\\\"\\\"\\r\\n        >>> stack = LinkedStack()\\r\\n        >>> stack.push(\\\"Java\\\")\\r\\n        >>> stack.push(\\\"C\\\")\\r\\n        >>> stack.push(\\\"Python\\\")\\r\\n        >>> str(stack)\\r\\n        'Python->C->Java'\\r\\n        >>> stack.clear()\\r\\n        >>> len(stack) == 0\\r\\n        True\\r\\n        \\\"\\\"\\\"\\r\\n        self.top = None\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    from doctest import testmod\\r\\n\\r\\n    testmod()\\r\\n\"",
    "stock span problem": "\"\\\"\\\"\\\"\\nThe stock span problem is a financial problem where we have a series of n daily\\nprice quotes for a stock and we need to calculate span of stock's price for all n days.\\n\\nThe span Si of the stock's price on a given day i is defined as the maximum\\nnumber of consecutive days just before the given day, for which the price of the stock\\non the current day is less than or equal to its price on the given day.\\n\\\"\\\"\\\"\\n\\n\\ndef calculateSpan(price, S):\\n\\n    n = len(price)\\n    # Create a stack and push index of fist element to it\\n    st = []\\n    st.append(0)\\n\\n    # Span value of first element is always 1\\n    S[0] = 1\\n\\n    # Calculate span values for rest of the elements\\n    for i in range(1, n):\\n\\n        # Pop elements from stack while stack is not\\n        # empty and top of stack is smaller than price[i]\\n        while len(st) > 0 and price[st[0]] <= price[i]:\\n            st.pop()\\n\\n        # If stack becomes empty, then price[i] is greater\\n        # than all elements on left of it, i.e. price[0],\\n        # price[1], ..price[i-1]. Else the price[i]  is\\n        # greater than elements after top of stack\\n        S[i] = i + 1 if len(st) <= 0 else (i - st[0])\\n\\n        # Push this element to stack\\n        st.append(i)\\n\\n\\n# A utility function to print elements of array\\ndef printArray(arr, n):\\n    for i in range(0, n):\\n        print(arr[i], end=\\\" \\\")\\n\\n\\n# Driver program to test above function\\nprice = [10, 4, 5, 90, 120, 80]\\nS = [0 for i in range(len(price) + 1)]\\n\\n# Fill the span values in array S[]\\ncalculateSpan(price, S)\\n\\n# Print the calculated span values\\nprintArray(S, len(price))\\n\"",
    "trie": "\"\\\"\\\"\\\"\\nA Trie/Prefix Tree is a kind of search tree used to provide quick lookup\\nof words/patterns in a set of words. A basic Trie however has O(n^2) space complexity\\nmaking it impractical in practice. It however provides O(max(search_string, length of\\nlongest word)) lookup time making it an optimal approach when space is not an issue.\\n\\\"\\\"\\\"\\n\\n\\nclass TrieNode:\\n    def __init__(self) -> None:\\n        self.nodes: dict[str, TrieNode] = dict()  # Mapping from char to TrieNode\\n        self.is_leaf = False\\n\\n    def insert_many(self, words: list[str]) -> None:\\n        \\\"\\\"\\\"\\n        Inserts a list of words into the Trie\\n        :param words: list of string words\\n        :return: None\\n        \\\"\\\"\\\"\\n        for word in words:\\n            self.insert(word)\\n\\n    def insert(self, word: str) -> None:\\n        \\\"\\\"\\\"\\n        Inserts a word into the Trie\\n        :param word: word to be inserted\\n        :return: None\\n        \\\"\\\"\\\"\\n        curr = self\\n        for char in word:\\n            if char not in curr.nodes:\\n                curr.nodes[char] = TrieNode()\\n            curr = curr.nodes[char]\\n        curr.is_leaf = True\\n\\n    def find(self, word: str) -> bool:\\n        \\\"\\\"\\\"\\n        Tries to find word in a Trie\\n        :param word: word to look for\\n        :return: Returns True if word is found, False otherwise\\n        \\\"\\\"\\\"\\n        curr = self\\n        for char in word:\\n            if char not in curr.nodes:\\n                return False\\n            curr = curr.nodes[char]\\n        return curr.is_leaf\\n\\n    def delete(self, word: str) -> None:\\n        \\\"\\\"\\\"\\n        Deletes a word in a Trie\\n        :param word: word to delete\\n        :return: None\\n        \\\"\\\"\\\"\\n\\n        def _delete(curr: TrieNode, word: str, index: int) -> bool:\\n            if index == len(word):\\n                # If word does not exist\\n                if not curr.is_leaf:\\n                    return False\\n                curr.is_leaf = False\\n                return len(curr.nodes) == 0\\n            char = word[index]\\n            char_node = curr.nodes.get(char)\\n            # If char not in current trie node\\n            if not char_node:\\n                return False\\n            # Flag to check if node can be deleted\\n            delete_curr = _delete(char_node, word, index + 1)\\n            if delete_curr:\\n                del curr.nodes[char]\\n                return len(curr.nodes) == 0\\n            return delete_curr\\n\\n        _delete(self, word, 0)\\n\\n\\ndef print_words(node: TrieNode, word: str) -> None:\\n    \\\"\\\"\\\"\\n    Prints all the words in a Trie\\n    :param node: root node of Trie\\n    :param word: Word variable should be empty at start\\n    :return: None\\n    \\\"\\\"\\\"\\n    if node.is_leaf:\\n        print(word, end=\\\" \\\")\\n\\n    for key, value in node.nodes.items():\\n        print_words(value, word + key)\\n\\n\\ndef test_trie() -> bool:\\n    words = \\\"banana bananas bandana band apple all beast\\\".split()\\n    root = TrieNode()\\n    root.insert_many(words)\\n    # print_words(root, \\\"\\\")\\n    assert all(root.find(word) for word in words)\\n    assert root.find(\\\"banana\\\")\\n    assert not root.find(\\\"bandanas\\\")\\n    assert not root.find(\\\"apps\\\")\\n    assert root.find(\\\"apple\\\")\\n    assert root.find(\\\"all\\\")\\n    root.delete(\\\"all\\\")\\n    assert not root.find(\\\"all\\\")\\n    root.delete(\\\"banana\\\")\\n    assert not root.find(\\\"banana\\\")\\n    assert root.find(\\\"bananas\\\")\\n    return True\\n\\n\\ndef print_results(msg: str, passes: bool) -> None:\\n    print(str(msg), \\\"works!\\\" if passes else \\\"doesn't work :(\\\")\\n\\n\\ndef pytests() -> None:\\n    assert test_trie()\\n\\n\\ndef main() -> None:\\n    \\\"\\\"\\\"\\n    >>> pytests()\\n    \\\"\\\"\\\"\\n    print_results(\\\"Testing trie functionality\\\", test_trie())\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"",
    "arithmetic": "\"\\\"\\\"\\\"\\nArithmetic mean\\nReference: https://en.wikipedia.org/wiki/Arithmetic_mean\\n\\nArithmetic series\\nReference: https://en.wikipedia.org/wiki/Arithmetic_series\\n(The URL above will redirect you to arithmetic progression)\\n\\\"\\\"\\\"\\n\\n\\ndef is_arithmetic_series(series: list) -> bool:\\n    \\\"\\\"\\\"\\n    checking whether the input series is arithmetic series or not\\n    >>> is_arithmetic_series([2, 4, 6])\\n    True\\n    >>> is_arithmetic_series([3, 6, 12, 24])\\n    False\\n    >>> is_arithmetic_series([1, 2, 3])\\n    True\\n    >>> is_arithmetic_series(4)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input series is not valid, valid series - [2, 4, 6]\\n    >>> is_arithmetic_series([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input list must be a non empty list\\n    \\\"\\\"\\\"\\n    if not isinstance(series, list):\\n        raise ValueError(\\\"Input series is not valid, valid series - [2, 4, 6]\\\")\\n    if len(series) == 0:\\n        raise ValueError(\\\"Input list must be a non empty list\\\")\\n    if len(series) == 1:\\n        return True\\n    common_diff = series[1] - series[0]\\n    for index in range(len(series) - 1):\\n        if series[index + 1] - series[index] != common_diff:\\n            return False\\n    return True\\n\\n\\ndef arithmetic_mean(series: list) -> float:\\n    \\\"\\\"\\\"\\n    return the arithmetic mean of series\\n\\n    >>> arithmetic_mean([2, 4, 6])\\n    4.0\\n    >>> arithmetic_mean([3, 6, 9, 12])\\n    7.5\\n    >>> arithmetic_mean(4)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input series is not valid, valid series - [2, 4, 6]\\n    >>> arithmetic_mean([4, 8, 1])\\n    4.333333333333333\\n    >>> arithmetic_mean([1, 2, 3])\\n    2.0\\n    >>> arithmetic_mean([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input list must be a non empty list\\n\\n    \\\"\\\"\\\"\\n    if not isinstance(series, list):\\n        raise ValueError(\\\"Input series is not valid, valid series - [2, 4, 6]\\\")\\n    if len(series) == 0:\\n        raise ValueError(\\\"Input list must be a non empty list\\\")\\n    answer = 0\\n    for val in series:\\n        answer += val\\n    return answer / len(series)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "geometric": "\"\\\"\\\"\\\"\\nGeometric Mean\\nReference :  https://en.wikipedia.org/wiki/Geometric_mean\\n\\nGeometric series\\nReference: https://en.wikipedia.org/wiki/Geometric_series\\n\\\"\\\"\\\"\\n\\n\\ndef is_geometric_series(series: list) -> bool:\\n    \\\"\\\"\\\"\\n    checking whether the input series is geometric series or not\\n    >>> is_geometric_series([2, 4, 8])\\n    True\\n    >>> is_geometric_series([3, 6, 12, 24])\\n    True\\n    >>> is_geometric_series([1, 2, 3])\\n    False\\n    >>> is_geometric_series([0, 0, 3])\\n    False\\n    >>> is_geometric_series([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input list must be a non empty list\\n    >>> is_geometric_series(4)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input series is not valid, valid series - [2, 4, 8]\\n    \\\"\\\"\\\"\\n    if not isinstance(series, list):\\n        raise ValueError(\\\"Input series is not valid, valid series - [2, 4, 8]\\\")\\n    if len(series) == 0:\\n        raise ValueError(\\\"Input list must be a non empty list\\\")\\n    if len(series) == 1:\\n        return True\\n    try:\\n        common_ratio = series[1] / series[0]\\n        for index in range(len(series) - 1):\\n            if series[index + 1] / series[index] != common_ratio:\\n                return False\\n    except ZeroDivisionError:\\n        return False\\n    return True\\n\\n\\ndef geometric_mean(series: list) -> float:\\n    \\\"\\\"\\\"\\n    return the geometric mean of series\\n\\n    >>> geometric_mean([2, 4, 8])\\n    3.9999999999999996\\n    >>> geometric_mean([3, 6, 12, 24])\\n    8.48528137423857\\n    >>> geometric_mean([4, 8, 16])\\n    7.999999999999999\\n    >>> geometric_mean(4)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input series is not valid, valid series - [2, 4, 8]\\n    >>> geometric_mean([1, 2, 3])\\n    1.8171205928321397\\n    >>> geometric_mean([0, 2, 3])\\n    0.0\\n    >>> geometric_mean([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input list must be a non empty list\\n\\n    \\\"\\\"\\\"\\n    if not isinstance(series, list):\\n        raise ValueError(\\\"Input series is not valid, valid series - [2, 4, 8]\\\")\\n    if len(series) == 0:\\n        raise ValueError(\\\"Input list must be a non empty list\\\")\\n    answer = 1\\n    for value in series:\\n        answer *= value\\n    return pow(answer, 1 / len(series))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "geometric series": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the Geometric Series algorithm\\nhttps://en.wikipedia.org/wiki/Geometric_series\\nRun the doctests with the following command:\\npython3 -m doctest -v geometric_series.py\\nor\\npython -m doctest -v geometric_series.py\\nFor manual testing run:\\npython3 geometric_series.py\\n\\\"\\\"\\\"\\n\\n\\nfrom __future__ import annotations\\n\\n\\ndef geometric_series(\\n    nth_term: float | int,\\n    start_term_a: float | int,\\n    common_ratio_r: float | int,\\n) -> list[float | int]:\\n    \\\"\\\"\\\"\\n    Pure Python implementation of Geometric Series algorithm\\n\\n    :param nth_term: The last term (nth term of Geometric Series)\\n    :param start_term_a : The first term of Geometric Series\\n    :param common_ratio_r : The common ratio between all the terms\\n    :return: The Geometric Series starting from first term a and multiple of common\\n        ration with first term with increase in power till last term (nth term)\\n    Examples:\\n    >>> geometric_series(4, 2, 2)\\n    [2, 4.0, 8.0, 16.0]\\n    >>> geometric_series(4.0, 2.0, 2.0)\\n    [2.0, 4.0, 8.0, 16.0]\\n    >>> geometric_series(4.1, 2.1, 2.1)\\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\\n    >>> geometric_series(4, 2, -2)\\n    [2, -4.0, 8.0, -16.0]\\n    >>> geometric_series(4, -2, 2)\\n    [-2, -4.0, -8.0, -16.0]\\n    >>> geometric_series(-4, 2, 2)\\n    []\\n    >>> geometric_series(0, 100, 500)\\n    []\\n    >>> geometric_series(1, 1, 1)\\n    [1]\\n    >>> geometric_series(0, 0, 0)\\n    []\\n    \\\"\\\"\\\"\\n    if not all((nth_term, start_term_a, common_ratio_r)):\\n        return []\\n    series: list[float | int] = []\\n    power = 1\\n    multiple = common_ratio_r\\n    for _ in range(int(nth_term)):\\n        if series == []:\\n            series.append(start_term_a)\\n        else:\\n            power += 1\\n            series.append(float(start_term_a * multiple))\\n            multiple = pow(float(common_ratio_r), power)\\n    return series\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    nth_term = float(input(\\\"Enter the last number (n term) of the Geometric Series\\\"))\\n    start_term_a = float(input(\\\"Enter the starting term (a) of the Geometric Series\\\"))\\n    common_ratio_r = float(\\n        input(\\\"Enter the common ratio between two terms (r) of the Geometric Series\\\")\\n    )\\n    print(\\\"Formula of Geometric Series => a + ar + ar^2 ... +ar^n\\\")\\n    print(geometric_series(nth_term, start_term_a, common_ratio_r))\\n\"",
    "harmonic": "\"\\\"\\\"\\\"\\nHarmonic mean\\nReference: https://en.wikipedia.org/wiki/Harmonic_mean\\n\\nHarmonic series\\nReference: https://en.wikipedia.org/wiki/Harmonic_series(mathematics)\\n\\\"\\\"\\\"\\n\\n\\ndef is_harmonic_series(series: list) -> bool:\\n    \\\"\\\"\\\"\\n    checking whether the input series is arithmetic series or not\\n    >>> is_harmonic_series([ 1, 2/3, 1/2, 2/5, 1/3])\\n    True\\n    >>> is_harmonic_series([ 1, 2/3, 2/5, 1/3])\\n    False\\n    >>> is_harmonic_series([1, 2, 3])\\n    False\\n    >>> is_harmonic_series([1/2, 1/3, 1/4])\\n    True\\n    >>> is_harmonic_series([2/5, 2/10, 2/15, 2/20, 2/25])\\n    True\\n    >>> is_harmonic_series(4)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input series is not valid, valid series - [1, 2/3, 2]\\n    >>> is_harmonic_series([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input list must be a non empty list\\n    >>> is_harmonic_series([0])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input series cannot have 0 as an element\\n    >>> is_harmonic_series([1,2,0,6])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input series cannot have 0 as an element\\n    \\\"\\\"\\\"\\n    if not isinstance(series, list):\\n        raise ValueError(\\\"Input series is not valid, valid series - [1, 2/3, 2]\\\")\\n    if len(series) == 0:\\n        raise ValueError(\\\"Input list must be a non empty list\\\")\\n    if len(series) == 1 and series[0] != 0:\\n        return True\\n    rec_series = []\\n    series_len = len(series)\\n    for i in range(0, series_len):\\n        if series[i] == 0:\\n            raise ValueError(\\\"Input series cannot have 0 as an element\\\")\\n        rec_series.append(1 / series[i])\\n    common_diff = rec_series[1] - rec_series[0]\\n    for index in range(2, series_len):\\n        if rec_series[index] - rec_series[index - 1] != common_diff:\\n            return False\\n    return True\\n\\n\\ndef harmonic_mean(series: list) -> float:\\n    \\\"\\\"\\\"\\n    return the harmonic mean of series\\n\\n    >>> harmonic_mean([1, 4, 4])\\n    2.0\\n    >>> harmonic_mean([3, 6, 9, 12])\\n    5.759999999999999\\n    >>> harmonic_mean(4)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input series is not valid, valid series - [2, 4, 6]\\n    >>> harmonic_mean([1, 2, 3])\\n    1.6363636363636365\\n    >>> harmonic_mean([])\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Input list must be a non empty list\\n\\n    \\\"\\\"\\\"\\n    if not isinstance(series, list):\\n        raise ValueError(\\\"Input series is not valid, valid series - [2, 4, 6]\\\")\\n    if len(series) == 0:\\n        raise ValueError(\\\"Input list must be a non empty list\\\")\\n    answer = 0\\n    for val in series:\\n        answer += 1 / val\\n    return len(series) / answer\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\"",
    "harmonic series": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the Harmonic Series algorithm\\nhttps://en.wikipedia.org/wiki/Harmonic_series_(mathematics)\\n\\nFor doctests run following command:\\npython -m doctest -v harmonic_series.py\\nor\\npython3 -m doctest -v harmonic_series.py\\n\\nFor manual testing run:\\npython3 harmonic_series.py\\n\\\"\\\"\\\"\\n\\n\\ndef harmonic_series(n_term: str) -> list:\\n    \\\"\\\"\\\"Pure Python implementation of Harmonic Series algorithm\\n\\n    :param n_term: The last (nth) term of Harmonic Series\\n    :return: The Harmonic Series starting from 1 to last (nth) term\\n\\n    Examples:\\n    >>> harmonic_series(5)\\n    ['1', '1/2', '1/3', '1/4', '1/5']\\n    >>> harmonic_series(5.0)\\n    ['1', '1/2', '1/3', '1/4', '1/5']\\n    >>> harmonic_series(5.1)\\n    ['1', '1/2', '1/3', '1/4', '1/5']\\n    >>> harmonic_series(-5)\\n    []\\n    >>> harmonic_series(0)\\n    []\\n    >>> harmonic_series(1)\\n    ['1']\\n    \\\"\\\"\\\"\\n    if n_term == \\\"\\\":\\n        return []\\n    series: list = []\\n    for temp in range(int(n_term)):\\n        series.append(f\\\"1/{temp + 1}\\\" if series else \\\"1\\\")\\n    return series\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    nth_term = input(\\\"Enter the last number (nth term) of the Harmonic Series\\\")\\n    print(\\\"Formula of Harmonic Series => 1+1/2+1/3 ..... 1/n\\\")\\n    print(harmonic_series(nth_term))\\n\"",
    "hexagonal numbers": "\"\\\"\\\"\\\"\\r\\nA hexagonal number sequence is a sequence of figurate numbers\\r\\nwhere the nth hexagonal number hₙ is the number of distinct dots\\r\\nin a pattern of dots consisting of the outlines of regular\\r\\nhexagons with sides up to n dots, when the hexagons are overlaid\\r\\nso that they share one vertex.\\r\\n\\r\\n    Calculates the hexagonal numbers sequence with a formula\\r\\n        hₙ = n(2n-1)\\r\\n        where:\\r\\n        hₙ --> is nth element of the sequence\\r\\n        n --> is the number of element in the sequence\\r\\n        reference-->\\\"Hexagonal number\\\" Wikipedia\\r\\n        <https://en.wikipedia.org/wiki/Hexagonal_number>\\r\\n\\\"\\\"\\\"\\r\\n\\r\\n\\r\\ndef hexagonal_numbers(length: int) -> list[int]:\\r\\n    \\\"\\\"\\\"\\r\\n    :param len: max number of elements\\r\\n    :type len: int\\r\\n    :return: Hexagonal numbers as a list\\r\\n\\r\\n    Tests:\\r\\n    >>> hexagonal_numbers(10)\\r\\n    [0, 1, 6, 15, 28, 45, 66, 91, 120, 153]\\r\\n    >>> hexagonal_numbers(5)\\r\\n    [0, 1, 6, 15, 28]\\r\\n    >>> hexagonal_numbers(0)\\r\\n    Traceback (most recent call last):\\r\\n      ...\\r\\n    ValueError: Length must be a positive integer.\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    if length <= 0 or not isinstance(length, int):\\r\\n        raise ValueError(\\\"Length must be a positive integer.\\\")\\r\\n    return [n * (2 * n - 1) for n in range(length)]\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n    print(hexagonal_numbers(length=5))\\r\\n    print(hexagonal_numbers(length=10))\\r\\n\"",
    "p series": "\"\\\"\\\"\\\"\\nThis is a pure Python implementation of the P-Series algorithm\\nhttps://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#P-series\\nFor doctests run following command:\\npython -m doctest -v p_series.py\\nor\\npython3 -m doctest -v p_series.py\\nFor manual testing run:\\npython3 p_series.py\\n\\\"\\\"\\\"\\n\\n\\nfrom __future__ import annotations\\n\\n\\ndef p_series(nth_term: int | float | str, power: int | float | str) -> list[str]:\\n    \\\"\\\"\\\"\\n    Pure Python implementation of P-Series algorithm\\n    :return: The P-Series starting from 1 to last (nth) term\\n    Examples:\\n    >>> p_series(5, 2)\\n    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\\n    >>> p_series(-5, 2)\\n    []\\n    >>> p_series(5, -2)\\n    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\\n    >>> p_series(\\\"\\\", 1000)\\n    ['']\\n    >>> p_series(0, 0)\\n    []\\n    >>> p_series(1, 1)\\n    ['1']\\n    \\\"\\\"\\\"\\n    if nth_term == \\\"\\\":\\n        return [\\\"\\\"]\\n    nth_term = int(nth_term)\\n    power = int(power)\\n    series: list[str] = []\\n    for temp in range(int(nth_term)):\\n        series.append(f\\\"1 / {pow(temp + 1, int(power))}\\\" if series else \\\"1\\\")\\n    return series\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n\\n    doctest.testmod()\\n\\n    nth_term = int(input(\\\"Enter the last number (nth term) of the P-Series\\\"))\\n    power = int(input(\\\"Enter the power for  P-Series\\\"))\\n    print(\\\"Formula of P-Series => 1+1/2^p+1/3^p ..... 1/n^p\\\")\\n    print(p_series(nth_term, power))\\n\""
  }
}
